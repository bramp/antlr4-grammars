// Code generated from clu.g4 by ANTLR 4.9.3. DO NOT EDIT.

package clu // clu
import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 95, 731,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4,
	50, 9, 50, 3, 2, 7, 2, 102, 10, 2, 12, 2, 14, 2, 105, 11, 2, 3, 2, 3, 2,
	3, 2, 5, 2, 110, 10, 2, 3, 3, 3, 3, 3, 3, 3, 3, 5, 3, 116, 10, 3, 3, 3,
	3, 3, 5, 3, 120, 10, 3, 3, 3, 5, 3, 123, 10, 3, 3, 3, 5, 3, 126, 10, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 4, 3, 4, 3, 4, 5, 4, 136, 10, 4, 3, 4,
	3, 4, 5, 4, 140, 10, 4, 3, 4, 5, 4, 143, 10, 4, 3, 4, 5, 4, 146, 10, 4,
	3, 4, 3, 4, 3, 4, 3, 4, 3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 156, 10, 5, 3, 5,
	3, 5, 3, 5, 5, 5, 161, 10, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 6, 3, 6, 3, 6,
	7, 6, 170, 10, 6, 12, 6, 14, 6, 173, 11, 6, 3, 7, 3, 7, 3, 7, 3, 7, 5,
	7, 179, 10, 7, 3, 8, 3, 8, 5, 8, 183, 10, 8, 3, 8, 3, 8, 3, 9, 3, 9, 3,
	9, 7, 9, 190, 10, 9, 12, 9, 14, 9, 193, 11, 9, 3, 10, 3, 10, 3, 10, 3,
	10, 3, 11, 3, 11, 3, 11, 3, 11, 3, 11, 3, 12, 3, 12, 3, 12, 3, 12, 3, 12,
	3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 7, 13, 214, 10, 13, 12, 13, 14, 13,
	217, 11, 13, 3, 13, 3, 13, 3, 14, 3, 14, 5, 14, 223, 10, 14, 3, 15, 3,
	15, 3, 15, 7, 15, 228, 10, 15, 12, 15, 14, 15, 231, 11, 15, 3, 16, 3, 16,
	3, 16, 3, 16, 7, 16, 237, 10, 16, 12, 16, 14, 16, 240, 11, 16, 3, 17, 3,
	17, 3, 17, 3, 17, 3, 17, 5, 17, 247, 10, 17, 3, 18, 3, 18, 3, 18, 3, 18,
	3, 18, 7, 18, 254, 10, 18, 12, 18, 14, 18, 257, 11, 18, 7, 18, 259, 10,
	18, 12, 18, 14, 18, 262, 11, 18, 3, 18, 5, 18, 265, 10, 18, 3, 19, 3, 19,
	3, 19, 7, 19, 270, 10, 19, 12, 19, 14, 19, 273, 11, 19, 3, 20, 3, 20, 3,
	20, 3, 20, 3, 21, 3, 21, 3, 21, 7, 21, 282, 10, 21, 12, 21, 14, 21, 285,
	11, 21, 3, 22, 3, 22, 3, 22, 5, 22, 290, 10, 22, 3, 22, 3, 22, 3, 23, 3,
	23, 3, 23, 7, 23, 297, 10, 23, 12, 23, 14, 23, 300, 11, 23, 3, 24, 3, 24,
	5, 24, 304, 10, 24, 3, 25, 7, 25, 307, 10, 25, 12, 25, 14, 25, 310, 11,
	25, 3, 25, 7, 25, 313, 10, 25, 12, 25, 14, 25, 316, 11, 25, 3, 25, 7, 25,
	319, 10, 25, 12, 25, 14, 25, 322, 11, 25, 3, 26, 7, 26, 325, 10, 26, 12,
	26, 14, 26, 328, 11, 26, 3, 26, 3, 26, 3, 26, 3, 26, 7, 26, 334, 10, 26,
	12, 26, 14, 26, 337, 11, 26, 3, 26, 7, 26, 340, 10, 26, 12, 26, 14, 26,
	343, 11, 26, 3, 26, 3, 26, 7, 26, 347, 10, 26, 12, 26, 14, 26, 350, 11,
	26, 3, 27, 3, 27, 5, 27, 354, 10, 27, 3, 28, 3, 28, 3, 28, 3, 28, 5, 28,
	360, 10, 28, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3,
	29, 3, 29, 3, 29, 3, 29, 5, 29, 374, 10, 29, 3, 30, 3, 30, 3, 30, 3, 30,
	3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 5, 30, 388, 10,
	30, 3, 30, 3, 30, 5, 30, 392, 10, 30, 3, 30, 3, 30, 5, 30, 396, 10, 30,
	3, 30, 5, 30, 399, 10, 30, 3, 30, 5, 30, 402, 10, 30, 3, 30, 3, 30, 5,
	30, 406, 10, 30, 5, 30, 408, 10, 30, 3, 31, 3, 31, 3, 31, 7, 31, 413, 10,
	31, 12, 31, 14, 31, 416, 11, 31, 3, 32, 3, 32, 3, 32, 3, 32, 3, 33, 3,
	33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33,
	3, 33, 3, 33, 3, 33, 3, 33, 5, 33, 438, 10, 33, 3, 33, 3, 33, 3, 33, 3,
	33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33,
	3, 33, 3, 33, 5, 33, 456, 10, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3,
	33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 7, 33,
	473, 10, 33, 12, 33, 14, 33, 476, 11, 33, 3, 33, 3, 33, 5, 33, 480, 10,
	33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 7, 33, 487, 10, 33, 12, 33, 14,
	33, 490, 11, 33, 3, 33, 3, 33, 3, 33, 5, 33, 495, 10, 33, 3, 33, 3, 33,
	3, 33, 3, 33, 5, 33, 501, 10, 33, 3, 33, 3, 33, 3, 33, 5, 33, 506, 10,
	33, 3, 33, 3, 33, 3, 33, 5, 33, 511, 10, 33, 3, 33, 3, 33, 3, 33, 3, 33,
	3, 33, 5, 33, 518, 10, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 7, 33, 525,
	10, 33, 12, 33, 14, 33, 528, 11, 33, 3, 33, 5, 33, 531, 10, 33, 3, 33,
	5, 33, 534, 10, 33, 7, 33, 536, 10, 33, 12, 33, 14, 33, 539, 11, 33, 3,
	34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 5, 34, 549, 10, 34,
	3, 34, 3, 34, 3, 34, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 5, 35, 560,
	10, 35, 5, 35, 562, 10, 35, 3, 35, 3, 35, 3, 35, 3, 36, 3, 36, 3, 36, 3,
	36, 3, 36, 3, 36, 3, 36, 5, 36, 574, 10, 36, 3, 36, 3, 36, 3, 36, 3, 37,
	7, 37, 580, 10, 37, 12, 37, 14, 37, 583, 11, 37, 3, 37, 7, 37, 586, 10,
	37, 12, 37, 14, 37, 589, 11, 37, 3, 38, 3, 38, 3, 38, 7, 38, 594, 10, 38,
	12, 38, 14, 38, 597, 11, 38, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39,
	3, 39, 3, 39, 5, 39, 607, 10, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3,
	39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39,
	3, 39, 3, 39, 7, 39, 627, 10, 39, 12, 39, 14, 39, 630, 11, 39, 3, 40, 3,
	40, 3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 5, 40, 641, 10, 40,
	3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 5, 40, 650, 10, 40, 3,
	40, 3, 40, 3, 40, 3, 40, 3, 40, 5, 40, 657, 10, 40, 5, 40, 659, 10, 40,
	3, 40, 3, 40, 5, 40, 663, 10, 40, 3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 5,
	40, 670, 10, 40, 3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 5, 40, 678,
	10, 40, 3, 40, 5, 40, 681, 10, 40, 7, 40, 683, 10, 40, 12, 40, 14, 40,
	686, 11, 40, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 42, 3, 42, 3, 42, 7,
	42, 696, 10, 42, 12, 42, 14, 42, 699, 11, 42, 3, 43, 3, 43, 3, 43, 3, 43,
	3, 44, 3, 44, 3, 44, 7, 44, 708, 10, 44, 12, 44, 14, 44, 711, 11, 44, 3,
	45, 3, 45, 3, 46, 3, 46, 3, 46, 7, 46, 718, 10, 46, 12, 46, 14, 46, 721,
	11, 46, 3, 47, 3, 47, 3, 48, 3, 48, 3, 49, 3, 49, 3, 50, 3, 50, 3, 50,
	2, 5, 64, 76, 78, 51, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28,
	30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64,
	66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 2,
	12, 3, 2, 36, 39, 3, 2, 40, 41, 3, 2, 52, 53, 3, 2, 63, 64, 4, 2, 62, 62,
	66, 67, 4, 2, 64, 64, 68, 69, 4, 2, 3, 3, 70, 78, 3, 2, 79, 80, 3, 2, 81,
	82, 3, 2, 88, 89, 2, 808, 2, 103, 3, 2, 2, 2, 4, 111, 3, 2, 2, 2, 6, 131,
	3, 2, 2, 2, 8, 151, 3, 2, 2, 2, 10, 166, 3, 2, 2, 2, 12, 174, 3, 2, 2,
	2, 14, 180, 3, 2, 2, 2, 16, 186, 3, 2, 2, 2, 18, 194, 3, 2, 2, 2, 20, 198,
	3, 2, 2, 2, 22, 203, 3, 2, 2, 2, 24, 208, 3, 2, 2, 2, 26, 220, 3, 2, 2,
	2, 28, 224, 3, 2, 2, 2, 30, 232, 3, 2, 2, 2, 32, 241, 3, 2, 2, 2, 34, 264,
	3, 2, 2, 2, 36, 266, 3, 2, 2, 2, 38, 274, 3, 2, 2, 2, 40, 278, 3, 2, 2,
	2, 42, 286, 3, 2, 2, 2, 44, 293, 3, 2, 2, 2, 46, 303, 3, 2, 2, 2, 48, 308,
	3, 2, 2, 2, 50, 326, 3, 2, 2, 2, 52, 353, 3, 2, 2, 2, 54, 355, 3, 2, 2,
	2, 56, 361, 3, 2, 2, 2, 58, 407, 3, 2, 2, 2, 60, 409, 3, 2, 2, 2, 62, 417,
	3, 2, 2, 2, 64, 517, 3, 2, 2, 2, 66, 540, 3, 2, 2, 2, 68, 553, 3, 2, 2,
	2, 70, 566, 3, 2, 2, 2, 72, 581, 3, 2, 2, 2, 74, 590, 3, 2, 2, 2, 76, 606,
	3, 2, 2, 2, 78, 669, 3, 2, 2, 2, 80, 687, 3, 2, 2, 2, 82, 692, 3, 2, 2,
	2, 84, 700, 3, 2, 2, 2, 86, 704, 3, 2, 2, 2, 88, 712, 3, 2, 2, 2, 90, 714,
	3, 2, 2, 2, 92, 722, 3, 2, 2, 2, 94, 724, 3, 2, 2, 2, 96, 726, 3, 2, 2,
	2, 98, 728, 3, 2, 2, 2, 100, 102, 5, 54, 28, 2, 101, 100, 3, 2, 2, 2, 102,
	105, 3, 2, 2, 2, 103, 101, 3, 2, 2, 2, 103, 104, 3, 2, 2, 2, 104, 109,
	3, 2, 2, 2, 105, 103, 3, 2, 2, 2, 106, 110, 5, 4, 3, 2, 107, 110, 5, 6,
	4, 2, 108, 110, 5, 8, 5, 2, 109, 106, 3, 2, 2, 2, 109, 107, 3, 2, 2, 2,
	109, 108, 3, 2, 2, 2, 110, 3, 3, 2, 2, 2, 111, 112, 5, 88, 45, 2, 112,
	113, 7, 3, 2, 2, 113, 115, 7, 4, 2, 2, 114, 116, 5, 10, 6, 2, 115, 114,
	3, 2, 2, 2, 115, 116, 3, 2, 2, 2, 116, 117, 3, 2, 2, 2, 117, 119, 5, 14,
	8, 2, 118, 120, 5, 20, 11, 2, 119, 118, 3, 2, 2, 2, 119, 120, 3, 2, 2,
	2, 120, 122, 3, 2, 2, 2, 121, 123, 5, 24, 13, 2, 122, 121, 3, 2, 2, 2,
	122, 123, 3, 2, 2, 2, 123, 125, 3, 2, 2, 2, 124, 126, 5, 30, 16, 2, 125,
	124, 3, 2, 2, 2, 125, 126, 3, 2, 2, 2, 126, 127, 3, 2, 2, 2, 127, 128,
	5, 48, 25, 2, 128, 129, 7, 5, 2, 2, 129, 130, 5, 88, 45, 2, 130, 5, 3,
	2, 2, 2, 131, 132, 5, 88, 45, 2, 132, 133, 7, 3, 2, 2, 133, 135, 7, 6,
	2, 2, 134, 136, 5, 10, 6, 2, 135, 134, 3, 2, 2, 2, 135, 136, 3, 2, 2, 2,
	136, 137, 3, 2, 2, 2, 137, 139, 5, 14, 8, 2, 138, 140, 5, 22, 12, 2, 139,
	138, 3, 2, 2, 2, 139, 140, 3, 2, 2, 2, 140, 142, 3, 2, 2, 2, 141, 143,
	5, 24, 13, 2, 142, 141, 3, 2, 2, 2, 142, 143, 3, 2, 2, 2, 143, 145, 3,
	2, 2, 2, 144, 146, 5, 30, 16, 2, 145, 144, 3, 2, 2, 2, 145, 146, 3, 2,
	2, 2, 146, 147, 3, 2, 2, 2, 147, 148, 5, 48, 25, 2, 148, 149, 7, 5, 2,
	2, 149, 150, 5, 88, 45, 2, 150, 7, 3, 2, 2, 2, 151, 152, 5, 88, 45, 2,
	152, 153, 7, 3, 2, 2, 153, 155, 7, 7, 2, 2, 154, 156, 5, 10, 6, 2, 155,
	154, 3, 2, 2, 2, 155, 156, 3, 2, 2, 2, 156, 157, 3, 2, 2, 2, 157, 158,
	7, 8, 2, 2, 158, 160, 5, 86, 44, 2, 159, 161, 5, 30, 16, 2, 160, 159, 3,
	2, 2, 2, 160, 161, 3, 2, 2, 2, 161, 162, 3, 2, 2, 2, 162, 163, 5, 50, 26,
	2, 163, 164, 7, 5, 2, 2, 164, 165, 5, 88, 45, 2, 165, 9, 3, 2, 2, 2, 166,
	171, 5, 12, 7, 2, 167, 168, 7, 9, 2, 2, 168, 170, 5, 12, 7, 2, 169, 167,
	3, 2, 2, 2, 170, 173, 3, 2, 2, 2, 171, 169, 3, 2, 2, 2, 171, 172, 3, 2,
	2, 2, 172, 11, 3, 2, 2, 2, 173, 171, 3, 2, 2, 2, 174, 175, 5, 86, 44, 2,
	175, 178, 7, 10, 2, 2, 176, 179, 7, 11, 2, 2, 177, 179, 5, 58, 30, 2, 178,
	176, 3, 2, 2, 2, 178, 177, 3, 2, 2, 2, 179, 13, 3, 2, 2, 2, 180, 182, 7,
	12, 2, 2, 181, 183, 5, 16, 9, 2, 182, 181, 3, 2, 2, 2, 182, 183, 3, 2,
	2, 2, 183, 184, 3, 2, 2, 2, 184, 185, 7, 13, 2, 2, 185, 15, 3, 2, 2, 2,
	186, 191, 5, 18, 10, 2, 187, 188, 7, 9, 2, 2, 188, 190, 5, 18, 10, 2, 189,
	187, 3, 2, 2, 2, 190, 193, 3, 2, 2, 2, 191, 189, 3, 2, 2, 2, 191, 192,
	3, 2, 2, 2, 192, 17, 3, 2, 2, 2, 193, 191, 3, 2, 2, 2, 194, 195, 5, 86,
	44, 2, 195, 196, 7, 10, 2, 2, 196, 197, 5, 58, 30, 2, 197, 19, 3, 2, 2,
	2, 198, 199, 7, 14, 2, 2, 199, 200, 7, 12, 2, 2, 200, 201, 5, 28, 15, 2,
	201, 202, 7, 13, 2, 2, 202, 21, 3, 2, 2, 2, 203, 204, 7, 15, 2, 2, 204,
	205, 7, 12, 2, 2, 205, 206, 5, 28, 15, 2, 206, 207, 7, 13, 2, 2, 207, 23,
	3, 2, 2, 2, 208, 209, 7, 16, 2, 2, 209, 210, 7, 12, 2, 2, 210, 215, 5,
	26, 14, 2, 211, 212, 7, 9, 2, 2, 212, 214, 5, 26, 14, 2, 213, 211, 3, 2,
	2, 2, 214, 217, 3, 2, 2, 2, 215, 213, 3, 2, 2, 2, 215, 216, 3, 2, 2, 2,
	216, 218, 3, 2, 2, 2, 217, 215, 3, 2, 2, 2, 218, 219, 7, 13, 2, 2, 219,
	25, 3, 2, 2, 2, 220, 222, 5, 92, 47, 2, 221, 223, 5, 28, 15, 2, 222, 221,
	3, 2, 2, 2, 222, 223, 3, 2, 2, 2, 223, 27, 3, 2, 2, 2, 224, 229, 5, 58,
	30, 2, 225, 226, 7, 9, 2, 2, 226, 228, 5, 58, 30, 2, 227, 225, 3, 2, 2,
	2, 228, 231, 3, 2, 2, 2, 229, 227, 3, 2, 2, 2, 229, 230, 3, 2, 2, 2, 230,
	29, 3, 2, 2, 2, 231, 229, 3, 2, 2, 2, 232, 233, 7, 17, 2, 2, 233, 238,
	5, 32, 17, 2, 234, 235, 7, 9, 2, 2, 235, 237, 5, 32, 17, 2, 236, 234, 3,
	2, 2, 2, 237, 240, 3, 2, 2, 2, 238, 236, 3, 2, 2, 2, 238, 239, 3, 2, 2,
	2, 239, 31, 3, 2, 2, 2, 240, 238, 3, 2, 2, 2, 241, 246, 5, 88, 45, 2, 242,
	243, 7, 18, 2, 2, 243, 247, 5, 36, 19, 2, 244, 245, 7, 19, 2, 2, 245, 247,
	5, 34, 18, 2, 246, 242, 3, 2, 2, 2, 246, 244, 3, 2, 2, 2, 247, 33, 3, 2,
	2, 2, 248, 259, 5, 88, 45, 2, 249, 250, 5, 88, 45, 2, 250, 251, 7, 18,
	2, 2, 251, 255, 5, 36, 19, 2, 252, 254, 5, 54, 28, 2, 253, 252, 3, 2, 2,
	2, 254, 257, 3, 2, 2, 2, 255, 253, 3, 2, 2, 2, 255, 256, 3, 2, 2, 2, 256,
	259, 3, 2, 2, 2, 257, 255, 3, 2, 2, 2, 258, 248, 3, 2, 2, 2, 258, 249,
	3, 2, 2, 2, 259, 262, 3, 2, 2, 2, 260, 258, 3, 2, 2, 2, 260, 261, 3, 2,
	2, 2, 261, 265, 3, 2, 2, 2, 262, 260, 3, 2, 2, 2, 263, 265, 5, 88, 45,
	2, 264, 260, 3, 2, 2, 2, 264, 263, 3, 2, 2, 2, 265, 35, 3, 2, 2, 2, 266,
	271, 5, 38, 20, 2, 267, 268, 7, 9, 2, 2, 268, 270, 5, 38, 20, 2, 269, 267,
	3, 2, 2, 2, 270, 273, 3, 2, 2, 2, 271, 269, 3, 2, 2, 2, 271, 272, 3, 2,
	2, 2, 272, 37, 3, 2, 2, 2, 273, 271, 3, 2, 2, 2, 274, 275, 5, 40, 21, 2,
	275, 276, 7, 10, 2, 2, 276, 277, 5, 58, 30, 2, 277, 39, 3, 2, 2, 2, 278,
	283, 5, 42, 22, 2, 279, 280, 7, 9, 2, 2, 280, 282, 5, 42, 22, 2, 281, 279,
	3, 2, 2, 2, 282, 285, 3, 2, 2, 2, 283, 281, 3, 2, 2, 2, 283, 284, 3, 2,
	2, 2, 284, 41, 3, 2, 2, 2, 285, 283, 3, 2, 2, 2, 286, 287, 5, 92, 47, 2,
	287, 289, 7, 20, 2, 2, 288, 290, 5, 44, 23, 2, 289, 288, 3, 2, 2, 2, 289,
	290, 3, 2, 2, 2, 290, 291, 3, 2, 2, 2, 291, 292, 7, 21, 2, 2, 292, 43,
	3, 2, 2, 2, 293, 298, 5, 46, 24, 2, 294, 295, 7, 9, 2, 2, 295, 297, 5,
	46, 24, 2, 296, 294, 3, 2, 2, 2, 297, 300, 3, 2, 2, 2, 298, 296, 3, 2,
	2, 2, 298, 299, 3, 2, 2, 2, 299, 45, 3, 2, 2, 2, 300, 298, 3, 2, 2, 2,
	301, 304, 5, 76, 39, 2, 302, 304, 5, 58, 30, 2, 303, 301, 3, 2, 2, 2, 303,
	302, 3, 2, 2, 2, 304, 47, 3, 2, 2, 2, 305, 307, 5, 54, 28, 2, 306, 305,
	3, 2, 2, 2, 307, 310, 3, 2, 2, 2, 308, 306, 3, 2, 2, 2, 308, 309, 3, 2,
	2, 2, 309, 314, 3, 2, 2, 2, 310, 308, 3, 2, 2, 2, 311, 313, 5, 56, 29,
	2, 312, 311, 3, 2, 2, 2, 313, 316, 3, 2, 2, 2, 314, 312, 3, 2, 2, 2, 314,
	315, 3, 2, 2, 2, 315, 320, 3, 2, 2, 2, 316, 314, 3, 2, 2, 2, 317, 319,
	5, 64, 33, 2, 318, 317, 3, 2, 2, 2, 319, 322, 3, 2, 2, 2, 320, 318, 3,
	2, 2, 2, 320, 321, 3, 2, 2, 2, 321, 49, 3, 2, 2, 2, 322, 320, 3, 2, 2,
	2, 323, 325, 5, 54, 28, 2, 324, 323, 3, 2, 2, 2, 325, 328, 3, 2, 2, 2,
	326, 324, 3, 2, 2, 2, 326, 327, 3, 2, 2, 2, 327, 329, 3, 2, 2, 2, 328,
	326, 3, 2, 2, 2, 329, 330, 7, 22, 2, 2, 330, 331, 7, 3, 2, 2, 331, 335,
	5, 58, 30, 2, 332, 334, 5, 54, 28, 2, 333, 332, 3, 2, 2, 2, 334, 337, 3,
	2, 2, 2, 335, 333, 3, 2, 2, 2, 335, 336, 3, 2, 2, 2, 336, 341, 3, 2, 2,
	2, 337, 335, 3, 2, 2, 2, 338, 340, 5, 56, 29, 2, 339, 338, 3, 2, 2, 2,
	340, 343, 3, 2, 2, 2, 341, 339, 3, 2, 2, 2, 341, 342, 3, 2, 2, 2, 342,
	344, 3, 2, 2, 2, 343, 341, 3, 2, 2, 2, 344, 348, 7, 23, 2, 2, 345, 347,
	5, 52, 27, 2, 346, 345, 3, 2, 2, 2, 347, 350, 3, 2, 2, 2, 348, 346, 3,
	2, 2, 2, 348, 349, 3, 2, 2, 2, 349, 51, 3, 2, 2, 2, 350, 348, 3, 2, 2,
	2, 351, 354, 5, 4, 3, 2, 352, 354, 5, 6, 4, 2, 353, 351, 3, 2, 2, 2, 353,
	352, 3, 2, 2, 2, 354, 53, 3, 2, 2, 2, 355, 356, 5, 88, 45, 2, 356, 359,
	7, 3, 2, 2, 357, 360, 5, 46, 24, 2, 358, 360, 5, 34, 18, 2, 359, 357, 3,
	2, 2, 2, 359, 358, 3, 2, 2, 2, 360, 55, 3, 2, 2, 2, 361, 373, 7, 24, 2,
	2, 362, 374, 5, 18, 10, 2, 363, 364, 5, 88, 45, 2, 364, 365, 7, 10, 2,
	2, 365, 366, 5, 58, 30, 2, 366, 367, 7, 25, 2, 2, 367, 368, 5, 76, 39,
	2, 368, 374, 3, 2, 2, 2, 369, 370, 5, 16, 9, 2, 370, 371, 7, 25, 2, 2,
	371, 372, 5, 80, 41, 2, 372, 374, 3, 2, 2, 2, 373, 362, 3, 2, 2, 2, 373,
	363, 3, 2, 2, 2, 373, 369, 3, 2, 2, 2, 374, 57, 3, 2, 2, 2, 375, 408, 7,
	26, 2, 2, 376, 408, 7, 27, 2, 2, 377, 408, 7, 28, 2, 2, 378, 408, 7, 29,
	2, 2, 379, 408, 7, 30, 2, 2, 380, 408, 7, 31, 2, 2, 381, 408, 7, 32, 2,
	2, 382, 408, 7, 22, 2, 2, 383, 408, 7, 33, 2, 2, 384, 408, 7, 34, 2, 2,
	385, 387, 7, 35, 2, 2, 386, 388, 5, 58, 30, 2, 387, 386, 3, 2, 2, 2, 387,
	388, 3, 2, 2, 2, 388, 408, 3, 2, 2, 2, 389, 391, 9, 2, 2, 2, 390, 392,
	5, 60, 31, 2, 391, 390, 3, 2, 2, 2, 391, 392, 3, 2, 2, 2, 392, 408, 3,
	2, 2, 2, 393, 395, 9, 3, 2, 2, 394, 396, 5, 60, 31, 2, 395, 394, 3, 2,
	2, 2, 395, 396, 3, 2, 2, 2, 396, 398, 3, 2, 2, 2, 397, 399, 5, 20, 11,
	2, 398, 397, 3, 2, 2, 2, 398, 399, 3, 2, 2, 2, 399, 401, 3, 2, 2, 2, 400,
	402, 5, 24, 13, 2, 401, 400, 3, 2, 2, 2, 401, 402, 3, 2, 2, 2, 402, 408,
	3, 2, 2, 2, 403, 405, 5, 88, 45, 2, 404, 406, 5, 44, 23, 2, 405, 404, 3,
	2, 2, 2, 405, 406, 3, 2, 2, 2, 406, 408, 3, 2, 2, 2, 407, 375, 3, 2, 2,
	2, 407, 376, 3, 2, 2, 2, 407, 377, 3, 2, 2, 2, 407, 378, 3, 2, 2, 2, 407,
	379, 3, 2, 2, 2, 407, 380, 3, 2, 2, 2, 407, 381, 3, 2, 2, 2, 407, 382,
	3, 2, 2, 2, 407, 383, 3, 2, 2, 2, 407, 384, 3, 2, 2, 2, 407, 385, 3, 2,
	2, 2, 407, 389, 3, 2, 2, 2, 407, 393, 3, 2, 2, 2, 407, 403, 3, 2, 2, 2,
	408, 59, 3, 2, 2, 2, 409, 414, 5, 62, 32, 2, 410, 411, 7, 9, 2, 2, 411,
	413, 5, 62, 32, 2, 412, 410, 3, 2, 2, 2, 413, 416, 3, 2, 2, 2, 414, 412,
	3, 2, 2, 2, 414, 415, 3, 2, 2, 2, 415, 61, 3, 2, 2, 2, 416, 414, 3, 2,
	2, 2, 417, 418, 5, 90, 46, 2, 418, 419, 7, 10, 2, 2, 419, 420, 5, 58, 30,
	2, 420, 63, 3, 2, 2, 2, 421, 422, 8, 33, 1, 2, 422, 518, 5, 18, 10, 2,
	423, 424, 5, 88, 45, 2, 424, 425, 7, 10, 2, 2, 425, 426, 5, 58, 30, 2,
	426, 427, 7, 25, 2, 2, 427, 428, 5, 76, 39, 2, 428, 518, 3, 2, 2, 2, 429,
	430, 5, 16, 9, 2, 430, 431, 7, 25, 2, 2, 431, 432, 5, 80, 41, 2, 432, 518,
	3, 2, 2, 2, 433, 434, 5, 86, 44, 2, 434, 437, 7, 25, 2, 2, 435, 438, 5,
	80, 41, 2, 436, 438, 5, 74, 38, 2, 437, 435, 3, 2, 2, 2, 437, 436, 3, 2,
	2, 2, 438, 518, 3, 2, 2, 2, 439, 440, 5, 78, 40, 2, 440, 441, 7, 42, 2,
	2, 441, 442, 5, 92, 47, 2, 442, 443, 7, 25, 2, 2, 443, 444, 5, 76, 39,
	2, 444, 518, 3, 2, 2, 2, 445, 518, 5, 80, 41, 2, 446, 447, 7, 43, 2, 2,
	447, 448, 5, 76, 39, 2, 448, 449, 7, 44, 2, 2, 449, 450, 5, 72, 37, 2,
	450, 451, 7, 5, 2, 2, 451, 518, 3, 2, 2, 2, 452, 455, 7, 45, 2, 2, 453,
	456, 5, 16, 9, 2, 454, 456, 5, 86, 44, 2, 455, 453, 3, 2, 2, 2, 455, 454,
	3, 2, 2, 2, 455, 456, 3, 2, 2, 2, 456, 457, 3, 2, 2, 2, 457, 458, 7, 19,
	2, 2, 458, 459, 5, 80, 41, 2, 459, 460, 7, 44, 2, 2, 460, 461, 5, 72, 37,
	2, 461, 462, 7, 5, 2, 2, 462, 518, 3, 2, 2, 2, 463, 464, 7, 46, 2, 2, 464,
	465, 5, 76, 39, 2, 465, 466, 7, 47, 2, 2, 466, 474, 5, 72, 37, 2, 467,
	468, 7, 48, 2, 2, 468, 469, 5, 76, 39, 2, 469, 470, 7, 47, 2, 2, 470, 471,
	5, 72, 37, 2, 471, 473, 3, 2, 2, 2, 472, 467, 3, 2, 2, 2, 473, 476, 3,
	2, 2, 2, 474, 472, 3, 2, 2, 2, 474, 475, 3, 2, 2, 2, 475, 479, 3, 2, 2,
	2, 476, 474, 3, 2, 2, 2, 477, 478, 7, 49, 2, 2, 478, 480, 5, 72, 37, 2,
	479, 477, 3, 2, 2, 2, 479, 480, 3, 2, 2, 2, 480, 481, 3, 2, 2, 2, 481,
	482, 7, 5, 2, 2, 482, 518, 3, 2, 2, 2, 483, 484, 7, 50, 2, 2, 484, 488,
	5, 76, 39, 2, 485, 487, 5, 66, 34, 2, 486, 485, 3, 2, 2, 2, 487, 490, 3,
	2, 2, 2, 488, 486, 3, 2, 2, 2, 488, 489, 3, 2, 2, 2, 489, 494, 3, 2, 2,
	2, 490, 488, 3, 2, 2, 2, 491, 492, 7, 51, 2, 2, 492, 493, 7, 10, 2, 2,
	493, 495, 5, 72, 37, 2, 494, 491, 3, 2, 2, 2, 494, 495, 3, 2, 2, 2, 495,
	496, 3, 2, 2, 2, 496, 497, 7, 5, 2, 2, 497, 518, 3, 2, 2, 2, 498, 500,
	9, 4, 2, 2, 499, 501, 5, 74, 38, 2, 500, 499, 3, 2, 2, 2, 500, 501, 3,
	2, 2, 2, 501, 518, 3, 2, 2, 2, 502, 503, 7, 54, 2, 2, 503, 505, 5, 92,
	47, 2, 504, 506, 5, 74, 38, 2, 505, 504, 3, 2, 2, 2, 505, 506, 3, 2, 2,
	2, 506, 518, 3, 2, 2, 2, 507, 508, 7, 55, 2, 2, 508, 510, 5, 92, 47, 2,
	509, 511, 5, 74, 38, 2, 510, 509, 3, 2, 2, 2, 510, 511, 3, 2, 2, 2, 511,
	518, 3, 2, 2, 2, 512, 518, 7, 56, 2, 2, 513, 514, 7, 57, 2, 2, 514, 515,
	5, 72, 37, 2, 515, 516, 7, 5, 2, 2, 516, 518, 3, 2, 2, 2, 517, 421, 3,
	2, 2, 2, 517, 423, 3, 2, 2, 2, 517, 429, 3, 2, 2, 2, 517, 433, 3, 2, 2,
	2, 517, 439, 3, 2, 2, 2, 517, 445, 3, 2, 2, 2, 517, 446, 3, 2, 2, 2, 517,
	452, 3, 2, 2, 2, 517, 463, 3, 2, 2, 2, 517, 483, 3, 2, 2, 2, 517, 498,
	3, 2, 2, 2, 517, 502, 3, 2, 2, 2, 517, 507, 3, 2, 2, 2, 517, 512, 3, 2,
	2, 2, 517, 513, 3, 2, 2, 2, 518, 537, 3, 2, 2, 2, 519, 533, 12, 3, 2, 2,
	520, 521, 7, 58, 2, 2, 521, 534, 5, 90, 46, 2, 522, 526, 7, 59, 2, 2, 523,
	525, 5, 68, 35, 2, 524, 523, 3, 2, 2, 2, 525, 528, 3, 2, 2, 2, 526, 524,
	3, 2, 2, 2, 526, 527, 3, 2, 2, 2, 527, 530, 3, 2, 2, 2, 528, 526, 3, 2,
	2, 2, 529, 531, 5, 70, 36, 2, 530, 529, 3, 2, 2, 2, 530, 531, 3, 2, 2,
	2, 531, 532, 3, 2, 2, 2, 532, 534, 7, 5, 2, 2, 533, 520, 3, 2, 2, 2, 533,
	522, 3, 2, 2, 2, 534, 536, 3, 2, 2, 2, 535, 519, 3, 2, 2, 2, 536, 539,
	3, 2, 2, 2, 537, 535, 3, 2, 2, 2, 537, 538, 3, 2, 2, 2, 538, 65, 3, 2,
	2, 2, 539, 537, 3, 2, 2, 2, 540, 541, 7, 60, 2, 2, 541, 548, 5, 90, 46,
	2, 542, 543, 7, 12, 2, 2, 543, 544, 5, 88, 45, 2, 544, 545, 7, 10, 2, 2,
	545, 546, 5, 58, 30, 2, 546, 547, 7, 13, 2, 2, 547, 549, 3, 2, 2, 2, 548,
	542, 3, 2, 2, 2, 548, 549, 3, 2, 2, 2, 549, 550, 3, 2, 2, 2, 550, 551,
	7, 10, 2, 2, 551, 552, 5, 72, 37, 2, 552, 67, 3, 2, 2, 2, 553, 554, 7,
	61, 2, 2, 554, 561, 5, 90, 46, 2, 555, 556, 7, 12, 2, 2, 556, 557, 7, 62,
	2, 2, 557, 562, 7, 13, 2, 2, 558, 560, 5, 16, 9, 2, 559, 558, 3, 2, 2,
	2, 559, 560, 3, 2, 2, 2, 560, 562, 3, 2, 2, 2, 561, 555, 3, 2, 2, 2, 561,
	559, 3, 2, 2, 2, 562, 563, 3, 2, 2, 2, 563, 564, 7, 10, 2, 2, 564, 565,
	5, 72, 37, 2, 565, 69, 3, 2, 2, 2, 566, 573, 7, 51, 2, 2, 567, 568, 7,
	12, 2, 2, 568, 569, 5, 88, 45, 2, 569, 570, 7, 10, 2, 2, 570, 571, 5, 58,
	30, 2, 571, 572, 7, 13, 2, 2, 572, 574, 3, 2, 2, 2, 573, 567, 3, 2, 2,
	2, 573, 574, 3, 2, 2, 2, 574, 575, 3, 2, 2, 2, 575, 576, 7, 10, 2, 2, 576,
	577, 5, 72, 37, 2, 577, 71, 3, 2, 2, 2, 578, 580, 5, 54, 28, 2, 579, 578,
	3, 2, 2, 2, 580, 583, 3, 2, 2, 2, 581, 579, 3, 2, 2, 2, 581, 582, 3, 2,
	2, 2, 582, 587, 3, 2, 2, 2, 583, 581, 3, 2, 2, 2, 584, 586, 5, 64, 33,
	2, 585, 584, 3, 2, 2, 2, 586, 589, 3, 2, 2, 2, 587, 585, 3, 2, 2, 2, 587,
	588, 3, 2, 2, 2, 588, 73, 3, 2, 2, 2, 589, 587, 3, 2, 2, 2, 590, 595, 5,
	76, 39, 2, 591, 592, 7, 9, 2, 2, 592, 594, 5, 76, 39, 2, 593, 591, 3, 2,
	2, 2, 594, 597, 3, 2, 2, 2, 595, 593, 3, 2, 2, 2, 595, 596, 3, 2, 2, 2,
	596, 75, 3, 2, 2, 2, 597, 595, 3, 2, 2, 2, 598, 599, 8, 39, 1, 2, 599,
	607, 5, 78, 40, 2, 600, 601, 7, 12, 2, 2, 601, 602, 5, 76, 39, 2, 602,
	603, 7, 13, 2, 2, 603, 607, 3, 2, 2, 2, 604, 605, 9, 5, 2, 2, 605, 607,
	5, 76, 39, 9, 606, 598, 3, 2, 2, 2, 606, 600, 3, 2, 2, 2, 606, 604, 3,
	2, 2, 2, 607, 628, 3, 2, 2, 2, 608, 609, 12, 8, 2, 2, 609, 610, 7, 65,
	2, 2, 610, 627, 5, 76, 39, 9, 611, 612, 12, 7, 2, 2, 612, 613, 9, 6, 2,
	2, 613, 627, 5, 76, 39, 8, 614, 615, 12, 6, 2, 2, 615, 616, 9, 7, 2, 2,
	616, 627, 5, 76, 39, 7, 617, 618, 12, 5, 2, 2, 618, 619, 9, 8, 2, 2, 619,
	627, 5, 76, 39, 6, 620, 621, 12, 4, 2, 2, 621, 622, 9, 9, 2, 2, 622, 627,
	5, 76, 39, 5, 623, 624, 12, 3, 2, 2, 624, 625, 9, 10, 2, 2, 625, 627, 5,
	76, 39, 4, 626, 608, 3, 2, 2, 2, 626, 611, 3, 2, 2, 2, 626, 614, 3, 2,
	2, 2, 626, 617, 3, 2, 2, 2, 626, 620, 3, 2, 2, 2, 626, 623, 3, 2, 2, 2,
	627, 630, 3, 2, 2, 2, 628, 626, 3, 2, 2, 2, 628, 629, 3, 2, 2, 2, 629,
	77, 3, 2, 2, 2, 630, 628, 3, 2, 2, 2, 631, 632, 8, 40, 1, 2, 632, 670,
	7, 83, 2, 2, 633, 670, 7, 84, 2, 2, 634, 670, 7, 85, 2, 2, 635, 670, 5,
	94, 48, 2, 636, 670, 5, 96, 49, 2, 637, 670, 5, 98, 50, 2, 638, 640, 5,
	88, 45, 2, 639, 641, 5, 44, 23, 2, 640, 639, 3, 2, 2, 2, 640, 641, 3, 2,
	2, 2, 641, 670, 3, 2, 2, 2, 642, 643, 5, 58, 30, 2, 643, 658, 7, 86, 2,
	2, 644, 659, 5, 82, 42, 2, 645, 649, 7, 20, 2, 2, 646, 647, 5, 76, 39,
	2, 647, 648, 7, 10, 2, 2, 648, 650, 3, 2, 2, 2, 649, 646, 3, 2, 2, 2, 649,
	650, 3, 2, 2, 2, 650, 651, 3, 2, 2, 2, 651, 652, 5, 74, 38, 2, 652, 653,
	7, 21, 2, 2, 653, 659, 3, 2, 2, 2, 654, 656, 5, 92, 47, 2, 655, 657, 5,
	44, 23, 2, 656, 655, 3, 2, 2, 2, 656, 657, 3, 2, 2, 2, 657, 659, 3, 2,
	2, 2, 658, 644, 3, 2, 2, 2, 658, 645, 3, 2, 2, 2, 658, 654, 3, 2, 2, 2,
	659, 670, 3, 2, 2, 2, 660, 662, 7, 87, 2, 2, 661, 663, 5, 58, 30, 2, 662,
	661, 3, 2, 2, 2, 662, 663, 3, 2, 2, 2, 663, 670, 3, 2, 2, 2, 664, 665,
	9, 11, 2, 2, 665, 666, 7, 12, 2, 2, 666, 667, 5, 76, 39, 2, 667, 668, 7,
	13, 2, 2, 668, 670, 3, 2, 2, 2, 669, 631, 3, 2, 2, 2, 669, 633, 3, 2, 2,
	2, 669, 634, 3, 2, 2, 2, 669, 635, 3, 2, 2, 2, 669, 636, 3, 2, 2, 2, 669,
	637, 3, 2, 2, 2, 669, 638, 3, 2, 2, 2, 669, 642, 3, 2, 2, 2, 669, 660,
	3, 2, 2, 2, 669, 664, 3, 2, 2, 2, 670, 684, 3, 2, 2, 2, 671, 680, 12, 6,
	2, 2, 672, 673, 7, 42, 2, 2, 673, 681, 5, 92, 47, 2, 674, 681, 5, 76, 39,
	2, 675, 677, 7, 12, 2, 2, 676, 678, 5, 74, 38, 2, 677, 676, 3, 2, 2, 2,
	677, 678, 3, 2, 2, 2, 678, 679, 3, 2, 2, 2, 679, 681, 7, 13, 2, 2, 680,
	672, 3, 2, 2, 2, 680, 674, 3, 2, 2, 2, 680, 675, 3, 2, 2, 2, 681, 683,
	3, 2, 2, 2, 682, 671, 3, 2, 2, 2, 683, 686, 3, 2, 2, 2, 684, 682, 3, 2,
	2, 2, 684, 685, 3, 2, 2, 2, 685, 79, 3, 2, 2, 2, 686, 684, 3, 2, 2, 2,
	687, 688, 5, 78, 40, 2, 688, 689, 7, 12, 2, 2, 689, 690, 5, 74, 38, 2,
	690, 691, 7, 13, 2, 2, 691, 81, 3, 2, 2, 2, 692, 697, 5, 84, 43, 2, 693,
	694, 7, 9, 2, 2, 694, 696, 5, 84, 43, 2, 695, 693, 3, 2, 2, 2, 696, 699,
	3, 2, 2, 2, 697, 695, 3, 2, 2, 2, 697, 698, 3, 2, 2, 2, 698, 83, 3, 2,
	2, 2, 699, 697, 3, 2, 2, 2, 700, 701, 5, 90, 46, 2, 701, 702, 7, 10, 2,
	2, 702, 703, 5, 76, 39, 2, 703, 85, 3, 2, 2, 2, 704, 709, 5, 88, 45, 2,
	705, 706, 7, 9, 2, 2, 706, 708, 5, 88, 45, 2, 707, 705, 3, 2, 2, 2, 708,
	711, 3, 2, 2, 2, 709, 707, 3, 2, 2, 2, 709, 710, 3, 2, 2, 2, 710, 87, 3,
	2, 2, 2, 711, 709, 3, 2, 2, 2, 712, 713, 7, 91, 2, 2, 713, 89, 3, 2, 2,
	2, 714, 719, 5, 92, 47, 2, 715, 716, 7, 9, 2, 2, 716, 718, 5, 92, 47, 2,
	717, 715, 3, 2, 2, 2, 718, 721, 3, 2, 2, 2, 719, 717, 3, 2, 2, 2, 719,
	720, 3, 2, 2, 2, 720, 91, 3, 2, 2, 2, 721, 719, 3, 2, 2, 2, 722, 723, 7,
	91, 2, 2, 723, 93, 3, 2, 2, 2, 724, 725, 7, 92, 2, 2, 725, 95, 3, 2, 2,
	2, 726, 727, 7, 93, 2, 2, 727, 97, 3, 2, 2, 2, 728, 729, 7, 90, 2, 2, 729,
	99, 3, 2, 2, 2, 86, 103, 109, 115, 119, 122, 125, 135, 139, 142, 145, 155,
	160, 171, 178, 182, 191, 215, 222, 229, 238, 246, 255, 258, 260, 264, 271,
	283, 289, 298, 303, 308, 314, 320, 326, 335, 341, 348, 353, 359, 373, 387,
	391, 395, 398, 401, 405, 407, 414, 437, 455, 474, 479, 488, 494, 500, 505,
	510, 517, 526, 530, 533, 537, 548, 559, 561, 573, 581, 587, 595, 606, 626,
	628, 640, 649, 656, 658, 662, 669, 677, 680, 684, 697, 709, 719,
}
var literalNames = []string{
	"", "'='", "'proc'", "'end'", "'iter'", "'cluster'", "'is'", "','", "':'",
	"'type'", "'('", "')'", "'returns'", "'yields'", "'signals'", "'where'",
	"'has'", "'in'", "'['", "']'", "'rep'", "'routine'", "'own'", "':='", "'null'",
	"'bool'", "'int'", "'real'", "'char'", "'string'", "'any'", "'cvt'", "'array'",
	"'sequence'", "'record'", "'struct'", "'oneof'", "'variant'", "'proctype'",
	"'itertype'", "'.'", "'while'", "'do'", "'for'", "'if'", "'then'", "'elseif'",
	"'else'", "'tagcase'", "'others'", "'return'", "'yield'", "'signal'", "'exit'",
	"'break'", "'begin'", "'resignal'", "'except'", "'tag'", "'when'", "'*'",
	"'~'", "'-'", "'**'", "'//'", "'/'", "'||'", "'+'", "'<'", "'<='", "'>='",
	"'>'", "'~<'", "'~<='", "'~='", "'~>='", "'~>'", "'&'", "'cand'", "'|'",
	"'cor'", "'nil'", "'true'", "'false'", "'$'", "'force'", "'up'", "'down'",
}
var symbolicNames = []string{
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "STRINGLITERAL",
	"STRING", "INT", "FLOAT", "COMMENT", "WS",
}

var ruleNames = []string{
	"module", "procedure", "iterator", "cluster", "parms", "param", "args",
	"decl_list", "decl", "returnz", "yields", "signals", "exception_", "type_spec_list",
	"where_", "restriction", "type_set", "oper_decl_list", "oper_decl", "op_name_list",
	"op_name", "constant_list", "constant", "routine_body", "cluster_body",
	"routine", "equate", "own_var", "type_spec", "field_spec_list", "field_spec",
	"statement", "tag_arm", "when_handler", "others_handler", "body", "expression_list",
	"expression", "primary", "invocation", "field_list", "field", "idn_list",
	"idn", "name_list", "name", "int_literal", "real_literal", "string_literal",
}

type cluParser struct {
	*antlr.BaseParser
}

// NewcluParser produces a new parser instance for the optional input antlr.TokenStream.
//
// The *cluParser instance produced may be reused by calling the SetInputStream method.
// The initial parser configuration is expensive to construct, and the object is not thread-safe;
// however, if used within a Golang sync.Pool, the construction cost amortizes well and the
// objects can be used in a thread-safe manner.
func NewcluParser(input antlr.TokenStream) *cluParser {
	this := new(cluParser)
	deserializer := antlr.NewATNDeserializer(nil)
	deserializedATN := deserializer.DeserializeFromUInt16(parserATN)
	decisionToDFA := make([]*antlr.DFA, len(deserializedATN.DecisionToState))
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "clu.g4"

	return this
}

// cluParser tokens.
const (
	cluParserEOF           = antlr.TokenEOF
	cluParserT__0          = 1
	cluParserT__1          = 2
	cluParserT__2          = 3
	cluParserT__3          = 4
	cluParserT__4          = 5
	cluParserT__5          = 6
	cluParserT__6          = 7
	cluParserT__7          = 8
	cluParserT__8          = 9
	cluParserT__9          = 10
	cluParserT__10         = 11
	cluParserT__11         = 12
	cluParserT__12         = 13
	cluParserT__13         = 14
	cluParserT__14         = 15
	cluParserT__15         = 16
	cluParserT__16         = 17
	cluParserT__17         = 18
	cluParserT__18         = 19
	cluParserT__19         = 20
	cluParserT__20         = 21
	cluParserT__21         = 22
	cluParserT__22         = 23
	cluParserT__23         = 24
	cluParserT__24         = 25
	cluParserT__25         = 26
	cluParserT__26         = 27
	cluParserT__27         = 28
	cluParserT__28         = 29
	cluParserT__29         = 30
	cluParserT__30         = 31
	cluParserT__31         = 32
	cluParserT__32         = 33
	cluParserT__33         = 34
	cluParserT__34         = 35
	cluParserT__35         = 36
	cluParserT__36         = 37
	cluParserT__37         = 38
	cluParserT__38         = 39
	cluParserT__39         = 40
	cluParserT__40         = 41
	cluParserT__41         = 42
	cluParserT__42         = 43
	cluParserT__43         = 44
	cluParserT__44         = 45
	cluParserT__45         = 46
	cluParserT__46         = 47
	cluParserT__47         = 48
	cluParserT__48         = 49
	cluParserT__49         = 50
	cluParserT__50         = 51
	cluParserT__51         = 52
	cluParserT__52         = 53
	cluParserT__53         = 54
	cluParserT__54         = 55
	cluParserT__55         = 56
	cluParserT__56         = 57
	cluParserT__57         = 58
	cluParserT__58         = 59
	cluParserT__59         = 60
	cluParserT__60         = 61
	cluParserT__61         = 62
	cluParserT__62         = 63
	cluParserT__63         = 64
	cluParserT__64         = 65
	cluParserT__65         = 66
	cluParserT__66         = 67
	cluParserT__67         = 68
	cluParserT__68         = 69
	cluParserT__69         = 70
	cluParserT__70         = 71
	cluParserT__71         = 72
	cluParserT__72         = 73
	cluParserT__73         = 74
	cluParserT__74         = 75
	cluParserT__75         = 76
	cluParserT__76         = 77
	cluParserT__77         = 78
	cluParserT__78         = 79
	cluParserT__79         = 80
	cluParserT__80         = 81
	cluParserT__81         = 82
	cluParserT__82         = 83
	cluParserT__83         = 84
	cluParserT__84         = 85
	cluParserT__85         = 86
	cluParserT__86         = 87
	cluParserSTRINGLITERAL = 88
	cluParserSTRING        = 89
	cluParserINT           = 90
	cluParserFLOAT         = 91
	cluParserCOMMENT       = 92
	cluParserWS            = 93
)

// cluParser rules.
const (
	cluParserRULE_module          = 0
	cluParserRULE_procedure       = 1
	cluParserRULE_iterator        = 2
	cluParserRULE_cluster         = 3
	cluParserRULE_parms           = 4
	cluParserRULE_param           = 5
	cluParserRULE_args            = 6
	cluParserRULE_decl_list       = 7
	cluParserRULE_decl            = 8
	cluParserRULE_returnz         = 9
	cluParserRULE_yields          = 10
	cluParserRULE_signals         = 11
	cluParserRULE_exception_      = 12
	cluParserRULE_type_spec_list  = 13
	cluParserRULE_where_          = 14
	cluParserRULE_restriction     = 15
	cluParserRULE_type_set        = 16
	cluParserRULE_oper_decl_list  = 17
	cluParserRULE_oper_decl       = 18
	cluParserRULE_op_name_list    = 19
	cluParserRULE_op_name         = 20
	cluParserRULE_constant_list   = 21
	cluParserRULE_constant        = 22
	cluParserRULE_routine_body    = 23
	cluParserRULE_cluster_body    = 24
	cluParserRULE_routine         = 25
	cluParserRULE_equate          = 26
	cluParserRULE_own_var         = 27
	cluParserRULE_type_spec       = 28
	cluParserRULE_field_spec_list = 29
	cluParserRULE_field_spec      = 30
	cluParserRULE_statement       = 31
	cluParserRULE_tag_arm         = 32
	cluParserRULE_when_handler    = 33
	cluParserRULE_others_handler  = 34
	cluParserRULE_body            = 35
	cluParserRULE_expression_list = 36
	cluParserRULE_expression      = 37
	cluParserRULE_primary         = 38
	cluParserRULE_invocation      = 39
	cluParserRULE_field_list      = 40
	cluParserRULE_field           = 41
	cluParserRULE_idn_list        = 42
	cluParserRULE_idn             = 43
	cluParserRULE_name_list       = 44
	cluParserRULE_name            = 45
	cluParserRULE_int_literal     = 46
	cluParserRULE_real_literal    = 47
	cluParserRULE_string_literal  = 48
)

// IModuleContext is an interface to support dynamic dispatch.
type IModuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModuleContext differentiates from other interfaces.
	IsModuleContext()
}

type ModuleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModuleContext() *ModuleContext {
	var p = new(ModuleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_module
	return p
}

func (*ModuleContext) IsModuleContext() {}

func NewModuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModuleContext {
	var p = new(ModuleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_module

	return p
}

func (s *ModuleContext) GetParser() antlr.Parser { return s.parser }

func (s *ModuleContext) Procedure() IProcedureContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedureContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedureContext)
}

func (s *ModuleContext) Iterator() IIteratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIteratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIteratorContext)
}

func (s *ModuleContext) Cluster() IClusterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClusterContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClusterContext)
}

func (s *ModuleContext) AllEquate() []IEquateContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEquateContext)(nil)).Elem())
	var tst = make([]IEquateContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEquateContext)
		}
	}

	return tst
}

func (s *ModuleContext) Equate(i int) IEquateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEquateContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEquateContext)
}

func (s *ModuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModuleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterModule(s)
	}
}

func (s *ModuleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitModule(s)
	}
}

func (p *cluParser) Module() (localctx IModuleContext) {
	this := p
	_ = this

	localctx = NewModuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, cluParserRULE_module)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(101)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 0, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(98)
				p.Equate()
			}

		}
		p.SetState(103)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 0, p.GetParserRuleContext())
	}
	p.SetState(107)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(104)
			p.Procedure()
		}

	case 2:
		{
			p.SetState(105)
			p.Iterator()
		}

	case 3:
		{
			p.SetState(106)
			p.Cluster()
		}

	}

	return localctx
}

// IProcedureContext is an interface to support dynamic dispatch.
type IProcedureContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedureContext differentiates from other interfaces.
	IsProcedureContext()
}

type ProcedureContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureContext() *ProcedureContext {
	var p = new(ProcedureContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_procedure
	return p
}

func (*ProcedureContext) IsProcedureContext() {}

func NewProcedureContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureContext {
	var p = new(ProcedureContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_procedure

	return p
}

func (s *ProcedureContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureContext) AllIdn() []IIdnContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdnContext)(nil)).Elem())
	var tst = make([]IIdnContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdnContext)
		}
	}

	return tst
}

func (s *ProcedureContext) Idn(i int) IIdnContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdnContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdnContext)
}

func (s *ProcedureContext) Args() IArgsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgsContext)
}

func (s *ProcedureContext) Routine_body() IRoutine_bodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRoutine_bodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRoutine_bodyContext)
}

func (s *ProcedureContext) Parms() IParmsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParmsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParmsContext)
}

func (s *ProcedureContext) Returnz() IReturnzContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReturnzContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReturnzContext)
}

func (s *ProcedureContext) Signals() ISignalsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISignalsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISignalsContext)
}

func (s *ProcedureContext) Where_() IWhere_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhere_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWhere_Context)
}

func (s *ProcedureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterProcedure(s)
	}
}

func (s *ProcedureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitProcedure(s)
	}
}

func (p *cluParser) Procedure() (localctx IProcedureContext) {
	this := p
	_ = this

	localctx = NewProcedureContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, cluParserRULE_procedure)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(109)
		p.Idn()
	}
	{
		p.SetState(110)
		p.Match(cluParserT__0)
	}
	{
		p.SetState(111)
		p.Match(cluParserT__1)
	}
	p.SetState(113)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == cluParserSTRING {
		{
			p.SetState(112)
			p.Parms()
		}

	}
	{
		p.SetState(115)
		p.Args()
	}
	p.SetState(117)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == cluParserT__11 {
		{
			p.SetState(116)
			p.Returnz()
		}

	}
	p.SetState(120)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == cluParserT__13 {
		{
			p.SetState(119)
			p.Signals()
		}

	}
	p.SetState(123)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == cluParserT__14 {
		{
			p.SetState(122)
			p.Where_()
		}

	}
	{
		p.SetState(125)
		p.Routine_body()
	}
	{
		p.SetState(126)
		p.Match(cluParserT__2)
	}
	{
		p.SetState(127)
		p.Idn()
	}

	return localctx
}

// IIteratorContext is an interface to support dynamic dispatch.
type IIteratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIteratorContext differentiates from other interfaces.
	IsIteratorContext()
}

type IteratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIteratorContext() *IteratorContext {
	var p = new(IteratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_iterator
	return p
}

func (*IteratorContext) IsIteratorContext() {}

func NewIteratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IteratorContext {
	var p = new(IteratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_iterator

	return p
}

func (s *IteratorContext) GetParser() antlr.Parser { return s.parser }

func (s *IteratorContext) AllIdn() []IIdnContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdnContext)(nil)).Elem())
	var tst = make([]IIdnContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdnContext)
		}
	}

	return tst
}

func (s *IteratorContext) Idn(i int) IIdnContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdnContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdnContext)
}

func (s *IteratorContext) Args() IArgsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgsContext)
}

func (s *IteratorContext) Routine_body() IRoutine_bodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRoutine_bodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRoutine_bodyContext)
}

func (s *IteratorContext) Parms() IParmsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParmsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParmsContext)
}

func (s *IteratorContext) Yields() IYieldsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IYieldsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IYieldsContext)
}

func (s *IteratorContext) Signals() ISignalsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISignalsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISignalsContext)
}

func (s *IteratorContext) Where_() IWhere_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhere_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWhere_Context)
}

func (s *IteratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IteratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IteratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterIterator(s)
	}
}

func (s *IteratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitIterator(s)
	}
}

func (p *cluParser) Iterator() (localctx IIteratorContext) {
	this := p
	_ = this

	localctx = NewIteratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, cluParserRULE_iterator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(129)
		p.Idn()
	}
	{
		p.SetState(130)
		p.Match(cluParserT__0)
	}
	{
		p.SetState(131)
		p.Match(cluParserT__3)
	}
	p.SetState(133)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == cluParserSTRING {
		{
			p.SetState(132)
			p.Parms()
		}

	}
	{
		p.SetState(135)
		p.Args()
	}
	p.SetState(137)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == cluParserT__12 {
		{
			p.SetState(136)
			p.Yields()
		}

	}
	p.SetState(140)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == cluParserT__13 {
		{
			p.SetState(139)
			p.Signals()
		}

	}
	p.SetState(143)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == cluParserT__14 {
		{
			p.SetState(142)
			p.Where_()
		}

	}
	{
		p.SetState(145)
		p.Routine_body()
	}
	{
		p.SetState(146)
		p.Match(cluParserT__2)
	}
	{
		p.SetState(147)
		p.Idn()
	}

	return localctx
}

// IClusterContext is an interface to support dynamic dispatch.
type IClusterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClusterContext differentiates from other interfaces.
	IsClusterContext()
}

type ClusterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClusterContext() *ClusterContext {
	var p = new(ClusterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_cluster
	return p
}

func (*ClusterContext) IsClusterContext() {}

func NewClusterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClusterContext {
	var p = new(ClusterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_cluster

	return p
}

func (s *ClusterContext) GetParser() antlr.Parser { return s.parser }

func (s *ClusterContext) AllIdn() []IIdnContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdnContext)(nil)).Elem())
	var tst = make([]IIdnContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdnContext)
		}
	}

	return tst
}

func (s *ClusterContext) Idn(i int) IIdnContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdnContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdnContext)
}

func (s *ClusterContext) Idn_list() IIdn_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdn_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdn_listContext)
}

func (s *ClusterContext) Cluster_body() ICluster_bodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICluster_bodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICluster_bodyContext)
}

func (s *ClusterContext) Parms() IParmsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParmsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParmsContext)
}

func (s *ClusterContext) Where_() IWhere_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhere_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWhere_Context)
}

func (s *ClusterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClusterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClusterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterCluster(s)
	}
}

func (s *ClusterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitCluster(s)
	}
}

func (p *cluParser) Cluster() (localctx IClusterContext) {
	this := p
	_ = this

	localctx = NewClusterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, cluParserRULE_cluster)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(149)
		p.Idn()
	}
	{
		p.SetState(150)
		p.Match(cluParserT__0)
	}
	{
		p.SetState(151)
		p.Match(cluParserT__4)
	}
	p.SetState(153)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == cluParserSTRING {
		{
			p.SetState(152)
			p.Parms()
		}

	}
	{
		p.SetState(155)
		p.Match(cluParserT__5)
	}
	{
		p.SetState(156)
		p.Idn_list()
	}
	p.SetState(158)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == cluParserT__14 {
		{
			p.SetState(157)
			p.Where_()
		}

	}
	{
		p.SetState(160)
		p.Cluster_body()
	}
	{
		p.SetState(161)
		p.Match(cluParserT__2)
	}
	{
		p.SetState(162)
		p.Idn()
	}

	return localctx
}

// IParmsContext is an interface to support dynamic dispatch.
type IParmsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParmsContext differentiates from other interfaces.
	IsParmsContext()
}

type ParmsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParmsContext() *ParmsContext {
	var p = new(ParmsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_parms
	return p
}

func (*ParmsContext) IsParmsContext() {}

func NewParmsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParmsContext {
	var p = new(ParmsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_parms

	return p
}

func (s *ParmsContext) GetParser() antlr.Parser { return s.parser }

func (s *ParmsContext) AllParam() []IParamContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IParamContext)(nil)).Elem())
	var tst = make([]IParamContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IParamContext)
		}
	}

	return tst
}

func (s *ParmsContext) Param(i int) IParamContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParamContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IParamContext)
}

func (s *ParmsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParmsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParmsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterParms(s)
	}
}

func (s *ParmsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitParms(s)
	}
}

func (p *cluParser) Parms() (localctx IParmsContext) {
	this := p
	_ = this

	localctx = NewParmsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, cluParserRULE_parms)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(164)
		p.Param()
	}
	p.SetState(169)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == cluParserT__6 {
		{
			p.SetState(165)
			p.Match(cluParserT__6)
		}
		{
			p.SetState(166)
			p.Param()
		}

		p.SetState(171)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IParamContext is an interface to support dynamic dispatch.
type IParamContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParamContext differentiates from other interfaces.
	IsParamContext()
}

type ParamContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParamContext() *ParamContext {
	var p = new(ParamContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_param
	return p
}

func (*ParamContext) IsParamContext() {}

func NewParamContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParamContext {
	var p = new(ParamContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_param

	return p
}

func (s *ParamContext) GetParser() antlr.Parser { return s.parser }

func (s *ParamContext) Idn_list() IIdn_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdn_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdn_listContext)
}

func (s *ParamContext) Type_spec() IType_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_specContext)
}

func (s *ParamContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParamContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParamContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterParam(s)
	}
}

func (s *ParamContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitParam(s)
	}
}

func (p *cluParser) Param() (localctx IParamContext) {
	this := p
	_ = this

	localctx = NewParamContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, cluParserRULE_param)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(172)
		p.Idn_list()
	}
	{
		p.SetState(173)
		p.Match(cluParserT__7)
	}
	p.SetState(176)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case cluParserT__8:
		{
			p.SetState(174)
			p.Match(cluParserT__8)
		}

	case cluParserT__19, cluParserT__23, cluParserT__24, cluParserT__25, cluParserT__26, cluParserT__27, cluParserT__28, cluParserT__29, cluParserT__30, cluParserT__31, cluParserT__32, cluParserT__33, cluParserT__34, cluParserT__35, cluParserT__36, cluParserT__37, cluParserT__38, cluParserSTRING:
		{
			p.SetState(175)
			p.Type_spec()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IArgsContext is an interface to support dynamic dispatch.
type IArgsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArgsContext differentiates from other interfaces.
	IsArgsContext()
}

type ArgsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgsContext() *ArgsContext {
	var p = new(ArgsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_args
	return p
}

func (*ArgsContext) IsArgsContext() {}

func NewArgsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgsContext {
	var p = new(ArgsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_args

	return p
}

func (s *ArgsContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgsContext) Decl_list() IDecl_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDecl_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDecl_listContext)
}

func (s *ArgsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterArgs(s)
	}
}

func (s *ArgsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitArgs(s)
	}
}

func (p *cluParser) Args() (localctx IArgsContext) {
	this := p
	_ = this

	localctx = NewArgsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, cluParserRULE_args)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(178)
		p.Match(cluParserT__9)
	}
	p.SetState(180)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == cluParserSTRING {
		{
			p.SetState(179)
			p.Decl_list()
		}

	}
	{
		p.SetState(182)
		p.Match(cluParserT__10)
	}

	return localctx
}

// IDecl_listContext is an interface to support dynamic dispatch.
type IDecl_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDecl_listContext differentiates from other interfaces.
	IsDecl_listContext()
}

type Decl_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDecl_listContext() *Decl_listContext {
	var p = new(Decl_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_decl_list
	return p
}

func (*Decl_listContext) IsDecl_listContext() {}

func NewDecl_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Decl_listContext {
	var p = new(Decl_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_decl_list

	return p
}

func (s *Decl_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Decl_listContext) AllDecl() []IDeclContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDeclContext)(nil)).Elem())
	var tst = make([]IDeclContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDeclContext)
		}
	}

	return tst
}

func (s *Decl_listContext) Decl(i int) IDeclContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDeclContext)
}

func (s *Decl_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Decl_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Decl_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterDecl_list(s)
	}
}

func (s *Decl_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitDecl_list(s)
	}
}

func (p *cluParser) Decl_list() (localctx IDecl_listContext) {
	this := p
	_ = this

	localctx = NewDecl_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, cluParserRULE_decl_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(184)
		p.Decl()
	}
	p.SetState(189)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == cluParserT__6 {
		{
			p.SetState(185)
			p.Match(cluParserT__6)
		}
		{
			p.SetState(186)
			p.Decl()
		}

		p.SetState(191)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IDeclContext is an interface to support dynamic dispatch.
type IDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeclContext differentiates from other interfaces.
	IsDeclContext()
}

type DeclContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclContext() *DeclContext {
	var p = new(DeclContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_decl
	return p
}

func (*DeclContext) IsDeclContext() {}

func NewDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclContext {
	var p = new(DeclContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_decl

	return p
}

func (s *DeclContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclContext) Idn_list() IIdn_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdn_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdn_listContext)
}

func (s *DeclContext) Type_spec() IType_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_specContext)
}

func (s *DeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterDecl(s)
	}
}

func (s *DeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitDecl(s)
	}
}

func (p *cluParser) Decl() (localctx IDeclContext) {
	this := p
	_ = this

	localctx = NewDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, cluParserRULE_decl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(192)
		p.Idn_list()
	}
	{
		p.SetState(193)
		p.Match(cluParserT__7)
	}
	{
		p.SetState(194)
		p.Type_spec()
	}

	return localctx
}

// IReturnzContext is an interface to support dynamic dispatch.
type IReturnzContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReturnzContext differentiates from other interfaces.
	IsReturnzContext()
}

type ReturnzContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnzContext() *ReturnzContext {
	var p = new(ReturnzContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_returnz
	return p
}

func (*ReturnzContext) IsReturnzContext() {}

func NewReturnzContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnzContext {
	var p = new(ReturnzContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_returnz

	return p
}

func (s *ReturnzContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnzContext) Type_spec_list() IType_spec_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_spec_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_spec_listContext)
}

func (s *ReturnzContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnzContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnzContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterReturnz(s)
	}
}

func (s *ReturnzContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitReturnz(s)
	}
}

func (p *cluParser) Returnz() (localctx IReturnzContext) {
	this := p
	_ = this

	localctx = NewReturnzContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, cluParserRULE_returnz)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(196)
		p.Match(cluParserT__11)
	}
	{
		p.SetState(197)
		p.Match(cluParserT__9)
	}
	{
		p.SetState(198)
		p.Type_spec_list()
	}
	{
		p.SetState(199)
		p.Match(cluParserT__10)
	}

	return localctx
}

// IYieldsContext is an interface to support dynamic dispatch.
type IYieldsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsYieldsContext differentiates from other interfaces.
	IsYieldsContext()
}

type YieldsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyYieldsContext() *YieldsContext {
	var p = new(YieldsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_yields
	return p
}

func (*YieldsContext) IsYieldsContext() {}

func NewYieldsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *YieldsContext {
	var p = new(YieldsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_yields

	return p
}

func (s *YieldsContext) GetParser() antlr.Parser { return s.parser }

func (s *YieldsContext) Type_spec_list() IType_spec_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_spec_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_spec_listContext)
}

func (s *YieldsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *YieldsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *YieldsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterYields(s)
	}
}

func (s *YieldsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitYields(s)
	}
}

func (p *cluParser) Yields() (localctx IYieldsContext) {
	this := p
	_ = this

	localctx = NewYieldsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, cluParserRULE_yields)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(201)
		p.Match(cluParserT__12)
	}
	{
		p.SetState(202)
		p.Match(cluParserT__9)
	}
	{
		p.SetState(203)
		p.Type_spec_list()
	}
	{
		p.SetState(204)
		p.Match(cluParserT__10)
	}

	return localctx
}

// ISignalsContext is an interface to support dynamic dispatch.
type ISignalsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSignalsContext differentiates from other interfaces.
	IsSignalsContext()
}

type SignalsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySignalsContext() *SignalsContext {
	var p = new(SignalsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_signals
	return p
}

func (*SignalsContext) IsSignalsContext() {}

func NewSignalsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SignalsContext {
	var p = new(SignalsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_signals

	return p
}

func (s *SignalsContext) GetParser() antlr.Parser { return s.parser }

func (s *SignalsContext) AllException_() []IException_Context {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IException_Context)(nil)).Elem())
	var tst = make([]IException_Context, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IException_Context)
		}
	}

	return tst
}

func (s *SignalsContext) Exception_(i int) IException_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IException_Context)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IException_Context)
}

func (s *SignalsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SignalsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SignalsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterSignals(s)
	}
}

func (s *SignalsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitSignals(s)
	}
}

func (p *cluParser) Signals() (localctx ISignalsContext) {
	this := p
	_ = this

	localctx = NewSignalsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, cluParserRULE_signals)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(206)
		p.Match(cluParserT__13)
	}
	{
		p.SetState(207)
		p.Match(cluParserT__9)
	}
	{
		p.SetState(208)
		p.Exception_()
	}
	p.SetState(213)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == cluParserT__6 {
		{
			p.SetState(209)
			p.Match(cluParserT__6)
		}
		{
			p.SetState(210)
			p.Exception_()
		}

		p.SetState(215)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(216)
		p.Match(cluParserT__10)
	}

	return localctx
}

// IException_Context is an interface to support dynamic dispatch.
type IException_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsException_Context differentiates from other interfaces.
	IsException_Context()
}

type Exception_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyException_Context() *Exception_Context {
	var p = new(Exception_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_exception_
	return p
}

func (*Exception_Context) IsException_Context() {}

func NewException_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Exception_Context {
	var p = new(Exception_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_exception_

	return p
}

func (s *Exception_Context) GetParser() antlr.Parser { return s.parser }

func (s *Exception_Context) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Exception_Context) Type_spec_list() IType_spec_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_spec_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_spec_listContext)
}

func (s *Exception_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Exception_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Exception_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterException_(s)
	}
}

func (s *Exception_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitException_(s)
	}
}

func (p *cluParser) Exception_() (localctx IException_Context) {
	this := p
	_ = this

	localctx = NewException_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, cluParserRULE_exception_)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(218)
		p.Name()
	}
	p.SetState(220)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-20)&-(0x1f+1)) == 0 && ((1<<uint((_la-20)))&((1<<(cluParserT__19-20))|(1<<(cluParserT__23-20))|(1<<(cluParserT__24-20))|(1<<(cluParserT__25-20))|(1<<(cluParserT__26-20))|(1<<(cluParserT__27-20))|(1<<(cluParserT__28-20))|(1<<(cluParserT__29-20))|(1<<(cluParserT__30-20))|(1<<(cluParserT__31-20))|(1<<(cluParserT__32-20))|(1<<(cluParserT__33-20))|(1<<(cluParserT__34-20))|(1<<(cluParserT__35-20))|(1<<(cluParserT__36-20))|(1<<(cluParserT__37-20))|(1<<(cluParserT__38-20)))) != 0) || _la == cluParserSTRING {
		{
			p.SetState(219)
			p.Type_spec_list()
		}

	}

	return localctx
}

// IType_spec_listContext is an interface to support dynamic dispatch.
type IType_spec_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsType_spec_listContext differentiates from other interfaces.
	IsType_spec_listContext()
}

type Type_spec_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_spec_listContext() *Type_spec_listContext {
	var p = new(Type_spec_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_type_spec_list
	return p
}

func (*Type_spec_listContext) IsType_spec_listContext() {}

func NewType_spec_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_spec_listContext {
	var p = new(Type_spec_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_type_spec_list

	return p
}

func (s *Type_spec_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_spec_listContext) AllType_spec() []IType_specContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IType_specContext)(nil)).Elem())
	var tst = make([]IType_specContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IType_specContext)
		}
	}

	return tst
}

func (s *Type_spec_listContext) Type_spec(i int) IType_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IType_specContext)
}

func (s *Type_spec_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_spec_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_spec_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterType_spec_list(s)
	}
}

func (s *Type_spec_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitType_spec_list(s)
	}
}

func (p *cluParser) Type_spec_list() (localctx IType_spec_listContext) {
	this := p
	_ = this

	localctx = NewType_spec_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, cluParserRULE_type_spec_list)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(222)
		p.Type_spec()
	}
	p.SetState(227)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 18, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(223)
				p.Match(cluParserT__6)
			}
			{
				p.SetState(224)
				p.Type_spec()
			}

		}
		p.SetState(229)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 18, p.GetParserRuleContext())
	}

	return localctx
}

// IWhere_Context is an interface to support dynamic dispatch.
type IWhere_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWhere_Context differentiates from other interfaces.
	IsWhere_Context()
}

type Where_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhere_Context() *Where_Context {
	var p = new(Where_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_where_
	return p
}

func (*Where_Context) IsWhere_Context() {}

func NewWhere_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Where_Context {
	var p = new(Where_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_where_

	return p
}

func (s *Where_Context) GetParser() antlr.Parser { return s.parser }

func (s *Where_Context) AllRestriction() []IRestrictionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRestrictionContext)(nil)).Elem())
	var tst = make([]IRestrictionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRestrictionContext)
		}
	}

	return tst
}

func (s *Where_Context) Restriction(i int) IRestrictionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRestrictionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRestrictionContext)
}

func (s *Where_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Where_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Where_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterWhere_(s)
	}
}

func (s *Where_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitWhere_(s)
	}
}

func (p *cluParser) Where_() (localctx IWhere_Context) {
	this := p
	_ = this

	localctx = NewWhere_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, cluParserRULE_where_)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(230)
		p.Match(cluParserT__14)
	}
	{
		p.SetState(231)
		p.Restriction()
	}
	p.SetState(236)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == cluParserT__6 {
		{
			p.SetState(232)
			p.Match(cluParserT__6)
		}
		{
			p.SetState(233)
			p.Restriction()
		}

		p.SetState(238)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IRestrictionContext is an interface to support dynamic dispatch.
type IRestrictionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRestrictionContext differentiates from other interfaces.
	IsRestrictionContext()
}

type RestrictionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRestrictionContext() *RestrictionContext {
	var p = new(RestrictionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_restriction
	return p
}

func (*RestrictionContext) IsRestrictionContext() {}

func NewRestrictionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RestrictionContext {
	var p = new(RestrictionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_restriction

	return p
}

func (s *RestrictionContext) GetParser() antlr.Parser { return s.parser }

func (s *RestrictionContext) Idn() IIdnContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdnContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdnContext)
}

func (s *RestrictionContext) Oper_decl_list() IOper_decl_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOper_decl_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOper_decl_listContext)
}

func (s *RestrictionContext) Type_set() IType_setContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_setContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_setContext)
}

func (s *RestrictionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RestrictionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RestrictionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterRestriction(s)
	}
}

func (s *RestrictionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitRestriction(s)
	}
}

func (p *cluParser) Restriction() (localctx IRestrictionContext) {
	this := p
	_ = this

	localctx = NewRestrictionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, cluParserRULE_restriction)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(239)
		p.Idn()
	}
	p.SetState(244)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case cluParserT__15:
		{
			p.SetState(240)
			p.Match(cluParserT__15)
		}
		{
			p.SetState(241)
			p.Oper_decl_list()
		}

	case cluParserT__16:
		{
			p.SetState(242)
			p.Match(cluParserT__16)
		}
		{
			p.SetState(243)
			p.Type_set()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IType_setContext is an interface to support dynamic dispatch.
type IType_setContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsType_setContext differentiates from other interfaces.
	IsType_setContext()
}

type Type_setContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_setContext() *Type_setContext {
	var p = new(Type_setContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_type_set
	return p
}

func (*Type_setContext) IsType_setContext() {}

func NewType_setContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_setContext {
	var p = new(Type_setContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_type_set

	return p
}

func (s *Type_setContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_setContext) AllIdn() []IIdnContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdnContext)(nil)).Elem())
	var tst = make([]IIdnContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdnContext)
		}
	}

	return tst
}

func (s *Type_setContext) Idn(i int) IIdnContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdnContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdnContext)
}

func (s *Type_setContext) AllOper_decl_list() []IOper_decl_listContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOper_decl_listContext)(nil)).Elem())
	var tst = make([]IOper_decl_listContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOper_decl_listContext)
		}
	}

	return tst
}

func (s *Type_setContext) Oper_decl_list(i int) IOper_decl_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOper_decl_listContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOper_decl_listContext)
}

func (s *Type_setContext) AllEquate() []IEquateContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEquateContext)(nil)).Elem())
	var tst = make([]IEquateContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEquateContext)
		}
	}

	return tst
}

func (s *Type_setContext) Equate(i int) IEquateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEquateContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEquateContext)
}

func (s *Type_setContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_setContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_setContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterType_set(s)
	}
}

func (s *Type_setContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitType_set(s)
	}
}

func (p *cluParser) Type_set() (localctx IType_setContext) {
	this := p
	_ = this

	localctx = NewType_setContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, cluParserRULE_type_set)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(262)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 24, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(258)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 23, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(256)
				p.GetErrorHandler().Sync(p)
				switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 22, p.GetParserRuleContext()) {
				case 1:
					{
						p.SetState(246)
						p.Idn()
					}

				case 2:
					{
						p.SetState(247)
						p.Idn()
					}
					{
						p.SetState(248)
						p.Match(cluParserT__15)
					}
					{
						p.SetState(249)
						p.Oper_decl_list()
					}
					p.SetState(253)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 21, p.GetParserRuleContext())

					for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
						if _alt == 1 {
							{
								p.SetState(250)
								p.Equate()
							}

						}
						p.SetState(255)
						p.GetErrorHandler().Sync(p)
						_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 21, p.GetParserRuleContext())
					}

				}

			}
			p.SetState(260)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 23, p.GetParserRuleContext())
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(261)
			p.Idn()
		}

	}

	return localctx
}

// IOper_decl_listContext is an interface to support dynamic dispatch.
type IOper_decl_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOper_decl_listContext differentiates from other interfaces.
	IsOper_decl_listContext()
}

type Oper_decl_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOper_decl_listContext() *Oper_decl_listContext {
	var p = new(Oper_decl_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_oper_decl_list
	return p
}

func (*Oper_decl_listContext) IsOper_decl_listContext() {}

func NewOper_decl_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Oper_decl_listContext {
	var p = new(Oper_decl_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_oper_decl_list

	return p
}

func (s *Oper_decl_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Oper_decl_listContext) AllOper_decl() []IOper_declContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOper_declContext)(nil)).Elem())
	var tst = make([]IOper_declContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOper_declContext)
		}
	}

	return tst
}

func (s *Oper_decl_listContext) Oper_decl(i int) IOper_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOper_declContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOper_declContext)
}

func (s *Oper_decl_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Oper_decl_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Oper_decl_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterOper_decl_list(s)
	}
}

func (s *Oper_decl_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitOper_decl_list(s)
	}
}

func (p *cluParser) Oper_decl_list() (localctx IOper_decl_listContext) {
	this := p
	_ = this

	localctx = NewOper_decl_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, cluParserRULE_oper_decl_list)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(264)
		p.Oper_decl()
	}
	p.SetState(269)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 25, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(265)
				p.Match(cluParserT__6)
			}
			{
				p.SetState(266)
				p.Oper_decl()
			}

		}
		p.SetState(271)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 25, p.GetParserRuleContext())
	}

	return localctx
}

// IOper_declContext is an interface to support dynamic dispatch.
type IOper_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOper_declContext differentiates from other interfaces.
	IsOper_declContext()
}

type Oper_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOper_declContext() *Oper_declContext {
	var p = new(Oper_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_oper_decl
	return p
}

func (*Oper_declContext) IsOper_declContext() {}

func NewOper_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Oper_declContext {
	var p = new(Oper_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_oper_decl

	return p
}

func (s *Oper_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Oper_declContext) Op_name_list() IOp_name_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOp_name_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOp_name_listContext)
}

func (s *Oper_declContext) Type_spec() IType_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_specContext)
}

func (s *Oper_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Oper_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Oper_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterOper_decl(s)
	}
}

func (s *Oper_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitOper_decl(s)
	}
}

func (p *cluParser) Oper_decl() (localctx IOper_declContext) {
	this := p
	_ = this

	localctx = NewOper_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, cluParserRULE_oper_decl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(272)
		p.Op_name_list()
	}
	{
		p.SetState(273)
		p.Match(cluParserT__7)
	}
	{
		p.SetState(274)
		p.Type_spec()
	}

	return localctx
}

// IOp_name_listContext is an interface to support dynamic dispatch.
type IOp_name_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOp_name_listContext differentiates from other interfaces.
	IsOp_name_listContext()
}

type Op_name_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOp_name_listContext() *Op_name_listContext {
	var p = new(Op_name_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_op_name_list
	return p
}

func (*Op_name_listContext) IsOp_name_listContext() {}

func NewOp_name_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Op_name_listContext {
	var p = new(Op_name_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_op_name_list

	return p
}

func (s *Op_name_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Op_name_listContext) AllOp_name() []IOp_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOp_nameContext)(nil)).Elem())
	var tst = make([]IOp_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOp_nameContext)
		}
	}

	return tst
}

func (s *Op_name_listContext) Op_name(i int) IOp_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOp_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOp_nameContext)
}

func (s *Op_name_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Op_name_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Op_name_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterOp_name_list(s)
	}
}

func (s *Op_name_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitOp_name_list(s)
	}
}

func (p *cluParser) Op_name_list() (localctx IOp_name_listContext) {
	this := p
	_ = this

	localctx = NewOp_name_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, cluParserRULE_op_name_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(276)
		p.Op_name()
	}
	p.SetState(281)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == cluParserT__6 {
		{
			p.SetState(277)
			p.Match(cluParserT__6)
		}
		{
			p.SetState(278)
			p.Op_name()
		}

		p.SetState(283)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IOp_nameContext is an interface to support dynamic dispatch.
type IOp_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOp_nameContext differentiates from other interfaces.
	IsOp_nameContext()
}

type Op_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOp_nameContext() *Op_nameContext {
	var p = new(Op_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_op_name
	return p
}

func (*Op_nameContext) IsOp_nameContext() {}

func NewOp_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Op_nameContext {
	var p = new(Op_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_op_name

	return p
}

func (s *Op_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Op_nameContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Op_nameContext) Constant_list() IConstant_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_listContext)
}

func (s *Op_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Op_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Op_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterOp_name(s)
	}
}

func (s *Op_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitOp_name(s)
	}
}

func (p *cluParser) Op_name() (localctx IOp_nameContext) {
	this := p
	_ = this

	localctx = NewOp_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, cluParserRULE_op_name)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(284)
		p.Name()
	}
	{
		p.SetState(285)
		p.Match(cluParserT__17)
	}
	p.SetState(287)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-10)&-(0x1f+1)) == 0 && ((1<<uint((_la-10)))&((1<<(cluParserT__9-10))|(1<<(cluParserT__19-10))|(1<<(cluParserT__23-10))|(1<<(cluParserT__24-10))|(1<<(cluParserT__25-10))|(1<<(cluParserT__26-10))|(1<<(cluParserT__27-10))|(1<<(cluParserT__28-10))|(1<<(cluParserT__29-10))|(1<<(cluParserT__30-10))|(1<<(cluParserT__31-10))|(1<<(cluParserT__32-10))|(1<<(cluParserT__33-10))|(1<<(cluParserT__34-10))|(1<<(cluParserT__35-10))|(1<<(cluParserT__36-10))|(1<<(cluParserT__37-10))|(1<<(cluParserT__38-10)))) != 0) || (((_la-61)&-(0x1f+1)) == 0 && ((1<<uint((_la-61)))&((1<<(cluParserT__60-61))|(1<<(cluParserT__61-61))|(1<<(cluParserT__80-61))|(1<<(cluParserT__81-61))|(1<<(cluParserT__82-61))|(1<<(cluParserT__84-61))|(1<<(cluParserT__85-61))|(1<<(cluParserT__86-61))|(1<<(cluParserSTRINGLITERAL-61))|(1<<(cluParserSTRING-61))|(1<<(cluParserINT-61))|(1<<(cluParserFLOAT-61)))) != 0) {
		{
			p.SetState(286)
			p.Constant_list()
		}

	}
	{
		p.SetState(289)
		p.Match(cluParserT__18)
	}

	return localctx
}

// IConstant_listContext is an interface to support dynamic dispatch.
type IConstant_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstant_listContext differentiates from other interfaces.
	IsConstant_listContext()
}

type Constant_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstant_listContext() *Constant_listContext {
	var p = new(Constant_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_constant_list
	return p
}

func (*Constant_listContext) IsConstant_listContext() {}

func NewConstant_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constant_listContext {
	var p = new(Constant_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_constant_list

	return p
}

func (s *Constant_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Constant_listContext) AllConstant() []IConstantContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConstantContext)(nil)).Elem())
	var tst = make([]IConstantContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConstantContext)
		}
	}

	return tst
}

func (s *Constant_listContext) Constant(i int) IConstantContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstantContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *Constant_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constant_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constant_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterConstant_list(s)
	}
}

func (s *Constant_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitConstant_list(s)
	}
}

func (p *cluParser) Constant_list() (localctx IConstant_listContext) {
	this := p
	_ = this

	localctx = NewConstant_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, cluParserRULE_constant_list)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(291)
		p.Constant()
	}
	p.SetState(296)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 28, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(292)
				p.Match(cluParserT__6)
			}
			{
				p.SetState(293)
				p.Constant()
			}

		}
		p.SetState(298)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 28, p.GetParserRuleContext())
	}

	return localctx
}

// IConstantContext is an interface to support dynamic dispatch.
type IConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstantContext differentiates from other interfaces.
	IsConstantContext()
}

type ConstantContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstantContext() *ConstantContext {
	var p = new(ConstantContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_constant
	return p
}

func (*ConstantContext) IsConstantContext() {}

func NewConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantContext {
	var p = new(ConstantContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_constant

	return p
}

func (s *ConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ConstantContext) Type_spec() IType_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_specContext)
}

func (s *ConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterConstant(s)
	}
}

func (s *ConstantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitConstant(s)
	}
}

func (p *cluParser) Constant() (localctx IConstantContext) {
	this := p
	_ = this

	localctx = NewConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, cluParserRULE_constant)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(301)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 29, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(299)
			p.expression(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(300)
			p.Type_spec()
		}

	}

	return localctx
}

// IRoutine_bodyContext is an interface to support dynamic dispatch.
type IRoutine_bodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRoutine_bodyContext differentiates from other interfaces.
	IsRoutine_bodyContext()
}

type Routine_bodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRoutine_bodyContext() *Routine_bodyContext {
	var p = new(Routine_bodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_routine_body
	return p
}

func (*Routine_bodyContext) IsRoutine_bodyContext() {}

func NewRoutine_bodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Routine_bodyContext {
	var p = new(Routine_bodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_routine_body

	return p
}

func (s *Routine_bodyContext) GetParser() antlr.Parser { return s.parser }

func (s *Routine_bodyContext) AllEquate() []IEquateContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEquateContext)(nil)).Elem())
	var tst = make([]IEquateContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEquateContext)
		}
	}

	return tst
}

func (s *Routine_bodyContext) Equate(i int) IEquateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEquateContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEquateContext)
}

func (s *Routine_bodyContext) AllOwn_var() []IOwn_varContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOwn_varContext)(nil)).Elem())
	var tst = make([]IOwn_varContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOwn_varContext)
		}
	}

	return tst
}

func (s *Routine_bodyContext) Own_var(i int) IOwn_varContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOwn_varContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOwn_varContext)
}

func (s *Routine_bodyContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *Routine_bodyContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *Routine_bodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Routine_bodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Routine_bodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterRoutine_body(s)
	}
}

func (s *Routine_bodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitRoutine_body(s)
	}
}

func (p *cluParser) Routine_body() (localctx IRoutine_bodyContext) {
	this := p
	_ = this

	localctx = NewRoutine_bodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, cluParserRULE_routine_body)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(306)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 30, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(303)
				p.Equate()
			}

		}
		p.SetState(308)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 30, p.GetParserRuleContext())
	}
	p.SetState(312)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == cluParserT__21 {
		{
			p.SetState(309)
			p.Own_var()
		}

		p.SetState(314)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(318)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<cluParserT__19)|(1<<cluParserT__23)|(1<<cluParserT__24)|(1<<cluParserT__25)|(1<<cluParserT__26)|(1<<cluParserT__27)|(1<<cluParserT__28)|(1<<cluParserT__29)|(1<<cluParserT__30))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(cluParserT__31-32))|(1<<(cluParserT__32-32))|(1<<(cluParserT__33-32))|(1<<(cluParserT__34-32))|(1<<(cluParserT__35-32))|(1<<(cluParserT__36-32))|(1<<(cluParserT__37-32))|(1<<(cluParserT__38-32))|(1<<(cluParserT__40-32))|(1<<(cluParserT__42-32))|(1<<(cluParserT__43-32))|(1<<(cluParserT__47-32))|(1<<(cluParserT__49-32))|(1<<(cluParserT__50-32))|(1<<(cluParserT__51-32))|(1<<(cluParserT__52-32))|(1<<(cluParserT__53-32))|(1<<(cluParserT__54-32)))) != 0) || (((_la-81)&-(0x1f+1)) == 0 && ((1<<uint((_la-81)))&((1<<(cluParserT__80-81))|(1<<(cluParserT__81-81))|(1<<(cluParserT__82-81))|(1<<(cluParserT__84-81))|(1<<(cluParserT__85-81))|(1<<(cluParserT__86-81))|(1<<(cluParserSTRINGLITERAL-81))|(1<<(cluParserSTRING-81))|(1<<(cluParserINT-81))|(1<<(cluParserFLOAT-81)))) != 0) {
		{
			p.SetState(315)
			p.statement(0)
		}

		p.SetState(320)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ICluster_bodyContext is an interface to support dynamic dispatch.
type ICluster_bodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCluster_bodyContext differentiates from other interfaces.
	IsCluster_bodyContext()
}

type Cluster_bodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCluster_bodyContext() *Cluster_bodyContext {
	var p = new(Cluster_bodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_cluster_body
	return p
}

func (*Cluster_bodyContext) IsCluster_bodyContext() {}

func NewCluster_bodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cluster_bodyContext {
	var p = new(Cluster_bodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_cluster_body

	return p
}

func (s *Cluster_bodyContext) GetParser() antlr.Parser { return s.parser }

func (s *Cluster_bodyContext) Type_spec() IType_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_specContext)
}

func (s *Cluster_bodyContext) AllEquate() []IEquateContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEquateContext)(nil)).Elem())
	var tst = make([]IEquateContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEquateContext)
		}
	}

	return tst
}

func (s *Cluster_bodyContext) Equate(i int) IEquateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEquateContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEquateContext)
}

func (s *Cluster_bodyContext) AllOwn_var() []IOwn_varContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOwn_varContext)(nil)).Elem())
	var tst = make([]IOwn_varContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOwn_varContext)
		}
	}

	return tst
}

func (s *Cluster_bodyContext) Own_var(i int) IOwn_varContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOwn_varContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOwn_varContext)
}

func (s *Cluster_bodyContext) AllRoutine() []IRoutineContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRoutineContext)(nil)).Elem())
	var tst = make([]IRoutineContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRoutineContext)
		}
	}

	return tst
}

func (s *Cluster_bodyContext) Routine(i int) IRoutineContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRoutineContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRoutineContext)
}

func (s *Cluster_bodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cluster_bodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cluster_bodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterCluster_body(s)
	}
}

func (s *Cluster_bodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitCluster_body(s)
	}
}

func (p *cluParser) Cluster_body() (localctx ICluster_bodyContext) {
	this := p
	_ = this

	localctx = NewCluster_bodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, cluParserRULE_cluster_body)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(324)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == cluParserSTRING {
		{
			p.SetState(321)
			p.Equate()
		}

		p.SetState(326)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(327)
		p.Match(cluParserT__19)
	}
	{
		p.SetState(328)
		p.Match(cluParserT__0)
	}
	{
		p.SetState(329)
		p.Type_spec()
	}
	p.SetState(333)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == cluParserSTRING {
		{
			p.SetState(330)
			p.Equate()
		}

		p.SetState(335)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(339)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == cluParserT__21 {
		{
			p.SetState(336)
			p.Own_var()
		}

		p.SetState(341)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(342)
		p.Match(cluParserT__20)
	}
	p.SetState(346)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == cluParserSTRING {
		{
			p.SetState(343)
			p.Routine()
		}

		p.SetState(348)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IRoutineContext is an interface to support dynamic dispatch.
type IRoutineContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRoutineContext differentiates from other interfaces.
	IsRoutineContext()
}

type RoutineContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRoutineContext() *RoutineContext {
	var p = new(RoutineContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_routine
	return p
}

func (*RoutineContext) IsRoutineContext() {}

func NewRoutineContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RoutineContext {
	var p = new(RoutineContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_routine

	return p
}

func (s *RoutineContext) GetParser() antlr.Parser { return s.parser }

func (s *RoutineContext) Procedure() IProcedureContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedureContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedureContext)
}

func (s *RoutineContext) Iterator() IIteratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIteratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIteratorContext)
}

func (s *RoutineContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoutineContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RoutineContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterRoutine(s)
	}
}

func (s *RoutineContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitRoutine(s)
	}
}

func (p *cluParser) Routine() (localctx IRoutineContext) {
	this := p
	_ = this

	localctx = NewRoutineContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, cluParserRULE_routine)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(351)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 37, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(349)
			p.Procedure()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(350)
			p.Iterator()
		}

	}

	return localctx
}

// IEquateContext is an interface to support dynamic dispatch.
type IEquateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEquateContext differentiates from other interfaces.
	IsEquateContext()
}

type EquateContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEquateContext() *EquateContext {
	var p = new(EquateContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_equate
	return p
}

func (*EquateContext) IsEquateContext() {}

func NewEquateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EquateContext {
	var p = new(EquateContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_equate

	return p
}

func (s *EquateContext) GetParser() antlr.Parser { return s.parser }

func (s *EquateContext) Idn() IIdnContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdnContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdnContext)
}

func (s *EquateContext) Constant() IConstantContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstantContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *EquateContext) Type_set() IType_setContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_setContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_setContext)
}

func (s *EquateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EquateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EquateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterEquate(s)
	}
}

func (s *EquateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitEquate(s)
	}
}

func (p *cluParser) Equate() (localctx IEquateContext) {
	this := p
	_ = this

	localctx = NewEquateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, cluParserRULE_equate)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(353)
		p.Idn()
	}
	{
		p.SetState(354)
		p.Match(cluParserT__0)
	}
	p.SetState(357)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 38, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(355)
			p.Constant()
		}

	case 2:
		{
			p.SetState(356)
			p.Type_set()
		}

	}

	return localctx
}

// IOwn_varContext is an interface to support dynamic dispatch.
type IOwn_varContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOwn_varContext differentiates from other interfaces.
	IsOwn_varContext()
}

type Own_varContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOwn_varContext() *Own_varContext {
	var p = new(Own_varContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_own_var
	return p
}

func (*Own_varContext) IsOwn_varContext() {}

func NewOwn_varContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Own_varContext {
	var p = new(Own_varContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_own_var

	return p
}

func (s *Own_varContext) GetParser() antlr.Parser { return s.parser }

func (s *Own_varContext) Decl() IDeclContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclContext)
}

func (s *Own_varContext) Idn() IIdnContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdnContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdnContext)
}

func (s *Own_varContext) Type_spec() IType_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_specContext)
}

func (s *Own_varContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Own_varContext) Decl_list() IDecl_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDecl_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDecl_listContext)
}

func (s *Own_varContext) Invocation() IInvocationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInvocationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInvocationContext)
}

func (s *Own_varContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Own_varContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Own_varContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterOwn_var(s)
	}
}

func (s *Own_varContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitOwn_var(s)
	}
}

func (p *cluParser) Own_var() (localctx IOwn_varContext) {
	this := p
	_ = this

	localctx = NewOwn_varContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, cluParserRULE_own_var)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(359)
		p.Match(cluParserT__21)
	}
	p.SetState(371)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 39, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(360)
			p.Decl()
		}

	case 2:
		{
			p.SetState(361)
			p.Idn()
		}
		{
			p.SetState(362)
			p.Match(cluParserT__7)
		}
		{
			p.SetState(363)
			p.Type_spec()
		}
		{
			p.SetState(364)
			p.Match(cluParserT__22)
		}
		{
			p.SetState(365)
			p.expression(0)
		}

	case 3:
		{
			p.SetState(367)
			p.Decl_list()
		}
		{
			p.SetState(368)
			p.Match(cluParserT__22)
		}
		{
			p.SetState(369)
			p.Invocation()
		}

	}

	return localctx
}

// IType_specContext is an interface to support dynamic dispatch.
type IType_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsType_specContext differentiates from other interfaces.
	IsType_specContext()
}

type Type_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_specContext() *Type_specContext {
	var p = new(Type_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_type_spec
	return p
}

func (*Type_specContext) IsType_specContext() {}

func NewType_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_specContext {
	var p = new(Type_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_type_spec

	return p
}

func (s *Type_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_specContext) Type_spec() IType_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_specContext)
}

func (s *Type_specContext) Field_spec_list() IField_spec_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IField_spec_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IField_spec_listContext)
}

func (s *Type_specContext) Returnz() IReturnzContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReturnzContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReturnzContext)
}

func (s *Type_specContext) Signals() ISignalsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISignalsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISignalsContext)
}

func (s *Type_specContext) Idn() IIdnContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdnContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdnContext)
}

func (s *Type_specContext) Constant_list() IConstant_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_listContext)
}

func (s *Type_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterType_spec(s)
	}
}

func (s *Type_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitType_spec(s)
	}
}

func (p *cluParser) Type_spec() (localctx IType_specContext) {
	this := p
	_ = this

	localctx = NewType_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, cluParserRULE_type_spec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(405)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case cluParserT__23:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(373)
			p.Match(cluParserT__23)
		}

	case cluParserT__24:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(374)
			p.Match(cluParserT__24)
		}

	case cluParserT__25:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(375)
			p.Match(cluParserT__25)
		}

	case cluParserT__26:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(376)
			p.Match(cluParserT__26)
		}

	case cluParserT__27:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(377)
			p.Match(cluParserT__27)
		}

	case cluParserT__28:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(378)
			p.Match(cluParserT__28)
		}

	case cluParserT__29:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(379)
			p.Match(cluParserT__29)
		}

	case cluParserT__19:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(380)
			p.Match(cluParserT__19)
		}

	case cluParserT__30:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(381)
			p.Match(cluParserT__30)
		}

	case cluParserT__31:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(382)
			p.Match(cluParserT__31)
		}

	case cluParserT__32:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(383)
			p.Match(cluParserT__32)
		}
		p.SetState(385)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 40, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(384)
				p.Type_spec()
			}

		}

	case cluParserT__33, cluParserT__34, cluParserT__35, cluParserT__36:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(387)
			_la = p.GetTokenStream().LA(1)

			if !(((_la-34)&-(0x1f+1)) == 0 && ((1<<uint((_la-34)))&((1<<(cluParserT__33-34))|(1<<(cluParserT__34-34))|(1<<(cluParserT__35-34))|(1<<(cluParserT__36-34)))) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(389)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 41, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(388)
				p.Field_spec_list()
			}

		}

	case cluParserT__37, cluParserT__38:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(391)
			_la = p.GetTokenStream().LA(1)

			if !(_la == cluParserT__37 || _la == cluParserT__38) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(393)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 42, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(392)
				p.Field_spec_list()
			}

		}
		p.SetState(396)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 43, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(395)
				p.Returnz()
			}

		}
		p.SetState(399)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 44, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(398)
				p.Signals()
			}

		}

	case cluParserSTRING:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(401)
			p.Idn()
		}
		p.SetState(403)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 45, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(402)
				p.Constant_list()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IField_spec_listContext is an interface to support dynamic dispatch.
type IField_spec_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsField_spec_listContext differentiates from other interfaces.
	IsField_spec_listContext()
}

type Field_spec_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyField_spec_listContext() *Field_spec_listContext {
	var p = new(Field_spec_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_field_spec_list
	return p
}

func (*Field_spec_listContext) IsField_spec_listContext() {}

func NewField_spec_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Field_spec_listContext {
	var p = new(Field_spec_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_field_spec_list

	return p
}

func (s *Field_spec_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Field_spec_listContext) AllField_spec() []IField_specContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IField_specContext)(nil)).Elem())
	var tst = make([]IField_specContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IField_specContext)
		}
	}

	return tst
}

func (s *Field_spec_listContext) Field_spec(i int) IField_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IField_specContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IField_specContext)
}

func (s *Field_spec_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Field_spec_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Field_spec_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterField_spec_list(s)
	}
}

func (s *Field_spec_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitField_spec_list(s)
	}
}

func (p *cluParser) Field_spec_list() (localctx IField_spec_listContext) {
	this := p
	_ = this

	localctx = NewField_spec_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, cluParserRULE_field_spec_list)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(407)
		p.Field_spec()
	}
	p.SetState(412)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 47, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(408)
				p.Match(cluParserT__6)
			}
			{
				p.SetState(409)
				p.Field_spec()
			}

		}
		p.SetState(414)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 47, p.GetParserRuleContext())
	}

	return localctx
}

// IField_specContext is an interface to support dynamic dispatch.
type IField_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsField_specContext differentiates from other interfaces.
	IsField_specContext()
}

type Field_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyField_specContext() *Field_specContext {
	var p = new(Field_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_field_spec
	return p
}

func (*Field_specContext) IsField_specContext() {}

func NewField_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Field_specContext {
	var p = new(Field_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_field_spec

	return p
}

func (s *Field_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Field_specContext) Name_list() IName_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_listContext)
}

func (s *Field_specContext) Type_spec() IType_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_specContext)
}

func (s *Field_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Field_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Field_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterField_spec(s)
	}
}

func (s *Field_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitField_spec(s)
	}
}

func (p *cluParser) Field_spec() (localctx IField_specContext) {
	this := p
	_ = this

	localctx = NewField_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, cluParserRULE_field_spec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(415)
		p.Name_list()
	}
	{
		p.SetState(416)
		p.Match(cluParserT__7)
	}
	{
		p.SetState(417)
		p.Type_spec()
	}

	return localctx
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_statement
	return p
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) Decl() IDeclContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclContext)
}

func (s *StatementContext) Idn() IIdnContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdnContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdnContext)
}

func (s *StatementContext) Type_spec() IType_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_specContext)
}

func (s *StatementContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *StatementContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *StatementContext) Decl_list() IDecl_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDecl_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDecl_listContext)
}

func (s *StatementContext) Invocation() IInvocationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInvocationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInvocationContext)
}

func (s *StatementContext) Idn_list() IIdn_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdn_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdn_listContext)
}

func (s *StatementContext) Expression_list() IExpression_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpression_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpression_listContext)
}

func (s *StatementContext) Primary() IPrimaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimaryContext)
}

func (s *StatementContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *StatementContext) AllBody() []IBodyContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBodyContext)(nil)).Elem())
	var tst = make([]IBodyContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBodyContext)
		}
	}

	return tst
}

func (s *StatementContext) Body(i int) IBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBodyContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBodyContext)
}

func (s *StatementContext) AllTag_arm() []ITag_armContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITag_armContext)(nil)).Elem())
	var tst = make([]ITag_armContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITag_armContext)
		}
	}

	return tst
}

func (s *StatementContext) Tag_arm(i int) ITag_armContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITag_armContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITag_armContext)
}

func (s *StatementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *StatementContext) Name_list() IName_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_listContext)
}

func (s *StatementContext) AllWhen_handler() []IWhen_handlerContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWhen_handlerContext)(nil)).Elem())
	var tst = make([]IWhen_handlerContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWhen_handlerContext)
		}
	}

	return tst
}

func (s *StatementContext) When_handler(i int) IWhen_handlerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhen_handlerContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWhen_handlerContext)
}

func (s *StatementContext) Others_handler() IOthers_handlerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOthers_handlerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOthers_handlerContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterStatement(s)
	}
}

func (s *StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitStatement(s)
	}
}

func (p *cluParser) Statement() (localctx IStatementContext) {
	return p.statement(0)
}

func (p *cluParser) statement(_p int) (localctx IStatementContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewStatementContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IStatementContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 62
	p.EnterRecursionRule(localctx, 62, cluParserRULE_statement, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(515)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 57, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(420)
			p.Decl()
		}

	case 2:
		{
			p.SetState(421)
			p.Idn()
		}
		{
			p.SetState(422)
			p.Match(cluParserT__7)
		}
		{
			p.SetState(423)
			p.Type_spec()
		}
		{
			p.SetState(424)
			p.Match(cluParserT__22)
		}
		{
			p.SetState(425)
			p.expression(0)
		}

	case 3:
		{
			p.SetState(427)
			p.Decl_list()
		}
		{
			p.SetState(428)
			p.Match(cluParserT__22)
		}
		{
			p.SetState(429)
			p.Invocation()
		}

	case 4:
		{
			p.SetState(431)
			p.Idn_list()
		}
		{
			p.SetState(432)
			p.Match(cluParserT__22)
		}
		p.SetState(435)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 48, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(433)
				p.Invocation()
			}

		case 2:
			{
				p.SetState(434)
				p.Expression_list()
			}

		}

	case 5:
		{
			p.SetState(437)
			p.primary(0)
		}
		{
			p.SetState(438)
			p.Match(cluParserT__39)
		}
		{
			p.SetState(439)
			p.Name()
		}
		{
			p.SetState(440)
			p.Match(cluParserT__22)
		}
		{
			p.SetState(441)
			p.expression(0)
		}

	case 6:
		{
			p.SetState(443)
			p.Invocation()
		}

	case 7:
		{
			p.SetState(444)
			p.Match(cluParserT__40)
		}
		{
			p.SetState(445)
			p.expression(0)
		}
		{
			p.SetState(446)
			p.Match(cluParserT__41)
		}
		{
			p.SetState(447)
			p.Body()
		}
		{
			p.SetState(448)
			p.Match(cluParserT__2)
		}

	case 8:
		{
			p.SetState(450)
			p.Match(cluParserT__42)
		}
		p.SetState(453)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 49, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(451)
				p.Decl_list()
			}

		} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 49, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(452)
				p.Idn_list()
			}

		}
		{
			p.SetState(455)
			p.Match(cluParserT__16)
		}
		{
			p.SetState(456)
			p.Invocation()
		}
		{
			p.SetState(457)
			p.Match(cluParserT__41)
		}
		{
			p.SetState(458)
			p.Body()
		}
		{
			p.SetState(459)
			p.Match(cluParserT__2)
		}

	case 9:
		{
			p.SetState(461)
			p.Match(cluParserT__43)
		}
		{
			p.SetState(462)
			p.expression(0)
		}
		{
			p.SetState(463)
			p.Match(cluParserT__44)
		}
		{
			p.SetState(464)
			p.Body()
		}
		p.SetState(472)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == cluParserT__45 {
			{
				p.SetState(465)
				p.Match(cluParserT__45)
			}
			{
				p.SetState(466)
				p.expression(0)
			}
			{
				p.SetState(467)
				p.Match(cluParserT__44)
			}
			{
				p.SetState(468)
				p.Body()
			}

			p.SetState(474)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(477)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == cluParserT__46 {
			{
				p.SetState(475)
				p.Match(cluParserT__46)
			}
			{
				p.SetState(476)
				p.Body()
			}

		}
		{
			p.SetState(479)
			p.Match(cluParserT__2)
		}

	case 10:
		{
			p.SetState(481)
			p.Match(cluParserT__47)
		}
		{
			p.SetState(482)
			p.expression(0)
		}
		p.SetState(486)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == cluParserT__57 {
			{
				p.SetState(483)
				p.Tag_arm()
			}

			p.SetState(488)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(492)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == cluParserT__48 {
			{
				p.SetState(489)
				p.Match(cluParserT__48)
			}
			{
				p.SetState(490)
				p.Match(cluParserT__7)
			}
			{
				p.SetState(491)
				p.Body()
			}

		}
		{
			p.SetState(494)
			p.Match(cluParserT__2)
		}

	case 11:
		{
			p.SetState(496)
			_la = p.GetTokenStream().LA(1)

			if !(_la == cluParserT__49 || _la == cluParserT__50) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(498)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 54, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(497)
				p.Expression_list()
			}

		}

	case 12:
		{
			p.SetState(500)
			p.Match(cluParserT__51)
		}
		{
			p.SetState(501)
			p.Name()
		}
		p.SetState(503)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 55, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(502)
				p.Expression_list()
			}

		}

	case 13:
		{
			p.SetState(505)
			p.Match(cluParserT__52)
		}
		{
			p.SetState(506)
			p.Name()
		}
		p.SetState(508)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 56, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(507)
				p.Expression_list()
			}

		}

	case 14:
		{
			p.SetState(510)
			p.Match(cluParserT__53)
		}

	case 15:
		{
			p.SetState(511)
			p.Match(cluParserT__54)
		}
		{
			p.SetState(512)
			p.Body()
		}
		{
			p.SetState(513)
			p.Match(cluParserT__2)
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(535)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 61, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewStatementContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, cluParserRULE_statement)
			p.SetState(517)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			p.SetState(531)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case cluParserT__55:
				{
					p.SetState(518)
					p.Match(cluParserT__55)
				}
				{
					p.SetState(519)
					p.Name_list()
				}

			case cluParserT__56:
				{
					p.SetState(520)
					p.Match(cluParserT__56)
				}
				p.SetState(524)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				for _la == cluParserT__58 {
					{
						p.SetState(521)
						p.When_handler()
					}

					p.SetState(526)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)
				}
				p.SetState(528)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == cluParserT__48 {
					{
						p.SetState(527)
						p.Others_handler()
					}

				}
				{
					p.SetState(530)
					p.Match(cluParserT__2)
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		}
		p.SetState(537)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 61, p.GetParserRuleContext())
	}

	return localctx
}

// ITag_armContext is an interface to support dynamic dispatch.
type ITag_armContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTag_armContext differentiates from other interfaces.
	IsTag_armContext()
}

type Tag_armContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTag_armContext() *Tag_armContext {
	var p = new(Tag_armContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_tag_arm
	return p
}

func (*Tag_armContext) IsTag_armContext() {}

func NewTag_armContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tag_armContext {
	var p = new(Tag_armContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_tag_arm

	return p
}

func (s *Tag_armContext) GetParser() antlr.Parser { return s.parser }

func (s *Tag_armContext) Name_list() IName_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_listContext)
}

func (s *Tag_armContext) Body() IBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBodyContext)
}

func (s *Tag_armContext) Idn() IIdnContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdnContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdnContext)
}

func (s *Tag_armContext) Type_spec() IType_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_specContext)
}

func (s *Tag_armContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tag_armContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tag_armContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterTag_arm(s)
	}
}

func (s *Tag_armContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitTag_arm(s)
	}
}

func (p *cluParser) Tag_arm() (localctx ITag_armContext) {
	this := p
	_ = this

	localctx = NewTag_armContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, cluParserRULE_tag_arm)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(538)
		p.Match(cluParserT__57)
	}
	{
		p.SetState(539)
		p.Name_list()
	}
	p.SetState(546)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == cluParserT__9 {
		{
			p.SetState(540)
			p.Match(cluParserT__9)
		}
		{
			p.SetState(541)
			p.Idn()
		}
		{
			p.SetState(542)
			p.Match(cluParserT__7)
		}
		{
			p.SetState(543)
			p.Type_spec()
		}
		{
			p.SetState(544)
			p.Match(cluParserT__10)
		}

	}
	{
		p.SetState(548)
		p.Match(cluParserT__7)
	}
	{
		p.SetState(549)
		p.Body()
	}

	return localctx
}

// IWhen_handlerContext is an interface to support dynamic dispatch.
type IWhen_handlerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWhen_handlerContext differentiates from other interfaces.
	IsWhen_handlerContext()
}

type When_handlerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhen_handlerContext() *When_handlerContext {
	var p = new(When_handlerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_when_handler
	return p
}

func (*When_handlerContext) IsWhen_handlerContext() {}

func NewWhen_handlerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *When_handlerContext {
	var p = new(When_handlerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_when_handler

	return p
}

func (s *When_handlerContext) GetParser() antlr.Parser { return s.parser }

func (s *When_handlerContext) Name_list() IName_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_listContext)
}

func (s *When_handlerContext) Body() IBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBodyContext)
}

func (s *When_handlerContext) Decl_list() IDecl_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDecl_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDecl_listContext)
}

func (s *When_handlerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *When_handlerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *When_handlerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterWhen_handler(s)
	}
}

func (s *When_handlerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitWhen_handler(s)
	}
}

func (p *cluParser) When_handler() (localctx IWhen_handlerContext) {
	this := p
	_ = this

	localctx = NewWhen_handlerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, cluParserRULE_when_handler)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(551)
		p.Match(cluParserT__58)
	}
	{
		p.SetState(552)
		p.Name_list()
	}
	p.SetState(559)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case cluParserT__9:
		{
			p.SetState(553)
			p.Match(cluParserT__9)
		}
		{
			p.SetState(554)
			p.Match(cluParserT__59)
		}
		{
			p.SetState(555)
			p.Match(cluParserT__10)
		}

	case cluParserT__7, cluParserSTRING:
		p.SetState(557)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == cluParserSTRING {
			{
				p.SetState(556)
				p.Decl_list()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(561)
		p.Match(cluParserT__7)
	}
	{
		p.SetState(562)
		p.Body()
	}

	return localctx
}

// IOthers_handlerContext is an interface to support dynamic dispatch.
type IOthers_handlerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOthers_handlerContext differentiates from other interfaces.
	IsOthers_handlerContext()
}

type Others_handlerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOthers_handlerContext() *Others_handlerContext {
	var p = new(Others_handlerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_others_handler
	return p
}

func (*Others_handlerContext) IsOthers_handlerContext() {}

func NewOthers_handlerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Others_handlerContext {
	var p = new(Others_handlerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_others_handler

	return p
}

func (s *Others_handlerContext) GetParser() antlr.Parser { return s.parser }

func (s *Others_handlerContext) Body() IBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBodyContext)
}

func (s *Others_handlerContext) Idn() IIdnContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdnContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdnContext)
}

func (s *Others_handlerContext) Type_spec() IType_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_specContext)
}

func (s *Others_handlerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Others_handlerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Others_handlerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterOthers_handler(s)
	}
}

func (s *Others_handlerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitOthers_handler(s)
	}
}

func (p *cluParser) Others_handler() (localctx IOthers_handlerContext) {
	this := p
	_ = this

	localctx = NewOthers_handlerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, cluParserRULE_others_handler)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(564)
		p.Match(cluParserT__48)
	}
	p.SetState(571)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == cluParserT__9 {
		{
			p.SetState(565)
			p.Match(cluParserT__9)
		}
		{
			p.SetState(566)
			p.Idn()
		}
		{
			p.SetState(567)
			p.Match(cluParserT__7)
		}
		{
			p.SetState(568)
			p.Type_spec()
		}
		{
			p.SetState(569)
			p.Match(cluParserT__10)
		}

	}
	{
		p.SetState(573)
		p.Match(cluParserT__7)
	}
	{
		p.SetState(574)
		p.Body()
	}

	return localctx
}

// IBodyContext is an interface to support dynamic dispatch.
type IBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBodyContext differentiates from other interfaces.
	IsBodyContext()
}

type BodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBodyContext() *BodyContext {
	var p = new(BodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_body
	return p
}

func (*BodyContext) IsBodyContext() {}

func NewBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BodyContext {
	var p = new(BodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_body

	return p
}

func (s *BodyContext) GetParser() antlr.Parser { return s.parser }

func (s *BodyContext) AllEquate() []IEquateContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEquateContext)(nil)).Elem())
	var tst = make([]IEquateContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEquateContext)
		}
	}

	return tst
}

func (s *BodyContext) Equate(i int) IEquateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEquateContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEquateContext)
}

func (s *BodyContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *BodyContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *BodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterBody(s)
	}
}

func (s *BodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitBody(s)
	}
}

func (p *cluParser) Body() (localctx IBodyContext) {
	this := p
	_ = this

	localctx = NewBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, cluParserRULE_body)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(579)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 66, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(576)
				p.Equate()
			}

		}
		p.SetState(581)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 66, p.GetParserRuleContext())
	}
	p.SetState(585)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<cluParserT__19)|(1<<cluParserT__23)|(1<<cluParserT__24)|(1<<cluParserT__25)|(1<<cluParserT__26)|(1<<cluParserT__27)|(1<<cluParserT__28)|(1<<cluParserT__29)|(1<<cluParserT__30))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(cluParserT__31-32))|(1<<(cluParserT__32-32))|(1<<(cluParserT__33-32))|(1<<(cluParserT__34-32))|(1<<(cluParserT__35-32))|(1<<(cluParserT__36-32))|(1<<(cluParserT__37-32))|(1<<(cluParserT__38-32))|(1<<(cluParserT__40-32))|(1<<(cluParserT__42-32))|(1<<(cluParserT__43-32))|(1<<(cluParserT__47-32))|(1<<(cluParserT__49-32))|(1<<(cluParserT__50-32))|(1<<(cluParserT__51-32))|(1<<(cluParserT__52-32))|(1<<(cluParserT__53-32))|(1<<(cluParserT__54-32)))) != 0) || (((_la-81)&-(0x1f+1)) == 0 && ((1<<uint((_la-81)))&((1<<(cluParserT__80-81))|(1<<(cluParserT__81-81))|(1<<(cluParserT__82-81))|(1<<(cluParserT__84-81))|(1<<(cluParserT__85-81))|(1<<(cluParserT__86-81))|(1<<(cluParserSTRINGLITERAL-81))|(1<<(cluParserSTRING-81))|(1<<(cluParserINT-81))|(1<<(cluParserFLOAT-81)))) != 0) {
		{
			p.SetState(582)
			p.statement(0)
		}

		p.SetState(587)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IExpression_listContext is an interface to support dynamic dispatch.
type IExpression_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpression_listContext differentiates from other interfaces.
	IsExpression_listContext()
}

type Expression_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpression_listContext() *Expression_listContext {
	var p = new(Expression_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_expression_list
	return p
}

func (*Expression_listContext) IsExpression_listContext() {}

func NewExpression_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expression_listContext {
	var p = new(Expression_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_expression_list

	return p
}

func (s *Expression_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Expression_listContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *Expression_listContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Expression_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expression_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expression_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterExpression_list(s)
	}
}

func (s *Expression_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitExpression_list(s)
	}
}

func (p *cluParser) Expression_list() (localctx IExpression_listContext) {
	this := p
	_ = this

	localctx = NewExpression_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, cluParserRULE_expression_list)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(588)
		p.expression(0)
	}
	p.SetState(593)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 68, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(589)
				p.Match(cluParserT__6)
			}
			{
				p.SetState(590)
				p.expression(0)
			}

		}
		p.SetState(595)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 68, p.GetParserRuleContext())
	}

	return localctx
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_expression
	return p
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) Primary() IPrimaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimaryContext)
}

func (s *ExpressionContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *ExpressionContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterExpression(s)
	}
}

func (s *ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitExpression(s)
	}
}

func (p *cluParser) Expression() (localctx IExpressionContext) {
	return p.expression(0)
}

func (p *cluParser) expression(_p int) (localctx IExpressionContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 74
	p.EnterRecursionRule(localctx, 74, cluParserRULE_expression, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(604)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case cluParserT__19, cluParserT__23, cluParserT__24, cluParserT__25, cluParserT__26, cluParserT__27, cluParserT__28, cluParserT__29, cluParserT__30, cluParserT__31, cluParserT__32, cluParserT__33, cluParserT__34, cluParserT__35, cluParserT__36, cluParserT__37, cluParserT__38, cluParserT__80, cluParserT__81, cluParserT__82, cluParserT__84, cluParserT__85, cluParserT__86, cluParserSTRINGLITERAL, cluParserSTRING, cluParserINT, cluParserFLOAT:
		{
			p.SetState(597)
			p.primary(0)
		}

	case cluParserT__9:
		{
			p.SetState(598)
			p.Match(cluParserT__9)
		}
		{
			p.SetState(599)
			p.expression(0)
		}
		{
			p.SetState(600)
			p.Match(cluParserT__10)
		}

	case cluParserT__60, cluParserT__61:
		{
			p.SetState(602)
			_la = p.GetTokenStream().LA(1)

			if !(_la == cluParserT__60 || _la == cluParserT__61) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(603)
			p.expression(7)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(626)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 71, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(624)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 70, p.GetParserRuleContext()) {
			case 1:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, cluParserRULE_expression)
				p.SetState(606)

				if !(p.Precpred(p.GetParserRuleContext(), 6)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
				}
				{
					p.SetState(607)
					p.Match(cluParserT__62)
				}
				{
					p.SetState(608)
					p.expression(7)
				}

			case 2:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, cluParserRULE_expression)
				p.SetState(609)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
				}
				{
					p.SetState(610)
					_la = p.GetTokenStream().LA(1)

					if !(((_la-60)&-(0x1f+1)) == 0 && ((1<<uint((_la-60)))&((1<<(cluParserT__59-60))|(1<<(cluParserT__63-60))|(1<<(cluParserT__64-60)))) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(611)
					p.expression(6)
				}

			case 3:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, cluParserRULE_expression)
				p.SetState(612)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
				}
				{
					p.SetState(613)
					_la = p.GetTokenStream().LA(1)

					if !(((_la-62)&-(0x1f+1)) == 0 && ((1<<uint((_la-62)))&((1<<(cluParserT__61-62))|(1<<(cluParserT__65-62))|(1<<(cluParserT__66-62)))) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(614)
					p.expression(5)
				}

			case 4:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, cluParserRULE_expression)
				p.SetState(615)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				}
				{
					p.SetState(616)
					_la = p.GetTokenStream().LA(1)

					if !(_la == cluParserT__0 || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(cluParserT__67-68))|(1<<(cluParserT__68-68))|(1<<(cluParserT__69-68))|(1<<(cluParserT__70-68))|(1<<(cluParserT__71-68))|(1<<(cluParserT__72-68))|(1<<(cluParserT__73-68))|(1<<(cluParserT__74-68))|(1<<(cluParserT__75-68)))) != 0)) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(617)
					p.expression(4)
				}

			case 5:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, cluParserRULE_expression)
				p.SetState(618)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(619)
					_la = p.GetTokenStream().LA(1)

					if !(_la == cluParserT__76 || _la == cluParserT__77) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(620)
					p.expression(3)
				}

			case 6:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, cluParserRULE_expression)
				p.SetState(621)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				}
				{
					p.SetState(622)
					_la = p.GetTokenStream().LA(1)

					if !(_la == cluParserT__78 || _la == cluParserT__79) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(623)
					p.expression(2)
				}

			}

		}
		p.SetState(628)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 71, p.GetParserRuleContext())
	}

	return localctx
}

// IPrimaryContext is an interface to support dynamic dispatch.
type IPrimaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimaryContext differentiates from other interfaces.
	IsPrimaryContext()
}

type PrimaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryContext() *PrimaryContext {
	var p = new(PrimaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_primary
	return p
}

func (*PrimaryContext) IsPrimaryContext() {}

func NewPrimaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryContext {
	var p = new(PrimaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_primary

	return p
}

func (s *PrimaryContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryContext) Int_literal() IInt_literalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInt_literalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInt_literalContext)
}

func (s *PrimaryContext) Real_literal() IReal_literalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReal_literalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReal_literalContext)
}

func (s *PrimaryContext) String_literal() IString_literalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IString_literalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IString_literalContext)
}

func (s *PrimaryContext) Idn() IIdnContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdnContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdnContext)
}

func (s *PrimaryContext) Constant_list() IConstant_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_listContext)
}

func (s *PrimaryContext) Type_spec() IType_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_specContext)
}

func (s *PrimaryContext) Field_list() IField_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IField_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IField_listContext)
}

func (s *PrimaryContext) Expression_list() IExpression_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpression_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpression_listContext)
}

func (s *PrimaryContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *PrimaryContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PrimaryContext) Primary() IPrimaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimaryContext)
}

func (s *PrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterPrimary(s)
	}
}

func (s *PrimaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitPrimary(s)
	}
}

func (p *cluParser) Primary() (localctx IPrimaryContext) {
	return p.primary(0)
}

func (p *cluParser) primary(_p int) (localctx IPrimaryContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewPrimaryContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IPrimaryContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 76
	p.EnterRecursionRule(localctx, 76, cluParserRULE_primary, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(667)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 77, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(630)
			p.Match(cluParserT__80)
		}

	case 2:
		{
			p.SetState(631)
			p.Match(cluParserT__81)
		}

	case 3:
		{
			p.SetState(632)
			p.Match(cluParserT__82)
		}

	case 4:
		{
			p.SetState(633)
			p.Int_literal()
		}

	case 5:
		{
			p.SetState(634)
			p.Real_literal()
		}

	case 6:
		{
			p.SetState(635)
			p.String_literal()
		}

	case 7:
		{
			p.SetState(636)
			p.Idn()
		}
		p.SetState(638)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 72, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(637)
				p.Constant_list()
			}

		}

	case 8:
		{
			p.SetState(640)
			p.Type_spec()
		}
		{
			p.SetState(641)
			p.Match(cluParserT__83)
		}
		p.SetState(656)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 75, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(642)
				p.Field_list()
			}

		case 2:
			{
				p.SetState(643)
				p.Match(cluParserT__17)
			}
			p.SetState(647)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 73, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(644)
					p.expression(0)
				}
				{
					p.SetState(645)
					p.Match(cluParserT__7)
				}

			}
			{
				p.SetState(649)
				p.Expression_list()
			}
			{
				p.SetState(650)
				p.Match(cluParserT__18)
			}

		case 3:
			{
				p.SetState(652)
				p.Name()
			}
			p.SetState(654)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 74, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(653)
					p.Constant_list()
				}

			}

		}

	case 9:
		{
			p.SetState(658)
			p.Match(cluParserT__84)
		}
		p.SetState(660)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 76, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(659)
				p.Type_spec()
			}

		}

	case 10:
		{
			p.SetState(662)
			_la = p.GetTokenStream().LA(1)

			if !(_la == cluParserT__85 || _la == cluParserT__86) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(663)
			p.Match(cluParserT__9)
		}
		{
			p.SetState(664)
			p.expression(0)
		}
		{
			p.SetState(665)
			p.Match(cluParserT__10)
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(682)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 80, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewPrimaryContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, cluParserRULE_primary)
			p.SetState(669)

			if !(p.Precpred(p.GetParserRuleContext(), 4)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
			}
			p.SetState(678)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 79, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(670)
					p.Match(cluParserT__39)
				}
				{
					p.SetState(671)
					p.Name()
				}

			case 2:
				{
					p.SetState(672)
					p.expression(0)
				}

			case 3:
				{
					p.SetState(673)
					p.Match(cluParserT__9)
				}
				p.SetState(675)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if (((_la-10)&-(0x1f+1)) == 0 && ((1<<uint((_la-10)))&((1<<(cluParserT__9-10))|(1<<(cluParserT__19-10))|(1<<(cluParserT__23-10))|(1<<(cluParserT__24-10))|(1<<(cluParserT__25-10))|(1<<(cluParserT__26-10))|(1<<(cluParserT__27-10))|(1<<(cluParserT__28-10))|(1<<(cluParserT__29-10))|(1<<(cluParserT__30-10))|(1<<(cluParserT__31-10))|(1<<(cluParserT__32-10))|(1<<(cluParserT__33-10))|(1<<(cluParserT__34-10))|(1<<(cluParserT__35-10))|(1<<(cluParserT__36-10))|(1<<(cluParserT__37-10))|(1<<(cluParserT__38-10)))) != 0) || (((_la-61)&-(0x1f+1)) == 0 && ((1<<uint((_la-61)))&((1<<(cluParserT__60-61))|(1<<(cluParserT__61-61))|(1<<(cluParserT__80-61))|(1<<(cluParserT__81-61))|(1<<(cluParserT__82-61))|(1<<(cluParserT__84-61))|(1<<(cluParserT__85-61))|(1<<(cluParserT__86-61))|(1<<(cluParserSTRINGLITERAL-61))|(1<<(cluParserSTRING-61))|(1<<(cluParserINT-61))|(1<<(cluParserFLOAT-61)))) != 0) {
					{
						p.SetState(674)
						p.Expression_list()
					}

				}
				{
					p.SetState(677)
					p.Match(cluParserT__10)
				}

			}

		}
		p.SetState(684)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 80, p.GetParserRuleContext())
	}

	return localctx
}

// IInvocationContext is an interface to support dynamic dispatch.
type IInvocationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInvocationContext differentiates from other interfaces.
	IsInvocationContext()
}

type InvocationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInvocationContext() *InvocationContext {
	var p = new(InvocationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_invocation
	return p
}

func (*InvocationContext) IsInvocationContext() {}

func NewInvocationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InvocationContext {
	var p = new(InvocationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_invocation

	return p
}

func (s *InvocationContext) GetParser() antlr.Parser { return s.parser }

func (s *InvocationContext) Primary() IPrimaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimaryContext)
}

func (s *InvocationContext) Expression_list() IExpression_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpression_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpression_listContext)
}

func (s *InvocationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InvocationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InvocationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterInvocation(s)
	}
}

func (s *InvocationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitInvocation(s)
	}
}

func (p *cluParser) Invocation() (localctx IInvocationContext) {
	this := p
	_ = this

	localctx = NewInvocationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, cluParserRULE_invocation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(685)
		p.primary(0)
	}
	{
		p.SetState(686)
		p.Match(cluParserT__9)
	}
	{
		p.SetState(687)
		p.Expression_list()
	}
	{
		p.SetState(688)
		p.Match(cluParserT__10)
	}

	return localctx
}

// IField_listContext is an interface to support dynamic dispatch.
type IField_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsField_listContext differentiates from other interfaces.
	IsField_listContext()
}

type Field_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyField_listContext() *Field_listContext {
	var p = new(Field_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_field_list
	return p
}

func (*Field_listContext) IsField_listContext() {}

func NewField_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Field_listContext {
	var p = new(Field_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_field_list

	return p
}

func (s *Field_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Field_listContext) AllField() []IFieldContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFieldContext)(nil)).Elem())
	var tst = make([]IFieldContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFieldContext)
		}
	}

	return tst
}

func (s *Field_listContext) Field(i int) IFieldContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFieldContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFieldContext)
}

func (s *Field_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Field_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Field_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterField_list(s)
	}
}

func (s *Field_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitField_list(s)
	}
}

func (p *cluParser) Field_list() (localctx IField_listContext) {
	this := p
	_ = this

	localctx = NewField_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, cluParserRULE_field_list)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(690)
		p.Field()
	}
	p.SetState(695)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 81, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(691)
				p.Match(cluParserT__6)
			}
			{
				p.SetState(692)
				p.Field()
			}

		}
		p.SetState(697)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 81, p.GetParserRuleContext())
	}

	return localctx
}

// IFieldContext is an interface to support dynamic dispatch.
type IFieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFieldContext differentiates from other interfaces.
	IsFieldContext()
}

type FieldContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldContext() *FieldContext {
	var p = new(FieldContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_field
	return p
}

func (*FieldContext) IsFieldContext() {}

func NewFieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldContext {
	var p = new(FieldContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_field

	return p
}

func (s *FieldContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldContext) Name_list() IName_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_listContext)
}

func (s *FieldContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterField(s)
	}
}

func (s *FieldContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitField(s)
	}
}

func (p *cluParser) Field() (localctx IFieldContext) {
	this := p
	_ = this

	localctx = NewFieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, cluParserRULE_field)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(698)
		p.Name_list()
	}
	{
		p.SetState(699)
		p.Match(cluParserT__7)
	}
	{
		p.SetState(700)
		p.expression(0)
	}

	return localctx
}

// IIdn_listContext is an interface to support dynamic dispatch.
type IIdn_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdn_listContext differentiates from other interfaces.
	IsIdn_listContext()
}

type Idn_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdn_listContext() *Idn_listContext {
	var p = new(Idn_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_idn_list
	return p
}

func (*Idn_listContext) IsIdn_listContext() {}

func NewIdn_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Idn_listContext {
	var p = new(Idn_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_idn_list

	return p
}

func (s *Idn_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Idn_listContext) AllIdn() []IIdnContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdnContext)(nil)).Elem())
	var tst = make([]IIdnContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdnContext)
		}
	}

	return tst
}

func (s *Idn_listContext) Idn(i int) IIdnContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdnContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdnContext)
}

func (s *Idn_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Idn_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Idn_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterIdn_list(s)
	}
}

func (s *Idn_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitIdn_list(s)
	}
}

func (p *cluParser) Idn_list() (localctx IIdn_listContext) {
	this := p
	_ = this

	localctx = NewIdn_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, cluParserRULE_idn_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(702)
		p.Idn()
	}
	p.SetState(707)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == cluParserT__6 {
		{
			p.SetState(703)
			p.Match(cluParserT__6)
		}
		{
			p.SetState(704)
			p.Idn()
		}

		p.SetState(709)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IIdnContext is an interface to support dynamic dispatch.
type IIdnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdnContext differentiates from other interfaces.
	IsIdnContext()
}

type IdnContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdnContext() *IdnContext {
	var p = new(IdnContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_idn
	return p
}

func (*IdnContext) IsIdnContext() {}

func NewIdnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdnContext {
	var p = new(IdnContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_idn

	return p
}

func (s *IdnContext) GetParser() antlr.Parser { return s.parser }

func (s *IdnContext) STRING() antlr.TerminalNode {
	return s.GetToken(cluParserSTRING, 0)
}

func (s *IdnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterIdn(s)
	}
}

func (s *IdnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitIdn(s)
	}
}

func (p *cluParser) Idn() (localctx IIdnContext) {
	this := p
	_ = this

	localctx = NewIdnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, cluParserRULE_idn)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(710)
		p.Match(cluParserSTRING)
	}

	return localctx
}

// IName_listContext is an interface to support dynamic dispatch.
type IName_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsName_listContext differentiates from other interfaces.
	IsName_listContext()
}

type Name_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyName_listContext() *Name_listContext {
	var p = new(Name_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_name_list
	return p
}

func (*Name_listContext) IsName_listContext() {}

func NewName_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Name_listContext {
	var p = new(Name_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_name_list

	return p
}

func (s *Name_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Name_listContext) AllName() []INameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INameContext)(nil)).Elem())
	var tst = make([]INameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INameContext)
		}
	}

	return tst
}

func (s *Name_listContext) Name(i int) INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Name_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Name_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Name_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterName_list(s)
	}
}

func (s *Name_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitName_list(s)
	}
}

func (p *cluParser) Name_list() (localctx IName_listContext) {
	this := p
	_ = this

	localctx = NewName_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, cluParserRULE_name_list)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(712)
		p.Name()
	}
	p.SetState(717)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 83, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(713)
				p.Match(cluParserT__6)
			}
			{
				p.SetState(714)
				p.Name()
			}

		}
		p.SetState(719)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 83, p.GetParserRuleContext())
	}

	return localctx
}

// INameContext is an interface to support dynamic dispatch.
type INameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNameContext differentiates from other interfaces.
	IsNameContext()
}

type NameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNameContext() *NameContext {
	var p = new(NameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_name
	return p
}

func (*NameContext) IsNameContext() {}

func NewNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NameContext {
	var p = new(NameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_name

	return p
}

func (s *NameContext) GetParser() antlr.Parser { return s.parser }

func (s *NameContext) STRING() antlr.TerminalNode {
	return s.GetToken(cluParserSTRING, 0)
}

func (s *NameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterName(s)
	}
}

func (s *NameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitName(s)
	}
}

func (p *cluParser) Name() (localctx INameContext) {
	this := p
	_ = this

	localctx = NewNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, cluParserRULE_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(720)
		p.Match(cluParserSTRING)
	}

	return localctx
}

// IInt_literalContext is an interface to support dynamic dispatch.
type IInt_literalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInt_literalContext differentiates from other interfaces.
	IsInt_literalContext()
}

type Int_literalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInt_literalContext() *Int_literalContext {
	var p = new(Int_literalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_int_literal
	return p
}

func (*Int_literalContext) IsInt_literalContext() {}

func NewInt_literalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Int_literalContext {
	var p = new(Int_literalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_int_literal

	return p
}

func (s *Int_literalContext) GetParser() antlr.Parser { return s.parser }

func (s *Int_literalContext) INT() antlr.TerminalNode {
	return s.GetToken(cluParserINT, 0)
}

func (s *Int_literalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Int_literalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Int_literalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterInt_literal(s)
	}
}

func (s *Int_literalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitInt_literal(s)
	}
}

func (p *cluParser) Int_literal() (localctx IInt_literalContext) {
	this := p
	_ = this

	localctx = NewInt_literalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, cluParserRULE_int_literal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(722)
		p.Match(cluParserINT)
	}

	return localctx
}

// IReal_literalContext is an interface to support dynamic dispatch.
type IReal_literalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReal_literalContext differentiates from other interfaces.
	IsReal_literalContext()
}

type Real_literalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReal_literalContext() *Real_literalContext {
	var p = new(Real_literalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_real_literal
	return p
}

func (*Real_literalContext) IsReal_literalContext() {}

func NewReal_literalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Real_literalContext {
	var p = new(Real_literalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_real_literal

	return p
}

func (s *Real_literalContext) GetParser() antlr.Parser { return s.parser }

func (s *Real_literalContext) FLOAT() antlr.TerminalNode {
	return s.GetToken(cluParserFLOAT, 0)
}

func (s *Real_literalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Real_literalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Real_literalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterReal_literal(s)
	}
}

func (s *Real_literalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitReal_literal(s)
	}
}

func (p *cluParser) Real_literal() (localctx IReal_literalContext) {
	this := p
	_ = this

	localctx = NewReal_literalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, cluParserRULE_real_literal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(724)
		p.Match(cluParserFLOAT)
	}

	return localctx
}

// IString_literalContext is an interface to support dynamic dispatch.
type IString_literalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsString_literalContext differentiates from other interfaces.
	IsString_literalContext()
}

type String_literalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyString_literalContext() *String_literalContext {
	var p = new(String_literalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_string_literal
	return p
}

func (*String_literalContext) IsString_literalContext() {}

func NewString_literalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *String_literalContext {
	var p = new(String_literalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_string_literal

	return p
}

func (s *String_literalContext) GetParser() antlr.Parser { return s.parser }

func (s *String_literalContext) STRINGLITERAL() antlr.TerminalNode {
	return s.GetToken(cluParserSTRINGLITERAL, 0)
}

func (s *String_literalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *String_literalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *String_literalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterString_literal(s)
	}
}

func (s *String_literalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitString_literal(s)
	}
}

func (p *cluParser) String_literal() (localctx IString_literalContext) {
	this := p
	_ = this

	localctx = NewString_literalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, cluParserRULE_string_literal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(726)
		p.Match(cluParserSTRINGLITERAL)
	}

	return localctx
}

func (p *cluParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 31:
		var t *StatementContext = nil
		if localctx != nil {
			t = localctx.(*StatementContext)
		}
		return p.Statement_Sempred(t, predIndex)

	case 37:
		var t *ExpressionContext = nil
		if localctx != nil {
			t = localctx.(*ExpressionContext)
		}
		return p.Expression_Sempred(t, predIndex)

	case 38:
		var t *PrimaryContext = nil
		if localctx != nil {
			t = localctx.(*PrimaryContext)
		}
		return p.Primary_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *cluParser) Statement_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *cluParser) Expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 1:
		return p.Precpred(p.GetParserRuleContext(), 6)

	case 2:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 3:
		return p.Precpred(p.GetParserRuleContext(), 4)

	case 4:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 5:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 6:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *cluParser) Primary_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 7:
		return p.Precpred(p.GetParserRuleContext(), 4)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
