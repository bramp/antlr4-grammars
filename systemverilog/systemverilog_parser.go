// Code generated from SystemVerilogParser.g4 by ANTLR 4.9.3. DO NOT EDIT.

package systemverilog // SystemVerilogParser
import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 359, 7893,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4,
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55,
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9,
	60, 4, 61, 9, 61, 4, 62, 9, 62, 4, 63, 9, 63, 4, 64, 9, 64, 4, 65, 9, 65,
	4, 66, 9, 66, 4, 67, 9, 67, 4, 68, 9, 68, 4, 69, 9, 69, 4, 70, 9, 70, 4,
	71, 9, 71, 4, 72, 9, 72, 4, 73, 9, 73, 4, 74, 9, 74, 4, 75, 9, 75, 4, 76,
	9, 76, 4, 77, 9, 77, 4, 78, 9, 78, 4, 79, 9, 79, 4, 80, 9, 80, 4, 81, 9,
	81, 4, 82, 9, 82, 4, 83, 9, 83, 4, 84, 9, 84, 4, 85, 9, 85, 4, 86, 9, 86,
	4, 87, 9, 87, 4, 88, 9, 88, 4, 89, 9, 89, 4, 90, 9, 90, 4, 91, 9, 91, 4,
	92, 9, 92, 4, 93, 9, 93, 4, 94, 9, 94, 4, 95, 9, 95, 4, 96, 9, 96, 4, 97,
	9, 97, 4, 98, 9, 98, 4, 99, 9, 99, 4, 100, 9, 100, 4, 101, 9, 101, 4, 102,
	9, 102, 4, 103, 9, 103, 4, 104, 9, 104, 4, 105, 9, 105, 4, 106, 9, 106,
	4, 107, 9, 107, 4, 108, 9, 108, 4, 109, 9, 109, 4, 110, 9, 110, 4, 111,
	9, 111, 4, 112, 9, 112, 4, 113, 9, 113, 4, 114, 9, 114, 4, 115, 9, 115,
	4, 116, 9, 116, 4, 117, 9, 117, 4, 118, 9, 118, 4, 119, 9, 119, 4, 120,
	9, 120, 4, 121, 9, 121, 4, 122, 9, 122, 4, 123, 9, 123, 4, 124, 9, 124,
	4, 125, 9, 125, 4, 126, 9, 126, 4, 127, 9, 127, 4, 128, 9, 128, 4, 129,
	9, 129, 4, 130, 9, 130, 4, 131, 9, 131, 4, 132, 9, 132, 4, 133, 9, 133,
	4, 134, 9, 134, 4, 135, 9, 135, 4, 136, 9, 136, 4, 137, 9, 137, 4, 138,
	9, 138, 4, 139, 9, 139, 4, 140, 9, 140, 4, 141, 9, 141, 4, 142, 9, 142,
	4, 143, 9, 143, 4, 144, 9, 144, 4, 145, 9, 145, 4, 146, 9, 146, 4, 147,
	9, 147, 4, 148, 9, 148, 4, 149, 9, 149, 4, 150, 9, 150, 4, 151, 9, 151,
	4, 152, 9, 152, 4, 153, 9, 153, 4, 154, 9, 154, 4, 155, 9, 155, 4, 156,
	9, 156, 4, 157, 9, 157, 4, 158, 9, 158, 4, 159, 9, 159, 4, 160, 9, 160,
	4, 161, 9, 161, 4, 162, 9, 162, 4, 163, 9, 163, 4, 164, 9, 164, 4, 165,
	9, 165, 4, 166, 9, 166, 4, 167, 9, 167, 4, 168, 9, 168, 4, 169, 9, 169,
	4, 170, 9, 170, 4, 171, 9, 171, 4, 172, 9, 172, 4, 173, 9, 173, 4, 174,
	9, 174, 4, 175, 9, 175, 4, 176, 9, 176, 4, 177, 9, 177, 4, 178, 9, 178,
	4, 179, 9, 179, 4, 180, 9, 180, 4, 181, 9, 181, 4, 182, 9, 182, 4, 183,
	9, 183, 4, 184, 9, 184, 4, 185, 9, 185, 4, 186, 9, 186, 4, 187, 9, 187,
	4, 188, 9, 188, 4, 189, 9, 189, 4, 190, 9, 190, 4, 191, 9, 191, 4, 192,
	9, 192, 4, 193, 9, 193, 4, 194, 9, 194, 4, 195, 9, 195, 4, 196, 9, 196,
	4, 197, 9, 197, 4, 198, 9, 198, 4, 199, 9, 199, 4, 200, 9, 200, 4, 201,
	9, 201, 4, 202, 9, 202, 4, 203, 9, 203, 4, 204, 9, 204, 4, 205, 9, 205,
	4, 206, 9, 206, 4, 207, 9, 207, 4, 208, 9, 208, 4, 209, 9, 209, 4, 210,
	9, 210, 4, 211, 9, 211, 4, 212, 9, 212, 4, 213, 9, 213, 4, 214, 9, 214,
	4, 215, 9, 215, 4, 216, 9, 216, 4, 217, 9, 217, 4, 218, 9, 218, 4, 219,
	9, 219, 4, 220, 9, 220, 4, 221, 9, 221, 4, 222, 9, 222, 4, 223, 9, 223,
	4, 224, 9, 224, 4, 225, 9, 225, 4, 226, 9, 226, 4, 227, 9, 227, 4, 228,
	9, 228, 4, 229, 9, 229, 4, 230, 9, 230, 4, 231, 9, 231, 4, 232, 9, 232,
	4, 233, 9, 233, 4, 234, 9, 234, 4, 235, 9, 235, 4, 236, 9, 236, 4, 237,
	9, 237, 4, 238, 9, 238, 4, 239, 9, 239, 4, 240, 9, 240, 4, 241, 9, 241,
	4, 242, 9, 242, 4, 243, 9, 243, 4, 244, 9, 244, 4, 245, 9, 245, 4, 246,
	9, 246, 4, 247, 9, 247, 4, 248, 9, 248, 4, 249, 9, 249, 4, 250, 9, 250,
	4, 251, 9, 251, 4, 252, 9, 252, 4, 253, 9, 253, 4, 254, 9, 254, 4, 255,
	9, 255, 4, 256, 9, 256, 4, 257, 9, 257, 4, 258, 9, 258, 4, 259, 9, 259,
	4, 260, 9, 260, 4, 261, 9, 261, 4, 262, 9, 262, 4, 263, 9, 263, 4, 264,
	9, 264, 4, 265, 9, 265, 4, 266, 9, 266, 4, 267, 9, 267, 4, 268, 9, 268,
	4, 269, 9, 269, 4, 270, 9, 270, 4, 271, 9, 271, 4, 272, 9, 272, 4, 273,
	9, 273, 4, 274, 9, 274, 4, 275, 9, 275, 4, 276, 9, 276, 4, 277, 9, 277,
	4, 278, 9, 278, 4, 279, 9, 279, 4, 280, 9, 280, 4, 281, 9, 281, 4, 282,
	9, 282, 4, 283, 9, 283, 4, 284, 9, 284, 4, 285, 9, 285, 4, 286, 9, 286,
	4, 287, 9, 287, 4, 288, 9, 288, 4, 289, 9, 289, 4, 290, 9, 290, 4, 291,
	9, 291, 4, 292, 9, 292, 4, 293, 9, 293, 4, 294, 9, 294, 4, 295, 9, 295,
	4, 296, 9, 296, 4, 297, 9, 297, 4, 298, 9, 298, 4, 299, 9, 299, 4, 300,
	9, 300, 4, 301, 9, 301, 4, 302, 9, 302, 4, 303, 9, 303, 4, 304, 9, 304,
	4, 305, 9, 305, 4, 306, 9, 306, 4, 307, 9, 307, 4, 308, 9, 308, 4, 309,
	9, 309, 4, 310, 9, 310, 4, 311, 9, 311, 4, 312, 9, 312, 4, 313, 9, 313,
	4, 314, 9, 314, 4, 315, 9, 315, 4, 316, 9, 316, 4, 317, 9, 317, 4, 318,
	9, 318, 4, 319, 9, 319, 4, 320, 9, 320, 4, 321, 9, 321, 4, 322, 9, 322,
	4, 323, 9, 323, 4, 324, 9, 324, 4, 325, 9, 325, 4, 326, 9, 326, 4, 327,
	9, 327, 4, 328, 9, 328, 4, 329, 9, 329, 4, 330, 9, 330, 4, 331, 9, 331,
	4, 332, 9, 332, 4, 333, 9, 333, 4, 334, 9, 334, 4, 335, 9, 335, 4, 336,
	9, 336, 4, 337, 9, 337, 4, 338, 9, 338, 4, 339, 9, 339, 4, 340, 9, 340,
	4, 341, 9, 341, 4, 342, 9, 342, 4, 343, 9, 343, 4, 344, 9, 344, 4, 345,
	9, 345, 4, 346, 9, 346, 4, 347, 9, 347, 4, 348, 9, 348, 4, 349, 9, 349,
	4, 350, 9, 350, 4, 351, 9, 351, 4, 352, 9, 352, 4, 353, 9, 353, 4, 354,
	9, 354, 4, 355, 9, 355, 4, 356, 9, 356, 4, 357, 9, 357, 4, 358, 9, 358,
	4, 359, 9, 359, 4, 360, 9, 360, 4, 361, 9, 361, 4, 362, 9, 362, 4, 363,
	9, 363, 4, 364, 9, 364, 4, 365, 9, 365, 4, 366, 9, 366, 4, 367, 9, 367,
	4, 368, 9, 368, 4, 369, 9, 369, 4, 370, 9, 370, 4, 371, 9, 371, 4, 372,
	9, 372, 4, 373, 9, 373, 4, 374, 9, 374, 4, 375, 9, 375, 4, 376, 9, 376,
	4, 377, 9, 377, 4, 378, 9, 378, 4, 379, 9, 379, 4, 380, 9, 380, 4, 381,
	9, 381, 4, 382, 9, 382, 4, 383, 9, 383, 4, 384, 9, 384, 4, 385, 9, 385,
	4, 386, 9, 386, 4, 387, 9, 387, 4, 388, 9, 388, 4, 389, 9, 389, 4, 390,
	9, 390, 4, 391, 9, 391, 4, 392, 9, 392, 4, 393, 9, 393, 4, 394, 9, 394,
	4, 395, 9, 395, 4, 396, 9, 396, 4, 397, 9, 397, 4, 398, 9, 398, 4, 399,
	9, 399, 4, 400, 9, 400, 4, 401, 9, 401, 4, 402, 9, 402, 4, 403, 9, 403,
	4, 404, 9, 404, 4, 405, 9, 405, 4, 406, 9, 406, 4, 407, 9, 407, 4, 408,
	9, 408, 4, 409, 9, 409, 4, 410, 9, 410, 4, 411, 9, 411, 4, 412, 9, 412,
	4, 413, 9, 413, 4, 414, 9, 414, 4, 415, 9, 415, 4, 416, 9, 416, 4, 417,
	9, 417, 4, 418, 9, 418, 4, 419, 9, 419, 4, 420, 9, 420, 4, 421, 9, 421,
	4, 422, 9, 422, 4, 423, 9, 423, 4, 424, 9, 424, 4, 425, 9, 425, 4, 426,
	9, 426, 4, 427, 9, 427, 4, 428, 9, 428, 4, 429, 9, 429, 4, 430, 9, 430,
	4, 431, 9, 431, 4, 432, 9, 432, 4, 433, 9, 433, 4, 434, 9, 434, 4, 435,
	9, 435, 4, 436, 9, 436, 4, 437, 9, 437, 4, 438, 9, 438, 4, 439, 9, 439,
	4, 440, 9, 440, 4, 441, 9, 441, 4, 442, 9, 442, 4, 443, 9, 443, 4, 444,
	9, 444, 4, 445, 9, 445, 4, 446, 9, 446, 4, 447, 9, 447, 4, 448, 9, 448,
	4, 449, 9, 449, 4, 450, 9, 450, 4, 451, 9, 451, 4, 452, 9, 452, 4, 453,
	9, 453, 4, 454, 9, 454, 4, 455, 9, 455, 4, 456, 9, 456, 4, 457, 9, 457,
	4, 458, 9, 458, 4, 459, 9, 459, 4, 460, 9, 460, 4, 461, 9, 461, 4, 462,
	9, 462, 4, 463, 9, 463, 4, 464, 9, 464, 4, 465, 9, 465, 4, 466, 9, 466,
	4, 467, 9, 467, 4, 468, 9, 468, 4, 469, 9, 469, 4, 470, 9, 470, 4, 471,
	9, 471, 4, 472, 9, 472, 4, 473, 9, 473, 4, 474, 9, 474, 4, 475, 9, 475,
	4, 476, 9, 476, 4, 477, 9, 477, 4, 478, 9, 478, 4, 479, 9, 479, 4, 480,
	9, 480, 4, 481, 9, 481, 4, 482, 9, 482, 4, 483, 9, 483, 4, 484, 9, 484,
	4, 485, 9, 485, 4, 486, 9, 486, 4, 487, 9, 487, 4, 488, 9, 488, 4, 489,
	9, 489, 4, 490, 9, 490, 4, 491, 9, 491, 4, 492, 9, 492, 4, 493, 9, 493,
	4, 494, 9, 494, 4, 495, 9, 495, 4, 496, 9, 496, 4, 497, 9, 497, 4, 498,
	9, 498, 4, 499, 9, 499, 4, 500, 9, 500, 4, 501, 9, 501, 4, 502, 9, 502,
	4, 503, 9, 503, 4, 504, 9, 504, 4, 505, 9, 505, 4, 506, 9, 506, 4, 507,
	9, 507, 4, 508, 9, 508, 4, 509, 9, 509, 4, 510, 9, 510, 4, 511, 9, 511,
	4, 512, 9, 512, 4, 513, 9, 513, 4, 514, 9, 514, 4, 515, 9, 515, 4, 516,
	9, 516, 4, 517, 9, 517, 4, 518, 9, 518, 4, 519, 9, 519, 4, 520, 9, 520,
	4, 521, 9, 521, 4, 522, 9, 522, 4, 523, 9, 523, 4, 524, 9, 524, 4, 525,
	9, 525, 4, 526, 9, 526, 4, 527, 9, 527, 4, 528, 9, 528, 4, 529, 9, 529,
	4, 530, 9, 530, 4, 531, 9, 531, 4, 532, 9, 532, 4, 533, 9, 533, 4, 534,
	9, 534, 4, 535, 9, 535, 4, 536, 9, 536, 4, 537, 9, 537, 4, 538, 9, 538,
	4, 539, 9, 539, 4, 540, 9, 540, 4, 541, 9, 541, 4, 542, 9, 542, 4, 543,
	9, 543, 4, 544, 9, 544, 4, 545, 9, 545, 4, 546, 9, 546, 4, 547, 9, 547,
	4, 548, 9, 548, 4, 549, 9, 549, 4, 550, 9, 550, 4, 551, 9, 551, 4, 552,
	9, 552, 4, 553, 9, 553, 4, 554, 9, 554, 4, 555, 9, 555, 4, 556, 9, 556,
	4, 557, 9, 557, 4, 558, 9, 558, 4, 559, 9, 559, 4, 560, 9, 560, 4, 561,
	9, 561, 4, 562, 9, 562, 4, 563, 9, 563, 4, 564, 9, 564, 4, 565, 9, 565,
	4, 566, 9, 566, 4, 567, 9, 567, 4, 568, 9, 568, 4, 569, 9, 569, 4, 570,
	9, 570, 4, 571, 9, 571, 4, 572, 9, 572, 4, 573, 9, 573, 4, 574, 9, 574,
	4, 575, 9, 575, 4, 576, 9, 576, 4, 577, 9, 577, 4, 578, 9, 578, 4, 579,
	9, 579, 4, 580, 9, 580, 4, 581, 9, 581, 4, 582, 9, 582, 4, 583, 9, 583,
	4, 584, 9, 584, 4, 585, 9, 585, 4, 586, 9, 586, 4, 587, 9, 587, 4, 588,
	9, 588, 4, 589, 9, 589, 4, 590, 9, 590, 4, 591, 9, 591, 4, 592, 9, 592,
	4, 593, 9, 593, 4, 594, 9, 594, 4, 595, 9, 595, 4, 596, 9, 596, 4, 597,
	9, 597, 4, 598, 9, 598, 4, 599, 9, 599, 4, 600, 9, 600, 4, 601, 9, 601,
	4, 602, 9, 602, 4, 603, 9, 603, 4, 604, 9, 604, 4, 605, 9, 605, 4, 606,
	9, 606, 4, 607, 9, 607, 4, 608, 9, 608, 4, 609, 9, 609, 4, 610, 9, 610,
	4, 611, 9, 611, 4, 612, 9, 612, 4, 613, 9, 613, 4, 614, 9, 614, 4, 615,
	9, 615, 4, 616, 9, 616, 4, 617, 9, 617, 4, 618, 9, 618, 4, 619, 9, 619,
	4, 620, 9, 620, 4, 621, 9, 621, 4, 622, 9, 622, 4, 623, 9, 623, 4, 624,
	9, 624, 3, 2, 7, 2, 1250, 10, 2, 12, 2, 14, 2, 1253, 11, 2, 3, 3, 3, 3,
	3, 3, 3, 3, 5, 3, 1259, 10, 3, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 7, 4, 1266,
	10, 4, 12, 4, 14, 4, 1269, 11, 4, 3, 4, 3, 4, 3, 4, 3, 4, 7, 4, 1275, 10,
	4, 12, 4, 14, 4, 1278, 11, 4, 5, 4, 1280, 10, 4, 3, 4, 3, 4, 3, 5, 3, 5,
	3, 5, 3, 5, 3, 6, 5, 6, 1289, 10, 6, 3, 6, 7, 6, 1292, 10, 6, 12, 6, 14,
	6, 1295, 11, 6, 3, 6, 3, 6, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 7, 7, 1304, 10,
	7, 12, 7, 14, 7, 1307, 11, 7, 3, 7, 3, 7, 5, 7, 1311, 10, 7, 3, 7, 5, 7,
	1314, 10, 7, 3, 8, 7, 8, 1317, 10, 8, 12, 8, 14, 8, 1320, 11, 8, 3, 8,
	3, 8, 5, 8, 1324, 10, 8, 3, 8, 3, 8, 7, 8, 1328, 10, 8, 12, 8, 14, 8, 1331,
	11, 8, 3, 8, 5, 8, 1334, 10, 8, 3, 8, 3, 8, 3, 8, 3, 9, 7, 9, 1340, 10,
	9, 12, 9, 14, 9, 1343, 11, 9, 3, 9, 3, 9, 5, 9, 1347, 10, 9, 3, 9, 3, 9,
	7, 9, 1351, 10, 9, 12, 9, 14, 9, 1354, 11, 9, 3, 9, 5, 9, 1357, 10, 9,
	3, 9, 5, 9, 1360, 10, 9, 3, 9, 3, 9, 3, 10, 3, 10, 5, 10, 1366, 10, 10,
	3, 10, 7, 10, 1369, 10, 10, 12, 10, 14, 10, 1372, 11, 10, 3, 10, 3, 10,
	3, 10, 5, 10, 1377, 10, 10, 3, 10, 3, 10, 5, 10, 1381, 10, 10, 3, 10, 7,
	10, 1384, 10, 10, 12, 10, 14, 10, 1387, 11, 10, 3, 10, 3, 10, 3, 10, 5,
	10, 1392, 10, 10, 3, 10, 7, 10, 1395, 10, 10, 12, 10, 14, 10, 1398, 11,
	10, 3, 10, 3, 10, 5, 10, 1402, 10, 10, 3, 10, 3, 10, 3, 10, 3, 10, 3, 10,
	3, 10, 5, 10, 1410, 10, 10, 3, 10, 7, 10, 1413, 10, 10, 12, 10, 14, 10,
	1416, 11, 10, 3, 10, 3, 10, 3, 10, 5, 10, 1421, 10, 10, 3, 10, 3, 10, 3,
	10, 5, 10, 1426, 10, 10, 5, 10, 1428, 10, 10, 3, 11, 3, 11, 3, 12, 3, 12,
	5, 12, 1434, 10, 12, 3, 12, 7, 12, 1437, 10, 12, 12, 12, 14, 12, 1440,
	11, 12, 3, 12, 3, 12, 3, 12, 5, 12, 1445, 10, 12, 3, 12, 3, 12, 5, 12,
	1449, 10, 12, 3, 12, 7, 12, 1452, 10, 12, 12, 12, 14, 12, 1455, 11, 12,
	3, 12, 3, 12, 3, 12, 5, 12, 1460, 10, 12, 3, 12, 7, 12, 1463, 10, 12, 12,
	12, 14, 12, 1466, 11, 12, 3, 12, 3, 12, 3, 12, 3, 12, 3, 12, 3, 12, 3,
	12, 5, 12, 1475, 10, 12, 3, 12, 7, 12, 1478, 10, 12, 12, 12, 14, 12, 1481,
	11, 12, 3, 12, 3, 12, 3, 12, 5, 12, 1486, 10, 12, 3, 12, 3, 12, 3, 12,
	5, 12, 1491, 10, 12, 5, 12, 1493, 10, 12, 3, 13, 7, 13, 1496, 10, 13, 12,
	13, 14, 13, 1499, 11, 13, 3, 13, 3, 13, 5, 13, 1503, 10, 13, 3, 13, 3,
	13, 7, 13, 1507, 10, 13, 12, 13, 14, 13, 1510, 11, 13, 3, 13, 5, 13, 1513,
	10, 13, 3, 13, 3, 13, 3, 13, 3, 14, 7, 14, 1519, 10, 14, 12, 14, 14, 14,
	1522, 11, 14, 3, 14, 3, 14, 5, 14, 1526, 10, 14, 3, 14, 3, 14, 7, 14, 1530,
	10, 14, 12, 14, 14, 14, 1533, 11, 14, 3, 14, 5, 14, 1536, 10, 14, 3, 14,
	5, 14, 1539, 10, 14, 3, 14, 3, 14, 3, 15, 3, 15, 5, 15, 1545, 10, 15, 3,
	15, 7, 15, 1548, 10, 15, 12, 15, 14, 15, 1551, 11, 15, 3, 15, 3, 15, 3,
	15, 5, 15, 1556, 10, 15, 3, 15, 3, 15, 5, 15, 1560, 10, 15, 3, 15, 7, 15,
	1563, 10, 15, 12, 15, 14, 15, 1566, 11, 15, 3, 15, 3, 15, 3, 15, 5, 15,
	1571, 10, 15, 3, 15, 7, 15, 1574, 10, 15, 12, 15, 14, 15, 1577, 11, 15,
	3, 15, 3, 15, 3, 15, 3, 15, 3, 15, 3, 15, 3, 15, 5, 15, 1586, 10, 15, 3,
	15, 7, 15, 1589, 10, 15, 12, 15, 14, 15, 1592, 11, 15, 3, 15, 3, 15, 3,
	15, 5, 15, 1597, 10, 15, 3, 15, 3, 15, 3, 15, 5, 15, 1602, 10, 15, 5, 15,
	1604, 10, 15, 3, 16, 7, 16, 1607, 10, 16, 12, 16, 14, 16, 1610, 11, 16,
	3, 16, 3, 16, 5, 16, 1614, 10, 16, 3, 16, 3, 16, 7, 16, 1618, 10, 16, 12,
	16, 14, 16, 1621, 11, 16, 3, 16, 5, 16, 1624, 10, 16, 3, 16, 3, 16, 3,
	16, 3, 17, 7, 17, 1630, 10, 17, 12, 17, 14, 17, 1633, 11, 17, 3, 17, 3,
	17, 5, 17, 1637, 10, 17, 3, 17, 3, 17, 7, 17, 1641, 10, 17, 12, 17, 14,
	17, 1644, 11, 17, 3, 17, 5, 17, 1647, 10, 17, 3, 17, 5, 17, 1650, 10, 17,
	3, 17, 3, 17, 3, 18, 3, 18, 3, 18, 3, 18, 5, 18, 1658, 10, 18, 3, 18, 5,
	18, 1661, 10, 18, 3, 18, 3, 18, 7, 18, 1665, 10, 18, 12, 18, 14, 18, 1668,
	11, 18, 3, 18, 7, 18, 1671, 10, 18, 12, 18, 14, 18, 1674, 11, 18, 3, 18,
	3, 18, 3, 18, 5, 18, 1679, 10, 18, 3, 19, 5, 19, 1682, 10, 19, 3, 19, 3,
	19, 5, 19, 1686, 10, 19, 3, 19, 3, 19, 5, 19, 1690, 10, 19, 3, 19, 3, 19,
	3, 19, 3, 19, 3, 19, 3, 19, 5, 19, 1698, 10, 19, 5, 19, 1700, 10, 19, 3,
	19, 3, 19, 3, 19, 3, 19, 7, 19, 1706, 10, 19, 12, 19, 14, 19, 1709, 11,
	19, 5, 19, 1711, 10, 19, 3, 19, 3, 19, 7, 19, 1715, 10, 19, 12, 19, 14,
	19, 1718, 11, 19, 3, 19, 3, 19, 3, 19, 5, 19, 1723, 10, 19, 3, 20, 3, 20,
	5, 20, 1727, 10, 20, 3, 21, 3, 21, 3, 21, 3, 21, 5, 21, 1733, 10, 21, 3,
	21, 3, 21, 3, 21, 3, 21, 7, 21, 1739, 10, 21, 12, 21, 14, 21, 1742, 11,
	21, 5, 21, 1744, 10, 21, 3, 21, 3, 21, 7, 21, 1748, 10, 21, 12, 21, 14,
	21, 1751, 11, 21, 3, 21, 3, 21, 3, 21, 5, 21, 1756, 10, 21, 3, 22, 3, 22,
	7, 22, 1760, 10, 22, 12, 22, 14, 22, 1763, 11, 22, 3, 22, 3, 22, 3, 22,
	5, 22, 1768, 10, 22, 3, 22, 5, 22, 1771, 10, 22, 3, 23, 3, 23, 3, 23, 3,
	23, 3, 23, 3, 24, 7, 24, 1779, 10, 24, 12, 24, 14, 24, 1782, 11, 24, 3,
	24, 3, 24, 5, 24, 1786, 10, 24, 3, 24, 3, 24, 3, 24, 5, 24, 1791, 10, 24,
	3, 24, 7, 24, 1794, 10, 24, 12, 24, 14, 24, 1797, 11, 24, 3, 24, 7, 24,
	1800, 10, 24, 12, 24, 14, 24, 1803, 11, 24, 3, 24, 3, 24, 3, 24, 5, 24,
	1808, 10, 24, 3, 25, 3, 25, 3, 25, 3, 25, 5, 25, 1814, 10, 25, 3, 25, 3,
	25, 3, 25, 5, 25, 1819, 10, 25, 3, 25, 3, 25, 3, 25, 3, 25, 3, 25, 3, 25,
	3, 25, 5, 25, 1828, 10, 25, 5, 25, 1830, 10, 25, 3, 26, 3, 26, 3, 26, 3,
	26, 5, 26, 1836, 10, 26, 3, 26, 3, 26, 7, 26, 1840, 10, 26, 12, 26, 14,
	26, 1843, 11, 26, 5, 26, 1845, 10, 26, 3, 26, 3, 26, 3, 27, 3, 27, 3, 27,
	3, 27, 3, 27, 3, 27, 3, 27, 5, 27, 1856, 10, 27, 3, 28, 3, 28, 3, 28, 3,
	28, 7, 28, 1862, 10, 28, 12, 28, 14, 28, 1865, 11, 28, 3, 28, 3, 28, 3,
	29, 3, 29, 7, 29, 1871, 10, 29, 12, 29, 14, 29, 1874, 11, 29, 3, 29, 3,
	29, 3, 29, 7, 29, 1879, 10, 29, 12, 29, 14, 29, 1882, 11, 29, 3, 29, 7,
	29, 1885, 10, 29, 12, 29, 14, 29, 1888, 11, 29, 5, 29, 1890, 10, 29, 3,
	29, 3, 29, 3, 30, 7, 30, 1895, 10, 30, 12, 30, 14, 30, 1898, 11, 30, 3,
	30, 3, 30, 3, 30, 3, 30, 3, 30, 5, 30, 1905, 10, 30, 3, 31, 5, 31, 1908,
	10, 31, 3, 31, 3, 31, 3, 31, 3, 31, 5, 31, 1914, 10, 31, 3, 31, 3, 31,
	5, 31, 1918, 10, 31, 3, 32, 3, 32, 3, 32, 3, 32, 3, 32, 7, 32, 1925, 10,
	32, 12, 32, 14, 32, 1928, 11, 32, 3, 32, 3, 32, 5, 32, 1932, 10, 32, 3,
	33, 3, 33, 3, 33, 3, 34, 3, 34, 3, 35, 5, 35, 1940, 10, 35, 3, 35, 3, 35,
	3, 36, 5, 36, 1945, 10, 36, 3, 36, 3, 36, 3, 37, 3, 37, 3, 37, 5, 37, 1952,
	10, 37, 3, 37, 3, 37, 3, 37, 5, 37, 1957, 10, 37, 5, 37, 1959, 10, 37,
	3, 38, 3, 38, 5, 38, 1963, 10, 38, 3, 38, 3, 38, 7, 38, 1967, 10, 38, 12,
	38, 14, 38, 1970, 11, 38, 3, 38, 3, 38, 5, 38, 1974, 10, 38, 3, 38, 5,
	38, 1977, 10, 38, 3, 38, 3, 38, 7, 38, 1981, 10, 38, 12, 38, 14, 38, 1984,
	11, 38, 3, 38, 3, 38, 5, 38, 1988, 10, 38, 3, 38, 5, 38, 1991, 10, 38,
	3, 38, 3, 38, 3, 38, 3, 38, 5, 38, 1997, 10, 38, 3, 38, 3, 38, 5, 38, 2001,
	10, 38, 3, 39, 3, 39, 3, 39, 5, 39, 2006, 10, 39, 3, 39, 5, 39, 2009, 10,
	39, 3, 39, 3, 39, 3, 39, 3, 39, 5, 39, 2015, 10, 39, 3, 39, 5, 39, 2018,
	10, 39, 3, 39, 5, 39, 2021, 10, 39, 3, 40, 3, 40, 3, 40, 3, 40, 3, 40,
	3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 5, 40, 2036, 10,
	40, 3, 41, 3, 41, 3, 41, 3, 41, 5, 41, 2042, 10, 41, 3, 42, 7, 42, 2045,
	10, 42, 12, 42, 14, 42, 2048, 11, 42, 3, 42, 3, 42, 3, 42, 3, 42, 5, 42,
	2054, 10, 42, 3, 43, 3, 43, 3, 43, 3, 43, 3, 43, 3, 43, 3, 43, 3, 43, 3,
	43, 5, 43, 2065, 10, 43, 3, 43, 3, 43, 5, 43, 2069, 10, 43, 3, 44, 3, 44,
	3, 44, 3, 44, 7, 44, 2075, 10, 44, 12, 44, 14, 44, 2078, 11, 44, 3, 44,
	3, 44, 3, 44, 3, 44, 3, 44, 5, 44, 2085, 10, 44, 3, 45, 3, 45, 3, 45, 3,
	45, 3, 46, 3, 46, 3, 46, 3, 46, 5, 46, 2095, 10, 46, 3, 46, 5, 46, 2098,
	10, 46, 3, 46, 3, 46, 3, 46, 3, 47, 3, 47, 5, 47, 2105, 10, 47, 3, 48,
	3, 48, 3, 48, 3, 49, 3, 49, 3, 49, 7, 49, 2113, 10, 49, 12, 49, 14, 49,
	2116, 11, 49, 3, 50, 3, 50, 3, 50, 3, 50, 5, 50, 2122, 10, 50, 3, 51, 3,
	51, 3, 51, 3, 51, 3, 51, 3, 51, 7, 51, 2130, 10, 51, 12, 51, 14, 51, 2133,
	11, 51, 3, 51, 3, 51, 7, 51, 2137, 10, 51, 12, 51, 14, 51, 2140, 11, 51,
	3, 51, 3, 51, 3, 51, 5, 51, 2145, 10, 51, 3, 52, 3, 52, 3, 52, 3, 52, 5,
	52, 2151, 10, 52, 3, 52, 7, 52, 2154, 10, 52, 12, 52, 14, 52, 2157, 11,
	52, 3, 52, 3, 52, 3, 53, 3, 53, 3, 53, 5, 53, 2164, 10, 53, 3, 53, 3, 53,
	3, 53, 3, 53, 3, 53, 5, 53, 2171, 10, 53, 3, 53, 3, 53, 3, 53, 5, 53, 2176,
	10, 53, 3, 54, 3, 54, 3, 55, 3, 55, 3, 55, 3, 56, 3, 56, 3, 56, 7, 56,
	2186, 10, 56, 12, 56, 14, 56, 2189, 11, 56, 3, 57, 3, 57, 3, 57, 3, 57,
	5, 57, 2195, 10, 57, 3, 57, 3, 57, 3, 58, 3, 58, 7, 58, 2201, 10, 58, 12,
	58, 14, 58, 2204, 11, 58, 3, 59, 3, 59, 3, 59, 3, 59, 5, 59, 2210, 10,
	59, 3, 59, 3, 59, 3, 59, 3, 59, 7, 59, 2216, 10, 59, 12, 59, 14, 59, 2219,
	11, 59, 5, 59, 2221, 10, 59, 3, 59, 3, 59, 5, 59, 2225, 10, 59, 3, 59,
	3, 59, 3, 59, 3, 59, 7, 59, 2231, 10, 59, 12, 59, 14, 59, 2234, 11, 59,
	3, 59, 3, 59, 5, 59, 2238, 10, 59, 5, 59, 2240, 10, 59, 3, 60, 7, 60, 2243,
	10, 60, 12, 60, 14, 60, 2246, 11, 60, 3, 60, 3, 60, 5, 60, 2250, 10, 60,
	3, 61, 3, 61, 3, 61, 3, 61, 5, 61, 2256, 10, 61, 3, 61, 3, 61, 3, 62, 3,
	62, 3, 62, 3, 62, 5, 62, 2264, 10, 62, 3, 63, 3, 63, 3, 63, 3, 63, 3, 63,
	3, 63, 5, 63, 2272, 10, 63, 3, 64, 3, 64, 3, 64, 3, 64, 5, 64, 2278, 10,
	64, 3, 65, 7, 65, 2281, 10, 65, 12, 65, 14, 65, 2284, 11, 65, 3, 65, 3,
	65, 3, 65, 3, 65, 3, 65, 5, 65, 2291, 10, 65, 3, 65, 3, 65, 5, 65, 2295,
	10, 65, 3, 66, 3, 66, 3, 66, 3, 66, 5, 66, 2301, 10, 66, 3, 67, 3, 67,
	3, 67, 7, 67, 2306, 10, 67, 12, 67, 14, 67, 2309, 11, 67, 3, 68, 7, 68,
	2312, 10, 68, 12, 68, 14, 68, 2315, 11, 68, 3, 68, 5, 68, 2318, 10, 68,
	3, 68, 3, 68, 3, 68, 7, 68, 2323, 10, 68, 12, 68, 14, 68, 2326, 11, 68,
	3, 68, 3, 68, 5, 68, 2330, 10, 68, 3, 69, 3, 69, 3, 70, 3, 70, 3, 70, 3,
	70, 3, 70, 3, 70, 3, 70, 5, 70, 2341, 10, 70, 3, 71, 5, 71, 2344, 10, 71,
	3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3,
	71, 3, 71, 3, 71, 5, 71, 2359, 10, 71, 5, 71, 2361, 10, 71, 3, 71, 5, 71,
	2364, 10, 71, 3, 72, 3, 72, 3, 72, 3, 72, 5, 72, 2370, 10, 72, 3, 73, 7,
	73, 2373, 10, 73, 12, 73, 14, 73, 2376, 11, 73, 3, 73, 3, 73, 3, 73, 3,
	73, 3, 73, 5, 73, 2383, 10, 73, 3, 73, 3, 73, 5, 73, 2387, 10, 73, 3, 73,
	5, 73, 2390, 10, 73, 3, 74, 7, 74, 2393, 10, 74, 12, 74, 14, 74, 2396,
	11, 74, 3, 74, 3, 74, 3, 74, 7, 74, 2401, 10, 74, 12, 74, 14, 74, 2404,
	11, 74, 3, 74, 3, 74, 3, 74, 3, 74, 5, 74, 2410, 10, 74, 3, 74, 3, 74,
	5, 74, 2414, 10, 74, 3, 75, 7, 75, 2417, 10, 75, 12, 75, 14, 75, 2420,
	11, 75, 3, 75, 3, 75, 3, 75, 5, 75, 2425, 10, 75, 3, 75, 3, 75, 3, 75,
	7, 75, 2430, 10, 75, 12, 75, 14, 75, 2433, 11, 75, 3, 75, 3, 75, 3, 75,
	3, 75, 3, 75, 7, 75, 2440, 10, 75, 12, 75, 14, 75, 2443, 11, 75, 3, 75,
	3, 75, 3, 75, 3, 75, 5, 75, 2449, 10, 75, 5, 75, 2451, 10, 75, 3, 76, 3,
	76, 3, 76, 3, 76, 5, 76, 2457, 10, 76, 3, 76, 5, 76, 2460, 10, 76, 3, 76,
	3, 76, 3, 77, 3, 77, 5, 77, 2466, 10, 77, 3, 78, 3, 78, 3, 79, 3, 79, 5,
	79, 2472, 10, 79, 3, 80, 3, 80, 3, 81, 5, 81, 2477, 10, 81, 3, 81, 3, 81,
	5, 81, 2481, 10, 81, 3, 82, 3, 82, 5, 82, 2485, 10, 82, 3, 83, 3, 83, 5,
	83, 2489, 10, 83, 3, 83, 3, 83, 3, 83, 5, 83, 2494, 10, 83, 3, 83, 5, 83,
	2497, 10, 83, 3, 83, 3, 83, 7, 83, 2501, 10, 83, 12, 83, 14, 83, 2504,
	11, 83, 3, 83, 3, 83, 3, 83, 3, 83, 3, 83, 3, 83, 3, 83, 5, 83, 2513, 10,
	83, 3, 83, 5, 83, 2516, 10, 83, 3, 83, 7, 83, 2519, 10, 83, 12, 83, 14,
	83, 2522, 11, 83, 3, 83, 3, 83, 3, 83, 5, 83, 2527, 10, 83, 3, 84, 5, 84,
	2530, 10, 84, 3, 84, 3, 84, 3, 84, 3, 84, 3, 85, 3, 85, 7, 85, 2538, 10,
	85, 12, 85, 14, 85, 2541, 11, 85, 3, 85, 3, 85, 3, 86, 3, 86, 3, 86, 3,
	86, 3, 86, 3, 86, 3, 86, 5, 86, 2552, 10, 86, 3, 87, 3, 87, 3, 87, 7, 87,
	2557, 10, 87, 12, 87, 14, 87, 2560, 11, 87, 3, 88, 3, 88, 3, 88, 3, 88,
	5, 88, 2566, 10, 88, 3, 88, 3, 88, 3, 88, 3, 89, 5, 89, 2572, 10, 89, 3,
	89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89,
	3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 5, 89, 2591, 10, 89, 3, 89, 3,
	89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89,
	3, 89, 3, 89, 5, 89, 2607, 10, 89, 3, 90, 3, 90, 7, 90, 2611, 10, 90, 12,
	90, 14, 90, 2614, 11, 90, 3, 91, 3, 91, 3, 91, 7, 91, 2619, 10, 91, 12,
	91, 14, 91, 2622, 11, 91, 3, 91, 5, 91, 2625, 10, 91, 3, 92, 3, 92, 3,
	92, 7, 92, 2630, 10, 92, 12, 92, 14, 92, 2633, 11, 92, 3, 93, 3, 93, 5,
	93, 2637, 10, 93, 3, 94, 3, 94, 3, 94, 3, 95, 5, 95, 2643, 10, 95, 3, 95,
	5, 95, 2646, 10, 95, 3, 95, 3, 95, 3, 95, 3, 95, 3, 96, 3, 96, 3, 97, 5,
	97, 2655, 10, 97, 3, 97, 3, 97, 3, 97, 3, 97, 3, 97, 3, 98, 3, 98, 3, 98,
	7, 98, 2665, 10, 98, 12, 98, 14, 98, 2668, 11, 98, 3, 99, 3, 99, 3, 99,
	3, 99, 5, 99, 2674, 10, 99, 3, 100, 3, 100, 3, 100, 3, 100, 3, 100, 3,
	100, 3, 100, 3, 100, 3, 100, 3, 100, 3, 100, 5, 100, 2687, 10, 100, 3,
	100, 3, 100, 3, 100, 5, 100, 2692, 10, 100, 3, 101, 3, 101, 3, 101, 7,
	101, 2697, 10, 101, 12, 101, 14, 101, 2700, 11, 101, 3, 101, 3, 101, 3,
	102, 3, 102, 3, 102, 3, 102, 3, 102, 3, 102, 5, 102, 2710, 10, 102, 3,
	103, 3, 103, 3, 103, 3, 103, 3, 103, 3, 103, 5, 103, 2718, 10, 103, 3,
	104, 3, 104, 3, 104, 3, 104, 3, 104, 3, 104, 5, 104, 2726, 10, 104, 3,
	105, 3, 105, 5, 105, 2730, 10, 105, 3, 105, 3, 105, 3, 105, 3, 106, 3,
	106, 3, 106, 3, 106, 3, 107, 3, 107, 3, 107, 3, 107, 3, 107, 3, 107, 3,
	107, 5, 107, 2746, 10, 107, 3, 108, 3, 108, 3, 108, 3, 108, 3, 108, 3,
	108, 3, 108, 5, 108, 2755, 10, 108, 3, 109, 3, 109, 3, 109, 5, 109, 2760,
	10, 109, 3, 109, 3, 109, 3, 110, 3, 110, 3, 110, 3, 110, 3, 111, 5, 111,
	2769, 10, 111, 3, 111, 5, 111, 2772, 10, 111, 3, 111, 5, 111, 2775, 10,
	111, 3, 111, 3, 111, 3, 111, 3, 111, 3, 111, 3, 111, 3, 111, 5, 111, 2784,
	10, 111, 3, 112, 3, 112, 3, 112, 3, 112, 7, 112, 2790, 10, 112, 12, 112,
	14, 112, 2793, 11, 112, 3, 112, 3, 112, 3, 113, 3, 113, 3, 113, 3, 113,
	5, 113, 2801, 10, 113, 3, 114, 3, 114, 3, 114, 3, 114, 3, 114, 7, 114,
	2808, 10, 114, 12, 114, 14, 114, 2811, 11, 114, 5, 114, 2813, 10, 114,
	3, 114, 3, 114, 3, 115, 3, 115, 3, 115, 3, 115, 3, 116, 3, 116, 3, 116,
	5, 116, 2824, 10, 116, 3, 116, 5, 116, 2827, 10, 116, 3, 116, 3, 116, 5,
	116, 2831, 10, 116, 3, 116, 3, 116, 3, 116, 3, 116, 3, 116, 5, 116, 2838,
	10, 116, 3, 116, 3, 116, 3, 116, 3, 116, 3, 116, 3, 116, 3, 116, 5, 116,
	2847, 10, 116, 3, 116, 3, 116, 7, 116, 2851, 10, 116, 12, 116, 14, 116,
	2854, 11, 116, 3, 116, 3, 116, 3, 116, 7, 116, 2859, 10, 116, 12, 116,
	14, 116, 2862, 11, 116, 5, 116, 2864, 10, 116, 3, 116, 3, 116, 5, 116,
	2868, 10, 116, 3, 117, 3, 117, 3, 117, 3, 117, 7, 117, 2874, 10, 117, 12,
	117, 14, 117, 2877, 11, 117, 3, 117, 3, 117, 3, 117, 3, 117, 3, 117, 3,
	117, 3, 117, 3, 117, 3, 117, 3, 117, 3, 117, 3, 117, 3, 117, 3, 117, 3,
	117, 3, 117, 3, 117, 5, 117, 2896, 10, 117, 3, 117, 3, 117, 3, 117, 5,
	117, 2901, 10, 117, 3, 118, 3, 118, 3, 118, 3, 118, 3, 118, 3, 118, 5,
	118, 2909, 10, 118, 3, 118, 5, 118, 2912, 10, 118, 3, 118, 3, 118, 3, 118,
	3, 118, 3, 118, 5, 118, 2919, 10, 118, 3, 118, 3, 118, 3, 118, 3, 118,
	5, 118, 2925, 10, 118, 3, 119, 3, 119, 3, 120, 3, 120, 3, 120, 3, 120,
	3, 120, 5, 120, 2934, 10, 120, 3, 121, 3, 121, 5, 121, 2938, 10, 121, 3,
	121, 7, 121, 2941, 10, 121, 12, 121, 14, 121, 2944, 11, 121, 3, 121, 3,
	121, 5, 121, 2948, 10, 121, 3, 121, 3, 121, 3, 121, 3, 121, 5, 121, 2954,
	10, 121, 5, 121, 2956, 10, 121, 3, 121, 3, 121, 3, 121, 7, 121, 2961, 10,
	121, 12, 121, 14, 121, 2964, 11, 121, 3, 121, 3, 121, 7, 121, 2968, 10,
	121, 12, 121, 14, 121, 2971, 11, 121, 3, 121, 3, 121, 5, 121, 2975, 10,
	121, 3, 121, 3, 121, 3, 121, 3, 121, 7, 121, 2981, 10, 121, 12, 121, 14,
	121, 2984, 11, 121, 3, 121, 3, 121, 7, 121, 2988, 10, 121, 12, 121, 14,
	121, 2991, 11, 121, 3, 121, 3, 121, 3, 121, 3, 121, 5, 121, 2997, 10, 121,
	3, 121, 3, 121, 5, 121, 3001, 10, 121, 3, 121, 3, 121, 5, 121, 3005, 10,
	121, 3, 121, 3, 121, 5, 121, 3009, 10, 121, 3, 121, 3, 121, 7, 121, 3013,
	10, 121, 12, 121, 14, 121, 3016, 11, 121, 3, 121, 3, 121, 3, 121, 3, 121,
	5, 121, 3022, 10, 121, 3, 122, 3, 122, 5, 122, 3026, 10, 122, 3, 123, 5,
	123, 3029, 10, 123, 3, 123, 7, 123, 3032, 10, 123, 12, 123, 14, 123, 3035,
	11, 123, 3, 124, 3, 124, 5, 124, 3039, 10, 124, 3, 124, 3, 124, 5, 124,
	3043, 10, 124, 3, 124, 5, 124, 3046, 10, 124, 3, 124, 3, 124, 5, 124, 3050,
	10, 124, 5, 124, 3052, 10, 124, 3, 125, 3, 125, 3, 125, 3, 125, 3, 125,
	5, 125, 3059, 10, 125, 3, 125, 5, 125, 3062, 10, 125, 3, 125, 3, 125, 5,
	125, 3066, 10, 125, 3, 126, 3, 126, 3, 126, 3, 127, 3, 127, 5, 127, 3073,
	10, 127, 3, 127, 3, 127, 3, 127, 5, 127, 3078, 10, 127, 7, 127, 3080, 10,
	127, 12, 127, 14, 127, 3083, 11, 127, 3, 128, 3, 128, 5, 128, 3087, 10,
	128, 3, 129, 3, 129, 3, 130, 3, 130, 3, 131, 3, 131, 3, 132, 3, 132, 3,
	133, 5, 133, 3098, 10, 133, 3, 133, 3, 133, 3, 133, 3, 133, 5, 133, 3104,
	10, 133, 3, 134, 3, 134, 3, 135, 3, 135, 3, 135, 5, 135, 3111, 10, 135,
	3, 136, 3, 136, 3, 137, 3, 137, 3, 137, 3, 137, 5, 137, 3119, 10, 137,
	3, 138, 7, 138, 3122, 10, 138, 12, 138, 14, 138, 3125, 11, 138, 3, 138,
	5, 138, 3128, 10, 138, 3, 138, 3, 138, 3, 138, 3, 138, 3, 139, 3, 139,
	5, 139, 3136, 10, 139, 3, 140, 3, 140, 3, 140, 5, 140, 3141, 10, 140, 5,
	140, 3143, 10, 140, 3, 141, 3, 141, 3, 141, 3, 141, 5, 141, 3149, 10, 141,
	3, 141, 3, 141, 3, 142, 3, 142, 3, 142, 3, 142, 3, 142, 5, 142, 3158, 10,
	142, 3, 142, 3, 142, 3, 142, 3, 142, 3, 142, 3, 142, 3, 142, 5, 142, 3167,
	10, 142, 3, 142, 3, 142, 3, 142, 3, 142, 3, 142, 3, 142, 3, 142, 3, 142,
	3, 142, 3, 142, 3, 142, 3, 142, 3, 142, 3, 142, 5, 142, 3183, 10, 142,
	3, 143, 3, 143, 3, 144, 3, 144, 3, 145, 3, 145, 3, 145, 3, 145, 3, 146,
	3, 146, 3, 146, 3, 146, 3, 146, 3, 146, 3, 146, 3, 146, 5, 146, 3201, 10,
	146, 5, 146, 3203, 10, 146, 3, 146, 3, 146, 5, 146, 3207, 10, 146, 3, 147,
	3, 147, 3, 147, 3, 147, 3, 147, 3, 147, 5, 147, 3215, 10, 147, 3, 147,
	3, 147, 5, 147, 3219, 10, 147, 3, 148, 3, 148, 3, 148, 3, 148, 3, 148,
	5, 148, 3226, 10, 148, 3, 149, 3, 149, 3, 149, 7, 149, 3231, 10, 149, 12,
	149, 14, 149, 3234, 11, 149, 3, 150, 3, 150, 3, 150, 7, 150, 3239, 10,
	150, 12, 150, 14, 150, 3242, 11, 150, 3, 151, 3, 151, 7, 151, 3246, 10,
	151, 12, 151, 14, 151, 3249, 11, 151, 3, 151, 3, 151, 3, 151, 7, 151, 3254,
	10, 151, 12, 151, 14, 151, 3257, 11, 151, 7, 151, 3259, 10, 151, 12, 151,
	14, 151, 3262, 11, 151, 3, 152, 3, 152, 3, 152, 7, 152, 3267, 10, 152,
	12, 152, 14, 152, 3270, 11, 152, 3, 153, 3, 153, 3, 153, 7, 153, 3275,
	10, 153, 12, 153, 14, 153, 3278, 11, 153, 3, 154, 3, 154, 7, 154, 3282,
	10, 154, 12, 154, 14, 154, 3285, 11, 154, 3, 154, 3, 154, 3, 154, 7, 154,
	3290, 10, 154, 12, 154, 14, 154, 3293, 11, 154, 7, 154, 3295, 10, 154,
	12, 154, 14, 154, 3298, 11, 154, 3, 155, 3, 155, 3, 155, 7, 155, 3303,
	10, 155, 12, 155, 14, 155, 3306, 11, 155, 3, 156, 3, 156, 3, 156, 7, 156,
	3311, 10, 156, 12, 156, 14, 156, 3314, 11, 156, 3, 157, 3, 157, 7, 157,
	3318, 10, 157, 12, 157, 14, 157, 3321, 11, 157, 3, 157, 3, 157, 5, 157,
	3325, 10, 157, 3, 157, 3, 157, 3, 157, 7, 157, 3330, 10, 157, 12, 157,
	14, 157, 3333, 11, 157, 3, 157, 3, 157, 5, 157, 3337, 10, 157, 7, 157,
	3339, 10, 157, 12, 157, 14, 157, 3342, 11, 157, 3, 158, 3, 158, 3, 158,
	7, 158, 3347, 10, 158, 12, 158, 14, 158, 3350, 11, 158, 3, 159, 3, 159,
	3, 159, 7, 159, 3355, 10, 159, 12, 159, 14, 159, 3358, 11, 159, 3, 160,
	3, 160, 7, 160, 3362, 10, 160, 12, 160, 14, 160, 3365, 11, 160, 3, 160,
	3, 160, 3, 160, 7, 160, 3370, 10, 160, 12, 160, 14, 160, 3373, 11, 160,
	7, 160, 3375, 10, 160, 12, 160, 14, 160, 3378, 11, 160, 3, 161, 3, 161,
	7, 161, 3382, 10, 161, 12, 161, 14, 161, 3385, 11, 161, 3, 161, 3, 161,
	5, 161, 3389, 10, 161, 3, 161, 3, 161, 3, 161, 7, 161, 3394, 10, 161, 12,
	161, 14, 161, 3397, 11, 161, 3, 161, 3, 161, 5, 161, 3401, 10, 161, 7,
	161, 3403, 10, 161, 12, 161, 14, 161, 3406, 11, 161, 3, 162, 3, 162, 3,
	162, 3, 162, 3, 163, 3, 163, 7, 163, 3414, 10, 163, 12, 163, 14, 163, 3417,
	11, 163, 3, 163, 3, 163, 5, 163, 3421, 10, 163, 3, 164, 3, 164, 7, 164,
	3425, 10, 164, 12, 164, 14, 164, 3428, 11, 164, 3, 164, 3, 164, 5, 164,
	3432, 10, 164, 3, 165, 3, 165, 3, 165, 3, 165, 3, 165, 5, 165, 3439, 10,
	165, 3, 166, 3, 166, 3, 166, 5, 166, 3444, 10, 166, 3, 167, 3, 167, 3,
	167, 3, 167, 3, 167, 5, 167, 3451, 10, 167, 3, 167, 3, 167, 3, 167, 3,
	167, 3, 167, 5, 167, 3458, 10, 167, 3, 167, 3, 167, 3, 168, 3, 168, 3,
	169, 3, 169, 3, 170, 3, 170, 3, 171, 3, 171, 7, 171, 3470, 10, 171, 12,
	171, 14, 171, 3473, 11, 171, 3, 171, 3, 171, 5, 171, 3477, 10, 171, 3,
	171, 3, 171, 3, 171, 7, 171, 3482, 10, 171, 12, 171, 14, 171, 3485, 11,
	171, 3, 171, 3, 171, 5, 171, 3489, 10, 171, 3, 171, 3, 171, 3, 171, 5,
	171, 3494, 10, 171, 5, 171, 3496, 10, 171, 3, 172, 5, 172, 3499, 10, 172,
	3, 172, 3, 172, 3, 172, 3, 172, 3, 172, 5, 172, 3506, 10, 172, 3, 172,
	3, 172, 5, 172, 3510, 10, 172, 3, 173, 3, 173, 3, 173, 3, 173, 3, 173,
	3, 173, 3, 173, 3, 173, 5, 173, 3520, 10, 173, 3, 174, 3, 174, 3, 174,
	5, 174, 3525, 10, 174, 3, 174, 3, 174, 3, 175, 3, 175, 3, 175, 3, 175,
	3, 175, 5, 175, 3534, 10, 175, 3, 176, 3, 176, 3, 176, 5, 176, 3539, 10,
	176, 3, 176, 3, 176, 3, 177, 3, 177, 3, 177, 3, 177, 5, 177, 3547, 10,
	177, 3, 178, 3, 178, 3, 178, 3, 178, 5, 178, 3553, 10, 178, 3, 178, 3,
	178, 3, 179, 3, 179, 3, 179, 3, 180, 3, 180, 5, 180, 3562, 10, 180, 3,
	181, 3, 181, 5, 181, 3566, 10, 181, 3, 181, 3, 181, 3, 182, 3, 182, 3,
	182, 3, 182, 3, 182, 5, 182, 3575, 10, 182, 3, 182, 3, 182, 3, 182, 7,
	182, 3580, 10, 182, 12, 182, 14, 182, 3583, 11, 182, 3, 182, 3, 182, 5,
	182, 3587, 10, 182, 3, 182, 3, 182, 3, 182, 7, 182, 3592, 10, 182, 12,
	182, 14, 182, 3595, 11, 182, 5, 182, 3597, 10, 182, 3, 182, 7, 182, 3600,
	10, 182, 12, 182, 14, 182, 3603, 11, 182, 3, 182, 3, 182, 3, 182, 5, 182,
	3608, 10, 182, 3, 183, 3, 183, 3, 183, 3, 183, 3, 183, 5, 183, 3615, 10,
	183, 3, 183, 5, 183, 3618, 10, 183, 3, 184, 3, 184, 3, 184, 5, 184, 3623,
	10, 184, 3, 184, 3, 184, 3, 184, 5, 184, 3628, 10, 184, 3, 184, 3, 184,
	5, 184, 3632, 10, 184, 3, 184, 3, 184, 3, 184, 5, 184, 3637, 10, 184, 3,
	184, 5, 184, 3640, 10, 184, 3, 184, 3, 184, 3, 184, 3, 184, 3, 184, 3,
	184, 3, 184, 5, 184, 3649, 10, 184, 3, 184, 3, 184, 3, 184, 3, 184, 5,
	184, 3655, 10, 184, 3, 184, 3, 184, 5, 184, 3659, 10, 184, 3, 185, 3, 185,
	3, 186, 3, 186, 3, 187, 3, 187, 3, 188, 3, 188, 3, 189, 3, 189, 3, 190,
	3, 190, 5, 190, 3673, 10, 190, 3, 190, 3, 190, 3, 191, 3, 191, 3, 191,
	3, 191, 5, 191, 3681, 10, 191, 3, 191, 3, 191, 3, 191, 7, 191, 3686, 10,
	191, 12, 191, 14, 191, 3689, 11, 191, 3, 191, 3, 191, 5, 191, 3693, 10,
	191, 3, 191, 3, 191, 3, 191, 7, 191, 3698, 10, 191, 12, 191, 14, 191, 3701,
	11, 191, 5, 191, 3703, 10, 191, 3, 191, 7, 191, 3706, 10, 191, 12, 191,
	14, 191, 3709, 11, 191, 3, 191, 3, 191, 3, 191, 5, 191, 3714, 10, 191,
	3, 192, 3, 192, 5, 192, 3718, 10, 192, 3, 193, 3, 193, 3, 193, 7, 193,
	3723, 10, 193, 12, 193, 14, 193, 3726, 11, 193, 3, 194, 7, 194, 3729, 10,
	194, 12, 194, 14, 194, 3732, 11, 194, 3, 194, 5, 194, 3735, 10, 194, 3,
	194, 5, 194, 3738, 10, 194, 3, 194, 3, 194, 3, 194, 7, 194, 3743, 10, 194,
	12, 194, 14, 194, 3746, 11, 194, 3, 194, 3, 194, 5, 194, 3750, 10, 194,
	5, 194, 3752, 10, 194, 3, 195, 3, 195, 3, 195, 5, 195, 3757, 10, 195, 3,
	196, 7, 196, 3760, 10, 196, 12, 196, 14, 196, 3763, 11, 196, 3, 196, 3,
	196, 5, 196, 3767, 10, 196, 3, 196, 3, 196, 3, 196, 3, 196, 3, 197, 3,
	197, 3, 197, 3, 197, 5, 197, 3777, 10, 197, 3, 197, 5, 197, 3780, 10, 197,
	3, 198, 7, 198, 3783, 10, 198, 12, 198, 14, 198, 3786, 11, 198, 3, 198,
	3, 198, 5, 198, 3790, 10, 198, 3, 198, 7, 198, 3793, 10, 198, 12, 198,
	14, 198, 3796, 11, 198, 3, 198, 3, 198, 5, 198, 3800, 10, 198, 3, 198,
	3, 198, 5, 198, 3804, 10, 198, 3, 199, 3, 199, 3, 199, 3, 199, 7, 199,
	3810, 10, 199, 12, 199, 14, 199, 3813, 11, 199, 3, 199, 3, 199, 3, 200,
	3, 200, 3, 200, 3, 200, 3, 200, 7, 200, 3822, 10, 200, 12, 200, 14, 200,
	3825, 11, 200, 3, 200, 3, 200, 3, 201, 7, 201, 3830, 10, 201, 12, 201,
	14, 201, 3833, 11, 201, 3, 201, 3, 201, 3, 201, 5, 201, 3838, 10, 201,
	3, 202, 3, 202, 3, 202, 3, 203, 3, 203, 3, 203, 3, 203, 7, 203, 3847, 10,
	203, 12, 203, 14, 203, 3850, 11, 203, 3, 204, 3, 204, 3, 204, 3, 204, 3,
	204, 5, 204, 3857, 10, 204, 3, 204, 3, 204, 5, 204, 3861, 10, 204, 3, 205,
	3, 205, 3, 205, 3, 205, 7, 205, 3867, 10, 205, 12, 205, 14, 205, 3870,
	11, 205, 3, 206, 3, 206, 5, 206, 3874, 10, 206, 3, 207, 3, 207, 3, 208,
	3, 208, 3, 208, 5, 208, 3881, 10, 208, 3, 208, 3, 208, 5, 208, 3885, 10,
	208, 3, 209, 3, 209, 3, 209, 3, 209, 3, 209, 5, 209, 3892, 10, 209, 3,
	210, 3, 210, 3, 210, 3, 210, 3, 210, 3, 210, 3, 210, 3, 211, 3, 211, 3,
	211, 3, 211, 3, 211, 3, 211, 3, 211, 3, 212, 3, 212, 3, 212, 3, 212, 3,
	212, 3, 212, 3, 212, 3, 213, 3, 213, 3, 213, 3, 213, 3, 213, 3, 213, 3,
	214, 3, 214, 3, 214, 3, 214, 5, 214, 3925, 10, 214, 3, 214, 3, 214, 3,
	214, 3, 214, 3, 214, 3, 214, 5, 214, 3933, 10, 214, 3, 214, 3, 214, 3,
	214, 3, 214, 3, 215, 3, 215, 3, 215, 3, 215, 3, 215, 3, 215, 3, 215, 3,
	216, 3, 216, 3, 216, 5, 216, 3949, 10, 216, 3, 216, 5, 216, 3952, 10, 216,
	3, 217, 5, 217, 3955, 10, 217, 3, 217, 3, 217, 5, 217, 3959, 10, 217, 7,
	217, 3961, 10, 217, 12, 217, 14, 217, 3964, 11, 217, 3, 217, 3, 217, 3,
	217, 3, 217, 5, 217, 3970, 10, 217, 3, 217, 3, 217, 5, 217, 3974, 10, 217,
	3, 217, 3, 217, 3, 217, 3, 217, 3, 217, 5, 217, 3981, 10, 217, 3, 217,
	3, 217, 7, 217, 3985, 10, 217, 12, 217, 14, 217, 3988, 11, 217, 3, 218,
	3, 218, 5, 218, 3992, 10, 218, 3, 219, 3, 219, 3, 219, 5, 219, 3997, 10,
	219, 3, 220, 3, 220, 3, 220, 3, 220, 5, 220, 4003, 10, 220, 3, 220, 5,
	220, 4006, 10, 220, 3, 220, 3, 220, 7, 220, 4010, 10, 220, 12, 220, 14,
	220, 4013, 11, 220, 3, 220, 3, 220, 5, 220, 4017, 10, 220, 3, 220, 3, 220,
	3, 220, 5, 220, 4022, 10, 220, 3, 221, 3, 221, 3, 221, 7, 221, 4027, 10,
	221, 12, 221, 14, 221, 4030, 11, 221, 3, 222, 7, 222, 4033, 10, 222, 12,
	222, 14, 222, 4036, 11, 222, 3, 222, 3, 222, 5, 222, 4040, 10, 222, 5,
	222, 4042, 10, 222, 3, 222, 3, 222, 3, 222, 7, 222, 4047, 10, 222, 12,
	222, 14, 222, 4050, 11, 222, 3, 222, 3, 222, 5, 222, 4054, 10, 222, 3,
	223, 3, 223, 3, 224, 3, 224, 5, 224, 4060, 10, 224, 3, 225, 5, 225, 4063,
	10, 225, 3, 225, 3, 225, 3, 225, 3, 225, 3, 225, 3, 225, 5, 225, 4071,
	10, 225, 3, 225, 3, 225, 3, 226, 3, 226, 3, 226, 3, 226, 5, 226, 4079,
	10, 226, 3, 226, 3, 226, 3, 226, 3, 226, 3, 226, 3, 226, 3, 226, 3, 226,
	3, 226, 3, 226, 3, 226, 3, 226, 3, 226, 3, 226, 3, 226, 3, 226, 3, 226,
	3, 226, 5, 226, 4099, 10, 226, 3, 226, 3, 226, 3, 226, 3, 226, 3, 226,
	3, 226, 7, 226, 4107, 10, 226, 12, 226, 14, 226, 4110, 11, 226, 3, 226,
	3, 226, 3, 226, 3, 226, 3, 226, 3, 226, 3, 226, 5, 226, 4119, 10, 226,
	3, 226, 3, 226, 3, 226, 3, 226, 3, 226, 3, 226, 5, 226, 4127, 10, 226,
	3, 226, 3, 226, 3, 226, 3, 226, 3, 226, 3, 226, 3, 226, 3, 226, 3, 226,
	3, 226, 3, 226, 3, 226, 3, 226, 3, 226, 3, 226, 3, 226, 3, 226, 5, 226,
	4146, 10, 226, 3, 226, 3, 226, 3, 226, 7, 226, 4151, 10, 226, 12, 226,
	14, 226, 4154, 11, 226, 3, 227, 3, 227, 3, 227, 7, 227, 4159, 10, 227,
	12, 227, 14, 227, 4162, 11, 227, 3, 227, 3, 227, 3, 227, 3, 227, 3, 227,
	3, 227, 5, 227, 4170, 10, 227, 3, 227, 3, 227, 3, 227, 5, 227, 4175, 10,
	227, 3, 228, 3, 228, 3, 228, 3, 228, 5, 228, 4181, 10, 228, 3, 228, 5,
	228, 4184, 10, 228, 3, 228, 3, 228, 7, 228, 4188, 10, 228, 12, 228, 14,
	228, 4191, 11, 228, 3, 228, 3, 228, 5, 228, 4195, 10, 228, 3, 228, 3, 228,
	3, 228, 5, 228, 4200, 10, 228, 3, 229, 3, 229, 3, 229, 7, 229, 4205, 10,
	229, 12, 229, 14, 229, 4208, 11, 229, 3, 230, 7, 230, 4211, 10, 230, 12,
	230, 14, 230, 4214, 11, 230, 3, 230, 3, 230, 5, 230, 4218, 10, 230, 5,
	230, 4220, 10, 230, 3, 230, 3, 230, 3, 230, 7, 230, 4225, 10, 230, 12,
	230, 14, 230, 4228, 11, 230, 3, 230, 3, 230, 5, 230, 4232, 10, 230, 3,
	231, 3, 231, 3, 232, 3, 232, 3, 232, 5, 232, 4239, 10, 232, 3, 233, 3,
	233, 3, 233, 3, 233, 3, 233, 3, 233, 7, 233, 4247, 10, 233, 12, 233, 14,
	233, 4250, 11, 233, 3, 233, 3, 233, 5, 233, 4254, 10, 233, 3, 233, 3, 233,
	5, 233, 4258, 10, 233, 3, 233, 3, 233, 5, 233, 4262, 10, 233, 3, 233, 3,
	233, 3, 233, 3, 233, 7, 233, 4268, 10, 233, 12, 233, 14, 233, 4271, 11,
	233, 3, 233, 3, 233, 5, 233, 4275, 10, 233, 3, 233, 3, 233, 3, 233, 3,
	233, 3, 233, 7, 233, 4282, 10, 233, 12, 233, 14, 233, 4285, 11, 233, 3,
	233, 3, 233, 3, 233, 3, 233, 3, 233, 5, 233, 4292, 10, 233, 3, 233, 3,
	233, 3, 233, 3, 233, 3, 233, 3, 233, 3, 233, 3, 233, 3, 233, 7, 233, 4303,
	10, 233, 12, 233, 14, 233, 4306, 11, 233, 7, 233, 4308, 10, 233, 12, 233,
	14, 233, 4311, 11, 233, 3, 234, 3, 234, 3, 234, 3, 234, 3, 234, 3, 234,
	5, 234, 4319, 10, 234, 3, 234, 5, 234, 4322, 10, 234, 3, 235, 3, 235, 3,
	235, 3, 235, 3, 236, 3, 236, 3, 236, 5, 236, 4331, 10, 236, 3, 237, 3,
	237, 3, 237, 5, 237, 4336, 10, 237, 3, 237, 5, 237, 4339, 10, 237, 3, 238,
	5, 238, 4342, 10, 238, 3, 238, 3, 238, 5, 238, 4346, 10, 238, 7, 238, 4348,
	10, 238, 12, 238, 14, 238, 4351, 11, 238, 3, 238, 3, 238, 3, 238, 3, 238,
	5, 238, 4357, 10, 238, 3, 238, 3, 238, 5, 238, 4361, 10, 238, 3, 238, 3,
	238, 3, 238, 3, 238, 3, 238, 5, 238, 4368, 10, 238, 3, 238, 3, 238, 7,
	238, 4372, 10, 238, 12, 238, 14, 238, 4375, 11, 238, 3, 239, 3, 239, 5,
	239, 4379, 10, 239, 3, 240, 3, 240, 3, 240, 5, 240, 4384, 10, 240, 3, 241,
	3, 241, 3, 242, 3, 242, 3, 242, 3, 242, 3, 242, 5, 242, 4393, 10, 242,
	3, 242, 3, 242, 3, 243, 3, 243, 3, 243, 3, 243, 3, 243, 3, 244, 3, 244,
	3, 244, 3, 244, 3, 244, 3, 245, 3, 245, 5, 245, 4409, 10, 245, 3, 246,
	3, 246, 3, 246, 3, 246, 5, 246, 4415, 10, 246, 3, 247, 3, 247, 3, 247,
	3, 247, 3, 247, 3, 247, 5, 247, 4423, 10, 247, 3, 248, 3, 248, 3, 248,
	3, 248, 3, 249, 3, 249, 3, 249, 3, 249, 5, 249, 4433, 10, 249, 3, 249,
	5, 249, 4436, 10, 249, 3, 249, 5, 249, 4439, 10, 249, 3, 249, 3, 249, 7,
	249, 4443, 10, 249, 12, 249, 14, 249, 4446, 11, 249, 3, 249, 3, 249, 3,
	249, 5, 249, 4451, 10, 249, 3, 250, 7, 250, 4454, 10, 250, 12, 250, 14,
	250, 4457, 11, 250, 3, 250, 3, 250, 3, 250, 3, 250, 5, 250, 4463, 10, 250,
	3, 251, 3, 251, 3, 251, 3, 251, 3, 251, 3, 251, 3, 251, 3, 251, 3, 251,
	3, 251, 5, 251, 4475, 10, 251, 3, 252, 3, 252, 5, 252, 4479, 10, 252, 3,
	253, 3, 253, 3, 253, 3, 253, 3, 253, 3, 253, 5, 253, 4487, 10, 253, 3,
	254, 3, 254, 3, 254, 3, 254, 3, 254, 3, 254, 3, 254, 7, 254, 4496, 10,
	254, 12, 254, 14, 254, 4499, 11, 254, 3, 255, 3, 255, 3, 255, 3, 255, 3,
	255, 3, 255, 5, 255, 4507, 10, 255, 3, 255, 5, 255, 4510, 10, 255, 3, 256,
	5, 256, 4513, 10, 256, 3, 256, 3, 256, 3, 256, 5, 256, 4518, 10, 256, 3,
	256, 3, 256, 3, 256, 3, 256, 3, 256, 3, 256, 3, 256, 5, 256, 4527, 10,
	256, 3, 256, 3, 256, 3, 257, 3, 257, 7, 257, 4533, 10, 257, 12, 257, 14,
	257, 4536, 11, 257, 3, 257, 3, 257, 3, 257, 7, 257, 4541, 10, 257, 12,
	257, 14, 257, 4544, 11, 257, 3, 257, 3, 257, 5, 257, 4548, 10, 257, 3,
	258, 3, 258, 5, 258, 4552, 10, 258, 3, 258, 3, 258, 3, 258, 3, 258, 5,
	258, 4558, 10, 258, 3, 258, 5, 258, 4561, 10, 258, 3, 258, 3, 258, 3, 258,
	3, 258, 3, 258, 3, 258, 3, 258, 3, 258, 3, 258, 5, 258, 4572, 10, 258,
	3, 258, 3, 258, 3, 258, 3, 258, 3, 258, 3, 258, 3, 258, 5, 258, 4581, 10,
	258, 3, 258, 3, 258, 5, 258, 4585, 10, 258, 3, 258, 3, 258, 5, 258, 4589,
	10, 258, 3, 258, 3, 258, 3, 258, 3, 258, 3, 258, 5, 258, 4596, 10, 258,
	3, 258, 3, 258, 3, 258, 3, 258, 5, 258, 4602, 10, 258, 3, 258, 5, 258,
	4605, 10, 258, 3, 258, 3, 258, 3, 258, 3, 258, 3, 258, 5, 258, 4612, 10,
	258, 3, 258, 3, 258, 3, 258, 3, 258, 3, 258, 5, 258, 4619, 10, 258, 5,
	258, 4621, 10, 258, 3, 259, 3, 259, 3, 260, 3, 260, 3, 260, 3, 260, 3,
	260, 3, 260, 3, 260, 3, 260, 7, 260, 4633, 10, 260, 12, 260, 14, 260, 4636,
	11, 260, 3, 261, 3, 261, 3, 261, 7, 261, 4641, 10, 261, 12, 261, 14, 261,
	4644, 11, 261, 3, 262, 3, 262, 3, 262, 3, 262, 3, 262, 3, 262, 5, 262,
	4652, 10, 262, 3, 263, 3, 263, 3, 264, 3, 264, 3, 264, 5, 264, 4659, 10,
	264, 3, 265, 3, 265, 3, 265, 5, 265, 4664, 10, 265, 3, 265, 3, 265, 3,
	265, 3, 265, 3, 265, 3, 265, 3, 265, 5, 265, 4673, 10, 265, 3, 265, 3,
	265, 3, 266, 3, 266, 3, 266, 3, 266, 3, 266, 7, 266, 4682, 10, 266, 12,
	266, 14, 266, 4685, 11, 266, 3, 267, 3, 267, 5, 267, 4689, 10, 267, 3,
	268, 3, 268, 3, 268, 3, 268, 7, 268, 4695, 10, 268, 12, 268, 14, 268, 4698,
	11, 268, 3, 268, 3, 268, 5, 268, 4702, 10, 268, 3, 269, 3, 269, 3, 269,
	3, 269, 5, 269, 4708, 10, 269, 3, 270, 7, 270, 4711, 10, 270, 12, 270,
	14, 270, 4714, 11, 270, 3, 270, 3, 270, 5, 270, 4718, 10, 270, 3, 271,
	3, 271, 3, 271, 3, 271, 3, 271, 3, 271, 3, 271, 3, 271, 3, 271, 5, 271,
	4729, 10, 271, 3, 272, 3, 272, 5, 272, 4733, 10, 272, 3, 272, 3, 272, 3,
	272, 3, 272, 3, 272, 3, 272, 3, 272, 3, 272, 3, 272, 5, 272, 4744, 10,
	272, 5, 272, 4746, 10, 272, 3, 272, 3, 272, 3, 272, 3, 272, 3, 272, 3,
	272, 3, 272, 3, 272, 3, 272, 3, 272, 5, 272, 4758, 10, 272, 7, 272, 4760,
	10, 272, 12, 272, 14, 272, 4763, 11, 272, 3, 273, 3, 273, 3, 273, 3, 273,
	3, 273, 3, 273, 3, 273, 3, 273, 3, 273, 5, 273, 4774, 10, 273, 3, 274,
	3, 274, 3, 274, 3, 274, 5, 274, 4780, 10, 274, 5, 274, 4782, 10, 274, 3,
	275, 3, 275, 3, 275, 7, 275, 4787, 10, 275, 12, 275, 14, 275, 4790, 11,
	275, 3, 276, 3, 276, 3, 276, 3, 276, 3, 276, 3, 276, 3, 276, 5, 276, 4799,
	10, 276, 3, 277, 3, 277, 3, 278, 3, 278, 3, 279, 3, 279, 3, 280, 3, 280,
	3, 281, 3, 281, 3, 282, 3, 282, 3, 282, 3, 282, 5, 282, 4815, 10, 282,
	3, 282, 5, 282, 4818, 10, 282, 3, 282, 3, 282, 3, 282, 3, 282, 3, 283,
	3, 283, 3, 284, 3, 284, 3, 284, 7, 284, 4829, 10, 284, 12, 284, 14, 284,
	4832, 11, 284, 3, 285, 7, 285, 4835, 10, 285, 12, 285, 14, 285, 4838, 11,
	285, 3, 285, 3, 285, 3, 285, 7, 285, 4843, 10, 285, 12, 285, 14, 285, 4846,
	11, 285, 3, 285, 3, 285, 5, 285, 4850, 10, 285, 3, 286, 3, 286, 5, 286,
	4854, 10, 286, 3, 287, 5, 287, 4857, 10, 287, 3, 287, 3, 287, 3, 287, 5,
	287, 4862, 10, 287, 3, 287, 5, 287, 4865, 10, 287, 3, 288, 5, 288, 4868,
	10, 288, 3, 288, 3, 288, 5, 288, 4872, 10, 288, 7, 288, 4874, 10, 288,
	12, 288, 14, 288, 4877, 11, 288, 3, 288, 3, 288, 3, 288, 3, 288, 5, 288,
	4883, 10, 288, 3, 288, 3, 288, 5, 288, 4887, 10, 288, 3, 288, 3, 288, 3,
	288, 3, 288, 3, 288, 5, 288, 4894, 10, 288, 3, 288, 3, 288, 7, 288, 4898,
	10, 288, 12, 288, 14, 288, 4901, 11, 288, 3, 289, 3, 289, 3, 290, 3, 290,
	5, 290, 4907, 10, 290, 3, 290, 3, 290, 3, 290, 7, 290, 4912, 10, 290, 12,
	290, 14, 290, 4915, 11, 290, 3, 290, 3, 290, 3, 290, 3, 290, 5, 290, 4921,
	10, 290, 3, 290, 5, 290, 4924, 10, 290, 3, 290, 3, 290, 3, 290, 7, 290,
	4929, 10, 290, 12, 290, 14, 290, 4932, 11, 290, 3, 290, 3, 290, 3, 290,
	3, 290, 5, 290, 4938, 10, 290, 3, 290, 3, 290, 3, 290, 7, 290, 4943, 10,
	290, 12, 290, 14, 290, 4946, 11, 290, 3, 290, 3, 290, 3, 290, 3, 290, 5,
	290, 4952, 10, 290, 3, 290, 5, 290, 4955, 10, 290, 3, 290, 3, 290, 3, 290,
	7, 290, 4960, 10, 290, 12, 290, 14, 290, 4963, 11, 290, 3, 290, 3, 290,
	3, 290, 3, 290, 5, 290, 4969, 10, 290, 3, 290, 5, 290, 4972, 10, 290, 3,
	290, 3, 290, 3, 290, 7, 290, 4977, 10, 290, 12, 290, 14, 290, 4980, 11,
	290, 3, 290, 3, 290, 3, 290, 3, 290, 5, 290, 4986, 10, 290, 3, 290, 3,
	290, 3, 290, 7, 290, 4991, 10, 290, 12, 290, 14, 290, 4994, 11, 290, 3,
	290, 3, 290, 3, 290, 3, 290, 3, 290, 3, 290, 7, 290, 5002, 10, 290, 12,
	290, 14, 290, 5005, 11, 290, 3, 290, 3, 290, 3, 290, 3, 290, 5, 290, 5011,
	10, 290, 3, 290, 3, 290, 3, 290, 7, 290, 5016, 10, 290, 12, 290, 14, 290,
	5019, 11, 290, 3, 290, 3, 290, 3, 290, 3, 290, 5, 290, 5025, 10, 290, 3,
	290, 3, 290, 3, 290, 7, 290, 5030, 10, 290, 12, 290, 14, 290, 5033, 11,
	290, 3, 290, 3, 290, 5, 290, 5037, 10, 290, 3, 291, 5, 291, 5040, 10, 291,
	3, 291, 3, 291, 3, 291, 3, 291, 3, 291, 3, 291, 3, 291, 3, 291, 3, 291,
	3, 291, 3, 292, 5, 292, 5053, 10, 292, 3, 292, 3, 292, 3, 292, 3, 292,
	3, 292, 3, 292, 3, 292, 3, 292, 3, 293, 5, 293, 5064, 10, 293, 3, 293,
	3, 293, 3, 293, 3, 293, 3, 293, 3, 293, 3, 293, 3, 293, 3, 294, 5, 294,
	5075, 10, 294, 3, 294, 3, 294, 3, 294, 3, 294, 3, 294, 3, 294, 7, 294,
	5083, 10, 294, 12, 294, 14, 294, 5086, 11, 294, 3, 294, 3, 294, 3, 295,
	5, 295, 5091, 10, 295, 3, 295, 3, 295, 3, 295, 3, 295, 7, 295, 5097, 10,
	295, 12, 295, 14, 295, 5100, 11, 295, 3, 295, 3, 295, 3, 295, 3, 295, 3,
	296, 5, 296, 5107, 10, 296, 3, 296, 3, 296, 3, 296, 3, 296, 3, 296, 3,
	296, 3, 297, 5, 297, 5116, 10, 297, 3, 297, 3, 297, 3, 297, 3, 297, 3,
	297, 3, 297, 3, 297, 3, 297, 3, 298, 5, 298, 5127, 10, 298, 3, 298, 3,
	298, 3, 298, 3, 298, 3, 299, 3, 299, 3, 299, 3, 299, 5, 299, 5137, 10,
	299, 3, 299, 3, 299, 3, 299, 3, 299, 3, 299, 3, 299, 3, 299, 3, 299, 5,
	299, 5147, 10, 299, 3, 300, 3, 300, 3, 300, 3, 300, 3, 300, 3, 300, 3,
	300, 3, 300, 3, 300, 3, 300, 5, 300, 5159, 10, 300, 3, 300, 3, 300, 5,
	300, 5163, 10, 300, 3, 301, 3, 301, 3, 302, 3, 302, 3, 303, 3, 303, 3,
	304, 3, 304, 3, 305, 3, 305, 3, 306, 3, 306, 3, 307, 3, 307, 3, 308, 3,
	308, 3, 309, 3, 309, 3, 310, 3, 310, 3, 311, 3, 311, 3, 312, 3, 312, 3,
	313, 3, 313, 3, 314, 3, 314, 5, 314, 5193, 10, 314, 3, 314, 3, 314, 3,
	314, 7, 314, 5198, 10, 314, 12, 314, 14, 314, 5201, 11, 314, 3, 314, 3,
	314, 3, 315, 3, 315, 3, 315, 5, 315, 5208, 10, 315, 3, 315, 3, 315, 3,
	316, 3, 316, 3, 316, 7, 316, 5215, 10, 316, 12, 316, 14, 316, 5218, 11,
	316, 3, 316, 3, 316, 3, 316, 7, 316, 5223, 10, 316, 12, 316, 14, 316, 5226,
	11, 316, 5, 316, 5228, 10, 316, 3, 317, 3, 317, 3, 318, 3, 318, 3, 318,
	3, 318, 5, 318, 5236, 10, 318, 3, 318, 3, 318, 3, 319, 3, 319, 3, 319,
	5, 319, 5243, 10, 319, 3, 319, 3, 319, 3, 320, 3, 320, 7, 320, 5249, 10,
	320, 12, 320, 14, 320, 5252, 11, 320, 3, 321, 3, 321, 3, 321, 7, 321, 5257,
	10, 321, 12, 321, 14, 321, 5260, 11, 321, 3, 321, 3, 321, 3, 321, 7, 321,
	5265, 10, 321, 12, 321, 14, 321, 5268, 11, 321, 5, 321, 5270, 10, 321,
	3, 322, 7, 322, 5273, 10, 322, 12, 322, 14, 322, 5276, 11, 322, 3, 322,
	5, 322, 5279, 10, 322, 3, 323, 7, 323, 5282, 10, 323, 12, 323, 14, 323,
	5285, 11, 323, 3, 323, 3, 323, 3, 323, 3, 323, 5, 323, 5291, 10, 323, 3,
	323, 5, 323, 5294, 10, 323, 3, 323, 5, 323, 5297, 10, 323, 3, 324, 3, 324,
	5, 324, 5301, 10, 324, 3, 324, 3, 324, 3, 324, 7, 324, 5306, 10, 324, 12,
	324, 14, 324, 5309, 11, 324, 3, 324, 3, 324, 3, 325, 3, 325, 5, 325, 5315,
	10, 325, 3, 325, 3, 325, 3, 325, 7, 325, 5320, 10, 325, 12, 325, 14, 325,
	5323, 11, 325, 3, 325, 3, 325, 3, 326, 3, 326, 3, 326, 3, 326, 5, 326,
	5331, 10, 326, 3, 326, 3, 326, 3, 326, 3, 327, 3, 327, 3, 327, 7, 327,
	5339, 10, 327, 12, 327, 14, 327, 5342, 11, 327, 3, 327, 3, 327, 3, 327,
	7, 327, 5347, 10, 327, 12, 327, 14, 327, 5350, 11, 327, 5, 327, 5352, 10,
	327, 3, 328, 7, 328, 5355, 10, 328, 12, 328, 14, 328, 5358, 11, 328, 3,
	328, 5, 328, 5361, 10, 328, 3, 329, 7, 329, 5364, 10, 329, 12, 329, 14,
	329, 5367, 11, 329, 3, 329, 3, 329, 3, 329, 3, 329, 5, 329, 5373, 10, 329,
	3, 329, 5, 329, 5376, 10, 329, 3, 329, 5, 329, 5379, 10, 329, 3, 330, 3,
	330, 7, 330, 5383, 10, 330, 12, 330, 14, 330, 5386, 11, 330, 3, 330, 3,
	330, 3, 331, 3, 331, 3, 331, 3, 331, 3, 331, 3, 331, 3, 331, 3, 331, 3,
	331, 3, 331, 3, 332, 5, 332, 5401, 10, 332, 3, 332, 3, 332, 3, 332, 3,
	332, 3, 333, 3, 333, 3, 333, 3, 333, 3, 333, 3, 333, 3, 333, 3, 333, 3,
	333, 3, 333, 5, 333, 5417, 10, 333, 3, 334, 3, 334, 5, 334, 5421, 10, 334,
	3, 335, 3, 335, 3, 335, 3, 335, 3, 335, 3, 335, 3, 335, 5, 335, 5430, 10,
	335, 3, 336, 3, 336, 3, 336, 3, 336, 3, 336, 3, 336, 7, 336, 5438, 10,
	336, 12, 336, 14, 336, 5441, 11, 336, 3, 336, 3, 336, 3, 337, 3, 337, 3,
	337, 7, 337, 5448, 10, 337, 12, 337, 14, 337, 5451, 11, 337, 3, 337, 3,
	337, 3, 337, 3, 337, 3, 337, 5, 337, 5458, 10, 337, 3, 337, 5, 337, 5461,
	10, 337, 3, 338, 3, 338, 3, 338, 3, 338, 5, 338, 5467, 10, 338, 3, 338,
	3, 338, 3, 338, 5, 338, 5472, 10, 338, 3, 338, 7, 338, 5475, 10, 338, 12,
	338, 14, 338, 5478, 11, 338, 3, 338, 3, 338, 3, 338, 5, 338, 5483, 10,
	338, 5, 338, 5485, 10, 338, 3, 339, 3, 339, 3, 339, 5, 339, 5490, 10, 339,
	3, 340, 3, 340, 5, 340, 5494, 10, 340, 3, 340, 5, 340, 5497, 10, 340, 3,
	340, 3, 340, 3, 340, 3, 340, 5, 340, 5503, 10, 340, 3, 340, 3, 340, 3,
	340, 5, 340, 5508, 10, 340, 3, 341, 3, 341, 3, 341, 7, 341, 5513, 10, 341,
	12, 341, 14, 341, 5516, 11, 341, 3, 342, 3, 342, 3, 342, 7, 342, 5521,
	10, 342, 12, 342, 14, 342, 5524, 11, 342, 3, 343, 3, 343, 3, 343, 3, 343,
	3, 343, 3, 343, 7, 343, 5532, 10, 343, 12, 343, 14, 343, 5535, 11, 343,
	3, 343, 3, 343, 3, 344, 3, 344, 3, 344, 3, 344, 3, 345, 3, 345, 3, 345,
	3, 346, 3, 346, 3, 346, 3, 347, 3, 347, 3, 348, 3, 348, 3, 348, 3, 349,
	3, 349, 3, 349, 3, 349, 3, 349, 3, 349, 3, 349, 3, 349, 3, 349, 3, 349,
	3, 349, 3, 349, 3, 349, 3, 349, 5, 349, 5568, 10, 349, 3, 349, 3, 349,
	3, 349, 3, 349, 3, 349, 3, 349, 5, 349, 5576, 10, 349, 3, 350, 3, 350,
	3, 350, 3, 350, 3, 351, 3, 351, 3, 352, 3, 352, 3, 352, 5, 352, 5587, 10,
	352, 3, 352, 3, 352, 3, 353, 3, 353, 3, 353, 3, 353, 3, 353, 3, 353, 3,
	353, 3, 353, 5, 353, 5599, 10, 353, 3, 354, 3, 354, 3, 354, 3, 354, 3,
	355, 5, 355, 5606, 10, 355, 3, 355, 5, 355, 5609, 10, 355, 3, 355, 3, 355,
	3, 356, 3, 356, 3, 356, 5, 356, 5616, 10, 356, 3, 356, 7, 356, 5619, 10,
	356, 12, 356, 14, 356, 5622, 11, 356, 3, 356, 7, 356, 5625, 10, 356, 12,
	356, 14, 356, 5628, 11, 356, 3, 356, 3, 356, 3, 356, 5, 356, 5633, 10,
	356, 3, 357, 3, 357, 3, 357, 5, 357, 5638, 10, 357, 3, 357, 7, 357, 5641,
	10, 357, 12, 357, 14, 357, 5644, 11, 357, 3, 357, 7, 357, 5647, 10, 357,
	12, 357, 14, 357, 5650, 11, 357, 3, 357, 3, 357, 3, 357, 5, 357, 5655,
	10, 357, 3, 358, 3, 358, 3, 359, 3, 359, 7, 359, 5661, 10, 359, 12, 359,
	14, 359, 5664, 11, 359, 3, 359, 5, 359, 5667, 10, 359, 3, 360, 3, 360,
	3, 360, 5, 360, 5672, 10, 360, 3, 360, 7, 360, 5675, 10, 360, 12, 360,
	14, 360, 5678, 11, 360, 3, 360, 3, 360, 3, 361, 3, 361, 3, 361, 3, 361,
	3, 361, 5, 361, 5687, 10, 361, 3, 361, 3, 361, 3, 361, 3, 361, 3, 361,
	3, 361, 3, 361, 3, 361, 3, 361, 3, 361, 3, 361, 3, 361, 3, 361, 3, 361,
	3, 361, 3, 361, 3, 361, 3, 361, 5, 361, 5707, 10, 361, 3, 362, 3, 362,
	3, 363, 3, 363, 7, 363, 5713, 10, 363, 12, 363, 14, 363, 5716, 11, 363,
	3, 363, 5, 363, 5719, 10, 363, 3, 364, 3, 364, 3, 364, 7, 364, 5724, 10,
	364, 12, 364, 14, 364, 5727, 11, 364, 3, 365, 3, 365, 3, 365, 3, 366, 3,
	366, 3, 366, 3, 366, 3, 366, 3, 366, 5, 366, 5738, 10, 366, 3, 366, 5,
	366, 5741, 10, 366, 3, 367, 3, 367, 3, 367, 3, 367, 3, 367, 3, 367, 5,
	367, 5749, 10, 367, 3, 368, 3, 368, 3, 368, 3, 368, 3, 368, 3, 368, 3,
	368, 5, 368, 5758, 10, 368, 3, 368, 5, 368, 5761, 10, 368, 3, 369, 3, 369,
	5, 369, 5765, 10, 369, 3, 369, 3, 369, 5, 369, 5769, 10, 369, 3, 369, 3,
	369, 5, 369, 5773, 10, 369, 3, 369, 3, 369, 3, 369, 3, 369, 5, 369, 5779,
	10, 369, 3, 369, 3, 369, 3, 369, 7, 369, 5784, 10, 369, 12, 369, 14, 369,
	5787, 11, 369, 3, 370, 3, 370, 3, 370, 5, 370, 5792, 10, 370, 3, 371, 3,
	371, 5, 371, 5796, 10, 371, 3, 371, 3, 371, 5, 371, 5800, 10, 371, 3, 371,
	3, 371, 3, 372, 3, 372, 3, 372, 3, 372, 3, 372, 3, 372, 3, 372, 3, 372,
	5, 372, 5812, 10, 372, 3, 372, 3, 372, 3, 372, 3, 372, 3, 372, 7, 372,
	5819, 10, 372, 12, 372, 14, 372, 5822, 11, 372, 3, 372, 3, 372, 3, 372,
	5, 372, 5827, 10, 372, 3, 373, 3, 373, 3, 373, 5, 373, 5832, 10, 373, 5,
	373, 5834, 10, 373, 3, 373, 3, 373, 3, 373, 3, 374, 3, 374, 3, 374, 3,
	374, 5, 374, 5843, 10, 374, 3, 374, 3, 374, 3, 375, 5, 375, 5848, 10, 375,
	3, 375, 3, 375, 3, 375, 3, 375, 3, 375, 3, 375, 3, 375, 3, 375, 3, 375,
	3, 375, 3, 375, 3, 375, 7, 375, 5862, 10, 375, 12, 375, 14, 375, 5865,
	11, 375, 3, 375, 3, 375, 5, 375, 5869, 10, 375, 3, 376, 3, 376, 3, 377,
	3, 377, 3, 377, 7, 377, 5876, 10, 377, 12, 377, 14, 377, 5879, 11, 377,
	3, 378, 3, 378, 5, 378, 5883, 10, 378, 3, 379, 3, 379, 3, 379, 3, 379,
	3, 380, 5, 380, 5890, 10, 380, 3, 380, 3, 380, 3, 380, 3, 380, 3, 380,
	3, 380, 7, 380, 5898, 10, 380, 12, 380, 14, 380, 5901, 11, 380, 3, 380,
	3, 380, 3, 380, 7, 380, 5906, 10, 380, 12, 380, 14, 380, 5909, 11, 380,
	5, 380, 5911, 10, 380, 3, 380, 3, 380, 3, 380, 5, 380, 5916, 10, 380, 3,
	380, 3, 380, 3, 380, 3, 380, 3, 380, 3, 380, 3, 380, 7, 380, 5925, 10,
	380, 12, 380, 14, 380, 5928, 11, 380, 3, 380, 3, 380, 5, 380, 5932, 10,
	380, 3, 381, 3, 381, 3, 382, 3, 382, 3, 383, 3, 383, 3, 383, 7, 383, 5941,
	10, 383, 12, 383, 14, 383, 5944, 11, 383, 3, 383, 3, 383, 3, 383, 3, 383,
	3, 383, 5, 383, 5951, 10, 383, 3, 383, 5, 383, 5954, 10, 383, 3, 384, 3,
	384, 3, 384, 5, 384, 5959, 10, 384, 3, 384, 3, 384, 3, 384, 3, 384, 3,
	384, 5, 384, 5966, 10, 384, 3, 384, 5, 384, 5969, 10, 384, 3, 385, 3, 385,
	3, 385, 3, 385, 3, 385, 3, 385, 5, 385, 5977, 10, 385, 3, 385, 5, 385,
	5980, 10, 385, 3, 386, 3, 386, 3, 387, 3, 387, 3, 387, 7, 387, 5987, 10,
	387, 12, 387, 14, 387, 5990, 11, 387, 3, 387, 3, 387, 3, 388, 3, 388, 3,
	388, 3, 388, 3, 389, 3, 389, 3, 389, 7, 389, 6001, 10, 389, 12, 389, 14,
	389, 6004, 11, 389, 3, 390, 3, 390, 3, 391, 3, 391, 3, 391, 3, 391, 3,
	391, 3, 391, 3, 391, 5, 391, 6015, 10, 391, 3, 391, 3, 391, 3, 391, 3,
	391, 3, 391, 7, 391, 6022, 10, 391, 12, 391, 14, 391, 6025, 11, 391, 3,
	391, 3, 391, 3, 391, 3, 391, 3, 391, 3, 391, 3, 391, 3, 391, 7, 391, 6035,
	10, 391, 12, 391, 14, 391, 6038, 11, 391, 5, 391, 6040, 10, 391, 3, 391,
	3, 391, 5, 391, 6044, 10, 391, 3, 392, 3, 392, 3, 392, 3, 392, 3, 392,
	7, 392, 6051, 10, 392, 12, 392, 14, 392, 6054, 11, 392, 3, 392, 3, 392,
	3, 392, 3, 392, 3, 392, 3, 392, 3, 392, 3, 392, 7, 392, 6064, 10, 392,
	12, 392, 14, 392, 6067, 11, 392, 3, 392, 3, 392, 3, 392, 3, 392, 3, 392,
	3, 392, 3, 392, 3, 392, 7, 392, 6077, 10, 392, 12, 392, 14, 392, 6080,
	11, 392, 3, 392, 3, 392, 3, 392, 3, 392, 3, 392, 7, 392, 6087, 10, 392,
	12, 392, 14, 392, 6090, 11, 392, 3, 392, 3, 392, 5, 392, 6094, 10, 392,
	3, 392, 3, 392, 3, 393, 3, 393, 5, 393, 6100, 10, 393, 3, 394, 3, 394,
	5, 394, 6104, 10, 394, 3, 395, 3, 395, 5, 395, 6108, 10, 395, 3, 396, 5,
	396, 6111, 10, 396, 3, 396, 3, 396, 3, 397, 3, 397, 3, 397, 3, 397, 5,
	397, 6119, 10, 397, 3, 398, 3, 398, 3, 399, 3, 399, 3, 399, 3, 399, 3,
	399, 7, 399, 6128, 10, 399, 12, 399, 14, 399, 6131, 11, 399, 3, 399, 3,
	399, 3, 400, 3, 400, 3, 400, 3, 400, 3, 400, 7, 400, 6140, 10, 400, 12,
	400, 14, 400, 6143, 11, 400, 3, 400, 3, 400, 3, 401, 3, 401, 3, 401, 3,
	401, 3, 401, 3, 401, 3, 401, 3, 401, 3, 401, 3, 401, 3, 401, 5, 401, 6158,
	10, 401, 3, 401, 3, 401, 5, 401, 6162, 10, 401, 3, 401, 3, 401, 5, 401,
	6166, 10, 401, 3, 401, 3, 401, 3, 401, 3, 401, 3, 401, 3, 401, 3, 401,
	3, 401, 3, 401, 3, 401, 3, 401, 3, 401, 3, 401, 3, 401, 3, 401, 3, 401,
	3, 401, 3, 401, 3, 401, 5, 401, 6187, 10, 401, 3, 402, 3, 402, 3, 402,
	3, 402, 7, 402, 6193, 10, 402, 12, 402, 14, 402, 6196, 11, 402, 5, 402,
	6198, 10, 402, 3, 403, 5, 403, 6201, 10, 403, 3, 403, 3, 403, 3, 403, 3,
	403, 3, 403, 3, 403, 3, 403, 3, 403, 3, 403, 7, 403, 6212, 10, 403, 12,
	403, 14, 403, 6215, 11, 403, 3, 404, 3, 404, 3, 404, 7, 404, 6220, 10,
	404, 12, 404, 14, 404, 6223, 11, 404, 3, 405, 3, 405, 3, 405, 5, 405, 6228,
	10, 405, 3, 406, 5, 406, 6231, 10, 406, 3, 406, 3, 406, 5, 406, 6235, 10,
	406, 7, 406, 6237, 10, 406, 12, 406, 14, 406, 6240, 11, 406, 3, 407, 3,
	407, 3, 407, 3, 407, 3, 407, 3, 407, 3, 407, 3, 407, 3, 407, 3, 407, 5,
	407, 6252, 10, 407, 3, 408, 3, 408, 5, 408, 6256, 10, 408, 3, 409, 3, 409,
	3, 409, 5, 409, 6261, 10, 409, 3, 409, 3, 409, 3, 410, 3, 410, 3, 410,
	5, 410, 6268, 10, 410, 3, 411, 3, 411, 5, 411, 6272, 10, 411, 3, 412, 3,
	412, 3, 412, 5, 412, 6277, 10, 412, 3, 413, 3, 413, 3, 413, 3, 413, 3,
	413, 3, 413, 3, 414, 3, 414, 3, 414, 3, 414, 3, 414, 3, 414, 3, 415, 3,
	415, 3, 415, 3, 415, 3, 415, 3, 415, 3, 416, 3, 416, 3, 416, 5, 416, 6300,
	10, 416, 3, 417, 3, 417, 3, 417, 3, 417, 3, 417, 3, 417, 3, 417, 3, 418,
	3, 418, 3, 418, 3, 418, 3, 418, 3, 418, 3, 418, 3, 419, 3, 419, 3, 419,
	3, 419, 3, 419, 3, 419, 3, 419, 3, 420, 5, 420, 6324, 10, 420, 3, 420,
	3, 420, 5, 420, 6328, 10, 420, 3, 420, 3, 420, 3, 420, 7, 420, 6333, 10,
	420, 12, 420, 14, 420, 6336, 11, 420, 3, 420, 3, 420, 3, 420, 5, 420, 6341,
	10, 420, 3, 420, 3, 420, 3, 420, 5, 420, 6346, 10, 420, 3, 420, 3, 420,
	3, 420, 3, 420, 3, 420, 5, 420, 6353, 10, 420, 5, 420, 6355, 10, 420, 3,
	421, 3, 421, 3, 421, 3, 421, 3, 421, 3, 421, 5, 421, 6363, 10, 421, 3,
	422, 3, 422, 3, 422, 3, 422, 3, 422, 3, 422, 3, 422, 3, 422, 3, 422, 7,
	422, 6374, 10, 422, 12, 422, 14, 422, 6377, 11, 422, 3, 422, 5, 422, 6380,
	10, 422, 3, 423, 3, 423, 3, 423, 3, 423, 5, 423, 6386, 10, 423, 3, 423,
	3, 423, 5, 423, 6390, 10, 423, 3, 424, 3, 424, 5, 424, 6394, 10, 424, 3,
	424, 3, 424, 5, 424, 6398, 10, 424, 5, 424, 6400, 10, 424, 3, 424, 3, 424,
	5, 424, 6404, 10, 424, 3, 424, 5, 424, 6407, 10, 424, 3, 425, 3, 425, 3,
	425, 7, 425, 6412, 10, 425, 12, 425, 14, 425, 6415, 11, 425, 3, 426, 3,
	426, 3, 426, 5, 426, 6420, 10, 426, 3, 427, 3, 427, 5, 427, 6424, 10, 427,
	3, 427, 5, 427, 6427, 10, 427, 3, 428, 3, 428, 3, 428, 5, 428, 6432, 10,
	428, 3, 428, 3, 428, 3, 429, 3, 429, 3, 429, 3, 429, 3, 429, 3, 429, 3,
	429, 3, 429, 3, 429, 3, 429, 3, 429, 5, 429, 6447, 10, 429, 3, 430, 3,
	430, 3, 431, 3, 431, 3, 431, 3, 432, 3, 432, 3, 432, 5, 432, 6457, 10,
	432, 3, 432, 3, 432, 3, 432, 7, 432, 6462, 10, 432, 12, 432, 14, 432, 6465,
	11, 432, 3, 432, 3, 432, 3, 433, 5, 433, 6470, 10, 433, 3, 433, 3, 433,
	3, 433, 3, 433, 3, 433, 5, 433, 6477, 10, 433, 3, 433, 3, 433, 3, 433,
	3, 433, 7, 433, 6483, 10, 433, 12, 433, 14, 433, 6486, 11, 433, 3, 433,
	3, 433, 3, 434, 3, 434, 3, 434, 3, 434, 5, 434, 6494, 10, 434, 5, 434,
	6496, 10, 434, 3, 435, 3, 435, 7, 435, 6500, 10, 435, 12, 435, 14, 435,
	6503, 11, 435, 3, 435, 3, 435, 3, 435, 3, 435, 3, 435, 3, 435, 5, 435,
	6511, 10, 435, 3, 435, 3, 435, 3, 435, 7, 435, 6516, 10, 435, 12, 435,
	14, 435, 6519, 11, 435, 5, 435, 6521, 10, 435, 3, 436, 3, 436, 3, 436,
	3, 436, 3, 436, 3, 436, 3, 436, 3, 436, 3, 436, 3, 436, 5, 436, 6533, 10,
	436, 3, 437, 3, 437, 7, 437, 6537, 10, 437, 12, 437, 14, 437, 6540, 11,
	437, 3, 437, 7, 437, 6543, 10, 437, 12, 437, 14, 437, 6546, 11, 437, 3,
	437, 3, 437, 3, 438, 3, 438, 3, 438, 3, 438, 3, 438, 5, 438, 6555, 10,
	438, 3, 439, 3, 439, 3, 439, 3, 439, 3, 439, 5, 439, 6562, 10, 439, 3,
	440, 3, 440, 3, 440, 3, 440, 3, 440, 3, 440, 3, 440, 5, 440, 6571, 10,
	440, 3, 441, 3, 441, 3, 441, 3, 441, 3, 441, 3, 441, 3, 442, 3, 442, 3,
	442, 3, 442, 3, 442, 3, 442, 7, 442, 6585, 10, 442, 12, 442, 14, 442, 6588,
	11, 442, 3, 442, 3, 442, 3, 443, 3, 443, 3, 443, 7, 443, 6595, 10, 443,
	12, 443, 14, 443, 6598, 11, 443, 3, 443, 3, 443, 3, 443, 3, 443, 3, 443,
	3, 443, 5, 443, 6606, 10, 443, 3, 443, 3, 443, 3, 443, 5, 443, 6611, 10,
	443, 3, 444, 3, 444, 7, 444, 6615, 10, 444, 12, 444, 14, 444, 6618, 11,
	444, 3, 444, 3, 444, 3, 445, 3, 445, 3, 445, 3, 445, 5, 445, 6626, 10,
	445, 3, 446, 3, 446, 3, 446, 3, 446, 3, 447, 3, 447, 3, 447, 3, 447, 3,
	448, 3, 448, 3, 448, 5, 448, 6639, 10, 448, 3, 448, 3, 448, 3, 449, 3,
	449, 5, 449, 6645, 10, 449, 3, 449, 3, 449, 3, 449, 3, 450, 3, 450, 3,
	450, 5, 450, 6653, 10, 450, 3, 450, 3, 450, 3, 450, 3, 450, 3, 451, 3,
	451, 3, 451, 5, 451, 6662, 10, 451, 3, 451, 3, 451, 3, 451, 3, 451, 3,
	452, 3, 452, 3, 452, 7, 452, 6671, 10, 452, 12, 452, 14, 452, 6674, 11,
	452, 3, 453, 3, 453, 3, 453, 7, 453, 6679, 10, 453, 12, 453, 14, 453, 6682,
	11, 453, 3, 454, 3, 454, 3, 454, 3, 454, 3, 454, 5, 454, 6689, 10, 454,
	3, 455, 3, 455, 3, 455, 3, 455, 3, 455, 5, 455, 6696, 10, 455, 3, 456,
	3, 456, 3, 456, 3, 456, 3, 456, 3, 456, 5, 456, 6704, 10, 456, 3, 457,
	3, 457, 3, 457, 3, 457, 3, 457, 3, 457, 5, 457, 6712, 10, 457, 3, 458,
	3, 458, 3, 458, 3, 458, 3, 458, 5, 458, 6719, 10, 458, 3, 459, 3, 459,
	3, 459, 3, 459, 3, 459, 3, 459, 5, 459, 6727, 10, 459, 3, 459, 3, 459,
	3, 459, 3, 459, 3, 459, 3, 459, 3, 459, 3, 459, 3, 459, 3, 459, 3, 459,
	3, 459, 3, 459, 3, 459, 3, 459, 3, 459, 3, 459, 3, 459, 3, 459, 3, 459,
	3, 459, 3, 459, 3, 459, 3, 459, 5, 459, 6753, 10, 459, 5, 459, 6755, 10,
	459, 3, 460, 3, 460, 3, 461, 3, 461, 3, 462, 3, 462, 3, 463, 3, 463, 3,
	464, 3, 464, 3, 465, 3, 465, 3, 466, 3, 466, 3, 467, 3, 467, 3, 468, 3,
	468, 3, 469, 3, 469, 3, 470, 3, 470, 3, 471, 3, 471, 3, 472, 3, 472, 3,
	473, 3, 473, 3, 474, 3, 474, 3, 475, 3, 475, 3, 476, 3, 476, 3, 477, 3,
	477, 5, 477, 6793, 10, 477, 3, 477, 3, 477, 3, 477, 3, 478, 3, 478, 5,
	478, 6800, 10, 478, 3, 478, 3, 478, 5, 478, 6804, 10, 478, 3, 478, 3, 478,
	3, 478, 3, 478, 5, 478, 6810, 10, 478, 3, 478, 3, 478, 3, 478, 3, 478,
	3, 478, 3, 479, 3, 479, 5, 479, 6819, 10, 479, 3, 479, 3, 479, 5, 479,
	6823, 10, 479, 3, 479, 3, 479, 3, 479, 3, 479, 5, 479, 6829, 10, 479, 3,
	479, 3, 479, 3, 479, 3, 479, 3, 479, 3, 480, 3, 480, 3, 481, 3, 481, 3,
	482, 3, 482, 3, 482, 3, 482, 3, 482, 3, 482, 5, 482, 6846, 10, 482, 3,
	482, 3, 482, 5, 482, 6850, 10, 482, 3, 483, 3, 483, 3, 484, 3, 484, 3,
	484, 3, 484, 7, 484, 6858, 10, 484, 12, 484, 14, 484, 6861, 11, 484, 3,
	484, 3, 484, 3, 485, 3, 485, 3, 485, 3, 485, 7, 485, 6869, 10, 485, 12,
	485, 14, 485, 6872, 11, 485, 3, 485, 3, 485, 3, 486, 3, 486, 3, 486, 3,
	486, 3, 486, 3, 487, 3, 487, 3, 487, 3, 487, 7, 487, 6885, 10, 487, 12,
	487, 14, 487, 6888, 11, 487, 3, 487, 3, 487, 3, 488, 3, 488, 3, 488, 3,
	488, 3, 488, 3, 489, 3, 489, 3, 489, 3, 489, 3, 489, 3, 490, 3, 490, 3,
	490, 5, 490, 6905, 10, 490, 3, 490, 3, 490, 3, 490, 3, 491, 3, 491, 3,
	492, 3, 492, 5, 492, 6914, 10, 492, 3, 493, 3, 493, 3, 493, 3, 493, 7,
	493, 6920, 10, 493, 12, 493, 14, 493, 6923, 11, 493, 3, 493, 3, 493, 3,
	494, 3, 494, 3, 494, 3, 494, 3, 494, 3, 494, 5, 494, 6933, 10, 494, 3,
	495, 3, 495, 3, 495, 5, 495, 6938, 10, 495, 3, 496, 3, 496, 3, 496, 3,
	497, 3, 497, 3, 498, 3, 498, 7, 498, 6947, 10, 498, 12, 498, 14, 498, 6950,
	11, 498, 3, 498, 3, 498, 3, 498, 3, 498, 5, 498, 6956, 10, 498, 3, 499,
	3, 499, 3, 499, 3, 499, 3, 499, 5, 499, 6963, 10, 499, 3, 499, 3, 499,
	3, 499, 3, 499, 5, 499, 6969, 10, 499, 3, 499, 3, 499, 3, 499, 5, 499,
	6974, 10, 499, 7, 499, 6976, 10, 499, 12, 499, 14, 499, 6979, 11, 499,
	3, 499, 3, 499, 5, 499, 6983, 10, 499, 5, 499, 6985, 10, 499, 5, 499, 6987,
	10, 499, 3, 499, 3, 499, 5, 499, 6991, 10, 499, 3, 500, 3, 500, 3, 500,
	3, 500, 3, 500, 5, 500, 6998, 10, 500, 3, 500, 3, 500, 3, 500, 3, 500,
	3, 500, 3, 500, 3, 500, 3, 500, 3, 500, 5, 500, 7009, 10, 500, 3, 500,
	3, 500, 3, 500, 3, 500, 3, 500, 5, 500, 7016, 10, 500, 3, 500, 3, 500,
	3, 500, 3, 500, 3, 500, 3, 500, 3, 500, 3, 500, 3, 500, 3, 500, 3, 500,
	3, 500, 5, 500, 7030, 10, 500, 3, 500, 3, 500, 3, 500, 3, 500, 5, 500,
	7036, 10, 500, 3, 500, 5, 500, 7039, 10, 500, 3, 501, 3, 501, 3, 502, 5,
	502, 7044, 10, 502, 3, 502, 3, 502, 5, 502, 7048, 10, 502, 7, 502, 7050,
	10, 502, 12, 502, 14, 502, 7053, 11, 502, 3, 502, 3, 502, 3, 502, 3, 502,
	5, 502, 7059, 10, 502, 3, 502, 3, 502, 5, 502, 7063, 10, 502, 3, 502, 3,
	502, 3, 502, 3, 502, 3, 502, 5, 502, 7070, 10, 502, 3, 502, 3, 502, 7,
	502, 7074, 10, 502, 12, 502, 14, 502, 7077, 11, 502, 3, 503, 3, 503, 7,
	503, 7081, 10, 503, 12, 503, 14, 503, 7084, 11, 503, 3, 503, 3, 503, 3,
	503, 3, 503, 5, 503, 7090, 10, 503, 3, 503, 5, 503, 7093, 10, 503, 3, 504,
	3, 504, 5, 504, 7097, 10, 504, 3, 505, 3, 505, 7, 505, 7101, 10, 505, 12,
	505, 14, 505, 7104, 11, 505, 3, 505, 3, 505, 3, 505, 3, 505, 5, 505, 7110,
	10, 505, 3, 505, 3, 505, 3, 505, 3, 505, 3, 505, 5, 505, 7117, 10, 505,
	3, 506, 3, 506, 7, 506, 7121, 10, 506, 12, 506, 14, 506, 7124, 11, 506,
	3, 506, 3, 506, 3, 506, 5, 506, 7129, 10, 506, 3, 506, 5, 506, 7132, 10,
	506, 3, 506, 3, 506, 3, 506, 5, 506, 7137, 10, 506, 3, 506, 5, 506, 7140,
	10, 506, 3, 506, 5, 506, 7143, 10, 506, 3, 507, 3, 507, 3, 507, 3, 507,
	3, 507, 5, 507, 7150, 10, 507, 3, 508, 3, 508, 7, 508, 7154, 10, 508, 12,
	508, 14, 508, 7157, 11, 508, 3, 508, 3, 508, 3, 508, 3, 508, 7, 508, 7163,
	10, 508, 12, 508, 14, 508, 7166, 11, 508, 3, 508, 3, 508, 5, 508, 7170,
	10, 508, 3, 509, 3, 509, 3, 509, 7, 509, 7175, 10, 509, 12, 509, 14, 509,
	7178, 11, 509, 5, 509, 7180, 10, 509, 3, 509, 3, 509, 3, 509, 3, 509, 3,
	509, 7, 509, 7187, 10, 509, 12, 509, 14, 509, 7190, 11, 509, 3, 509, 3,
	509, 7, 509, 7194, 10, 509, 12, 509, 14, 509, 7197, 11, 509, 3, 509, 3,
	509, 3, 509, 5, 509, 7202, 10, 509, 3, 509, 3, 509, 7, 509, 7206, 10, 509,
	12, 509, 14, 509, 7209, 11, 509, 3, 510, 3, 510, 3, 510, 3, 510, 3, 510,
	3, 510, 5, 510, 7217, 10, 510, 3, 511, 3, 511, 3, 511, 5, 511, 7222, 10,
	511, 3, 512, 3, 512, 3, 512, 5, 512, 7227, 10, 512, 3, 513, 3, 513, 5,
	513, 7231, 10, 513, 3, 514, 3, 514, 5, 514, 7235, 10, 514, 3, 515, 3, 515,
	3, 515, 3, 515, 3, 516, 3, 516, 3, 516, 3, 516, 3, 517, 3, 517, 3, 517,
	7, 517, 7248, 10, 517, 12, 517, 14, 517, 7251, 11, 517, 5, 517, 7253, 10,
	517, 3, 517, 3, 517, 3, 517, 3, 517, 3, 517, 3, 517, 3, 517, 3, 517, 3,
	517, 3, 517, 3, 517, 5, 517, 7266, 10, 517, 5, 517, 7268, 10, 517, 3, 517,
	3, 517, 3, 517, 7, 517, 7273, 10, 517, 12, 517, 14, 517, 7276, 11, 517,
	3, 517, 3, 517, 3, 517, 3, 517, 3, 517, 7, 517, 7283, 10, 517, 12, 517,
	14, 517, 7286, 11, 517, 3, 517, 3, 517, 7, 517, 7290, 10, 517, 12, 517,
	14, 517, 7293, 11, 517, 3, 517, 3, 517, 3, 517, 3, 517, 3, 517, 3, 517,
	3, 517, 7, 517, 7302, 10, 517, 12, 517, 14, 517, 7305, 11, 517, 7, 517,
	7307, 10, 517, 12, 517, 14, 517, 7310, 11, 517, 3, 518, 3, 518, 3, 518,
	3, 518, 3, 518, 3, 518, 3, 518, 5, 518, 7319, 10, 518, 3, 519, 3, 519,
	3, 519, 3, 519, 3, 519, 3, 519, 5, 519, 7327, 10, 519, 3, 520, 3, 520,
	3, 520, 7, 520, 7332, 10, 520, 12, 520, 14, 520, 7335, 11, 520, 5, 520,
	7337, 10, 520, 3, 520, 3, 520, 3, 520, 3, 520, 3, 520, 7, 520, 7344, 10,
	520, 12, 520, 14, 520, 7347, 11, 520, 3, 520, 3, 520, 3, 520, 3, 520, 3,
	520, 7, 520, 7354, 10, 520, 12, 520, 14, 520, 7357, 11, 520, 3, 520, 3,
	520, 3, 520, 3, 520, 7, 520, 7363, 10, 520, 12, 520, 14, 520, 7366, 11,
	520, 3, 521, 3, 521, 3, 521, 3, 521, 3, 521, 3, 521, 5, 521, 7374, 10,
	521, 3, 522, 3, 522, 5, 522, 7378, 10, 522, 3, 523, 3, 523, 3, 523, 3,
	523, 3, 524, 3, 524, 3, 525, 3, 525, 3, 525, 5, 525, 7389, 10, 525, 3,
	525, 3, 525, 3, 525, 3, 525, 3, 525, 5, 525, 7396, 10, 525, 3, 525, 3,
	525, 3, 525, 3, 525, 5, 525, 7402, 10, 525, 3, 525, 3, 525, 3, 525, 5,
	525, 7407, 10, 525, 3, 525, 3, 525, 3, 525, 3, 525, 3, 525, 3, 525, 3,
	525, 3, 525, 3, 525, 3, 525, 5, 525, 7419, 10, 525, 3, 526, 3, 526, 3,
	526, 3, 526, 3, 526, 3, 526, 3, 526, 3, 526, 3, 526, 5, 526, 7430, 10,
	526, 3, 527, 3, 527, 3, 527, 5, 527, 7435, 10, 527, 3, 527, 3, 527, 3,
	527, 3, 527, 3, 527, 3, 527, 3, 527, 3, 527, 3, 527, 5, 527, 7446, 10,
	527, 3, 527, 3, 527, 3, 527, 3, 527, 3, 527, 5, 527, 7453, 10, 527, 3,
	527, 3, 527, 3, 527, 3, 527, 3, 527, 3, 527, 3, 527, 3, 527, 3, 527, 3,
	527, 3, 527, 3, 527, 3, 527, 5, 527, 7468, 10, 527, 3, 528, 3, 528, 5,
	528, 7472, 10, 528, 3, 528, 3, 528, 3, 528, 3, 528, 5, 528, 7478, 10, 528,
	3, 529, 3, 529, 5, 529, 7482, 10, 529, 3, 530, 3, 530, 3, 530, 5, 530,
	7487, 10, 530, 3, 531, 3, 531, 3, 531, 5, 531, 7492, 10, 531, 3, 531, 5,
	531, 7495, 10, 531, 3, 532, 3, 532, 3, 532, 3, 532, 7, 532, 7501, 10, 532,
	12, 532, 14, 532, 7504, 11, 532, 3, 533, 3, 533, 3, 533, 3, 533, 7, 533,
	7510, 10, 533, 12, 533, 14, 533, 7513, 11, 533, 3, 533, 3, 533, 5, 533,
	7517, 10, 533, 3, 533, 3, 533, 3, 533, 3, 533, 3, 533, 5, 533, 7524, 10,
	533, 3, 534, 3, 534, 3, 534, 3, 534, 7, 534, 7530, 10, 534, 12, 534, 14,
	534, 7533, 11, 534, 3, 534, 3, 534, 5, 534, 7537, 10, 534, 3, 534, 3, 534,
	3, 535, 3, 535, 3, 535, 3, 535, 7, 535, 7545, 10, 535, 12, 535, 14, 535,
	7548, 11, 535, 3, 536, 3, 536, 3, 536, 3, 536, 7, 536, 7554, 10, 536, 12,
	536, 14, 536, 7557, 11, 536, 3, 536, 3, 536, 5, 536, 7561, 10, 536, 3,
	536, 3, 536, 3, 536, 3, 536, 3, 536, 5, 536, 7568, 10, 536, 3, 537, 3,
	537, 3, 538, 3, 538, 3, 538, 3, 538, 3, 538, 3, 538, 3, 539, 3, 539, 3,
	539, 3, 539, 3, 539, 3, 539, 3, 539, 7, 539, 7585, 10, 539, 12, 539, 14,
	539, 7588, 11, 539, 3, 539, 3, 539, 3, 539, 5, 539, 7593, 10, 539, 3, 539,
	5, 539, 7596, 10, 539, 3, 540, 3, 540, 3, 540, 3, 540, 5, 540, 7602, 10,
	540, 3, 540, 3, 540, 3, 540, 3, 540, 3, 540, 3, 540, 3, 540, 7, 540, 7611,
	10, 540, 12, 540, 14, 540, 7614, 11, 540, 3, 540, 3, 540, 3, 540, 5, 540,
	7619, 10, 540, 3, 540, 3, 540, 5, 540, 7623, 10, 540, 3, 541, 3, 541, 3,
	541, 3, 541, 5, 541, 7629, 10, 541, 3, 541, 3, 541, 3, 541, 3, 542, 3,
	542, 3, 543, 3, 543, 3, 544, 3, 544, 3, 545, 3, 545, 3, 546, 3, 546, 3,
	547, 3, 547, 3, 548, 3, 548, 3, 548, 3, 548, 7, 548, 7650, 10, 548, 12,
	548, 14, 548, 7653, 11, 548, 3, 548, 3, 548, 3, 549, 3, 549, 3, 549, 5,
	549, 7660, 10, 549, 3, 550, 3, 550, 3, 551, 3, 551, 3, 552, 3, 552, 3,
	553, 3, 553, 3, 554, 3, 554, 3, 555, 3, 555, 3, 556, 3, 556, 3, 557, 3,
	557, 3, 558, 3, 558, 3, 559, 3, 559, 3, 560, 3, 560, 3, 561, 3, 561, 3,
	562, 3, 562, 3, 563, 3, 563, 3, 564, 3, 564, 3, 565, 3, 565, 3, 566, 3,
	566, 3, 567, 3, 567, 3, 568, 3, 568, 3, 569, 3, 569, 3, 570, 3, 570, 3,
	571, 3, 571, 3, 572, 3, 572, 3, 573, 3, 573, 3, 574, 3, 574, 3, 575, 3,
	575, 3, 576, 5, 576, 7715, 10, 576, 3, 576, 3, 576, 3, 576, 3, 576, 7,
	576, 7721, 10, 576, 12, 576, 14, 576, 7724, 11, 576, 3, 576, 3, 576, 3,
	577, 3, 577, 3, 578, 3, 578, 3, 579, 3, 579, 3, 580, 3, 580, 3, 581, 3,
	581, 3, 582, 3, 582, 3, 583, 3, 583, 3, 584, 3, 584, 3, 585, 3, 585, 3,
	586, 3, 586, 3, 587, 3, 587, 3, 588, 3, 588, 3, 589, 3, 589, 3, 590, 3,
	590, 3, 591, 3, 591, 3, 592, 3, 592, 3, 593, 3, 593, 3, 594, 3, 594, 3,
	595, 3, 595, 3, 596, 3, 596, 3, 597, 3, 597, 3, 598, 3, 598, 3, 599, 3,
	599, 3, 600, 3, 600, 5, 600, 7776, 10, 600, 3, 600, 3, 600, 3, 601, 3,
	601, 3, 602, 3, 602, 3, 603, 3, 603, 3, 604, 3, 604, 3, 605, 3, 605, 3,
	606, 5, 606, 7791, 10, 606, 3, 606, 3, 606, 3, 607, 5, 607, 7796, 10, 607,
	3, 607, 3, 607, 3, 608, 5, 608, 7801, 10, 608, 3, 608, 3, 608, 3, 609,
	5, 609, 7806, 10, 609, 3, 609, 3, 609, 3, 610, 3, 610, 3, 610, 3, 610,
	3, 610, 5, 610, 7815, 10, 610, 3, 610, 3, 610, 3, 611, 5, 611, 7820, 10,
	611, 3, 611, 3, 611, 5, 611, 7824, 10, 611, 3, 612, 5, 612, 7827, 10, 612,
	3, 612, 3, 612, 5, 612, 7831, 10, 612, 3, 613, 5, 613, 7834, 10, 613, 3,
	613, 3, 613, 5, 613, 7838, 10, 613, 3, 614, 5, 614, 7841, 10, 614, 3, 614,
	3, 614, 5, 614, 7845, 10, 614, 3, 615, 3, 615, 5, 615, 7849, 10, 615, 3,
	615, 3, 615, 3, 615, 3, 615, 3, 615, 3, 615, 5, 615, 7857, 10, 615, 3,
	615, 3, 615, 7, 615, 7861, 10, 615, 12, 615, 14, 615, 7864, 11, 615, 3,
	615, 5, 615, 7867, 10, 615, 3, 616, 3, 616, 3, 616, 3, 616, 5, 616, 7873,
	10, 616, 3, 616, 3, 616, 3, 617, 3, 617, 3, 618, 3, 618, 3, 619, 3, 619,
	3, 620, 3, 620, 3, 621, 3, 621, 3, 622, 3, 622, 3, 623, 3, 623, 3, 624,
	3, 624, 3, 624, 2, 10, 450, 464, 506, 542, 736, 1016, 1032, 1038, 625,
	2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38,
	40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74,
	76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108,
	110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138,
	140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168,
	170, 172, 174, 176, 178, 180, 182, 184, 186, 188, 190, 192, 194, 196, 198,
	200, 202, 204, 206, 208, 210, 212, 214, 216, 218, 220, 222, 224, 226, 228,
	230, 232, 234, 236, 238, 240, 242, 244, 246, 248, 250, 252, 254, 256, 258,
	260, 262, 264, 266, 268, 270, 272, 274, 276, 278, 280, 282, 284, 286, 288,
	290, 292, 294, 296, 298, 300, 302, 304, 306, 308, 310, 312, 314, 316, 318,
	320, 322, 324, 326, 328, 330, 332, 334, 336, 338, 340, 342, 344, 346, 348,
	350, 352, 354, 356, 358, 360, 362, 364, 366, 368, 370, 372, 374, 376, 378,
	380, 382, 384, 386, 388, 390, 392, 394, 396, 398, 400, 402, 404, 406, 408,
	410, 412, 414, 416, 418, 420, 422, 424, 426, 428, 430, 432, 434, 436, 438,
	440, 442, 444, 446, 448, 450, 452, 454, 456, 458, 460, 462, 464, 466, 468,
	470, 472, 474, 476, 478, 480, 482, 484, 486, 488, 490, 492, 494, 496, 498,
	500, 502, 504, 506, 508, 510, 512, 514, 516, 518, 520, 522, 524, 526, 528,
	530, 532, 534, 536, 538, 540, 542, 544, 546, 548, 550, 552, 554, 556, 558,
	560, 562, 564, 566, 568, 570, 572, 574, 576, 578, 580, 582, 584, 586, 588,
	590, 592, 594, 596, 598, 600, 602, 604, 606, 608, 610, 612, 614, 616, 618,
	620, 622, 624, 626, 628, 630, 632, 634, 636, 638, 640, 642, 644, 646, 648,
	650, 652, 654, 656, 658, 660, 662, 664, 666, 668, 670, 672, 674, 676, 678,
	680, 682, 684, 686, 688, 690, 692, 694, 696, 698, 700, 702, 704, 706, 708,
	710, 712, 714, 716, 718, 720, 722, 724, 726, 728, 730, 732, 734, 736, 738,
	740, 742, 744, 746, 748, 750, 752, 754, 756, 758, 760, 762, 764, 766, 768,
	770, 772, 774, 776, 778, 780, 782, 784, 786, 788, 790, 792, 794, 796, 798,
	800, 802, 804, 806, 808, 810, 812, 814, 816, 818, 820, 822, 824, 826, 828,
	830, 832, 834, 836, 838, 840, 842, 844, 846, 848, 850, 852, 854, 856, 858,
	860, 862, 864, 866, 868, 870, 872, 874, 876, 878, 880, 882, 884, 886, 888,
	890, 892, 894, 896, 898, 900, 902, 904, 906, 908, 910, 912, 914, 916, 918,
	920, 922, 924, 926, 928, 930, 932, 934, 936, 938, 940, 942, 944, 946, 948,
	950, 952, 954, 956, 958, 960, 962, 964, 966, 968, 970, 972, 974, 976, 978,
	980, 982, 984, 986, 988, 990, 992, 994, 996, 998, 1000, 1002, 1004, 1006,
	1008, 1010, 1012, 1014, 1016, 1018, 1020, 1022, 1024, 1026, 1028, 1030,
	1032, 1034, 1036, 1038, 1040, 1042, 1044, 1046, 1048, 1050, 1052, 1054,
	1056, 1058, 1060, 1062, 1064, 1066, 1068, 1070, 1072, 1074, 1076, 1078,
	1080, 1082, 1084, 1086, 1088, 1090, 1092, 1094, 1096, 1098, 1100, 1102,
	1104, 1106, 1108, 1110, 1112, 1114, 1116, 1118, 1120, 1122, 1124, 1126,
	1128, 1130, 1132, 1134, 1136, 1138, 1140, 1142, 1144, 1146, 1148, 1150,
	1152, 1154, 1156, 1158, 1160, 1162, 1164, 1166, 1168, 1170, 1172, 1174,
	1176, 1178, 1180, 1182, 1184, 1186, 1188, 1190, 1192, 1194, 1196, 1198,
	1200, 1202, 1204, 1206, 1208, 1210, 1212, 1214, 1216, 1218, 1220, 1222,
	1224, 1226, 1228, 1230, 1232, 1234, 1236, 1238, 1240, 1242, 1244, 1246,
	2, 67, 4, 2, 213, 213, 218, 218, 5, 2, 193, 194, 233, 233, 259, 259, 5,
	2, 17, 17, 19, 19, 22, 22, 4, 2, 194, 194, 233, 233, 5, 2, 209, 209, 243,
	243, 287, 287, 3, 2, 251, 252, 4, 2, 45, 45, 47, 47, 4, 2, 167, 167, 250,
	250, 4, 2, 276, 276, 328, 328, 4, 2, 105, 105, 287, 287, 4, 2, 348, 351,
	353, 353, 7, 2, 116, 116, 197, 198, 212, 212, 278, 278, 303, 303, 5, 2,
	111, 111, 211, 211, 260, 260, 4, 2, 257, 258, 279, 279, 8, 2, 295, 296,
	309, 314, 326, 326, 333, 333, 339, 339, 342, 342, 4, 2, 281, 281, 321,
	321, 6, 2, 244, 244, 291, 291, 295, 295, 335, 335, 6, 2, 245, 245, 292,
	292, 296, 296, 336, 336, 5, 2, 205, 205, 215, 215, 282, 282, 3, 2, 9, 10,
	4, 2, 129, 129, 250, 250, 4, 2, 165, 165, 189, 189, 4, 2, 13, 14, 62, 63,
	4, 2, 290, 290, 334, 334, 4, 2, 223, 223, 273, 273, 4, 2, 97, 97, 272,
	272, 4, 2, 163, 163, 271, 271, 5, 2, 95, 95, 261, 261, 297, 298, 9, 2,
	62, 63, 101, 101, 183, 183, 188, 188, 232, 232, 274, 275, 322, 323, 4,
	2, 193, 194, 233, 233, 6, 2, 101, 101, 201, 201, 232, 232, 341, 341, 4,
	2, 107, 107, 144, 144, 4, 2, 109, 109, 185, 186, 5, 2, 32, 32, 80, 80,
	87, 87, 4, 2, 26, 26, 60, 60, 4, 2, 125, 125, 256, 256, 4, 2, 114, 115,
	228, 229, 5, 2, 224, 224, 238, 238, 266, 267, 7, 2, 101, 101, 219, 219,
	225, 225, 232, 232, 343, 344, 4, 2, 113, 113, 227, 227, 4, 2, 269, 270,
	307, 308, 4, 2, 268, 268, 306, 306, 3, 2, 97, 100, 13, 2, 24, 24, 28, 28,
	36, 36, 42, 42, 57, 57, 61, 61, 72, 72, 76, 77, 80, 81, 91, 91, 93, 93,
	4, 2, 103, 103, 171, 171, 4, 2, 135, 135, 262, 262, 3, 2, 202, 204, 4,
	2, 38, 38, 232, 232, 4, 2, 240, 240, 319, 320, 3, 2, 117, 119, 4, 2, 263,
	263, 337, 337, 4, 2, 15, 15, 168, 168, 3, 2, 248, 249, 4, 2, 226, 226,
	280, 280, 5, 2, 142, 142, 220, 220, 239, 239, 4, 2, 3, 3, 69, 69, 4, 2,
	74, 74, 89, 89, 4, 2, 43, 44, 70, 70, 4, 2, 44, 44, 70, 70, 8, 2, 3, 3,
	5, 5, 25, 25, 55, 56, 59, 59, 65, 69, 19, 2, 3, 4, 6, 8, 23, 23, 25, 26,
	32, 32, 34, 34, 41, 41, 55, 56, 59, 60, 67, 67, 69, 69, 71, 71, 73, 75,
	78, 79, 82, 84, 86, 89, 92, 92, 4, 2, 4, 4, 71, 71, 7, 2, 5, 5, 25, 25,
	55, 56, 59, 59, 65, 68, 8, 2, 6, 6, 25, 26, 55, 56, 59, 60, 67, 67, 82,
	82, 3, 2, 348, 353, 2, 8553, 2, 1251, 3, 2, 2, 2, 4, 1258, 3, 2, 2, 2,
	6, 1260, 3, 2, 2, 2, 8, 1283, 3, 2, 2, 2, 10, 1288, 3, 2, 2, 2, 12, 1313,
	3, 2, 2, 2, 14, 1318, 3, 2, 2, 2, 16, 1341, 3, 2, 2, 2, 18, 1427, 3, 2,
	2, 2, 20, 1429, 3, 2, 2, 2, 22, 1492, 3, 2, 2, 2, 24, 1497, 3, 2, 2, 2,
	26, 1520, 3, 2, 2, 2, 28, 1603, 3, 2, 2, 2, 30, 1608, 3, 2, 2, 2, 32, 1631,
	3, 2, 2, 2, 34, 1653, 3, 2, 2, 2, 36, 1681, 3, 2, 2, 2, 38, 1724, 3, 2,
	2, 2, 40, 1728, 3, 2, 2, 2, 42, 1770, 3, 2, 2, 2, 44, 1772, 3, 2, 2, 2,
	46, 1780, 3, 2, 2, 2, 48, 1829, 3, 2, 2, 2, 50, 1831, 3, 2, 2, 2, 52, 1855,
	3, 2, 2, 2, 54, 1857, 3, 2, 2, 2, 56, 1868, 3, 2, 2, 2, 58, 1896, 3, 2,
	2, 2, 60, 1917, 3, 2, 2, 2, 62, 1931, 3, 2, 2, 2, 64, 1933, 3, 2, 2, 2,
	66, 1936, 3, 2, 2, 2, 68, 1939, 3, 2, 2, 2, 70, 1944, 3, 2, 2, 2, 72, 1958,
	3, 2, 2, 2, 74, 2000, 3, 2, 2, 2, 76, 2020, 3, 2, 2, 2, 78, 2035, 3, 2,
	2, 2, 80, 2041, 3, 2, 2, 2, 82, 2046, 3, 2, 2, 2, 84, 2068, 3, 2, 2, 2,
	86, 2084, 3, 2, 2, 2, 88, 2086, 3, 2, 2, 2, 90, 2090, 3, 2, 2, 2, 92, 2104,
	3, 2, 2, 2, 94, 2106, 3, 2, 2, 2, 96, 2109, 3, 2, 2, 2, 98, 2121, 3, 2,
	2, 2, 100, 2123, 3, 2, 2, 2, 102, 2146, 3, 2, 2, 2, 104, 2175, 3, 2, 2,
	2, 106, 2177, 3, 2, 2, 2, 108, 2179, 3, 2, 2, 2, 110, 2182, 3, 2, 2, 2,
	112, 2190, 3, 2, 2, 2, 114, 2198, 3, 2, 2, 2, 116, 2239, 3, 2, 2, 2, 118,
	2244, 3, 2, 2, 2, 120, 2251, 3, 2, 2, 2, 122, 2263, 3, 2, 2, 2, 124, 2271,
	3, 2, 2, 2, 126, 2277, 3, 2, 2, 2, 128, 2294, 3, 2, 2, 2, 130, 2300, 3,
	2, 2, 2, 132, 2302, 3, 2, 2, 2, 134, 2313, 3, 2, 2, 2, 136, 2331, 3, 2,
	2, 2, 138, 2340, 3, 2, 2, 2, 140, 2363, 3, 2, 2, 2, 142, 2369, 3, 2, 2,
	2, 144, 2389, 3, 2, 2, 2, 146, 2413, 3, 2, 2, 2, 148, 2450, 3, 2, 2, 2,
	150, 2452, 3, 2, 2, 2, 152, 2465, 3, 2, 2, 2, 154, 2467, 3, 2, 2, 2, 156,
	2471, 3, 2, 2, 2, 158, 2473, 3, 2, 2, 2, 160, 2480, 3, 2, 2, 2, 162, 2484,
	3, 2, 2, 2, 164, 2486, 3, 2, 2, 2, 166, 2529, 3, 2, 2, 2, 168, 2535, 3,
	2, 2, 2, 170, 2551, 3, 2, 2, 2, 172, 2553, 3, 2, 2, 2, 174, 2565, 3, 2,
	2, 2, 176, 2606, 3, 2, 2, 2, 178, 2608, 3, 2, 2, 2, 180, 2624, 3, 2, 2,
	2, 182, 2626, 3, 2, 2, 2, 184, 2634, 3, 2, 2, 2, 186, 2638, 3, 2, 2, 2,
	188, 2642, 3, 2, 2, 2, 190, 2651, 3, 2, 2, 2, 192, 2654, 3, 2, 2, 2, 194,
	2661, 3, 2, 2, 2, 196, 2673, 3, 2, 2, 2, 198, 2691, 3, 2, 2, 2, 200, 2693,
	3, 2, 2, 2, 202, 2709, 3, 2, 2, 2, 204, 2711, 3, 2, 2, 2, 206, 2719, 3,
	2, 2, 2, 208, 2727, 3, 2, 2, 2, 210, 2734, 3, 2, 2, 2, 212, 2738, 3, 2,
	2, 2, 214, 2747, 3, 2, 2, 2, 216, 2756, 3, 2, 2, 2, 218, 2763, 3, 2, 2,
	2, 220, 2783, 3, 2, 2, 2, 222, 2785, 3, 2, 2, 2, 224, 2796, 3, 2, 2, 2,
	226, 2802, 3, 2, 2, 2, 228, 2816, 3, 2, 2, 2, 230, 2867, 3, 2, 2, 2, 232,
	2900, 3, 2, 2, 2, 234, 2924, 3, 2, 2, 2, 236, 2926, 3, 2, 2, 2, 238, 2933,
	3, 2, 2, 2, 240, 3021, 3, 2, 2, 2, 242, 3025, 3, 2, 2, 2, 244, 3028, 3,
	2, 2, 2, 246, 3051, 3, 2, 2, 2, 248, 3053, 3, 2, 2, 2, 250, 3067, 3, 2,
	2, 2, 252, 3070, 3, 2, 2, 2, 254, 3086, 3, 2, 2, 2, 256, 3088, 3, 2, 2,
	2, 258, 3090, 3, 2, 2, 2, 260, 3092, 3, 2, 2, 2, 262, 3094, 3, 2, 2, 2,
	264, 3103, 3, 2, 2, 2, 266, 3105, 3, 2, 2, 2, 268, 3110, 3, 2, 2, 2, 270,
	3112, 3, 2, 2, 2, 272, 3118, 3, 2, 2, 2, 274, 3123, 3, 2, 2, 2, 276, 3135,
	3, 2, 2, 2, 278, 3142, 3, 2, 2, 2, 280, 3144, 3, 2, 2, 2, 282, 3182, 3,
	2, 2, 2, 284, 3184, 3, 2, 2, 2, 286, 3186, 3, 2, 2, 2, 288, 3188, 3, 2,
	2, 2, 290, 3192, 3, 2, 2, 2, 292, 3208, 3, 2, 2, 2, 294, 3225, 3, 2, 2,
	2, 296, 3227, 3, 2, 2, 2, 298, 3235, 3, 2, 2, 2, 300, 3243, 3, 2, 2, 2,
	302, 3263, 3, 2, 2, 2, 304, 3271, 3, 2, 2, 2, 306, 3279, 3, 2, 2, 2, 308,
	3299, 3, 2, 2, 2, 310, 3307, 3, 2, 2, 2, 312, 3315, 3, 2, 2, 2, 314, 3343,
	3, 2, 2, 2, 316, 3351, 3, 2, 2, 2, 318, 3359, 3, 2, 2, 2, 320, 3379, 3,
	2, 2, 2, 322, 3407, 3, 2, 2, 2, 324, 3411, 3, 2, 2, 2, 326, 3422, 3, 2,
	2, 2, 328, 3438, 3, 2, 2, 2, 330, 3440, 3, 2, 2, 2, 332, 3445, 3, 2, 2,
	2, 334, 3461, 3, 2, 2, 2, 336, 3463, 3, 2, 2, 2, 338, 3465, 3, 2, 2, 2,
	340, 3495, 3, 2, 2, 2, 342, 3509, 3, 2, 2, 2, 344, 3511, 3, 2, 2, 2, 346,
	3521, 3, 2, 2, 2, 348, 3533, 3, 2, 2, 2, 350, 3535, 3, 2, 2, 2, 352, 3546,
	3, 2, 2, 2, 354, 3548, 3, 2, 2, 2, 356, 3556, 3, 2, 2, 2, 358, 3561, 3,
	2, 2, 2, 360, 3563, 3, 2, 2, 2, 362, 3569, 3, 2, 2, 2, 364, 3609, 3, 2,
	2, 2, 366, 3658, 3, 2, 2, 2, 368, 3660, 3, 2, 2, 2, 370, 3662, 3, 2, 2,
	2, 372, 3664, 3, 2, 2, 2, 374, 3666, 3, 2, 2, 2, 376, 3668, 3, 2, 2, 2,
	378, 3670, 3, 2, 2, 2, 380, 3680, 3, 2, 2, 2, 382, 3717, 3, 2, 2, 2, 384,
	3719, 3, 2, 2, 2, 386, 3730, 3, 2, 2, 2, 388, 3756, 3, 2, 2, 2, 390, 3761,
	3, 2, 2, 2, 392, 3772, 3, 2, 2, 2, 394, 3803, 3, 2, 2, 2, 396, 3805, 3,
	2, 2, 2, 398, 3816, 3, 2, 2, 2, 400, 3831, 3, 2, 2, 2, 402, 3839, 3, 2,
	2, 2, 404, 3842, 3, 2, 2, 2, 406, 3860, 3, 2, 2, 2, 408, 3862, 3, 2, 2,
	2, 410, 3873, 3, 2, 2, 2, 412, 3875, 3, 2, 2, 2, 414, 3884, 3, 2, 2, 2,
	416, 3891, 3, 2, 2, 2, 418, 3893, 3, 2, 2, 2, 420, 3900, 3, 2, 2, 2, 422,
	3907, 3, 2, 2, 2, 424, 3914, 3, 2, 2, 2, 426, 3920, 3, 2, 2, 2, 428, 3938,
	3, 2, 2, 2, 430, 3945, 3, 2, 2, 2, 432, 3973, 3, 2, 2, 2, 434, 3991, 3,
	2, 2, 2, 436, 3996, 3, 2, 2, 2, 438, 3998, 3, 2, 2, 2, 440, 4023, 3, 2,
	2, 2, 442, 4034, 3, 2, 2, 2, 444, 4055, 3, 2, 2, 2, 446, 4059, 3, 2, 2,
	2, 448, 4062, 3, 2, 2, 2, 450, 4145, 3, 2, 2, 2, 452, 4174, 3, 2, 2, 2,
	454, 4176, 3, 2, 2, 2, 456, 4201, 3, 2, 2, 2, 458, 4212, 3, 2, 2, 2, 460,
	4233, 3, 2, 2, 2, 462, 4238, 3, 2, 2, 2, 464, 4291, 3, 2, 2, 2, 466, 4312,
	3, 2, 2, 2, 468, 4323, 3, 2, 2, 2, 470, 4330, 3, 2, 2, 2, 472, 4332, 3,
	2, 2, 2, 474, 4360, 3, 2, 2, 2, 476, 4378, 3, 2, 2, 2, 478, 4383, 3, 2,
	2, 2, 480, 4385, 3, 2, 2, 2, 482, 4387, 3, 2, 2, 2, 484, 4396, 3, 2, 2,
	2, 486, 4401, 3, 2, 2, 2, 488, 4408, 3, 2, 2, 2, 490, 4410, 3, 2, 2, 2,
	492, 4416, 3, 2, 2, 2, 494, 4424, 3, 2, 2, 2, 496, 4428, 3, 2, 2, 2, 498,
	4455, 3, 2, 2, 2, 500, 4474, 3, 2, 2, 2, 502, 4478, 3, 2, 2, 2, 504, 4486,
	3, 2, 2, 2, 506, 4488, 3, 2, 2, 2, 508, 4509, 3, 2, 2, 2, 510, 4517, 3,
	2, 2, 2, 512, 4547, 3, 2, 2, 2, 514, 4620, 3, 2, 2, 2, 516, 4622, 3, 2,
	2, 2, 518, 4624, 3, 2, 2, 2, 520, 4637, 3, 2, 2, 2, 522, 4645, 3, 2, 2,
	2, 524, 4653, 3, 2, 2, 2, 526, 4655, 3, 2, 2, 2, 528, 4663, 3, 2, 2, 2,
	530, 4676, 3, 2, 2, 2, 532, 4688, 3, 2, 2, 2, 534, 4701, 3, 2, 2, 2, 536,
	4707, 3, 2, 2, 2, 538, 4712, 3, 2, 2, 2, 540, 4719, 3, 2, 2, 2, 542, 4745,
	3, 2, 2, 2, 544, 4764, 3, 2, 2, 2, 546, 4781, 3, 2, 2, 2, 548, 4783, 3,
	2, 2, 2, 550, 4798, 3, 2, 2, 2, 552, 4800, 3, 2, 2, 2, 554, 4802, 3, 2,
	2, 2, 556, 4804, 3, 2, 2, 2, 558, 4806, 3, 2, 2, 2, 560, 4808, 3, 2, 2,
	2, 562, 4810, 3, 2, 2, 2, 564, 4823, 3, 2, 2, 2, 566, 4825, 3, 2, 2, 2,
	568, 4836, 3, 2, 2, 2, 570, 4853, 3, 2, 2, 2, 572, 4856, 3, 2, 2, 2, 574,
	4886, 3, 2, 2, 2, 576, 4902, 3, 2, 2, 2, 578, 5036, 3, 2, 2, 2, 580, 5039,
	3, 2, 2, 2, 582, 5052, 3, 2, 2, 2, 584, 5063, 3, 2, 2, 2, 586, 5074, 3,
	2, 2, 2, 588, 5090, 3, 2, 2, 2, 590, 5106, 3, 2, 2, 2, 592, 5115, 3, 2,
	2, 2, 594, 5126, 3, 2, 2, 2, 596, 5146, 3, 2, 2, 2, 598, 5162, 3, 2, 2,
	2, 600, 5164, 3, 2, 2, 2, 602, 5166, 3, 2, 2, 2, 604, 5168, 3, 2, 2, 2,
	606, 5170, 3, 2, 2, 2, 608, 5172, 3, 2, 2, 2, 610, 5174, 3, 2, 2, 2, 612,
	5176, 3, 2, 2, 2, 614, 5178, 3, 2, 2, 2, 616, 5180, 3, 2, 2, 2, 618, 5182,
	3, 2, 2, 2, 620, 5184, 3, 2, 2, 2, 622, 5186, 3, 2, 2, 2, 624, 5188, 3,
	2, 2, 2, 626, 5190, 3, 2, 2, 2, 628, 5204, 3, 2, 2, 2, 630, 5227, 3, 2,
	2, 2, 632, 5229, 3, 2, 2, 2, 634, 5231, 3, 2, 2, 2, 636, 5239, 3, 2, 2,
	2, 638, 5246, 3, 2, 2, 2, 640, 5269, 3, 2, 2, 2, 642, 5274, 3, 2, 2, 2,
	644, 5283, 3, 2, 2, 2, 646, 5298, 3, 2, 2, 2, 648, 5312, 3, 2, 2, 2, 650,
	5326, 3, 2, 2, 2, 652, 5351, 3, 2, 2, 2, 654, 5356, 3, 2, 2, 2, 656, 5365,
	3, 2, 2, 2, 658, 5380, 3, 2, 2, 2, 660, 5389, 3, 2, 2, 2, 662, 5400, 3,
	2, 2, 2, 664, 5416, 3, 2, 2, 2, 666, 5420, 3, 2, 2, 2, 668, 5422, 3, 2,
	2, 2, 670, 5431, 3, 2, 2, 2, 672, 5460, 3, 2, 2, 2, 674, 5484, 3, 2, 2,
	2, 676, 5489, 3, 2, 2, 2, 678, 5491, 3, 2, 2, 2, 680, 5509, 3, 2, 2, 2,
	682, 5517, 3, 2, 2, 2, 684, 5525, 3, 2, 2, 2, 686, 5538, 3, 2, 2, 2, 688,
	5542, 3, 2, 2, 2, 690, 5545, 3, 2, 2, 2, 692, 5548, 3, 2, 2, 2, 694, 5550,
	3, 2, 2, 2, 696, 5575, 3, 2, 2, 2, 698, 5577, 3, 2, 2, 2, 700, 5581, 3,
	2, 2, 2, 702, 5583, 3, 2, 2, 2, 704, 5598, 3, 2, 2, 2, 706, 5600, 3, 2,
	2, 2, 708, 5608, 3, 2, 2, 2, 710, 5612, 3, 2, 2, 2, 712, 5634, 3, 2, 2,
	2, 714, 5656, 3, 2, 2, 2, 716, 5666, 3, 2, 2, 2, 718, 5671, 3, 2, 2, 2,
	720, 5706, 3, 2, 2, 2, 722, 5708, 3, 2, 2, 2, 724, 5718, 3, 2, 2, 2, 726,
	5720, 3, 2, 2, 2, 728, 5728, 3, 2, 2, 2, 730, 5740, 3, 2, 2, 2, 732, 5742,
	3, 2, 2, 2, 734, 5750, 3, 2, 2, 2, 736, 5778, 3, 2, 2, 2, 738, 5791, 3,
	2, 2, 2, 740, 5799, 3, 2, 2, 2, 742, 5826, 3, 2, 2, 2, 744, 5833, 3, 2,
	2, 2, 746, 5838, 3, 2, 2, 2, 748, 5847, 3, 2, 2, 2, 750, 5870, 3, 2, 2,
	2, 752, 5872, 3, 2, 2, 2, 754, 5882, 3, 2, 2, 2, 756, 5884, 3, 2, 2, 2,
	758, 5931, 3, 2, 2, 2, 760, 5933, 3, 2, 2, 2, 762, 5935, 3, 2, 2, 2, 764,
	5953, 3, 2, 2, 2, 766, 5968, 3, 2, 2, 2, 768, 5979, 3, 2, 2, 2, 770, 5981,
	3, 2, 2, 2, 772, 5983, 3, 2, 2, 2, 774, 5993, 3, 2, 2, 2, 776, 5997, 3,
	2, 2, 2, 778, 6005, 3, 2, 2, 2, 780, 6043, 3, 2, 2, 2, 782, 6045, 3, 2,
	2, 2, 784, 6099, 3, 2, 2, 2, 786, 6103, 3, 2, 2, 2, 788, 6107, 3, 2, 2,
	2, 790, 6110, 3, 2, 2, 2, 792, 6118, 3, 2, 2, 2, 794, 6120, 3, 2, 2, 2,
	796, 6122, 3, 2, 2, 2, 798, 6134, 3, 2, 2, 2, 800, 6186, 3, 2, 2, 2, 802,
	6197, 3, 2, 2, 2, 804, 6200, 3, 2, 2, 2, 806, 6216, 3, 2, 2, 2, 808, 6227,
	3, 2, 2, 2, 810, 6230, 3, 2, 2, 2, 812, 6251, 3, 2, 2, 2, 814, 6255, 3,
	2, 2, 2, 816, 6260, 3, 2, 2, 2, 818, 6267, 3, 2, 2, 2, 820, 6271, 3, 2,
	2, 2, 822, 6276, 3, 2, 2, 2, 824, 6278, 3, 2, 2, 2, 826, 6284, 3, 2, 2,
	2, 828, 6290, 3, 2, 2, 2, 830, 6299, 3, 2, 2, 2, 832, 6301, 3, 2, 2, 2,
	834, 6308, 3, 2, 2, 2, 836, 6315, 3, 2, 2, 2, 838, 6354, 3, 2, 2, 2, 840,
	6356, 3, 2, 2, 2, 842, 6379, 3, 2, 2, 2, 844, 6389, 3, 2, 2, 2, 846, 6406,
	3, 2, 2, 2, 848, 6408, 3, 2, 2, 2, 850, 6416, 3, 2, 2, 2, 852, 6426, 3,
	2, 2, 2, 854, 6428, 3, 2, 2, 2, 856, 6435, 3, 2, 2, 2, 858, 6448, 3, 2,
	2, 2, 860, 6450, 3, 2, 2, 2, 862, 6453, 3, 2, 2, 2, 864, 6469, 3, 2, 2,
	2, 866, 6489, 3, 2, 2, 2, 868, 6520, 3, 2, 2, 2, 870, 6532, 3, 2, 2, 2,
	872, 6534, 3, 2, 2, 2, 874, 6554, 3, 2, 2, 2, 876, 6556, 3, 2, 2, 2, 878,
	6563, 3, 2, 2, 2, 880, 6572, 3, 2, 2, 2, 882, 6578, 3, 2, 2, 2, 884, 6610,
	3, 2, 2, 2, 886, 6612, 3, 2, 2, 2, 888, 6625, 3, 2, 2, 2, 890, 6627, 3,
	2, 2, 2, 892, 6631, 3, 2, 2, 2, 894, 6638, 3, 2, 2, 2, 896, 6644, 3, 2,
	2, 2, 898, 6649, 3, 2, 2, 2, 900, 6658, 3, 2, 2, 2, 902, 6667, 3, 2, 2,
	2, 904, 6675, 3, 2, 2, 2, 906, 6683, 3, 2, 2, 2, 908, 6690, 3, 2, 2, 2,
	910, 6703, 3, 2, 2, 2, 912, 6711, 3, 2, 2, 2, 914, 6718, 3, 2, 2, 2, 916,
	6754, 3, 2, 2, 2, 918, 6756, 3, 2, 2, 2, 920, 6758, 3, 2, 2, 2, 922, 6760,
	3, 2, 2, 2, 924, 6762, 3, 2, 2, 2, 926, 6764, 3, 2, 2, 2, 928, 6766, 3,
	2, 2, 2, 930, 6768, 3, 2, 2, 2, 932, 6770, 3, 2, 2, 2, 934, 6772, 3, 2,
	2, 2, 936, 6774, 3, 2, 2, 2, 938, 6776, 3, 2, 2, 2, 940, 6778, 3, 2, 2,
	2, 942, 6780, 3, 2, 2, 2, 944, 6782, 3, 2, 2, 2, 946, 6784, 3, 2, 2, 2,
	948, 6786, 3, 2, 2, 2, 950, 6788, 3, 2, 2, 2, 952, 6792, 3, 2, 2, 2, 954,
	6797, 3, 2, 2, 2, 956, 6816, 3, 2, 2, 2, 958, 6835, 3, 2, 2, 2, 960, 6837,
	3, 2, 2, 2, 962, 6849, 3, 2, 2, 2, 964, 6851, 3, 2, 2, 2, 966, 6853, 3,
	2, 2, 2, 968, 6864, 3, 2, 2, 2, 970, 6875, 3, 2, 2, 2, 972, 6880, 3, 2,
	2, 2, 974, 6891, 3, 2, 2, 2, 976, 6896, 3, 2, 2, 2, 978, 6901, 3, 2, 2,
	2, 980, 6909, 3, 2, 2, 2, 982, 6913, 3, 2, 2, 2, 984, 6915, 3, 2, 2, 2,
	986, 6926, 3, 2, 2, 2, 988, 6934, 3, 2, 2, 2, 990, 6939, 3, 2, 2, 2, 992,
	6942, 3, 2, 2, 2, 994, 6944, 3, 2, 2, 2, 996, 6957, 3, 2, 2, 2, 998, 7038,
	3, 2, 2, 2, 1000, 7040, 3, 2, 2, 2, 1002, 7062, 3, 2, 2, 2, 1004, 7092,
	3, 2, 2, 2, 1006, 7096, 3, 2, 2, 2, 1008, 7098, 3, 2, 2, 2, 1010, 7118,
	3, 2, 2, 2, 1012, 7149, 3, 2, 2, 2, 1014, 7169, 3, 2, 2, 2, 1016, 7171,
	3, 2, 2, 2, 1018, 7210, 3, 2, 2, 2, 1020, 7221, 3, 2, 2, 2, 1022, 7226,
	3, 2, 2, 2, 1024, 7230, 3, 2, 2, 2, 1026, 7234, 3, 2, 2, 2, 1028, 7236,
	3, 2, 2, 2, 1030, 7240, 3, 2, 2, 2, 1032, 7267, 3, 2, 2, 2, 1034, 7318,
	3, 2, 2, 2, 1036, 7320, 3, 2, 2, 2, 1038, 7328, 3, 2, 2, 2, 1040, 7367,
	3, 2, 2, 2, 1042, 7377, 3, 2, 2, 2, 1044, 7379, 3, 2, 2, 2, 1046, 7383,
	3, 2, 2, 2, 1048, 7418, 3, 2, 2, 2, 1050, 7429, 3, 2, 2, 2, 1052, 7467,
	3, 2, 2, 2, 1054, 7471, 3, 2, 2, 2, 1056, 7481, 3, 2, 2, 2, 1058, 7486,
	3, 2, 2, 2, 1060, 7494, 3, 2, 2, 2, 1062, 7502, 3, 2, 2, 2, 1064, 7516,
	3, 2, 2, 2, 1066, 7536, 3, 2, 2, 2, 1068, 7546, 3, 2, 2, 2, 1070, 7560,
	3, 2, 2, 2, 1072, 7569, 3, 2, 2, 2, 1074, 7571, 3, 2, 2, 2, 1076, 7595,
	3, 2, 2, 2, 1078, 7622, 3, 2, 2, 2, 1080, 7628, 3, 2, 2, 2, 1082, 7633,
	3, 2, 2, 2, 1084, 7635, 3, 2, 2, 2, 1086, 7637, 3, 2, 2, 2, 1088, 7639,
	3, 2, 2, 2, 1090, 7641, 3, 2, 2, 2, 1092, 7643, 3, 2, 2, 2, 1094, 7645,
	3, 2, 2, 2, 1096, 7656, 3, 2, 2, 2, 1098, 7661, 3, 2, 2, 2, 1100, 7663,
	3, 2, 2, 2, 1102, 7665, 3, 2, 2, 2, 1104, 7667, 3, 2, 2, 2, 1106, 7669,
	3, 2, 2, 2, 1108, 7671, 3, 2, 2, 2, 1110, 7673, 3, 2, 2, 2, 1112, 7675,
	3, 2, 2, 2, 1114, 7677, 3, 2, 2, 2, 1116, 7679, 3, 2, 2, 2, 1118, 7681,
	3, 2, 2, 2, 1120, 7683, 3, 2, 2, 2, 1122, 7685, 3, 2, 2, 2, 1124, 7687,
	3, 2, 2, 2, 1126, 7689, 3, 2, 2, 2, 1128, 7691, 3, 2, 2, 2, 1130, 7693,
	3, 2, 2, 2, 1132, 7695, 3, 2, 2, 2, 1134, 7697, 3, 2, 2, 2, 1136, 7699,
	3, 2, 2, 2, 1138, 7701, 3, 2, 2, 2, 1140, 7703, 3, 2, 2, 2, 1142, 7705,
	3, 2, 2, 2, 1144, 7707, 3, 2, 2, 2, 1146, 7709, 3, 2, 2, 2, 1148, 7711,
	3, 2, 2, 2, 1150, 7714, 3, 2, 2, 2, 1152, 7727, 3, 2, 2, 2, 1154, 7729,
	3, 2, 2, 2, 1156, 7731, 3, 2, 2, 2, 1158, 7733, 3, 2, 2, 2, 1160, 7735,
	3, 2, 2, 2, 1162, 7737, 3, 2, 2, 2, 1164, 7739, 3, 2, 2, 2, 1166, 7741,
	3, 2, 2, 2, 1168, 7743, 3, 2, 2, 2, 1170, 7745, 3, 2, 2, 2, 1172, 7747,
	3, 2, 2, 2, 1174, 7749, 3, 2, 2, 2, 1176, 7751, 3, 2, 2, 2, 1178, 7753,
	3, 2, 2, 2, 1180, 7755, 3, 2, 2, 2, 1182, 7757, 3, 2, 2, 2, 1184, 7759,
	3, 2, 2, 2, 1186, 7761, 3, 2, 2, 2, 1188, 7763, 3, 2, 2, 2, 1190, 7765,
	3, 2, 2, 2, 1192, 7767, 3, 2, 2, 2, 1194, 7769, 3, 2, 2, 2, 1196, 7771,
	3, 2, 2, 2, 1198, 7775, 3, 2, 2, 2, 1200, 7779, 3, 2, 2, 2, 1202, 7781,
	3, 2, 2, 2, 1204, 7783, 3, 2, 2, 2, 1206, 7785, 3, 2, 2, 2, 1208, 7787,
	3, 2, 2, 2, 1210, 7790, 3, 2, 2, 2, 1212, 7795, 3, 2, 2, 2, 1214, 7800,
	3, 2, 2, 2, 1216, 7805, 3, 2, 2, 2, 1218, 7814, 3, 2, 2, 2, 1220, 7823,
	3, 2, 2, 2, 1222, 7830, 3, 2, 2, 2, 1224, 7837, 3, 2, 2, 2, 1226, 7844,
	3, 2, 2, 2, 1228, 7866, 3, 2, 2, 2, 1230, 7872, 3, 2, 2, 2, 1232, 7876,
	3, 2, 2, 2, 1234, 7878, 3, 2, 2, 2, 1236, 7880, 3, 2, 2, 2, 1238, 7882,
	3, 2, 2, 2, 1240, 7884, 3, 2, 2, 2, 1242, 7886, 3, 2, 2, 2, 1244, 7888,
	3, 2, 2, 2, 1246, 7890, 3, 2, 2, 2, 1248, 1250, 5, 4, 3, 2, 1249, 1248,
	3, 2, 2, 2, 1250, 1253, 3, 2, 2, 2, 1251, 1249, 3, 2, 2, 2, 1251, 1252,
	3, 2, 2, 2, 1252, 3, 3, 2, 2, 2, 1253, 1251, 3, 2, 2, 2, 1254, 1259, 5,
	6, 4, 2, 1255, 1259, 5, 8, 5, 2, 1256, 1259, 5, 100, 51, 2, 1257, 1259,
	7, 48, 2, 2, 1258, 1254, 3, 2, 2, 2, 1258, 1255, 3, 2, 2, 2, 1258, 1256,
	3, 2, 2, 2, 1258, 1257, 3, 2, 2, 2, 1259, 5, 3, 2, 2, 2, 1260, 1261, 7,
	208, 2, 2, 1261, 1262, 5, 1180, 591, 2, 1262, 1267, 7, 346, 2, 2, 1263,
	1264, 7, 38, 2, 2, 1264, 1266, 7, 346, 2, 2, 1265, 1263, 3, 2, 2, 2, 1266,
	1269, 3, 2, 2, 2, 1267, 1265, 3, 2, 2, 2, 1267, 1268, 3, 2, 2, 2, 1268,
	1279, 3, 2, 2, 2, 1269, 1267, 3, 2, 2, 2, 1270, 1271, 7, 190, 2, 2, 1271,
	1276, 7, 346, 2, 2, 1272, 1273, 7, 38, 2, 2, 1273, 1275, 7, 346, 2, 2,
	1274, 1272, 3, 2, 2, 2, 1275, 1278, 3, 2, 2, 2, 1276, 1274, 3, 2, 2, 2,
	1276, 1277, 3, 2, 2, 2, 1277, 1280, 3, 2, 2, 2, 1278, 1276, 3, 2, 2, 2,
	1279, 1270, 3, 2, 2, 2, 1279, 1280, 3, 2, 2, 2, 1280, 1281, 3, 2, 2, 2,
	1281, 1282, 7, 48, 2, 2, 1282, 7, 3, 2, 2, 2, 1283, 1284, 7, 191, 2, 2,
	1284, 1285, 7, 346, 2, 2, 1285, 1286, 7, 48, 2, 2, 1286, 9, 3, 2, 2, 2,
	1287, 1289, 5, 48, 25, 2, 1288, 1287, 3, 2, 2, 2, 1288, 1289, 3, 2, 2,
	2, 1289, 1293, 3, 2, 2, 2, 1290, 1292, 5, 12, 7, 2, 1291, 1290, 3, 2, 2,
	2, 1292, 1295, 3, 2, 2, 2, 1293, 1291, 3, 2, 2, 2, 1293, 1294, 3, 2, 2,
	2, 1294, 1296, 3, 2, 2, 2, 1295, 1293, 3, 2, 2, 2, 1296, 1297, 7, 2, 2,
	3, 1297, 11, 3, 2, 2, 2, 1298, 1314, 5, 18, 10, 2, 1299, 1314, 5, 22, 12,
	2, 1300, 1314, 5, 28, 15, 2, 1301, 1314, 5, 46, 24, 2, 1302, 1304, 5, 1094,
	548, 2, 1303, 1302, 3, 2, 2, 2, 1304, 1307, 3, 2, 2, 2, 1305, 1303, 3,
	2, 2, 2, 1305, 1306, 3, 2, 2, 2, 1306, 1310, 3, 2, 2, 2, 1307, 1305, 3,
	2, 2, 2, 1308, 1311, 5, 196, 99, 2, 1309, 1311, 5, 90, 46, 2, 1310, 1308,
	3, 2, 2, 2, 1310, 1309, 3, 2, 2, 2, 1311, 1314, 3, 2, 2, 2, 1312, 1314,
	5, 100, 51, 2, 1313, 1298, 3, 2, 2, 2, 1313, 1299, 3, 2, 2, 2, 1313, 1300,
	3, 2, 2, 2, 1313, 1301, 3, 2, 2, 2, 1313, 1305, 3, 2, 2, 2, 1313, 1312,
	3, 2, 2, 2, 1314, 13, 3, 2, 2, 2, 1315, 1317, 5, 1094, 548, 2, 1316, 1315,
	3, 2, 2, 2, 1317, 1320, 3, 2, 2, 2, 1318, 1316, 3, 2, 2, 2, 1318, 1319,
	3, 2, 2, 2, 1319, 1321, 3, 2, 2, 2, 1320, 1318, 3, 2, 2, 2, 1321, 1323,
	5, 20, 11, 2, 1322, 1324, 5, 236, 119, 2, 1323, 1322, 3, 2, 2, 2, 1323,
	1324, 3, 2, 2, 2, 1324, 1325, 3, 2, 2, 2, 1325, 1329, 5, 1188, 595, 2,
	1326, 1328, 5, 222, 112, 2, 1327, 1326, 3, 2, 2, 2, 1328, 1331, 3, 2, 2,
	2, 1329, 1327, 3, 2, 2, 2, 1329, 1330, 3, 2, 2, 2, 1330, 1333, 3, 2, 2,
	2, 1331, 1329, 3, 2, 2, 2, 1332, 1334, 5, 50, 26, 2, 1333, 1332, 3, 2,
	2, 2, 1333, 1334, 3, 2, 2, 2, 1334, 1335, 3, 2, 2, 2, 1335, 1336, 5, 54,
	28, 2, 1336, 1337, 7, 48, 2, 2, 1337, 15, 3, 2, 2, 2, 1338, 1340, 5, 1094,
	548, 2, 1339, 1338, 3, 2, 2, 2, 1340, 1343, 3, 2, 2, 2, 1341, 1339, 3,
	2, 2, 2, 1341, 1342, 3, 2, 2, 2, 1342, 1344, 3, 2, 2, 2, 1343, 1341, 3,
	2, 2, 2, 1344, 1346, 5, 20, 11, 2, 1345, 1347, 5, 236, 119, 2, 1346, 1345,
	3, 2, 2, 2, 1346, 1347, 3, 2, 2, 2, 1347, 1348, 3, 2, 2, 2, 1348, 1352,
	5, 1188, 595, 2, 1349, 1351, 5, 222, 112, 2, 1350, 1349, 3, 2, 2, 2, 1351,
	1354, 3, 2, 2, 2, 1352, 1350, 3, 2, 2, 2, 1352, 1353, 3, 2, 2, 2, 1353,
	1356, 3, 2, 2, 2, 1354, 1352, 3, 2, 2, 2, 1355, 1357, 5, 50, 26, 2, 1356,
	1355, 3, 2, 2, 2, 1356, 1357, 3, 2, 2, 2, 1357, 1359, 3, 2, 2, 2, 1358,
	1360, 5, 56, 29, 2, 1359, 1358, 3, 2, 2, 2, 1359, 1360, 3, 2, 2, 2, 1360,
	1361, 3, 2, 2, 2, 1361, 1362, 7, 48, 2, 2, 1362, 17, 3, 2, 2, 2, 1363,
	1365, 5, 14, 8, 2, 1364, 1366, 5, 48, 25, 2, 1365, 1364, 3, 2, 2, 2, 1365,
	1366, 3, 2, 2, 2, 1366, 1370, 3, 2, 2, 2, 1367, 1369, 5, 80, 41, 2, 1368,
	1367, 3, 2, 2, 2, 1369, 1372, 3, 2, 2, 2, 1370, 1368, 3, 2, 2, 2, 1370,
	1371, 3, 2, 2, 2, 1371, 1373, 3, 2, 2, 2, 1372, 1370, 3, 2, 2, 2, 1373,
	1376, 7, 154, 2, 2, 1374, 1375, 7, 43, 2, 2, 1375, 1377, 5, 1188, 595,
	2, 1376, 1374, 3, 2, 2, 2, 1376, 1377, 3, 2, 2, 2, 1377, 1428, 3, 2, 2,
	2, 1378, 1380, 5, 16, 9, 2, 1379, 1381, 5, 48, 25, 2, 1380, 1379, 3, 2,
	2, 2, 1380, 1381, 3, 2, 2, 2, 1381, 1385, 3, 2, 2, 2, 1382, 1384, 5, 86,
	44, 2, 1383, 1382, 3, 2, 2, 2, 1384, 1387, 3, 2, 2, 2, 1385, 1383, 3, 2,
	2, 2, 1385, 1386, 3, 2, 2, 2, 1386, 1388, 3, 2, 2, 2, 1387, 1385, 3, 2,
	2, 2, 1388, 1391, 7, 154, 2, 2, 1389, 1390, 7, 43, 2, 2, 1390, 1392, 5,
	1188, 595, 2, 1391, 1389, 3, 2, 2, 2, 1391, 1392, 3, 2, 2, 2, 1392, 1428,
	3, 2, 2, 2, 1393, 1395, 5, 1094, 548, 2, 1394, 1393, 3, 2, 2, 2, 1395,
	1398, 3, 2, 2, 2, 1396, 1394, 3, 2, 2, 2, 1396, 1397, 3, 2, 2, 2, 1397,
	1399, 3, 2, 2, 2, 1398, 1396, 3, 2, 2, 2, 1399, 1401, 5, 20, 11, 2, 1400,
	1402, 5, 236, 119, 2, 1401, 1400, 3, 2, 2, 2, 1401, 1402, 3, 2, 2, 2, 1402,
	1403, 3, 2, 2, 2, 1403, 1404, 5, 1188, 595, 2, 1404, 1405, 7, 29, 2, 2,
	1405, 1406, 7, 40, 2, 2, 1406, 1407, 7, 31, 2, 2, 1407, 1409, 7, 48, 2,
	2, 1408, 1410, 5, 48, 25, 2, 1409, 1408, 3, 2, 2, 2, 1409, 1410, 3, 2,
	2, 2, 1410, 1414, 3, 2, 2, 2, 1411, 1413, 5, 80, 41, 2, 1412, 1411, 3,
	2, 2, 2, 1413, 1416, 3, 2, 2, 2, 1414, 1412, 3, 2, 2, 2, 1414, 1415, 3,
	2, 2, 2, 1415, 1417, 3, 2, 2, 2, 1416, 1414, 3, 2, 2, 2, 1417, 1420, 7,
	154, 2, 2, 1418, 1419, 7, 43, 2, 2, 1419, 1421, 5, 1188, 595, 2, 1420,
	1418, 3, 2, 2, 2, 1420, 1421, 3, 2, 2, 2, 1421, 1428, 3, 2, 2, 2, 1422,
	1425, 7, 167, 2, 2, 1423, 1426, 5, 14, 8, 2, 1424, 1426, 5, 16, 9, 2, 1425,
	1423, 3, 2, 2, 2, 1425, 1424, 3, 2, 2, 2, 1426, 1428, 3, 2, 2, 2, 1427,
	1363, 3, 2, 2, 2, 1427, 1378, 3, 2, 2, 2, 1427, 1396, 3, 2, 2, 2, 1427,
	1422, 3, 2, 2, 2, 1428, 19, 3, 2, 2, 2, 1429, 1430, 9, 2, 2, 2, 1430, 21,
	3, 2, 2, 2, 1431, 1433, 5, 24, 13, 2, 1432, 1434, 5, 48, 25, 2, 1433, 1432,
	3, 2, 2, 2, 1433, 1434, 3, 2, 2, 2, 1434, 1438, 3, 2, 2, 2, 1435, 1437,
	5, 122, 62, 2, 1436, 1435, 3, 2, 2, 2, 1437, 1440, 3, 2, 2, 2, 1438, 1436,
	3, 2, 2, 2, 1438, 1439, 3, 2, 2, 2, 1439, 1441, 3, 2, 2, 2, 1440, 1438,
	3, 2, 2, 2, 1441, 1444, 7, 153, 2, 2, 1442, 1443, 7, 43, 2, 2, 1443, 1445,
	5, 1170, 586, 2, 1444, 1442, 3, 2, 2, 2, 1444, 1445, 3, 2, 2, 2, 1445,
	1493, 3, 2, 2, 2, 1446, 1448, 5, 26, 14, 2, 1447, 1449, 5, 48, 25, 2, 1448,
	1447, 3, 2, 2, 2, 1448, 1449, 3, 2, 2, 2, 1449, 1453, 3, 2, 2, 2, 1450,
	1452, 5, 124, 63, 2, 1451, 1450, 3, 2, 2, 2, 1452, 1455, 3, 2, 2, 2, 1453,
	1451, 3, 2, 2, 2, 1453, 1454, 3, 2, 2, 2, 1454, 1456, 3, 2, 2, 2, 1455,
	1453, 3, 2, 2, 2, 1456, 1459, 7, 153, 2, 2, 1457, 1458, 7, 43, 2, 2, 1458,
	1460, 5, 1170, 586, 2, 1459, 1457, 3, 2, 2, 2, 1459, 1460, 3, 2, 2, 2,
	1460, 1493, 3, 2, 2, 2, 1461, 1463, 5, 1094, 548, 2, 1462, 1461, 3, 2,
	2, 2, 1463, 1466, 3, 2, 2, 2, 1464, 1462, 3, 2, 2, 2, 1464, 1465, 3, 2,
	2, 2, 1465, 1467, 3, 2, 2, 2, 1466, 1464, 3, 2, 2, 2, 1467, 1468, 7, 200,
	2, 2, 1468, 1469, 5, 1170, 586, 2, 1469, 1470, 7, 29, 2, 2, 1470, 1471,
	7, 40, 2, 2, 1471, 1472, 7, 31, 2, 2, 1472, 1474, 7, 48, 2, 2, 1473, 1475,
	5, 48, 25, 2, 1474, 1473, 3, 2, 2, 2, 1474, 1475, 3, 2, 2, 2, 1475, 1479,
	3, 2, 2, 2, 1476, 1478, 5, 122, 62, 2, 1477, 1476, 3, 2, 2, 2, 1478, 1481,
	3, 2, 2, 2, 1479, 1477, 3, 2, 2, 2, 1479, 1480, 3, 2, 2, 2, 1480, 1482,
	3, 2, 2, 2, 1481, 1479, 3, 2, 2, 2, 1482, 1485, 7, 153, 2, 2, 1483, 1484,
	7, 43, 2, 2, 1484, 1486, 5, 1170, 586, 2, 1485, 1483, 3, 2, 2, 2, 1485,
	1486, 3, 2, 2, 2, 1486, 1493, 3, 2, 2, 2, 1487, 1490, 7, 167, 2, 2, 1488,
	1491, 5, 24, 13, 2, 1489, 1491, 5, 26, 14, 2, 1490, 1488, 3, 2, 2, 2, 1490,
	1489, 3, 2, 2, 2, 1491, 1493, 3, 2, 2, 2, 1492, 1431, 3, 2, 2, 2, 1492,
	1446, 3, 2, 2, 2, 1492, 1464, 3, 2, 2, 2, 1492, 1487, 3, 2, 2, 2, 1493,
	23, 3, 2, 2, 2, 1494, 1496, 5, 1094, 548, 2, 1495, 1494, 3, 2, 2, 2, 1496,
	1499, 3, 2, 2, 2, 1497, 1495, 3, 2, 2, 2, 1497, 1498, 3, 2, 2, 2, 1498,
	1500, 3, 2, 2, 2, 1499, 1497, 3, 2, 2, 2, 1500, 1502, 7, 200, 2, 2, 1501,
	1503, 5, 236, 119, 2, 1502, 1501, 3, 2, 2, 2, 1502, 1503, 3, 2, 2, 2, 1503,
	1504, 3, 2, 2, 2, 1504, 1508, 5, 1170, 586, 2, 1505, 1507, 5, 222, 112,
	2, 1506, 1505, 3, 2, 2, 2, 1507, 1510, 3, 2, 2, 2, 1508, 1506, 3, 2, 2,
	2, 1508, 1509, 3, 2, 2, 2, 1509, 1512, 3, 2, 2, 2, 1510, 1508, 3, 2, 2,
	2, 1511, 1513, 5, 50, 26, 2, 1512, 1511, 3, 2, 2, 2, 1512, 1513, 3, 2,
	2, 2, 1513, 1514, 3, 2, 2, 2, 1514, 1515, 5, 54, 28, 2, 1515, 1516, 7,
	48, 2, 2, 1516, 25, 3, 2, 2, 2, 1517, 1519, 5, 1094, 548, 2, 1518, 1517,
	3, 2, 2, 2, 1519, 1522, 3, 2, 2, 2, 1520, 1518, 3, 2, 2, 2, 1520, 1521,
	3, 2, 2, 2, 1521, 1523, 3, 2, 2, 2, 1522, 1520, 3, 2, 2, 2, 1523, 1525,
	7, 200, 2, 2, 1524, 1526, 5, 236, 119, 2, 1525, 1524, 3, 2, 2, 2, 1525,
	1526, 3, 2, 2, 2, 1526, 1527, 3, 2, 2, 2, 1527, 1531, 5, 1170, 586, 2,
	1528, 1530, 5, 222, 112, 2, 1529, 1528, 3, 2, 2, 2, 1530, 1533, 3, 2, 2,
	2, 1531, 1529, 3, 2, 2, 2, 1531, 1532, 3, 2, 2, 2, 1532, 1535, 3, 2, 2,
	2, 1533, 1531, 3, 2, 2, 2, 1534, 1536, 5, 50, 26, 2, 1535, 1534, 3, 2,
	2, 2, 1535, 1536, 3, 2, 2, 2, 1536, 1538, 3, 2, 2, 2, 1537, 1539, 5, 56,
	29, 2, 1538, 1537, 3, 2, 2, 2, 1538, 1539, 3, 2, 2, 2, 1539, 1540, 3, 2,
	2, 2, 1540, 1541, 7, 48, 2, 2, 1541, 27, 3, 2, 2, 2, 1542, 1544, 5, 30,
	16, 2, 1543, 1545, 5, 48, 25, 2, 1544, 1543, 3, 2, 2, 2, 1544, 1545, 3,
	2, 2, 2, 1545, 1549, 3, 2, 2, 2, 1546, 1548, 5, 126, 64, 2, 1547, 1546,
	3, 2, 2, 2, 1548, 1551, 3, 2, 2, 2, 1549, 1547, 3, 2, 2, 2, 1549, 1550,
	3, 2, 2, 2, 1550, 1552, 3, 2, 2, 2, 1551, 1549, 3, 2, 2, 2, 1552, 1555,
	7, 156, 2, 2, 1553, 1554, 7, 43, 2, 2, 1554, 1556, 5, 1206, 604, 2, 1555,
	1553, 3, 2, 2, 2, 1555, 1556, 3, 2, 2, 2, 1556, 1604, 3, 2, 2, 2, 1557,
	1559, 5, 32, 17, 2, 1558, 1560, 5, 48, 25, 2, 1559, 1558, 3, 2, 2, 2, 1559,
	1560, 3, 2, 2, 2, 1560, 1564, 3, 2, 2, 2, 1561, 1563, 5, 128, 65, 2, 1562,
	1561, 3, 2, 2, 2, 1563, 1566, 3, 2, 2, 2, 1564, 1562, 3, 2, 2, 2, 1564,
	1565, 3, 2, 2, 2, 1565, 1567, 3, 2, 2, 2, 1566, 1564, 3, 2, 2, 2, 1567,
	1570, 7, 156, 2, 2, 1568, 1569, 7, 43, 2, 2, 1569, 1571, 5, 1206, 604,
	2, 1570, 1568, 3, 2, 2, 2, 1570, 1571, 3, 2, 2, 2, 1571, 1604, 3, 2, 2,
	2, 1572, 1574, 5, 1094, 548, 2, 1573, 1572, 3, 2, 2, 2, 1574, 1577, 3,
	2, 2, 2, 1575, 1573, 3, 2, 2, 2, 1575, 1576, 3, 2, 2, 2, 1576, 1578, 3,
	2, 2, 2, 1577, 1575, 3, 2, 2, 2, 1578, 1579, 7, 241, 2, 2, 1579, 1580,
	5, 1206, 604, 2, 1580, 1581, 7, 29, 2, 2, 1581, 1582, 7, 40, 2, 2, 1582,
	1583, 7, 31, 2, 2, 1583, 1585, 7, 48, 2, 2, 1584, 1586, 5, 48, 25, 2, 1585,
	1584, 3, 2, 2, 2, 1585, 1586, 3, 2, 2, 2, 1586, 1590, 3, 2, 2, 2, 1587,
	1589, 5, 126, 64, 2, 1588, 1587, 3, 2, 2, 2, 1589, 1592, 3, 2, 2, 2, 1590,
	1588, 3, 2, 2, 2, 1590, 1591, 3, 2, 2, 2, 1591, 1593, 3, 2, 2, 2, 1592,
	1590, 3, 2, 2, 2, 1593, 1596, 7, 156, 2, 2, 1594, 1595, 7, 43, 2, 2, 1595,
	1597, 5, 1206, 604, 2, 1596, 1594, 3, 2, 2, 2, 1596, 1597, 3, 2, 2, 2,
	1597, 1604, 3, 2, 2, 2, 1598, 1601, 7, 167, 2, 2, 1599, 1602, 5, 30, 16,
	2, 1600, 1602, 5, 32, 17, 2, 1601, 1599, 3, 2, 2, 2, 1601, 1600, 3, 2,
	2, 2, 1602, 1604, 3, 2, 2, 2, 1603, 1542, 3, 2, 2, 2, 1603, 1557, 3, 2,
	2, 2, 1603, 1575, 3, 2, 2, 2, 1603, 1598, 3, 2, 2, 2, 1604, 29, 3, 2, 2,
	2, 1605, 1607, 5, 1094, 548, 2, 1606, 1605, 3, 2, 2, 2, 1607, 1610, 3,
	2, 2, 2, 1608, 1606, 3, 2, 2, 2, 1608, 1609, 3, 2, 2, 2, 1609, 1611, 3,
	2, 2, 2, 1610, 1608, 3, 2, 2, 2, 1611, 1613, 7, 241, 2, 2, 1612, 1614,
	5, 236, 119, 2, 1613, 1612, 3, 2, 2, 2, 1613, 1614, 3, 2, 2, 2, 1614, 1615,
	3, 2, 2, 2, 1615, 1619, 5, 1206, 604, 2, 1616, 1618, 5, 222, 112, 2, 1617,
	1616, 3, 2, 2, 2, 1618, 1621, 3, 2, 2, 2, 1619, 1617, 3, 2, 2, 2, 1619,
	1620, 3, 2, 2, 2, 1620, 1623, 3, 2, 2, 2, 1621, 1619, 3, 2, 2, 2, 1622,
	1624, 5, 50, 26, 2, 1623, 1622, 3, 2, 2, 2, 1623, 1624, 3, 2, 2, 2, 1624,
	1625, 3, 2, 2, 2, 1625, 1626, 5, 54, 28, 2, 1626, 1627, 7, 48, 2, 2, 1627,
	31, 3, 2, 2, 2, 1628, 1630, 5, 1094, 548, 2, 1629, 1628, 3, 2, 2, 2, 1630,
	1633, 3, 2, 2, 2, 1631, 1629, 3, 2, 2, 2, 1631, 1632, 3, 2, 2, 2, 1632,
	1634, 3, 2, 2, 2, 1633, 1631, 3, 2, 2, 2, 1634, 1636, 7, 241, 2, 2, 1635,
	1637, 5, 236, 119, 2, 1636, 1635, 3, 2, 2, 2, 1636, 1637, 3, 2, 2, 2, 1637,
	1638, 3, 2, 2, 2, 1638, 1642, 5, 1206, 604, 2, 1639, 1641, 5, 222, 112,
	2, 1640, 1639, 3, 2, 2, 2, 1641, 1644, 3, 2, 2, 2, 1642, 1640, 3, 2, 2,
	2, 1642, 1643, 3, 2, 2, 2, 1643, 1646, 3, 2, 2, 2, 1644, 1642, 3, 2, 2,
	2, 1645, 1647, 5, 50, 26, 2, 1646, 1645, 3, 2, 2, 2, 1646, 1647, 3, 2,
	2, 2, 1647, 1649, 3, 2, 2, 2, 1648, 1650, 5, 56, 29, 2, 1649, 1648, 3,
	2, 2, 2, 1649, 1650, 3, 2, 2, 2, 1650, 1651, 3, 2, 2, 2, 1651, 1652, 7,
	48, 2, 2, 1652, 33, 3, 2, 2, 2, 1653, 1654, 7, 122, 2, 2, 1654, 1660, 5,
	1110, 556, 2, 1655, 1657, 7, 29, 2, 2, 1656, 1658, 5, 132, 67, 2, 1657,
	1656, 3, 2, 2, 2, 1657, 1658, 3, 2, 2, 2, 1658, 1659, 3, 2, 2, 2, 1659,
	1661, 7, 31, 2, 2, 1660, 1655, 3, 2, 2, 2, 1660, 1661, 3, 2, 2, 2, 1661,
	1662, 3, 2, 2, 2, 1662, 1672, 7, 48, 2, 2, 1663, 1665, 5, 1094, 548, 2,
	1664, 1663, 3, 2, 2, 2, 1665, 1668, 3, 2, 2, 2, 1666, 1664, 3, 2, 2, 2,
	1666, 1667, 3, 2, 2, 2, 1667, 1669, 3, 2, 2, 2, 1668, 1666, 3, 2, 2, 2,
	1669, 1671, 5, 138, 70, 2, 1670, 1666, 3, 2, 2, 2, 1671, 1674, 3, 2, 2,
	2, 1672, 1670, 3, 2, 2, 2, 1672, 1673, 3, 2, 2, 2, 1673, 1675, 3, 2, 2,
	2, 1674, 1672, 3, 2, 2, 2, 1675, 1678, 7, 146, 2, 2, 1676, 1677, 7, 43,
	2, 2, 1677, 1679, 5, 1110, 556, 2, 1678, 1676, 3, 2, 2, 2, 1678, 1679,
	3, 2, 2, 2, 1679, 35, 3, 2, 2, 2, 1680, 1682, 7, 329, 2, 2, 1681, 1680,
	3, 2, 2, 2, 1681, 1682, 3, 2, 2, 2, 1682, 1683, 3, 2, 2, 2, 1683, 1685,
	7, 123, 2, 2, 1684, 1686, 5, 236, 119, 2, 1685, 1684, 3, 2, 2, 2, 1685,
	1686, 3, 2, 2, 2, 1686, 1687, 3, 2, 2, 2, 1687, 1689, 5, 1112, 557, 2,
	1688, 1690, 5, 50, 26, 2, 1689, 1688, 3, 2, 2, 2, 1689, 1690, 3, 2, 2,
	2, 1690, 1699, 3, 2, 2, 2, 1691, 1692, 7, 166, 2, 2, 1692, 1697, 5, 252,
	127, 2, 1693, 1694, 7, 29, 2, 2, 1694, 1695, 5, 1002, 502, 2, 1695, 1696,
	7, 31, 2, 2, 1696, 1698, 3, 2, 2, 2, 1697, 1693, 3, 2, 2, 2, 1697, 1698,
	3, 2, 2, 2, 1698, 1700, 3, 2, 2, 2, 1699, 1691, 3, 2, 2, 2, 1699, 1700,
	3, 2, 2, 2, 1700, 1710, 3, 2, 2, 2, 1701, 1702, 7, 187, 2, 2, 1702, 1707,
	5, 38, 20, 2, 1703, 1704, 7, 38, 2, 2, 1704, 1706, 5, 38, 20, 2, 1705,
	1703, 3, 2, 2, 2, 1706, 1709, 3, 2, 2, 2, 1707, 1705, 3, 2, 2, 2, 1707,
	1708, 3, 2, 2, 2, 1708, 1711, 3, 2, 2, 2, 1709, 1707, 3, 2, 2, 2, 1710,
	1701, 3, 2, 2, 2, 1710, 1711, 3, 2, 2, 2, 1711, 1712, 3, 2, 2, 2, 1712,
	1716, 7, 48, 2, 2, 1713, 1715, 5, 144, 73, 2, 1714, 1713, 3, 2, 2, 2, 1715,
	1718, 3, 2, 2, 2, 1716, 1714, 3, 2, 2, 2, 1716, 1717, 3, 2, 2, 2, 1717,
	1719, 3, 2, 2, 2, 1718, 1716, 3, 2, 2, 2, 1719, 1722, 7, 147, 2, 2, 1720,
	1721, 7, 43, 2, 2, 1721, 1723, 5, 1112, 557, 2, 1722, 1720, 3, 2, 2, 2,
	1722, 1723, 3, 2, 2, 2, 1723, 37, 3, 2, 2, 2, 1724, 1726, 5, 1210, 606,
	2, 1725, 1727, 5, 628, 315, 2, 1726, 1725, 3, 2, 2, 2, 1726, 1727, 3, 2,
	2, 2, 1727, 39, 3, 2, 2, 2, 1728, 1729, 7, 200, 2, 2, 1729, 1730, 7, 123,
	2, 2, 1730, 1732, 5, 1112, 557, 2, 1731, 1733, 5, 50, 26, 2, 1732, 1731,
	3, 2, 2, 2, 1732, 1733, 3, 2, 2, 2, 1733, 1743, 3, 2, 2, 2, 1734, 1735,
	7, 166, 2, 2, 1735, 1740, 5, 38, 20, 2, 1736, 1737, 7, 38, 2, 2, 1737,
	1739, 5, 38, 20, 2, 1738, 1736, 3, 2, 2, 2, 1739, 1742, 3, 2, 2, 2, 1740,
	1738, 3, 2, 2, 2, 1740, 1741, 3, 2, 2, 2, 1741, 1744, 3, 2, 2, 2, 1742,
	1740, 3, 2, 2, 2, 1743, 1734, 3, 2, 2, 2, 1743, 1744, 3, 2, 2, 2, 1744,
	1745, 3, 2, 2, 2, 1745, 1749, 7, 48, 2, 2, 1746, 1748, 5, 42, 22, 2, 1747,
	1746, 3, 2, 2, 2, 1748, 1751, 3, 2, 2, 2, 1749, 1747, 3, 2, 2, 2, 1749,
	1750, 3, 2, 2, 2, 1750, 1752, 3, 2, 2, 2, 1751, 1749, 3, 2, 2, 2, 1752,
	1755, 7, 147, 2, 2, 1753, 1754, 7, 43, 2, 2, 1754, 1756, 5, 1112, 557,
	2, 1755, 1753, 3, 2, 2, 2, 1755, 1756, 3, 2, 2, 2, 1756, 41, 3, 2, 2, 2,
	1757, 1771, 5, 232, 117, 2, 1758, 1760, 5, 1094, 548, 2, 1759, 1758, 3,
	2, 2, 2, 1760, 1763, 3, 2, 2, 2, 1761, 1759, 3, 2, 2, 2, 1761, 1762, 3,
	2, 2, 2, 1762, 1764, 3, 2, 2, 2, 1763, 1761, 3, 2, 2, 2, 1764, 1771, 5,
	44, 23, 2, 1765, 1768, 5, 204, 103, 2, 1766, 1768, 5, 206, 104, 2, 1767,
	1765, 3, 2, 2, 2, 1767, 1766, 3, 2, 2, 2, 1767, 1768, 3, 2, 2, 2, 1768,
	1769, 3, 2, 2, 2, 1769, 1771, 7, 48, 2, 2, 1770, 1757, 3, 2, 2, 2, 1770,
	1761, 3, 2, 2, 2, 1770, 1767, 3, 2, 2, 2, 1771, 43, 3, 2, 2, 2, 1772, 1773,
	7, 250, 2, 2, 1773, 1774, 7, 329, 2, 2, 1774, 1775, 5, 162, 82, 2, 1775,
	1776, 7, 48, 2, 2, 1776, 45, 3, 2, 2, 2, 1777, 1779, 5, 1094, 548, 2, 1778,
	1777, 3, 2, 2, 2, 1779, 1782, 3, 2, 2, 2, 1780, 1778, 3, 2, 2, 2, 1780,
	1781, 3, 2, 2, 2, 1781, 1783, 3, 2, 2, 2, 1782, 1780, 3, 2, 2, 2, 1783,
	1785, 7, 234, 2, 2, 1784, 1786, 5, 236, 119, 2, 1785, 1784, 3, 2, 2, 2,
	1785, 1786, 3, 2, 2, 2, 1786, 1787, 3, 2, 2, 2, 1787, 1788, 5, 1196, 599,
	2, 1788, 1790, 7, 48, 2, 2, 1789, 1791, 5, 48, 25, 2, 1790, 1789, 3, 2,
	2, 2, 1790, 1791, 3, 2, 2, 2, 1791, 1801, 3, 2, 2, 2, 1792, 1794, 5, 1094,
	548, 2, 1793, 1792, 3, 2, 2, 2, 1794, 1797, 3, 2, 2, 2, 1795, 1793, 3,
	2, 2, 2, 1795, 1796, 3, 2, 2, 2, 1796, 1798, 3, 2, 2, 2, 1797, 1795, 3,
	2, 2, 2, 1798, 1800, 5, 196, 99, 2, 1799, 1795, 3, 2, 2, 2, 1800, 1803,
	3, 2, 2, 2, 1801, 1799, 3, 2, 2, 2, 1801, 1802, 3, 2, 2, 2, 1802, 1804,
	3, 2, 2, 2, 1803, 1801, 3, 2, 2, 2, 1804, 1807, 7, 155, 2, 2, 1805, 1806,
	7, 43, 2, 2, 1806, 1808, 5, 1196, 599, 2, 1807, 1805, 3, 2, 2, 2, 1807,
	1808, 3, 2, 2, 2, 1808, 47, 3, 2, 2, 2, 1809, 1810, 7, 305, 2, 2, 1810,
	1818, 7, 347, 2, 2, 1811, 1812, 7, 41, 2, 2, 1812, 1814, 7, 347, 2, 2,
	1813, 1811, 3, 2, 2, 2, 1813, 1814, 3, 2, 2, 2, 1814, 1819, 3, 2, 2, 2,
	1815, 1816, 7, 48, 2, 2, 1816, 1817, 7, 304, 2, 2, 1817, 1819, 7, 347,
	2, 2, 1818, 1813, 3, 2, 2, 2, 1818, 1815, 3, 2, 2, 2, 1819, 1820, 3, 2,
	2, 2, 1820, 1830, 7, 48, 2, 2, 1821, 1822, 7, 304, 2, 2, 1822, 1823, 7,
	347, 2, 2, 1823, 1827, 7, 48, 2, 2, 1824, 1825, 7, 305, 2, 2, 1825, 1826,
	7, 347, 2, 2, 1826, 1828, 7, 48, 2, 2, 1827, 1824, 3, 2, 2, 2, 1827, 1828,
	3, 2, 2, 2, 1828, 1830, 3, 2, 2, 2, 1829, 1809, 3, 2, 2, 2, 1829, 1821,
	3, 2, 2, 2, 1830, 49, 3, 2, 2, 2, 1831, 1832, 7, 11, 2, 2, 1832, 1844,
	7, 29, 2, 2, 1833, 1836, 5, 304, 153, 2, 1834, 1836, 5, 52, 27, 2, 1835,
	1833, 3, 2, 2, 2, 1835, 1834, 3, 2, 2, 2, 1836, 1841, 3, 2, 2, 2, 1837,
	1838, 7, 38, 2, 2, 1838, 1840, 5, 52, 27, 2, 1839, 1837, 3, 2, 2, 2, 1840,
	1843, 3, 2, 2, 2, 1841, 1839, 3, 2, 2, 2, 1841, 1842, 3, 2, 2, 2, 1842,
	1845, 3, 2, 2, 2, 1843, 1841, 3, 2, 2, 2, 1844, 1835, 3, 2, 2, 2, 1844,
	1845, 3, 2, 2, 2, 1845, 1846, 3, 2, 2, 2, 1846, 1847, 7, 31, 2, 2, 1847,
	51, 3, 2, 2, 2, 1848, 1856, 5, 206, 104, 2, 1849, 1856, 5, 204, 103, 2,
	1850, 1851, 5, 240, 121, 2, 1851, 1852, 5, 304, 153, 2, 1852, 1856, 3,
	2, 2, 2, 1853, 1854, 7, 315, 2, 2, 1854, 1856, 5, 314, 158, 2, 1855, 1848,
	3, 2, 2, 2, 1855, 1849, 3, 2, 2, 2, 1855, 1850, 3, 2, 2, 2, 1855, 1853,
	3, 2, 2, 2, 1856, 53, 3, 2, 2, 2, 1857, 1858, 7, 29, 2, 2, 1858, 1863,
	5, 60, 31, 2, 1859, 1860, 7, 38, 2, 2, 1860, 1862, 5, 60, 31, 2, 1861,
	1859, 3, 2, 2, 2, 1862, 1865, 3, 2, 2, 2, 1863, 1861, 3, 2, 2, 2, 1863,
	1864, 3, 2, 2, 2, 1864, 1866, 3, 2, 2, 2, 1865, 1863, 3, 2, 2, 2, 1866,
	1867, 7, 31, 2, 2, 1867, 55, 3, 2, 2, 2, 1868, 1889, 7, 29, 2, 2, 1869,
	1871, 5, 1094, 548, 2, 1870, 1869, 3, 2, 2, 2, 1871, 1874, 3, 2, 2, 2,
	1872, 1870, 3, 2, 2, 2, 1872, 1873, 3, 2, 2, 2, 1873, 1875, 3, 2, 2, 2,
	1874, 1872, 3, 2, 2, 2, 1875, 1886, 5, 74, 38, 2, 1876, 1880, 7, 38, 2,
	2, 1877, 1879, 5, 1094, 548, 2, 1878, 1877, 3, 2, 2, 2, 1879, 1882, 3,
	2, 2, 2, 1880, 1878, 3, 2, 2, 2, 1880, 1881, 3, 2, 2, 2, 1881, 1883, 3,
	2, 2, 2, 1882, 1880, 3, 2, 2, 2, 1883, 1885, 5, 74, 38, 2, 1884, 1876,
	3, 2, 2, 2, 1885, 1888, 3, 2, 2, 2, 1886, 1884, 3, 2, 2, 2, 1886, 1887,
	3, 2, 2, 2, 1887, 1890, 3, 2, 2, 2, 1888, 1886, 3, 2, 2, 2, 1889, 1872,
	3, 2, 2, 2, 1889, 1890, 3, 2, 2, 2, 1890, 1891, 3, 2, 2, 2, 1891, 1892,
	7, 31, 2, 2, 1892, 57, 3, 2, 2, 2, 1893, 1895, 5, 1094, 548, 2, 1894, 1893,
	3, 2, 2, 2, 1895, 1898, 3, 2, 2, 2, 1896, 1894, 3, 2, 2, 2, 1896, 1897,
	3, 2, 2, 2, 1897, 1904, 3, 2, 2, 2, 1898, 1896, 3, 2, 2, 2, 1899, 1905,
	5, 210, 106, 2, 1900, 1905, 5, 212, 107, 2, 1901, 1905, 5, 214, 108, 2,
	1902, 1905, 5, 218, 110, 2, 1903, 1905, 5, 216, 109, 2, 1904, 1899, 3,
	2, 2, 2, 1904, 1900, 3, 2, 2, 2, 1904, 1901, 3, 2, 2, 2, 1904, 1902, 3,
	2, 2, 2, 1904, 1903, 3, 2, 2, 2, 1905, 59, 3, 2, 2, 2, 1906, 1908, 5, 62,
	32, 2, 1907, 1906, 3, 2, 2, 2, 1907, 1908, 3, 2, 2, 2, 1908, 1918, 3, 2,
	2, 2, 1909, 1910, 7, 39, 2, 2, 1910, 1911, 5, 1202, 602, 2, 1911, 1913,
	7, 29, 2, 2, 1912, 1914, 5, 62, 32, 2, 1913, 1912, 3, 2, 2, 2, 1913, 1914,
	3, 2, 2, 2, 1914, 1915, 3, 2, 2, 2, 1915, 1916, 7, 31, 2, 2, 1916, 1918,
	3, 2, 2, 2, 1917, 1907, 3, 2, 2, 2, 1917, 1909, 3, 2, 2, 2, 1918, 61, 3,
	2, 2, 2, 1919, 1932, 5, 64, 33, 2, 1920, 1921, 7, 58, 2, 2, 1921, 1926,
	5, 64, 33, 2, 1922, 1923, 7, 38, 2, 2, 1923, 1925, 5, 64, 33, 2, 1924,
	1922, 3, 2, 2, 2, 1925, 1928, 3, 2, 2, 2, 1926, 1924, 3, 2, 2, 2, 1926,
	1927, 3, 2, 2, 2, 1927, 1929, 3, 2, 2, 2, 1928, 1926, 3, 2, 2, 2, 1929,
	1930, 7, 64, 2, 2, 1930, 1932, 3, 2, 2, 2, 1931, 1919, 3, 2, 2, 2, 1931,
	1920, 3, 2, 2, 2, 1932, 63, 3, 2, 2, 2, 1933, 1934, 5, 1202, 602, 2, 1934,
	1935, 5, 1070, 536, 2, 1935, 65, 3, 2, 2, 2, 1936, 1937, 9, 3, 2, 2, 1937,
	67, 3, 2, 2, 2, 1938, 1940, 5, 66, 34, 2, 1939, 1938, 3, 2, 2, 2, 1939,
	1940, 3, 2, 2, 2, 1940, 1941, 3, 2, 2, 2, 1941, 1942, 5, 264, 133, 2, 1942,
	69, 3, 2, 2, 2, 1943, 1945, 5, 66, 34, 2, 1944, 1943, 3, 2, 2, 2, 1944,
	1945, 3, 2, 2, 2, 1945, 1946, 3, 2, 2, 2, 1946, 1947, 5, 266, 134, 2, 1947,
	71, 3, 2, 2, 2, 1948, 1951, 5, 1170, 586, 2, 1949, 1950, 7, 39, 2, 2, 1950,
	1952, 5, 1186, 594, 2, 1951, 1949, 3, 2, 2, 2, 1951, 1952, 3, 2, 2, 2,
	1952, 1959, 3, 2, 2, 2, 1953, 1956, 7, 200, 2, 2, 1954, 1955, 7, 39, 2,
	2, 1955, 1957, 5, 1186, 594, 2, 1956, 1954, 3, 2, 2, 2, 1956, 1957, 3,
	2, 2, 2, 1957, 1959, 3, 2, 2, 2, 1958, 1948, 3, 2, 2, 2, 1958, 1953, 3,
	2, 2, 2, 1959, 73, 3, 2, 2, 2, 1960, 1963, 5, 68, 35, 2, 1961, 1963, 5,
	72, 37, 2, 1962, 1960, 3, 2, 2, 2, 1962, 1961, 3, 2, 2, 2, 1962, 1963,
	3, 2, 2, 2, 1963, 1964, 3, 2, 2, 2, 1964, 1968, 5, 1202, 602, 2, 1965,
	1967, 5, 346, 174, 2, 1966, 1965, 3, 2, 2, 2, 1967, 1970, 3, 2, 2, 2, 1968,
	1966, 3, 2, 2, 2, 1968, 1969, 3, 2, 2, 2, 1969, 1973, 3, 2, 2, 2, 1970,
	1968, 3, 2, 2, 2, 1971, 1972, 7, 80, 2, 2, 1972, 1974, 5, 1016, 509, 2,
	1973, 1971, 3, 2, 2, 2, 1973, 1974, 3, 2, 2, 2, 1974, 2001, 3, 2, 2, 2,
	1975, 1977, 5, 70, 36, 2, 1976, 1975, 3, 2, 2, 2, 1976, 1977, 3, 2, 2,
	2, 1977, 1978, 3, 2, 2, 2, 1978, 1982, 5, 1202, 602, 2, 1979, 1981, 5,
	352, 177, 2, 1980, 1979, 3, 2, 2, 2, 1981, 1984, 3, 2, 2, 2, 1982, 1980,
	3, 2, 2, 2, 1982, 1983, 3, 2, 2, 2, 1983, 1987, 3, 2, 2, 2, 1984, 1982,
	3, 2, 2, 2, 1985, 1986, 7, 80, 2, 2, 1986, 1988, 5, 1016, 509, 2, 1987,
	1985, 3, 2, 2, 2, 1987, 1988, 3, 2, 2, 2, 1988, 2001, 3, 2, 2, 2, 1989,
	1991, 5, 66, 34, 2, 1990, 1989, 3, 2, 2, 2, 1990, 1991, 3, 2, 2, 2, 1991,
	1992, 3, 2, 2, 2, 1992, 1993, 7, 39, 2, 2, 1993, 1994, 5, 1202, 602, 2,
	1994, 1996, 7, 29, 2, 2, 1995, 1997, 5, 1032, 517, 2, 1996, 1995, 3, 2,
	2, 2, 1996, 1997, 3, 2, 2, 2, 1997, 1998, 3, 2, 2, 2, 1998, 1999, 7, 31,
	2, 2, 1999, 2001, 3, 2, 2, 2, 2000, 1962, 3, 2, 2, 2, 2000, 1976, 3, 2,
	2, 2, 2000, 1990, 3, 2, 2, 2, 2001, 75, 3, 2, 2, 2, 2002, 2008, 7, 18,
	2, 2, 2003, 2005, 7, 29, 2, 2, 2004, 2006, 5, 1002, 502, 2, 2005, 2004,
	3, 2, 2, 2, 2005, 2006, 3, 2, 2, 2, 2006, 2007, 3, 2, 2, 2, 2007, 2009,
	7, 31, 2, 2, 2008, 2003, 3, 2, 2, 2, 2008, 2009, 3, 2, 2, 2, 2009, 2010,
	3, 2, 2, 2, 2010, 2021, 7, 48, 2, 2, 2011, 2017, 9, 4, 2, 2, 2012, 2014,
	7, 29, 2, 2, 2013, 2015, 5, 1002, 502, 2, 2014, 2013, 3, 2, 2, 2, 2014,
	2015, 3, 2, 2, 2, 2015, 2016, 3, 2, 2, 2, 2016, 2018, 7, 31, 2, 2, 2017,
	2012, 3, 2, 2, 2, 2017, 2018, 3, 2, 2, 2, 2018, 2019, 3, 2, 2, 2, 2019,
	2021, 7, 48, 2, 2, 2020, 2002, 3, 2, 2, 2, 2020, 2011, 3, 2, 2, 2, 2021,
	77, 3, 2, 2, 2, 2022, 2036, 5, 84, 43, 2, 2023, 2036, 5, 646, 324, 2, 2024,
	2036, 5, 648, 325, 2, 2025, 2036, 5, 814, 408, 2, 2026, 2036, 5, 90, 46,
	2, 2027, 2036, 5, 678, 340, 2, 2028, 2036, 5, 684, 343, 2, 2029, 2036,
	5, 688, 345, 2, 2030, 2036, 5, 694, 348, 2, 2031, 2036, 5, 690, 346, 2,
	2032, 2036, 5, 660, 331, 2, 2033, 2036, 5, 666, 334, 2, 2034, 2036, 5,
	76, 39, 2, 2035, 2022, 3, 2, 2, 2, 2035, 2023, 3, 2, 2, 2, 2035, 2024,
	3, 2, 2, 2, 2035, 2025, 3, 2, 2, 2, 2035, 2026, 3, 2, 2, 2, 2035, 2027,
	3, 2, 2, 2, 2035, 2028, 3, 2, 2, 2, 2035, 2029, 3, 2, 2, 2, 2035, 2030,
	3, 2, 2, 2, 2035, 2031, 3, 2, 2, 2, 2035, 2032, 3, 2, 2, 2, 2035, 2033,
	3, 2, 2, 2, 2035, 2034, 3, 2, 2, 2, 2036, 79, 3, 2, 2, 2, 2037, 2038, 5,
	58, 30, 2, 2038, 2039, 7, 48, 2, 2, 2039, 2042, 3, 2, 2, 2, 2040, 2042,
	5, 86, 44, 2, 2041, 2037, 3, 2, 2, 2, 2041, 2040, 3, 2, 2, 2, 2042, 81,
	3, 2, 2, 2, 2043, 2045, 5, 1094, 548, 2, 2044, 2043, 3, 2, 2, 2, 2045,
	2048, 3, 2, 2, 2, 2046, 2044, 3, 2, 2, 2, 2046, 2047, 3, 2, 2, 2, 2047,
	2053, 3, 2, 2, 2, 2048, 2046, 3, 2, 2, 2, 2049, 2054, 5, 88, 45, 2, 2050,
	2054, 5, 578, 290, 2, 2051, 2054, 5, 626, 314, 2, 2052, 2054, 5, 78, 40,
	2, 2053, 2049, 3, 2, 2, 2, 2053, 2050, 3, 2, 2, 2, 2053, 2051, 3, 2, 2,
	2, 2053, 2052, 3, 2, 2, 2, 2054, 83, 3, 2, 2, 2, 2055, 2069, 5, 198, 100,
	2, 2056, 2069, 5, 228, 115, 2, 2057, 2069, 5, 838, 420, 2, 2058, 2064,
	7, 136, 2, 2, 2059, 2060, 7, 124, 2, 2, 2060, 2065, 5, 1116, 559, 2, 2061,
	2062, 7, 139, 2, 2, 2062, 2063, 7, 183, 2, 2, 2063, 2065, 5, 492, 247,
	2, 2064, 2059, 3, 2, 2, 2, 2064, 2061, 3, 2, 2, 2, 2065, 2066, 3, 2, 2,
	2, 2066, 2067, 7, 48, 2, 2, 2067, 2069, 3, 2, 2, 2, 2068, 2055, 3, 2, 2,
	2, 2068, 2056, 3, 2, 2, 2, 2068, 2057, 3, 2, 2, 2, 2068, 2058, 3, 2, 2,
	2, 2069, 85, 3, 2, 2, 2, 2070, 2085, 5, 658, 330, 2, 2071, 2085, 5, 82,
	42, 2, 2072, 2085, 5, 886, 444, 2, 2073, 2075, 5, 1094, 548, 2, 2074, 2073,
	3, 2, 2, 2, 2075, 2078, 3, 2, 2, 2, 2076, 2074, 3, 2, 2, 2, 2076, 2077,
	3, 2, 2, 2, 2077, 2079, 3, 2, 2, 2, 2078, 2076, 3, 2, 2, 2, 2079, 2085,
	5, 208, 105, 2, 2080, 2085, 5, 28, 15, 2, 2081, 2085, 5, 18, 10, 2, 2082,
	2085, 5, 22, 12, 2, 2083, 2085, 5, 48, 25, 2, 2084, 2070, 3, 2, 2, 2, 2084,
	2071, 3, 2, 2, 2, 2084, 2072, 3, 2, 2, 2, 2084, 2076, 3, 2, 2, 2, 2084,
	2080, 3, 2, 2, 2, 2084, 2081, 3, 2, 2, 2, 2084, 2082, 3, 2, 2, 2, 2084,
	2083, 3, 2, 2, 2, 2085, 87, 3, 2, 2, 2, 2086, 2087, 7, 137, 2, 2, 2087,
	2088, 5, 296, 149, 2, 2088, 2089, 7, 48, 2, 2, 2089, 89, 3, 2, 2, 2, 2090,
	2097, 7, 108, 2, 2, 2091, 2094, 5, 92, 47, 2, 2092, 2093, 7, 43, 2, 2,
	2093, 2095, 5, 96, 49, 2, 2094, 2092, 3, 2, 2, 2, 2094, 2095, 3, 2, 2,
	2, 2095, 2098, 3, 2, 2, 2, 2096, 2098, 5, 94, 48, 2, 2097, 2091, 3, 2,
	2, 2, 2097, 2096, 3, 2, 2, 2, 2098, 2099, 3, 2, 2, 2, 2099, 2100, 5, 98,
	50, 2, 2100, 2101, 7, 48, 2, 2, 2101, 91, 3, 2, 2, 2, 2102, 2105, 5, 1188,
	595, 2, 2103, 2105, 5, 1170, 586, 2, 2104, 2102, 3, 2, 2, 2, 2104, 2103,
	3, 2, 2, 2, 2105, 93, 3, 2, 2, 2, 2106, 2107, 5, 1150, 576, 2, 2107, 2108,
	5, 1068, 535, 2, 2108, 95, 3, 2, 2, 2, 2109, 2114, 5, 94, 48, 2, 2110,
	2111, 7, 38, 2, 2, 2111, 2113, 5, 94, 48, 2, 2112, 2110, 3, 2, 2, 2, 2113,
	2116, 3, 2, 2, 2, 2114, 2112, 3, 2, 2, 2, 2114, 2115, 3, 2, 2, 2, 2115,
	97, 3, 2, 2, 2, 2116, 2114, 3, 2, 2, 2, 2117, 2122, 5, 648, 325, 2, 2118,
	2122, 5, 626, 314, 2, 2119, 2122, 5, 646, 324, 2, 2120, 2122, 5, 650, 326,
	2, 2121, 2117, 3, 2, 2, 2, 2121, 2118, 3, 2, 2, 2, 2121, 2119, 3, 2, 2,
	2, 2121, 2120, 3, 2, 2, 2, 2122, 99, 3, 2, 2, 2, 2123, 2124, 7, 126, 2,
	2, 2124, 2125, 5, 1118, 560, 2, 2125, 2131, 7, 48, 2, 2, 2126, 2127, 5,
	204, 103, 2, 2127, 2128, 7, 48, 2, 2, 2128, 2130, 3, 2, 2, 2, 2129, 2126,
	3, 2, 2, 2, 2130, 2133, 3, 2, 2, 2, 2131, 2129, 3, 2, 2, 2, 2131, 2132,
	3, 2, 2, 2, 2132, 2134, 3, 2, 2, 2, 2133, 2131, 3, 2, 2, 2, 2134, 2138,
	5, 102, 52, 2, 2135, 2137, 5, 104, 53, 2, 2136, 2135, 3, 2, 2, 2, 2137,
	2140, 3, 2, 2, 2, 2138, 2136, 3, 2, 2, 2, 2138, 2139, 3, 2, 2, 2, 2139,
	2141, 3, 2, 2, 2, 2140, 2138, 3, 2, 2, 2, 2141, 2144, 7, 149, 2, 2, 2142,
	2143, 7, 43, 2, 2, 2143, 2145, 5, 1118, 560, 2, 2144, 2142, 3, 2, 2, 2,
	2144, 2145, 3, 2, 2, 2, 2145, 101, 3, 2, 2, 2, 2146, 2155, 7, 138, 2, 2,
	2147, 2148, 5, 1180, 591, 2, 2148, 2149, 7, 39, 2, 2, 2149, 2151, 3, 2,
	2, 2, 2150, 2147, 3, 2, 2, 2, 2150, 2151, 3, 2, 2, 2, 2151, 2152, 3, 2,
	2, 2, 2152, 2154, 5, 1108, 555, 2, 2153, 2150, 3, 2, 2, 2, 2154, 2157,
	3, 2, 2, 2, 2155, 2153, 3, 2, 2, 2, 2155, 2156, 3, 2, 2, 2, 2156, 2158,
	3, 2, 2, 2, 2157, 2155, 3, 2, 2, 2, 2158, 2159, 7, 48, 2, 2, 2159, 103,
	3, 2, 2, 2, 2160, 2164, 5, 106, 54, 2, 2161, 2164, 5, 108, 55, 2, 2162,
	2164, 5, 112, 57, 2, 2163, 2160, 3, 2, 2, 2, 2163, 2161, 3, 2, 2, 2, 2163,
	2162, 3, 2, 2, 2, 2164, 2165, 3, 2, 2, 2, 2165, 2166, 5, 114, 58, 2, 2166,
	2167, 7, 48, 2, 2, 2167, 2176, 3, 2, 2, 2, 2168, 2171, 5, 108, 55, 2, 2169,
	2171, 5, 112, 57, 2, 2170, 2168, 3, 2, 2, 2, 2170, 2169, 3, 2, 2, 2, 2171,
	2172, 3, 2, 2, 2, 2172, 2173, 5, 116, 59, 2, 2173, 2174, 7, 48, 2, 2, 2174,
	2176, 3, 2, 2, 2, 2175, 2163, 3, 2, 2, 2, 2175, 2170, 3, 2, 2, 2, 2176,
	105, 3, 2, 2, 2, 2177, 2178, 7, 136, 2, 2, 2178, 107, 3, 2, 2, 2, 2179,
	2180, 7, 196, 2, 2, 2180, 2181, 5, 110, 56, 2, 2181, 109, 3, 2, 2, 2, 2182,
	2187, 5, 1242, 622, 2, 2183, 2184, 7, 39, 2, 2, 2184, 2186, 5, 1178, 590,
	2, 2185, 2183, 3, 2, 2, 2, 2186, 2189, 3, 2, 2, 2, 2187, 2185, 3, 2, 2,
	2, 2187, 2188, 3, 2, 2, 2, 2188, 111, 3, 2, 2, 2, 2189, 2187, 3, 2, 2,
	2, 2190, 2194, 7, 120, 2, 2, 2191, 2192, 5, 1180, 591, 2, 2192, 2193, 7,
	39, 2, 2, 2193, 2195, 3, 2, 2, 2, 2194, 2191, 3, 2, 2, 2, 2194, 2195, 3,
	2, 2, 2, 2195, 2196, 3, 2, 2, 2, 2196, 2197, 5, 1108, 555, 2, 2197, 113,
	3, 2, 2, 2, 2198, 2202, 7, 207, 2, 2, 2199, 2201, 5, 1180, 591, 2, 2200,
	2199, 3, 2, 2, 2, 2201, 2204, 3, 2, 2, 2, 2202, 2200, 3, 2, 2, 2, 2202,
	2203, 3, 2, 2, 2, 2203, 115, 3, 2, 2, 2, 2204, 2202, 3, 2, 2, 2, 2205,
	2209, 7, 325, 2, 2, 2206, 2207, 5, 1180, 591, 2, 2207, 2208, 7, 39, 2,
	2, 2208, 2210, 3, 2, 2, 2, 2209, 2206, 3, 2, 2, 2, 2209, 2210, 3, 2, 2,
	2, 2210, 2211, 3, 2, 2, 2, 2211, 2220, 5, 1108, 555, 2, 2212, 2217, 5,
	634, 318, 2, 2213, 2214, 7, 38, 2, 2, 2214, 2216, 5, 634, 318, 2, 2215,
	2213, 3, 2, 2, 2, 2216, 2219, 3, 2, 2, 2, 2217, 2215, 3, 2, 2, 2, 2217,
	2218, 3, 2, 2, 2, 2218, 2221, 3, 2, 2, 2, 2219, 2217, 3, 2, 2, 2, 2220,
	2212, 3, 2, 2, 2, 2220, 2221, 3, 2, 2, 2, 2221, 2224, 3, 2, 2, 2, 2222,
	2223, 7, 43, 2, 2, 2223, 2225, 7, 126, 2, 2, 2224, 2222, 3, 2, 2, 2, 2224,
	2225, 3, 2, 2, 2, 2225, 2240, 3, 2, 2, 2, 2226, 2227, 7, 325, 2, 2, 2227,
	2232, 5, 634, 318, 2, 2228, 2229, 7, 38, 2, 2, 2229, 2231, 5, 634, 318,
	2, 2230, 2228, 3, 2, 2, 2, 2231, 2234, 3, 2, 2, 2, 2232, 2230, 3, 2, 2,
	2, 2232, 2233, 3, 2, 2, 2, 2233, 2237, 3, 2, 2, 2, 2234, 2232, 3, 2, 2,
	2, 2235, 2236, 7, 43, 2, 2, 2236, 2238, 7, 126, 2, 2, 2237, 2235, 3, 2,
	2, 2, 2237, 2238, 3, 2, 2, 2, 2238, 2240, 3, 2, 2, 2, 2239, 2205, 3, 2,
	2, 2, 2239, 2226, 3, 2, 2, 2, 2240, 117, 3, 2, 2, 2, 2241, 2243, 5, 1094,
	548, 2, 2242, 2241, 3, 2, 2, 2, 2243, 2246, 3, 2, 2, 2, 2244, 2242, 3,
	2, 2, 2, 2244, 2245, 3, 2, 2, 2, 2245, 2249, 3, 2, 2, 2, 2246, 2244, 3,
	2, 2, 2, 2247, 2250, 5, 78, 40, 2, 2248, 2250, 5, 120, 61, 2, 2249, 2247,
	3, 2, 2, 2, 2249, 2248, 3, 2, 2, 2, 2250, 119, 3, 2, 2, 2, 2251, 2255,
	7, 167, 2, 2, 2252, 2256, 5, 162, 82, 2, 2253, 2254, 7, 175, 2, 2, 2254,
	2256, 5, 392, 197, 2, 2255, 2252, 3, 2, 2, 2, 2255, 2253, 3, 2, 2, 2, 2256,
	2257, 3, 2, 2, 2, 2257, 2258, 7, 48, 2, 2, 2258, 121, 3, 2, 2, 2, 2259,
	2260, 5, 58, 30, 2, 2260, 2261, 7, 48, 2, 2, 2261, 2264, 3, 2, 2, 2, 2262,
	2264, 5, 124, 63, 2, 2263, 2259, 3, 2, 2, 2, 2263, 2262, 3, 2, 2, 2, 2264,
	123, 3, 2, 2, 2, 2265, 2272, 5, 658, 330, 2, 2266, 2272, 5, 118, 60, 2,
	2267, 2272, 5, 28, 15, 2, 2268, 2272, 5, 396, 199, 2, 2269, 2272, 5, 22,
	12, 2, 2270, 2272, 5, 48, 25, 2, 2271, 2265, 3, 2, 2, 2, 2271, 2266, 3,
	2, 2, 2, 2271, 2267, 3, 2, 2, 2, 2271, 2268, 3, 2, 2, 2, 2271, 2269, 3,
	2, 2, 2, 2271, 2270, 3, 2, 2, 2, 2272, 125, 3, 2, 2, 2, 2273, 2274, 5,
	58, 30, 2, 2274, 2275, 7, 48, 2, 2, 2275, 2278, 3, 2, 2, 2, 2276, 2278,
	5, 128, 65, 2, 2277, 2273, 3, 2, 2, 2, 2277, 2276, 3, 2, 2, 2, 2278, 127,
	3, 2, 2, 2, 2279, 2281, 5, 1094, 548, 2, 2280, 2279, 3, 2, 2, 2, 2281,
	2284, 3, 2, 2, 2, 2282, 2280, 3, 2, 2, 2, 2282, 2283, 3, 2, 2, 2, 2283,
	2290, 3, 2, 2, 2, 2284, 2282, 3, 2, 2, 2, 2285, 2291, 5, 678, 340, 2, 2286,
	2291, 5, 84, 43, 2, 2287, 2291, 5, 688, 345, 2, 2288, 2291, 5, 694, 348,
	2, 2289, 2291, 5, 414, 208, 2, 2290, 2285, 3, 2, 2, 2, 2290, 2286, 3, 2,
	2, 2, 2290, 2287, 3, 2, 2, 2, 2290, 2288, 3, 2, 2, 2, 2290, 2289, 3, 2,
	2, 2, 2291, 2295, 3, 2, 2, 2, 2292, 2295, 5, 48, 25, 2, 2293, 2295, 5,
	130, 66, 2, 2294, 2282, 3, 2, 2, 2, 2294, 2292, 3, 2, 2, 2, 2294, 2293,
	3, 2, 2, 2, 2295, 129, 3, 2, 2, 2, 2296, 2301, 5, 660, 331, 2, 2297, 2301,
	5, 666, 334, 2, 2298, 2301, 5, 658, 330, 2, 2299, 2301, 5, 76, 39, 2, 2300,
	2296, 3, 2, 2, 2, 2300, 2297, 3, 2, 2, 2, 2300, 2298, 3, 2, 2, 2, 2300,
	2299, 3, 2, 2, 2, 2301, 131, 3, 2, 2, 2, 2302, 2307, 5, 134, 68, 2, 2303,
	2304, 7, 38, 2, 2, 2304, 2306, 5, 134, 68, 2, 2305, 2303, 3, 2, 2, 2, 2306,
	2309, 3, 2, 2, 2, 2307, 2305, 3, 2, 2, 2, 2307, 2308, 3, 2, 2, 2, 2308,
	133, 3, 2, 2, 2, 2309, 2307, 3, 2, 2, 2, 2310, 2312, 5, 1094, 548, 2, 2311,
	2310, 3, 2, 2, 2, 2312, 2315, 3, 2, 2, 2, 2313, 2311, 3, 2, 2, 2, 2313,
	2314, 3, 2, 2, 2, 2314, 2317, 3, 2, 2, 2, 2315, 2313, 3, 2, 2, 2, 2316,
	2318, 5, 136, 69, 2, 2317, 2316, 3, 2, 2, 2, 2317, 2318, 3, 2, 2, 2, 2318,
	2319, 3, 2, 2, 2, 2319, 2320, 5, 446, 224, 2, 2320, 2324, 5, 1136, 569,
	2, 2321, 2323, 5, 352, 177, 2, 2322, 2321, 3, 2, 2, 2, 2323, 2326, 3, 2,
	2, 2, 2324, 2322, 3, 2, 2, 2, 2324, 2325, 3, 2, 2, 2, 2325, 2329, 3, 2,
	2, 2, 2326, 2324, 3, 2, 2, 2, 2327, 2328, 7, 80, 2, 2, 2328, 2330, 5, 434,
	218, 2, 2329, 2327, 3, 2, 2, 2, 2329, 2330, 3, 2, 2, 2, 2330, 135, 3, 2,
	2, 2, 2331, 2332, 9, 5, 2, 2, 2332, 137, 3, 2, 2, 2, 2333, 2341, 5, 140,
	71, 2, 2334, 2341, 5, 688, 345, 2, 2335, 2341, 5, 690, 346, 2, 2336, 2341,
	5, 694, 348, 2, 2337, 2341, 5, 814, 408, 2, 2338, 2341, 5, 678, 340, 2,
	2339, 2341, 5, 142, 72, 2, 2340, 2333, 3, 2, 2, 2, 2340, 2334, 3, 2, 2,
	2, 2340, 2335, 3, 2, 2, 2, 2340, 2336, 3, 2, 2, 2, 2340, 2337, 3, 2, 2,
	2, 2340, 2338, 3, 2, 2, 2, 2340, 2339, 3, 2, 2, 2, 2341, 139, 3, 2, 2,
	2, 2342, 2344, 7, 251, 2, 2, 2343, 2342, 3, 2, 2, 2, 2343, 2344, 3, 2,
	2, 2, 2344, 2345, 3, 2, 2, 2, 2345, 2364, 5, 220, 111, 2, 2346, 2364, 5,
	360, 181, 2, 2347, 2364, 5, 34, 18, 2, 2348, 2364, 5, 436, 219, 2, 2349,
	2364, 5, 496, 249, 2, 2350, 2364, 5, 228, 115, 2, 2351, 2364, 5, 838, 420,
	2, 2352, 2358, 7, 136, 2, 2, 2353, 2354, 7, 124, 2, 2, 2354, 2359, 5, 1116,
	559, 2, 2355, 2356, 7, 139, 2, 2, 2356, 2357, 7, 183, 2, 2, 2357, 2359,
	5, 492, 247, 2, 2358, 2353, 3, 2, 2, 2, 2358, 2355, 3, 2, 2, 2, 2359, 2361,
	3, 2, 2, 2, 2360, 2352, 3, 2, 2, 2, 2360, 2361, 3, 2, 2, 2, 2361, 2362,
	3, 2, 2, 2, 2362, 2364, 7, 48, 2, 2, 2363, 2343, 3, 2, 2, 2, 2363, 2346,
	3, 2, 2, 2, 2363, 2347, 3, 2, 2, 2, 2363, 2348, 3, 2, 2, 2, 2363, 2349,
	3, 2, 2, 2, 2363, 2350, 3, 2, 2, 2, 2363, 2351, 3, 2, 2, 2, 2363, 2360,
	3, 2, 2, 2, 2364, 141, 3, 2, 2, 2, 2365, 2370, 5, 660, 331, 2, 2366, 2370,
	5, 666, 334, 2, 2367, 2370, 5, 658, 330, 2, 2368, 2370, 5, 76, 39, 2, 2369,
	2365, 3, 2, 2, 2, 2369, 2366, 3, 2, 2, 2, 2369, 2367, 3, 2, 2, 2, 2369,
	2368, 3, 2, 2, 2, 2370, 143, 3, 2, 2, 2, 2371, 2373, 5, 1094, 548, 2, 2372,
	2371, 3, 2, 2, 2, 2373, 2376, 3, 2, 2, 2, 2374, 2372, 3, 2, 2, 2, 2374,
	2375, 3, 2, 2, 2, 2375, 2382, 3, 2, 2, 2, 2376, 2374, 3, 2, 2, 2, 2377,
	2383, 5, 146, 74, 2, 2378, 2383, 5, 148, 75, 2, 2379, 2383, 5, 152, 77,
	2, 2380, 2383, 5, 36, 19, 2, 2381, 2383, 5, 496, 249, 2, 2382, 2377, 3,
	2, 2, 2, 2382, 2378, 3, 2, 2, 2, 2382, 2379, 3, 2, 2, 2, 2382, 2380, 3,
	2, 2, 2, 2382, 2381, 3, 2, 2, 2, 2383, 2390, 3, 2, 2, 2, 2384, 2387, 5,
	204, 103, 2, 2385, 2387, 5, 206, 104, 2, 2386, 2384, 3, 2, 2, 2, 2386,
	2385, 3, 2, 2, 2, 2386, 2387, 3, 2, 2, 2, 2387, 2388, 3, 2, 2, 2, 2388,
	2390, 7, 48, 2, 2, 2389, 2374, 3, 2, 2, 2, 2389, 2386, 3, 2, 2, 2, 2390,
	145, 3, 2, 2, 2, 2391, 2393, 5, 156, 79, 2, 2392, 2391, 3, 2, 2, 2, 2393,
	2396, 3, 2, 2, 2, 2394, 2392, 3, 2, 2, 2, 2394, 2395, 3, 2, 2, 2, 2395,
	2397, 3, 2, 2, 2, 2396, 2394, 3, 2, 2, 2, 2397, 2414, 5, 220, 111, 2, 2398,
	2402, 7, 127, 2, 2, 2399, 2401, 5, 154, 78, 2, 2400, 2399, 3, 2, 2, 2,
	2401, 2404, 3, 2, 2, 2, 2402, 2400, 3, 2, 2, 2, 2402, 2403, 3, 2, 2, 2,
	2403, 2405, 3, 2, 2, 2, 2404, 2402, 3, 2, 2, 2, 2405, 2406, 5, 240, 121,
	2, 2406, 2409, 5, 1120, 561, 2, 2407, 2408, 7, 80, 2, 2, 2408, 2410, 5,
	1016, 509, 2, 2409, 2407, 3, 2, 2, 2, 2409, 2410, 3, 2, 2, 2, 2410, 2411,
	3, 2, 2, 2, 2411, 2412, 7, 48, 2, 2, 2412, 2414, 3, 2, 2, 2, 2413, 2394,
	3, 2, 2, 2, 2413, 2398, 3, 2, 2, 2, 2414, 147, 3, 2, 2, 2, 2415, 2417,
	5, 160, 81, 2, 2416, 2415, 3, 2, 2, 2, 2417, 2420, 3, 2, 2, 2, 2418, 2416,
	3, 2, 2, 2, 2418, 2419, 3, 2, 2, 2, 2419, 2424, 3, 2, 2, 2, 2420, 2418,
	3, 2, 2, 2, 2421, 2425, 5, 378, 190, 2, 2422, 2425, 5, 360, 181, 2, 2423,
	2425, 5, 164, 83, 2, 2424, 2421, 3, 2, 2, 2, 2424, 2422, 3, 2, 2, 2, 2424,
	2423, 3, 2, 2, 2, 2425, 2451, 3, 2, 2, 2, 2426, 2427, 7, 250, 2, 2, 2427,
	2431, 7, 329, 2, 2, 2428, 2430, 5, 154, 78, 2, 2429, 2428, 3, 2, 2, 2,
	2430, 2433, 3, 2, 2, 2, 2431, 2429, 3, 2, 2, 2, 2431, 2432, 3, 2, 2, 2,
	2432, 2434, 3, 2, 2, 2, 2433, 2431, 3, 2, 2, 2, 2434, 2435, 5, 162, 82,
	2, 2435, 2436, 7, 48, 2, 2, 2436, 2451, 3, 2, 2, 2, 2437, 2441, 7, 167,
	2, 2, 2438, 2440, 5, 160, 81, 2, 2439, 2438, 3, 2, 2, 2, 2440, 2443, 3,
	2, 2, 2, 2441, 2439, 3, 2, 2, 2, 2441, 2442, 3, 2, 2, 2, 2442, 2448, 3,
	2, 2, 2, 2443, 2441, 3, 2, 2, 2, 2444, 2445, 5, 162, 82, 2, 2445, 2446,
	7, 48, 2, 2, 2446, 2449, 3, 2, 2, 2, 2447, 2449, 5, 150, 76, 2, 2448, 2444,
	3, 2, 2, 2, 2448, 2447, 3, 2, 2, 2, 2449, 2451, 3, 2, 2, 2, 2450, 2418,
	3, 2, 2, 2, 2450, 2426, 3, 2, 2, 2, 2450, 2437, 3, 2, 2, 2, 2451, 149,
	3, 2, 2, 2, 2452, 2453, 7, 176, 2, 2, 2453, 2459, 7, 222, 2, 2, 2454, 2456,
	7, 29, 2, 2, 2455, 2457, 5, 384, 193, 2, 2456, 2455, 3, 2, 2, 2, 2456,
	2457, 3, 2, 2, 2, 2457, 2458, 3, 2, 2, 2, 2458, 2460, 7, 31, 2, 2, 2459,
	2454, 3, 2, 2, 2, 2459, 2460, 3, 2, 2, 2, 2460, 2461, 3, 2, 2, 2, 2461,
	2462, 7, 48, 2, 2, 2462, 151, 3, 2, 2, 2, 2463, 2466, 5, 188, 95, 2, 2464,
	2466, 5, 166, 84, 2, 2465, 2463, 3, 2, 2, 2, 2465, 2464, 3, 2, 2, 2, 2466,
	153, 3, 2, 2, 2, 2467, 2468, 9, 6, 2, 2, 2468, 155, 3, 2, 2, 2, 2469, 2472,
	5, 158, 80, 2, 2470, 2472, 5, 154, 78, 2, 2471, 2469, 3, 2, 2, 2, 2471,
	2470, 3, 2, 2, 2, 2472, 157, 3, 2, 2, 2, 2473, 2474, 9, 7, 2, 2, 2474,
	159, 3, 2, 2, 2, 2475, 2477, 7, 250, 2, 2, 2476, 2475, 3, 2, 2, 2, 2476,
	2477, 3, 2, 2, 2, 2477, 2478, 3, 2, 2, 2, 2478, 2481, 7, 329, 2, 2, 2479,
	2481, 5, 154, 78, 2, 2480, 2476, 3, 2, 2, 2, 2480, 2479, 3, 2, 2, 2, 2481,
	161, 3, 2, 2, 2, 2482, 2485, 5, 392, 197, 2, 2483, 2485, 5, 364, 183, 2,
	2484, 2482, 3, 2, 2, 2, 2484, 2483, 3, 2, 2, 2, 2485, 163, 3, 2, 2, 2,
	2486, 2488, 7, 176, 2, 2, 2487, 2489, 5, 250, 126, 2, 2488, 2487, 3, 2,
	2, 2, 2488, 2489, 3, 2, 2, 2, 2489, 2490, 3, 2, 2, 2, 2490, 2496, 7, 222,
	2, 2, 2491, 2493, 7, 29, 2, 2, 2492, 2494, 5, 384, 193, 2, 2493, 2492,
	3, 2, 2, 2, 2493, 2494, 3, 2, 2, 2, 2494, 2495, 3, 2, 2, 2, 2495, 2497,
	7, 31, 2, 2, 2496, 2491, 3, 2, 2, 2, 2496, 2497, 3, 2, 2, 2, 2497, 2498,
	3, 2, 2, 2, 2498, 2502, 7, 48, 2, 2, 2499, 2501, 5, 394, 198, 2, 2500,
	2499, 3, 2, 2, 2, 2501, 2504, 3, 2, 2, 2, 2502, 2500, 3, 2, 2, 2, 2502,
	2503, 3, 2, 2, 2, 2503, 2515, 3, 2, 2, 2, 2504, 2502, 3, 2, 2, 2, 2505,
	2506, 7, 294, 2, 2, 2506, 2507, 7, 39, 2, 2, 2507, 2512, 7, 222, 2, 2,
	2508, 2509, 7, 29, 2, 2, 2509, 2510, 5, 1002, 502, 2, 2510, 2511, 7, 31,
	2, 2, 2511, 2513, 3, 2, 2, 2, 2512, 2508, 3, 2, 2, 2, 2512, 2513, 3, 2,
	2, 2, 2513, 2514, 3, 2, 2, 2, 2514, 2516, 7, 48, 2, 2, 2515, 2505, 3, 2,
	2, 2, 2515, 2516, 3, 2, 2, 2, 2516, 2520, 3, 2, 2, 2, 2517, 2519, 5, 724,
	363, 2, 2518, 2517, 3, 2, 2, 2, 2519, 2522, 3, 2, 2, 2, 2520, 2518, 3,
	2, 2, 2, 2520, 2521, 3, 2, 2, 2, 2521, 2523, 3, 2, 2, 2, 2522, 2520, 3,
	2, 2, 2, 2523, 2526, 7, 150, 2, 2, 2524, 2525, 7, 43, 2, 2, 2525, 2527,
	7, 222, 2, 2, 2526, 2524, 3, 2, 2, 2, 2526, 2527, 3, 2, 2, 2, 2527, 165,
	3, 2, 2, 2, 2528, 2530, 7, 287, 2, 2, 2529, 2528, 3, 2, 2, 2, 2529, 2530,
	3, 2, 2, 2, 2530, 2531, 3, 2, 2, 2, 2531, 2532, 7, 128, 2, 2, 2532, 2533,
	5, 1122, 562, 2, 2533, 2534, 5, 168, 85, 2, 2534, 167, 3, 2, 2, 2, 2535,
	2539, 7, 58, 2, 2, 2536, 2538, 5, 170, 86, 2, 2537, 2536, 3, 2, 2, 2, 2538,
	2541, 3, 2, 2, 2, 2539, 2537, 3, 2, 2, 2, 2539, 2540, 3, 2, 2, 2, 2540,
	2542, 3, 2, 2, 2, 2541, 2539, 3, 2, 2, 2, 2542, 2543, 7, 64, 2, 2, 2543,
	169, 3, 2, 2, 2, 2544, 2545, 7, 284, 2, 2, 2545, 2546, 5, 172, 87, 2, 2546,
	2547, 7, 106, 2, 2, 2547, 2548, 5, 172, 87, 2, 2548, 2549, 7, 48, 2, 2,
	2549, 2552, 3, 2, 2, 2, 2550, 2552, 5, 176, 89, 2, 2551, 2544, 3, 2, 2,
	2, 2551, 2550, 3, 2, 2, 2, 2552, 171, 3, 2, 2, 2, 2553, 2558, 5, 174, 88,
	2, 2554, 2555, 7, 38, 2, 2, 2555, 2557, 5, 174, 88, 2, 2556, 2554, 3, 2,
	2, 2, 2557, 2560, 3, 2, 2, 2, 2558, 2556, 3, 2, 2, 2, 2558, 2559, 3, 2,
	2, 2, 2559, 173, 3, 2, 2, 2, 2560, 2558, 3, 2, 2, 2, 2561, 2562, 5, 1060,
	531, 2, 2562, 2563, 7, 39, 2, 2, 2563, 2566, 3, 2, 2, 2, 2564, 2566, 5,
	250, 126, 2, 2565, 2561, 3, 2, 2, 2, 2565, 2564, 3, 2, 2, 2, 2565, 2566,
	3, 2, 2, 2, 2566, 2567, 3, 2, 2, 2, 2567, 2568, 5, 1150, 576, 2, 2568,
	2569, 5, 1064, 533, 2, 2569, 175, 3, 2, 2, 2, 2570, 2572, 7, 283, 2, 2,
	2571, 2570, 3, 2, 2, 2, 2571, 2572, 3, 2, 2, 2, 2572, 2573, 3, 2, 2, 2,
	2573, 2574, 5, 492, 247, 2, 2574, 2575, 7, 48, 2, 2, 2575, 2607, 3, 2,
	2, 2, 2576, 2577, 5, 178, 90, 2, 2577, 2578, 7, 48, 2, 2, 2578, 2607, 3,
	2, 2, 2, 2579, 2580, 5, 1032, 517, 2, 2580, 2581, 7, 87, 2, 2, 2581, 2582,
	5, 180, 91, 2, 2582, 2607, 3, 2, 2, 2, 2583, 2584, 7, 182, 2, 2, 2584,
	2585, 7, 29, 2, 2, 2585, 2586, 5, 1032, 517, 2, 2586, 2587, 7, 31, 2, 2,
	2587, 2590, 5, 180, 91, 2, 2588, 2589, 7, 143, 2, 2, 2589, 2591, 5, 180,
	91, 2, 2590, 2588, 3, 2, 2, 2, 2590, 2591, 3, 2, 2, 2, 2591, 2607, 3, 2,
	2, 2, 2592, 2593, 7, 172, 2, 2, 2593, 2594, 7, 29, 2, 2, 2594, 2595, 5,
	1218, 610, 2, 2595, 2596, 7, 52, 2, 2, 2596, 2597, 5, 810, 406, 2, 2597,
	2598, 7, 54, 2, 2, 2598, 2599, 7, 31, 2, 2, 2599, 2600, 5, 180, 91, 2,
	2600, 2607, 3, 2, 2, 2, 2601, 2602, 7, 139, 2, 2, 2602, 2603, 7, 283, 2,
	2, 2603, 2604, 5, 174, 88, 2, 2604, 2605, 7, 48, 2, 2, 2605, 2607, 3, 2,
	2, 2, 2606, 2571, 3, 2, 2, 2, 2606, 2576, 3, 2, 2, 2, 2606, 2579, 3, 2,
	2, 2, 2606, 2583, 3, 2, 2, 2, 2606, 2592, 3, 2, 2, 2, 2606, 2601, 3, 2,
	2, 2, 2607, 177, 3, 2, 2, 2, 2608, 2612, 7, 319, 2, 2, 2609, 2611, 5, 776,
	389, 2, 2610, 2609, 3, 2, 2, 2, 2611, 2614, 3, 2, 2, 2, 2612, 2610, 3,
	2, 2, 2, 2612, 2613, 3, 2, 2, 2, 2613, 179, 3, 2, 2, 2, 2614, 2612, 3,
	2, 2, 2, 2615, 2625, 5, 176, 89, 2, 2616, 2620, 7, 58, 2, 2, 2617, 2619,
	5, 176, 89, 2, 2618, 2617, 3, 2, 2, 2, 2619, 2622, 3, 2, 2, 2, 2620, 2618,
	3, 2, 2, 2, 2620, 2621, 3, 2, 2, 2, 2621, 2623, 3, 2, 2, 2, 2622, 2620,
	3, 2, 2, 2, 2623, 2625, 7, 64, 2, 2, 2624, 2615, 3, 2, 2, 2, 2624, 2616,
	3, 2, 2, 2, 2625, 181, 3, 2, 2, 2, 2626, 2631, 5, 184, 93, 2, 2627, 2628,
	7, 38, 2, 2, 2628, 2630, 5, 184, 93, 2, 2629, 2627, 3, 2, 2, 2, 2630, 2633,
	3, 2, 2, 2, 2631, 2629, 3, 2, 2, 2, 2631, 2632, 3, 2, 2, 2, 2632, 183,
	3, 2, 2, 2, 2633, 2631, 3, 2, 2, 2, 2634, 2636, 5, 1034, 518, 2, 2635,
	2637, 5, 186, 94, 2, 2636, 2635, 3, 2, 2, 2, 2636, 2637, 3, 2, 2, 2, 2637,
	185, 3, 2, 2, 2, 2638, 2639, 9, 8, 2, 2, 2639, 2640, 5, 1032, 517, 2, 2640,
	187, 3, 2, 2, 2, 2641, 2643, 5, 190, 96, 2, 2642, 2641, 3, 2, 2, 2, 2642,
	2643, 3, 2, 2, 2, 2643, 2645, 3, 2, 2, 2, 2644, 2646, 7, 287, 2, 2, 2645,
	2644, 3, 2, 2, 2, 2645, 2646, 3, 2, 2, 2, 2646, 2647, 3, 2, 2, 2, 2647,
	2648, 7, 128, 2, 2, 2648, 2649, 5, 1122, 562, 2, 2649, 2650, 7, 48, 2,
	2, 2650, 189, 3, 2, 2, 2, 2651, 2652, 9, 9, 2, 2, 2652, 191, 3, 2, 2, 2,
	2653, 2655, 7, 287, 2, 2, 2654, 2653, 3, 2, 2, 2, 2654, 2655, 3, 2, 2,
	2, 2655, 2656, 3, 2, 2, 2, 2656, 2657, 7, 128, 2, 2, 2657, 2658, 5, 250,
	126, 2, 2658, 2659, 5, 1122, 562, 2, 2659, 2660, 5, 168, 85, 2, 2660, 193,
	3, 2, 2, 2, 2661, 2666, 5, 1166, 584, 2, 2662, 2663, 7, 38, 2, 2, 2663,
	2665, 5, 1166, 584, 2, 2664, 2662, 3, 2, 2, 2, 2665, 2668, 3, 2, 2, 2,
	2666, 2664, 3, 2, 2, 2, 2666, 2667, 3, 2, 2, 2, 2667, 195, 3, 2, 2, 2,
	2668, 2666, 3, 2, 2, 2, 2669, 2674, 5, 198, 100, 2, 2670, 2674, 5, 200,
	101, 2, 2671, 2674, 5, 226, 114, 2, 2672, 2674, 5, 48, 25, 2, 2673, 2669,
	3, 2, 2, 2, 2673, 2670, 3, 2, 2, 2, 2673, 2671, 3, 2, 2, 2, 2673, 2672,
	3, 2, 2, 2, 2674, 197, 3, 2, 2, 2, 2675, 2692, 5, 230, 116, 2, 2676, 2692,
	5, 220, 111, 2, 2677, 2692, 5, 378, 190, 2, 2678, 2692, 5, 360, 181, 2,
	2679, 2692, 5, 34, 18, 2, 2680, 2692, 5, 366, 184, 2, 2681, 2692, 5, 192,
	97, 2, 2682, 2692, 5, 36, 19, 2, 2683, 2692, 5, 164, 83, 2, 2684, 2687,
	5, 204, 103, 2, 2685, 2687, 5, 206, 104, 2, 2686, 2684, 3, 2, 2, 2, 2686,
	2685, 3, 2, 2, 2, 2686, 2687, 3, 2, 2, 2, 2687, 2688, 3, 2, 2, 2, 2688,
	2692, 7, 48, 2, 2, 2689, 2692, 5, 496, 249, 2, 2690, 2692, 5, 436, 219,
	2, 2691, 2675, 3, 2, 2, 2, 2691, 2676, 3, 2, 2, 2, 2691, 2677, 3, 2, 2,
	2, 2691, 2678, 3, 2, 2, 2, 2691, 2679, 3, 2, 2, 2, 2691, 2680, 3, 2, 2,
	2, 2691, 2681, 3, 2, 2, 2, 2691, 2682, 3, 2, 2, 2, 2691, 2683, 3, 2, 2,
	2, 2691, 2686, 3, 2, 2, 2, 2691, 2689, 3, 2, 2, 2, 2691, 2690, 3, 2, 2,
	2, 2692, 199, 3, 2, 2, 2, 2693, 2694, 7, 241, 2, 2, 2694, 2698, 7, 48,
	2, 2, 2695, 2697, 5, 202, 102, 2, 2696, 2695, 3, 2, 2, 2, 2697, 2700, 3,
	2, 2, 2, 2698, 2696, 3, 2, 2, 2, 2698, 2699, 3, 2, 2, 2, 2699, 2701, 3,
	2, 2, 2, 2700, 2698, 3, 2, 2, 2, 2701, 2702, 7, 156, 2, 2, 2702, 201, 3,
	2, 2, 2, 2703, 2710, 5, 378, 190, 2, 2704, 2710, 5, 360, 181, 2, 2705,
	2710, 5, 36, 19, 2, 2706, 2710, 5, 496, 249, 2, 2707, 2710, 5, 164, 83,
	2, 2708, 2710, 7, 48, 2, 2, 2709, 2703, 3, 2, 2, 2, 2709, 2704, 3, 2, 2,
	2, 2709, 2705, 3, 2, 2, 2, 2709, 2706, 3, 2, 2, 2, 2709, 2707, 3, 2, 2,
	2, 2709, 2708, 3, 2, 2, 2, 2710, 203, 3, 2, 2, 2, 2711, 2717, 7, 210, 2,
	2, 2712, 2713, 5, 242, 122, 2, 2713, 2714, 5, 304, 153, 2, 2714, 2718,
	3, 2, 2, 2, 2715, 2716, 7, 315, 2, 2, 2716, 2718, 5, 314, 158, 2, 2717,
	2712, 3, 2, 2, 2, 2717, 2715, 3, 2, 2, 2, 2718, 205, 3, 2, 2, 2, 2719,
	2725, 7, 236, 2, 2, 2720, 2721, 5, 242, 122, 2, 2721, 2722, 5, 304, 153,
	2, 2722, 2726, 3, 2, 2, 2, 2723, 2724, 7, 315, 2, 2, 2724, 2726, 5, 314,
	158, 2, 2725, 2720, 3, 2, 2, 2, 2725, 2723, 3, 2, 2, 2, 2726, 207, 3, 2,
	2, 2, 2727, 2729, 7, 286, 2, 2, 2728, 2730, 5, 348, 175, 2, 2729, 2728,
	3, 2, 2, 2, 2729, 2730, 3, 2, 2, 2, 2730, 2731, 3, 2, 2, 2, 2731, 2732,
	5, 310, 156, 2, 2732, 2733, 7, 48, 2, 2, 2733, 209, 3, 2, 2, 2, 2734, 2735,
	7, 193, 2, 2, 2735, 2736, 5, 264, 133, 2, 2736, 2737, 5, 306, 154, 2, 2737,
	211, 3, 2, 2, 2, 2738, 2745, 7, 194, 2, 2, 2739, 2740, 5, 264, 133, 2,
	2740, 2741, 5, 306, 154, 2, 2741, 2746, 3, 2, 2, 2, 2742, 2743, 5, 266,
	134, 2, 2743, 2744, 5, 318, 160, 2, 2744, 2746, 3, 2, 2, 2, 2745, 2739,
	3, 2, 2, 2, 2745, 2742, 3, 2, 2, 2, 2746, 213, 3, 2, 2, 2, 2747, 2754,
	7, 233, 2, 2, 2748, 2749, 5, 264, 133, 2, 2749, 2750, 5, 306, 154, 2, 2750,
	2755, 3, 2, 2, 2, 2751, 2752, 5, 266, 134, 2, 2752, 2753, 5, 320, 161,
	2, 2753, 2755, 3, 2, 2, 2, 2754, 2748, 3, 2, 2, 2, 2754, 2751, 3, 2, 2,
	2, 2755, 215, 3, 2, 2, 2, 2756, 2759, 5, 1170, 586, 2, 2757, 2758, 7, 39,
	2, 2, 2758, 2760, 5, 1186, 594, 2, 2759, 2757, 3, 2, 2, 2, 2759, 2760,
	3, 2, 2, 2, 2760, 2761, 3, 2, 2, 2, 2761, 2762, 5, 300, 151, 2, 2762, 217,
	3, 2, 2, 2, 2763, 2764, 7, 259, 2, 2, 2764, 2765, 5, 266, 134, 2, 2765,
	2766, 5, 318, 160, 2, 2766, 219, 3, 2, 2, 2, 2767, 2769, 7, 127, 2, 2,
	2768, 2767, 3, 2, 2, 2, 2768, 2769, 3, 2, 2, 2, 2769, 2771, 3, 2, 2, 2,
	2770, 2772, 7, 327, 2, 2, 2771, 2770, 3, 2, 2, 2, 2771, 2772, 3, 2, 2,
	2, 2772, 2774, 3, 2, 2, 2, 2773, 2775, 5, 236, 119, 2, 2774, 2773, 3, 2,
	2, 2, 2774, 2775, 3, 2, 2, 2, 2775, 2776, 3, 2, 2, 2, 2776, 2777, 5, 242,
	122, 2, 2777, 2778, 5, 316, 159, 2, 2778, 2779, 7, 48, 2, 2, 2779, 2784,
	3, 2, 2, 2, 2780, 2784, 5, 232, 117, 2, 2781, 2784, 5, 222, 112, 2, 2782,
	2784, 5, 234, 118, 2, 2783, 2768, 3, 2, 2, 2, 2783, 2780, 3, 2, 2, 2, 2783,
	2781, 3, 2, 2, 2, 2783, 2782, 3, 2, 2, 2, 2784, 221, 3, 2, 2, 2, 2785,
	2786, 7, 189, 2, 2, 2786, 2791, 5, 224, 113, 2, 2787, 2788, 7, 38, 2, 2,
	2788, 2790, 5, 224, 113, 2, 2789, 2787, 3, 2, 2, 2, 2790, 2793, 3, 2, 2,
	2, 2791, 2789, 3, 2, 2, 2, 2791, 2792, 3, 2, 2, 2, 2792, 2794, 3, 2, 2,
	2, 2793, 2791, 3, 2, 2, 2, 2794, 2795, 7, 48, 2, 2, 2795, 223, 3, 2, 2,
	2, 2796, 2797, 5, 1196, 599, 2, 2797, 2800, 7, 46, 2, 2, 2798, 2801, 5,
	1166, 584, 2, 2799, 2801, 7, 32, 2, 2, 2800, 2798, 3, 2, 2, 2, 2800, 2799,
	3, 2, 2, 2, 2801, 225, 3, 2, 2, 2, 2802, 2812, 7, 165, 2, 2, 2803, 2813,
	7, 35, 2, 2, 2804, 2809, 5, 224, 113, 2, 2805, 2806, 7, 38, 2, 2, 2806,
	2808, 5, 224, 113, 2, 2807, 2805, 3, 2, 2, 2, 2808, 2811, 3, 2, 2, 2, 2809,
	2807, 3, 2, 2, 2, 2809, 2810, 3, 2, 2, 2, 2810, 2813, 3, 2, 2, 2, 2811,
	2809, 3, 2, 2, 2, 2812, 2803, 3, 2, 2, 2, 2812, 2804, 3, 2, 2, 2, 2813,
	2814, 3, 2, 2, 2, 2814, 2815, 7, 48, 2, 2, 2815, 227, 3, 2, 2, 2, 2816,
	2817, 7, 178, 2, 2, 2817, 2818, 5, 298, 150, 2, 2818, 2819, 7, 48, 2, 2,
	2819, 229, 3, 2, 2, 2, 2820, 2823, 5, 262, 132, 2, 2821, 2824, 5, 282,
	142, 2, 2822, 2824, 5, 288, 145, 2, 2823, 2821, 3, 2, 2, 2, 2823, 2822,
	3, 2, 2, 2, 2823, 2824, 3, 2, 2, 2, 2824, 2826, 3, 2, 2, 2, 2825, 2827,
	9, 10, 2, 2, 2826, 2825, 3, 2, 2, 2, 2826, 2827, 3, 2, 2, 2, 2827, 2828,
	3, 2, 2, 2, 2828, 2830, 5, 242, 122, 2, 2829, 2831, 5, 290, 146, 2, 2830,
	2829, 3, 2, 2, 2, 2830, 2831, 3, 2, 2, 2, 2831, 2832, 3, 2, 2, 2, 2832,
	2833, 5, 302, 152, 2, 2833, 2834, 7, 48, 2, 2, 2834, 2868, 3, 2, 2, 2,
	2835, 2837, 5, 1192, 597, 2, 2836, 2838, 5, 732, 367, 2, 2837, 2836, 3,
	2, 2, 2, 2837, 2838, 3, 2, 2, 2, 2838, 2839, 3, 2, 2, 2, 2839, 2840, 5,
	302, 152, 2, 2840, 2841, 7, 48, 2, 2, 2841, 2868, 3, 2, 2, 2, 2842, 2843,
	7, 199, 2, 2, 2843, 2846, 5, 244, 123, 2, 2844, 2845, 7, 11, 2, 2, 2845,
	2847, 5, 294, 148, 2, 2846, 2844, 3, 2, 2, 2, 2846, 2847, 3, 2, 2, 2, 2847,
	2848, 3, 2, 2, 2, 2848, 2852, 5, 1190, 596, 2, 2849, 2851, 5, 346, 174,
	2, 2850, 2849, 3, 2, 2, 2, 2851, 2854, 3, 2, 2, 2, 2852, 2850, 3, 2, 2,
	2, 2852, 2853, 3, 2, 2, 2, 2853, 2863, 3, 2, 2, 2, 2854, 2852, 3, 2, 2,
	2, 2855, 2856, 7, 38, 2, 2, 2856, 2860, 5, 1190, 596, 2, 2857, 2859, 5,
	346, 174, 2, 2858, 2857, 3, 2, 2, 2, 2859, 2862, 3, 2, 2, 2, 2860, 2858,
	3, 2, 2, 2, 2860, 2861, 3, 2, 2, 2, 2861, 2864, 3, 2, 2, 2, 2862, 2860,
	3, 2, 2, 2, 2863, 2855, 3, 2, 2, 2, 2863, 2864, 3, 2, 2, 2, 2864, 2865,
	3, 2, 2, 2, 2865, 2866, 7, 48, 2, 2, 2866, 2868, 3, 2, 2, 2, 2867, 2820,
	3, 2, 2, 2, 2867, 2835, 3, 2, 2, 2, 2867, 2842, 3, 2, 2, 2, 2868, 231,
	3, 2, 2, 2, 2869, 2870, 7, 317, 2, 2, 2870, 2871, 5, 240, 121, 2, 2871,
	2875, 5, 1244, 623, 2, 2872, 2874, 5, 352, 177, 2, 2873, 2872, 3, 2, 2,
	2, 2874, 2877, 3, 2, 2, 2, 2875, 2873, 3, 2, 2, 2, 2875, 2876, 3, 2, 2,
	2, 2876, 2878, 3, 2, 2, 2, 2877, 2875, 3, 2, 2, 2, 2878, 2879, 7, 48, 2,
	2, 2879, 2901, 3, 2, 2, 2, 2880, 2881, 7, 317, 2, 2, 2881, 2882, 5, 1172,
	587, 2, 2882, 2883, 5, 1068, 535, 2, 2883, 2884, 7, 39, 2, 2, 2884, 2885,
	5, 1244, 623, 2, 2885, 2886, 5, 1244, 623, 2, 2886, 2887, 7, 48, 2, 2,
	2887, 2901, 3, 2, 2, 2, 2888, 2895, 7, 317, 2, 2, 2889, 2896, 7, 161, 2,
	2, 2890, 2896, 7, 293, 2, 2, 2891, 2896, 7, 318, 2, 2, 2892, 2896, 7, 123,
	2, 2, 2893, 2894, 7, 200, 2, 2, 2894, 2896, 7, 123, 2, 2, 2895, 2889, 3,
	2, 2, 2, 2895, 2890, 3, 2, 2, 2, 2895, 2891, 3, 2, 2, 2, 2895, 2892, 3,
	2, 2, 2, 2895, 2893, 3, 2, 2, 2, 2895, 2896, 3, 2, 2, 2, 2896, 2897, 3,
	2, 2, 2, 2897, 2898, 5, 1244, 623, 2, 2898, 2899, 7, 48, 2, 2, 2899, 2901,
	3, 2, 2, 2, 2900, 2869, 3, 2, 2, 2, 2900, 2880, 3, 2, 2, 2, 2900, 2888,
	3, 2, 2, 2, 2901, 233, 3, 2, 2, 2, 2902, 2903, 7, 221, 2, 2, 2903, 2904,
	5, 240, 121, 2, 2904, 2911, 5, 1192, 597, 2, 2905, 2908, 7, 340, 2, 2,
	2906, 2909, 5, 1198, 600, 2, 2907, 2909, 5, 250, 126, 2, 2908, 2906, 3,
	2, 2, 2, 2908, 2907, 3, 2, 2, 2, 2908, 2909, 3, 2, 2, 2, 2909, 2910, 3,
	2, 2, 2, 2910, 2912, 5, 1240, 621, 2, 2911, 2905, 3, 2, 2, 2, 2911, 2912,
	3, 2, 2, 2, 2912, 2913, 3, 2, 2, 2, 2913, 2914, 7, 48, 2, 2, 2914, 2925,
	3, 2, 2, 2, 2915, 2918, 7, 221, 2, 2, 2916, 2919, 5, 1198, 600, 2, 2917,
	2919, 5, 250, 126, 2, 2918, 2916, 3, 2, 2, 2, 2918, 2917, 3, 2, 2, 2, 2918,
	2919, 3, 2, 2, 2, 2919, 2920, 3, 2, 2, 2, 2920, 2921, 5, 1192, 597, 2,
	2921, 2922, 5, 1192, 597, 2, 2922, 2923, 7, 48, 2, 2, 2923, 2925, 3, 2,
	2, 2, 2924, 2902, 3, 2, 2, 2, 2924, 2915, 3, 2, 2, 2, 2925, 235, 3, 2,
	2, 2, 2926, 2927, 9, 11, 2, 2, 2927, 237, 3, 2, 2, 2, 2928, 2934, 5, 272,
	137, 2, 2929, 2934, 5, 1048, 525, 2, 2930, 2934, 5, 270, 136, 2, 2931,
	2934, 7, 289, 2, 2, 2932, 2934, 7, 127, 2, 2, 2933, 2928, 3, 2, 2, 2, 2933,
	2929, 3, 2, 2, 2, 2933, 2930, 3, 2, 2, 2, 2933, 2931, 3, 2, 2, 2, 2933,
	2932, 3, 2, 2, 2, 2934, 239, 3, 2, 2, 2, 2935, 2937, 5, 258, 130, 2, 2936,
	2938, 5, 270, 136, 2, 2937, 2936, 3, 2, 2, 2, 2937, 2938, 3, 2, 2, 2, 2938,
	2942, 3, 2, 2, 2, 2939, 2941, 5, 348, 175, 2, 2940, 2939, 3, 2, 2, 2, 2941,
	2944, 3, 2, 2, 2, 2942, 2940, 3, 2, 2, 2, 2942, 2943, 3, 2, 2, 2, 2943,
	3022, 3, 2, 2, 2, 2944, 2942, 3, 2, 2, 2, 2945, 2947, 5, 256, 129, 2, 2946,
	2948, 5, 270, 136, 2, 2947, 2946, 3, 2, 2, 2, 2947, 2948, 3, 2, 2, 2, 2948,
	3022, 3, 2, 2, 2, 2949, 3022, 5, 260, 131, 2, 2950, 2955, 5, 278, 140,
	2, 2951, 2953, 7, 235, 2, 2, 2952, 2954, 5, 270, 136, 2, 2953, 2952, 3,
	2, 2, 2, 2953, 2954, 3, 2, 2, 2, 2954, 2956, 3, 2, 2, 2, 2955, 2951, 3,
	2, 2, 2, 2955, 2956, 3, 2, 2, 2, 2956, 2957, 3, 2, 2, 2, 2957, 2958, 7,
	58, 2, 2, 2958, 2962, 5, 274, 138, 2, 2959, 2961, 5, 274, 138, 2, 2960,
	2959, 3, 2, 2, 2, 2961, 2964, 3, 2, 2, 2, 2962, 2960, 3, 2, 2, 2, 2962,
	2963, 3, 2, 2, 2, 2963, 2965, 3, 2, 2, 2, 2964, 2962, 3, 2, 2, 2, 2965,
	2969, 7, 64, 2, 2, 2966, 2968, 5, 348, 175, 2, 2967, 2966, 3, 2, 2, 2,
	2968, 2971, 3, 2, 2, 2, 2969, 2967, 3, 2, 2, 2, 2969, 2970, 3, 2, 2, 2,
	2970, 3022, 3, 2, 2, 2, 2971, 2969, 3, 2, 2, 2, 2972, 2974, 7, 161, 2,
	2, 2973, 2975, 5, 246, 124, 2, 2974, 2973, 3, 2, 2, 2, 2974, 2975, 3, 2,
	2, 2, 2975, 2976, 3, 2, 2, 2, 2976, 2977, 7, 58, 2, 2, 2977, 2982, 5, 248,
	125, 2, 2978, 2979, 7, 38, 2, 2, 2979, 2981, 5, 248, 125, 2, 2980, 2978,
	3, 2, 2, 2, 2981, 2984, 3, 2, 2, 2, 2982, 2980, 3, 2, 2, 2, 2982, 2983,
	3, 2, 2, 2, 2983, 2985, 3, 2, 2, 2, 2984, 2982, 3, 2, 2, 2, 2985, 2989,
	7, 64, 2, 2, 2986, 2988, 5, 348, 175, 2, 2987, 2986, 3, 2, 2, 2, 2988,
	2991, 3, 2, 2, 2, 2989, 2987, 3, 2, 2, 2, 2989, 2990, 3, 2, 2, 2, 2990,
	3022, 3, 2, 2, 2, 2991, 2989, 3, 2, 2, 2, 2992, 3022, 7, 289, 2, 2, 2993,
	3022, 7, 121, 2, 2, 2994, 2996, 7, 329, 2, 2, 2995, 2997, 7, 200, 2, 2,
	2996, 2995, 3, 2, 2, 2, 2996, 2997, 3, 2, 2, 2, 2997, 2998, 3, 2, 2, 2,
	2998, 3000, 5, 1170, 586, 2, 2999, 3001, 5, 628, 315, 2, 3000, 2999, 3,
	2, 2, 2, 3000, 3001, 3, 2, 2, 2, 3001, 3004, 3, 2, 2, 2, 3002, 3003, 7,
	39, 2, 2, 3003, 3005, 5, 1186, 594, 2, 3004, 3002, 3, 2, 2, 2, 3004, 3005,
	3, 2, 2, 2, 3005, 3022, 3, 2, 2, 2, 3006, 3009, 5, 250, 126, 2, 3007, 3009,
	5, 1198, 600, 2, 3008, 3006, 3, 2, 2, 2, 3008, 3007, 3, 2, 2, 2, 3008,
	3009, 3, 2, 2, 2, 3009, 3010, 3, 2, 2, 2, 3010, 3014, 5, 1244, 623, 2,
	3011, 3013, 5, 348, 175, 2, 3012, 3011, 3, 2, 2, 2, 3013, 3016, 3, 2, 2,
	2, 3014, 3012, 3, 2, 2, 2, 3014, 3015, 3, 2, 2, 2, 3015, 3022, 3, 2, 2,
	2, 3016, 3014, 3, 2, 2, 2, 3017, 3022, 5, 252, 127, 2, 3018, 3022, 7, 162,
	2, 2, 3019, 3022, 5, 1212, 607, 2, 3020, 3022, 5, 280, 141, 2, 3021, 2935,
	3, 2, 2, 2, 3021, 2945, 3, 2, 2, 2, 3021, 2949, 3, 2, 2, 2, 3021, 2950,
	3, 2, 2, 2, 3021, 2972, 3, 2, 2, 2, 3021, 2992, 3, 2, 2, 2, 3021, 2993,
	3, 2, 2, 2, 3021, 2994, 3, 2, 2, 2, 3021, 3008, 3, 2, 2, 2, 3021, 3017,
	3, 2, 2, 2, 3021, 3018, 3, 2, 2, 2, 3021, 3019, 3, 2, 2, 2, 3021, 3020,
	3, 2, 2, 2, 3022, 241, 3, 2, 2, 2, 3023, 3026, 5, 240, 121, 2, 3024, 3026,
	5, 244, 123, 2, 3025, 3023, 3, 2, 2, 2, 3025, 3024, 3, 2, 2, 2, 3026, 243,
	3, 2, 2, 2, 3027, 3029, 5, 270, 136, 2, 3028, 3027, 3, 2, 2, 2, 3028, 3029,
	3, 2, 2, 2, 3029, 3033, 3, 2, 2, 2, 3030, 3032, 5, 348, 175, 2, 3031, 3030,
	3, 2, 2, 2, 3032, 3035, 3, 2, 2, 2, 3033, 3031, 3, 2, 2, 2, 3033, 3034,
	3, 2, 2, 2, 3034, 245, 3, 2, 2, 2, 3035, 3033, 3, 2, 2, 2, 3036, 3038,
	5, 256, 129, 2, 3037, 3039, 5, 270, 136, 2, 3038, 3037, 3, 2, 2, 2, 3038,
	3039, 3, 2, 2, 2, 3039, 3052, 3, 2, 2, 2, 3040, 3042, 5, 258, 130, 2, 3041,
	3043, 5, 270, 136, 2, 3042, 3041, 3, 2, 2, 2, 3042, 3043, 3, 2, 2, 2, 3043,
	3045, 3, 2, 2, 2, 3044, 3046, 5, 348, 175, 2, 3045, 3044, 3, 2, 2, 2, 3045,
	3046, 3, 2, 2, 2, 3046, 3052, 3, 2, 2, 2, 3047, 3049, 5, 1244, 623, 2,
	3048, 3050, 5, 348, 175, 2, 3049, 3048, 3, 2, 2, 2, 3049, 3050, 3, 2, 2,
	2, 3050, 3052, 3, 2, 2, 2, 3051, 3036, 3, 2, 2, 2, 3051, 3040, 3, 2, 2,
	2, 3051, 3047, 3, 2, 2, 2, 3052, 247, 3, 2, 2, 2, 3053, 3061, 5, 1134,
	568, 2, 3054, 3055, 7, 52, 2, 2, 3055, 3058, 9, 12, 2, 2, 3056, 3057, 7,
	43, 2, 2, 3057, 3059, 9, 12, 2, 2, 3058, 3056, 3, 2, 2, 2, 3058, 3059,
	3, 2, 2, 2, 3059, 3060, 3, 2, 2, 2, 3060, 3062, 7, 54, 2, 2, 3061, 3054,
	3, 2, 2, 2, 3061, 3062, 3, 2, 2, 2, 3062, 3065, 3, 2, 2, 2, 3063, 3064,
	7, 80, 2, 2, 3064, 3066, 5, 1016, 509, 2, 3065, 3063, 3, 2, 2, 2, 3065,
	3066, 3, 2, 2, 2, 3066, 249, 3, 2, 2, 2, 3067, 3068, 5, 252, 127, 2, 3068,
	3069, 7, 46, 2, 2, 3069, 251, 3, 2, 2, 2, 3070, 3072, 5, 1210, 606, 2,
	3071, 3073, 5, 628, 315, 2, 3072, 3071, 3, 2, 2, 2, 3072, 3073, 3, 2, 2,
	2, 3073, 3081, 3, 2, 2, 2, 3074, 3075, 7, 46, 2, 2, 3075, 3077, 5, 1112,
	557, 2, 3076, 3078, 5, 628, 315, 2, 3077, 3076, 3, 2, 2, 2, 3077, 3078,
	3, 2, 2, 2, 3078, 3080, 3, 2, 2, 2, 3079, 3074, 3, 2, 2, 2, 3080, 3083,
	3, 2, 2, 2, 3081, 3079, 3, 2, 2, 2, 3081, 3082, 3, 2, 2, 2, 3082, 253,
	3, 2, 2, 2, 3083, 3081, 3, 2, 2, 2, 3084, 3087, 5, 258, 130, 2, 3085, 3087,
	5, 256, 129, 2, 3086, 3084, 3, 2, 2, 2, 3086, 3085, 3, 2, 2, 2, 3087, 255,
	3, 2, 2, 2, 3088, 3089, 9, 13, 2, 2, 3089, 257, 3, 2, 2, 2, 3090, 3091,
	9, 14, 2, 2, 3091, 259, 3, 2, 2, 2, 3092, 3093, 9, 15, 2, 2, 3093, 261,
	3, 2, 2, 2, 3094, 3095, 9, 16, 2, 2, 3095, 263, 3, 2, 2, 2, 3096, 3098,
	5, 262, 132, 2, 3097, 3096, 3, 2, 2, 2, 3097, 3098, 3, 2, 2, 2, 3098, 3099,
	3, 2, 2, 2, 3099, 3104, 5, 242, 122, 2, 3100, 3104, 5, 1192, 597, 2, 3101,
	3102, 7, 199, 2, 2, 3102, 3104, 5, 244, 123, 2, 3103, 3097, 3, 2, 2, 2,
	3103, 3100, 3, 2, 2, 2, 3103, 3101, 3, 2, 2, 2, 3104, 265, 3, 2, 2, 2,
	3105, 3106, 5, 268, 135, 2, 3106, 267, 3, 2, 2, 2, 3107, 3111, 5, 240,
	121, 2, 3108, 3109, 7, 327, 2, 2, 3109, 3111, 5, 242, 122, 2, 3110, 3107,
	3, 2, 2, 2, 3110, 3108, 3, 2, 2, 2, 3111, 269, 3, 2, 2, 2, 3112, 3113,
	9, 17, 2, 2, 3113, 271, 3, 2, 2, 2, 3114, 3119, 5, 254, 128, 2, 3115, 3119,
	5, 260, 131, 2, 3116, 3119, 5, 1230, 616, 2, 3117, 3119, 5, 1228, 615,
	2, 3118, 3114, 3, 2, 2, 2, 3118, 3115, 3, 2, 2, 2, 3118, 3116, 3, 2, 2,
	2, 3118, 3117, 3, 2, 2, 2, 3119, 273, 3, 2, 2, 2, 3120, 3122, 5, 1094,
	548, 2, 3121, 3120, 3, 2, 2, 2, 3122, 3125, 3, 2, 2, 2, 3123, 3121, 3,
	2, 2, 2, 3123, 3124, 3, 2, 2, 2, 3124, 3127, 3, 2, 2, 2, 3125, 3123, 3,
	2, 2, 2, 3126, 3128, 5, 158, 80, 2, 3127, 3126, 3, 2, 2, 2, 3127, 3128,
	3, 2, 2, 2, 3128, 3129, 3, 2, 2, 2, 3129, 3130, 5, 276, 139, 2, 3130, 3131,
	5, 316, 159, 2, 3131, 3132, 7, 48, 2, 2, 3132, 275, 3, 2, 2, 2, 3133, 3136,
	5, 240, 121, 2, 3134, 3136, 7, 330, 2, 2, 3135, 3133, 3, 2, 2, 2, 3135,
	3134, 3, 2, 2, 2, 3136, 277, 3, 2, 2, 2, 3137, 3143, 7, 293, 2, 2, 3138,
	3140, 7, 318, 2, 2, 3139, 3141, 7, 299, 2, 2, 3140, 3139, 3, 2, 2, 2, 3140,
	3141, 3, 2, 2, 2, 3141, 3143, 3, 2, 2, 2, 3142, 3137, 3, 2, 2, 2, 3142,
	3138, 3, 2, 2, 2, 3143, 279, 3, 2, 2, 2, 3144, 3145, 7, 315, 2, 2, 3145,
	3148, 7, 29, 2, 2, 3146, 3149, 5, 1032, 517, 2, 3147, 3149, 5, 240, 121,
	2, 3148, 3146, 3, 2, 2, 2, 3148, 3147, 3, 2, 2, 2, 3149, 3150, 3, 2, 2,
	2, 3150, 3151, 7, 31, 2, 2, 3151, 281, 3, 2, 2, 2, 3152, 3153, 7, 29, 2,
	2, 3153, 3154, 5, 284, 143, 2, 3154, 3157, 7, 38, 2, 2, 3155, 3158, 5,
	286, 144, 2, 3156, 3158, 7, 181, 2, 2, 3157, 3155, 3, 2, 2, 2, 3157, 3156,
	3, 2, 2, 2, 3158, 3159, 3, 2, 2, 2, 3159, 3160, 7, 31, 2, 2, 3160, 3183,
	3, 2, 2, 2, 3161, 3162, 7, 29, 2, 2, 3162, 3163, 5, 286, 144, 2, 3163,
	3166, 7, 38, 2, 2, 3164, 3167, 5, 284, 143, 2, 3165, 3167, 7, 180, 2, 2,
	3166, 3164, 3, 2, 2, 2, 3166, 3165, 3, 2, 2, 2, 3167, 3168, 3, 2, 2, 2,
	3168, 3169, 7, 31, 2, 2, 3169, 3183, 3, 2, 2, 2, 3170, 3171, 7, 29, 2,
	2, 3171, 3172, 7, 180, 2, 2, 3172, 3173, 7, 38, 2, 2, 3173, 3174, 5, 286,
	144, 2, 3174, 3175, 7, 31, 2, 2, 3175, 3183, 3, 2, 2, 2, 3176, 3177, 7,
	29, 2, 2, 3177, 3178, 7, 181, 2, 2, 3178, 3179, 7, 38, 2, 2, 3179, 3180,
	5, 284, 143, 2, 3180, 3181, 7, 31, 2, 2, 3181, 3183, 3, 2, 2, 2, 3182,
	3152, 3, 2, 2, 2, 3182, 3161, 3, 2, 2, 2, 3182, 3170, 3, 2, 2, 2, 3182,
	3176, 3, 2, 2, 2, 3183, 283, 3, 2, 2, 2, 3184, 3185, 9, 18, 2, 2, 3185,
	285, 3, 2, 2, 2, 3186, 3187, 9, 19, 2, 2, 3187, 287, 3, 2, 2, 2, 3188,
	3189, 7, 29, 2, 2, 3189, 3190, 9, 20, 2, 2, 3190, 3191, 7, 31, 2, 2, 3191,
	289, 3, 2, 2, 2, 3192, 3206, 7, 11, 2, 2, 3193, 3207, 5, 294, 148, 2, 3194,
	3195, 7, 29, 2, 2, 3195, 3202, 5, 1036, 519, 2, 3196, 3197, 7, 38, 2, 2,
	3197, 3200, 5, 1036, 519, 2, 3198, 3199, 7, 38, 2, 2, 3199, 3201, 5, 1036,
	519, 2, 3200, 3198, 3, 2, 2, 2, 3200, 3201, 3, 2, 2, 2, 3201, 3203, 3,
	2, 2, 2, 3202, 3196, 3, 2, 2, 2, 3202, 3203, 3, 2, 2, 2, 3203, 3204, 3,
	2, 2, 2, 3204, 3205, 7, 31, 2, 2, 3205, 3207, 3, 2, 2, 2, 3206, 3193, 3,
	2, 2, 2, 3206, 3194, 3, 2, 2, 2, 3207, 291, 3, 2, 2, 2, 3208, 3218, 7,
	11, 2, 2, 3209, 3219, 5, 294, 148, 2, 3210, 3211, 7, 29, 2, 2, 3211, 3214,
	5, 1036, 519, 2, 3212, 3213, 7, 38, 2, 2, 3213, 3215, 5, 1036, 519, 2,
	3214, 3212, 3, 2, 2, 2, 3214, 3215, 3, 2, 2, 2, 3215, 3216, 3, 2, 2, 2,
	3216, 3217, 7, 31, 2, 2, 3217, 3219, 3, 2, 2, 2, 3218, 3209, 3, 2, 2, 2,
	3218, 3210, 3, 2, 2, 2, 3219, 293, 3, 2, 2, 2, 3220, 3226, 7, 353, 2, 2,
	3221, 3226, 7, 352, 2, 2, 3222, 3226, 5, 1216, 609, 2, 3223, 3226, 7, 347,
	2, 2, 3224, 3226, 7, 94, 2, 2, 3225, 3220, 3, 2, 2, 2, 3225, 3221, 3, 2,
	2, 2, 3225, 3222, 3, 2, 2, 2, 3225, 3223, 3, 2, 2, 2, 3225, 3224, 3, 2,
	2, 2, 3226, 295, 3, 2, 2, 2, 3227, 3232, 5, 322, 162, 2, 3228, 3229, 7,
	38, 2, 2, 3229, 3231, 5, 322, 162, 2, 3230, 3228, 3, 2, 2, 2, 3231, 3234,
	3, 2, 2, 2, 3232, 3230, 3, 2, 2, 2, 3232, 3233, 3, 2, 2, 2, 3233, 297,
	3, 2, 2, 2, 3234, 3232, 3, 2, 2, 2, 3235, 3240, 5, 1142, 572, 2, 3236,
	3237, 7, 38, 2, 2, 3237, 3239, 5, 1142, 572, 2, 3238, 3236, 3, 2, 2, 2,
	3239, 3242, 3, 2, 2, 2, 3240, 3238, 3, 2, 2, 2, 3240, 3241, 3, 2, 2, 2,
	3241, 299, 3, 2, 2, 2, 3242, 3240, 3, 2, 2, 2, 3243, 3247, 5, 1170, 586,
	2, 3244, 3246, 5, 346, 174, 2, 3245, 3244, 3, 2, 2, 2, 3246, 3249, 3, 2,
	2, 2, 3247, 3245, 3, 2, 2, 2, 3247, 3248, 3, 2, 2, 2, 3248, 3260, 3, 2,
	2, 2, 3249, 3247, 3, 2, 2, 2, 3250, 3251, 7, 38, 2, 2, 3251, 3255, 5, 1170,
	586, 2, 3252, 3254, 5, 346, 174, 2, 3253, 3252, 3, 2, 2, 2, 3254, 3257,
	3, 2, 2, 2, 3255, 3253, 3, 2, 2, 2, 3255, 3256, 3, 2, 2, 2, 3256, 3259,
	3, 2, 2, 2, 3257, 3255, 3, 2, 2, 2, 3258, 3250, 3, 2, 2, 2, 3259, 3262,
	3, 2, 2, 2, 3260, 3258, 3, 2, 2, 2, 3260, 3261, 3, 2, 2, 2, 3261, 301,
	3, 2, 2, 2, 3262, 3260, 3, 2, 2, 2, 3263, 3268, 5, 324, 163, 2, 3264, 3265,
	7, 38, 2, 2, 3265, 3267, 5, 324, 163, 2, 3266, 3264, 3, 2, 2, 2, 3267,
	3270, 3, 2, 2, 2, 3268, 3266, 3, 2, 2, 2, 3268, 3269, 3, 2, 2, 2, 3269,
	303, 3, 2, 2, 2, 3270, 3268, 3, 2, 2, 2, 3271, 3276, 5, 326, 164, 2, 3272,
	3273, 7, 38, 2, 2, 3273, 3275, 5, 326, 164, 2, 3274, 3272, 3, 2, 2, 2,
	3275, 3278, 3, 2, 2, 2, 3276, 3274, 3, 2, 2, 2, 3276, 3277, 3, 2, 2, 2,
	3277, 305, 3, 2, 2, 2, 3278, 3276, 3, 2, 2, 2, 3279, 3283, 5, 1202, 602,
	2, 3280, 3282, 5, 346, 174, 2, 3281, 3280, 3, 2, 2, 2, 3282, 3285, 3, 2,
	2, 2, 3283, 3281, 3, 2, 2, 2, 3283, 3284, 3, 2, 2, 2, 3284, 3296, 3, 2,
	2, 2, 3285, 3283, 3, 2, 2, 2, 3286, 3287, 7, 38, 2, 2, 3287, 3291, 5, 1202,
	602, 2, 3288, 3290, 5, 346, 174, 2, 3289, 3288, 3, 2, 2, 2, 3290, 3293,
	3, 2, 2, 2, 3291, 3289, 3, 2, 2, 2, 3291, 3292, 3, 2, 2, 2, 3292, 3295,
	3, 2, 2, 2, 3293, 3291, 3, 2, 2, 2, 3294, 3286, 3, 2, 2, 2, 3295, 3298,
	3, 2, 2, 2, 3296, 3294, 3, 2, 2, 2, 3296, 3297, 3, 2, 2, 2, 3297, 307,
	3, 2, 2, 2, 3298, 3296, 3, 2, 2, 2, 3299, 3304, 5, 1202, 602, 2, 3300,
	3301, 7, 38, 2, 2, 3301, 3303, 5, 1202, 602, 2, 3302, 3300, 3, 2, 2, 2,
	3303, 3306, 3, 2, 2, 2, 3304, 3302, 3, 2, 2, 2, 3304, 3305, 3, 2, 2, 2,
	3305, 309, 3, 2, 2, 2, 3306, 3304, 3, 2, 2, 2, 3307, 3312, 5, 328, 165,
	2, 3308, 3309, 7, 38, 2, 2, 3309, 3311, 5, 328, 165, 2, 3310, 3308, 3,
	2, 2, 2, 3311, 3314, 3, 2, 2, 2, 3312, 3310, 3, 2, 2, 2, 3312, 3313, 3,
	2, 2, 2, 3313, 311, 3, 2, 2, 2, 3314, 3312, 3, 2, 2, 2, 3315, 3319, 5,
	1202, 602, 2, 3316, 3318, 5, 352, 177, 2, 3317, 3316, 3, 2, 2, 2, 3318,
	3321, 3, 2, 2, 2, 3319, 3317, 3, 2, 2, 2, 3319, 3320, 3, 2, 2, 2, 3320,
	3324, 3, 2, 2, 2, 3321, 3319, 3, 2, 2, 2, 3322, 3323, 7, 80, 2, 2, 3323,
	3325, 5, 1032, 517, 2, 3324, 3322, 3, 2, 2, 2, 3324, 3325, 3, 2, 2, 2,
	3325, 3340, 3, 2, 2, 2, 3326, 3327, 7, 38, 2, 2, 3327, 3331, 5, 1202, 602,
	2, 3328, 3330, 5, 352, 177, 2, 3329, 3328, 3, 2, 2, 2, 3330, 3333, 3, 2,
	2, 2, 3331, 3329, 3, 2, 2, 2, 3331, 3332, 3, 2, 2, 2, 3332, 3336, 3, 2,
	2, 2, 3333, 3331, 3, 2, 2, 2, 3334, 3335, 7, 80, 2, 2, 3335, 3337, 5, 1032,
	517, 2, 3336, 3334, 3, 2, 2, 2, 3336, 3337, 3, 2, 2, 2, 3337, 3339, 3,
	2, 2, 2, 3338, 3326, 3, 2, 2, 2, 3339, 3342, 3, 2, 2, 2, 3340, 3338, 3,
	2, 2, 2, 3340, 3341, 3, 2, 2, 2, 3341, 313, 3, 2, 2, 2, 3342, 3340, 3,
	2, 2, 2, 3343, 3348, 5, 330, 166, 2, 3344, 3345, 7, 38, 2, 2, 3345, 3347,
	5, 330, 166, 2, 3346, 3344, 3, 2, 2, 2, 3347, 3350, 3, 2, 2, 2, 3348, 3346,
	3, 2, 2, 2, 3348, 3349, 3, 2, 2, 2, 3349, 315, 3, 2, 2, 2, 3350, 3348,
	3, 2, 2, 2, 3351, 3356, 5, 340, 171, 2, 3352, 3353, 7, 38, 2, 2, 3353,
	3355, 5, 340, 171, 2, 3354, 3352, 3, 2, 2, 2, 3355, 3358, 3, 2, 2, 2, 3356,
	3354, 3, 2, 2, 2, 3356, 3357, 3, 2, 2, 2, 3357, 317, 3, 2, 2, 2, 3358,
	3356, 3, 2, 2, 2, 3359, 3363, 5, 1246, 624, 2, 3360, 3362, 5, 352, 177,
	2, 3361, 3360, 3, 2, 2, 2, 3362, 3365, 3, 2, 2, 2, 3363, 3361, 3, 2, 2,
	2, 3363, 3364, 3, 2, 2, 2, 3364, 3376, 3, 2, 2, 2, 3365, 3363, 3, 2, 2,
	2, 3366, 3367, 7, 38, 2, 2, 3367, 3371, 5, 1246, 624, 2, 3368, 3370, 5,
	352, 177, 2, 3369, 3368, 3, 2, 2, 2, 3370, 3373, 3, 2, 2, 2, 3371, 3369,
	3, 2, 2, 2, 3371, 3372, 3, 2, 2, 2, 3372, 3375, 3, 2, 2, 2, 3373, 3371,
	3, 2, 2, 2, 3374, 3366, 3, 2, 2, 2, 3375, 3378, 3, 2, 2, 2, 3376, 3374,
	3, 2, 2, 2, 3376, 3377, 3, 2, 2, 2, 3377, 319, 3, 2, 2, 2, 3378, 3376,
	3, 2, 2, 2, 3379, 3383, 5, 1202, 602, 2, 3380, 3382, 5, 352, 177, 2, 3381,
	3380, 3, 2, 2, 2, 3382, 3385, 3, 2, 2, 2, 3383, 3381, 3, 2, 2, 2, 3383,
	3384, 3, 2, 2, 2, 3384, 3388, 3, 2, 2, 2, 3385, 3383, 3, 2, 2, 2, 3386,
	3387, 7, 80, 2, 2, 3387, 3389, 5, 1016, 509, 2, 3388, 3386, 3, 2, 2, 2,
	3388, 3389, 3, 2, 2, 2, 3389, 3404, 3, 2, 2, 2, 3390, 3391, 7, 38, 2, 2,
	3391, 3395, 5, 1202, 602, 2, 3392, 3394, 5, 352, 177, 2, 3393, 3392, 3,
	2, 2, 2, 3394, 3397, 3, 2, 2, 2, 3395, 3393, 3, 2, 2, 2, 3395, 3396, 3,
	2, 2, 2, 3396, 3400, 3, 2, 2, 2, 3397, 3395, 3, 2, 2, 2, 3398, 3399, 7,
	80, 2, 2, 3399, 3401, 5, 1016, 509, 2, 3400, 3398, 3, 2, 2, 2, 3400, 3401,
	3, 2, 2, 2, 3401, 3403, 3, 2, 2, 2, 3402, 3390, 3, 2, 2, 2, 3403, 3406,
	3, 2, 2, 2, 3404, 3402, 3, 2, 2, 2, 3404, 3405, 3, 2, 2, 2, 3405, 321,
	3, 2, 2, 2, 3406, 3404, 3, 2, 2, 2, 3407, 3408, 5, 1154, 578, 2, 3408,
	3409, 7, 80, 2, 2, 3409, 3410, 5, 1018, 510, 2, 3410, 323, 3, 2, 2, 2,
	3411, 3415, 5, 1190, 596, 2, 3412, 3414, 5, 346, 174, 2, 3413, 3412, 3,
	2, 2, 2, 3414, 3417, 3, 2, 2, 2, 3415, 3413, 3, 2, 2, 2, 3415, 3416, 3,
	2, 2, 2, 3416, 3420, 3, 2, 2, 2, 3417, 3415, 3, 2, 2, 2, 3418, 3419, 7,
	80, 2, 2, 3419, 3421, 5, 1032, 517, 2, 3420, 3418, 3, 2, 2, 2, 3420, 3421,
	3, 2, 2, 2, 3421, 325, 3, 2, 2, 2, 3422, 3426, 5, 1200, 601, 2, 3423, 3425,
	5, 346, 174, 2, 3424, 3423, 3, 2, 2, 2, 3425, 3428, 3, 2, 2, 2, 3426, 3424,
	3, 2, 2, 2, 3426, 3427, 3, 2, 2, 2, 3427, 3431, 3, 2, 2, 2, 3428, 3426,
	3, 2, 2, 2, 3429, 3430, 7, 80, 2, 2, 3430, 3432, 5, 1020, 511, 2, 3431,
	3429, 3, 2, 2, 2, 3431, 3432, 3, 2, 2, 2, 3432, 327, 3, 2, 2, 2, 3433,
	3434, 5, 1236, 619, 2, 3434, 3435, 7, 80, 2, 2, 3435, 3436, 5, 1018, 510,
	2, 3436, 3439, 3, 2, 2, 2, 3437, 3439, 5, 332, 167, 2, 3438, 3433, 3, 2,
	2, 2, 3438, 3437, 3, 2, 2, 2, 3439, 329, 3, 2, 2, 2, 3440, 3443, 5, 1244,
	623, 2, 3441, 3442, 7, 80, 2, 2, 3442, 3444, 5, 240, 121, 2, 3443, 3441,
	3, 2, 2, 2, 3443, 3444, 3, 2, 2, 2, 3444, 331, 3, 2, 2, 2, 3445, 3450,
	7, 237, 2, 2, 3446, 3447, 5, 906, 454, 2, 3447, 3448, 7, 16, 2, 2, 3448,
	3449, 5, 908, 455, 2, 3449, 3451, 3, 2, 2, 2, 3450, 3446, 3, 2, 2, 2, 3450,
	3451, 3, 2, 2, 2, 3451, 3452, 3, 2, 2, 2, 3452, 3453, 7, 80, 2, 2, 3453,
	3454, 7, 29, 2, 2, 3454, 3457, 5, 336, 169, 2, 3455, 3456, 7, 38, 2, 2,
	3456, 3458, 5, 334, 168, 2, 3457, 3455, 3, 2, 2, 2, 3457, 3458, 3, 2, 2,
	2, 3458, 3459, 3, 2, 2, 2, 3459, 3460, 7, 31, 2, 2, 3460, 333, 3, 2, 2,
	2, 3461, 3462, 5, 338, 170, 2, 3462, 335, 3, 2, 2, 2, 3463, 3464, 5, 338,
	170, 2, 3464, 337, 3, 2, 2, 2, 3465, 3466, 5, 1018, 510, 2, 3466, 339,
	3, 2, 2, 2, 3467, 3471, 5, 1246, 624, 2, 3468, 3470, 5, 352, 177, 2, 3469,
	3468, 3, 2, 2, 2, 3470, 3473, 3, 2, 2, 2, 3471, 3469, 3, 2, 2, 2, 3471,
	3472, 3, 2, 2, 2, 3472, 3476, 3, 2, 2, 2, 3473, 3471, 3, 2, 2, 2, 3474,
	3475, 7, 80, 2, 2, 3475, 3477, 5, 1032, 517, 2, 3476, 3474, 3, 2, 2, 2,
	3476, 3477, 3, 2, 2, 2, 3477, 3496, 3, 2, 2, 2, 3478, 3479, 5, 1132, 567,
	2, 3479, 3483, 5, 356, 179, 2, 3480, 3482, 5, 352, 177, 2, 3481, 3480,
	3, 2, 2, 2, 3482, 3485, 3, 2, 2, 2, 3483, 3481, 3, 2, 2, 2, 3483, 3484,
	3, 2, 2, 2, 3484, 3488, 3, 2, 2, 2, 3485, 3483, 3, 2, 2, 2, 3486, 3487,
	7, 80, 2, 2, 3487, 3489, 5, 344, 173, 2, 3488, 3486, 3, 2, 2, 2, 3488,
	3489, 3, 2, 2, 2, 3489, 3496, 3, 2, 2, 2, 3490, 3493, 5, 1114, 558, 2,
	3491, 3492, 7, 80, 2, 2, 3492, 3494, 5, 342, 172, 2, 3493, 3491, 3, 2,
	2, 2, 3493, 3494, 3, 2, 2, 2, 3494, 3496, 3, 2, 2, 2, 3495, 3467, 3, 2,
	2, 2, 3495, 3478, 3, 2, 2, 2, 3495, 3490, 3, 2, 2, 2, 3496, 341, 3, 2,
	2, 2, 3497, 3499, 5, 250, 126, 2, 3498, 3497, 3, 2, 2, 2, 3498, 3499, 3,
	2, 2, 2, 3499, 3500, 3, 2, 2, 2, 3500, 3505, 7, 222, 2, 2, 3501, 3502,
	7, 29, 2, 2, 3502, 3503, 5, 1002, 502, 2, 3503, 3504, 7, 31, 2, 2, 3504,
	3506, 3, 2, 2, 2, 3505, 3501, 3, 2, 2, 2, 3505, 3506, 3, 2, 2, 2, 3506,
	3510, 3, 2, 2, 2, 3507, 3508, 7, 222, 2, 2, 3508, 3510, 5, 1032, 517, 2,
	3509, 3498, 3, 2, 2, 2, 3509, 3507, 3, 2, 2, 2, 3510, 343, 3, 2, 2, 2,
	3511, 3512, 7, 222, 2, 2, 3512, 3513, 7, 52, 2, 2, 3513, 3514, 5, 1032,
	517, 2, 3514, 3519, 7, 54, 2, 2, 3515, 3516, 7, 29, 2, 2, 3516, 3517, 5,
	1032, 517, 2, 3517, 3518, 7, 31, 2, 2, 3518, 3520, 3, 2, 2, 2, 3519, 3515,
	3, 2, 2, 2, 3519, 3520, 3, 2, 2, 2, 3520, 345, 3, 2, 2, 2, 3521, 3524,
	7, 52, 2, 2, 3522, 3525, 5, 1028, 515, 2, 3523, 3525, 5, 1016, 509, 2,
	3524, 3522, 3, 2, 2, 2, 3524, 3523, 3, 2, 2, 2, 3525, 3526, 3, 2, 2, 2,
	3526, 3527, 7, 54, 2, 2, 3527, 347, 3, 2, 2, 2, 3528, 3529, 7, 52, 2, 2,
	3529, 3530, 5, 1028, 515, 2, 3530, 3531, 7, 54, 2, 2, 3531, 3534, 3, 2,
	2, 2, 3532, 3534, 5, 356, 179, 2, 3533, 3528, 3, 2, 2, 2, 3533, 3532, 3,
	2, 2, 2, 3534, 349, 3, 2, 2, 2, 3535, 3538, 7, 52, 2, 2, 3536, 3539, 5,
	240, 121, 2, 3537, 3539, 7, 32, 2, 2, 3538, 3536, 3, 2, 2, 2, 3538, 3537,
	3, 2, 2, 2, 3539, 3540, 3, 2, 2, 2, 3540, 3541, 7, 54, 2, 2, 3541, 351,
	3, 2, 2, 2, 3542, 3547, 5, 356, 179, 2, 3543, 3547, 5, 346, 174, 2, 3544,
	3547, 5, 350, 176, 2, 3545, 3547, 5, 354, 178, 2, 3546, 3542, 3, 2, 2,
	2, 3546, 3543, 3, 2, 2, 2, 3546, 3544, 3, 2, 2, 2, 3546, 3545, 3, 2, 2,
	2, 3547, 353, 3, 2, 2, 2, 3548, 3549, 7, 52, 2, 2, 3549, 3552, 7, 16, 2,
	2, 3550, 3551, 7, 43, 2, 2, 3551, 3553, 5, 1016, 509, 2, 3552, 3550, 3,
	2, 2, 2, 3552, 3553, 3, 2, 2, 2, 3553, 3554, 3, 2, 2, 2, 3554, 3555, 7,
	54, 2, 2, 3555, 355, 3, 2, 2, 2, 3556, 3557, 7, 52, 2, 2, 3557, 3558, 7,
	54, 2, 2, 3558, 357, 3, 2, 2, 2, 3559, 3562, 5, 276, 139, 2, 3560, 3562,
	5, 244, 123, 2, 3561, 3559, 3, 2, 2, 2, 3561, 3560, 3, 2, 2, 2, 3562, 359,
	3, 2, 2, 2, 3563, 3565, 7, 176, 2, 2, 3564, 3566, 5, 236, 119, 2, 3565,
	3564, 3, 2, 2, 2, 3565, 3566, 3, 2, 2, 2, 3566, 3567, 3, 2, 2, 2, 3567,
	3568, 5, 362, 182, 2, 3568, 361, 3, 2, 2, 2, 3569, 3574, 5, 358, 180, 2,
	3570, 3571, 5, 1170, 586, 2, 3571, 3572, 7, 39, 2, 2, 3572, 3575, 3, 2,
	2, 2, 3573, 3575, 5, 250, 126, 2, 3574, 3570, 3, 2, 2, 2, 3574, 3573, 3,
	2, 2, 2, 3574, 3575, 3, 2, 2, 2, 3575, 3576, 3, 2, 2, 2, 3576, 3596, 5,
	1138, 570, 2, 3577, 3581, 7, 48, 2, 2, 3578, 3580, 5, 382, 192, 2, 3579,
	3578, 3, 2, 2, 2, 3580, 3583, 3, 2, 2, 2, 3581, 3579, 3, 2, 2, 2, 3581,
	3582, 3, 2, 2, 2, 3582, 3597, 3, 2, 2, 2, 3583, 3581, 3, 2, 2, 2, 3584,
	3586, 7, 29, 2, 2, 3585, 3587, 5, 384, 193, 2, 3586, 3585, 3, 2, 2, 2,
	3586, 3587, 3, 2, 2, 2, 3587, 3588, 3, 2, 2, 2, 3588, 3589, 7, 31, 2, 2,
	3589, 3593, 7, 48, 2, 2, 3590, 3592, 5, 394, 198, 2, 3591, 3590, 3, 2,
	2, 2, 3592, 3595, 3, 2, 2, 2, 3593, 3591, 3, 2, 2, 2, 3593, 3594, 3, 2,
	2, 2, 3594, 3597, 3, 2, 2, 2, 3595, 3593, 3, 2, 2, 2, 3596, 3577, 3, 2,
	2, 2, 3596, 3584, 3, 2, 2, 2, 3597, 3601, 3, 2, 2, 2, 3598, 3600, 5, 724,
	363, 2, 3599, 3598, 3, 2, 2, 2, 3600, 3603, 3, 2, 2, 2, 3601, 3599, 3,
	2, 2, 2, 3601, 3602, 3, 2, 2, 2, 3602, 3604, 3, 2, 2, 2, 3603, 3601, 3,
	2, 2, 2, 3604, 3607, 7, 150, 2, 2, 3605, 3606, 7, 43, 2, 2, 3606, 3608,
	5, 1138, 570, 2, 3607, 3605, 3, 2, 2, 2, 3607, 3608, 3, 2, 2, 2, 3608,
	363, 3, 2, 2, 2, 3609, 3610, 7, 176, 2, 2, 3610, 3611, 5, 276, 139, 2,
	3611, 3617, 5, 1138, 570, 2, 3612, 3614, 7, 29, 2, 2, 3613, 3615, 5, 384,
	193, 2, 3614, 3613, 3, 2, 2, 2, 3614, 3615, 3, 2, 2, 2, 3615, 3616, 3,
	2, 2, 2, 3616, 3618, 7, 31, 2, 2, 3617, 3612, 3, 2, 2, 2, 3617, 3618, 3,
	2, 2, 2, 3618, 365, 3, 2, 2, 2, 3619, 3620, 7, 189, 2, 2, 3620, 3639, 5,
	368, 185, 2, 3621, 3623, 5, 370, 186, 2, 3622, 3621, 3, 2, 2, 2, 3622,
	3623, 3, 2, 2, 2, 3623, 3627, 3, 2, 2, 2, 3624, 3625, 5, 1106, 554, 2,
	3625, 3626, 7, 80, 2, 2, 3626, 3628, 3, 2, 2, 2, 3627, 3624, 3, 2, 2, 2,
	3627, 3628, 3, 2, 2, 2, 3628, 3629, 3, 2, 2, 2, 3629, 3640, 5, 374, 188,
	2, 3630, 3632, 5, 372, 187, 2, 3631, 3630, 3, 2, 2, 2, 3631, 3632, 3, 2,
	2, 2, 3632, 3636, 3, 2, 2, 2, 3633, 3634, 5, 1106, 554, 2, 3634, 3635,
	7, 80, 2, 2, 3635, 3637, 3, 2, 2, 2, 3636, 3633, 3, 2, 2, 2, 3636, 3637,
	3, 2, 2, 2, 3637, 3638, 3, 2, 2, 2, 3638, 3640, 5, 376, 189, 2, 3639, 3622,
	3, 2, 2, 2, 3639, 3631, 3, 2, 2, 2, 3640, 3641, 3, 2, 2, 2, 3641, 3642,
	7, 48, 2, 2, 3642, 3659, 3, 2, 2, 2, 3643, 3644, 7, 165, 2, 2, 3644, 3648,
	5, 368, 185, 2, 3645, 3646, 5, 1106, 554, 2, 3646, 3647, 7, 80, 2, 2, 3647,
	3649, 3, 2, 2, 2, 3648, 3645, 3, 2, 2, 2, 3648, 3649, 3, 2, 2, 2, 3649,
	3654, 3, 2, 2, 2, 3650, 3651, 7, 176, 2, 2, 3651, 3655, 5, 1138, 570, 2,
	3652, 3653, 7, 300, 2, 2, 3653, 3655, 5, 1238, 620, 2, 3654, 3650, 3, 2,
	2, 2, 3654, 3652, 3, 2, 2, 2, 3655, 3656, 3, 2, 2, 2, 3656, 3657, 7, 48,
	2, 2, 3657, 3659, 3, 2, 2, 2, 3658, 3619, 3, 2, 2, 2, 3658, 3643, 3, 2,
	2, 2, 3659, 367, 3, 2, 2, 2, 3660, 3661, 9, 21, 2, 2, 3661, 369, 3, 2,
	2, 2, 3662, 3663, 9, 22, 2, 2, 3663, 371, 3, 2, 2, 2, 3664, 3665, 7, 129,
	2, 2, 3665, 373, 3, 2, 2, 2, 3666, 3667, 5, 364, 183, 2, 3667, 375, 3,
	2, 2, 2, 3668, 3669, 5, 392, 197, 2, 3669, 377, 3, 2, 2, 2, 3670, 3672,
	7, 300, 2, 2, 3671, 3673, 5, 236, 119, 2, 3672, 3671, 3, 2, 2, 2, 3672,
	3673, 3, 2, 2, 2, 3673, 3674, 3, 2, 2, 2, 3674, 3675, 5, 380, 191, 2, 3675,
	379, 3, 2, 2, 2, 3676, 3677, 5, 1170, 586, 2, 3677, 3678, 7, 39, 2, 2,
	3678, 3681, 3, 2, 2, 2, 3679, 3681, 5, 250, 126, 2, 3680, 3676, 3, 2, 2,
	2, 3680, 3679, 3, 2, 2, 2, 3680, 3681, 3, 2, 2, 2, 3681, 3682, 3, 2, 2,
	2, 3682, 3702, 5, 1238, 620, 2, 3683, 3687, 7, 48, 2, 2, 3684, 3686, 5,
	382, 192, 2, 3685, 3684, 3, 2, 2, 2, 3686, 3689, 3, 2, 2, 2, 3687, 3685,
	3, 2, 2, 2, 3687, 3688, 3, 2, 2, 2, 3688, 3703, 3, 2, 2, 2, 3689, 3687,
	3, 2, 2, 2, 3690, 3692, 7, 29, 2, 2, 3691, 3693, 5, 384, 193, 2, 3692,
	3691, 3, 2, 2, 2, 3692, 3693, 3, 2, 2, 2, 3693, 3694, 3, 2, 2, 2, 3694,
	3695, 7, 31, 2, 2, 3695, 3699, 7, 48, 2, 2, 3696, 3698, 5, 394, 198, 2,
	3697, 3696, 3, 2, 2, 2, 3698, 3701, 3, 2, 2, 2, 3699, 3697, 3, 2, 2, 2,
	3699, 3700, 3, 2, 2, 2, 3700, 3703, 3, 2, 2, 2, 3701, 3699, 3, 2, 2, 2,
	3702, 3683, 3, 2, 2, 2, 3702, 3690, 3, 2, 2, 2, 3703, 3707, 3, 2, 2, 2,
	3704, 3706, 5, 716, 359, 2, 3705, 3704, 3, 2, 2, 2, 3706, 3709, 3, 2, 2,
	2, 3707, 3705, 3, 2, 2, 2, 3707, 3708, 3, 2, 2, 2, 3708, 3710, 3, 2, 2,
	2, 3709, 3707, 3, 2, 2, 2, 3710, 3713, 7, 160, 2, 2, 3711, 3712, 7, 43,
	2, 2, 3712, 3714, 5, 1238, 620, 2, 3713, 3711, 3, 2, 2, 2, 3713, 3714,
	3, 2, 2, 2, 3714, 381, 3, 2, 2, 2, 3715, 3718, 5, 394, 198, 2, 3716, 3718,
	5, 390, 196, 2, 3717, 3715, 3, 2, 2, 2, 3717, 3716, 3, 2, 2, 2, 3718, 383,
	3, 2, 2, 2, 3719, 3724, 5, 386, 194, 2, 3720, 3721, 7, 38, 2, 2, 3721,
	3723, 5, 386, 194, 2, 3722, 3720, 3, 2, 2, 2, 3723, 3726, 3, 2, 2, 2, 3724,
	3722, 3, 2, 2, 2, 3724, 3725, 3, 2, 2, 2, 3725, 385, 3, 2, 2, 2, 3726,
	3724, 3, 2, 2, 2, 3727, 3729, 5, 1094, 548, 2, 3728, 3727, 3, 2, 2, 2,
	3729, 3732, 3, 2, 2, 2, 3730, 3728, 3, 2, 2, 2, 3730, 3731, 3, 2, 2, 2,
	3731, 3734, 3, 2, 2, 2, 3732, 3730, 3, 2, 2, 2, 3733, 3735, 5, 388, 195,
	2, 3734, 3733, 3, 2, 2, 2, 3734, 3735, 3, 2, 2, 2, 3735, 3737, 3, 2, 2,
	2, 3736, 3738, 7, 327, 2, 2, 3737, 3736, 3, 2, 2, 2, 3737, 3738, 3, 2,
	2, 2, 3738, 3739, 3, 2, 2, 2, 3739, 3751, 5, 242, 122, 2, 3740, 3744, 5,
	1202, 602, 2, 3741, 3743, 5, 352, 177, 2, 3742, 3741, 3, 2, 2, 2, 3743,
	3746, 3, 2, 2, 2, 3744, 3742, 3, 2, 2, 2, 3744, 3745, 3, 2, 2, 2, 3745,
	3749, 3, 2, 2, 2, 3746, 3744, 3, 2, 2, 2, 3747, 3748, 7, 80, 2, 2, 3748,
	3750, 5, 1032, 517, 2, 3749, 3747, 3, 2, 2, 2, 3749, 3750, 3, 2, 2, 2,
	3750, 3752, 3, 2, 2, 2, 3751, 3740, 3, 2, 2, 2, 3751, 3752, 3, 2, 2, 2,
	3752, 387, 3, 2, 2, 2, 3753, 3757, 5, 66, 34, 2, 3754, 3755, 7, 127, 2,
	2, 3755, 3757, 7, 259, 2, 2, 3756, 3753, 3, 2, 2, 2, 3756, 3754, 3, 2,
	2, 2, 3757, 389, 3, 2, 2, 2, 3758, 3760, 5, 1094, 548, 2, 3759, 3758, 3,
	2, 2, 2, 3760, 3763, 3, 2, 2, 2, 3761, 3759, 3, 2, 2, 2, 3761, 3762, 3,
	2, 2, 2, 3762, 3764, 3, 2, 2, 2, 3763, 3761, 3, 2, 2, 2, 3764, 3766, 5,
	388, 195, 2, 3765, 3767, 7, 327, 2, 2, 3766, 3765, 3, 2, 2, 2, 3766, 3767,
	3, 2, 2, 2, 3767, 3768, 3, 2, 2, 2, 3768, 3769, 5, 242, 122, 2, 3769, 3770,
	5, 312, 157, 2, 3770, 3771, 7, 48, 2, 2, 3771, 391, 3, 2, 2, 2, 3772, 3773,
	7, 300, 2, 2, 3773, 3779, 5, 1238, 620, 2, 3774, 3776, 7, 29, 2, 2, 3775,
	3777, 5, 384, 193, 2, 3776, 3775, 3, 2, 2, 2, 3776, 3777, 3, 2, 2, 2, 3777,
	3778, 3, 2, 2, 2, 3778, 3780, 7, 31, 2, 2, 3779, 3774, 3, 2, 2, 2, 3779,
	3780, 3, 2, 2, 2, 3780, 393, 3, 2, 2, 2, 3781, 3783, 5, 1094, 548, 2, 3782,
	3781, 3, 2, 2, 2, 3783, 3786, 3, 2, 2, 2, 3784, 3782, 3, 2, 2, 2, 3784,
	3785, 3, 2, 2, 2, 3785, 3789, 3, 2, 2, 2, 3786, 3784, 3, 2, 2, 2, 3787,
	3790, 5, 220, 111, 2, 3788, 3790, 5, 562, 282, 2, 3789, 3787, 3, 2, 2,
	2, 3789, 3788, 3, 2, 2, 2, 3790, 3804, 3, 2, 2, 2, 3791, 3793, 5, 1094,
	548, 2, 3792, 3791, 3, 2, 2, 2, 3793, 3796, 3, 2, 2, 2, 3794, 3792, 3,
	2, 2, 2, 3794, 3795, 3, 2, 2, 2, 3795, 3799, 3, 2, 2, 2, 3796, 3794, 3,
	2, 2, 2, 3797, 3800, 5, 204, 103, 2, 3798, 3800, 5, 206, 104, 2, 3799,
	3797, 3, 2, 2, 2, 3799, 3798, 3, 2, 2, 2, 3800, 3801, 3, 2, 2, 2, 3801,
	3802, 7, 48, 2, 2, 3802, 3804, 3, 2, 2, 2, 3803, 3784, 3, 2, 2, 2, 3803,
	3794, 3, 2, 2, 2, 3804, 395, 3, 2, 2, 2, 3805, 3806, 7, 217, 2, 2, 3806,
	3811, 5, 398, 200, 2, 3807, 3808, 7, 38, 2, 2, 3808, 3810, 5, 398, 200,
	2, 3809, 3807, 3, 2, 2, 2, 3810, 3813, 3, 2, 2, 2, 3811, 3809, 3, 2, 2,
	2, 3811, 3812, 3, 2, 2, 2, 3812, 3814, 3, 2, 2, 2, 3813, 3811, 3, 2, 2,
	2, 3814, 3815, 7, 48, 2, 2, 3815, 397, 3, 2, 2, 2, 3816, 3817, 5, 1186,
	594, 2, 3817, 3818, 7, 29, 2, 2, 3818, 3823, 5, 400, 201, 2, 3819, 3820,
	7, 38, 2, 2, 3820, 3822, 5, 400, 201, 2, 3821, 3819, 3, 2, 2, 2, 3822,
	3825, 3, 2, 2, 2, 3823, 3821, 3, 2, 2, 2, 3823, 3824, 3, 2, 2, 2, 3824,
	3826, 3, 2, 2, 2, 3825, 3823, 3, 2, 2, 2, 3826, 3827, 7, 31, 2, 2, 3827,
	399, 3, 2, 2, 2, 3828, 3830, 5, 1094, 548, 2, 3829, 3828, 3, 2, 2, 2, 3830,
	3833, 3, 2, 2, 2, 3831, 3829, 3, 2, 2, 2, 3831, 3832, 3, 2, 2, 2, 3832,
	3837, 3, 2, 2, 2, 3833, 3831, 3, 2, 2, 2, 3834, 3838, 5, 404, 203, 2, 3835,
	3838, 5, 408, 205, 2, 3836, 3838, 5, 402, 202, 2, 3837, 3834, 3, 2, 2,
	2, 3837, 3835, 3, 2, 2, 2, 3837, 3836, 3, 2, 2, 2, 3838, 401, 3, 2, 2,
	2, 3839, 3840, 7, 124, 2, 2, 3840, 3841, 5, 1116, 559, 2, 3841, 403, 3,
	2, 2, 2, 3842, 3843, 5, 66, 34, 2, 3843, 3848, 5, 406, 204, 2, 3844, 3845,
	7, 38, 2, 2, 3845, 3847, 5, 406, 204, 2, 3846, 3844, 3, 2, 2, 2, 3847,
	3850, 3, 2, 2, 2, 3848, 3846, 3, 2, 2, 2, 3848, 3849, 3, 2, 2, 2, 3849,
	405, 3, 2, 2, 2, 3850, 3848, 3, 2, 2, 2, 3851, 3861, 5, 1202, 602, 2, 3852,
	3853, 7, 39, 2, 2, 3853, 3854, 5, 1202, 602, 2, 3854, 3856, 7, 29, 2, 2,
	3855, 3857, 5, 1032, 517, 2, 3856, 3855, 3, 2, 2, 2, 3856, 3857, 3, 2,
	2, 2, 3857, 3858, 3, 2, 2, 2, 3858, 3859, 7, 31, 2, 2, 3859, 3861, 3, 2,
	2, 2, 3860, 3851, 3, 2, 2, 2, 3860, 3852, 3, 2, 2, 2, 3861, 407, 3, 2,
	2, 2, 3862, 3863, 5, 412, 207, 2, 3863, 3868, 5, 410, 206, 2, 3864, 3865,
	7, 38, 2, 2, 3865, 3867, 5, 410, 206, 2, 3866, 3864, 3, 2, 2, 2, 3867,
	3870, 3, 2, 2, 2, 3868, 3866, 3, 2, 2, 2, 3868, 3869, 3, 2, 2, 2, 3869,
	409, 3, 2, 2, 2, 3870, 3868, 3, 2, 2, 2, 3871, 3874, 5, 162, 82, 2, 3872,
	3874, 5, 1240, 621, 2, 3873, 3871, 3, 2, 2, 2, 3873, 3872, 3, 2, 2, 2,
	3874, 411, 3, 2, 2, 2, 3875, 3876, 9, 23, 2, 2, 3876, 413, 3, 2, 2, 2,
	3877, 3878, 5, 1102, 552, 2, 3878, 3879, 7, 43, 2, 2, 3879, 3881, 3, 2,
	2, 2, 3880, 3877, 3, 2, 2, 2, 3880, 3881, 3, 2, 2, 2, 3881, 3882, 3, 2,
	2, 2, 3882, 3885, 5, 416, 209, 2, 3883, 3885, 5, 650, 326, 2, 3884, 3880,
	3, 2, 2, 2, 3884, 3883, 3, 2, 2, 2, 3885, 415, 3, 2, 2, 2, 3886, 3892,
	5, 418, 210, 2, 3887, 3892, 5, 420, 211, 2, 3888, 3892, 5, 422, 212, 2,
	3889, 3892, 5, 426, 214, 2, 3890, 3892, 5, 428, 215, 2, 3891, 3886, 3,
	2, 2, 2, 3891, 3887, 3, 2, 2, 2, 3891, 3888, 3, 2, 2, 2, 3891, 3889, 3,
	2, 2, 2, 3891, 3890, 3, 2, 2, 2, 3892, 417, 3, 2, 2, 2, 3893, 3894, 7,
	102, 2, 2, 3894, 3895, 7, 242, 2, 2, 3895, 3896, 7, 29, 2, 2, 3896, 3897,
	5, 448, 225, 2, 3897, 3898, 7, 31, 2, 2, 3898, 3899, 5, 708, 355, 2, 3899,
	419, 3, 2, 2, 2, 3900, 3901, 7, 104, 2, 2, 3901, 3902, 7, 242, 2, 2, 3902,
	3903, 7, 29, 2, 2, 3903, 3904, 5, 448, 225, 2, 3904, 3905, 7, 31, 2, 2,
	3905, 3906, 5, 708, 355, 2, 3906, 421, 3, 2, 2, 2, 3907, 3908, 7, 131,
	2, 2, 3908, 3909, 7, 242, 2, 2, 3909, 3910, 7, 29, 2, 2, 3910, 3911, 5,
	448, 225, 2, 3911, 3912, 7, 31, 2, 2, 3912, 3913, 5, 716, 359, 2, 3913,
	423, 3, 2, 2, 2, 3914, 3915, 7, 164, 2, 2, 3915, 3916, 7, 29, 2, 2, 3916,
	3917, 5, 448, 225, 2, 3917, 3918, 7, 31, 2, 2, 3918, 3919, 5, 708, 355,
	2, 3919, 425, 3, 2, 2, 2, 3920, 3921, 7, 131, 2, 2, 3921, 3922, 7, 277,
	2, 2, 3922, 3924, 7, 29, 2, 2, 3923, 3925, 5, 840, 421, 2, 3924, 3923,
	3, 2, 2, 2, 3924, 3925, 3, 2, 2, 2, 3925, 3932, 3, 2, 2, 2, 3926, 3927,
	7, 139, 2, 2, 3927, 3928, 7, 183, 2, 2, 3928, 3929, 7, 29, 2, 2, 3929,
	3930, 5, 492, 247, 2, 3930, 3931, 7, 31, 2, 2, 3931, 3933, 3, 2, 2, 2,
	3932, 3926, 3, 2, 2, 2, 3932, 3933, 3, 2, 2, 2, 3933, 3934, 3, 2, 2, 2,
	3934, 3935, 5, 464, 233, 2, 3935, 3936, 7, 31, 2, 2, 3936, 3937, 5, 716,
	359, 2, 3937, 427, 3, 2, 2, 2, 3938, 3939, 7, 264, 2, 2, 3939, 3940, 7,
	242, 2, 2, 3940, 3941, 7, 29, 2, 2, 3941, 3942, 5, 448, 225, 2, 3942, 3943,
	7, 31, 2, 2, 3943, 3944, 7, 48, 2, 2, 3944, 429, 3, 2, 2, 2, 3945, 3951,
	5, 1222, 612, 2, 3946, 3948, 7, 29, 2, 2, 3947, 3949, 5, 432, 217, 2, 3948,
	3947, 3, 2, 2, 2, 3948, 3949, 3, 2, 2, 2, 3949, 3950, 3, 2, 2, 2, 3950,
	3952, 7, 31, 2, 2, 3951, 3946, 3, 2, 2, 2, 3951, 3952, 3, 2, 2, 2, 3952,
	431, 3, 2, 2, 2, 3953, 3955, 5, 434, 218, 2, 3954, 3953, 3, 2, 2, 2, 3954,
	3955, 3, 2, 2, 2, 3955, 3962, 3, 2, 2, 2, 3956, 3958, 7, 38, 2, 2, 3957,
	3959, 5, 434, 218, 2, 3958, 3957, 3, 2, 2, 2, 3958, 3959, 3, 2, 2, 2, 3959,
	3961, 3, 2, 2, 2, 3960, 3956, 3, 2, 2, 2, 3961, 3964, 3, 2, 2, 2, 3962,
	3960, 3, 2, 2, 2, 3962, 3963, 3, 2, 2, 2, 3963, 3974, 3, 2, 2, 2, 3964,
	3962, 3, 2, 2, 2, 3965, 3966, 7, 39, 2, 2, 3966, 3967, 5, 1166, 584, 2,
	3967, 3969, 7, 29, 2, 2, 3968, 3970, 5, 434, 218, 2, 3969, 3968, 3, 2,
	2, 2, 3969, 3970, 3, 2, 2, 2, 3970, 3971, 3, 2, 2, 2, 3971, 3972, 7, 31,
	2, 2, 3972, 3974, 3, 2, 2, 2, 3973, 3954, 3, 2, 2, 2, 3973, 3965, 3, 2,
	2, 2, 3974, 3986, 3, 2, 2, 2, 3975, 3976, 7, 38, 2, 2, 3976, 3977, 7, 39,
	2, 2, 3977, 3978, 5, 1166, 584, 2, 3978, 3980, 7, 29, 2, 2, 3979, 3981,
	5, 434, 218, 2, 3980, 3979, 3, 2, 2, 2, 3980, 3981, 3, 2, 2, 2, 3981, 3982,
	3, 2, 2, 2, 3982, 3983, 7, 31, 2, 2, 3983, 3985, 3, 2, 2, 2, 3984, 3975,
	3, 2, 2, 2, 3985, 3988, 3, 2, 2, 2, 3986, 3984, 3, 2, 2, 2, 3986, 3987,
	3, 2, 2, 2, 3987, 433, 3, 2, 2, 2, 3988, 3986, 3, 2, 2, 2, 3989, 3992,
	5, 450, 226, 2, 3990, 3992, 5, 476, 239, 2, 3991, 3989, 3, 2, 2, 2, 3991,
	3990, 3, 2, 2, 2, 3992, 435, 3, 2, 2, 2, 3993, 3997, 5, 438, 220, 2, 3994,
	3997, 5, 454, 228, 2, 3995, 3997, 5, 562, 282, 2, 3996, 3993, 3, 2, 2,
	2, 3996, 3994, 3, 2, 2, 2, 3996, 3995, 3, 2, 2, 2, 3997, 437, 3, 2, 2,
	2, 3998, 3999, 7, 242, 2, 2, 3999, 4005, 5, 1208, 605, 2, 4000, 4002, 7,
	29, 2, 2, 4001, 4003, 5, 440, 221, 2, 4002, 4001, 3, 2, 2, 2, 4002, 4003,
	3, 2, 2, 2, 4003, 4004, 3, 2, 2, 2, 4004, 4006, 7, 31, 2, 2, 4005, 4000,
	3, 2, 2, 2, 4005, 4006, 3, 2, 2, 2, 4006, 4007, 3, 2, 2, 2, 4007, 4011,
	7, 48, 2, 2, 4008, 4010, 5, 494, 248, 2, 4009, 4008, 3, 2, 2, 2, 4010,
	4013, 3, 2, 2, 2, 4011, 4009, 3, 2, 2, 2, 4011, 4012, 3, 2, 2, 2, 4012,
	4014, 3, 2, 2, 2, 4013, 4011, 3, 2, 2, 2, 4014, 4016, 5, 448, 225, 2, 4015,
	4017, 7, 48, 2, 2, 4016, 4015, 3, 2, 2, 2, 4016, 4017, 3, 2, 2, 2, 4017,
	4018, 3, 2, 2, 2, 4018, 4021, 7, 157, 2, 2, 4019, 4020, 7, 43, 2, 2, 4020,
	4022, 5, 1208, 605, 2, 4021, 4019, 3, 2, 2, 2, 4021, 4022, 3, 2, 2, 2,
	4022, 439, 3, 2, 2, 2, 4023, 4028, 5, 442, 222, 2, 4024, 4025, 7, 38, 2,
	2, 4025, 4027, 5, 442, 222, 2, 4026, 4024, 3, 2, 2, 2, 4027, 4030, 3, 2,
	2, 2, 4028, 4026, 3, 2, 2, 2, 4028, 4029, 3, 2, 2, 2, 4029, 441, 3, 2,
	2, 2, 4030, 4028, 3, 2, 2, 2, 4031, 4033, 5, 1094, 548, 2, 4032, 4031,
	3, 2, 2, 2, 4033, 4036, 3, 2, 2, 2, 4034, 4032, 3, 2, 2, 2, 4034, 4035,
	3, 2, 2, 2, 4035, 4041, 3, 2, 2, 2, 4036, 4034, 3, 2, 2, 2, 4037, 4039,
	7, 209, 2, 2, 4038, 4040, 5, 444, 223, 2, 4039, 4038, 3, 2, 2, 2, 4039,
	4040, 3, 2, 2, 2, 4040, 4042, 3, 2, 2, 2, 4041, 4037, 3, 2, 2, 2, 4041,
	4042, 3, 2, 2, 2, 4042, 4043, 3, 2, 2, 2, 4043, 4044, 5, 446, 224, 2, 4044,
	4048, 5, 1136, 569, 2, 4045, 4047, 5, 352, 177, 2, 4046, 4045, 3, 2, 2,
	2, 4047, 4050, 3, 2, 2, 2, 4048, 4046, 3, 2, 2, 2, 4048, 4049, 3, 2, 2,
	2, 4049, 4053, 3, 2, 2, 2, 4050, 4048, 3, 2, 2, 2, 4051, 4052, 7, 80, 2,
	2, 4052, 4054, 5, 434, 218, 2, 4053, 4051, 3, 2, 2, 2, 4053, 4054, 3, 2,
	2, 2, 4054, 443, 3, 2, 2, 2, 4055, 4056, 7, 194, 2, 2, 4056, 445, 3, 2,
	2, 2, 4057, 4060, 5, 462, 232, 2, 4058, 4060, 7, 242, 2, 2, 4059, 4057,
	3, 2, 2, 2, 4059, 4058, 3, 2, 2, 2, 4060, 447, 3, 2, 2, 2, 4061, 4063,
	5, 840, 421, 2, 4062, 4061, 3, 2, 2, 2, 4062, 4063, 3, 2, 2, 2, 4063, 4070,
	3, 2, 2, 2, 4064, 4065, 7, 139, 2, 2, 4065, 4066, 7, 183, 2, 2, 4066, 4067,
	7, 29, 2, 2, 4067, 4068, 5, 492, 247, 2, 4068, 4069, 7, 31, 2, 2, 4069,
	4071, 3, 2, 2, 2, 4070, 4064, 3, 2, 2, 2, 4070, 4071, 3, 2, 2, 2, 4071,
	4072, 3, 2, 2, 2, 4072, 4073, 5, 450, 226, 2, 4073, 449, 3, 2, 2, 2, 4074,
	4075, 8, 226, 1, 2, 4075, 4078, 5, 464, 233, 2, 4076, 4077, 9, 24, 2, 2,
	4077, 4079, 5, 450, 226, 2, 4078, 4076, 3, 2, 2, 2, 4078, 4079, 3, 2, 2,
	2, 4079, 4146, 3, 2, 2, 2, 4080, 4081, 9, 25, 2, 2, 4081, 4082, 7, 29,
	2, 2, 4082, 4083, 5, 464, 233, 2, 4083, 4084, 7, 31, 2, 2, 4084, 4146,
	3, 2, 2, 2, 4085, 4086, 7, 29, 2, 2, 4086, 4087, 5, 450, 226, 2, 4087,
	4088, 7, 31, 2, 2, 4088, 4146, 3, 2, 2, 2, 4089, 4090, 7, 227, 2, 2, 4090,
	4146, 5, 450, 226, 12, 4091, 4092, 7, 182, 2, 2, 4092, 4093, 7, 29, 2,
	2, 4093, 4094, 5, 492, 247, 2, 4094, 4095, 7, 31, 2, 2, 4095, 4098, 5,
	450, 226, 2, 4096, 4097, 7, 143, 2, 2, 4097, 4099, 5, 450, 226, 2, 4098,
	4096, 3, 2, 2, 2, 4098, 4099, 3, 2, 2, 2, 4099, 4146, 3, 2, 2, 2, 4100,
	4101, 7, 117, 2, 2, 4101, 4102, 7, 29, 2, 2, 4102, 4103, 5, 492, 247, 2,
	4103, 4104, 7, 31, 2, 2, 4104, 4108, 5, 452, 227, 2, 4105, 4107, 5, 452,
	227, 2, 4106, 4105, 3, 2, 2, 2, 4107, 4110, 3, 2, 2, 2, 4108, 4106, 3,
	2, 2, 2, 4108, 4109, 3, 2, 2, 2, 4109, 4111, 3, 2, 2, 2, 4110, 4108, 3,
	2, 2, 2, 4111, 4112, 7, 145, 2, 2, 4112, 4146, 3, 2, 2, 2, 4113, 4118,
	9, 26, 2, 2, 4114, 4115, 7, 52, 2, 2, 4115, 4116, 5, 1016, 509, 2, 4116,
	4117, 7, 54, 2, 2, 4117, 4119, 3, 2, 2, 2, 4118, 4114, 3, 2, 2, 2, 4118,
	4119, 3, 2, 2, 2, 4119, 4120, 3, 2, 2, 2, 4120, 4146, 5, 450, 226, 8, 4121,
	4126, 9, 27, 2, 2, 4122, 4123, 7, 52, 2, 2, 4123, 4124, 5, 490, 246, 2,
	4124, 4125, 7, 54, 2, 2, 4125, 4127, 3, 2, 2, 2, 4126, 4122, 3, 2, 2, 2,
	4126, 4127, 3, 2, 2, 2, 4127, 4128, 3, 2, 2, 2, 4128, 4146, 5, 450, 226,
	7, 4129, 4130, 9, 28, 2, 2, 4130, 4131, 7, 52, 2, 2, 4131, 4132, 5, 1028,
	515, 2, 4132, 4133, 7, 54, 2, 2, 4133, 4134, 5, 450, 226, 6, 4134, 4146,
	3, 2, 2, 2, 4135, 4136, 9, 29, 2, 2, 4136, 4137, 7, 29, 2, 2, 4137, 4138,
	5, 492, 247, 2, 4138, 4139, 7, 31, 2, 2, 4139, 4140, 5, 450, 226, 5, 4140,
	4146, 3, 2, 2, 2, 4141, 4146, 5, 430, 216, 2, 4142, 4143, 5, 840, 421,
	2, 4143, 4144, 5, 450, 226, 3, 4144, 4146, 3, 2, 2, 2, 4145, 4074, 3, 2,
	2, 2, 4145, 4080, 3, 2, 2, 2, 4145, 4085, 3, 2, 2, 2, 4145, 4089, 3, 2,
	2, 2, 4145, 4091, 3, 2, 2, 2, 4145, 4100, 3, 2, 2, 2, 4145, 4113, 3, 2,
	2, 2, 4145, 4121, 3, 2, 2, 2, 4145, 4129, 3, 2, 2, 2, 4145, 4135, 3, 2,
	2, 2, 4145, 4141, 3, 2, 2, 2, 4145, 4142, 3, 2, 2, 2, 4146, 4152, 3, 2,
	2, 2, 4147, 4148, 12, 11, 2, 2, 4148, 4149, 9, 30, 2, 2, 4149, 4151, 5,
	450, 226, 12, 4150, 4147, 3, 2, 2, 2, 4151, 4154, 3, 2, 2, 2, 4152, 4150,
	3, 2, 2, 2, 4152, 4153, 3, 2, 2, 2, 4153, 451, 3, 2, 2, 2, 4154, 4152,
	3, 2, 2, 2, 4155, 4160, 5, 492, 247, 2, 4156, 4157, 7, 38, 2, 2, 4157,
	4159, 5, 492, 247, 2, 4158, 4156, 3, 2, 2, 2, 4159, 4162, 3, 2, 2, 2, 4160,
	4158, 3, 2, 2, 2, 4160, 4161, 3, 2, 2, 2, 4161, 4163, 3, 2, 2, 2, 4162,
	4160, 3, 2, 2, 2, 4163, 4164, 7, 43, 2, 2, 4164, 4165, 5, 450, 226, 2,
	4165, 4166, 7, 48, 2, 2, 4166, 4175, 3, 2, 2, 2, 4167, 4169, 7, 136, 2,
	2, 4168, 4170, 7, 43, 2, 2, 4169, 4168, 3, 2, 2, 2, 4169, 4170, 3, 2, 2,
	2, 4170, 4171, 3, 2, 2, 2, 4171, 4172, 5, 450, 226, 2, 4172, 4173, 7, 48,
	2, 2, 4173, 4175, 3, 2, 2, 2, 4174, 4155, 3, 2, 2, 2, 4174, 4167, 3, 2,
	2, 2, 4175, 453, 3, 2, 2, 2, 4176, 4177, 7, 277, 2, 2, 4177, 4183, 5, 1232,
	617, 2, 4178, 4180, 7, 29, 2, 2, 4179, 4181, 5, 456, 229, 2, 4180, 4179,
	3, 2, 2, 2, 4180, 4181, 3, 2, 2, 2, 4181, 4182, 3, 2, 2, 2, 4182, 4184,
	7, 31, 2, 2, 4183, 4178, 3, 2, 2, 2, 4183, 4184, 3, 2, 2, 2, 4184, 4185,
	3, 2, 2, 2, 4185, 4189, 7, 48, 2, 2, 4186, 4188, 5, 494, 248, 2, 4187,
	4186, 3, 2, 2, 2, 4188, 4191, 3, 2, 2, 2, 4189, 4187, 3, 2, 2, 2, 4189,
	4190, 3, 2, 2, 2, 4190, 4192, 3, 2, 2, 2, 4191, 4189, 3, 2, 2, 2, 4192,
	4194, 5, 464, 233, 2, 4193, 4195, 7, 48, 2, 2, 4194, 4193, 3, 2, 2, 2,
	4194, 4195, 3, 2, 2, 2, 4195, 4196, 3, 2, 2, 2, 4196, 4199, 7, 158, 2,
	2, 4197, 4198, 7, 43, 2, 2, 4198, 4200, 5, 1232, 617, 2, 4199, 4197, 3,
	2, 2, 2, 4199, 4200, 3, 2, 2, 2, 4200, 455, 3, 2, 2, 2, 4201, 4206, 5,
	458, 230, 2, 4202, 4203, 7, 38, 2, 2, 4203, 4205, 5, 458, 230, 2, 4204,
	4202, 3, 2, 2, 2, 4205, 4208, 3, 2, 2, 2, 4206, 4204, 3, 2, 2, 2, 4206,
	4207, 3, 2, 2, 2, 4207, 457, 3, 2, 2, 2, 4208, 4206, 3, 2, 2, 2, 4209,
	4211, 5, 1094, 548, 2, 4210, 4209, 3, 2, 2, 2, 4211, 4214, 3, 2, 2, 2,
	4212, 4210, 3, 2, 2, 2, 4212, 4213, 3, 2, 2, 2, 4213, 4219, 3, 2, 2, 2,
	4214, 4212, 3, 2, 2, 2, 4215, 4217, 7, 209, 2, 2, 4216, 4218, 5, 460, 231,
	2, 4217, 4216, 3, 2, 2, 2, 4217, 4218, 3, 2, 2, 2, 4218, 4220, 3, 2, 2,
	2, 4219, 4215, 3, 2, 2, 2, 4219, 4220, 3, 2, 2, 2, 4220, 4221, 3, 2, 2,
	2, 4221, 4222, 5, 462, 232, 2, 4222, 4226, 5, 1136, 569, 2, 4223, 4225,
	5, 352, 177, 2, 4224, 4223, 3, 2, 2, 2, 4225, 4228, 3, 2, 2, 2, 4226, 4224,
	3, 2, 2, 2, 4226, 4227, 3, 2, 2, 2, 4227, 4231, 3, 2, 2, 2, 4228, 4226,
	3, 2, 2, 2, 4229, 4230, 7, 80, 2, 2, 4230, 4232, 5, 476, 239, 2, 4231,
	4229, 3, 2, 2, 2, 4231, 4232, 3, 2, 2, 2, 4232, 459, 3, 2, 2, 2, 4233,
	4234, 9, 31, 2, 2, 4234, 461, 3, 2, 2, 2, 4235, 4239, 5, 242, 122, 2, 4236,
	4239, 7, 277, 2, 2, 4237, 4239, 7, 324, 2, 2, 4238, 4235, 3, 2, 2, 2, 4238,
	4236, 3, 2, 2, 2, 4238, 4237, 3, 2, 2, 2, 4239, 463, 3, 2, 2, 2, 4240,
	4241, 8, 233, 1, 2, 4241, 4242, 5, 466, 234, 2, 4242, 4248, 5, 464, 233,
	2, 4243, 4244, 5, 466, 234, 2, 4244, 4245, 5, 464, 233, 2, 4245, 4247,
	3, 2, 2, 2, 4246, 4243, 3, 2, 2, 2, 4247, 4250, 3, 2, 2, 2, 4248, 4246,
	3, 2, 2, 2, 4248, 4249, 3, 2, 2, 2, 4249, 4292, 3, 2, 2, 2, 4250, 4248,
	3, 2, 2, 2, 4251, 4257, 5, 492, 247, 2, 4252, 4254, 5, 478, 240, 2, 4253,
	4252, 3, 2, 2, 2, 4253, 4254, 3, 2, 2, 2, 4254, 4258, 3, 2, 2, 2, 4255,
	4256, 7, 302, 2, 2, 4256, 4258, 5, 464, 233, 2, 4257, 4253, 3, 2, 2, 2,
	4257, 4255, 3, 2, 2, 2, 4258, 4292, 3, 2, 2, 2, 4259, 4261, 5, 472, 237,
	2, 4260, 4262, 5, 480, 241, 2, 4261, 4260, 3, 2, 2, 2, 4261, 4262, 3, 2,
	2, 2, 4262, 4292, 3, 2, 2, 2, 4263, 4264, 7, 29, 2, 2, 4264, 4269, 5, 464,
	233, 2, 4265, 4266, 7, 38, 2, 2, 4266, 4268, 5, 470, 236, 2, 4267, 4265,
	3, 2, 2, 2, 4268, 4271, 3, 2, 2, 2, 4269, 4267, 3, 2, 2, 2, 4269, 4270,
	3, 2, 2, 2, 4270, 4272, 3, 2, 2, 2, 4271, 4269, 3, 2, 2, 2, 4272, 4274,
	7, 31, 2, 2, 4273, 4275, 5, 480, 241, 2, 4274, 4273, 3, 2, 2, 2, 4274,
	4275, 3, 2, 2, 2, 4275, 4292, 3, 2, 2, 2, 4276, 4277, 7, 169, 2, 2, 4277,
	4278, 7, 29, 2, 2, 4278, 4283, 5, 464, 233, 2, 4279, 4280, 7, 38, 2, 2,
	4280, 4282, 5, 470, 236, 2, 4281, 4279, 3, 2, 2, 2, 4282, 4285, 3, 2, 2,
	2, 4283, 4281, 3, 2, 2, 2, 4283, 4284, 3, 2, 2, 2, 4284, 4286, 3, 2, 2,
	2, 4285, 4283, 3, 2, 2, 2, 4286, 4287, 7, 31, 2, 2, 4287, 4292, 3, 2, 2,
	2, 4288, 4289, 5, 840, 421, 2, 4289, 4290, 5, 464, 233, 3, 4290, 4292,
	3, 2, 2, 2, 4291, 4240, 3, 2, 2, 2, 4291, 4251, 3, 2, 2, 2, 4291, 4259,
	3, 2, 2, 2, 4291, 4263, 3, 2, 2, 2, 4291, 4276, 3, 2, 2, 2, 4291, 4288,
	3, 2, 2, 2, 4292, 4309, 3, 2, 2, 2, 4293, 4294, 12, 5, 2, 2, 4294, 4295,
	9, 32, 2, 2, 4295, 4308, 5, 464, 233, 6, 4296, 4297, 12, 9, 2, 2, 4297,
	4298, 5, 466, 234, 2, 4298, 4304, 5, 464, 233, 2, 4299, 4300, 5, 466, 234,
	2, 4300, 4301, 5, 464, 233, 2, 4301, 4303, 3, 2, 2, 2, 4302, 4299, 3, 2,
	2, 2, 4303, 4306, 3, 2, 2, 2, 4304, 4302, 3, 2, 2, 2, 4304, 4305, 3, 2,
	2, 2, 4305, 4308, 3, 2, 2, 2, 4306, 4304, 3, 2, 2, 2, 4307, 4293, 3, 2,
	2, 2, 4307, 4296, 3, 2, 2, 2, 4308, 4311, 3, 2, 2, 2, 4309, 4307, 3, 2,
	2, 2, 4309, 4310, 3, 2, 2, 2, 4310, 465, 3, 2, 2, 2, 4311, 4309, 3, 2,
	2, 2, 4312, 4321, 7, 12, 2, 2, 4313, 4322, 5, 1048, 525, 2, 4314, 4318,
	7, 52, 2, 2, 4315, 4319, 5, 490, 246, 2, 4316, 4319, 7, 32, 2, 2, 4317,
	4319, 7, 69, 2, 2, 4318, 4315, 3, 2, 2, 2, 4318, 4316, 3, 2, 2, 2, 4318,
	4317, 3, 2, 2, 2, 4319, 4320, 3, 2, 2, 2, 4320, 4322, 7, 54, 2, 2, 4321,
	4313, 3, 2, 2, 2, 4321, 4314, 3, 2, 2, 2, 4322, 467, 3, 2, 2, 2, 4323,
	4324, 5, 472, 237, 2, 4324, 4325, 7, 39, 2, 2, 4325, 4326, 5, 1184, 593,
	2, 4326, 469, 3, 2, 2, 2, 4327, 4331, 5, 698, 350, 2, 4328, 4331, 5, 1014,
	508, 2, 4329, 4331, 5, 998, 500, 2, 4330, 4327, 3, 2, 2, 2, 4330, 4328,
	3, 2, 2, 2, 4330, 4329, 3, 2, 2, 2, 4331, 471, 3, 2, 2, 2, 4332, 4338,
	5, 1224, 613, 2, 4333, 4335, 7, 29, 2, 2, 4334, 4336, 5, 474, 238, 2, 4335,
	4334, 3, 2, 2, 2, 4335, 4336, 3, 2, 2, 2, 4336, 4337, 3, 2, 2, 2, 4337,
	4339, 7, 31, 2, 2, 4338, 4333, 3, 2, 2, 2, 4338, 4339, 3, 2, 2, 2, 4339,
	473, 3, 2, 2, 2, 4340, 4342, 5, 476, 239, 2, 4341, 4340, 3, 2, 2, 2, 4341,
	4342, 3, 2, 2, 2, 4342, 4349, 3, 2, 2, 2, 4343, 4345, 7, 38, 2, 2, 4344,
	4346, 5, 476, 239, 2, 4345, 4344, 3, 2, 2, 2, 4345, 4346, 3, 2, 2, 2, 4346,
	4348, 3, 2, 2, 2, 4347, 4343, 3, 2, 2, 2, 4348, 4351, 3, 2, 2, 2, 4349,
	4347, 3, 2, 2, 2, 4349, 4350, 3, 2, 2, 2, 4350, 4361, 3, 2, 2, 2, 4351,
	4349, 3, 2, 2, 2, 4352, 4353, 7, 39, 2, 2, 4353, 4354, 5, 1166, 584, 2,
	4354, 4356, 7, 29, 2, 2, 4355, 4357, 5, 476, 239, 2, 4356, 4355, 3, 2,
	2, 2, 4356, 4357, 3, 2, 2, 2, 4357, 4358, 3, 2, 2, 2, 4358, 4359, 7, 31,
	2, 2, 4359, 4361, 3, 2, 2, 2, 4360, 4341, 3, 2, 2, 2, 4360, 4352, 3, 2,
	2, 2, 4361, 4373, 3, 2, 2, 2, 4362, 4363, 7, 38, 2, 2, 4363, 4364, 7, 39,
	2, 2, 4364, 4365, 5, 1166, 584, 2, 4365, 4367, 7, 29, 2, 2, 4366, 4368,
	5, 476, 239, 2, 4367, 4366, 3, 2, 2, 2, 4367, 4368, 3, 2, 2, 2, 4368, 4369,
	3, 2, 2, 2, 4369, 4370, 7, 31, 2, 2, 4370, 4372, 3, 2, 2, 2, 4371, 4362,
	3, 2, 2, 2, 4372, 4375, 3, 2, 2, 2, 4373, 4371, 3, 2, 2, 2, 4373, 4374,
	3, 2, 2, 2, 4374, 475, 3, 2, 2, 2, 4375, 4373, 3, 2, 2, 2, 4376, 4379,
	5, 736, 369, 2, 4377, 4379, 5, 464, 233, 2, 4378, 4376, 3, 2, 2, 2, 4378,
	4377, 3, 2, 2, 2, 4379, 477, 3, 2, 2, 2, 4380, 4384, 5, 482, 242, 2, 4381,
	4384, 5, 484, 243, 2, 4382, 4384, 5, 486, 244, 2, 4383, 4380, 3, 2, 2,
	2, 4383, 4381, 3, 2, 2, 2, 4383, 4382, 3, 2, 2, 2, 4384, 479, 3, 2, 2,
	2, 4385, 4386, 5, 482, 242, 2, 4386, 481, 3, 2, 2, 2, 4387, 4392, 7, 52,
	2, 2, 4388, 4389, 7, 32, 2, 2, 4389, 4393, 5, 488, 245, 2, 4390, 4393,
	7, 32, 2, 2, 4391, 4393, 7, 69, 2, 2, 4392, 4388, 3, 2, 2, 2, 4392, 4390,
	3, 2, 2, 2, 4392, 4391, 3, 2, 2, 2, 4393, 4394, 3, 2, 2, 2, 4394, 4395,
	7, 54, 2, 2, 4395, 483, 3, 2, 2, 2, 4396, 4397, 7, 52, 2, 2, 4397, 4398,
	7, 80, 2, 2, 4398, 4399, 5, 488, 245, 2, 4399, 4400, 7, 54, 2, 2, 4400,
	485, 3, 2, 2, 2, 4401, 4402, 7, 52, 2, 2, 4402, 4403, 7, 87, 2, 2, 4403,
	4404, 5, 488, 245, 2, 4404, 4405, 7, 54, 2, 2, 4405, 487, 3, 2, 2, 2, 4406,
	4409, 5, 1016, 509, 2, 4407, 4409, 5, 490, 246, 2, 4408, 4406, 3, 2, 2,
	2, 4408, 4407, 3, 2, 2, 2, 4409, 489, 3, 2, 2, 2, 4410, 4411, 5, 1016,
	509, 2, 4411, 4414, 7, 43, 2, 2, 4412, 4415, 5, 1016, 509, 2, 4413, 4415,
	7, 16, 2, 2, 4414, 4412, 3, 2, 2, 2, 4414, 4413, 3, 2, 2, 2, 4415, 491,
	3, 2, 2, 2, 4416, 4422, 5, 1032, 517, 2, 4417, 4418, 7, 140, 2, 2, 4418,
	4419, 7, 58, 2, 2, 4419, 4420, 5, 182, 92, 2, 4420, 4421, 7, 64, 2, 2,
	4421, 4423, 3, 2, 2, 2, 4422, 4417, 3, 2, 2, 2, 4422, 4423, 3, 2, 2, 2,
	4423, 493, 3, 2, 2, 2, 4424, 4425, 5, 268, 135, 2, 4425, 4426, 5, 316,
	159, 2, 4426, 4427, 7, 48, 2, 2, 4427, 495, 3, 2, 2, 2, 4428, 4429, 7,
	132, 2, 2, 4429, 4435, 5, 1124, 563, 2, 4430, 4432, 7, 29, 2, 2, 4431,
	4433, 5, 384, 193, 2, 4432, 4431, 3, 2, 2, 2, 4432, 4433, 3, 2, 2, 2, 4433,
	4434, 3, 2, 2, 2, 4434, 4436, 7, 31, 2, 2, 4435, 4430, 3, 2, 2, 2, 4435,
	4436, 3, 2, 2, 2, 4436, 4438, 3, 2, 2, 2, 4437, 4439, 5, 504, 253, 2, 4438,
	4437, 3, 2, 2, 2, 4438, 4439, 3, 2, 2, 2, 4439, 4440, 3, 2, 2, 2, 4440,
	4444, 7, 48, 2, 2, 4441, 4443, 5, 498, 250, 2, 4442, 4441, 3, 2, 2, 2,
	4443, 4446, 3, 2, 2, 2, 4444, 4442, 3, 2, 2, 2, 4444, 4445, 3, 2, 2, 2,
	4445, 4447, 3, 2, 2, 2, 4446, 4444, 3, 2, 2, 2, 4447, 4450, 7, 152, 2,
	2, 4448, 4449, 7, 43, 2, 2, 4449, 4451, 5, 1124, 563, 2, 4450, 4448, 3,
	2, 2, 2, 4450, 4451, 3, 2, 2, 2, 4451, 497, 3, 2, 2, 2, 4452, 4454, 5,
	1094, 548, 2, 4453, 4452, 3, 2, 2, 2, 4454, 4457, 3, 2, 2, 2, 4455, 4453,
	3, 2, 2, 2, 4455, 4456, 3, 2, 2, 2, 4456, 4462, 3, 2, 2, 2, 4457, 4455,
	3, 2, 2, 2, 4458, 4463, 5, 502, 252, 2, 4459, 4460, 5, 500, 251, 2, 4460,
	4461, 7, 48, 2, 2, 4461, 4463, 3, 2, 2, 2, 4462, 4458, 3, 2, 2, 2, 4462,
	4459, 3, 2, 2, 2, 4463, 499, 3, 2, 2, 2, 4464, 4465, 7, 231, 2, 2, 4465,
	4466, 7, 39, 2, 2, 4466, 4467, 7, 216, 2, 2, 4467, 4468, 7, 80, 2, 2, 4468,
	4475, 5, 1032, 517, 2, 4469, 4470, 7, 316, 2, 2, 4470, 4471, 7, 39, 2,
	2, 4471, 4472, 7, 216, 2, 2, 4472, 4473, 7, 80, 2, 2, 4473, 4475, 5, 1016,
	509, 2, 4474, 4464, 3, 2, 2, 2, 4474, 4469, 3, 2, 2, 2, 4475, 501, 3, 2,
	2, 2, 4476, 4479, 5, 510, 256, 2, 4477, 4479, 5, 528, 265, 2, 4478, 4476,
	3, 2, 2, 2, 4478, 4477, 3, 2, 2, 2, 4479, 503, 3, 2, 2, 2, 4480, 4487,
	5, 840, 421, 2, 4481, 4482, 7, 51, 2, 2, 4482, 4483, 7, 29, 2, 2, 4483,
	4484, 5, 506, 254, 2, 4484, 4485, 7, 31, 2, 2, 4485, 4487, 3, 2, 2, 2,
	4486, 4480, 3, 2, 2, 2, 4486, 4481, 3, 2, 2, 2, 4487, 505, 3, 2, 2, 2,
	4488, 4489, 8, 254, 1, 2, 4489, 4490, 9, 33, 2, 2, 4490, 4491, 5, 508,
	255, 2, 4491, 4497, 3, 2, 2, 2, 4492, 4493, 12, 4, 2, 2, 4493, 4494, 7,
	232, 2, 2, 4494, 4496, 5, 506, 254, 5, 4495, 4492, 3, 2, 2, 2, 4496, 4499,
	3, 2, 2, 2, 4497, 4495, 3, 2, 2, 2, 4497, 4498, 3, 2, 2, 2, 4498, 507,
	3, 2, 2, 2, 4499, 4497, 3, 2, 2, 2, 4500, 4510, 5, 1162, 582, 2, 4501,
	4510, 5, 1146, 574, 2, 4502, 4503, 5, 1150, 576, 2, 4503, 4504, 7, 39,
	2, 2, 4504, 4507, 3, 2, 2, 2, 4505, 4507, 5, 250, 126, 2, 4506, 4502, 3,
	2, 2, 2, 4506, 4505, 3, 2, 2, 2, 4506, 4507, 3, 2, 2, 2, 4507, 4508, 3,
	2, 2, 2, 4508, 4510, 5, 1184, 593, 2, 4509, 4500, 3, 2, 2, 2, 4509, 4501,
	3, 2, 2, 2, 4509, 4506, 3, 2, 2, 2, 4510, 509, 3, 2, 2, 2, 4511, 4513,
	5, 242, 122, 2, 4512, 4511, 3, 2, 2, 2, 4512, 4513, 3, 2, 2, 2, 4513, 4514,
	3, 2, 2, 2, 4514, 4515, 5, 1128, 565, 2, 4515, 4516, 7, 43, 2, 2, 4516,
	4518, 3, 2, 2, 2, 4517, 4512, 3, 2, 2, 2, 4517, 4518, 3, 2, 2, 2, 4518,
	4519, 3, 2, 2, 2, 4519, 4520, 7, 133, 2, 2, 4520, 4526, 5, 1032, 517, 2,
	4521, 4522, 7, 183, 2, 2, 4522, 4523, 7, 29, 2, 2, 4523, 4524, 5, 1032,
	517, 2, 4524, 4525, 7, 31, 2, 2, 4525, 4527, 3, 2, 2, 2, 4526, 4521, 3,
	2, 2, 2, 4526, 4527, 3, 2, 2, 2, 4527, 4528, 3, 2, 2, 2, 4528, 4529, 5,
	512, 257, 2, 4529, 511, 3, 2, 2, 2, 4530, 4534, 7, 58, 2, 2, 4531, 4533,
	5, 1094, 548, 2, 4532, 4531, 3, 2, 2, 2, 4533, 4536, 3, 2, 2, 2, 4534,
	4532, 3, 2, 2, 2, 4534, 4535, 3, 2, 2, 2, 4535, 4542, 3, 2, 2, 2, 4536,
	4534, 3, 2, 2, 2, 4537, 4538, 5, 514, 258, 2, 4538, 4539, 7, 48, 2, 2,
	4539, 4541, 3, 2, 2, 2, 4540, 4537, 3, 2, 2, 2, 4541, 4544, 3, 2, 2, 2,
	4542, 4540, 3, 2, 2, 2, 4542, 4543, 3, 2, 2, 2, 4543, 4545, 3, 2, 2, 2,
	4544, 4542, 3, 2, 2, 2, 4545, 4548, 7, 64, 2, 2, 4546, 4548, 7, 48, 2,
	2, 4547, 4530, 3, 2, 2, 2, 4547, 4546, 3, 2, 2, 2, 4548, 513, 3, 2, 2,
	2, 4549, 4621, 5, 500, 251, 2, 4550, 4552, 7, 338, 2, 2, 4551, 4550, 3,
	2, 2, 2, 4551, 4552, 3, 2, 2, 2, 4552, 4553, 3, 2, 2, 2, 4553, 4554, 5,
	516, 259, 2, 4554, 4588, 5, 1104, 553, 2, 4555, 4557, 7, 52, 2, 2, 4556,
	4558, 5, 560, 281, 2, 4557, 4556, 3, 2, 2, 2, 4557, 4558, 3, 2, 2, 2, 4558,
	4559, 3, 2, 2, 2, 4559, 4561, 7, 54, 2, 2, 4560, 4555, 3, 2, 2, 2, 4560,
	4561, 3, 2, 2, 2, 4561, 4562, 3, 2, 2, 2, 4562, 4580, 7, 80, 2, 2, 4563,
	4564, 7, 58, 2, 2, 4564, 4565, 5, 548, 275, 2, 4565, 4571, 7, 64, 2, 2,
	4566, 4567, 7, 340, 2, 2, 4567, 4568, 7, 29, 2, 2, 4568, 4569, 5, 552,
	277, 2, 4569, 4570, 7, 31, 2, 2, 4570, 4572, 3, 2, 2, 2, 4571, 4566, 3,
	2, 2, 2, 4571, 4572, 3, 2, 2, 2, 4572, 4581, 3, 2, 2, 2, 4573, 4574, 5,
	1128, 565, 2, 4574, 4575, 7, 340, 2, 2, 4575, 4576, 7, 29, 2, 2, 4576,
	4577, 5, 552, 277, 2, 4577, 4578, 7, 31, 2, 2, 4578, 4581, 3, 2, 2, 2,
	4579, 4581, 5, 554, 278, 2, 4580, 4563, 3, 2, 2, 2, 4580, 4573, 3, 2, 2,
	2, 4580, 4579, 3, 2, 2, 2, 4581, 4589, 3, 2, 2, 2, 4582, 4583, 7, 52, 2,
	2, 4583, 4585, 7, 54, 2, 2, 4584, 4582, 3, 2, 2, 2, 4584, 4585, 3, 2, 2,
	2, 4585, 4586, 3, 2, 2, 2, 4586, 4587, 7, 80, 2, 2, 4587, 4589, 5, 518,
	260, 2, 4588, 4560, 3, 2, 2, 2, 4588, 4584, 3, 2, 2, 2, 4589, 4595, 3,
	2, 2, 2, 4590, 4591, 7, 183, 2, 2, 4591, 4592, 7, 29, 2, 2, 4592, 4593,
	5, 1032, 517, 2, 4593, 4594, 7, 31, 2, 2, 4594, 4596, 3, 2, 2, 2, 4595,
	4590, 3, 2, 2, 2, 4595, 4596, 3, 2, 2, 2, 4596, 4621, 3, 2, 2, 2, 4597,
	4598, 5, 516, 259, 2, 4598, 4611, 5, 1104, 553, 2, 4599, 4601, 7, 52, 2,
	2, 4600, 4602, 5, 560, 281, 2, 4601, 4600, 3, 2, 2, 2, 4601, 4602, 3, 2,
	2, 2, 4602, 4603, 3, 2, 2, 2, 4603, 4605, 7, 54, 2, 2, 4604, 4599, 3, 2,
	2, 2, 4604, 4605, 3, 2, 2, 2, 4605, 4606, 3, 2, 2, 2, 4606, 4607, 7, 80,
	2, 2, 4607, 4612, 7, 136, 2, 2, 4608, 4609, 7, 80, 2, 2, 4609, 4610, 7,
	136, 2, 2, 4610, 4612, 7, 277, 2, 2, 4611, 4604, 3, 2, 2, 2, 4611, 4608,
	3, 2, 2, 2, 4612, 4618, 3, 2, 2, 2, 4613, 4614, 7, 183, 2, 2, 4614, 4615,
	7, 29, 2, 2, 4615, 4616, 5, 1032, 517, 2, 4616, 4617, 7, 31, 2, 2, 4617,
	4619, 3, 2, 2, 2, 4618, 4613, 3, 2, 2, 2, 4618, 4619, 3, 2, 2, 2, 4619,
	4621, 3, 2, 2, 2, 4620, 4549, 3, 2, 2, 2, 4620, 4551, 3, 2, 2, 2, 4620,
	4597, 3, 2, 2, 2, 4621, 515, 3, 2, 2, 2, 4622, 4623, 9, 34, 2, 2, 4623,
	517, 3, 2, 2, 2, 4624, 4625, 7, 29, 2, 2, 4625, 4626, 5, 520, 261, 2, 4626,
	4634, 7, 31, 2, 2, 4627, 4628, 7, 38, 2, 2, 4628, 4629, 7, 29, 2, 2, 4629,
	4630, 5, 520, 261, 2, 4630, 4631, 7, 31, 2, 2, 4631, 4633, 3, 2, 2, 2,
	4632, 4627, 3, 2, 2, 2, 4633, 4636, 3, 2, 2, 2, 4634, 4632, 3, 2, 2, 2,
	4634, 4635, 3, 2, 2, 2, 4635, 519, 3, 2, 2, 2, 4636, 4634, 3, 2, 2, 2,
	4637, 4642, 5, 522, 262, 2, 4638, 4639, 7, 85, 2, 2, 4639, 4641, 5, 522,
	262, 2, 4640, 4638, 3, 2, 2, 2, 4641, 4644, 3, 2, 2, 2, 4642, 4640, 3,
	2, 2, 2, 4642, 4643, 3, 2, 2, 2, 4643, 521, 3, 2, 2, 2, 4644, 4642, 3,
	2, 2, 2, 4645, 4651, 5, 524, 263, 2, 4646, 4647, 7, 52, 2, 2, 4647, 4648,
	9, 35, 2, 2, 4648, 4649, 5, 526, 264, 2, 4649, 4650, 7, 54, 2, 2, 4650,
	4652, 3, 2, 2, 2, 4651, 4646, 3, 2, 2, 2, 4651, 4652, 3, 2, 2, 2, 4652,
	523, 3, 2, 2, 2, 4653, 4654, 5, 548, 275, 2, 4654, 525, 3, 2, 2, 2, 4655,
	4658, 5, 560, 281, 2, 4656, 4657, 7, 43, 2, 2, 4657, 4659, 5, 560, 281,
	2, 4658, 4656, 3, 2, 2, 2, 4658, 4659, 3, 2, 2, 2, 4659, 527, 3, 2, 2,
	2, 4660, 4661, 5, 1130, 566, 2, 4661, 4662, 7, 43, 2, 2, 4662, 4664, 3,
	2, 2, 2, 4663, 4660, 3, 2, 2, 2, 4663, 4664, 3, 2, 2, 2, 4664, 4665, 3,
	2, 2, 2, 4665, 4666, 7, 134, 2, 2, 4666, 4672, 5, 530, 266, 2, 4667, 4668,
	7, 183, 2, 2, 4668, 4669, 7, 29, 2, 2, 4669, 4670, 5, 1032, 517, 2, 4670,
	4671, 7, 31, 2, 2, 4671, 4673, 3, 2, 2, 2, 4672, 4667, 3, 2, 2, 2, 4672,
	4673, 3, 2, 2, 2, 4673, 4674, 3, 2, 2, 2, 4674, 4675, 5, 534, 268, 2, 4675,
	529, 3, 2, 2, 2, 4676, 4677, 5, 532, 267, 2, 4677, 4678, 7, 38, 2, 2, 4678,
	4683, 5, 532, 267, 2, 4679, 4680, 7, 38, 2, 2, 4680, 4682, 5, 532, 267,
	2, 4681, 4679, 3, 2, 2, 2, 4682, 4685, 3, 2, 2, 2, 4683, 4681, 3, 2, 2,
	2, 4683, 4684, 3, 2, 2, 2, 4684, 531, 3, 2, 2, 2, 4685, 4683, 3, 2, 2,
	2, 4686, 4689, 5, 1128, 565, 2, 4687, 4689, 5, 1246, 624, 2, 4688, 4686,
	3, 2, 2, 2, 4688, 4687, 3, 2, 2, 2, 4689, 533, 3, 2, 2, 2, 4690, 4696,
	7, 58, 2, 2, 4691, 4692, 5, 536, 269, 2, 4692, 4693, 7, 48, 2, 2, 4693,
	4695, 3, 2, 2, 2, 4694, 4691, 3, 2, 2, 2, 4695, 4698, 3, 2, 2, 2, 4696,
	4694, 3, 2, 2, 2, 4696, 4697, 3, 2, 2, 2, 4697, 4699, 3, 2, 2, 2, 4698,
	4696, 3, 2, 2, 2, 4699, 4702, 7, 64, 2, 2, 4700, 4702, 7, 48, 2, 2, 4701,
	4690, 3, 2, 2, 2, 4701, 4700, 3, 2, 2, 2, 4702, 535, 3, 2, 2, 2, 4703,
	4708, 5, 360, 181, 2, 4704, 4705, 5, 538, 270, 2, 4705, 4706, 7, 48, 2,
	2, 4706, 4708, 3, 2, 2, 2, 4707, 4703, 3, 2, 2, 2, 4707, 4704, 3, 2, 2,
	2, 4708, 537, 3, 2, 2, 2, 4709, 4711, 5, 1094, 548, 2, 4710, 4709, 3, 2,
	2, 2, 4711, 4714, 3, 2, 2, 2, 4712, 4710, 3, 2, 2, 2, 4712, 4713, 3, 2,
	2, 2, 4713, 4717, 3, 2, 2, 2, 4714, 4712, 3, 2, 2, 2, 4715, 4718, 5, 500,
	251, 2, 4716, 4718, 5, 540, 271, 2, 4717, 4715, 3, 2, 2, 2, 4717, 4716,
	3, 2, 2, 2, 4718, 539, 3, 2, 2, 2, 4719, 4720, 5, 516, 259, 2, 4720, 4721,
	5, 1104, 553, 2, 4721, 4722, 7, 80, 2, 2, 4722, 4728, 5, 542, 272, 2, 4723,
	4724, 7, 183, 2, 2, 4724, 4725, 7, 29, 2, 2, 4725, 4726, 5, 1032, 517,
	2, 4726, 4727, 7, 31, 2, 2, 4727, 4729, 3, 2, 2, 2, 4728, 4723, 3, 2, 2,
	2, 4728, 4729, 3, 2, 2, 2, 4729, 541, 3, 2, 2, 2, 4730, 4732, 8, 272, 1,
	2, 4731, 4733, 7, 5, 2, 2, 4732, 4731, 3, 2, 2, 2, 4732, 4733, 3, 2, 2,
	2, 4733, 4734, 3, 2, 2, 2, 4734, 4746, 5, 544, 273, 2, 4735, 4736, 7, 29,
	2, 2, 4736, 4737, 5, 542, 272, 2, 4737, 4738, 7, 31, 2, 2, 4738, 4746,
	3, 2, 2, 2, 4739, 4746, 5, 1130, 566, 2, 4740, 4743, 5, 558, 280, 2, 4741,
	4742, 7, 214, 2, 2, 4742, 4744, 5, 556, 279, 2, 4743, 4741, 3, 2, 2, 2,
	4743, 4744, 3, 2, 2, 2, 4744, 4746, 3, 2, 2, 2, 4745, 4730, 3, 2, 2, 2,
	4745, 4735, 3, 2, 2, 2, 4745, 4739, 3, 2, 2, 2, 4745, 4740, 3, 2, 2, 2,
	4746, 4761, 3, 2, 2, 2, 4747, 4748, 12, 7, 2, 2, 4748, 4749, 9, 36, 2,
	2, 4749, 4760, 5, 542, 272, 8, 4750, 4751, 12, 5, 2, 2, 4751, 4752, 7,
	340, 2, 2, 4752, 4753, 7, 29, 2, 2, 4753, 4754, 5, 552, 277, 2, 4754, 4757,
	7, 31, 2, 2, 4755, 4756, 7, 214, 2, 2, 4756, 4758, 5, 556, 279, 2, 4757,
	4755, 3, 2, 2, 2, 4757, 4758, 3, 2, 2, 2, 4758, 4760, 3, 2, 2, 2, 4759,
	4747, 3, 2, 2, 2, 4759, 4750, 3, 2, 2, 2, 4760, 4763, 3, 2, 2, 2, 4761,
	4759, 3, 2, 2, 2, 4761, 4762, 3, 2, 2, 2, 4762, 543, 3, 2, 2, 2, 4763,
	4761, 3, 2, 2, 2, 4764, 4765, 7, 110, 2, 2, 4765, 4766, 7, 29, 2, 2, 4766,
	4767, 5, 546, 274, 2, 4767, 4773, 7, 31, 2, 2, 4768, 4769, 7, 201, 2, 2,
	4769, 4770, 7, 58, 2, 2, 4770, 4771, 5, 548, 275, 2, 4771, 4772, 7, 64,
	2, 2, 4772, 4774, 3, 2, 2, 2, 4773, 4768, 3, 2, 2, 2, 4773, 4774, 3, 2,
	2, 2, 4774, 545, 3, 2, 2, 2, 4775, 4782, 5, 1246, 624, 2, 4776, 4779, 5,
	1128, 565, 2, 4777, 4778, 7, 39, 2, 2, 4778, 4780, 5, 1104, 553, 2, 4779,
	4777, 3, 2, 2, 2, 4779, 4780, 3, 2, 2, 2, 4780, 4782, 3, 2, 2, 2, 4781,
	4775, 3, 2, 2, 2, 4781, 4776, 3, 2, 2, 2, 4782, 547, 3, 2, 2, 2, 4783,
	4788, 5, 550, 276, 2, 4784, 4785, 7, 38, 2, 2, 4785, 4787, 5, 550, 276,
	2, 4786, 4784, 3, 2, 2, 2, 4787, 4790, 3, 2, 2, 2, 4788, 4786, 3, 2, 2,
	2, 4788, 4789, 3, 2, 2, 2, 4789, 549, 3, 2, 2, 2, 4790, 4788, 3, 2, 2,
	2, 4791, 4799, 5, 560, 281, 2, 4792, 4793, 7, 52, 2, 2, 4793, 4794, 5,
	560, 281, 2, 4794, 4795, 7, 43, 2, 2, 4795, 4796, 5, 560, 281, 2, 4796,
	4797, 7, 54, 2, 2, 4797, 4799, 3, 2, 2, 2, 4798, 4791, 3, 2, 2, 2, 4798,
	4792, 3, 2, 2, 2, 4799, 551, 3, 2, 2, 2, 4800, 4801, 5, 560, 281, 2, 4801,
	553, 3, 2, 2, 2, 4802, 4803, 5, 560, 281, 2, 4803, 555, 3, 2, 2, 2, 4804,
	4805, 5, 560, 281, 2, 4805, 557, 3, 2, 2, 2, 4806, 4807, 5, 560, 281, 2,
	4807, 559, 3, 2, 2, 2, 4808, 4809, 5, 1032, 517, 2, 4809, 561, 3, 2, 2,
	2, 4810, 4811, 7, 206, 2, 2, 4811, 4817, 5, 564, 283, 2, 4812, 4814, 7,
	29, 2, 2, 4813, 4815, 5, 566, 284, 2, 4814, 4813, 3, 2, 2, 2, 4814, 4815,
	3, 2, 2, 2, 4815, 4816, 3, 2, 2, 2, 4816, 4818, 7, 31, 2, 2, 4817, 4812,
	3, 2, 2, 2, 4817, 4818, 3, 2, 2, 2, 4818, 4819, 3, 2, 2, 2, 4819, 4820,
	7, 80, 2, 2, 4820, 4821, 5, 1032, 517, 2, 4821, 4822, 7, 48, 2, 2, 4822,
	563, 3, 2, 2, 2, 4823, 4824, 5, 1166, 584, 2, 4824, 565, 3, 2, 2, 2, 4825,
	4830, 5, 568, 285, 2, 4826, 4827, 7, 38, 2, 2, 4827, 4829, 5, 568, 285,
	2, 4828, 4826, 3, 2, 2, 2, 4829, 4832, 3, 2, 2, 2, 4830, 4828, 3, 2, 2,
	2, 4830, 4831, 3, 2, 2, 2, 4831, 567, 3, 2, 2, 2, 4832, 4830, 3, 2, 2,
	2, 4833, 4835, 5, 1094, 548, 2, 4834, 4833, 3, 2, 2, 2, 4835, 4838, 3,
	2, 2, 2, 4836, 4834, 3, 2, 2, 2, 4836, 4837, 3, 2, 2, 2, 4837, 4839, 3,
	2, 2, 2, 4838, 4836, 3, 2, 2, 2, 4839, 4840, 5, 570, 286, 2, 4840, 4844,
	5, 1136, 569, 2, 4841, 4843, 5, 352, 177, 2, 4842, 4841, 3, 2, 2, 2, 4843,
	4846, 3, 2, 2, 2, 4844, 4842, 3, 2, 2, 2, 4844, 4845, 3, 2, 2, 2, 4845,
	4849, 3, 2, 2, 2, 4846, 4844, 3, 2, 2, 2, 4847, 4848, 7, 80, 2, 2, 4848,
	4850, 5, 1032, 517, 2, 4849, 4847, 3, 2, 2, 2, 4849, 4850, 3, 2, 2, 2,
	4850, 569, 3, 2, 2, 2, 4851, 4854, 5, 242, 122, 2, 4852, 4854, 7, 324,
	2, 2, 4853, 4851, 3, 2, 2, 2, 4853, 4852, 3, 2, 2, 2, 4854, 571, 3, 2,
	2, 2, 4855, 4857, 5, 1198, 600, 2, 4856, 4855, 3, 2, 2, 2, 4856, 4857,
	3, 2, 2, 2, 4857, 4858, 3, 2, 2, 2, 4858, 4864, 5, 564, 283, 2, 4859, 4861,
	7, 29, 2, 2, 4860, 4862, 5, 574, 288, 2, 4861, 4860, 3, 2, 2, 2, 4861,
	4862, 3, 2, 2, 2, 4862, 4863, 3, 2, 2, 2, 4863, 4865, 7, 31, 2, 2, 4864,
	4859, 3, 2, 2, 2, 4864, 4865, 3, 2, 2, 2, 4865, 573, 3, 2, 2, 2, 4866,
	4868, 5, 576, 289, 2, 4867, 4866, 3, 2, 2, 2, 4867, 4868, 3, 2, 2, 2, 4868,
	4875, 3, 2, 2, 2, 4869, 4871, 7, 38, 2, 2, 4870, 4872, 5, 576, 289, 2,
	4871, 4870, 3, 2, 2, 2, 4871, 4872, 3, 2, 2, 2, 4872, 4874, 3, 2, 2, 2,
	4873, 4869, 3, 2, 2, 2, 4874, 4877, 3, 2, 2, 2, 4875, 4873, 3, 2, 2, 2,
	4875, 4876, 3, 2, 2, 2, 4876, 4887, 3, 2, 2, 2, 4877, 4875, 3, 2, 2, 2,
	4878, 4879, 7, 39, 2, 2, 4879, 4880, 5, 1166, 584, 2, 4880, 4882, 7, 29,
	2, 2, 4881, 4883, 5, 576, 289, 2, 4882, 4881, 3, 2, 2, 2, 4882, 4883, 3,
	2, 2, 2, 4883, 4884, 3, 2, 2, 2, 4884, 4885, 7, 31, 2, 2, 4885, 4887, 3,
	2, 2, 2, 4886, 4867, 3, 2, 2, 2, 4886, 4878, 3, 2, 2, 2, 4887, 4899, 3,
	2, 2, 2, 4888, 4889, 7, 38, 2, 2, 4889, 4890, 7, 39, 2, 2, 4890, 4891,
	5, 1166, 584, 2, 4891, 4893, 7, 29, 2, 2, 4892, 4894, 5, 576, 289, 2, 4893,
	4892, 3, 2, 2, 2, 4893, 4894, 3, 2, 2, 2, 4894, 4895, 3, 2, 2, 2, 4895,
	4896, 7, 31, 2, 2, 4896, 4898, 3, 2, 2, 2, 4897, 4888, 3, 2, 2, 2, 4898,
	4901, 3, 2, 2, 2, 4899, 4897, 3, 2, 2, 2, 4899, 4900, 3, 2, 2, 2, 4900,
	575, 3, 2, 2, 2, 4901, 4899, 3, 2, 2, 2, 4902, 4903, 5, 1032, 517, 2, 4903,
	577, 3, 2, 2, 2, 4904, 4906, 5, 612, 307, 2, 4905, 4907, 5, 290, 146, 2,
	4906, 4905, 3, 2, 2, 2, 4906, 4907, 3, 2, 2, 2, 4907, 4908, 3, 2, 2, 2,
	4908, 4913, 5, 580, 291, 2, 4909, 4910, 7, 38, 2, 2, 4910, 4912, 5, 580,
	291, 2, 4911, 4909, 3, 2, 2, 2, 4912, 4915, 3, 2, 2, 2, 4913, 4911, 3,
	2, 2, 2, 4913, 4914, 3, 2, 2, 2, 4914, 4916, 3, 2, 2, 2, 4915, 4913, 3,
	2, 2, 2, 4916, 4917, 7, 48, 2, 2, 4917, 5037, 3, 2, 2, 2, 4918, 4920, 5,
	614, 308, 2, 4919, 4921, 5, 282, 142, 2, 4920, 4919, 3, 2, 2, 2, 4920,
	4921, 3, 2, 2, 2, 4921, 4923, 3, 2, 2, 2, 4922, 4924, 5, 290, 146, 2, 4923,
	4922, 3, 2, 2, 2, 4923, 4924, 3, 2, 2, 2, 4924, 4925, 3, 2, 2, 2, 4925,
	4930, 5, 582, 292, 2, 4926, 4927, 7, 38, 2, 2, 4927, 4929, 5, 582, 292,
	2, 4928, 4926, 3, 2, 2, 2, 4929, 4932, 3, 2, 2, 2, 4930, 4928, 3, 2, 2,
	2, 4930, 4931, 3, 2, 2, 2, 4931, 4933, 3, 2, 2, 2, 4932, 4930, 3, 2, 2,
	2, 4933, 4934, 7, 48, 2, 2, 4934, 5037, 3, 2, 2, 2, 4935, 4937, 5, 616,
	309, 2, 4936, 4938, 5, 290, 146, 2, 4937, 4936, 3, 2, 2, 2, 4937, 4938,
	3, 2, 2, 2, 4938, 4939, 3, 2, 2, 2, 4939, 4944, 5, 584, 293, 2, 4940, 4941,
	7, 38, 2, 2, 4941, 4943, 5, 584, 293, 2, 4942, 4940, 3, 2, 2, 2, 4943,
	4946, 3, 2, 2, 2, 4944, 4942, 3, 2, 2, 2, 4944, 4945, 3, 2, 2, 2, 4945,
	4947, 3, 2, 2, 2, 4946, 4944, 3, 2, 2, 2, 4947, 4948, 7, 48, 2, 2, 4948,
	5037, 3, 2, 2, 2, 4949, 4951, 5, 618, 310, 2, 4950, 4952, 5, 282, 142,
	2, 4951, 4950, 3, 2, 2, 2, 4951, 4952, 3, 2, 2, 2, 4952, 4954, 3, 2, 2,
	2, 4953, 4955, 5, 292, 147, 2, 4954, 4953, 3, 2, 2, 2, 4954, 4955, 3, 2,
	2, 2, 4955, 4956, 3, 2, 2, 2, 4956, 4961, 5, 586, 294, 2, 4957, 4958, 7,
	38, 2, 2, 4958, 4960, 5, 586, 294, 2, 4959, 4957, 3, 2, 2, 2, 4960, 4963,
	3, 2, 2, 2, 4961, 4959, 3, 2, 2, 2, 4961, 4962, 3, 2, 2, 2, 4962, 4964,
	3, 2, 2, 2, 4963, 4961, 3, 2, 2, 2, 4964, 4965, 7, 48, 2, 2, 4965, 5037,
	3, 2, 2, 2, 4966, 4968, 5, 620, 311, 2, 4967, 4969, 5, 282, 142, 2, 4968,
	4967, 3, 2, 2, 2, 4968, 4969, 3, 2, 2, 2, 4969, 4971, 3, 2, 2, 2, 4970,
	4972, 5, 292, 147, 2, 4971, 4970, 3, 2, 2, 2, 4971, 4972, 3, 2, 2, 2, 4972,
	4973, 3, 2, 2, 2, 4973, 4978, 5, 588, 295, 2, 4974, 4975, 7, 38, 2, 2,
	4975, 4977, 5, 588, 295, 2, 4976, 4974, 3, 2, 2, 2, 4977, 4980, 3, 2, 2,
	2, 4978, 4976, 3, 2, 2, 2, 4978, 4979, 3, 2, 2, 2, 4979, 4981, 3, 2, 2,
	2, 4980, 4978, 3, 2, 2, 2, 4981, 4982, 7, 48, 2, 2, 4982, 5037, 3, 2, 2,
	2, 4983, 4985, 5, 622, 312, 2, 4984, 4986, 5, 292, 147, 2, 4985, 4984,
	3, 2, 2, 2, 4985, 4986, 3, 2, 2, 2, 4986, 4987, 3, 2, 2, 2, 4987, 4992,
	5, 592, 297, 2, 4988, 4989, 7, 38, 2, 2, 4989, 4991, 5, 592, 297, 2, 4990,
	4988, 3, 2, 2, 2, 4991, 4994, 3, 2, 2, 2, 4992, 4990, 3, 2, 2, 2, 4992,
	4993, 3, 2, 2, 2, 4993, 4995, 3, 2, 2, 2, 4994, 4992, 3, 2, 2, 2, 4995,
	4996, 7, 48, 2, 2, 4996, 5037, 3, 2, 2, 2, 4997, 4998, 5, 624, 313, 2,
	4998, 5003, 5, 590, 296, 2, 4999, 5000, 7, 38, 2, 2, 5000, 5002, 5, 590,
	296, 2, 5001, 4999, 3, 2, 2, 2, 5002, 5005, 3, 2, 2, 2, 5003, 5001, 3,
	2, 2, 2, 5003, 5004, 3, 2, 2, 2, 5004, 5006, 3, 2, 2, 2, 5005, 5003, 3,
	2, 2, 2, 5006, 5007, 7, 48, 2, 2, 5007, 5037, 3, 2, 2, 2, 5008, 5010, 7,
	246, 2, 2, 5009, 5011, 5, 596, 299, 2, 5010, 5009, 3, 2, 2, 2, 5010, 5011,
	3, 2, 2, 2, 5011, 5012, 3, 2, 2, 2, 5012, 5017, 5, 594, 298, 2, 5013, 5014,
	7, 38, 2, 2, 5014, 5016, 5, 594, 298, 2, 5015, 5013, 3, 2, 2, 2, 5016,
	5019, 3, 2, 2, 2, 5017, 5015, 3, 2, 2, 2, 5017, 5018, 3, 2, 2, 2, 5018,
	5020, 3, 2, 2, 2, 5019, 5017, 3, 2, 2, 2, 5020, 5021, 7, 48, 2, 2, 5021,
	5037, 3, 2, 2, 2, 5022, 5024, 7, 247, 2, 2, 5023, 5025, 5, 598, 300, 2,
	5024, 5023, 3, 2, 2, 2, 5024, 5025, 3, 2, 2, 2, 5025, 5026, 3, 2, 2, 2,
	5026, 5031, 5, 594, 298, 2, 5027, 5028, 7, 38, 2, 2, 5028, 5030, 5, 594,
	298, 2, 5029, 5027, 3, 2, 2, 2, 5030, 5033, 3, 2, 2, 2, 5031, 5029, 3,
	2, 2, 2, 5031, 5032, 3, 2, 2, 2, 5032, 5034, 3, 2, 2, 2, 5033, 5031, 3,
	2, 2, 2, 5034, 5035, 7, 48, 2, 2, 5035, 5037, 3, 2, 2, 2, 5036, 4904, 3,
	2, 2, 2, 5036, 4918, 3, 2, 2, 2, 5036, 4935, 3, 2, 2, 2, 5036, 4949, 3,
	2, 2, 2, 5036, 4966, 3, 2, 2, 2, 5036, 4983, 3, 2, 2, 2, 5036, 4997, 3,
	2, 2, 2, 5036, 5008, 3, 2, 2, 2, 5036, 5022, 3, 2, 2, 2, 5037, 579, 3,
	2, 2, 2, 5038, 5040, 5, 638, 320, 2, 5039, 5038, 3, 2, 2, 2, 5039, 5040,
	3, 2, 2, 2, 5040, 5041, 3, 2, 2, 2, 5041, 5042, 7, 29, 2, 2, 5042, 5043,
	5, 608, 305, 2, 5043, 5044, 7, 38, 2, 2, 5044, 5045, 5, 604, 303, 2, 5045,
	5046, 7, 38, 2, 2, 5046, 5047, 5, 606, 304, 2, 5047, 5048, 7, 38, 2, 2,
	5048, 5049, 5, 610, 306, 2, 5049, 5050, 7, 31, 2, 2, 5050, 581, 3, 2, 2,
	2, 5051, 5053, 5, 638, 320, 2, 5052, 5051, 3, 2, 2, 2, 5052, 5053, 3, 2,
	2, 2, 5053, 5054, 3, 2, 2, 2, 5054, 5055, 7, 29, 2, 2, 5055, 5056, 5, 608,
	305, 2, 5056, 5057, 7, 38, 2, 2, 5057, 5058, 5, 604, 303, 2, 5058, 5059,
	7, 38, 2, 2, 5059, 5060, 5, 600, 301, 2, 5060, 5061, 7, 31, 2, 2, 5061,
	583, 3, 2, 2, 2, 5062, 5064, 5, 638, 320, 2, 5063, 5062, 3, 2, 2, 2, 5063,
	5064, 3, 2, 2, 2, 5064, 5065, 3, 2, 2, 2, 5065, 5066, 7, 29, 2, 2, 5066,
	5067, 5, 608, 305, 2, 5067, 5068, 7, 38, 2, 2, 5068, 5069, 5, 604, 303,
	2, 5069, 5070, 7, 38, 2, 2, 5070, 5071, 5, 600, 301, 2, 5071, 5072, 7,
	31, 2, 2, 5072, 585, 3, 2, 2, 2, 5073, 5075, 5, 638, 320, 2, 5074, 5073,
	3, 2, 2, 2, 5074, 5075, 3, 2, 2, 2, 5075, 5076, 3, 2, 2, 2, 5076, 5077,
	7, 29, 2, 2, 5077, 5078, 5, 608, 305, 2, 5078, 5079, 7, 38, 2, 2, 5079,
	5084, 5, 604, 303, 2, 5080, 5081, 7, 38, 2, 2, 5081, 5083, 5, 604, 303,
	2, 5082, 5080, 3, 2, 2, 2, 5083, 5086, 3, 2, 2, 2, 5084, 5082, 3, 2, 2,
	2, 5084, 5085, 3, 2, 2, 2, 5085, 5087, 3, 2, 2, 2, 5086, 5084, 3, 2, 2,
	2, 5087, 5088, 7, 31, 2, 2, 5088, 587, 3, 2, 2, 2, 5089, 5091, 5, 638,
	320, 2, 5090, 5089, 3, 2, 2, 2, 5090, 5091, 3, 2, 2, 2, 5091, 5092, 3,
	2, 2, 2, 5092, 5093, 7, 29, 2, 2, 5093, 5098, 5, 608, 305, 2, 5094, 5095,
	7, 38, 2, 2, 5095, 5097, 5, 608, 305, 2, 5096, 5094, 3, 2, 2, 2, 5097,
	5100, 3, 2, 2, 2, 5098, 5096, 3, 2, 2, 2, 5098, 5099, 3, 2, 2, 2, 5099,
	5101, 3, 2, 2, 2, 5100, 5098, 3, 2, 2, 2, 5101, 5102, 7, 38, 2, 2, 5102,
	5103, 5, 604, 303, 2, 5103, 5104, 7, 31, 2, 2, 5104, 589, 3, 2, 2, 2, 5105,
	5107, 5, 638, 320, 2, 5106, 5105, 3, 2, 2, 2, 5106, 5107, 3, 2, 2, 2, 5107,
	5108, 3, 2, 2, 2, 5108, 5109, 7, 29, 2, 2, 5109, 5110, 5, 602, 302, 2,
	5110, 5111, 7, 38, 2, 2, 5111, 5112, 5, 602, 302, 2, 5112, 5113, 7, 31,
	2, 2, 5113, 591, 3, 2, 2, 2, 5114, 5116, 5, 638, 320, 2, 5115, 5114, 3,
	2, 2, 2, 5115, 5116, 3, 2, 2, 2, 5116, 5117, 3, 2, 2, 2, 5117, 5118, 7,
	29, 2, 2, 5118, 5119, 5, 602, 302, 2, 5119, 5120, 7, 38, 2, 2, 5120, 5121,
	5, 602, 302, 2, 5121, 5122, 7, 38, 2, 2, 5122, 5123, 5, 600, 301, 2, 5123,
	5124, 7, 31, 2, 2, 5124, 593, 3, 2, 2, 2, 5125, 5127, 5, 638, 320, 2, 5126,
	5125, 3, 2, 2, 2, 5126, 5127, 3, 2, 2, 2, 5127, 5128, 3, 2, 2, 2, 5128,
	5129, 7, 29, 2, 2, 5129, 5130, 5, 608, 305, 2, 5130, 5131, 7, 31, 2, 2,
	5131, 595, 3, 2, 2, 2, 5132, 5133, 7, 29, 2, 2, 5133, 5136, 5, 284, 143,
	2, 5134, 5135, 7, 38, 2, 2, 5135, 5137, 5, 286, 144, 2, 5136, 5134, 3,
	2, 2, 2, 5136, 5137, 3, 2, 2, 2, 5137, 5138, 3, 2, 2, 2, 5138, 5139, 7,
	31, 2, 2, 5139, 5147, 3, 2, 2, 2, 5140, 5141, 7, 29, 2, 2, 5141, 5142,
	5, 286, 144, 2, 5142, 5143, 7, 38, 2, 2, 5143, 5144, 5, 284, 143, 2, 5144,
	5145, 7, 31, 2, 2, 5145, 5147, 3, 2, 2, 2, 5146, 5132, 3, 2, 2, 2, 5146,
	5140, 3, 2, 2, 2, 5147, 597, 3, 2, 2, 2, 5148, 5149, 7, 29, 2, 2, 5149,
	5150, 5, 284, 143, 2, 5150, 5151, 7, 38, 2, 2, 5151, 5152, 5, 286, 144,
	2, 5152, 5153, 7, 31, 2, 2, 5153, 5163, 3, 2, 2, 2, 5154, 5155, 7, 29,
	2, 2, 5155, 5158, 5, 286, 144, 2, 5156, 5157, 7, 38, 2, 2, 5157, 5159,
	5, 284, 143, 2, 5158, 5156, 3, 2, 2, 2, 5158, 5159, 3, 2, 2, 2, 5159, 5160,
	3, 2, 2, 2, 5160, 5161, 7, 31, 2, 2, 5161, 5163, 3, 2, 2, 2, 5162, 5148,
	3, 2, 2, 2, 5162, 5154, 3, 2, 2, 2, 5163, 599, 3, 2, 2, 2, 5164, 5165,
	5, 1032, 517, 2, 5165, 601, 3, 2, 2, 2, 5166, 5167, 5, 1076, 539, 2, 5167,
	603, 3, 2, 2, 2, 5168, 5169, 5, 1032, 517, 2, 5169, 605, 3, 2, 2, 2, 5170,
	5171, 5, 1032, 517, 2, 5171, 607, 3, 2, 2, 2, 5172, 5173, 5, 1076, 539,
	2, 5173, 609, 3, 2, 2, 2, 5174, 5175, 5, 1032, 517, 2, 5175, 611, 3, 2,
	2, 2, 5176, 5177, 9, 37, 2, 2, 5177, 613, 3, 2, 2, 2, 5178, 5179, 9, 38,
	2, 2, 5179, 615, 3, 2, 2, 2, 5180, 5181, 9, 39, 2, 2, 5181, 617, 3, 2,
	2, 2, 5182, 5183, 9, 40, 2, 2, 5183, 619, 3, 2, 2, 2, 5184, 5185, 9, 41,
	2, 2, 5185, 621, 3, 2, 2, 2, 5186, 5187, 9, 42, 2, 2, 5187, 623, 3, 2,
	2, 2, 5188, 5189, 9, 43, 2, 2, 5189, 625, 3, 2, 2, 2, 5190, 5192, 5, 1188,
	595, 2, 5191, 5193, 5, 628, 315, 2, 5192, 5191, 3, 2, 2, 2, 5192, 5193,
	3, 2, 2, 2, 5193, 5194, 3, 2, 2, 2, 5194, 5199, 5, 636, 319, 2, 5195, 5196,
	7, 38, 2, 2, 5196, 5198, 5, 636, 319, 2, 5197, 5195, 3, 2, 2, 2, 5198,
	5201, 3, 2, 2, 2, 5199, 5197, 3, 2, 2, 2, 5199, 5200, 3, 2, 2, 2, 5200,
	5202, 3, 2, 2, 2, 5201, 5199, 3, 2, 2, 2, 5202, 5203, 7, 48, 2, 2, 5203,
	627, 3, 2, 2, 2, 5204, 5205, 7, 11, 2, 2, 5205, 5207, 7, 29, 2, 2, 5206,
	5208, 5, 630, 316, 2, 5207, 5206, 3, 2, 2, 2, 5207, 5208, 3, 2, 2, 2, 5208,
	5209, 3, 2, 2, 2, 5209, 5210, 7, 31, 2, 2, 5210, 629, 3, 2, 2, 2, 5211,
	5216, 5, 632, 317, 2, 5212, 5213, 7, 38, 2, 2, 5213, 5215, 5, 632, 317,
	2, 5214, 5212, 3, 2, 2, 2, 5215, 5218, 3, 2, 2, 2, 5216, 5214, 3, 2, 2,
	2, 5216, 5217, 3, 2, 2, 2, 5217, 5228, 3, 2, 2, 2, 5218, 5216, 3, 2, 2,
	2, 5219, 5224, 5, 634, 318, 2, 5220, 5221, 7, 38, 2, 2, 5221, 5223, 5,
	634, 318, 2, 5222, 5220, 3, 2, 2, 2, 5223, 5226, 3, 2, 2, 2, 5224, 5222,
	3, 2, 2, 2, 5224, 5225, 3, 2, 2, 2, 5225, 5228, 3, 2, 2, 2, 5226, 5224,
	3, 2, 2, 2, 5227, 5211, 3, 2, 2, 2, 5227, 5219, 3, 2, 2, 2, 5228, 631,
	3, 2, 2, 2, 5229, 5230, 5, 1022, 512, 2, 5230, 633, 3, 2, 2, 2, 5231, 5232,
	7, 39, 2, 2, 5232, 5233, 5, 1200, 601, 2, 5233, 5235, 7, 29, 2, 2, 5234,
	5236, 5, 1022, 512, 2, 5235, 5234, 3, 2, 2, 2, 5235, 5236, 3, 2, 2, 2,
	5236, 5237, 3, 2, 2, 2, 5237, 5238, 7, 31, 2, 2, 5238, 635, 3, 2, 2, 2,
	5239, 5240, 5, 638, 320, 2, 5240, 5242, 7, 29, 2, 2, 5241, 5243, 5, 640,
	321, 2, 5242, 5241, 3, 2, 2, 2, 5242, 5243, 3, 2, 2, 2, 5243, 5244, 3,
	2, 2, 2, 5244, 5245, 7, 31, 2, 2, 5245, 637, 3, 2, 2, 2, 5246, 5250, 5,
	1178, 590, 2, 5247, 5249, 5, 346, 174, 2, 5248, 5247, 3, 2, 2, 2, 5249,
	5252, 3, 2, 2, 2, 5250, 5248, 3, 2, 2, 2, 5250, 5251, 3, 2, 2, 2, 5251,
	639, 3, 2, 2, 2, 5252, 5250, 3, 2, 2, 2, 5253, 5258, 5, 642, 322, 2, 5254,
	5255, 7, 38, 2, 2, 5255, 5257, 5, 642, 322, 2, 5256, 5254, 3, 2, 2, 2,
	5257, 5260, 3, 2, 2, 2, 5258, 5256, 3, 2, 2, 2, 5258, 5259, 3, 2, 2, 2,
	5259, 5270, 3, 2, 2, 2, 5260, 5258, 3, 2, 2, 2, 5261, 5266, 5, 644, 323,
	2, 5262, 5263, 7, 38, 2, 2, 5263, 5265, 5, 644, 323, 2, 5264, 5262, 3,
	2, 2, 2, 5265, 5268, 3, 2, 2, 2, 5266, 5264, 3, 2, 2, 2, 5266, 5267, 3,
	2, 2, 2, 5267, 5270, 3, 2, 2, 2, 5268, 5266, 3, 2, 2, 2, 5269, 5253, 3,
	2, 2, 2, 5269, 5261, 3, 2, 2, 2, 5270, 641, 3, 2, 2, 2, 5271, 5273, 5,
	1094, 548, 2, 5272, 5271, 3, 2, 2, 2, 5273, 5276, 3, 2, 2, 2, 5274, 5272,
	3, 2, 2, 2, 5274, 5275, 3, 2, 2, 2, 5275, 5278, 3, 2, 2, 2, 5276, 5274,
	3, 2, 2, 2, 5277, 5279, 5, 1032, 517, 2, 5278, 5277, 3, 2, 2, 2, 5278,
	5279, 3, 2, 2, 2, 5279, 643, 3, 2, 2, 2, 5280, 5282, 5, 1094, 548, 2, 5281,
	5280, 3, 2, 2, 2, 5282, 5285, 3, 2, 2, 2, 5283, 5281, 3, 2, 2, 2, 5283,
	5284, 3, 2, 2, 2, 5284, 5296, 3, 2, 2, 2, 5285, 5283, 3, 2, 2, 2, 5286,
	5287, 7, 39, 2, 2, 5287, 5293, 5, 1202, 602, 2, 5288, 5290, 7, 29, 2, 2,
	5289, 5291, 5, 1032, 517, 2, 5290, 5289, 3, 2, 2, 2, 5290, 5291, 3, 2,
	2, 2, 5291, 5292, 3, 2, 2, 2, 5292, 5294, 7, 31, 2, 2, 5293, 5288, 3, 2,
	2, 2, 5293, 5294, 3, 2, 2, 2, 5294, 5297, 3, 2, 2, 2, 5295, 5297, 7, 40,
	2, 2, 5296, 5286, 3, 2, 2, 2, 5296, 5295, 3, 2, 2, 2, 5297, 645, 3, 2,
	2, 2, 5298, 5300, 5, 1170, 586, 2, 5299, 5301, 5, 628, 315, 2, 5300, 5299,
	3, 2, 2, 2, 5300, 5301, 3, 2, 2, 2, 5301, 5302, 3, 2, 2, 2, 5302, 5307,
	5, 636, 319, 2, 5303, 5304, 7, 38, 2, 2, 5304, 5306, 5, 636, 319, 2, 5305,
	5303, 3, 2, 2, 2, 5306, 5309, 3, 2, 2, 2, 5307, 5305, 3, 2, 2, 2, 5307,
	5308, 3, 2, 2, 2, 5308, 5310, 3, 2, 2, 2, 5309, 5307, 3, 2, 2, 2, 5310,
	5311, 7, 48, 2, 2, 5311, 647, 3, 2, 2, 2, 5312, 5314, 5, 1206, 604, 2,
	5313, 5315, 5, 628, 315, 2, 5314, 5313, 3, 2, 2, 2, 5314, 5315, 3, 2, 2,
	2, 5315, 5316, 3, 2, 2, 2, 5316, 5321, 5, 636, 319, 2, 5317, 5318, 7, 38,
	2, 2, 5318, 5320, 5, 636, 319, 2, 5319, 5317, 3, 2, 2, 2, 5320, 5323, 3,
	2, 2, 2, 5321, 5319, 3, 2, 2, 2, 5321, 5322, 3, 2, 2, 2, 5322, 5324, 3,
	2, 2, 2, 5323, 5321, 3, 2, 2, 2, 5324, 5325, 7, 48, 2, 2, 5325, 649, 3,
	2, 2, 2, 5326, 5327, 5, 1214, 608, 2, 5327, 5328, 5, 638, 320, 2, 5328,
	5330, 7, 29, 2, 2, 5329, 5331, 5, 652, 327, 2, 5330, 5329, 3, 2, 2, 2,
	5330, 5331, 3, 2, 2, 2, 5331, 5332, 3, 2, 2, 2, 5332, 5333, 7, 31, 2, 2,
	5333, 5334, 7, 48, 2, 2, 5334, 651, 3, 2, 2, 2, 5335, 5340, 5, 654, 328,
	2, 5336, 5337, 7, 38, 2, 2, 5337, 5339, 5, 654, 328, 2, 5338, 5336, 3,
	2, 2, 2, 5339, 5342, 3, 2, 2, 2, 5340, 5338, 3, 2, 2, 2, 5340, 5341, 3,
	2, 2, 2, 5341, 5352, 3, 2, 2, 2, 5342, 5340, 3, 2, 2, 2, 5343, 5348, 5,
	656, 329, 2, 5344, 5345, 7, 38, 2, 2, 5345, 5347, 5, 656, 329, 2, 5346,
	5344, 3, 2, 2, 2, 5347, 5350, 3, 2, 2, 2, 5348, 5346, 3, 2, 2, 2, 5348,
	5349, 3, 2, 2, 2, 5349, 5352, 3, 2, 2, 2, 5350, 5348, 3, 2, 2, 2, 5351,
	5335, 3, 2, 2, 2, 5351, 5343, 3, 2, 2, 2, 5352, 653, 3, 2, 2, 2, 5353,
	5355, 5, 1094, 548, 2, 5354, 5353, 3, 2, 2, 2, 5355, 5358, 3, 2, 2, 2,
	5356, 5354, 3, 2, 2, 2, 5356, 5357, 3, 2, 2, 2, 5357, 5360, 3, 2, 2, 2,
	5358, 5356, 3, 2, 2, 2, 5359, 5361, 5, 434, 218, 2, 5360, 5359, 3, 2, 2,
	2, 5360, 5361, 3, 2, 2, 2, 5361, 655, 3, 2, 2, 2, 5362, 5364, 5, 1094,
	548, 2, 5363, 5362, 3, 2, 2, 2, 5364, 5367, 3, 2, 2, 2, 5365, 5363, 3,
	2, 2, 2, 5365, 5366, 3, 2, 2, 2, 5366, 5378, 3, 2, 2, 2, 5367, 5365, 3,
	2, 2, 2, 5368, 5369, 7, 39, 2, 2, 5369, 5375, 5, 1136, 569, 2, 5370, 5372,
	7, 29, 2, 2, 5371, 5373, 5, 434, 218, 2, 5372, 5371, 3, 2, 2, 2, 5372,
	5373, 3, 2, 2, 2, 5373, 5374, 3, 2, 2, 2, 5374, 5376, 7, 31, 2, 2, 5375,
	5370, 3, 2, 2, 2, 5375, 5376, 3, 2, 2, 2, 5376, 5379, 3, 2, 2, 2, 5377,
	5379, 7, 40, 2, 2, 5378, 5368, 3, 2, 2, 2, 5378, 5377, 3, 2, 2, 2, 5379,
	657, 3, 2, 2, 2, 5380, 5384, 7, 177, 2, 2, 5381, 5383, 5, 676, 339, 2,
	5382, 5381, 3, 2, 2, 2, 5383, 5386, 3, 2, 2, 2, 5384, 5382, 3, 2, 2, 2,
	5384, 5385, 3, 2, 2, 2, 5385, 5387, 3, 2, 2, 2, 5386, 5384, 3, 2, 2, 2,
	5387, 5388, 7, 151, 2, 2, 5388, 659, 3, 2, 2, 2, 5389, 5390, 7, 170, 2,
	2, 5390, 5391, 7, 29, 2, 2, 5391, 5392, 5, 662, 332, 2, 5392, 5393, 7,
	48, 2, 2, 5393, 5394, 5, 1046, 524, 2, 5394, 5395, 7, 48, 2, 2, 5395, 5396,
	5, 664, 333, 2, 5396, 5397, 7, 31, 2, 2, 5397, 5398, 5, 674, 338, 2, 5398,
	661, 3, 2, 2, 2, 5399, 5401, 7, 178, 2, 2, 5400, 5399, 3, 2, 2, 2, 5400,
	5401, 3, 2, 2, 2, 5401, 5402, 3, 2, 2, 2, 5402, 5403, 5, 1142, 572, 2,
	5403, 5404, 7, 80, 2, 2, 5404, 5405, 5, 1016, 509, 2, 5405, 663, 3, 2,
	2, 2, 5406, 5407, 5, 1142, 572, 2, 5407, 5408, 5, 700, 351, 2, 5408, 5409,
	5, 1046, 524, 2, 5409, 5417, 3, 2, 2, 2, 5410, 5411, 5, 1086, 544, 2, 5411,
	5412, 5, 1142, 572, 2, 5412, 5417, 3, 2, 2, 2, 5413, 5414, 5, 1142, 572,
	2, 5414, 5415, 5, 1086, 544, 2, 5415, 5417, 3, 2, 2, 2, 5416, 5406, 3,
	2, 2, 2, 5416, 5410, 3, 2, 2, 2, 5416, 5413, 3, 2, 2, 2, 5417, 665, 3,
	2, 2, 2, 5418, 5421, 5, 668, 335, 2, 5419, 5421, 5, 670, 336, 2, 5420,
	5418, 3, 2, 2, 2, 5420, 5419, 3, 2, 2, 2, 5421, 667, 3, 2, 2, 2, 5422,
	5423, 7, 182, 2, 2, 5423, 5424, 7, 29, 2, 2, 5424, 5425, 5, 1016, 509,
	2, 5425, 5426, 7, 31, 2, 2, 5426, 5429, 5, 674, 338, 2, 5427, 5428, 7,
	143, 2, 2, 5428, 5430, 5, 674, 338, 2, 5429, 5427, 3, 2, 2, 2, 5429, 5430,
	3, 2, 2, 2, 5430, 669, 3, 2, 2, 2, 5431, 5432, 7, 117, 2, 2, 5432, 5433,
	7, 29, 2, 2, 5433, 5434, 5, 1016, 509, 2, 5434, 5435, 7, 31, 2, 2, 5435,
	5439, 5, 672, 337, 2, 5436, 5438, 5, 672, 337, 2, 5437, 5436, 3, 2, 2,
	2, 5438, 5441, 3, 2, 2, 2, 5439, 5437, 3, 2, 2, 2, 5439, 5440, 3, 2, 2,
	2, 5440, 5442, 3, 2, 2, 2, 5441, 5439, 3, 2, 2, 2, 5442, 5443, 7, 145,
	2, 2, 5443, 671, 3, 2, 2, 2, 5444, 5449, 5, 1016, 509, 2, 5445, 5446, 7,
	38, 2, 2, 5446, 5448, 5, 1016, 509, 2, 5447, 5445, 3, 2, 2, 2, 5448, 5451,
	3, 2, 2, 2, 5449, 5447, 3, 2, 2, 2, 5449, 5450, 3, 2, 2, 2, 5450, 5452,
	3, 2, 2, 2, 5451, 5449, 3, 2, 2, 2, 5452, 5453, 7, 43, 2, 2, 5453, 5454,
	5, 674, 338, 2, 5454, 5461, 3, 2, 2, 2, 5455, 5457, 7, 136, 2, 2, 5456,
	5458, 7, 43, 2, 2, 5457, 5456, 3, 2, 2, 2, 5457, 5458, 3, 2, 2, 2, 5458,
	5459, 3, 2, 2, 2, 5459, 5461, 5, 674, 338, 2, 5460, 5444, 3, 2, 2, 2, 5460,
	5455, 3, 2, 2, 2, 5461, 673, 3, 2, 2, 2, 5462, 5485, 5, 676, 339, 2, 5463,
	5464, 5, 1140, 571, 2, 5464, 5465, 7, 43, 2, 2, 5465, 5467, 3, 2, 2, 2,
	5466, 5463, 3, 2, 2, 2, 5466, 5467, 3, 2, 2, 2, 5467, 5468, 3, 2, 2, 2,
	5468, 5471, 7, 107, 2, 2, 5469, 5470, 7, 43, 2, 2, 5470, 5472, 5, 1140,
	571, 2, 5471, 5469, 3, 2, 2, 2, 5471, 5472, 3, 2, 2, 2, 5472, 5476, 3,
	2, 2, 2, 5473, 5475, 5, 676, 339, 2, 5474, 5473, 3, 2, 2, 2, 5475, 5478,
	3, 2, 2, 2, 5476, 5474, 3, 2, 2, 2, 5476, 5477, 3, 2, 2, 2, 5477, 5479,
	3, 2, 2, 2, 5478, 5476, 3, 2, 2, 2, 5479, 5482, 7, 144, 2, 2, 5480, 5481,
	7, 43, 2, 2, 5481, 5483, 5, 1140, 571, 2, 5482, 5480, 3, 2, 2, 2, 5482,
	5483, 3, 2, 2, 2, 5483, 5485, 3, 2, 2, 2, 5484, 5462, 3, 2, 2, 2, 5484,
	5466, 3, 2, 2, 2, 5485, 675, 3, 2, 2, 2, 5486, 5490, 5, 82, 42, 2, 5487,
	5490, 5, 118, 60, 2, 5488, 5490, 5, 138, 70, 2, 5489, 5486, 3, 2, 2, 2,
	5489, 5487, 3, 2, 2, 2, 5489, 5488, 3, 2, 2, 2, 5490, 677, 3, 2, 2, 2,
	5491, 5507, 7, 103, 2, 2, 5492, 5494, 5, 282, 142, 2, 5493, 5492, 3, 2,
	2, 2, 5493, 5494, 3, 2, 2, 2, 5494, 5496, 3, 2, 2, 2, 5495, 5497, 5, 290,
	146, 2, 5496, 5495, 3, 2, 2, 2, 5496, 5497, 3, 2, 2, 2, 5497, 5498, 3,
	2, 2, 2, 5498, 5499, 5, 680, 341, 2, 5499, 5500, 7, 48, 2, 2, 5500, 5508,
	3, 2, 2, 2, 5501, 5503, 5, 732, 367, 2, 5502, 5501, 3, 2, 2, 2, 5502, 5503,
	3, 2, 2, 2, 5503, 5504, 3, 2, 2, 2, 5504, 5505, 5, 682, 342, 2, 5505, 5506,
	7, 48, 2, 2, 5506, 5508, 3, 2, 2, 2, 5507, 5493, 3, 2, 2, 2, 5507, 5502,
	3, 2, 2, 2, 5508, 679, 3, 2, 2, 2, 5509, 5514, 5, 686, 344, 2, 5510, 5511,
	7, 38, 2, 2, 5511, 5513, 5, 686, 344, 2, 5512, 5510, 3, 2, 2, 2, 5513,
	5516, 3, 2, 2, 2, 5514, 5512, 3, 2, 2, 2, 5514, 5515, 3, 2, 2, 2, 5515,
	681, 3, 2, 2, 2, 5516, 5514, 3, 2, 2, 2, 5517, 5522, 5, 706, 354, 2, 5518,
	5519, 7, 38, 2, 2, 5519, 5521, 5, 706, 354, 2, 5520, 5518, 3, 2, 2, 2,
	5521, 5524, 3, 2, 2, 2, 5522, 5520, 3, 2, 2, 2, 5522, 5523, 3, 2, 2, 2,
	5523, 683, 3, 2, 2, 2, 5524, 5522, 3, 2, 2, 2, 5525, 5526, 7, 96, 2, 2,
	5526, 5527, 5, 1076, 539, 2, 5527, 5528, 7, 80, 2, 2, 5528, 5533, 5, 1076,
	539, 2, 5529, 5530, 7, 80, 2, 2, 5530, 5532, 5, 1076, 539, 2, 5531, 5529,
	3, 2, 2, 2, 5532, 5535, 3, 2, 2, 2, 5533, 5531, 3, 2, 2, 2, 5533, 5534,
	3, 2, 2, 2, 5534, 5536, 3, 2, 2, 2, 5535, 5533, 3, 2, 2, 2, 5536, 5537,
	7, 48, 2, 2, 5537, 685, 3, 2, 2, 2, 5538, 5539, 5, 1076, 539, 2, 5539,
	5540, 7, 80, 2, 2, 5540, 5541, 5, 1032, 517, 2, 5541, 687, 3, 2, 2, 2,
	5542, 5543, 7, 192, 2, 2, 5543, 5544, 5, 716, 359, 2, 5544, 689, 3, 2,
	2, 2, 5545, 5546, 5, 692, 347, 2, 5546, 5547, 5, 718, 360, 2, 5547, 691,
	3, 2, 2, 2, 5548, 5549, 9, 44, 2, 2, 5549, 693, 3, 2, 2, 2, 5550, 5551,
	7, 168, 2, 2, 5551, 5552, 5, 722, 362, 2, 5552, 695, 3, 2, 2, 2, 5553,
	5554, 5, 1078, 540, 2, 5554, 5555, 7, 80, 2, 2, 5555, 5556, 5, 730, 366,
	2, 5556, 5557, 5, 1032, 517, 2, 5557, 5576, 3, 2, 2, 2, 5558, 5559, 5,
	1080, 541, 2, 5559, 5560, 7, 80, 2, 2, 5560, 5561, 5, 344, 173, 2, 5561,
	5576, 3, 2, 2, 2, 5562, 5563, 5, 1060, 531, 2, 5563, 5564, 7, 39, 2, 2,
	5564, 5568, 3, 2, 2, 2, 5565, 5568, 5, 250, 126, 2, 5566, 5568, 5, 1198,
	600, 2, 5567, 5562, 3, 2, 2, 2, 5567, 5565, 3, 2, 2, 2, 5567, 5566, 3,
	2, 2, 2, 5567, 5568, 3, 2, 2, 2, 5568, 5569, 3, 2, 2, 2, 5569, 5570, 5,
	1164, 583, 2, 5570, 5571, 5, 1064, 533, 2, 5571, 5572, 7, 80, 2, 2, 5572,
	5573, 5, 342, 172, 2, 5573, 5576, 3, 2, 2, 2, 5574, 5576, 5, 698, 350,
	2, 5575, 5553, 3, 2, 2, 2, 5575, 5558, 3, 2, 2, 2, 5575, 5567, 3, 2, 2,
	2, 5575, 5574, 3, 2, 2, 2, 5576, 697, 3, 2, 2, 2, 5577, 5578, 5, 1078,
	540, 2, 5578, 5579, 5, 700, 351, 2, 5579, 5580, 5, 1032, 517, 2, 5580,
	699, 3, 2, 2, 2, 5581, 5582, 9, 45, 2, 2, 5582, 701, 3, 2, 2, 2, 5583,
	5584, 5, 1078, 540, 2, 5584, 5586, 7, 78, 2, 2, 5585, 5587, 5, 730, 366,
	2, 5586, 5585, 3, 2, 2, 2, 5586, 5587, 3, 2, 2, 2, 5587, 5588, 3, 2, 2,
	2, 5588, 5589, 5, 1032, 517, 2, 5589, 703, 3, 2, 2, 2, 5590, 5591, 9, 46,
	2, 2, 5591, 5599, 5, 706, 354, 2, 5592, 5593, 9, 47, 2, 2, 5593, 5599,
	5, 1078, 540, 2, 5594, 5595, 7, 171, 2, 2, 5595, 5599, 5, 686, 344, 2,
	5596, 5597, 7, 262, 2, 2, 5597, 5599, 5, 1076, 539, 2, 5598, 5590, 3, 2,
	2, 2, 5598, 5592, 3, 2, 2, 2, 5598, 5594, 3, 2, 2, 2, 5598, 5596, 3, 2,
	2, 2, 5599, 705, 3, 2, 2, 2, 5600, 5601, 5, 1078, 540, 2, 5601, 5602, 7,
	80, 2, 2, 5602, 5603, 5, 1032, 517, 2, 5603, 707, 3, 2, 2, 2, 5604, 5606,
	5, 718, 360, 2, 5605, 5604, 3, 2, 2, 2, 5605, 5606, 3, 2, 2, 2, 5606, 5607,
	3, 2, 2, 2, 5607, 5609, 7, 143, 2, 2, 5608, 5605, 3, 2, 2, 2, 5608, 5609,
	3, 2, 2, 2, 5609, 5610, 3, 2, 2, 2, 5610, 5611, 5, 716, 359, 2, 5611, 709,
	3, 2, 2, 2, 5612, 5615, 7, 107, 2, 2, 5613, 5614, 7, 43, 2, 2, 5614, 5616,
	5, 1102, 552, 2, 5615, 5613, 3, 2, 2, 2, 5615, 5616, 3, 2, 2, 2, 5616,
	5620, 3, 2, 2, 2, 5617, 5619, 5, 394, 198, 2, 5618, 5617, 3, 2, 2, 2, 5619,
	5622, 3, 2, 2, 2, 5620, 5618, 3, 2, 2, 2, 5620, 5621, 3, 2, 2, 2, 5621,
	5626, 3, 2, 2, 2, 5622, 5620, 3, 2, 2, 2, 5623, 5625, 5, 716, 359, 2, 5624,
	5623, 3, 2, 2, 2, 5625, 5628, 3, 2, 2, 2, 5626, 5624, 3, 2, 2, 2, 5626,
	5627, 3, 2, 2, 2, 5627, 5629, 3, 2, 2, 2, 5628, 5626, 3, 2, 2, 2, 5629,
	5632, 7, 144, 2, 2, 5630, 5631, 7, 43, 2, 2, 5631, 5633, 5, 1102, 552,
	2, 5632, 5630, 3, 2, 2, 2, 5632, 5633, 3, 2, 2, 2, 5633, 711, 3, 2, 2,
	2, 5634, 5637, 7, 174, 2, 2, 5635, 5636, 7, 43, 2, 2, 5636, 5638, 5, 1102,
	552, 2, 5637, 5635, 3, 2, 2, 2, 5637, 5638, 3, 2, 2, 2, 5638, 5642, 3,
	2, 2, 2, 5639, 5641, 5, 394, 198, 2, 5640, 5639, 3, 2, 2, 2, 5641, 5644,
	3, 2, 2, 2, 5642, 5640, 3, 2, 2, 2, 5642, 5643, 3, 2, 2, 2, 5643, 5648,
	3, 2, 2, 2, 5644, 5642, 3, 2, 2, 2, 5645, 5647, 5, 716, 359, 2, 5646, 5645,
	3, 2, 2, 2, 5647, 5650, 3, 2, 2, 2, 5648, 5646, 3, 2, 2, 2, 5648, 5649,
	3, 2, 2, 2, 5649, 5651, 3, 2, 2, 2, 5650, 5648, 3, 2, 2, 2, 5651, 5654,
	5, 714, 358, 2, 5652, 5653, 7, 43, 2, 2, 5653, 5655, 5, 1102, 552, 2, 5654,
	5652, 3, 2, 2, 2, 5654, 5655, 3, 2, 2, 2, 5655, 713, 3, 2, 2, 2, 5656,
	5657, 9, 48, 2, 2, 5657, 715, 3, 2, 2, 2, 5658, 5667, 5, 718, 360, 2, 5659,
	5661, 5, 1094, 548, 2, 5660, 5659, 3, 2, 2, 2, 5661, 5664, 3, 2, 2, 2,
	5662, 5660, 3, 2, 2, 2, 5662, 5663, 3, 2, 2, 2, 5663, 5665, 3, 2, 2, 2,
	5664, 5662, 3, 2, 2, 2, 5665, 5667, 7, 48, 2, 2, 5666, 5658, 3, 2, 2, 2,
	5666, 5662, 3, 2, 2, 2, 5667, 717, 3, 2, 2, 2, 5668, 5669, 5, 1102, 552,
	2, 5669, 5670, 7, 43, 2, 2, 5670, 5672, 3, 2, 2, 2, 5671, 5668, 3, 2, 2,
	2, 5671, 5672, 3, 2, 2, 2, 5672, 5676, 3, 2, 2, 2, 5673, 5675, 5, 1094,
	548, 2, 5674, 5673, 3, 2, 2, 2, 5675, 5678, 3, 2, 2, 2, 5676, 5674, 3,
	2, 2, 2, 5676, 5677, 3, 2, 2, 2, 5677, 5679, 3, 2, 2, 2, 5678, 5676, 3,
	2, 2, 2, 5679, 5680, 5, 720, 361, 2, 5680, 719, 3, 2, 2, 2, 5681, 5687,
	5, 696, 349, 2, 5682, 5687, 5, 702, 352, 2, 5683, 5687, 5, 704, 353, 2,
	5684, 5687, 5, 1014, 508, 2, 5685, 5687, 5, 854, 428, 2, 5686, 5681, 3,
	2, 2, 2, 5686, 5682, 3, 2, 2, 2, 5686, 5683, 3, 2, 2, 2, 5686, 5684, 3,
	2, 2, 2, 5686, 5685, 3, 2, 2, 2, 5687, 5688, 3, 2, 2, 2, 5688, 5689, 7,
	48, 2, 2, 5689, 5707, 3, 2, 2, 2, 5690, 5707, 5, 758, 380, 2, 5691, 5707,
	5, 748, 375, 2, 5692, 5707, 5, 812, 407, 2, 5693, 5707, 5, 746, 374, 2,
	5694, 5707, 5, 744, 373, 2, 5695, 5707, 5, 800, 401, 2, 5696, 5707, 5,
	740, 371, 2, 5697, 5707, 5, 712, 357, 2, 5698, 5707, 5, 728, 365, 2, 5699,
	5707, 5, 710, 356, 2, 5700, 5707, 5, 742, 372, 2, 5701, 5707, 5, 818, 410,
	2, 5702, 5707, 5, 862, 432, 2, 5703, 5707, 5, 772, 387, 2, 5704, 5707,
	5, 424, 213, 2, 5705, 5707, 5, 76, 39, 2, 5706, 5686, 3, 2, 2, 2, 5706,
	5690, 3, 2, 2, 2, 5706, 5691, 3, 2, 2, 2, 5706, 5692, 3, 2, 2, 2, 5706,
	5693, 3, 2, 2, 2, 5706, 5694, 3, 2, 2, 2, 5706, 5695, 3, 2, 2, 2, 5706,
	5696, 3, 2, 2, 2, 5706, 5697, 3, 2, 2, 2, 5706, 5698, 3, 2, 2, 2, 5706,
	5699, 3, 2, 2, 2, 5706, 5700, 3, 2, 2, 2, 5706, 5701, 3, 2, 2, 2, 5706,
	5702, 3, 2, 2, 2, 5706, 5703, 3, 2, 2, 2, 5706, 5704, 3, 2, 2, 2, 5706,
	5705, 3, 2, 2, 2, 5707, 721, 3, 2, 2, 2, 5708, 5709, 5, 718, 360, 2, 5709,
	723, 3, 2, 2, 2, 5710, 5719, 5, 722, 362, 2, 5711, 5713, 5, 1094, 548,
	2, 5712, 5711, 3, 2, 2, 2, 5713, 5716, 3, 2, 2, 2, 5714, 5712, 3, 2, 2,
	2, 5714, 5715, 3, 2, 2, 2, 5715, 5717, 3, 2, 2, 2, 5716, 5714, 3, 2, 2,
	2, 5717, 5719, 7, 48, 2, 2, 5718, 5710, 3, 2, 2, 2, 5718, 5714, 3, 2, 2,
	2, 5719, 725, 3, 2, 2, 2, 5720, 5725, 5, 1246, 624, 2, 5721, 5722, 7, 38,
	2, 2, 5722, 5724, 5, 1246, 624, 2, 5723, 5721, 3, 2, 2, 2, 5724, 5727,
	3, 2, 2, 2, 5725, 5723, 3, 2, 2, 2, 5725, 5726, 3, 2, 2, 2, 5726, 727,
	3, 2, 2, 2, 5727, 5725, 3, 2, 2, 2, 5728, 5729, 5, 738, 370, 2, 5729, 5730,
	5, 716, 359, 2, 5730, 729, 3, 2, 2, 2, 5731, 5741, 5, 732, 367, 2, 5732,
	5733, 7, 263, 2, 2, 5733, 5734, 7, 29, 2, 2, 5734, 5735, 5, 1032, 517,
	2, 5735, 5736, 7, 31, 2, 2, 5736, 5738, 3, 2, 2, 2, 5737, 5732, 3, 2, 2,
	2, 5737, 5738, 3, 2, 2, 2, 5738, 5739, 3, 2, 2, 2, 5739, 5741, 5, 734,
	368, 2, 5740, 5731, 3, 2, 2, 2, 5740, 5737, 3, 2, 2, 2, 5741, 731, 3, 2,
	2, 2, 5742, 5748, 7, 11, 2, 2, 5743, 5749, 5, 294, 148, 2, 5744, 5745,
	7, 29, 2, 2, 5745, 5746, 5, 1036, 519, 2, 5746, 5747, 7, 31, 2, 2, 5747,
	5749, 3, 2, 2, 2, 5748, 5743, 3, 2, 2, 2, 5748, 5744, 3, 2, 2, 2, 5749,
	733, 3, 2, 2, 2, 5750, 5760, 7, 50, 2, 2, 5751, 5761, 5, 1148, 575, 2,
	5752, 5761, 5, 1224, 613, 2, 5753, 5761, 7, 32, 2, 2, 5754, 5757, 7, 29,
	2, 2, 5755, 5758, 5, 736, 369, 2, 5756, 5758, 7, 32, 2, 2, 5757, 5755,
	3, 2, 2, 2, 5757, 5756, 3, 2, 2, 2, 5758, 5759, 3, 2, 2, 2, 5759, 5761,
	7, 31, 2, 2, 5760, 5751, 3, 2, 2, 2, 5760, 5752, 3, 2, 2, 2, 5760, 5753,
	3, 2, 2, 2, 5760, 5754, 3, 2, 2, 2, 5761, 735, 3, 2, 2, 2, 5762, 5768,
	8, 369, 1, 2, 5763, 5765, 5, 960, 481, 2, 5764, 5763, 3, 2, 2, 2, 5764,
	5765, 3, 2, 2, 2, 5765, 5766, 3, 2, 2, 2, 5766, 5769, 5, 1032, 517, 2,
	5767, 5769, 5, 472, 237, 2, 5768, 5764, 3, 2, 2, 2, 5768, 5767, 3, 2, 2,
	2, 5769, 5772, 3, 2, 2, 2, 5770, 5771, 7, 183, 2, 2, 5771, 5773, 5, 1032,
	517, 2, 5772, 5770, 3, 2, 2, 2, 5772, 5773, 3, 2, 2, 2, 5773, 5779, 3,
	2, 2, 2, 5774, 5775, 7, 29, 2, 2, 5775, 5776, 5, 736, 369, 2, 5776, 5777,
	7, 31, 2, 2, 5777, 5779, 3, 2, 2, 2, 5778, 5762, 3, 2, 2, 2, 5778, 5774,
	3, 2, 2, 2, 5779, 5785, 3, 2, 2, 2, 5780, 5781, 12, 4, 2, 2, 5781, 5782,
	9, 49, 2, 2, 5782, 5784, 5, 736, 369, 5, 5783, 5780, 3, 2, 2, 2, 5784,
	5787, 3, 2, 2, 2, 5785, 5783, 3, 2, 2, 2, 5785, 5786, 3, 2, 2, 2, 5786,
	737, 3, 2, 2, 2, 5787, 5785, 3, 2, 2, 2, 5788, 5792, 5, 732, 367, 2, 5789,
	5792, 5, 734, 368, 2, 5790, 5792, 5, 856, 429, 2, 5791, 5788, 3, 2, 2,
	2, 5791, 5789, 3, 2, 2, 2, 5791, 5790, 3, 2, 2, 2, 5792, 739, 3, 2, 2,
	2, 5793, 5795, 7, 265, 2, 2, 5794, 5796, 5, 1032, 517, 2, 5795, 5794, 3,
	2, 2, 2, 5795, 5796, 3, 2, 2, 2, 5796, 5800, 3, 2, 2, 2, 5797, 5800, 7,
	112, 2, 2, 5798, 5800, 7, 130, 2, 2, 5799, 5793, 3, 2, 2, 2, 5799, 5797,
	3, 2, 2, 2, 5799, 5798, 3, 2, 2, 2, 5800, 5801, 3, 2, 2, 2, 5801, 5802,
	7, 48, 2, 2, 5802, 741, 3, 2, 2, 2, 5803, 5811, 7, 331, 2, 2, 5804, 5805,
	7, 29, 2, 2, 5805, 5806, 5, 1032, 517, 2, 5806, 5807, 7, 31, 2, 2, 5807,
	5808, 5, 716, 359, 2, 5808, 5812, 3, 2, 2, 2, 5809, 5810, 7, 174, 2, 2,
	5810, 5812, 7, 48, 2, 2, 5811, 5804, 3, 2, 2, 2, 5811, 5809, 3, 2, 2, 2,
	5812, 5827, 3, 2, 2, 2, 5813, 5814, 7, 332, 2, 2, 5814, 5815, 7, 29, 2,
	2, 5815, 5820, 5, 1150, 576, 2, 5816, 5817, 7, 38, 2, 2, 5817, 5819, 5,
	1150, 576, 2, 5818, 5816, 3, 2, 2, 2, 5819, 5822, 3, 2, 2, 2, 5820, 5818,
	3, 2, 2, 2, 5820, 5821, 3, 2, 2, 2, 5821, 5823, 3, 2, 2, 2, 5822, 5820,
	3, 2, 2, 2, 5823, 5824, 7, 31, 2, 2, 5824, 5825, 5, 708, 355, 2, 5825,
	5827, 3, 2, 2, 2, 5826, 5803, 3, 2, 2, 2, 5826, 5813, 3, 2, 2, 2, 5827,
	743, 3, 2, 2, 2, 5828, 5834, 7, 87, 2, 2, 5829, 5831, 7, 90, 2, 2, 5830,
	5832, 5, 730, 366, 2, 5831, 5830, 3, 2, 2, 2, 5831, 5832, 3, 2, 2, 2, 5832,
	5834, 3, 2, 2, 2, 5833, 5828, 3, 2, 2, 2, 5833, 5829, 3, 2, 2, 2, 5834,
	5835, 3, 2, 2, 2, 5835, 5836, 5, 1148, 575, 2, 5836, 5837, 7, 48, 2, 2,
	5837, 745, 3, 2, 2, 2, 5838, 5842, 7, 139, 2, 2, 5839, 5843, 5, 1160, 581,
	2, 5840, 5843, 5, 1146, 574, 2, 5841, 5843, 7, 174, 2, 2, 5842, 5839, 3,
	2, 2, 2, 5842, 5840, 3, 2, 2, 2, 5842, 5841, 3, 2, 2, 2, 5843, 5844, 3,
	2, 2, 2, 5844, 5845, 7, 48, 2, 2, 5845, 747, 3, 2, 2, 2, 5846, 5848, 5,
	750, 376, 2, 5847, 5846, 3, 2, 2, 2, 5847, 5848, 3, 2, 2, 2, 5848, 5849,
	3, 2, 2, 2, 5849, 5850, 7, 182, 2, 2, 5850, 5851, 7, 29, 2, 2, 5851, 5852,
	5, 752, 377, 2, 5852, 5853, 7, 31, 2, 2, 5853, 5863, 5, 716, 359, 2, 5854,
	5855, 7, 143, 2, 2, 5855, 5856, 7, 182, 2, 2, 5856, 5857, 7, 29, 2, 2,
	5857, 5858, 5, 752, 377, 2, 5858, 5859, 7, 31, 2, 2, 5859, 5860, 5, 716,
	359, 2, 5860, 5862, 3, 2, 2, 2, 5861, 5854, 3, 2, 2, 2, 5862, 5865, 3,
	2, 2, 2, 5863, 5861, 3, 2, 2, 2, 5863, 5864, 3, 2, 2, 2, 5864, 5868, 3,
	2, 2, 2, 5865, 5863, 3, 2, 2, 2, 5866, 5867, 7, 143, 2, 2, 5867, 5869,
	5, 716, 359, 2, 5868, 5866, 3, 2, 2, 2, 5868, 5869, 3, 2, 2, 2, 5869, 749,
	3, 2, 2, 2, 5870, 5871, 9, 50, 2, 2, 5871, 751, 3, 2, 2, 2, 5872, 5877,
	5, 754, 378, 2, 5873, 5874, 7, 27, 2, 2, 5874, 5876, 5, 754, 378, 2, 5875,
	5873, 3, 2, 2, 2, 5876, 5879, 3, 2, 2, 2, 5877, 5875, 3, 2, 2, 2, 5877,
	5878, 3, 2, 2, 2, 5878, 753, 3, 2, 2, 2, 5879, 5877, 3, 2, 2, 2, 5880,
	5883, 5, 1032, 517, 2, 5881, 5883, 5, 756, 379, 2, 5882, 5880, 3, 2, 2,
	2, 5882, 5881, 3, 2, 2, 2, 5883, 755, 3, 2, 2, 2, 5884, 5885, 5, 1032,
	517, 2, 5885, 5886, 7, 214, 2, 2, 5886, 5887, 5, 780, 391, 2, 5887, 757,
	3, 2, 2, 2, 5888, 5890, 5, 750, 376, 2, 5889, 5888, 3, 2, 2, 2, 5889, 5890,
	3, 2, 2, 2, 5890, 5891, 3, 2, 2, 2, 5891, 5892, 5, 760, 381, 2, 5892, 5893,
	7, 29, 2, 2, 5893, 5894, 5, 762, 382, 2, 5894, 5910, 7, 31, 2, 2, 5895,
	5899, 5, 764, 383, 2, 5896, 5898, 5, 764, 383, 2, 5897, 5896, 3, 2, 2,
	2, 5898, 5901, 3, 2, 2, 2, 5899, 5897, 3, 2, 2, 2, 5899, 5900, 3, 2, 2,
	2, 5900, 5911, 3, 2, 2, 2, 5901, 5899, 3, 2, 2, 2, 5902, 5903, 7, 214,
	2, 2, 5903, 5907, 5, 766, 384, 2, 5904, 5906, 5, 766, 384, 2, 5905, 5904,
	3, 2, 2, 2, 5906, 5909, 3, 2, 2, 2, 5907, 5905, 3, 2, 2, 2, 5907, 5908,
	3, 2, 2, 2, 5908, 5911, 3, 2, 2, 2, 5909, 5907, 3, 2, 2, 2, 5910, 5895,
	3, 2, 2, 2, 5910, 5902, 3, 2, 2, 2, 5911, 5912, 3, 2, 2, 2, 5912, 5913,
	7, 145, 2, 2, 5913, 5932, 3, 2, 2, 2, 5914, 5916, 5, 750, 376, 2, 5915,
	5914, 3, 2, 2, 2, 5915, 5916, 3, 2, 2, 2, 5916, 5917, 3, 2, 2, 2, 5917,
	5918, 7, 117, 2, 2, 5918, 5919, 7, 29, 2, 2, 5919, 5920, 5, 762, 382, 2,
	5920, 5921, 7, 31, 2, 2, 5921, 5922, 7, 195, 2, 2, 5922, 5926, 5, 768,
	385, 2, 5923, 5925, 5, 768, 385, 2, 5924, 5923, 3, 2, 2, 2, 5925, 5928,
	3, 2, 2, 2, 5926, 5924, 3, 2, 2, 2, 5926, 5927, 3, 2, 2, 2, 5927, 5929,
	3, 2, 2, 2, 5928, 5926, 3, 2, 2, 2, 5929, 5930, 7, 145, 2, 2, 5930, 5932,
	3, 2, 2, 2, 5931, 5889, 3, 2, 2, 2, 5931, 5915, 3, 2, 2, 2, 5932, 759,
	3, 2, 2, 2, 5933, 5934, 9, 51, 2, 2, 5934, 761, 3, 2, 2, 2, 5935, 5936,
	5, 1032, 517, 2, 5936, 763, 3, 2, 2, 2, 5937, 5942, 5, 770, 386, 2, 5938,
	5939, 7, 38, 2, 2, 5939, 5941, 5, 770, 386, 2, 5940, 5938, 3, 2, 2, 2,
	5941, 5944, 3, 2, 2, 2, 5942, 5940, 3, 2, 2, 2, 5942, 5943, 3, 2, 2, 2,
	5943, 5945, 3, 2, 2, 2, 5944, 5942, 3, 2, 2, 2, 5945, 5946, 7, 43, 2, 2,
	5946, 5947, 5, 716, 359, 2, 5947, 5954, 3, 2, 2, 2, 5948, 5950, 7, 136,
	2, 2, 5949, 5951, 7, 43, 2, 2, 5950, 5949, 3, 2, 2, 2, 5950, 5951, 3, 2,
	2, 2, 5951, 5952, 3, 2, 2, 2, 5952, 5954, 5, 716, 359, 2, 5953, 5937, 3,
	2, 2, 2, 5953, 5948, 3, 2, 2, 2, 5954, 765, 3, 2, 2, 2, 5955, 5958, 5,
	780, 391, 2, 5956, 5957, 7, 27, 2, 2, 5957, 5959, 5, 1032, 517, 2, 5958,
	5956, 3, 2, 2, 2, 5958, 5959, 3, 2, 2, 2, 5959, 5960, 3, 2, 2, 2, 5960,
	5961, 7, 43, 2, 2, 5961, 5962, 5, 716, 359, 2, 5962, 5969, 3, 2, 2, 2,
	5963, 5965, 7, 136, 2, 2, 5964, 5966, 7, 43, 2, 2, 5965, 5964, 3, 2, 2,
	2, 5965, 5966, 3, 2, 2, 2, 5966, 5967, 3, 2, 2, 2, 5967, 5969, 5, 716,
	359, 2, 5968, 5955, 3, 2, 2, 2, 5968, 5963, 3, 2, 2, 2, 5969, 767, 3, 2,
	2, 2, 5970, 5971, 5, 776, 389, 2, 5971, 5972, 7, 43, 2, 2, 5972, 5973,
	5, 716, 359, 2, 5973, 5980, 3, 2, 2, 2, 5974, 5976, 7, 136, 2, 2, 5975,
	5977, 7, 43, 2, 2, 5976, 5975, 3, 2, 2, 2, 5976, 5977, 3, 2, 2, 2, 5977,
	5978, 3, 2, 2, 2, 5978, 5980, 5, 716, 359, 2, 5979, 5970, 3, 2, 2, 2, 5979,
	5974, 3, 2, 2, 2, 5980, 769, 3, 2, 2, 2, 5981, 5982, 5, 1032, 517, 2, 5982,
	771, 3, 2, 2, 2, 5983, 5984, 7, 253, 2, 2, 5984, 5988, 5, 774, 388, 2,
	5985, 5987, 5, 774, 388, 2, 5986, 5985, 3, 2, 2, 2, 5987, 5990, 3, 2, 2,
	2, 5988, 5986, 3, 2, 2, 2, 5988, 5989, 3, 2, 2, 2, 5989, 5991, 3, 2, 2,
	2, 5990, 5988, 3, 2, 2, 2, 5991, 5992, 7, 145, 2, 2, 5992, 773, 3, 2, 2,
	2, 5993, 5994, 5, 1032, 517, 2, 5994, 5995, 7, 43, 2, 2, 5995, 5996, 5,
	716, 359, 2, 5996, 775, 3, 2, 2, 2, 5997, 6002, 5, 778, 390, 2, 5998, 5999,
	7, 38, 2, 2, 5999, 6001, 5, 778, 390, 2, 6000, 5998, 3, 2, 2, 2, 6001,
	6004, 3, 2, 2, 2, 6002, 6000, 3, 2, 2, 2, 6002, 6003, 3, 2, 2, 2, 6003,
	777, 3, 2, 2, 2, 6004, 6002, 3, 2, 2, 2, 6005, 6006, 5, 1034, 518, 2, 6006,
	779, 3, 2, 2, 2, 6007, 6008, 7, 39, 2, 2, 6008, 6044, 5, 1246, 624, 2,
	6009, 6044, 7, 40, 2, 2, 6010, 6044, 5, 1016, 509, 2, 6011, 6012, 7, 299,
	2, 2, 6012, 6014, 5, 1182, 592, 2, 6013, 6015, 5, 780, 391, 2, 6014, 6013,
	3, 2, 2, 2, 6014, 6015, 3, 2, 2, 2, 6015, 6044, 3, 2, 2, 2, 6016, 6017,
	7, 53, 2, 2, 6017, 6039, 7, 58, 2, 2, 6018, 6023, 5, 780, 391, 2, 6019,
	6020, 7, 38, 2, 2, 6020, 6022, 5, 780, 391, 2, 6021, 6019, 3, 2, 2, 2,
	6022, 6025, 3, 2, 2, 2, 6023, 6021, 3, 2, 2, 2, 6023, 6024, 3, 2, 2, 2,
	6024, 6040, 3, 2, 2, 2, 6025, 6023, 3, 2, 2, 2, 6026, 6027, 5, 1182, 592,
	2, 6027, 6028, 7, 43, 2, 2, 6028, 6036, 5, 780, 391, 2, 6029, 6030, 7,
	38, 2, 2, 6030, 6031, 5, 1182, 592, 2, 6031, 6032, 7, 43, 2, 2, 6032, 6033,
	5, 780, 391, 2, 6033, 6035, 3, 2, 2, 2, 6034, 6029, 3, 2, 2, 2, 6035, 6038,
	3, 2, 2, 2, 6036, 6034, 3, 2, 2, 2, 6036, 6037, 3, 2, 2, 2, 6037, 6040,
	3, 2, 2, 2, 6038, 6036, 3, 2, 2, 2, 6039, 6018, 3, 2, 2, 2, 6039, 6026,
	3, 2, 2, 2, 6040, 6041, 3, 2, 2, 2, 6041, 6042, 7, 64, 2, 2, 6042, 6044,
	3, 2, 2, 2, 6043, 6007, 3, 2, 2, 2, 6043, 6009, 3, 2, 2, 2, 6043, 6010,
	3, 2, 2, 2, 6043, 6011, 3, 2, 2, 2, 6043, 6016, 3, 2, 2, 2, 6044, 781,
	3, 2, 2, 2, 6045, 6046, 7, 53, 2, 2, 6046, 6093, 7, 58, 2, 2, 6047, 6052,
	5, 1032, 517, 2, 6048, 6049, 7, 38, 2, 2, 6049, 6051, 5, 1032, 517, 2,
	6050, 6048, 3, 2, 2, 2, 6051, 6054, 3, 2, 2, 2, 6052, 6050, 3, 2, 2, 2,
	6052, 6053, 3, 2, 2, 2, 6053, 6094, 3, 2, 2, 2, 6054, 6052, 3, 2, 2, 2,
	6055, 6056, 5, 784, 393, 2, 6056, 6057, 7, 43, 2, 2, 6057, 6065, 5, 1032,
	517, 2, 6058, 6059, 7, 38, 2, 2, 6059, 6060, 5, 784, 393, 2, 6060, 6061,
	7, 43, 2, 2, 6061, 6062, 5, 1032, 517, 2, 6062, 6064, 3, 2, 2, 2, 6063,
	6058, 3, 2, 2, 2, 6064, 6067, 3, 2, 2, 2, 6065, 6063, 3, 2, 2, 2, 6065,
	6066, 3, 2, 2, 2, 6066, 6094, 3, 2, 2, 2, 6067, 6065, 3, 2, 2, 2, 6068,
	6069, 5, 786, 394, 2, 6069, 6070, 7, 43, 2, 2, 6070, 6078, 5, 1032, 517,
	2, 6071, 6072, 7, 38, 2, 2, 6072, 6073, 5, 786, 394, 2, 6073, 6074, 7,
	43, 2, 2, 6074, 6075, 5, 1032, 517, 2, 6075, 6077, 3, 2, 2, 2, 6076, 6071,
	3, 2, 2, 2, 6077, 6080, 3, 2, 2, 2, 6078, 6076, 3, 2, 2, 2, 6078, 6079,
	3, 2, 2, 2, 6079, 6094, 3, 2, 2, 2, 6080, 6078, 3, 2, 2, 2, 6081, 6082,
	5, 1016, 509, 2, 6082, 6083, 7, 58, 2, 2, 6083, 6088, 5, 1032, 517, 2,
	6084, 6085, 7, 38, 2, 2, 6085, 6087, 5, 1032, 517, 2, 6086, 6084, 3, 2,
	2, 2, 6087, 6090, 3, 2, 2, 2, 6088, 6086, 3, 2, 2, 2, 6088, 6089, 3, 2,
	2, 2, 6089, 6091, 3, 2, 2, 2, 6090, 6088, 3, 2, 2, 2, 6091, 6092, 7, 64,
	2, 2, 6092, 6094, 3, 2, 2, 2, 6093, 6047, 3, 2, 2, 2, 6093, 6055, 3, 2,
	2, 2, 6093, 6068, 3, 2, 2, 2, 6093, 6081, 3, 2, 2, 2, 6094, 6095, 3, 2,
	2, 2, 6095, 6096, 7, 64, 2, 2, 6096, 783, 3, 2, 2, 2, 6097, 6100, 5, 1182,
	592, 2, 6098, 6100, 5, 788, 395, 2, 6099, 6097, 3, 2, 2, 2, 6099, 6098,
	3, 2, 2, 2, 6100, 785, 3, 2, 2, 2, 6101, 6104, 5, 1016, 509, 2, 6102, 6104,
	5, 788, 395, 2, 6103, 6101, 3, 2, 2, 2, 6103, 6102, 3, 2, 2, 2, 6104, 787,
	3, 2, 2, 2, 6105, 6108, 5, 272, 137, 2, 6106, 6108, 7, 136, 2, 2, 6107,
	6105, 3, 2, 2, 2, 6107, 6106, 3, 2, 2, 2, 6108, 789, 3, 2, 2, 2, 6109,
	6111, 5, 792, 397, 2, 6110, 6109, 3, 2, 2, 2, 6110, 6111, 3, 2, 2, 2, 6111,
	6112, 3, 2, 2, 2, 6112, 6113, 5, 782, 392, 2, 6113, 791, 3, 2, 2, 2, 6114,
	6119, 5, 1230, 616, 2, 6115, 6119, 5, 1228, 615, 2, 6116, 6119, 5, 256,
	129, 2, 6117, 6119, 5, 280, 141, 2, 6118, 6114, 3, 2, 2, 2, 6118, 6115,
	3, 2, 2, 2, 6118, 6116, 3, 2, 2, 2, 6118, 6117, 3, 2, 2, 2, 6119, 793,
	3, 2, 2, 2, 6120, 6121, 5, 790, 396, 2, 6121, 795, 3, 2, 2, 2, 6122, 6123,
	7, 53, 2, 2, 6123, 6124, 7, 58, 2, 2, 6124, 6129, 5, 1076, 539, 2, 6125,
	6126, 7, 38, 2, 2, 6126, 6128, 5, 1076, 539, 2, 6127, 6125, 3, 2, 2, 2,
	6128, 6131, 3, 2, 2, 2, 6129, 6127, 3, 2, 2, 2, 6129, 6130, 3, 2, 2, 2,
	6130, 6132, 3, 2, 2, 2, 6131, 6129, 3, 2, 2, 2, 6132, 6133, 7, 64, 2, 2,
	6133, 797, 3, 2, 2, 2, 6134, 6135, 7, 53, 2, 2, 6135, 6136, 7, 58, 2, 2,
	6136, 6141, 5, 1078, 540, 2, 6137, 6138, 7, 38, 2, 2, 6138, 6140, 5, 1078,
	540, 2, 6139, 6137, 3, 2, 2, 2, 6140, 6143, 3, 2, 2, 2, 6141, 6139, 3,
	2, 2, 2, 6141, 6142, 3, 2, 2, 2, 6142, 6144, 3, 2, 2, 2, 6143, 6141, 3,
	2, 2, 2, 6144, 6145, 7, 64, 2, 2, 6145, 799, 3, 2, 2, 2, 6146, 6147, 7,
	173, 2, 2, 6147, 6187, 5, 716, 359, 2, 6148, 6149, 9, 52, 2, 2, 6149, 6150,
	7, 29, 2, 2, 6150, 6151, 5, 1032, 517, 2, 6151, 6152, 7, 31, 2, 2, 6152,
	6153, 5, 716, 359, 2, 6153, 6187, 3, 2, 2, 2, 6154, 6155, 7, 170, 2, 2,
	6155, 6157, 7, 29, 2, 2, 6156, 6158, 5, 802, 402, 2, 6157, 6156, 3, 2,
	2, 2, 6157, 6158, 3, 2, 2, 2, 6158, 6159, 3, 2, 2, 2, 6159, 6161, 7, 48,
	2, 2, 6160, 6162, 5, 1032, 517, 2, 6161, 6160, 3, 2, 2, 2, 6161, 6162,
	3, 2, 2, 2, 6162, 6163, 3, 2, 2, 2, 6163, 6165, 7, 48, 2, 2, 6164, 6166,
	5, 806, 404, 2, 6165, 6164, 3, 2, 2, 2, 6165, 6166, 3, 2, 2, 2, 6166, 6167,
	3, 2, 2, 2, 6167, 6168, 7, 31, 2, 2, 6168, 6187, 5, 716, 359, 2, 6169,
	6170, 7, 141, 2, 2, 6170, 6171, 5, 716, 359, 2, 6171, 6172, 7, 337, 2,
	2, 6172, 6173, 7, 29, 2, 2, 6173, 6174, 5, 1032, 517, 2, 6174, 6175, 7,
	31, 2, 2, 6175, 6176, 7, 48, 2, 2, 6176, 6187, 3, 2, 2, 2, 6177, 6178,
	7, 172, 2, 2, 6178, 6179, 7, 29, 2, 2, 6179, 6180, 5, 1218, 610, 2, 6180,
	6181, 7, 52, 2, 2, 6181, 6182, 5, 810, 406, 2, 6182, 6183, 7, 54, 2, 2,
	6183, 6184, 7, 31, 2, 2, 6184, 6185, 5, 718, 360, 2, 6185, 6187, 3, 2,
	2, 2, 6186, 6146, 3, 2, 2, 2, 6186, 6148, 3, 2, 2, 2, 6186, 6154, 3, 2,
	2, 2, 6186, 6169, 3, 2, 2, 2, 6186, 6177, 3, 2, 2, 2, 6187, 801, 3, 2,
	2, 2, 6188, 6198, 5, 682, 342, 2, 6189, 6194, 5, 804, 403, 2, 6190, 6191,
	7, 38, 2, 2, 6191, 6193, 5, 804, 403, 2, 6192, 6190, 3, 2, 2, 2, 6193,
	6196, 3, 2, 2, 2, 6194, 6192, 3, 2, 2, 2, 6194, 6195, 3, 2, 2, 2, 6195,
	6198, 3, 2, 2, 2, 6196, 6194, 3, 2, 2, 2, 6197, 6188, 3, 2, 2, 2, 6197,
	6189, 3, 2, 2, 2, 6198, 803, 3, 2, 2, 2, 6199, 6201, 7, 327, 2, 2, 6200,
	6199, 3, 2, 2, 2, 6200, 6201, 3, 2, 2, 2, 6201, 6202, 3, 2, 2, 2, 6202,
	6203, 5, 240, 121, 2, 6203, 6204, 5, 1246, 624, 2, 6204, 6205, 7, 80, 2,
	2, 6205, 6213, 5, 1032, 517, 2, 6206, 6207, 7, 38, 2, 2, 6207, 6208, 5,
	1246, 624, 2, 6208, 6209, 7, 80, 2, 2, 6209, 6210, 5, 1032, 517, 2, 6210,
	6212, 3, 2, 2, 2, 6211, 6206, 3, 2, 2, 2, 6212, 6215, 3, 2, 2, 2, 6213,
	6211, 3, 2, 2, 2, 6213, 6214, 3, 2, 2, 2, 6214, 805, 3, 2, 2, 2, 6215,
	6213, 3, 2, 2, 2, 6216, 6221, 5, 808, 405, 2, 6217, 6218, 7, 38, 2, 2,
	6218, 6220, 5, 808, 405, 2, 6219, 6217, 3, 2, 2, 2, 6220, 6223, 3, 2, 2,
	2, 6221, 6219, 3, 2, 2, 2, 6221, 6222, 3, 2, 2, 2, 6222, 807, 3, 2, 2,
	2, 6223, 6221, 3, 2, 2, 2, 6224, 6228, 5, 698, 350, 2, 6225, 6228, 5, 1014,
	508, 2, 6226, 6228, 5, 1000, 501, 2, 6227, 6224, 3, 2, 2, 2, 6227, 6225,
	3, 2, 2, 2, 6227, 6226, 3, 2, 2, 2, 6228, 809, 3, 2, 2, 2, 6229, 6231,
	5, 1168, 585, 2, 6230, 6229, 3, 2, 2, 2, 6230, 6231, 3, 2, 2, 2, 6231,
	6238, 3, 2, 2, 2, 6232, 6234, 7, 38, 2, 2, 6233, 6235, 5, 1168, 585, 2,
	6234, 6233, 3, 2, 2, 2, 6234, 6235, 3, 2, 2, 2, 6235, 6237, 3, 2, 2, 2,
	6236, 6232, 3, 2, 2, 2, 6237, 6240, 3, 2, 2, 2, 6238, 6236, 3, 2, 2, 2,
	6238, 6239, 3, 2, 2, 2, 6239, 811, 3, 2, 2, 2, 6240, 6238, 3, 2, 2, 2,
	6241, 6242, 5, 998, 500, 2, 6242, 6243, 7, 48, 2, 2, 6243, 6252, 3, 2,
	2, 2, 6244, 6245, 7, 330, 2, 2, 6245, 6246, 7, 53, 2, 2, 6246, 6247, 7,
	29, 2, 2, 6247, 6248, 5, 1000, 501, 2, 6248, 6249, 7, 31, 2, 2, 6249, 6250,
	7, 48, 2, 2, 6250, 6252, 3, 2, 2, 2, 6251, 6241, 3, 2, 2, 2, 6251, 6244,
	3, 2, 2, 2, 6252, 813, 3, 2, 2, 2, 6253, 6256, 5, 414, 208, 2, 6254, 6256,
	5, 816, 409, 2, 6255, 6253, 3, 2, 2, 2, 6255, 6254, 3, 2, 2, 2, 6256, 815,
	3, 2, 2, 2, 6257, 6258, 5, 1102, 552, 2, 6258, 6259, 7, 43, 2, 2, 6259,
	6261, 3, 2, 2, 2, 6260, 6257, 3, 2, 2, 2, 6260, 6261, 3, 2, 2, 2, 6261,
	6262, 3, 2, 2, 2, 6262, 6263, 5, 830, 416, 2, 6263, 817, 3, 2, 2, 2, 6264,
	6268, 5, 416, 209, 2, 6265, 6268, 5, 820, 411, 2, 6266, 6268, 5, 650, 326,
	2, 6267, 6264, 3, 2, 2, 2, 6267, 6265, 3, 2, 2, 2, 6267, 6266, 3, 2, 2,
	2, 6268, 819, 3, 2, 2, 2, 6269, 6272, 5, 822, 412, 2, 6270, 6272, 5, 830,
	416, 2, 6271, 6269, 3, 2, 2, 2, 6271, 6270, 3, 2, 2, 2, 6272, 821, 3, 2,
	2, 2, 6273, 6277, 5, 824, 413, 2, 6274, 6277, 5, 826, 414, 2, 6275, 6277,
	5, 828, 415, 2, 6276, 6273, 3, 2, 2, 2, 6276, 6274, 3, 2, 2, 2, 6276, 6275,
	3, 2, 2, 2, 6277, 823, 3, 2, 2, 2, 6278, 6279, 7, 102, 2, 2, 6279, 6280,
	7, 29, 2, 2, 6280, 6281, 5, 1032, 517, 2, 6281, 6282, 7, 31, 2, 2, 6282,
	6283, 5, 708, 355, 2, 6283, 825, 3, 2, 2, 2, 6284, 6285, 7, 104, 2, 2,
	6285, 6286, 7, 29, 2, 2, 6286, 6287, 5, 1032, 517, 2, 6287, 6288, 7, 31,
	2, 2, 6288, 6289, 5, 708, 355, 2, 6289, 827, 3, 2, 2, 2, 6290, 6291, 7,
	131, 2, 2, 6291, 6292, 7, 29, 2, 2, 6292, 6293, 5, 1032, 517, 2, 6293,
	6294, 7, 31, 2, 2, 6294, 6295, 5, 716, 359, 2, 6295, 829, 3, 2, 2, 2, 6296,
	6300, 5, 832, 417, 2, 6297, 6300, 5, 834, 418, 2, 6298, 6300, 5, 836, 419,
	2, 6299, 6296, 3, 2, 2, 2, 6299, 6297, 3, 2, 2, 2, 6299, 6298, 3, 2, 2,
	2, 6300, 831, 3, 2, 2, 2, 6301, 6302, 7, 102, 2, 2, 6302, 6303, 9, 53,
	2, 2, 6303, 6304, 7, 29, 2, 2, 6304, 6305, 5, 1032, 517, 2, 6305, 6306,
	7, 31, 2, 2, 6306, 6307, 5, 708, 355, 2, 6307, 833, 3, 2, 2, 2, 6308, 6309,
	7, 104, 2, 2, 6309, 6310, 9, 53, 2, 2, 6310, 6311, 7, 29, 2, 2, 6311, 6312,
	5, 1032, 517, 2, 6312, 6313, 7, 31, 2, 2, 6313, 6314, 5, 708, 355, 2, 6314,
	835, 3, 2, 2, 2, 6315, 6316, 7, 131, 2, 2, 6316, 6317, 9, 53, 2, 2, 6317,
	6318, 7, 29, 2, 2, 6318, 6319, 5, 1032, 517, 2, 6319, 6320, 7, 31, 2, 2,
	6320, 6321, 5, 716, 359, 2, 6321, 837, 3, 2, 2, 2, 6322, 6324, 7, 136,
	2, 2, 6323, 6322, 3, 2, 2, 2, 6323, 6324, 3, 2, 2, 2, 6324, 6325, 3, 2,
	2, 2, 6325, 6327, 7, 124, 2, 2, 6326, 6328, 5, 1116, 559, 2, 6327, 6326,
	3, 2, 2, 2, 6327, 6328, 3, 2, 2, 2, 6328, 6329, 3, 2, 2, 2, 6329, 6330,
	5, 840, 421, 2, 6330, 6334, 7, 48, 2, 2, 6331, 6333, 5, 842, 422, 2, 6332,
	6331, 3, 2, 2, 2, 6333, 6336, 3, 2, 2, 2, 6334, 6332, 3, 2, 2, 2, 6334,
	6335, 3, 2, 2, 2, 6335, 6337, 3, 2, 2, 2, 6336, 6334, 3, 2, 2, 2, 6337,
	6340, 7, 148, 2, 2, 6338, 6339, 7, 43, 2, 2, 6339, 6341, 5, 1116, 559,
	2, 6340, 6338, 3, 2, 2, 2, 6340, 6341, 3, 2, 2, 2, 6341, 6355, 3, 2, 2,
	2, 6342, 6343, 7, 179, 2, 2, 6343, 6345, 7, 124, 2, 2, 6344, 6346, 5, 1116,
	559, 2, 6345, 6344, 3, 2, 2, 2, 6345, 6346, 3, 2, 2, 2, 6346, 6347, 3,
	2, 2, 2, 6347, 6348, 5, 840, 421, 2, 6348, 6349, 7, 48, 2, 2, 6349, 6352,
	7, 148, 2, 2, 6350, 6351, 7, 43, 2, 2, 6351, 6353, 5, 1116, 559, 2, 6352,
	6350, 3, 2, 2, 2, 6352, 6353, 3, 2, 2, 2, 6353, 6355, 3, 2, 2, 2, 6354,
	6323, 3, 2, 2, 2, 6354, 6342, 3, 2, 2, 2, 6355, 839, 3, 2, 2, 2, 6356,
	6362, 7, 50, 2, 2, 6357, 6363, 5, 1166, 584, 2, 6358, 6359, 7, 29, 2, 2,
	6359, 6360, 5, 736, 369, 2, 6360, 6361, 7, 31, 2, 2, 6361, 6363, 3, 2,
	2, 2, 6362, 6357, 3, 2, 2, 2, 6362, 6358, 3, 2, 2, 2, 6363, 841, 3, 2,
	2, 2, 6364, 6365, 7, 136, 2, 2, 6365, 6366, 5, 844, 423, 2, 6366, 6367,
	7, 48, 2, 2, 6367, 6380, 3, 2, 2, 2, 6368, 6369, 5, 846, 424, 2, 6369,
	6370, 5, 848, 425, 2, 6370, 6371, 7, 48, 2, 2, 6371, 6380, 3, 2, 2, 2,
	6372, 6374, 5, 1094, 548, 2, 6373, 6372, 3, 2, 2, 2, 6374, 6377, 3, 2,
	2, 2, 6375, 6373, 3, 2, 2, 2, 6375, 6376, 3, 2, 2, 2, 6376, 6378, 3, 2,
	2, 2, 6377, 6375, 3, 2, 2, 2, 6378, 6380, 5, 436, 219, 2, 6379, 6364, 3,
	2, 2, 2, 6379, 6368, 3, 2, 2, 2, 6379, 6375, 3, 2, 2, 2, 6380, 843, 3,
	2, 2, 2, 6381, 6382, 7, 194, 2, 2, 6382, 6385, 5, 852, 427, 2, 6383, 6384,
	7, 233, 2, 2, 6384, 6386, 5, 852, 427, 2, 6385, 6383, 3, 2, 2, 2, 6385,
	6386, 3, 2, 2, 2, 6386, 6390, 3, 2, 2, 2, 6387, 6388, 7, 233, 2, 2, 6388,
	6390, 5, 852, 427, 2, 6389, 6381, 3, 2, 2, 2, 6389, 6387, 3, 2, 2, 2, 6390,
	845, 3, 2, 2, 2, 6391, 6393, 7, 194, 2, 2, 6392, 6394, 5, 852, 427, 2,
	6393, 6392, 3, 2, 2, 2, 6393, 6394, 3, 2, 2, 2, 6394, 6399, 3, 2, 2, 2,
	6395, 6397, 7, 233, 2, 2, 6396, 6398, 5, 852, 427, 2, 6397, 6396, 3, 2,
	2, 2, 6397, 6398, 3, 2, 2, 2, 6398, 6400, 3, 2, 2, 2, 6399, 6395, 3, 2,
	2, 2, 6399, 6400, 3, 2, 2, 2, 6400, 6407, 3, 2, 2, 2, 6401, 6403, 7, 233,
	2, 2, 6402, 6404, 5, 852, 427, 2, 6403, 6402, 3, 2, 2, 2, 6403, 6404, 3,
	2, 2, 2, 6404, 6407, 3, 2, 2, 2, 6405, 6407, 7, 193, 2, 2, 6406, 6391,
	3, 2, 2, 2, 6406, 6401, 3, 2, 2, 2, 6406, 6405, 3, 2, 2, 2, 6407, 847,
	3, 2, 2, 2, 6408, 6413, 5, 850, 426, 2, 6409, 6410, 7, 38, 2, 2, 6410,
	6412, 5, 850, 426, 2, 6411, 6409, 3, 2, 2, 2, 6412, 6415, 3, 2, 2, 2, 6413,
	6411, 3, 2, 2, 2, 6413, 6414, 3, 2, 2, 2, 6414, 849, 3, 2, 2, 2, 6415,
	6413, 3, 2, 2, 2, 6416, 6419, 5, 1234, 618, 2, 6417, 6418, 7, 80, 2, 2,
	6418, 6420, 5, 1032, 517, 2, 6419, 6417, 3, 2, 2, 2, 6419, 6420, 3, 2,
	2, 2, 6420, 851, 3, 2, 2, 2, 6421, 6423, 5, 960, 481, 2, 6422, 6424, 5,
	732, 367, 2, 6423, 6422, 3, 2, 2, 2, 6423, 6424, 3, 2, 2, 2, 6424, 6427,
	3, 2, 2, 2, 6425, 6427, 5, 732, 367, 2, 6426, 6421, 3, 2, 2, 2, 6426, 6425,
	3, 2, 2, 2, 6427, 853, 3, 2, 2, 2, 6428, 6429, 5, 860, 431, 2, 6429, 6431,
	7, 78, 2, 2, 6430, 6432, 5, 856, 429, 2, 6431, 6430, 3, 2, 2, 2, 6431,
	6432, 3, 2, 2, 2, 6432, 6433, 3, 2, 2, 2, 6433, 6434, 5, 1032, 517, 2,
	6434, 855, 3, 2, 2, 2, 6435, 6446, 7, 12, 2, 2, 6436, 6447, 7, 348, 2,
	2, 6437, 6447, 7, 353, 2, 2, 6438, 6447, 7, 350, 2, 2, 6439, 6447, 7, 349,
	2, 2, 6440, 6447, 7, 351, 2, 2, 6441, 6447, 5, 1166, 584, 2, 6442, 6443,
	7, 29, 2, 2, 6443, 6444, 5, 1032, 517, 2, 6444, 6445, 7, 31, 2, 2, 6445,
	6447, 3, 2, 2, 2, 6446, 6436, 3, 2, 2, 2, 6446, 6437, 3, 2, 2, 2, 6446,
	6438, 3, 2, 2, 2, 6446, 6439, 3, 2, 2, 2, 6446, 6440, 3, 2, 2, 2, 6446,
	6441, 3, 2, 2, 2, 6446, 6442, 3, 2, 2, 2, 6447, 857, 3, 2, 2, 2, 6448,
	6449, 5, 1150, 576, 2, 6449, 859, 3, 2, 2, 2, 6450, 6451, 5, 858, 430,
	2, 6451, 6452, 5, 1064, 533, 2, 6452, 861, 3, 2, 2, 2, 6453, 6454, 7, 255,
	2, 2, 6454, 6456, 7, 29, 2, 2, 6455, 6457, 5, 1204, 603, 2, 6456, 6455,
	3, 2, 2, 2, 6456, 6457, 3, 2, 2, 2, 6457, 6458, 3, 2, 2, 2, 6458, 6459,
	7, 31, 2, 2, 6459, 6463, 5, 864, 433, 2, 6460, 6462, 5, 864, 433, 2, 6461,
	6460, 3, 2, 2, 2, 6462, 6465, 3, 2, 2, 2, 6463, 6461, 3, 2, 2, 2, 6463,
	6464, 3, 2, 2, 2, 6464, 6466, 3, 2, 2, 2, 6465, 6463, 3, 2, 2, 2, 6466,
	6467, 7, 158, 2, 2, 6467, 863, 3, 2, 2, 2, 6468, 6470, 5, 276, 139, 2,
	6469, 6468, 3, 2, 2, 2, 6469, 6470, 3, 2, 2, 2, 6470, 6471, 3, 2, 2, 2,
	6471, 6476, 5, 1204, 603, 2, 6472, 6473, 7, 29, 2, 2, 6473, 6474, 5, 384,
	193, 2, 6474, 6475, 7, 31, 2, 2, 6475, 6477, 3, 2, 2, 2, 6476, 6472, 3,
	2, 2, 2, 6476, 6477, 3, 2, 2, 2, 6477, 6478, 3, 2, 2, 2, 6478, 6479, 7,
	43, 2, 2, 6479, 6484, 5, 866, 434, 2, 6480, 6481, 7, 59, 2, 2, 6481, 6483,
	5, 866, 434, 2, 6482, 6480, 3, 2, 2, 2, 6483, 6486, 3, 2, 2, 2, 6484, 6482,
	3, 2, 2, 2, 6484, 6485, 3, 2, 2, 2, 6485, 6487, 3, 2, 2, 2, 6486, 6484,
	3, 2, 2, 2, 6487, 6488, 7, 48, 2, 2, 6488, 865, 3, 2, 2, 2, 6489, 6495,
	5, 868, 435, 2, 6490, 6491, 7, 47, 2, 2, 6491, 6493, 5, 870, 436, 2, 6492,
	6494, 5, 872, 437, 2, 6493, 6492, 3, 2, 2, 2, 6493, 6494, 3, 2, 2, 2, 6494,
	6496, 3, 2, 2, 2, 6495, 6490, 3, 2, 2, 2, 6495, 6496, 3, 2, 2, 2, 6496,
	867, 3, 2, 2, 2, 6497, 6501, 5, 874, 438, 2, 6498, 6500, 5, 874, 438, 2,
	6499, 6498, 3, 2, 2, 2, 6500, 6503, 3, 2, 2, 2, 6501, 6499, 3, 2, 2, 2,
	6501, 6502, 3, 2, 2, 2, 6502, 6521, 3, 2, 2, 2, 6503, 6501, 3, 2, 2, 2,
	6504, 6505, 7, 251, 2, 2, 6505, 6510, 7, 202, 2, 2, 6506, 6507, 7, 29,
	2, 2, 6507, 6508, 5, 1032, 517, 2, 6508, 6509, 7, 31, 2, 2, 6509, 6511,
	3, 2, 2, 2, 6510, 6506, 3, 2, 2, 2, 6510, 6511, 3, 2, 2, 2, 6511, 6512,
	3, 2, 2, 2, 6512, 6513, 5, 876, 439, 2, 6513, 6517, 5, 876, 439, 2, 6514,
	6516, 5, 876, 439, 2, 6515, 6514, 3, 2, 2, 2, 6516, 6519, 3, 2, 2, 2, 6517,
	6515, 3, 2, 2, 2, 6517, 6518, 3, 2, 2, 2, 6518, 6521, 3, 2, 2, 2, 6519,
	6517, 3, 2, 2, 2, 6520, 6497, 3, 2, 2, 2, 6520, 6504, 3, 2, 2, 2, 6521,
	869, 3, 2, 2, 2, 6522, 6533, 7, 348, 2, 2, 6523, 6533, 7, 353, 2, 2, 6524,
	6533, 7, 350, 2, 2, 6525, 6533, 7, 349, 2, 2, 6526, 6533, 7, 351, 2, 2,
	6527, 6533, 5, 1216, 609, 2, 6528, 6529, 7, 29, 2, 2, 6529, 6530, 5, 1032,
	517, 2, 6530, 6531, 7, 31, 2, 2, 6531, 6533, 3, 2, 2, 2, 6532, 6522, 3,
	2, 2, 2, 6532, 6523, 3, 2, 2, 2, 6532, 6524, 3, 2, 2, 2, 6532, 6525, 3,
	2, 2, 2, 6532, 6526, 3, 2, 2, 2, 6532, 6527, 3, 2, 2, 2, 6532, 6528, 3,
	2, 2, 2, 6533, 871, 3, 2, 2, 2, 6534, 6538, 7, 58, 2, 2, 6535, 6537, 5,
	220, 111, 2, 6536, 6535, 3, 2, 2, 2, 6537, 6540, 3, 2, 2, 2, 6538, 6536,
	3, 2, 2, 2, 6538, 6539, 3, 2, 2, 2, 6539, 6544, 3, 2, 2, 2, 6540, 6538,
	3, 2, 2, 2, 6541, 6543, 5, 716, 359, 2, 6542, 6541, 3, 2, 2, 2, 6543, 6546,
	3, 2, 2, 2, 6544, 6542, 3, 2, 2, 2, 6544, 6545, 3, 2, 2, 2, 6545, 6547,
	3, 2, 2, 2, 6546, 6544, 3, 2, 2, 2, 6547, 6548, 7, 64, 2, 2, 6548, 873,
	3, 2, 2, 2, 6549, 6555, 5, 876, 439, 2, 6550, 6555, 5, 872, 437, 2, 6551,
	6555, 5, 878, 440, 2, 6552, 6555, 5, 880, 441, 2, 6553, 6555, 5, 882, 442,
	2, 6554, 6549, 3, 2, 2, 2, 6554, 6550, 3, 2, 2, 2, 6554, 6551, 3, 2, 2,
	2, 6554, 6552, 3, 2, 2, 2, 6554, 6553, 3, 2, 2, 2, 6555, 875, 3, 2, 2,
	2, 6556, 6561, 5, 1204, 603, 2, 6557, 6558, 7, 29, 2, 2, 6558, 6559, 5,
	1002, 502, 2, 6559, 6560, 7, 31, 2, 2, 6560, 6562, 3, 2, 2, 2, 6561, 6557,
	3, 2, 2, 2, 6561, 6562, 3, 2, 2, 2, 6562, 877, 3, 2, 2, 2, 6563, 6564,
	7, 182, 2, 2, 6564, 6565, 7, 29, 2, 2, 6565, 6566, 5, 1032, 517, 2, 6566,
	6567, 7, 31, 2, 2, 6567, 6570, 5, 876, 439, 2, 6568, 6569, 7, 143, 2, 2,
	6569, 6571, 5, 876, 439, 2, 6570, 6568, 3, 2, 2, 2, 6570, 6571, 3, 2, 2,
	2, 6571, 879, 3, 2, 2, 2, 6572, 6573, 7, 263, 2, 2, 6573, 6574, 7, 29,
	2, 2, 6574, 6575, 5, 1032, 517, 2, 6575, 6576, 7, 31, 2, 2, 6576, 6577,
	5, 876, 439, 2, 6577, 881, 3, 2, 2, 2, 6578, 6579, 7, 117, 2, 2, 6579,
	6580, 7, 29, 2, 2, 6580, 6581, 5, 762, 382, 2, 6581, 6582, 7, 31, 2, 2,
	6582, 6586, 5, 884, 443, 2, 6583, 6585, 5, 884, 443, 2, 6584, 6583, 3,
	2, 2, 2, 6585, 6588, 3, 2, 2, 2, 6586, 6584, 3, 2, 2, 2, 6586, 6587, 3,
	2, 2, 2, 6587, 6589, 3, 2, 2, 2, 6588, 6586, 3, 2, 2, 2, 6589, 6590, 7,
	145, 2, 2, 6590, 883, 3, 2, 2, 2, 6591, 6596, 5, 770, 386, 2, 6592, 6593,
	7, 38, 2, 2, 6593, 6595, 5, 770, 386, 2, 6594, 6592, 3, 2, 2, 2, 6595,
	6598, 3, 2, 2, 2, 6596, 6594, 3, 2, 2, 2, 6596, 6597, 3, 2, 2, 2, 6597,
	6599, 3, 2, 2, 2, 6598, 6596, 3, 2, 2, 2, 6599, 6600, 7, 43, 2, 2, 6600,
	6601, 5, 876, 439, 2, 6601, 6602, 7, 48, 2, 2, 6602, 6611, 3, 2, 2, 2,
	6603, 6605, 7, 136, 2, 2, 6604, 6606, 7, 43, 2, 2, 6605, 6604, 3, 2, 2,
	2, 6605, 6606, 3, 2, 2, 2, 6606, 6607, 3, 2, 2, 2, 6607, 6608, 5, 876,
	439, 2, 6608, 6609, 7, 48, 2, 2, 6609, 6611, 3, 2, 2, 2, 6610, 6591, 3,
	2, 2, 2, 6610, 6603, 3, 2, 2, 2, 6611, 885, 3, 2, 2, 2, 6612, 6616, 7,
	285, 2, 2, 6613, 6615, 5, 888, 445, 2, 6614, 6613, 3, 2, 2, 2, 6615, 6618,
	3, 2, 2, 2, 6616, 6614, 3, 2, 2, 2, 6616, 6617, 3, 2, 2, 2, 6617, 6619,
	3, 2, 2, 2, 6618, 6616, 3, 2, 2, 2, 6619, 6620, 7, 159, 2, 2, 6620, 887,
	3, 2, 2, 2, 6621, 6626, 5, 208, 105, 2, 6622, 6626, 5, 890, 446, 2, 6623,
	6626, 5, 892, 447, 2, 6624, 6626, 5, 894, 448, 2, 6625, 6621, 3, 2, 2,
	2, 6625, 6622, 3, 2, 2, 2, 6625, 6623, 3, 2, 2, 2, 6625, 6624, 3, 2, 2,
	2, 6626, 889, 3, 2, 2, 2, 6627, 6628, 9, 54, 2, 2, 6628, 6629, 5, 904,
	453, 2, 6629, 6630, 7, 48, 2, 2, 6630, 891, 3, 2, 2, 2, 6631, 6632, 9,
	55, 2, 2, 6632, 6633, 5, 904, 453, 2, 6633, 6634, 7, 48, 2, 2, 6634, 893,
	3, 2, 2, 2, 6635, 6639, 5, 896, 449, 2, 6636, 6639, 5, 952, 477, 2, 6637,
	6639, 5, 962, 482, 2, 6638, 6635, 3, 2, 2, 2, 6638, 6636, 3, 2, 2, 2, 6638,
	6637, 3, 2, 2, 2, 6639, 6640, 3, 2, 2, 2, 6640, 6641, 7, 48, 2, 2, 6641,
	895, 3, 2, 2, 2, 6642, 6645, 5, 898, 450, 2, 6643, 6645, 5, 900, 451, 2,
	6644, 6642, 3, 2, 2, 2, 6644, 6643, 3, 2, 2, 2, 6645, 6646, 3, 2, 2, 2,
	6646, 6647, 7, 80, 2, 2, 6647, 6648, 5, 914, 458, 2, 6648, 897, 3, 2, 2,
	2, 6649, 6650, 7, 29, 2, 2, 6650, 6652, 5, 906, 454, 2, 6651, 6653, 5,
	964, 483, 2, 6652, 6651, 3, 2, 2, 2, 6652, 6653, 3, 2, 2, 2, 6653, 6654,
	3, 2, 2, 2, 6654, 6655, 7, 85, 2, 2, 6655, 6656, 5, 908, 455, 2, 6656,
	6657, 7, 31, 2, 2, 6657, 899, 3, 2, 2, 2, 6658, 6659, 7, 29, 2, 2, 6659,
	6661, 5, 902, 452, 2, 6660, 6662, 5, 964, 483, 2, 6661, 6660, 3, 2, 2,
	2, 6661, 6662, 3, 2, 2, 2, 6662, 6663, 3, 2, 2, 2, 6663, 6664, 7, 37, 2,
	2, 6664, 6665, 5, 904, 453, 2, 6665, 6666, 7, 31, 2, 2, 6666, 901, 3, 2,
	2, 2, 6667, 6672, 5, 906, 454, 2, 6668, 6669, 7, 38, 2, 2, 6669, 6671,
	5, 906, 454, 2, 6670, 6668, 3, 2, 2, 2, 6671, 6674, 3, 2, 2, 2, 6672, 6670,
	3, 2, 2, 2, 6672, 6673, 3, 2, 2, 2, 6673, 903, 3, 2, 2, 2, 6674, 6672,
	3, 2, 2, 2, 6675, 6680, 5, 908, 455, 2, 6676, 6677, 7, 38, 2, 2, 6677,
	6679, 5, 908, 455, 2, 6678, 6676, 3, 2, 2, 2, 6679, 6682, 3, 2, 2, 2, 6680,
	6678, 3, 2, 2, 2, 6680, 6681, 3, 2, 2, 2, 6681, 905, 3, 2, 2, 2, 6682,
	6680, 3, 2, 2, 2, 6683, 6688, 5, 910, 456, 2, 6684, 6685, 7, 52, 2, 2,
	6685, 6686, 5, 1024, 513, 2, 6686, 6687, 7, 54, 2, 2, 6687, 6689, 3, 2,
	2, 2, 6688, 6684, 3, 2, 2, 2, 6688, 6689, 3, 2, 2, 2, 6689, 907, 3, 2,
	2, 2, 6690, 6695, 5, 912, 457, 2, 6691, 6692, 7, 52, 2, 2, 6692, 6693,
	5, 1024, 513, 2, 6693, 6694, 7, 54, 2, 2, 6694, 6696, 3, 2, 2, 2, 6695,
	6691, 3, 2, 2, 2, 6695, 6696, 3, 2, 2, 2, 6696, 909, 3, 2, 2, 2, 6697,
	6704, 5, 1176, 589, 2, 6698, 6704, 5, 1174, 588, 2, 6699, 6700, 5, 1170,
	586, 2, 6700, 6701, 7, 39, 2, 2, 6701, 6702, 5, 1202, 602, 2, 6702, 6704,
	3, 2, 2, 2, 6703, 6697, 3, 2, 2, 2, 6703, 6698, 3, 2, 2, 2, 6703, 6699,
	3, 2, 2, 2, 6704, 911, 3, 2, 2, 2, 6705, 6712, 5, 1194, 598, 2, 6706, 6712,
	5, 1174, 588, 2, 6707, 6708, 5, 1170, 586, 2, 6708, 6709, 7, 39, 2, 2,
	6709, 6710, 5, 1202, 602, 2, 6710, 6712, 3, 2, 2, 2, 6711, 6705, 3, 2,
	2, 2, 6711, 6706, 3, 2, 2, 2, 6711, 6707, 3, 2, 2, 2, 6712, 913, 3, 2,
	2, 2, 6713, 6719, 5, 916, 459, 2, 6714, 6715, 7, 29, 2, 2, 6715, 6716,
	5, 916, 459, 2, 6716, 6717, 7, 31, 2, 2, 6717, 6719, 3, 2, 2, 2, 6718,
	6713, 3, 2, 2, 2, 6718, 6714, 3, 2, 2, 2, 6719, 915, 3, 2, 2, 2, 6720,
	6755, 5, 918, 460, 2, 6721, 6722, 5, 920, 461, 2, 6722, 6723, 7, 38, 2,
	2, 6723, 6726, 5, 922, 462, 2, 6724, 6725, 7, 38, 2, 2, 6725, 6727, 5,
	924, 463, 2, 6726, 6724, 3, 2, 2, 2, 6726, 6727, 3, 2, 2, 2, 6727, 6755,
	3, 2, 2, 2, 6728, 6729, 5, 926, 464, 2, 6729, 6730, 7, 38, 2, 2, 6730,
	6731, 5, 928, 465, 2, 6731, 6732, 7, 38, 2, 2, 6732, 6733, 5, 930, 466,
	2, 6733, 6734, 7, 38, 2, 2, 6734, 6735, 5, 932, 467, 2, 6735, 6736, 7,
	38, 2, 2, 6736, 6737, 5, 934, 468, 2, 6737, 6738, 7, 38, 2, 2, 6738, 6752,
	5, 936, 469, 2, 6739, 6740, 7, 38, 2, 2, 6740, 6741, 5, 938, 470, 2, 6741,
	6742, 7, 38, 2, 2, 6742, 6743, 5, 940, 471, 2, 6743, 6744, 7, 38, 2, 2,
	6744, 6745, 5, 942, 472, 2, 6745, 6746, 7, 38, 2, 2, 6746, 6747, 5, 944,
	473, 2, 6747, 6748, 7, 38, 2, 2, 6748, 6749, 5, 946, 474, 2, 6749, 6750,
	7, 38, 2, 2, 6750, 6751, 5, 948, 475, 2, 6751, 6753, 3, 2, 2, 2, 6752,
	6739, 3, 2, 2, 2, 6752, 6753, 3, 2, 2, 2, 6753, 6755, 3, 2, 2, 2, 6754,
	6720, 3, 2, 2, 2, 6754, 6721, 3, 2, 2, 2, 6754, 6728, 3, 2, 2, 2, 6755,
	917, 3, 2, 2, 2, 6756, 6757, 5, 950, 476, 2, 6757, 919, 3, 2, 2, 2, 6758,
	6759, 5, 950, 476, 2, 6759, 921, 3, 2, 2, 2, 6760, 6761, 5, 950, 476, 2,
	6761, 923, 3, 2, 2, 2, 6762, 6763, 5, 950, 476, 2, 6763, 925, 3, 2, 2,
	2, 6764, 6765, 5, 950, 476, 2, 6765, 927, 3, 2, 2, 2, 6766, 6767, 5, 950,
	476, 2, 6767, 929, 3, 2, 2, 2, 6768, 6769, 5, 950, 476, 2, 6769, 931, 3,
	2, 2, 2, 6770, 6771, 5, 950, 476, 2, 6771, 933, 3, 2, 2, 2, 6772, 6773,
	5, 950, 476, 2, 6773, 935, 3, 2, 2, 2, 6774, 6775, 5, 950, 476, 2, 6775,
	937, 3, 2, 2, 2, 6776, 6777, 5, 950, 476, 2, 6777, 939, 3, 2, 2, 2, 6778,
	6779, 5, 950, 476, 2, 6779, 941, 3, 2, 2, 2, 6780, 6781, 5, 950, 476, 2,
	6781, 943, 3, 2, 2, 2, 6782, 6783, 5, 950, 476, 2, 6783, 945, 3, 2, 2,
	2, 6784, 6785, 5, 950, 476, 2, 6785, 947, 3, 2, 2, 2, 6786, 6787, 5, 950,
	476, 2, 6787, 949, 3, 2, 2, 2, 6788, 6789, 5, 1018, 510, 2, 6789, 951,
	3, 2, 2, 2, 6790, 6793, 5, 954, 478, 2, 6791, 6793, 5, 956, 479, 2, 6792,
	6790, 3, 2, 2, 2, 6792, 6791, 3, 2, 2, 2, 6793, 6794, 3, 2, 2, 2, 6794,
	6795, 7, 80, 2, 2, 6795, 6796, 5, 914, 458, 2, 6796, 953, 3, 2, 2, 2, 6797,
	6799, 7, 29, 2, 2, 6798, 6800, 5, 960, 481, 2, 6799, 6798, 3, 2, 2, 2,
	6799, 6800, 3, 2, 2, 2, 6800, 6801, 3, 2, 2, 2, 6801, 6803, 5, 906, 454,
	2, 6802, 6804, 5, 964, 483, 2, 6803, 6802, 3, 2, 2, 2, 6803, 6804, 3, 2,
	2, 2, 6804, 6805, 3, 2, 2, 2, 6805, 6806, 7, 85, 2, 2, 6806, 6807, 7, 29,
	2, 2, 6807, 6809, 5, 908, 455, 2, 6808, 6810, 5, 964, 483, 2, 6809, 6808,
	3, 2, 2, 2, 6809, 6810, 3, 2, 2, 2, 6810, 6811, 3, 2, 2, 2, 6811, 6812,
	7, 43, 2, 2, 6812, 6813, 5, 958, 480, 2, 6813, 6814, 7, 31, 2, 2, 6814,
	6815, 7, 31, 2, 2, 6815, 955, 3, 2, 2, 2, 6816, 6818, 7, 29, 2, 2, 6817,
	6819, 5, 960, 481, 2, 6818, 6817, 3, 2, 2, 2, 6818, 6819, 3, 2, 2, 2, 6819,
	6820, 3, 2, 2, 2, 6820, 6822, 5, 902, 452, 2, 6821, 6823, 5, 964, 483,
	2, 6822, 6821, 3, 2, 2, 2, 6822, 6823, 3, 2, 2, 2, 6823, 6824, 3, 2, 2,
	2, 6824, 6825, 7, 37, 2, 2, 6825, 6826, 7, 29, 2, 2, 6826, 6828, 5, 904,
	453, 2, 6827, 6829, 5, 964, 483, 2, 6828, 6827, 3, 2, 2, 2, 6828, 6829,
	3, 2, 2, 2, 6829, 6830, 3, 2, 2, 2, 6830, 6831, 7, 43, 2, 2, 6831, 6832,
	5, 958, 480, 2, 6832, 6833, 7, 31, 2, 2, 6833, 6834, 7, 31, 2, 2, 6834,
	957, 3, 2, 2, 2, 6835, 6836, 5, 1032, 517, 2, 6836, 959, 3, 2, 2, 2, 6837,
	6838, 9, 56, 2, 2, 6838, 961, 3, 2, 2, 2, 6839, 6840, 7, 182, 2, 2, 6840,
	6841, 7, 29, 2, 2, 6841, 6842, 5, 1038, 520, 2, 6842, 6845, 7, 31, 2, 2,
	6843, 6846, 5, 896, 449, 2, 6844, 6846, 5, 952, 477, 2, 6845, 6843, 3,
	2, 2, 2, 6845, 6844, 3, 2, 2, 2, 6846, 6850, 3, 2, 2, 2, 6847, 6848, 7,
	184, 2, 2, 6848, 6850, 5, 896, 449, 2, 6849, 6839, 3, 2, 2, 2, 6849, 6847,
	3, 2, 2, 2, 6850, 963, 3, 2, 2, 2, 6851, 6852, 9, 57, 2, 2, 6852, 965,
	3, 2, 2, 2, 6853, 6854, 7, 58, 2, 2, 6854, 6859, 5, 1032, 517, 2, 6855,
	6856, 7, 38, 2, 2, 6856, 6858, 5, 1032, 517, 2, 6857, 6855, 3, 2, 2, 2,
	6858, 6861, 3, 2, 2, 2, 6859, 6857, 3, 2, 2, 2, 6859, 6860, 3, 2, 2, 2,
	6860, 6862, 3, 2, 2, 2, 6861, 6859, 3, 2, 2, 2, 6862, 6863, 7, 64, 2, 2,
	6863, 967, 3, 2, 2, 2, 6864, 6865, 7, 58, 2, 2, 6865, 6870, 5, 1016, 509,
	2, 6866, 6867, 7, 38, 2, 2, 6867, 6869, 5, 1016, 509, 2, 6868, 6866, 3,
	2, 2, 2, 6869, 6872, 3, 2, 2, 2, 6870, 6868, 3, 2, 2, 2, 6870, 6871, 3,
	2, 2, 2, 6871, 6873, 3, 2, 2, 2, 6872, 6870, 3, 2, 2, 2, 6873, 6874, 7,
	64, 2, 2, 6874, 969, 3, 2, 2, 2, 6875, 6876, 7, 58, 2, 2, 6876, 6877, 5,
	1016, 509, 2, 6877, 6878, 5, 968, 485, 2, 6878, 6879, 7, 64, 2, 2, 6879,
	971, 3, 2, 2, 2, 6880, 6881, 7, 58, 2, 2, 6881, 6886, 5, 1038, 520, 2,
	6882, 6883, 7, 38, 2, 2, 6883, 6885, 5, 1038, 520, 2, 6884, 6882, 3, 2,
	2, 2, 6885, 6888, 3, 2, 2, 2, 6886, 6884, 3, 2, 2, 2, 6886, 6887, 3, 2,
	2, 2, 6887, 6889, 3, 2, 2, 2, 6888, 6886, 3, 2, 2, 2, 6889, 6890, 7, 64,
	2, 2, 6890, 973, 3, 2, 2, 2, 6891, 6892, 7, 58, 2, 2, 6892, 6893, 5, 1016,
	509, 2, 6893, 6894, 5, 972, 487, 2, 6894, 6895, 7, 64, 2, 2, 6895, 975,
	3, 2, 2, 2, 6896, 6897, 7, 58, 2, 2, 6897, 6898, 5, 1032, 517, 2, 6898,
	6899, 5, 966, 484, 2, 6899, 6900, 7, 64, 2, 2, 6900, 977, 3, 2, 2, 2, 6901,
	6902, 7, 58, 2, 2, 6902, 6904, 5, 980, 491, 2, 6903, 6905, 5, 982, 492,
	2, 6904, 6903, 3, 2, 2, 2, 6904, 6905, 3, 2, 2, 2, 6905, 6906, 3, 2, 2,
	2, 6906, 6907, 5, 984, 493, 2, 6907, 6908, 7, 64, 2, 2, 6908, 979, 3, 2,
	2, 2, 6909, 6910, 9, 58, 2, 2, 6910, 981, 3, 2, 2, 2, 6911, 6914, 5, 272,
	137, 2, 6912, 6914, 5, 1016, 509, 2, 6913, 6911, 3, 2, 2, 2, 6913, 6912,
	3, 2, 2, 2, 6914, 983, 3, 2, 2, 2, 6915, 6916, 7, 58, 2, 2, 6916, 6921,
	5, 986, 494, 2, 6917, 6918, 7, 38, 2, 2, 6918, 6920, 5, 986, 494, 2, 6919,
	6917, 3, 2, 2, 2, 6920, 6923, 3, 2, 2, 2, 6921, 6919, 3, 2, 2, 2, 6921,
	6922, 3, 2, 2, 2, 6922, 6924, 3, 2, 2, 2, 6923, 6921, 3, 2, 2, 2, 6924,
	6925, 7, 64, 2, 2, 6925, 985, 3, 2, 2, 2, 6926, 6932, 5, 1032, 517, 2,
	6927, 6928, 7, 340, 2, 2, 6928, 6929, 7, 52, 2, 2, 6929, 6930, 5, 988,
	495, 2, 6930, 6931, 7, 54, 2, 2, 6931, 6933, 3, 2, 2, 2, 6932, 6927, 3,
	2, 2, 2, 6932, 6933, 3, 2, 2, 2, 6933, 987, 3, 2, 2, 2, 6934, 6937, 5,
	1032, 517, 2, 6935, 6936, 9, 59, 2, 2, 6936, 6938, 5, 1032, 517, 2, 6937,
	6935, 3, 2, 2, 2, 6937, 6938, 3, 2, 2, 2, 6938, 989, 3, 2, 2, 2, 6939,
	6940, 7, 58, 2, 2, 6940, 6941, 7, 64, 2, 2, 6941, 991, 3, 2, 2, 2, 6942,
	6943, 5, 1000, 501, 2, 6943, 993, 3, 2, 2, 2, 6944, 6948, 5, 1226, 614,
	2, 6945, 6947, 5, 1094, 548, 2, 6946, 6945, 3, 2, 2, 2, 6947, 6950, 3,
	2, 2, 2, 6948, 6946, 3, 2, 2, 2, 6948, 6949, 3, 2, 2, 2, 6949, 6955, 3,
	2, 2, 2, 6950, 6948, 3, 2, 2, 2, 6951, 6952, 7, 29, 2, 2, 6952, 6953, 5,
	1002, 502, 2, 6953, 6954, 7, 31, 2, 2, 6954, 6956, 3, 2, 2, 2, 6955, 6951,
	3, 2, 2, 2, 6955, 6956, 3, 2, 2, 2, 6956, 995, 3, 2, 2, 2, 6957, 6990,
	7, 358, 2, 2, 6958, 6959, 7, 29, 2, 2, 6959, 6960, 5, 1002, 502, 2, 6960,
	6961, 7, 31, 2, 2, 6961, 6963, 3, 2, 2, 2, 6962, 6958, 3, 2, 2, 2, 6962,
	6963, 3, 2, 2, 2, 6963, 6991, 3, 2, 2, 2, 6964, 6986, 7, 29, 2, 2, 6965,
	6968, 5, 240, 121, 2, 6966, 6967, 7, 38, 2, 2, 6967, 6969, 5, 1032, 517,
	2, 6968, 6966, 3, 2, 2, 2, 6968, 6969, 3, 2, 2, 2, 6969, 6987, 3, 2, 2,
	2, 6970, 6977, 5, 1032, 517, 2, 6971, 6973, 7, 38, 2, 2, 6972, 6974, 5,
	1032, 517, 2, 6973, 6972, 3, 2, 2, 2, 6973, 6974, 3, 2, 2, 2, 6974, 6976,
	3, 2, 2, 2, 6975, 6971, 3, 2, 2, 2, 6976, 6979, 3, 2, 2, 2, 6977, 6975,
	3, 2, 2, 2, 6977, 6978, 3, 2, 2, 2, 6978, 6984, 3, 2, 2, 2, 6979, 6977,
	3, 2, 2, 2, 6980, 6982, 7, 38, 2, 2, 6981, 6983, 5, 840, 421, 2, 6982,
	6981, 3, 2, 2, 2, 6982, 6983, 3, 2, 2, 2, 6983, 6985, 3, 2, 2, 2, 6984,
	6980, 3, 2, 2, 2, 6984, 6985, 3, 2, 2, 2, 6985, 6987, 3, 2, 2, 2, 6986,
	6965, 3, 2, 2, 2, 6986, 6970, 3, 2, 2, 2, 6987, 6988, 3, 2, 2, 2, 6988,
	6989, 7, 31, 2, 2, 6989, 6991, 3, 2, 2, 2, 6990, 6962, 3, 2, 2, 2, 6990,
	6964, 3, 2, 2, 2, 6991, 997, 3, 2, 2, 2, 6992, 7039, 5, 994, 498, 2, 6993,
	7039, 5, 996, 499, 2, 6994, 7030, 5, 1058, 530, 2, 6995, 6998, 5, 1054,
	528, 2, 6996, 6998, 5, 1198, 600, 2, 6997, 6995, 3, 2, 2, 2, 6997, 6996,
	3, 2, 2, 2, 6997, 6998, 3, 2, 2, 2, 6998, 6999, 3, 2, 2, 2, 6999, 7000,
	5, 1150, 576, 2, 7000, 7001, 5, 1064, 533, 2, 7001, 7030, 3, 2, 2, 2, 7002,
	7030, 5, 990, 496, 2, 7003, 7008, 5, 966, 484, 2, 7004, 7005, 7, 52, 2,
	2, 7005, 7006, 5, 1056, 529, 2, 7006, 7007, 7, 54, 2, 2, 7007, 7009, 3,
	2, 2, 2, 7008, 7004, 3, 2, 2, 2, 7008, 7009, 3, 2, 2, 2, 7009, 7030, 3,
	2, 2, 2, 7010, 7015, 5, 976, 489, 2, 7011, 7012, 7, 52, 2, 2, 7012, 7013,
	5, 1056, 529, 2, 7013, 7014, 7, 54, 2, 2, 7014, 7016, 3, 2, 2, 2, 7015,
	7011, 3, 2, 2, 2, 7015, 7016, 3, 2, 2, 2, 7016, 7030, 3, 2, 2, 2, 7017,
	7030, 5, 572, 287, 2, 7018, 7019, 7, 29, 2, 2, 7019, 7020, 5, 1036, 519,
	2, 7020, 7021, 7, 31, 2, 2, 7021, 7030, 3, 2, 2, 2, 7022, 7030, 5, 790,
	396, 2, 7023, 7030, 5, 978, 490, 2, 7024, 7030, 5, 468, 235, 2, 7025, 7030,
	7, 301, 2, 2, 7026, 7030, 7, 16, 2, 2, 7027, 7030, 7, 230, 2, 2, 7028,
	7030, 5, 1060, 531, 2, 7029, 6994, 3, 2, 2, 2, 7029, 6997, 3, 2, 2, 2,
	7029, 7002, 3, 2, 2, 2, 7029, 7003, 3, 2, 2, 2, 7029, 7010, 3, 2, 2, 2,
	7029, 7017, 3, 2, 2, 2, 7029, 7018, 3, 2, 2, 2, 7029, 7022, 3, 2, 2, 2,
	7029, 7023, 3, 2, 2, 2, 7029, 7024, 3, 2, 2, 2, 7029, 7025, 3, 2, 2, 2,
	7029, 7026, 3, 2, 2, 2, 7029, 7027, 3, 2, 2, 2, 7029, 7028, 3, 2, 2, 2,
	7030, 7031, 3, 2, 2, 2, 7031, 7032, 7, 39, 2, 2, 7032, 7039, 5, 1004, 503,
	2, 7033, 7034, 7, 288, 2, 2, 7034, 7036, 7, 46, 2, 2, 7035, 7033, 3, 2,
	2, 2, 7035, 7036, 3, 2, 2, 2, 7036, 7037, 3, 2, 2, 2, 7037, 7039, 5, 1010,
	506, 2, 7038, 6992, 3, 2, 2, 2, 7038, 6993, 3, 2, 2, 2, 7038, 7029, 3,
	2, 2, 2, 7038, 7035, 3, 2, 2, 2, 7039, 999, 3, 2, 2, 2, 7040, 7041, 5,
	998, 500, 2, 7041, 1001, 3, 2, 2, 2, 7042, 7044, 5, 1032, 517, 2, 7043,
	7042, 3, 2, 2, 2, 7043, 7044, 3, 2, 2, 2, 7044, 7051, 3, 2, 2, 2, 7045,
	7047, 7, 38, 2, 2, 7046, 7048, 5, 1032, 517, 2, 7047, 7046, 3, 2, 2, 2,
	7047, 7048, 3, 2, 2, 2, 7048, 7050, 3, 2, 2, 2, 7049, 7045, 3, 2, 2, 2,
	7050, 7053, 3, 2, 2, 2, 7051, 7049, 3, 2, 2, 2, 7051, 7052, 3, 2, 2, 2,
	7052, 7063, 3, 2, 2, 2, 7053, 7051, 3, 2, 2, 2, 7054, 7055, 7, 39, 2, 2,
	7055, 7056, 5, 1166, 584, 2, 7056, 7058, 7, 29, 2, 2, 7057, 7059, 5, 1032,
	517, 2, 7058, 7057, 3, 2, 2, 2, 7058, 7059, 3, 2, 2, 2, 7059, 7060, 3,
	2, 2, 2, 7060, 7061, 7, 31, 2, 2, 7061, 7063, 3, 2, 2, 2, 7062, 7043, 3,
	2, 2, 2, 7062, 7054, 3, 2, 2, 2, 7063, 7075, 3, 2, 2, 2, 7064, 7065, 7,
	38, 2, 2, 7065, 7066, 7, 39, 2, 2, 7066, 7067, 5, 1166, 584, 2, 7067, 7069,
	7, 29, 2, 2, 7068, 7070, 5, 1032, 517, 2, 7069, 7068, 3, 2, 2, 2, 7069,
	7070, 3, 2, 2, 2, 7070, 7071, 3, 2, 2, 2, 7071, 7072, 7, 31, 2, 2, 7072,
	7074, 3, 2, 2, 2, 7073, 7064, 3, 2, 2, 2, 7074, 7077, 3, 2, 2, 2, 7075,
	7073, 3, 2, 2, 2, 7075, 7076, 3, 2, 2, 2, 7076, 1003, 3, 2, 2, 2, 7077,
	7075, 3, 2, 2, 2, 7078, 7082, 5, 1184, 593, 2, 7079, 7081, 5, 1094, 548,
	2, 7080, 7079, 3, 2, 2, 2, 7081, 7084, 3, 2, 2, 2, 7082, 7080, 3, 2, 2,
	2, 7082, 7083, 3, 2, 2, 2, 7083, 7089, 3, 2, 2, 2, 7084, 7082, 3, 2, 2,
	2, 7085, 7086, 7, 29, 2, 2, 7086, 7087, 5, 1002, 502, 2, 7087, 7088, 7,
	31, 2, 2, 7088, 7090, 3, 2, 2, 2, 7089, 7085, 3, 2, 2, 2, 7089, 7090, 3,
	2, 2, 2, 7090, 7093, 3, 2, 2, 2, 7091, 7093, 5, 1006, 504, 2, 7092, 7078,
	3, 2, 2, 2, 7092, 7091, 3, 2, 2, 2, 7093, 1005, 3, 2, 2, 2, 7094, 7097,
	5, 1008, 505, 2, 7095, 7097, 5, 1010, 506, 2, 7096, 7094, 3, 2, 2, 2, 7096,
	7095, 3, 2, 2, 2, 7097, 1007, 3, 2, 2, 2, 7098, 7102, 5, 1012, 507, 2,
	7099, 7101, 5, 1094, 548, 2, 7100, 7099, 3, 2, 2, 2, 7101, 7104, 3, 2,
	2, 2, 7102, 7100, 3, 2, 2, 2, 7102, 7103, 3, 2, 2, 2, 7103, 7109, 3, 2,
	2, 2, 7104, 7102, 3, 2, 2, 2, 7105, 7106, 7, 29, 2, 2, 7106, 7107, 5, 1002,
	502, 2, 7107, 7108, 7, 31, 2, 2, 7108, 7110, 3, 2, 2, 2, 7109, 7105, 3,
	2, 2, 2, 7109, 7110, 3, 2, 2, 2, 7110, 7116, 3, 2, 2, 2, 7111, 7112, 7,
	340, 2, 2, 7112, 7113, 7, 29, 2, 2, 7113, 7114, 5, 1032, 517, 2, 7114,
	7115, 7, 31, 2, 2, 7115, 7117, 3, 2, 2, 2, 7116, 7111, 3, 2, 2, 2, 7116,
	7117, 3, 2, 2, 2, 7117, 1009, 3, 2, 2, 2, 7118, 7122, 7, 254, 2, 2, 7119,
	7121, 5, 1094, 548, 2, 7120, 7119, 3, 2, 2, 2, 7121, 7124, 3, 2, 2, 2,
	7122, 7120, 3, 2, 2, 2, 7122, 7123, 3, 2, 2, 2, 7123, 7131, 3, 2, 2, 2,
	7124, 7122, 3, 2, 2, 2, 7125, 7128, 7, 29, 2, 2, 7126, 7129, 5, 726, 364,
	2, 7127, 7129, 7, 230, 2, 2, 7128, 7126, 3, 2, 2, 2, 7128, 7127, 3, 2,
	2, 2, 7128, 7129, 3, 2, 2, 2, 7129, 7130, 3, 2, 2, 2, 7130, 7132, 7, 31,
	2, 2, 7131, 7125, 3, 2, 2, 2, 7131, 7132, 3, 2, 2, 2, 7132, 7142, 3, 2,
	2, 2, 7133, 7139, 7, 340, 2, 2, 7134, 7136, 7, 29, 2, 2, 7135, 7137, 5,
	194, 98, 2, 7136, 7135, 3, 2, 2, 2, 7136, 7137, 3, 2, 2, 2, 7137, 7138,
	3, 2, 2, 2, 7138, 7140, 7, 31, 2, 2, 7139, 7134, 3, 2, 2, 2, 7139, 7140,
	3, 2, 2, 2, 7140, 7141, 3, 2, 2, 2, 7141, 7143, 5, 168, 85, 2, 7142, 7133,
	3, 2, 2, 2, 7142, 7143, 3, 2, 2, 2, 7143, 1011, 3, 2, 2, 2, 7144, 7150,
	5, 1184, 593, 2, 7145, 7150, 7, 319, 2, 2, 7146, 7150, 7, 101, 2, 2, 7147,
	7150, 7, 232, 2, 2, 7148, 7150, 7, 344, 2, 2, 7149, 7144, 3, 2, 2, 2, 7149,
	7145, 3, 2, 2, 2, 7149, 7146, 3, 2, 2, 2, 7149, 7147, 3, 2, 2, 2, 7149,
	7148, 3, 2, 2, 2, 7150, 1013, 3, 2, 2, 2, 7151, 7155, 5, 1086, 544, 2,
	7152, 7154, 5, 1094, 548, 2, 7153, 7152, 3, 2, 2, 2, 7154, 7157, 3, 2,
	2, 2, 7155, 7153, 3, 2, 2, 2, 7155, 7156, 3, 2, 2, 2, 7156, 7158, 3, 2,
	2, 2, 7157, 7155, 3, 2, 2, 2, 7158, 7159, 5, 1078, 540, 2, 7159, 7170,
	3, 2, 2, 2, 7160, 7164, 5, 1078, 540, 2, 7161, 7163, 5, 1094, 548, 2, 7162,
	7161, 3, 2, 2, 2, 7163, 7166, 3, 2, 2, 2, 7164, 7162, 3, 2, 2, 2, 7164,
	7165, 3, 2, 2, 2, 7165, 7167, 3, 2, 2, 2, 7166, 7164, 3, 2, 2, 2, 7167,
	7168, 5, 1086, 544, 2, 7168, 7170, 3, 2, 2, 2, 7169, 7151, 3, 2, 2, 2,
	7169, 7160, 3, 2, 2, 2, 7170, 1015, 3, 2, 2, 2, 7171, 7179, 8, 509, 1,
	2, 7172, 7176, 5, 1082, 542, 2, 7173, 7175, 5, 1094, 548, 2, 7174, 7173,
	3, 2, 2, 2, 7175, 7178, 3, 2, 2, 2, 7176, 7174, 3, 2, 2, 2, 7176, 7177,
	3, 2, 2, 2, 7177, 7180, 3, 2, 2, 2, 7178, 7176, 3, 2, 2, 2, 7179, 7172,
	3, 2, 2, 2, 7179, 7180, 3, 2, 2, 2, 7180, 7181, 3, 2, 2, 2, 7181, 7182,
	5, 1048, 525, 2, 7182, 7207, 3, 2, 2, 2, 7183, 7201, 12, 3, 2, 2, 7184,
	7188, 5, 1084, 543, 2, 7185, 7187, 5, 1094, 548, 2, 7186, 7185, 3, 2, 2,
	2, 7187, 7190, 3, 2, 2, 2, 7188, 7186, 3, 2, 2, 2, 7188, 7189, 3, 2, 2,
	2, 7189, 7202, 3, 2, 2, 2, 7190, 7188, 3, 2, 2, 2, 7191, 7195, 7, 49, 2,
	2, 7192, 7194, 5, 1094, 548, 2, 7193, 7192, 3, 2, 2, 2, 7194, 7197, 3,
	2, 2, 2, 7195, 7193, 3, 2, 2, 2, 7195, 7196, 3, 2, 2, 2, 7196, 7198, 3,
	2, 2, 2, 7197, 7195, 3, 2, 2, 2, 7198, 7199, 5, 1016, 509, 2, 7199, 7200,
	7, 43, 2, 2, 7200, 7202, 3, 2, 2, 2, 7201, 7184, 3, 2, 2, 2, 7201, 7191,
	3, 2, 2, 2, 7202, 7203, 3, 2, 2, 2, 7203, 7204, 5, 1016, 509, 4, 7204,
	7206, 3, 2, 2, 2, 7205, 7183, 3, 2, 2, 2, 7206, 7209, 3, 2, 2, 2, 7207,
	7205, 3, 2, 2, 2, 7207, 7208, 3, 2, 2, 2, 7208, 1017, 3, 2, 2, 2, 7209,
	7207, 3, 2, 2, 2, 7210, 7216, 5, 1016, 509, 2, 7211, 7212, 7, 43, 2, 2,
	7212, 7213, 5, 1016, 509, 2, 7213, 7214, 7, 43, 2, 2, 7214, 7215, 5, 1016,
	509, 2, 7215, 7217, 3, 2, 2, 2, 7216, 7211, 3, 2, 2, 2, 7216, 7217, 3,
	2, 2, 2, 7217, 1019, 3, 2, 2, 2, 7218, 7222, 5, 1018, 510, 2, 7219, 7222,
	5, 240, 121, 2, 7220, 7222, 7, 16, 2, 2, 7221, 7218, 3, 2, 2, 2, 7221,
	7219, 3, 2, 2, 2, 7221, 7220, 3, 2, 2, 2, 7222, 1021, 3, 2, 2, 2, 7223,
	7227, 5, 1036, 519, 2, 7224, 7227, 5, 240, 121, 2, 7225, 7227, 7, 16, 2,
	2, 7226, 7223, 3, 2, 2, 2, 7226, 7224, 3, 2, 2, 2, 7226, 7225, 3, 2, 2,
	2, 7227, 1023, 3, 2, 2, 2, 7228, 7231, 5, 1016, 509, 2, 7229, 7231, 5,
	1026, 514, 2, 7230, 7228, 3, 2, 2, 2, 7230, 7229, 3, 2, 2, 2, 7231, 1025,
	3, 2, 2, 2, 7232, 7235, 5, 1028, 515, 2, 7233, 7235, 5, 1030, 516, 2, 7234,
	7232, 3, 2, 2, 2, 7234, 7233, 3, 2, 2, 2, 7235, 1027, 3, 2, 2, 2, 7236,
	7237, 5, 1016, 509, 2, 7237, 7238, 7, 43, 2, 2, 7238, 7239, 5, 1016, 509,
	2, 7239, 1029, 3, 2, 2, 2, 7240, 7241, 5, 1016, 509, 2, 7241, 7242, 9,
	60, 2, 2, 7242, 7243, 5, 1016, 509, 2, 7243, 1031, 3, 2, 2, 2, 7244, 7252,
	8, 517, 1, 2, 7245, 7249, 5, 1082, 542, 2, 7246, 7248, 5, 1094, 548, 2,
	7247, 7246, 3, 2, 2, 2, 7248, 7251, 3, 2, 2, 2, 7249, 7247, 3, 2, 2, 2,
	7249, 7250, 3, 2, 2, 2, 7250, 7253, 3, 2, 2, 2, 7251, 7249, 3, 2, 2, 2,
	7252, 7245, 3, 2, 2, 2, 7252, 7253, 3, 2, 2, 2, 7253, 7254, 3, 2, 2, 2,
	7254, 7268, 5, 1052, 527, 2, 7255, 7268, 5, 1014, 508, 2, 7256, 7257, 7,
	29, 2, 2, 7257, 7258, 5, 1078, 540, 2, 7258, 7259, 5, 700, 351, 2, 7259,
	7260, 5, 1032, 517, 2, 7260, 7261, 7, 31, 2, 2, 7261, 7268, 3, 2, 2, 2,
	7262, 7263, 7, 299, 2, 2, 7263, 7265, 5, 1182, 592, 2, 7264, 7266, 5, 1032,
	517, 2, 7265, 7264, 3, 2, 2, 2, 7265, 7266, 3, 2, 2, 2, 7266, 7268, 3,
	2, 2, 2, 7267, 7244, 3, 2, 2, 2, 7267, 7255, 3, 2, 2, 2, 7267, 7256, 3,
	2, 2, 2, 7267, 7262, 3, 2, 2, 2, 7268, 7308, 3, 2, 2, 2, 7269, 7270, 12,
	6, 2, 2, 7270, 7274, 5, 1084, 543, 2, 7271, 7273, 5, 1094, 548, 2, 7272,
	7271, 3, 2, 2, 2, 7273, 7276, 3, 2, 2, 2, 7274, 7272, 3, 2, 2, 2, 7274,
	7275, 3, 2, 2, 2, 7275, 7277, 3, 2, 2, 2, 7276, 7274, 3, 2, 2, 2, 7277,
	7278, 5, 1032, 517, 7, 7278, 7307, 3, 2, 2, 2, 7279, 7284, 12, 5, 2, 2,
	7280, 7281, 7, 27, 2, 2, 7281, 7283, 5, 1032, 517, 2, 7282, 7280, 3, 2,
	2, 2, 7283, 7286, 3, 2, 2, 2, 7284, 7282, 3, 2, 2, 2, 7284, 7285, 3, 2,
	2, 2, 7285, 7287, 3, 2, 2, 2, 7286, 7284, 3, 2, 2, 2, 7287, 7291, 7, 49,
	2, 2, 7288, 7290, 5, 1094, 548, 2, 7289, 7288, 3, 2, 2, 2, 7290, 7293,
	3, 2, 2, 2, 7291, 7289, 3, 2, 2, 2, 7291, 7292, 3, 2, 2, 2, 7292, 7294,
	3, 2, 2, 2, 7293, 7291, 3, 2, 2, 2, 7294, 7295, 5, 1032, 517, 2, 7295,
	7296, 7, 43, 2, 2, 7296, 7297, 5, 1032, 517, 6, 7297, 7307, 3, 2, 2, 2,
	7298, 7299, 12, 4, 2, 2, 7299, 7303, 7, 195, 2, 2, 7300, 7302, 5, 776,
	389, 2, 7301, 7300, 3, 2, 2, 2, 7302, 7305, 3, 2, 2, 2, 7303, 7301, 3,
	2, 2, 2, 7303, 7304, 3, 2, 2, 2, 7304, 7307, 3, 2, 2, 2, 7305, 7303, 3,
	2, 2, 2, 7306, 7269, 3, 2, 2, 2, 7306, 7279, 3, 2, 2, 2, 7306, 7298, 3,
	2, 2, 2, 7307, 7310, 3, 2, 2, 2, 7308, 7306, 3, 2, 2, 2, 7308, 7309, 3,
	2, 2, 2, 7309, 1033, 3, 2, 2, 2, 7310, 7308, 3, 2, 2, 2, 7311, 7319, 5,
	1032, 517, 2, 7312, 7313, 7, 52, 2, 2, 7313, 7314, 5, 1032, 517, 2, 7314,
	7315, 7, 43, 2, 2, 7315, 7316, 5, 1032, 517, 2, 7316, 7317, 7, 54, 2, 2,
	7317, 7319, 3, 2, 2, 2, 7318, 7311, 3, 2, 2, 2, 7318, 7312, 3, 2, 2, 2,
	7319, 1035, 3, 2, 2, 2, 7320, 7326, 5, 1032, 517, 2, 7321, 7322, 7, 43,
	2, 2, 7322, 7323, 5, 1032, 517, 2, 7323, 7324, 7, 43, 2, 2, 7324, 7325,
	5, 1032, 517, 2, 7325, 7327, 3, 2, 2, 2, 7326, 7321, 3, 2, 2, 2, 7326,
	7327, 3, 2, 2, 2, 7327, 1037, 3, 2, 2, 2, 7328, 7336, 8, 520, 1, 2, 7329,
	7333, 5, 1088, 545, 2, 7330, 7332, 5, 1094, 548, 2, 7331, 7330, 3, 2, 2,
	2, 7332, 7335, 3, 2, 2, 2, 7333, 7331, 3, 2, 2, 2, 7333, 7334, 3, 2, 2,
	2, 7334, 7337, 3, 2, 2, 2, 7335, 7333, 3, 2, 2, 2, 7336, 7329, 3, 2, 2,
	2, 7336, 7337, 3, 2, 2, 2, 7337, 7338, 3, 2, 2, 2, 7338, 7339, 5, 1050,
	526, 2, 7339, 7364, 3, 2, 2, 2, 7340, 7341, 12, 4, 2, 2, 7341, 7345, 5,
	1090, 546, 2, 7342, 7344, 5, 1094, 548, 2, 7343, 7342, 3, 2, 2, 2, 7344,
	7347, 3, 2, 2, 2, 7345, 7343, 3, 2, 2, 2, 7345, 7346, 3, 2, 2, 2, 7346,
	7348, 3, 2, 2, 2, 7347, 7345, 3, 2, 2, 2, 7348, 7349, 5, 1038, 520, 5,
	7349, 7363, 3, 2, 2, 2, 7350, 7351, 12, 3, 2, 2, 7351, 7355, 7, 49, 2,
	2, 7352, 7354, 5, 1094, 548, 2, 7353, 7352, 3, 2, 2, 2, 7354, 7357, 3,
	2, 2, 2, 7355, 7353, 3, 2, 2, 2, 7355, 7356, 3, 2, 2, 2, 7356, 7358, 3,
	2, 2, 2, 7357, 7355, 3, 2, 2, 2, 7358, 7359, 5, 1038, 520, 2, 7359, 7360,
	7, 43, 2, 2, 7360, 7361, 5, 1038, 520, 4, 7361, 7363, 3, 2, 2, 2, 7362,
	7340, 3, 2, 2, 2, 7362, 7350, 3, 2, 2, 2, 7363, 7366, 3, 2, 2, 2, 7364,
	7362, 3, 2, 2, 2, 7364, 7365, 3, 2, 2, 2, 7365, 1039, 3, 2, 2, 2, 7366,
	7364, 3, 2, 2, 2, 7367, 7373, 5, 1038, 520, 2, 7368, 7369, 7, 43, 2, 2,
	7369, 7370, 5, 1038, 520, 2, 7370, 7371, 7, 43, 2, 2, 7371, 7372, 5, 1038,
	520, 2, 7372, 7374, 3, 2, 2, 2, 7373, 7368, 3, 2, 2, 2, 7373, 7374, 3,
	2, 2, 2, 7374, 1041, 3, 2, 2, 2, 7375, 7378, 5, 1028, 515, 2, 7376, 7378,
	5, 1044, 523, 2, 7377, 7375, 3, 2, 2, 2, 7377, 7376, 3, 2, 2, 2, 7378,
	1043, 3, 2, 2, 2, 7379, 7380, 5, 1032, 517, 2, 7380, 7381, 9, 60, 2, 2,
	7381, 7382, 5, 1016, 509, 2, 7382, 1045, 3, 2, 2, 2, 7383, 7384, 5, 1016,
	509, 2, 7384, 1047, 3, 2, 2, 2, 7385, 7419, 5, 1058, 530, 2, 7386, 7389,
	5, 1228, 615, 2, 7387, 7389, 5, 1136, 569, 2, 7388, 7386, 3, 2, 2, 2, 7388,
	7387, 3, 2, 2, 2, 7389, 7390, 3, 2, 2, 2, 7390, 7391, 5, 1070, 536, 2,
	7391, 7419, 3, 2, 2, 2, 7392, 7396, 5, 1236, 619, 2, 7393, 7396, 5, 968,
	485, 2, 7394, 7396, 5, 970, 486, 2, 7395, 7392, 3, 2, 2, 2, 7395, 7393,
	3, 2, 2, 2, 7395, 7394, 3, 2, 2, 2, 7396, 7401, 3, 2, 2, 2, 7397, 7398,
	7, 52, 2, 2, 7398, 7399, 5, 1024, 513, 2, 7399, 7400, 7, 54, 2, 2, 7400,
	7402, 3, 2, 2, 2, 7401, 7397, 3, 2, 2, 2, 7401, 7402, 3, 2, 2, 2, 7402,
	7419, 3, 2, 2, 2, 7403, 7419, 5, 1142, 572, 2, 7404, 7407, 5, 1198, 600,
	2, 7405, 7407, 5, 250, 126, 2, 7406, 7404, 3, 2, 2, 2, 7406, 7405, 3, 2,
	2, 2, 7406, 7407, 3, 2, 2, 2, 7407, 7408, 3, 2, 2, 2, 7408, 7419, 5, 1134,
	568, 2, 7409, 7419, 5, 992, 497, 2, 7410, 7419, 5, 1072, 537, 2, 7411,
	7412, 7, 29, 2, 2, 7412, 7413, 5, 1018, 510, 2, 7413, 7414, 7, 31, 2, 2,
	7414, 7419, 3, 2, 2, 2, 7415, 7419, 5, 794, 398, 2, 7416, 7419, 5, 280,
	141, 2, 7417, 7419, 7, 230, 2, 2, 7418, 7385, 3, 2, 2, 2, 7418, 7388, 3,
	2, 2, 2, 7418, 7395, 3, 2, 2, 2, 7418, 7403, 3, 2, 2, 2, 7418, 7406, 3,
	2, 2, 2, 7418, 7409, 3, 2, 2, 2, 7418, 7410, 3, 2, 2, 2, 7418, 7411, 3,
	2, 2, 2, 7418, 7415, 3, 2, 2, 2, 7418, 7416, 3, 2, 2, 2, 7418, 7417, 3,
	2, 2, 2, 7419, 1049, 3, 2, 2, 2, 7420, 7430, 5, 1092, 547, 2, 7421, 7430,
	5, 1166, 584, 2, 7422, 7430, 5, 972, 487, 2, 7423, 7430, 5, 974, 488, 2,
	7424, 7430, 5, 1000, 501, 2, 7425, 7426, 7, 29, 2, 2, 7426, 7427, 5, 1040,
	521, 2, 7427, 7428, 7, 31, 2, 2, 7428, 7430, 3, 2, 2, 2, 7429, 7420, 3,
	2, 2, 2, 7429, 7421, 3, 2, 2, 2, 7429, 7422, 3, 2, 2, 2, 7429, 7423, 3,
	2, 2, 2, 7429, 7424, 3, 2, 2, 2, 7429, 7425, 3, 2, 2, 2, 7430, 1051, 3,
	2, 2, 2, 7431, 7468, 5, 1058, 530, 2, 7432, 7435, 5, 1054, 528, 2, 7433,
	7435, 5, 1198, 600, 2, 7434, 7432, 3, 2, 2, 2, 7434, 7433, 3, 2, 2, 2,
	7434, 7435, 3, 2, 2, 2, 7435, 7436, 3, 2, 2, 2, 7436, 7437, 5, 1150, 576,
	2, 7437, 7438, 5, 1064, 533, 2, 7438, 7468, 3, 2, 2, 2, 7439, 7468, 5,
	990, 496, 2, 7440, 7445, 5, 966, 484, 2, 7441, 7442, 7, 52, 2, 2, 7442,
	7443, 5, 1056, 529, 2, 7443, 7444, 7, 54, 2, 2, 7444, 7446, 3, 2, 2, 2,
	7445, 7441, 3, 2, 2, 2, 7445, 7446, 3, 2, 2, 2, 7446, 7468, 3, 2, 2, 2,
	7447, 7452, 5, 976, 489, 2, 7448, 7449, 7, 52, 2, 2, 7449, 7450, 5, 1056,
	529, 2, 7450, 7451, 7, 54, 2, 2, 7451, 7453, 3, 2, 2, 2, 7452, 7448, 3,
	2, 2, 2, 7452, 7453, 3, 2, 2, 2, 7453, 7468, 3, 2, 2, 2, 7454, 7468, 5,
	1000, 501, 2, 7455, 7468, 5, 572, 287, 2, 7456, 7457, 7, 29, 2, 2, 7457,
	7458, 5, 1036, 519, 2, 7458, 7459, 7, 31, 2, 2, 7459, 7468, 3, 2, 2, 2,
	7460, 7468, 5, 1074, 538, 2, 7461, 7468, 5, 790, 396, 2, 7462, 7468, 5,
	978, 490, 2, 7463, 7468, 5, 468, 235, 2, 7464, 7468, 7, 301, 2, 2, 7465,
	7468, 7, 16, 2, 2, 7466, 7468, 7, 230, 2, 2, 7467, 7431, 3, 2, 2, 2, 7467,
	7434, 3, 2, 2, 2, 7467, 7439, 3, 2, 2, 2, 7467, 7440, 3, 2, 2, 2, 7467,
	7447, 3, 2, 2, 2, 7467, 7454, 3, 2, 2, 2, 7467, 7455, 3, 2, 2, 2, 7467,
	7456, 3, 2, 2, 2, 7467, 7460, 3, 2, 2, 2, 7467, 7461, 3, 2, 2, 2, 7467,
	7462, 3, 2, 2, 2, 7467, 7463, 3, 2, 2, 2, 7467, 7464, 3, 2, 2, 2, 7467,
	7465, 3, 2, 2, 2, 7467, 7466, 3, 2, 2, 2, 7468, 1053, 3, 2, 2, 2, 7469,
	7470, 7, 209, 2, 2, 7470, 7472, 7, 46, 2, 2, 7471, 7469, 3, 2, 2, 2, 7471,
	7472, 3, 2, 2, 2, 7472, 7477, 3, 2, 2, 2, 7473, 7474, 5, 1060, 531, 2,
	7474, 7475, 7, 39, 2, 2, 7475, 7478, 3, 2, 2, 2, 7476, 7478, 5, 250, 126,
	2, 7477, 7473, 3, 2, 2, 2, 7477, 7476, 3, 2, 2, 2, 7477, 7478, 3, 2, 2,
	2, 7478, 1055, 3, 2, 2, 2, 7479, 7482, 5, 1032, 517, 2, 7480, 7482, 5,
	1042, 522, 2, 7481, 7479, 3, 2, 2, 2, 7481, 7480, 3, 2, 2, 2, 7482, 1057,
	3, 2, 2, 2, 7483, 7487, 5, 1092, 547, 2, 7484, 7487, 7, 347, 2, 2, 7485,
	7487, 7, 354, 2, 2, 7486, 7483, 3, 2, 2, 2, 7486, 7484, 3, 2, 2, 2, 7486,
	7485, 3, 2, 2, 2, 7487, 1059, 3, 2, 2, 2, 7488, 7491, 7, 301, 2, 2, 7489,
	7490, 7, 39, 2, 2, 7490, 7492, 7, 294, 2, 2, 7491, 7489, 3, 2, 2, 2, 7491,
	7492, 3, 2, 2, 2, 7492, 7495, 3, 2, 2, 2, 7493, 7495, 7, 294, 2, 2, 7494,
	7488, 3, 2, 2, 2, 7494, 7493, 3, 2, 2, 2, 7495, 1061, 3, 2, 2, 2, 7496,
	7497, 7, 52, 2, 2, 7497, 7498, 5, 1032, 517, 2, 7498, 7499, 7, 54, 2, 2,
	7499, 7501, 3, 2, 2, 2, 7500, 7496, 3, 2, 2, 2, 7501, 7504, 3, 2, 2, 2,
	7502, 7500, 3, 2, 2, 2, 7502, 7503, 3, 2, 2, 2, 7503, 1063, 3, 2, 2, 2,
	7504, 7502, 3, 2, 2, 2, 7505, 7506, 7, 39, 2, 2, 7506, 7507, 5, 1182, 592,
	2, 7507, 7508, 5, 1062, 532, 2, 7508, 7510, 3, 2, 2, 2, 7509, 7505, 3,
	2, 2, 2, 7510, 7513, 3, 2, 2, 2, 7511, 7509, 3, 2, 2, 2, 7511, 7512, 3,
	2, 2, 2, 7512, 7514, 3, 2, 2, 2, 7513, 7511, 3, 2, 2, 2, 7514, 7515, 7,
	39, 2, 2, 7515, 7517, 5, 1182, 592, 2, 7516, 7511, 3, 2, 2, 2, 7516, 7517,
	3, 2, 2, 2, 7517, 7518, 3, 2, 2, 2, 7518, 7523, 5, 1062, 532, 2, 7519,
	7520, 7, 52, 2, 2, 7520, 7521, 5, 1042, 522, 2, 7521, 7522, 7, 54, 2, 2,
	7522, 7524, 3, 2, 2, 2, 7523, 7519, 3, 2, 2, 2, 7523, 7524, 3, 2, 2, 2,
	7524, 1065, 3, 2, 2, 2, 7525, 7526, 7, 39, 2, 2, 7526, 7527, 5, 1182, 592,
	2, 7527, 7528, 5, 1062, 532, 2, 7528, 7530, 3, 2, 2, 2, 7529, 7525, 3,
	2, 2, 2, 7530, 7533, 3, 2, 2, 2, 7531, 7529, 3, 2, 2, 2, 7531, 7532, 3,
	2, 2, 2, 7532, 7534, 3, 2, 2, 2, 7533, 7531, 3, 2, 2, 2, 7534, 7535, 7,
	39, 2, 2, 7535, 7537, 5, 1182, 592, 2, 7536, 7531, 3, 2, 2, 2, 7536, 7537,
	3, 2, 2, 2, 7537, 7538, 3, 2, 2, 2, 7538, 7539, 5, 1062, 532, 2, 7539,
	1067, 3, 2, 2, 2, 7540, 7541, 7, 52, 2, 2, 7541, 7542, 5, 1016, 509, 2,
	7542, 7543, 7, 54, 2, 2, 7543, 7545, 3, 2, 2, 2, 7544, 7540, 3, 2, 2, 2,
	7545, 7548, 3, 2, 2, 2, 7546, 7544, 3, 2, 2, 2, 7546, 7547, 3, 2, 2, 2,
	7547, 1069, 3, 2, 2, 2, 7548, 7546, 3, 2, 2, 2, 7549, 7550, 7, 39, 2, 2,
	7550, 7551, 5, 1182, 592, 2, 7551, 7552, 5, 1068, 535, 2, 7552, 7554, 3,
	2, 2, 2, 7553, 7549, 3, 2, 2, 2, 7554, 7557, 3, 2, 2, 2, 7555, 7553, 3,
	2, 2, 2, 7555, 7556, 3, 2, 2, 2, 7556, 7558, 3, 2, 2, 2, 7557, 7555, 3,
	2, 2, 2, 7558, 7559, 7, 39, 2, 2, 7559, 7561, 5, 1182, 592, 2, 7560, 7555,
	3, 2, 2, 2, 7560, 7561, 3, 2, 2, 2, 7561, 7562, 3, 2, 2, 2, 7562, 7567,
	5, 1068, 535, 2, 7563, 7564, 7, 52, 2, 2, 7564, 7565, 5, 1026, 514, 2,
	7565, 7566, 7, 54, 2, 2, 7566, 7568, 3, 2, 2, 2, 7567, 7563, 3, 2, 2, 2,
	7567, 7568, 3, 2, 2, 2, 7568, 1071, 3, 2, 2, 2, 7569, 7570, 5, 572, 287,
	2, 7570, 1073, 3, 2, 2, 2, 7571, 7572, 5, 238, 120, 2, 7572, 7573, 7, 53,
	2, 2, 7573, 7574, 7, 29, 2, 2, 7574, 7575, 5, 1032, 517, 2, 7575, 7576,
	7, 31, 2, 2, 7576, 1075, 3, 2, 2, 2, 7577, 7578, 5, 1220, 611, 2, 7578,
	7579, 5, 1070, 536, 2, 7579, 7596, 3, 2, 2, 2, 7580, 7581, 7, 58, 2, 2,
	7581, 7586, 5, 1076, 539, 2, 7582, 7583, 7, 38, 2, 2, 7583, 7585, 5, 1076,
	539, 2, 7584, 7582, 3, 2, 2, 2, 7585, 7588, 3, 2, 2, 2, 7586, 7584, 3,
	2, 2, 2, 7586, 7587, 3, 2, 2, 2, 7587, 7589, 3, 2, 2, 2, 7588, 7586, 3,
	2, 2, 2, 7589, 7590, 7, 64, 2, 2, 7590, 7596, 3, 2, 2, 2, 7591, 7593, 5,
	792, 397, 2, 7592, 7591, 3, 2, 2, 2, 7592, 7593, 3, 2, 2, 2, 7593, 7594,
	3, 2, 2, 2, 7594, 7596, 5, 796, 399, 2, 7595, 7577, 3, 2, 2, 2, 7595, 7580,
	3, 2, 2, 2, 7595, 7592, 3, 2, 2, 2, 7596, 1077, 3, 2, 2, 2, 7597, 7598,
	5, 1060, 531, 2, 7598, 7599, 7, 39, 2, 2, 7599, 7602, 3, 2, 2, 2, 7600,
	7602, 5, 1198, 600, 2, 7601, 7597, 3, 2, 2, 2, 7601, 7600, 3, 2, 2, 2,
	7601, 7602, 3, 2, 2, 2, 7602, 7603, 3, 2, 2, 2, 7603, 7604, 5, 1164, 583,
	2, 7604, 7605, 5, 1064, 533, 2, 7605, 7623, 3, 2, 2, 2, 7606, 7607, 7,
	58, 2, 2, 7607, 7612, 5, 1078, 540, 2, 7608, 7609, 7, 38, 2, 2, 7609, 7611,
	5, 1078, 540, 2, 7610, 7608, 3, 2, 2, 2, 7611, 7614, 3, 2, 2, 2, 7612,
	7610, 3, 2, 2, 2, 7612, 7613, 3, 2, 2, 2, 7613, 7615, 3, 2, 2, 2, 7614,
	7612, 3, 2, 2, 2, 7615, 7616, 7, 64, 2, 2, 7616, 7623, 3, 2, 2, 2, 7617,
	7619, 5, 792, 397, 2, 7618, 7617, 3, 2, 2, 2, 7618, 7619, 3, 2, 2, 2, 7619,
	7620, 3, 2, 2, 2, 7620, 7623, 5, 798, 400, 2, 7621, 7623, 5, 978, 490,
	2, 7622, 7601, 3, 2, 2, 2, 7622, 7606, 3, 2, 2, 2, 7622, 7618, 3, 2, 2,
	2, 7622, 7621, 3, 2, 2, 2, 7623, 1079, 3, 2, 2, 2, 7624, 7625, 5, 1060,
	531, 2, 7625, 7626, 7, 39, 2, 2, 7626, 7629, 3, 2, 2, 2, 7627, 7629, 5,
	1198, 600, 2, 7628, 7624, 3, 2, 2, 2, 7628, 7627, 3, 2, 2, 2, 7628, 7629,
	3, 2, 2, 2, 7629, 7630, 3, 2, 2, 2, 7630, 7631, 5, 1164, 583, 2, 7631,
	7632, 5, 1066, 534, 2, 7632, 1081, 3, 2, 2, 2, 7633, 7634, 9, 61, 2, 2,
	7634, 1083, 3, 2, 2, 2, 7635, 7636, 9, 62, 2, 2, 7636, 1085, 3, 2, 2, 2,
	7637, 7638, 9, 63, 2, 2, 7638, 1087, 3, 2, 2, 2, 7639, 7640, 9, 64, 2,
	2, 7640, 1089, 3, 2, 2, 2, 7641, 7642, 9, 65, 2, 2, 7642, 1091, 3, 2, 2,
	2, 7643, 7644, 9, 66, 2, 2, 7644, 1093, 3, 2, 2, 2, 7645, 7646, 7, 30,
	2, 2, 7646, 7651, 5, 1096, 549, 2, 7647, 7648, 7, 38, 2, 2, 7648, 7650,
	5, 1096, 549, 2, 7649, 7647, 3, 2, 2, 2, 7650, 7653, 3, 2, 2, 2, 7651,
	7649, 3, 2, 2, 2, 7651, 7652, 3, 2, 2, 2, 7652, 7654, 3, 2, 2, 2, 7653,
	7651, 3, 2, 2, 2, 7654, 7655, 7, 33, 2, 2, 7655, 1095, 3, 2, 2, 2, 7656,
	7659, 5, 1098, 550, 2, 7657, 7658, 7, 80, 2, 2, 7658, 7660, 5, 1016, 509,
	2, 7659, 7657, 3, 2, 2, 2, 7659, 7660, 3, 2, 2, 2, 7660, 1097, 3, 2, 2,
	2, 7661, 7662, 5, 1166, 584, 2, 7662, 1099, 3, 2, 2, 2, 7663, 7664, 5,
	1166, 584, 2, 7664, 1101, 3, 2, 2, 2, 7665, 7666, 5, 1166, 584, 2, 7666,
	1103, 3, 2, 2, 2, 7667, 7668, 5, 1166, 584, 2, 7668, 1105, 3, 2, 2, 2,
	7669, 7670, 7, 357, 2, 2, 7670, 1107, 3, 2, 2, 2, 7671, 7672, 5, 1166,
	584, 2, 7672, 1109, 3, 2, 2, 2, 7673, 7674, 5, 1166, 584, 2, 7674, 1111,
	3, 2, 2, 2, 7675, 7676, 5, 1166, 584, 2, 7676, 1113, 3, 2, 2, 2, 7677,
	7678, 5, 1246, 624, 2, 7678, 1115, 3, 2, 2, 2, 7679, 7680, 5, 1166, 584,
	2, 7680, 1117, 3, 2, 2, 2, 7681, 7682, 5, 1166, 584, 2, 7682, 1119, 3,
	2, 2, 2, 7683, 7684, 5, 1166, 584, 2, 7684, 1121, 3, 2, 2, 2, 7685, 7686,
	5, 1166, 584, 2, 7686, 1123, 3, 2, 2, 2, 7687, 7688, 5, 1166, 584, 2, 7688,
	1125, 3, 2, 2, 2, 7689, 7690, 5, 1246, 624, 2, 7690, 1127, 3, 2, 2, 2,
	7691, 7692, 5, 1166, 584, 2, 7692, 1129, 3, 2, 2, 2, 7693, 7694, 5, 1166,
	584, 2, 7694, 1131, 3, 2, 2, 2, 7695, 7696, 5, 1246, 624, 2, 7696, 1133,
	3, 2, 2, 2, 7697, 7698, 5, 1166, 584, 2, 7698, 1135, 3, 2, 2, 2, 7699,
	7700, 5, 1166, 584, 2, 7700, 1137, 3, 2, 2, 2, 7701, 7702, 5, 1166, 584,
	2, 7702, 1139, 3, 2, 2, 2, 7703, 7704, 5, 1166, 584, 2, 7704, 1141, 3,
	2, 2, 2, 7705, 7706, 5, 1166, 584, 2, 7706, 1143, 3, 2, 2, 2, 7707, 7708,
	5, 1150, 576, 2, 7708, 1145, 3, 2, 2, 2, 7709, 7710, 5, 1150, 576, 2, 7710,
	1147, 3, 2, 2, 2, 7711, 7712, 5, 1150, 576, 2, 7712, 1149, 3, 2, 2, 2,
	7713, 7715, 7, 20, 2, 2, 7714, 7713, 3, 2, 2, 2, 7714, 7715, 3, 2, 2, 2,
	7715, 7722, 3, 2, 2, 2, 7716, 7717, 5, 1166, 584, 2, 7717, 7718, 5, 1068,
	535, 2, 7718, 7719, 7, 39, 2, 2, 7719, 7721, 3, 2, 2, 2, 7720, 7716, 3,
	2, 2, 2, 7721, 7724, 3, 2, 2, 2, 7722, 7720, 3, 2, 2, 2, 7722, 7723, 3,
	2, 2, 2, 7723, 7725, 3, 2, 2, 2, 7724, 7722, 3, 2, 2, 2, 7725, 7726, 5,
	1166, 584, 2, 7726, 1151, 3, 2, 2, 2, 7727, 7728, 5, 1150, 576, 2, 7728,
	1153, 3, 2, 2, 2, 7729, 7730, 5, 1150, 576, 2, 7730, 1155, 3, 2, 2, 2,
	7731, 7732, 5, 1150, 576, 2, 7732, 1157, 3, 2, 2, 2, 7733, 7734, 5, 1150,
	576, 2, 7734, 1159, 3, 2, 2, 2, 7735, 7736, 5, 1150, 576, 2, 7736, 1161,
	3, 2, 2, 2, 7737, 7738, 5, 1150, 576, 2, 7738, 1163, 3, 2, 2, 2, 7739,
	7740, 5, 1150, 576, 2, 7740, 1165, 3, 2, 2, 2, 7741, 7742, 7, 357, 2, 2,
	7742, 1167, 3, 2, 2, 2, 7743, 7744, 5, 1166, 584, 2, 7744, 1169, 3, 2,
	2, 2, 7745, 7746, 5, 1166, 584, 2, 7746, 1171, 3, 2, 2, 2, 7747, 7748,
	5, 1166, 584, 2, 7748, 1173, 3, 2, 2, 2, 7749, 7750, 5, 1166, 584, 2, 7750,
	1175, 3, 2, 2, 2, 7751, 7752, 5, 1166, 584, 2, 7752, 1177, 3, 2, 2, 2,
	7753, 7754, 5, 1166, 584, 2, 7754, 1179, 3, 2, 2, 2, 7755, 7756, 5, 1166,
	584, 2, 7756, 1181, 3, 2, 2, 2, 7757, 7758, 5, 1166, 584, 2, 7758, 1183,
	3, 2, 2, 2, 7759, 7760, 5, 1166, 584, 2, 7760, 1185, 3, 2, 2, 2, 7761,
	7762, 5, 1166, 584, 2, 7762, 1187, 3, 2, 2, 2, 7763, 7764, 5, 1166, 584,
	2, 7764, 1189, 3, 2, 2, 2, 7765, 7766, 5, 1166, 584, 2, 7766, 1191, 3,
	2, 2, 2, 7767, 7768, 5, 1166, 584, 2, 7768, 1193, 3, 2, 2, 2, 7769, 7770,
	5, 1166, 584, 2, 7770, 1195, 3, 2, 2, 2, 7771, 7772, 5, 1166, 584, 2, 7772,
	1197, 3, 2, 2, 2, 7773, 7776, 5, 1196, 599, 2, 7774, 7776, 7, 21, 2, 2,
	7775, 7773, 3, 2, 2, 2, 7775, 7774, 3, 2, 2, 2, 7776, 7777, 3, 2, 2, 2,
	7777, 7778, 7, 46, 2, 2, 7778, 1199, 3, 2, 2, 2, 7779, 7780, 5, 1166, 584,
	2, 7780, 1201, 3, 2, 2, 2, 7781, 7782, 5, 1166, 584, 2, 7782, 1203, 3,
	2, 2, 2, 7783, 7784, 5, 1166, 584, 2, 7784, 1205, 3, 2, 2, 2, 7785, 7786,
	5, 1166, 584, 2, 7786, 1207, 3, 2, 2, 2, 7787, 7788, 5, 1166, 584, 2, 7788,
	1209, 3, 2, 2, 2, 7789, 7791, 5, 1198, 600, 2, 7790, 7789, 3, 2, 2, 2,
	7790, 7791, 3, 2, 2, 2, 7791, 7792, 3, 2, 2, 2, 7792, 7793, 5, 1112, 557,
	2, 7793, 1211, 3, 2, 2, 2, 7794, 7796, 5, 1198, 600, 2, 7795, 7794, 3,
	2, 2, 2, 7795, 7796, 3, 2, 2, 2, 7796, 7797, 3, 2, 2, 2, 7797, 7798, 5,
	1124, 563, 2, 7798, 1213, 3, 2, 2, 2, 7799, 7801, 5, 1198, 600, 2, 7800,
	7799, 3, 2, 2, 2, 7800, 7801, 3, 2, 2, 2, 7801, 7802, 3, 2, 2, 2, 7802,
	7803, 5, 1110, 556, 2, 7803, 1215, 3, 2, 2, 2, 7804, 7806, 5, 1198, 600,
	2, 7805, 7804, 3, 2, 2, 2, 7805, 7806, 3, 2, 2, 2, 7806, 7807, 3, 2, 2,
	2, 7807, 7808, 5, 1166, 584, 2, 7808, 1217, 3, 2, 2, 2, 7809, 7810, 5,
	1060, 531, 2, 7810, 7811, 7, 39, 2, 2, 7811, 7815, 3, 2, 2, 2, 7812, 7815,
	5, 250, 126, 2, 7813, 7815, 5, 1198, 600, 2, 7814, 7809, 3, 2, 2, 2, 7814,
	7812, 3, 2, 2, 2, 7814, 7813, 3, 2, 2, 2, 7814, 7815, 3, 2, 2, 2, 7815,
	7816, 3, 2, 2, 2, 7816, 7817, 5, 1144, 573, 2, 7817, 1219, 3, 2, 2, 2,
	7818, 7820, 5, 1198, 600, 2, 7819, 7818, 3, 2, 2, 2, 7819, 7820, 3, 2,
	2, 2, 7820, 7821, 3, 2, 2, 2, 7821, 7824, 5, 1190, 596, 2, 7822, 7824,
	5, 1152, 577, 2, 7823, 7819, 3, 2, 2, 2, 7823, 7822, 3, 2, 2, 2, 7824,
	1221, 3, 2, 2, 2, 7825, 7827, 5, 1198, 600, 2, 7826, 7825, 3, 2, 2, 2,
	7826, 7827, 3, 2, 2, 2, 7827, 7828, 3, 2, 2, 2, 7828, 7831, 5, 1208, 605,
	2, 7829, 7831, 5, 1156, 579, 2, 7830, 7826, 3, 2, 2, 2, 7830, 7829, 3,
	2, 2, 2, 7831, 1223, 3, 2, 2, 2, 7832, 7834, 5, 1198, 600, 2, 7833, 7832,
	3, 2, 2, 2, 7833, 7834, 3, 2, 2, 2, 7834, 7835, 3, 2, 2, 2, 7835, 7838,
	5, 1232, 617, 2, 7836, 7838, 5, 1158, 580, 2, 7837, 7833, 3, 2, 2, 2, 7837,
	7836, 3, 2, 2, 2, 7838, 1225, 3, 2, 2, 2, 7839, 7841, 5, 1198, 600, 2,
	7840, 7839, 3, 2, 2, 2, 7840, 7841, 3, 2, 2, 2, 7841, 7842, 3, 2, 2, 2,
	7842, 7845, 5, 1240, 621, 2, 7843, 7845, 5, 1162, 582, 2, 7844, 7840, 3,
	2, 2, 2, 7844, 7843, 3, 2, 2, 2, 7845, 1227, 3, 2, 2, 2, 7846, 7849, 5,
	1198, 600, 2, 7847, 7849, 5, 250, 126, 2, 7848, 7846, 3, 2, 2, 2, 7848,
	7847, 3, 2, 2, 2, 7848, 7849, 3, 2, 2, 2, 7849, 7850, 3, 2, 2, 2, 7850,
	7867, 5, 1200, 601, 2, 7851, 7856, 5, 1140, 571, 2, 7852, 7853, 7, 52,
	2, 2, 7853, 7854, 5, 1016, 509, 2, 7854, 7855, 7, 54, 2, 2, 7855, 7857,
	3, 2, 2, 2, 7856, 7852, 3, 2, 2, 2, 7856, 7857, 3, 2, 2, 2, 7857, 7858,
	3, 2, 2, 2, 7858, 7859, 7, 39, 2, 2, 7859, 7861, 3, 2, 2, 2, 7860, 7851,
	3, 2, 2, 2, 7861, 7864, 3, 2, 2, 2, 7862, 7860, 3, 2, 2, 2, 7862, 7863,
	3, 2, 2, 2, 7863, 7865, 3, 2, 2, 2, 7864, 7862, 3, 2, 2, 2, 7865, 7867,
	5, 1200, 601, 2, 7866, 7848, 3, 2, 2, 2, 7866, 7862, 3, 2, 2, 2, 7867,
	1229, 3, 2, 2, 2, 7868, 7869, 7, 209, 2, 2, 7869, 7873, 7, 46, 2, 2, 7870,
	7873, 5, 1198, 600, 2, 7871, 7873, 5, 250, 126, 2, 7872, 7868, 3, 2, 2,
	2, 7872, 7870, 3, 2, 2, 2, 7872, 7871, 3, 2, 2, 2, 7872, 7873, 3, 2, 2,
	2, 7873, 7874, 3, 2, 2, 2, 7874, 7875, 5, 1244, 623, 2, 7875, 1231, 3,
	2, 2, 2, 7876, 7877, 5, 1166, 584, 2, 7877, 1233, 3, 2, 2, 2, 7878, 7879,
	5, 1166, 584, 2, 7879, 1235, 3, 2, 2, 2, 7880, 7881, 5, 1166, 584, 2, 7881,
	1237, 3, 2, 2, 2, 7882, 7883, 5, 1166, 584, 2, 7883, 1239, 3, 2, 2, 2,
	7884, 7885, 5, 1166, 584, 2, 7885, 1241, 3, 2, 2, 2, 7886, 7887, 5, 1166,
	584, 2, 7887, 1243, 3, 2, 2, 2, 7888, 7889, 5, 1166, 584, 2, 7889, 1245,
	3, 2, 2, 2, 7890, 7891, 5, 1166, 584, 2, 7891, 1247, 3, 2, 2, 2, 982, 1251,
	1258, 1267, 1276, 1279, 1288, 1293, 1305, 1310, 1313, 1318, 1323, 1329,
	1333, 1341, 1346, 1352, 1356, 1359, 1365, 1370, 1376, 1380, 1385, 1391,
	1396, 1401, 1409, 1414, 1420, 1425, 1427, 1433, 1438, 1444, 1448, 1453,
	1459, 1464, 1474, 1479, 1485, 1490, 1492, 1497, 1502, 1508, 1512, 1520,
	1525, 1531, 1535, 1538, 1544, 1549, 1555, 1559, 1564, 1570, 1575, 1585,
	1590, 1596, 1601, 1603, 1608, 1613, 1619, 1623, 1631, 1636, 1642, 1646,
	1649, 1657, 1660, 1666, 1672, 1678, 1681, 1685, 1689, 1697, 1699, 1707,
	1710, 1716, 1722, 1726, 1732, 1740, 1743, 1749, 1755, 1761, 1767, 1770,
	1780, 1785, 1790, 1795, 1801, 1807, 1813, 1818, 1827, 1829, 1835, 1841,
	1844, 1855, 1863, 1872, 1880, 1886, 1889, 1896, 1904, 1907, 1913, 1917,
	1926, 1931, 1939, 1944, 1951, 1956, 1958, 1962, 1968, 1973, 1976, 1982,
	1987, 1990, 1996, 2000, 2005, 2008, 2014, 2017, 2020, 2035, 2041, 2046,
	2053, 2064, 2068, 2076, 2084, 2094, 2097, 2104, 2114, 2121, 2131, 2138,
	2144, 2150, 2155, 2163, 2170, 2175, 2187, 2194, 2202, 2209, 2217, 2220,
	2224, 2232, 2237, 2239, 2244, 2249, 2255, 2263, 2271, 2277, 2282, 2290,
	2294, 2300, 2307, 2313, 2317, 2324, 2329, 2340, 2343, 2358, 2360, 2363,
	2369, 2374, 2382, 2386, 2389, 2394, 2402, 2409, 2413, 2418, 2424, 2431,
	2441, 2448, 2450, 2456, 2459, 2465, 2471, 2476, 2480, 2484, 2488, 2493,
	2496, 2502, 2512, 2515, 2520, 2526, 2529, 2539, 2551, 2558, 2565, 2571,
	2590, 2606, 2612, 2620, 2624, 2631, 2636, 2642, 2645, 2654, 2666, 2673,
	2686, 2691, 2698, 2709, 2717, 2725, 2729, 2745, 2754, 2759, 2768, 2771,
	2774, 2783, 2791, 2800, 2809, 2812, 2823, 2826, 2830, 2837, 2846, 2852,
	2860, 2863, 2867, 2875, 2895, 2900, 2908, 2911, 2918, 2924, 2933, 2937,
	2942, 2947, 2953, 2955, 2962, 2969, 2974, 2982, 2989, 2996, 3000, 3004,
	3008, 3014, 3021, 3025, 3028, 3033, 3038, 3042, 3045, 3049, 3051, 3058,
	3061, 3065, 3072, 3077, 3081, 3086, 3097, 3103, 3110, 3118, 3123, 3127,
	3135, 3140, 3142, 3148, 3157, 3166, 3182, 3200, 3202, 3206, 3214, 3218,
	3225, 3232, 3240, 3247, 3255, 3260, 3268, 3276, 3283, 3291, 3296, 3304,
	3312, 3319, 3324, 3331, 3336, 3340, 3348, 3356, 3363, 3371, 3376, 3383,
	3388, 3395, 3400, 3404, 3415, 3420, 3426, 3431, 3438, 3443, 3450, 3457,
	3471, 3476, 3483, 3488, 3493, 3495, 3498, 3505, 3509, 3519, 3524, 3533,
	3538, 3546, 3552, 3561, 3565, 3574, 3581, 3586, 3593, 3596, 3601, 3607,
	3614, 3617, 3622, 3627, 3631, 3636, 3639, 3648, 3654, 3658, 3672, 3680,
	3687, 3692, 3699, 3702, 3707, 3713, 3717, 3724, 3730, 3734, 3737, 3744,
	3749, 3751, 3756, 3761, 3766, 3776, 3779, 3784, 3789, 3794, 3799, 3803,
	3811, 3823, 3831, 3837, 3848, 3856, 3860, 3868, 3873, 3880, 3884, 3891,
	3924, 3932, 3948, 3951, 3954, 3958, 3962, 3969, 3973, 3980, 3986, 3991,
	3996, 4002, 4005, 4011, 4016, 4021, 4028, 4034, 4039, 4041, 4048, 4053,
	4059, 4062, 4070, 4078, 4098, 4108, 4118, 4126, 4145, 4152, 4160, 4169,
	4174, 4180, 4183, 4189, 4194, 4199, 4206, 4212, 4217, 4219, 4226, 4231,
	4238, 4248, 4253, 4257, 4261, 4269, 4274, 4283, 4291, 4304, 4307, 4309,
	4318, 4321, 4330, 4335, 4338, 4341, 4345, 4349, 4356, 4360, 4367, 4373,
	4378, 4383, 4392, 4408, 4414, 4422, 4432, 4435, 4438, 4444, 4450, 4455,
	4462, 4474, 4478, 4486, 4497, 4506, 4509, 4512, 4517, 4526, 4534, 4542,
	4547, 4551, 4557, 4560, 4571, 4580, 4584, 4588, 4595, 4601, 4604, 4611,
	4618, 4620, 4634, 4642, 4651, 4658, 4663, 4672, 4683, 4688, 4696, 4701,
	4707, 4712, 4717, 4728, 4732, 4743, 4745, 4757, 4759, 4761, 4773, 4779,
	4781, 4788, 4798, 4814, 4817, 4830, 4836, 4844, 4849, 4853, 4856, 4861,
	4864, 4867, 4871, 4875, 4882, 4886, 4893, 4899, 4906, 4913, 4920, 4923,
	4930, 4937, 4944, 4951, 4954, 4961, 4968, 4971, 4978, 4985, 4992, 5003,
	5010, 5017, 5024, 5031, 5036, 5039, 5052, 5063, 5074, 5084, 5090, 5098,
	5106, 5115, 5126, 5136, 5146, 5158, 5162, 5192, 5199, 5207, 5216, 5224,
	5227, 5235, 5242, 5250, 5258, 5266, 5269, 5274, 5278, 5283, 5290, 5293,
	5296, 5300, 5307, 5314, 5321, 5330, 5340, 5348, 5351, 5356, 5360, 5365,
	5372, 5375, 5378, 5384, 5400, 5416, 5420, 5429, 5439, 5449, 5457, 5460,
	5466, 5471, 5476, 5482, 5484, 5489, 5493, 5496, 5502, 5507, 5514, 5522,
	5533, 5567, 5575, 5586, 5598, 5605, 5608, 5615, 5620, 5626, 5632, 5637,
	5642, 5648, 5654, 5662, 5666, 5671, 5676, 5686, 5706, 5714, 5718, 5725,
	5737, 5740, 5748, 5757, 5760, 5764, 5768, 5772, 5778, 5785, 5791, 5795,
	5799, 5811, 5820, 5826, 5831, 5833, 5842, 5847, 5863, 5868, 5877, 5882,
	5889, 5899, 5907, 5910, 5915, 5926, 5931, 5942, 5950, 5953, 5958, 5965,
	5968, 5976, 5979, 5988, 6002, 6014, 6023, 6036, 6039, 6043, 6052, 6065,
	6078, 6088, 6093, 6099, 6103, 6107, 6110, 6118, 6129, 6141, 6157, 6161,
	6165, 6186, 6194, 6197, 6200, 6213, 6221, 6227, 6230, 6234, 6238, 6251,
	6255, 6260, 6267, 6271, 6276, 6299, 6323, 6327, 6334, 6340, 6345, 6352,
	6354, 6362, 6375, 6379, 6385, 6389, 6393, 6397, 6399, 6403, 6406, 6413,
	6419, 6423, 6426, 6431, 6446, 6456, 6463, 6469, 6476, 6484, 6493, 6495,
	6501, 6510, 6517, 6520, 6532, 6538, 6544, 6554, 6561, 6570, 6586, 6596,
	6605, 6610, 6616, 6625, 6638, 6644, 6652, 6661, 6672, 6680, 6688, 6695,
	6703, 6711, 6718, 6726, 6752, 6754, 6792, 6799, 6803, 6809, 6818, 6822,
	6828, 6845, 6849, 6859, 6870, 6886, 6904, 6913, 6921, 6932, 6937, 6948,
	6955, 6962, 6968, 6973, 6977, 6982, 6984, 6986, 6990, 6997, 7008, 7015,
	7029, 7035, 7038, 7043, 7047, 7051, 7058, 7062, 7069, 7075, 7082, 7089,
	7092, 7096, 7102, 7109, 7116, 7122, 7128, 7131, 7136, 7139, 7142, 7149,
	7155, 7164, 7169, 7176, 7179, 7188, 7195, 7201, 7207, 7216, 7221, 7226,
	7230, 7234, 7249, 7252, 7265, 7267, 7274, 7284, 7291, 7303, 7306, 7308,
	7318, 7326, 7333, 7336, 7345, 7355, 7362, 7364, 7373, 7377, 7388, 7395,
	7401, 7406, 7418, 7429, 7434, 7445, 7452, 7467, 7471, 7477, 7481, 7486,
	7491, 7494, 7502, 7511, 7516, 7523, 7531, 7536, 7546, 7555, 7560, 7567,
	7586, 7592, 7595, 7601, 7612, 7618, 7622, 7628, 7651, 7659, 7714, 7722,
	7775, 7790, 7795, 7800, 7805, 7814, 7819, 7823, 7826, 7830, 7833, 7837,
	7840, 7844, 7848, 7856, 7862, 7866, 7872,
}
var literalNames = []string{
	"", "'-'", "'--'", "'!'", "'!='", "'!=?'", "'!=='", "'\"DPI\"'", "'\"DPI-C\"'",
	"'#'", "'##'", "'#-#'", "'#=#'", "'#0'", "'$'", "'$error'", "'$fatal'",
	"'$info'", "'$root.'", "'$unit'", "'$warning'", "'%'", "'%='", "'&'", "'&&'",
	"'&&&'", "'&='", "'('", "'(*'", "')'", "'*'", "'*)'", "'**'", "'*::*'",
	"'*='", "'*>'", "','", "'.'", "'.*'", "'/'", "'/='", "':'", "'-:'", "':/'",
	"'::'", "':='", "';'", "'?'", "'@'", "'@@'", "'['", "'''", "']'", "'^'",
	"'^~'", "'^='", "'{'", "'|'", "'||'", "'|='", "'|=>'", "'|->'", "'}'",
	"'~'", "'~&'", "'~^'", "'~|'", "'+'", "'+:'", "'++'", "'+='", "'<'", "'<<'",
	"'<<<'", "'<<<='", "'<<='", "'<='", "'<->'", "'='", "'-='", "'=='", "'==?'",
	"'==='", "'=>'", "'>'", "'->'", "'>='", "'>>'", "'->>'", "'>>='", "'>>>'",
	"'>>>='", "'1step'", "'accept_on'", "'alias'", "'always'", "'always_comb'",
	"'always_ff'", "'always_latch'", "'and'", "'assert'", "'assign'", "'assume'",
	"'automatic'", "'before'", "'begin'", "'bind'", "'bins'", "'binsof'", "'bit'",
	"'break'", "'buf'", "'bufif0'", "'bufif1'", "'byte'", "'case'", "'casex'",
	"'casez'", "'cell'", "'chandle'", "'checker'", "'class'", "'clocking'",
	"'cmos'", "'config'", "'const'", "'constraint'", "'context'", "'continue'",
	"'cover'", "'covergroup'", "'coverpoint'", "'cross'", "'deassign'", "'default'",
	"'defparam'", "'design'", "'disable'", "'dist'", "'do'", "'edge'", "'else'",
	"'end'", "'endcase'", "'endchecker'", "'endclass'", "'endclocking'", "'endconfig'",
	"'endfunction'", "'endgenerate'", "'endgroup'", "'endinterface'", "'endmodule'",
	"'endpackage'", "'endprogram'", "'endproperty'", "'endsequence'", "'endspecify'",
	"'endtask'", "'enum'", "'event'", "'eventually'", "'expect'", "'export'",
	"'extends'", "'extern'", "'final'", "'first_match'", "'for'", "'force'",
	"'foreach'", "'forever'", "'fork'", "'forkjoin'", "'function'", "'generate'",
	"'genvar'", "'global'", "'highz0'", "'highz1'", "'if'", "'iff'", "'ifnone'",
	"'ignore_bins'", "'illegal_bins'", "'implements'", "'implies'", "'import'",
	"'-incdir'", "'include'", "'initial'", "'inout'", "'input'", "'inside'",
	"'instance'", "'int'", "'integer'", "'interconnect'", "'interface'", "'intersect'",
	"'join'", "'join_any'", "'join_none'", "'large'", "'let'", "'liblist'",
	"'library'", "'local'", "'localparam'", "'logic'", "'longint'", "'macromodule'",
	"'matches'", "'medium'", "'member_identifier'", "'modport'", "'module'",
	"'nand'", "'negedge'", "'nettype'", "'new'", "'nexttime'", "'nmos'", "'nor'",
	"'noshowcancelled'", "'not'", "'notif0'", "'notif1'", "'null'", "'option'",
	"'or'", "'output'", "'package'", "'packed'", "'parameter'", "'PATHPULSE$'",
	"'pmos'", "'posedge'", "'priority'", "'program'", "'property'", "'protected'",
	"'pull0'", "'pull1'", "'pulldown'", "'pullup'", "'pulsestyle_ondetect'",
	"'pulsestyle_onevent'", "'pure'", "'rand'", "'randc'", "'randcase'", "'randomize'",
	"'randsequence'", "'rcmos'", "'real'", "'realtime'", "'ref'", "'reg'",
	"'reject_on'", "'release'", "'repeat'", "'restrict'", "'return'", "'rnmos'",
	"'rpmos'", "'rtran'", "'rtranif0'", "'rtranif1'", "'s_always'", "'s_eventually'",
	"'s_nexttime'", "'s_until'", "'s_until_with'", "'scalared'", "'sequence'",
	"'shortint'", "'shortreal'", "'showcancelled'", "'signed'", "'small'",
	"'soft'", "'solve'", "'specify'", "'specparam'", "'static'", "'std'", "'string'",
	"'strong'", "'strong0'", "'strong1'", "'struct'", "'super'", "'supply0'",
	"'supply1'", "'sync_accept_on'", "'sync_reject_on'", "'tagged'", "'task'",
	"'this'", "'throughout'", "'time'", "'timeprecision'", "'timeunit'", "'tran'",
	"'tranif0'", "'tranif1'", "'tri'", "'tri0'", "'tri1'", "'triand'", "'trior'",
	"'trireg'", "'type'", "'type_option'", "'typedef'", "'union'", "'unique'",
	"'unique0'", "'unsigned'", "'until'", "'until_with'", "'untyped'", "'use'",
	"'uwire'", "'var'", "'vectored'", "'virtual'", "'void'", "'wait'", "'wait_order'",
	"'wand'", "'weak'", "'weak0'", "'weak1'", "'while'", "'wildcard'", "'wire'",
	"'with'", "'within'", "'wor'", "'xnor'", "'xor'",
}
var symbolicNames = []string{
	"", "MINUS", "MINUSMINS", "NOT", "NE", "NEQ", "NEE", "DPI", "DPIC", "P",
	"PP", "PMP", "PEP", "PZ", "DOLLAR", "DERROR", "DFATAL", "DINFO", "DROOT",
	"DUNIT", "DWARNING", "PER", "PE", "AND", "ANDAND", "ANDANDAND", "AE", "LP",
	"LPS", "RP", "STAR", "SRP", "SS", "SCCS", "SEQ", "SGT", "COMMA", "DOT",
	"DOTSTAR", "SLASH", "SLASHEQ", "COLON", "MCOLON", "COLONSLASH", "COLONCOLON",
	"COLONEQ", "SEMI", "QUES", "AT", "ATAT", "LB", "QUOTE", "RB", "CARET",
	"CARETSQUIG", "CARETEQ", "LC", "BAR", "BARBAR", "BAREQ", "BAREQGT", "BARARROW",
	"RC", "SQUIG", "SQUIGAND", "SQUIGCARET", "SQUIGBAR", "PLUS", "PLUSCOLON",
	"PLUSPLUS", "PLUSEQ", "LT", "LTLT", "LTLTLT", "LTLTLTEQ", "LTLTEQ", "LTEQ",
	"LTMINUSGT", "EQ", "MINUSEQ", "EQEQ", "EQEQQUEST", "EQEQEQ", "EQGT", "GT",
	"ARROW", "GE", "GTGT", "MINUSGTGT", "GTGTEQ", "GTGTGT", "GTGTGTEQ", "KONESTEP",
	"KACCEPT_ON", "KALIAS", "KALWAYS", "KALWAYS_COMB", "KALWAYS_FF", "KALWAYS_LATCH",
	"KAND", "KASSERT", "KASSIGN", "KASSUME", "KAUTOMATIC", "KBEFORE", "KBEGIN",
	"KBIND", "KBINS", "KBINSOF", "KBIT", "KBREAK", "KBUF", "KBUFIF0", "KBUFIF1",
	"KBYTE", "KCASE", "KCASEX", "KCASEZ", "KCELL", "KCHANDLE", "KCHECKER",
	"KCLASS", "KCLOCKING", "KCMOS", "KCONFIG", "KCONST", "KCONSTRAINT", "KCONTEXT",
	"KCONTINUE", "KCOVER", "KCOVERGROUP", "KCOVERPOINT", "KCROSS", "KDEASSIGN",
	"KDEFAULT", "KDEFPARAM", "KDESIGN", "KDISABLE", "KDIST", "KDO", "KEDGE",
	"KELSE", "KEND", "KENDCASE", "KENDCHECKER", "KENDCLASS", "KENDCLOCKING",
	"KENDCONFIG", "KENDFUNCTION", "KENDGENERATE", "KENDGROUP", "KENDINTERFACE",
	"KENDMODULE", "KENDPACKAGE", "KENDPROGRAM", "KENDPROPERTY", "KENDSEQUENCE",
	"KENDSPECIFY", "KENDTASK", "KENUM", "KEVENT", "KEVENTUALLY", "KEXPECT",
	"KEXPORT", "KEXTENDS", "KEXTERN", "KFINAL", "KFIRST_MATCH", "KFOR", "KFORCE",
	"KFOREACH", "KFOREVER", "KFORK", "KFORKJOIN", "KFUNCTION", "KGENERATE",
	"KGENVAR", "KGLOBAL", "KHIGHZ0", "KHIGHZ1", "KIF", "KIFF", "KIFNONE", "KIGNORE_BINS",
	"KILLEGAL_BINS", "KIMPLEMENTS", "KIMPLIES", "KIMPORT", "KINCDIR", "KINCLUDE",
	"KINITIAL", "KINOUT", "KINPUT", "KINSIDE", "KINSTANCE", "KINT", "KINTEGER",
	"KINTERCONNECT", "KINTERFACE", "KINTERSECT", "KJOIN", "KJOIN_ANY", "KJOIN_NONE",
	"KLARGE", "KLET", "KLIBLIST", "KLIBRARY", "KLOCAL", "KLOCALPARAM", "KLOGIC",
	"KLONGINT", "KMACROMODULE", "KMATCHES", "KMEDIUM", "KMEMBER_IDENTIFIER",
	"KMODPORT", "KMODULE", "KNAND", "KNEGEDGE", "KNETTYPE", "KNEW", "KNEXTTIME",
	"KNMOS", "KNOR", "KNOSHOWCANCELLED", "KNOT", "KNOTIF0", "KNOTIF1", "KNULL",
	"KOPTION", "KOR", "KOUTPUT", "KPACKAGE", "KPACKED", "KPARAMETER", "KPATHPULSE",
	"KPMOS", "KPOSEDGE", "KPRIORITY", "KPROGRAM", "KPROPERTY", "KPROTECTED",
	"KPULL0", "KPULL1", "KPULLDOWN", "KPULLUP", "KPULSESTYLE_ONDETECT", "KPULSESTYLE_ONEVENT",
	"KPURE", "KRAND", "KRANDC", "KRANDCASE", "KRANDOMIZE", "KRANDSEQUENCE",
	"KRCMOS", "KREAL", "KREALTIME", "KREF", "KREG", "KREJECT_ON", "KRELEASE",
	"KREPEAT", "KRESTRICT", "KRETURN", "KRNMOS", "KRPMOS", "KRTRAN", "KRTRANIF0",
	"KRTRANIF1", "KS_ALWAYS", "KS_EVENTUALLY", "KS_NEXTTIME", "KS_UNTIL", "KS_UNTIL_WITH",
	"KSCALARED", "KSEQUENCE", "KSHORTINT", "KSHORTREAL", "KSHOWCANCELLED",
	"KSIGNED", "KSMALL", "KSOFT", "KSOLVE", "KSPECIFY", "KSPECPARAM", "KSTATIC",
	"KSTD", "KSTRING", "KSTRONG", "KSTRONG0", "KSTRONG1", "KSTRUCT", "KSUPER",
	"KSUPPLY0", "KSUPPLY1", "KSYNC_ACCEPT_ON", "KSYNC_REJECT_ON", "KTAGGED",
	"KTASK", "KTHIS", "KTHROUGHOUT", "KTIME", "KTIMEPRECISION", "KTIMEUNIT",
	"KTRAN", "KTRANIF0", "KTRANIF1", "KTRI", "KTRI0", "KTRI1", "KTRIAND", "KTRIOR",
	"KTRIREG", "KTYPE", "KTYPE_OPTION", "KTYPEDEF", "KUNION", "KUNIQUE", "KUNIQUE0",
	"KUNSIGNED", "KUNTIL", "KUNTIL_WITH", "KUNTYPED", "KUSE", "KUWIRE", "KVAR",
	"KVECTORED", "KVIRTUAL", "KVOID", "KWAIT", "KWAIT_ORDER", "KWAND", "KWEAK",
	"KWEAK0", "KWEAK1", "KWHILE", "KWILDCARD", "KWIRE", "KWITH", "KWITHIN",
	"KWOR", "KXNOR", "KXOR", "COMPILER_DIRECTIVE", "FILE_PATH_SPEC", "TIME_LITERAL",
	"DECIMAL_NUMBER", "BINARY_NUMBER", "OCTAL_NUMBER", "HEX_NUMBER", "REAL_NUMBER",
	"UNSIGNED_NUMBER", "STRING_LITERAL", "ONE_LINE_COMMENT", "BLOCK_COMMENT",
	"SIMPLE_IDENTIFIER", "SYSTEM_TF_IDENTIFIER", "WHITE_SPACE",
}

var ruleNames = []string{
	"library_text", "library_description", "library_declaration", "include_statement",
	"source_text", "description", "module_nonansi_header", "module_ansi_header",
	"module_declaration", "module_keyword", "interface_declaration", "interface_nonansi_header",
	"interface_ansi_header", "program_declaration", "program_nonansi_header",
	"program_ansi_header", "checker_declaration", "class_declaration", "interface_class_type",
	"interface_class_declaration", "interface_class_item", "interface_class_method",
	"package_declaration", "timeunits_declaration", "parameter_port_list",
	"parameter_port_declaration", "list_of_ports", "list_of_port_declarations",
	"port_declaration", "port", "port_expression", "port_reference", "port_direction",
	"net_port_header", "variable_port_header", "interface_port_header", "ansi_port_declaration",
	"elaboration_system_task", "module_common_item", "module_item", "module_or_generate_item",
	"module_or_generate_item_declaration", "non_port_module_item", "parameter_override",
	"bind_directive", "bind_target_scope", "bind_target_instance", "bind_target_instance_list",
	"bind_instantiation", "config_declaration", "design_statement", "config_rule_statement",
	"default_clause", "inst_clause", "inst_name", "cell_clause", "liblist_clause",
	"use_clause", "interface_or_generate_item", "extern_tf_declaration", "interface_item",
	"non_port_interface_item", "program_item", "non_port_program_item", "program_generate_item",
	"checker_port_list", "checker_port_item", "checker_port_direction", "checker_or_generate_item",
	"checker_or_generate_item_declaration", "checker_generate_item", "class_item",
	"class_property", "class_method", "class_constructor_prototype", "class_constraint",
	"class_item_qualifier", "property_qualifier", "random_qualifier", "method_qualifier",
	"method_prototype", "class_constructor_declaration", "constraint_declaration",
	"constraint_block", "constraint_block_item", "solve_before_list", "constraint_primary",
	"constraint_expression", "uniqueness_constraint", "constraint_set", "dist_list",
	"dist_item", "dist_weight", "constraint_prototype", "constraint_prototype_qualifier",
	"extern_constraint_declaration", "identifier_list", "package_item", "package_or_generate_item_declaration",
	"anonymous_program", "anonymous_program_item", "local_parameter_declaration",
	"parameter_declaration", "specparam_declaration", "inout_declaration",
	"input_declaration", "output_declaration", "interface_port_declaration",
	"ref_declaration", "data_declaration", "package_import_declaration", "package_import_item",
	"package_export_declaration", "genvar_declaration", "net_declaration",
	"type_declaration", "net_type_declaration", "lifetime", "casting_type",
	"data_type", "data_type_or_implicit", "implicit_data_type", "enum_base_type",
	"enum_name_declaration", "class_scope", "class_type", "integer_type", "integer_atom_type",
	"integer_vector_type", "non_integer_type", "net_type", "net_port_type",
	"variable_port_type", "var_data_type", "signing", "simple_type", "struct_union_member",
	"data_type_or_void", "struct_union", "type_reference", "drive_strength",
	"strength0", "strength1", "charge_strength", "delay3", "delay2", "delay_value",
	"list_of_defparam_assignments", "list_of_genvar_identifiers", "list_of_interface_identifiers",
	"list_of_net_decl_assignments", "list_of_param_assignments", "list_of_port_identifiers",
	"list_of_udp_port_identifiers", "list_of_specparam_assignments", "list_of_tf_variable_identifiers",
	"list_of_type_assignments", "list_of_variable_decl_assignments", "list_of_variable_identifiers",
	"list_of_variable_port_identifiers", "defparam_assignment", "net_decl_assignment",
	"param_assignment", "specparam_assignment", "type_assignment", "pulse_control_specparam",
	"error_limit_value", "reject_limit_value", "limit_value", "variable_decl_assignment",
	"class_new", "dynamic_array_new", "unpacked_dimension", "packed_dimension",
	"associative_dimension", "variable_dimension", "queue_dimension", "unsized_dimension",
	"function_data_type_or_implicit", "function_declaration", "function_body_declaration",
	"function_prototype", "dpi_import_export", "dpi_spec_string", "dpi_function_import_property",
	"dpi_task_import_property", "dpi_function_proto", "dpi_task_proto", "task_declaration",
	"task_body_declaration", "tf_item_declaration", "tf_port_list", "tf_port_item",
	"tf_port_direction", "tf_port_declaration", "task_prototype", "block_item_declaration",
	"modport_declaration", "modport_item", "modport_ports_declaration", "modport_clocking_declaration",
	"modport_simple_ports_declaration", "modport_simple_port", "modport_tf_ports_declaration",
	"modport_tf_port", "import_export", "concurrent_assertion_item", "concurrent_assertion_statement",
	"assert_property_statement", "assume_property_statement", "cover_property_statement",
	"expect_property_statement", "cover_sequence_statement", "restrict_property_statement",
	"property_instance", "property_list_of_arguments", "property_actual_arg",
	"assertion_item_declaration", "property_declaration", "property_port_list",
	"property_port_item", "property_lvar_port_direction", "property_formal_type",
	"property_spec", "property_expr", "property_case_item", "sequence_declaration",
	"sequence_port_list", "sequence_port_item", "sequence_lvar_port_direction",
	"sequence_formal_type", "sequence_expr", "cycle_delay_range", "sequence_method_call",
	"sequence_match_item", "sequence_instance", "sequence_list_of_arguments",
	"sequence_actual_arg", "boolean_abbrev", "sequence_abbrev", "consecutive_repetition",
	"non_consecutive_repetition", "goto_repetition", "const_or_range_expression",
	"cycle_delay_const_range_expression", "expression_or_dist", "assertion_variable_declaration",
	"covergroup_declaration", "coverage_spec_or_option", "coverage_option",
	"coverage_spec", "coverage_event", "block_event_expression", "hierarchical_btf_identifier",
	"cover_point", "bins_or_empty", "bins_or_options", "bins_keyword", "trans_list",
	"trans_set", "trans_range_list", "trans_item", "repeat_range", "cover_cross",
	"list_of_cross_items", "cross_item", "cross_body", "cross_body_item", "bins_selection_or_option",
	"bins_selection", "select_expression", "select_condition", "bins_expression",
	"covergroup_range_list", "covergroup_value_range", "with_covergroup_expression",
	"set_covergroup_expression", "integer_covergroup_expression", "cross_set_expression",
	"covergroup_expression", "let_declaration", "let_identifier", "let_port_list",
	"let_port_item", "let_formal_type", "let_expression", "let_list_of_arguments",
	"let_actual_arg", "gate_instantiation", "cmos_switch_instance", "enable_gate_instance",
	"mos_switch_instance", "n_input_gate_instance", "n_output_gate_instance",
	"pass_switch_instance", "pass_enable_switch_instance", "pull_gate_instance",
	"pulldown_strength", "pullup_strength", "enable_terminal", "inout_terminal",
	"input_terminal", "ncontrol_terminal", "output_terminal", "pcontrol_terminal",
	"cmos_switchtype", "enable_gatetype", "mos_switchtype", "n_input_gatetype",
	"n_output_gatetype", "pass_en_switchtype", "pass_switchtype", "module_instantiation",
	"parameter_value_assignment", "list_of_parameter_assignments", "ordered_parameter_assignment",
	"named_parameter_assignment", "hierarchical_instance", "name_of_instance",
	"list_of_port_connections", "ordered_port_connection", "named_port_connection",
	"interface_instantiation", "program_instantiation", "checker_instantiation",
	"list_of_checker_port_connections", "ordered_checker_port_connection",
	"named_checker_port_connection", "generate_region", "loop_generate_construct",
	"genvar_initialization", "genvar_iteration", "conditional_generate_construct",
	"if_generate_construct", "case_generate_construct", "case_generate_item",
	"generate_block", "generate_item", "continuous_assign", "list_of_net_assignments",
	"list_of_variable_assignments", "net_alias", "net_assignment", "initial_construct",
	"always_construct", "always_keyword", "final_construct", "blocking_assignment",
	"operator_assignment", "assignment_operator", "nonblocking_assignment",
	"procedural_continuous_assignment", "variable_assignment", "action_block",
	"seq_block", "par_block", "join_keyword", "statement_or_null", "statement",
	"statement_item", "function_statement", "function_statement_or_null", "variable_identifier_list",
	"procedural_timing_control_statement", "delay_or_event_control", "delay_control",
	"event_control", "event_expression", "procedural_timing_control", "jump_statement",
	"wait_statement", "event_trigger", "disable_statement", "conditional_statement",
	"unique_priority", "cond_predicate", "expression_or_cond_pattern", "cond_pattern",
	"case_statement", "case_keyword", "case_expression", "case_item", "case_pattern_item",
	"case_inside_item", "case_item_expression", "randcase_statement", "randcase_item",
	"open_range_list", "open_value_range", "pattern", "assignment_pattern",
	"structure_pattern_key", "array_pattern_key", "assignment_pattern_key",
	"assignment_pattern_expression", "assignment_pattern_expression_type",
	"constant_assignment_pattern_expression", "assignment_pattern_net_lvalue",
	"assignment_pattern_variable_lvalue", "loop_statement", "for_initialization",
	"for_variable_declaration", "for_step", "for_step_assignment", "loop_variables",
	"subroutine_call_statement", "assertion_item", "deferred_immediate_assertion_item",
	"procedural_assertion_statement", "immediate_assertion_statement", "simple_immediate_assertion_statement",
	"simple_immediate_assert_statement", "simple_immediate_assume_statement",
	"simple_immediate_cover_statement", "deferred_immediate_assertion_statement",
	"deferred_immediate_assert_statement", "deferred_immediate_assume_statement",
	"deferred_immediate_cover_statement", "clocking_declaration", "clocking_event",
	"clocking_item", "default_skew", "clocking_direction", "list_of_clocking_decl_assign",
	"clocking_decl_assign", "clocking_skew", "clocking_drive", "cycle_delay",
	"clockvar", "clockvar_expression", "randsequence_statement", "production",
	"rs_rule", "rs_production_list", "weight_specification", "rs_code_block",
	"rs_prod", "production_item", "rs_if_else", "rs_repeat", "rs_case", "rs_case_item",
	"specify_block", "specify_item", "pulsestyle_declaration", "showcancelled_declaration",
	"path_declaration", "simple_path_declaration", "parallel_path_description",
	"full_path_description", "list_of_path_inputs", "list_of_path_outputs",
	"specify_input_terminal_descriptor", "specify_output_terminal_descriptor",
	"input_identifier", "output_identifier", "path_delay_value", "list_of_path_delay_expressions",
	"t_path_delay_expression", "trise_path_delay_expression", "tfall_path_delay_expression",
	"tz_path_delay_expression", "t01_path_delay_expression", "t10_path_delay_expression",
	"t0z_path_delay_expression", "tz1_path_delay_expression", "t1z_path_delay_expression",
	"tz0_path_delay_expression", "t0x_path_delay_expression", "tx1_path_delay_expression",
	"t1x_path_delay_expression", "tx0_path_delay_expression", "txz_path_delay_expression",
	"tzx_path_delay_expression", "path_delay_expression", "edge_sensitive_path_declaration",
	"parallel_edge_sensitive_path_description", "full_edge_sensitive_path_description",
	"data_source_expression", "edge_identifier", "state_dependent_path_declaration",
	"polarity_operator", "concatenation", "constant_concatenation", "constant_multiple_concatenation",
	"module_path_concatenation", "module_path_multiple_concatenation", "multiple_concatenation",
	"streaming_concatenation", "stream_operator", "slice_size", "stream_concatenation",
	"stream_expression", "array_range_expression", "empty_unpacked_array_concatenation",
	"constant_function_call", "tf_call", "system_tf_call", "subroutine_call",
	"function_subroutine_call", "list_of_arguments", "method_call_body", "built_in_method_call",
	"array_manipulation_call", "randomize_call", "array_method_name", "inc_or_dec_expression",
	"constant_expression", "constant_mintypmax_expression", "constant_param_expression",
	"param_expression", "constant_range_expression", "constant_part_select_range",
	"constant_range", "constant_indexed_range", "expression", "value_range",
	"mintypmax_expression", "module_path_expression", "module_path_mintypmax_expression",
	"part_select_range", "indexed_range", "genvar_expression", "constant_primary",
	"module_path_primary", "primary", "class_qualifier", "range_expression",
	"primary_literal", "implicit_class_handle", "bit_select", "select_", "nonrange_select",
	"constant_bit_select", "constant_select", "constant_let_expression", "cast",
	"net_lvalue", "variable_lvalue", "nonrange_variable_lvalue", "unary_operator",
	"binary_operator", "inc_or_dec_operator", "unary_module_path_operator",
	"binary_module_path_operator", "number", "attribute_instance", "attr_spec",
	"attr_name", "array_identifier", "block_identifier", "bin_identifier",
	"c_identifier", "cell_identifier", "checker_identifier", "class_identifier",
	"class_variable_identifier", "clocking_identifier", "config_identifier",
	"const_identifier", "constraint_identifier", "covergroup_identifier", "covergroup_variable_identifier",
	"cover_point_identifier", "cross_identifier", "dynamic_array_variable_identifier",
	"enum_identifier", "formal_port_identifier", "function_identifier", "generate_block_identifier",
	"genvar_identifier", "hierarchical_array_identifier", "hierarchical_block_identifier",
	"hierarchical_event_identifier", "hierarchical_identifier", "hierarchical_net_identifier",
	"hierarchical_parameter_identifier", "hierarchical_property_identifier",
	"hierarchical_sequence_identifier", "hierarchical_task_identifier", "hierarchical_tf_identifier",
	"hierarchical_variable_identifier", "identifier", "index_variable_identifier",
	"interface_identifier", "interface_instance_identifier", "inout_port_identifier",
	"input_port_identifier", "instance_identifier", "library_identifier", "member_identifier",
	"method_identifier", "modport_identifier", "module_identifier", "net_identifier",
	"net_type_identifier", "output_port_identifier", "package_identifier",
	"package_scope", "parameter_identifier", "port_identifier", "production_identifier",
	"program_identifier", "property_identifier", "ps_class_identifier", "ps_covergroup_identifier",
	"ps_checker_identifier", "ps_identifier", "ps_or_hierarchical_array_identifier",
	"ps_or_hierarchical_net_identifier", "ps_or_hierarchical_property_identifier",
	"ps_or_hierarchical_sequence_identifier", "ps_or_hierarchical_tf_identifier",
	"ps_parameter_identifier", "ps_type_identifier", "sequence_identifier",
	"signal_identifier", "specparam_identifier", "task_identifier", "tf_identifier",
	"topmodule_identifier", "type_identifier", "variable_identifier",
}

type SystemVerilogParser struct {
	*antlr.BaseParser
}

// NewSystemVerilogParser produces a new parser instance for the optional input antlr.TokenStream.
//
// The *SystemVerilogParser instance produced may be reused by calling the SetInputStream method.
// The initial parser configuration is expensive to construct, and the object is not thread-safe;
// however, if used within a Golang sync.Pool, the construction cost amortizes well and the
// objects can be used in a thread-safe manner.
func NewSystemVerilogParser(input antlr.TokenStream) *SystemVerilogParser {
	this := new(SystemVerilogParser)
	deserializer := antlr.NewATNDeserializer(nil)
	deserializedATN := deserializer.DeserializeFromUInt16(parserATN)
	decisionToDFA := make([]*antlr.DFA, len(deserializedATN.DecisionToState))
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "SystemVerilogParser.g4"

	return this
}

// SystemVerilogParser tokens.
const (
	SystemVerilogParserEOF                  = antlr.TokenEOF
	SystemVerilogParserMINUS                = 1
	SystemVerilogParserMINUSMINS            = 2
	SystemVerilogParserNOT                  = 3
	SystemVerilogParserNE                   = 4
	SystemVerilogParserNEQ                  = 5
	SystemVerilogParserNEE                  = 6
	SystemVerilogParserDPI                  = 7
	SystemVerilogParserDPIC                 = 8
	SystemVerilogParserP                    = 9
	SystemVerilogParserPP                   = 10
	SystemVerilogParserPMP                  = 11
	SystemVerilogParserPEP                  = 12
	SystemVerilogParserPZ                   = 13
	SystemVerilogParserDOLLAR               = 14
	SystemVerilogParserDERROR               = 15
	SystemVerilogParserDFATAL               = 16
	SystemVerilogParserDINFO                = 17
	SystemVerilogParserDROOT                = 18
	SystemVerilogParserDUNIT                = 19
	SystemVerilogParserDWARNING             = 20
	SystemVerilogParserPER                  = 21
	SystemVerilogParserPE                   = 22
	SystemVerilogParserAND                  = 23
	SystemVerilogParserANDAND               = 24
	SystemVerilogParserANDANDAND            = 25
	SystemVerilogParserAE                   = 26
	SystemVerilogParserLP                   = 27
	SystemVerilogParserLPS                  = 28
	SystemVerilogParserRP                   = 29
	SystemVerilogParserSTAR                 = 30
	SystemVerilogParserSRP                  = 31
	SystemVerilogParserSS                   = 32
	SystemVerilogParserSCCS                 = 33
	SystemVerilogParserSEQ                  = 34
	SystemVerilogParserSGT                  = 35
	SystemVerilogParserCOMMA                = 36
	SystemVerilogParserDOT                  = 37
	SystemVerilogParserDOTSTAR              = 38
	SystemVerilogParserSLASH                = 39
	SystemVerilogParserSLASHEQ              = 40
	SystemVerilogParserCOLON                = 41
	SystemVerilogParserMCOLON               = 42
	SystemVerilogParserCOLONSLASH           = 43
	SystemVerilogParserCOLONCOLON           = 44
	SystemVerilogParserCOLONEQ              = 45
	SystemVerilogParserSEMI                 = 46
	SystemVerilogParserQUES                 = 47
	SystemVerilogParserAT                   = 48
	SystemVerilogParserATAT                 = 49
	SystemVerilogParserLB                   = 50
	SystemVerilogParserQUOTE                = 51
	SystemVerilogParserRB                   = 52
	SystemVerilogParserCARET                = 53
	SystemVerilogParserCARETSQUIG           = 54
	SystemVerilogParserCARETEQ              = 55
	SystemVerilogParserLC                   = 56
	SystemVerilogParserBAR                  = 57
	SystemVerilogParserBARBAR               = 58
	SystemVerilogParserBAREQ                = 59
	SystemVerilogParserBAREQGT              = 60
	SystemVerilogParserBARARROW             = 61
	SystemVerilogParserRC                   = 62
	SystemVerilogParserSQUIG                = 63
	SystemVerilogParserSQUIGAND             = 64
	SystemVerilogParserSQUIGCARET           = 65
	SystemVerilogParserSQUIGBAR             = 66
	SystemVerilogParserPLUS                 = 67
	SystemVerilogParserPLUSCOLON            = 68
	SystemVerilogParserPLUSPLUS             = 69
	SystemVerilogParserPLUSEQ               = 70
	SystemVerilogParserLT                   = 71
	SystemVerilogParserLTLT                 = 72
	SystemVerilogParserLTLTLT               = 73
	SystemVerilogParserLTLTLTEQ             = 74
	SystemVerilogParserLTLTEQ               = 75
	SystemVerilogParserLTEQ                 = 76
	SystemVerilogParserLTMINUSGT            = 77
	SystemVerilogParserEQ                   = 78
	SystemVerilogParserMINUSEQ              = 79
	SystemVerilogParserEQEQ                 = 80
	SystemVerilogParserEQEQQUEST            = 81
	SystemVerilogParserEQEQEQ               = 82
	SystemVerilogParserEQGT                 = 83
	SystemVerilogParserGT                   = 84
	SystemVerilogParserARROW                = 85
	SystemVerilogParserGE                   = 86
	SystemVerilogParserGTGT                 = 87
	SystemVerilogParserMINUSGTGT            = 88
	SystemVerilogParserGTGTEQ               = 89
	SystemVerilogParserGTGTGT               = 90
	SystemVerilogParserGTGTGTEQ             = 91
	SystemVerilogParserKONESTEP             = 92
	SystemVerilogParserKACCEPT_ON           = 93
	SystemVerilogParserKALIAS               = 94
	SystemVerilogParserKALWAYS              = 95
	SystemVerilogParserKALWAYS_COMB         = 96
	SystemVerilogParserKALWAYS_FF           = 97
	SystemVerilogParserKALWAYS_LATCH        = 98
	SystemVerilogParserKAND                 = 99
	SystemVerilogParserKASSERT              = 100
	SystemVerilogParserKASSIGN              = 101
	SystemVerilogParserKASSUME              = 102
	SystemVerilogParserKAUTOMATIC           = 103
	SystemVerilogParserKBEFORE              = 104
	SystemVerilogParserKBEGIN               = 105
	SystemVerilogParserKBIND                = 106
	SystemVerilogParserKBINS                = 107
	SystemVerilogParserKBINSOF              = 108
	SystemVerilogParserKBIT                 = 109
	SystemVerilogParserKBREAK               = 110
	SystemVerilogParserKBUF                 = 111
	SystemVerilogParserKBUFIF0              = 112
	SystemVerilogParserKBUFIF1              = 113
	SystemVerilogParserKBYTE                = 114
	SystemVerilogParserKCASE                = 115
	SystemVerilogParserKCASEX               = 116
	SystemVerilogParserKCASEZ               = 117
	SystemVerilogParserKCELL                = 118
	SystemVerilogParserKCHANDLE             = 119
	SystemVerilogParserKCHECKER             = 120
	SystemVerilogParserKCLASS               = 121
	SystemVerilogParserKCLOCKING            = 122
	SystemVerilogParserKCMOS                = 123
	SystemVerilogParserKCONFIG              = 124
	SystemVerilogParserKCONST               = 125
	SystemVerilogParserKCONSTRAINT          = 126
	SystemVerilogParserKCONTEXT             = 127
	SystemVerilogParserKCONTINUE            = 128
	SystemVerilogParserKCOVER               = 129
	SystemVerilogParserKCOVERGROUP          = 130
	SystemVerilogParserKCOVERPOINT          = 131
	SystemVerilogParserKCROSS               = 132
	SystemVerilogParserKDEASSIGN            = 133
	SystemVerilogParserKDEFAULT             = 134
	SystemVerilogParserKDEFPARAM            = 135
	SystemVerilogParserKDESIGN              = 136
	SystemVerilogParserKDISABLE             = 137
	SystemVerilogParserKDIST                = 138
	SystemVerilogParserKDO                  = 139
	SystemVerilogParserKEDGE                = 140
	SystemVerilogParserKELSE                = 141
	SystemVerilogParserKEND                 = 142
	SystemVerilogParserKENDCASE             = 143
	SystemVerilogParserKENDCHECKER          = 144
	SystemVerilogParserKENDCLASS            = 145
	SystemVerilogParserKENDCLOCKING         = 146
	SystemVerilogParserKENDCONFIG           = 147
	SystemVerilogParserKENDFUNCTION         = 148
	SystemVerilogParserKENDGENERATE         = 149
	SystemVerilogParserKENDGROUP            = 150
	SystemVerilogParserKENDINTERFACE        = 151
	SystemVerilogParserKENDMODULE           = 152
	SystemVerilogParserKENDPACKAGE          = 153
	SystemVerilogParserKENDPROGRAM          = 154
	SystemVerilogParserKENDPROPERTY         = 155
	SystemVerilogParserKENDSEQUENCE         = 156
	SystemVerilogParserKENDSPECIFY          = 157
	SystemVerilogParserKENDTASK             = 158
	SystemVerilogParserKENUM                = 159
	SystemVerilogParserKEVENT               = 160
	SystemVerilogParserKEVENTUALLY          = 161
	SystemVerilogParserKEXPECT              = 162
	SystemVerilogParserKEXPORT              = 163
	SystemVerilogParserKEXTENDS             = 164
	SystemVerilogParserKEXTERN              = 165
	SystemVerilogParserKFINAL               = 166
	SystemVerilogParserKFIRST_MATCH         = 167
	SystemVerilogParserKFOR                 = 168
	SystemVerilogParserKFORCE               = 169
	SystemVerilogParserKFOREACH             = 170
	SystemVerilogParserKFOREVER             = 171
	SystemVerilogParserKFORK                = 172
	SystemVerilogParserKFORKJOIN            = 173
	SystemVerilogParserKFUNCTION            = 174
	SystemVerilogParserKGENERATE            = 175
	SystemVerilogParserKGENVAR              = 176
	SystemVerilogParserKGLOBAL              = 177
	SystemVerilogParserKHIGHZ0              = 178
	SystemVerilogParserKHIGHZ1              = 179
	SystemVerilogParserKIF                  = 180
	SystemVerilogParserKIFF                 = 181
	SystemVerilogParserKIFNONE              = 182
	SystemVerilogParserKIGNORE_BINS         = 183
	SystemVerilogParserKILLEGAL_BINS        = 184
	SystemVerilogParserKIMPLEMENTS          = 185
	SystemVerilogParserKIMPLIES             = 186
	SystemVerilogParserKIMPORT              = 187
	SystemVerilogParserKINCDIR              = 188
	SystemVerilogParserKINCLUDE             = 189
	SystemVerilogParserKINITIAL             = 190
	SystemVerilogParserKINOUT               = 191
	SystemVerilogParserKINPUT               = 192
	SystemVerilogParserKINSIDE              = 193
	SystemVerilogParserKINSTANCE            = 194
	SystemVerilogParserKINT                 = 195
	SystemVerilogParserKINTEGER             = 196
	SystemVerilogParserKINTERCONNECT        = 197
	SystemVerilogParserKINTERFACE           = 198
	SystemVerilogParserKINTERSECT           = 199
	SystemVerilogParserKJOIN                = 200
	SystemVerilogParserKJOIN_ANY            = 201
	SystemVerilogParserKJOIN_NONE           = 202
	SystemVerilogParserKLARGE               = 203
	SystemVerilogParserKLET                 = 204
	SystemVerilogParserKLIBLIST             = 205
	SystemVerilogParserKLIBRARY             = 206
	SystemVerilogParserKLOCAL               = 207
	SystemVerilogParserKLOCALPARAM          = 208
	SystemVerilogParserKLOGIC               = 209
	SystemVerilogParserKLONGINT             = 210
	SystemVerilogParserKMACROMODULE         = 211
	SystemVerilogParserKMATCHES             = 212
	SystemVerilogParserKMEDIUM              = 213
	SystemVerilogParserKMEMBER_IDENTIFIER   = 214
	SystemVerilogParserKMODPORT             = 215
	SystemVerilogParserKMODULE              = 216
	SystemVerilogParserKNAND                = 217
	SystemVerilogParserKNEGEDGE             = 218
	SystemVerilogParserKNETTYPE             = 219
	SystemVerilogParserKNEW                 = 220
	SystemVerilogParserKNEXTTIME            = 221
	SystemVerilogParserKNMOS                = 222
	SystemVerilogParserKNOR                 = 223
	SystemVerilogParserKNOSHOWCANCELLED     = 224
	SystemVerilogParserKNOT                 = 225
	SystemVerilogParserKNOTIF0              = 226
	SystemVerilogParserKNOTIF1              = 227
	SystemVerilogParserKNULL                = 228
	SystemVerilogParserKOPTION              = 229
	SystemVerilogParserKOR                  = 230
	SystemVerilogParserKOUTPUT              = 231
	SystemVerilogParserKPACKAGE             = 232
	SystemVerilogParserKPACKED              = 233
	SystemVerilogParserKPARAMETER           = 234
	SystemVerilogParserKPATHPULSE           = 235
	SystemVerilogParserKPMOS                = 236
	SystemVerilogParserKPOSEDGE             = 237
	SystemVerilogParserKPRIORITY            = 238
	SystemVerilogParserKPROGRAM             = 239
	SystemVerilogParserKPROPERTY            = 240
	SystemVerilogParserKPROTECTED           = 241
	SystemVerilogParserKPULL0               = 242
	SystemVerilogParserKPULL1               = 243
	SystemVerilogParserKPULLDOWN            = 244
	SystemVerilogParserKPULLUP              = 245
	SystemVerilogParserKPULSESTYLE_ONDETECT = 246
	SystemVerilogParserKPULSESTYLE_ONEVENT  = 247
	SystemVerilogParserKPURE                = 248
	SystemVerilogParserKRAND                = 249
	SystemVerilogParserKRANDC               = 250
	SystemVerilogParserKRANDCASE            = 251
	SystemVerilogParserKRANDOMIZE           = 252
	SystemVerilogParserKRANDSEQUENCE        = 253
	SystemVerilogParserKRCMOS               = 254
	SystemVerilogParserKREAL                = 255
	SystemVerilogParserKREALTIME            = 256
	SystemVerilogParserKREF                 = 257
	SystemVerilogParserKREG                 = 258
	SystemVerilogParserKREJECT_ON           = 259
	SystemVerilogParserKRELEASE             = 260
	SystemVerilogParserKREPEAT              = 261
	SystemVerilogParserKRESTRICT            = 262
	SystemVerilogParserKRETURN              = 263
	SystemVerilogParserKRNMOS               = 264
	SystemVerilogParserKRPMOS               = 265
	SystemVerilogParserKRTRAN               = 266
	SystemVerilogParserKRTRANIF0            = 267
	SystemVerilogParserKRTRANIF1            = 268
	SystemVerilogParserKS_ALWAYS            = 269
	SystemVerilogParserKS_EVENTUALLY        = 270
	SystemVerilogParserKS_NEXTTIME          = 271
	SystemVerilogParserKS_UNTIL             = 272
	SystemVerilogParserKS_UNTIL_WITH        = 273
	SystemVerilogParserKSCALARED            = 274
	SystemVerilogParserKSEQUENCE            = 275
	SystemVerilogParserKSHORTINT            = 276
	SystemVerilogParserKSHORTREAL           = 277
	SystemVerilogParserKSHOWCANCELLED       = 278
	SystemVerilogParserKSIGNED              = 279
	SystemVerilogParserKSMALL               = 280
	SystemVerilogParserKSOFT                = 281
	SystemVerilogParserKSOLVE               = 282
	SystemVerilogParserKSPECIFY             = 283
	SystemVerilogParserKSPECPARAM           = 284
	SystemVerilogParserKSTATIC              = 285
	SystemVerilogParserKSTD                 = 286
	SystemVerilogParserKSTRING              = 287
	SystemVerilogParserKSTRONG              = 288
	SystemVerilogParserKSTRONG0             = 289
	SystemVerilogParserKSTRONG1             = 290
	SystemVerilogParserKSTRUCT              = 291
	SystemVerilogParserKSUPER               = 292
	SystemVerilogParserKSUPPLY0             = 293
	SystemVerilogParserKSUPPLY1             = 294
	SystemVerilogParserKSYNC_ACCEPT_ON      = 295
	SystemVerilogParserKSYNC_REJECT_ON      = 296
	SystemVerilogParserKTAGGED              = 297
	SystemVerilogParserKTASK                = 298
	SystemVerilogParserKTHIS                = 299
	SystemVerilogParserKTHROUGHOUT          = 300
	SystemVerilogParserKTIME                = 301
	SystemVerilogParserKTIMEPRECISION       = 302
	SystemVerilogParserKTIMEUNIT            = 303
	SystemVerilogParserKTRAN                = 304
	SystemVerilogParserKTRANIF0             = 305
	SystemVerilogParserKTRANIF1             = 306
	SystemVerilogParserKTRI                 = 307
	SystemVerilogParserKTRI0                = 308
	SystemVerilogParserKTRI1                = 309
	SystemVerilogParserKTRIAND              = 310
	SystemVerilogParserKTRIOR               = 311
	SystemVerilogParserKTRIREG              = 312
	SystemVerilogParserKTYPE                = 313
	SystemVerilogParserKTYPE_OPTION         = 314
	SystemVerilogParserKTYPEDEF             = 315
	SystemVerilogParserKUNION               = 316
	SystemVerilogParserKUNIQUE              = 317
	SystemVerilogParserKUNIQUE0             = 318
	SystemVerilogParserKUNSIGNED            = 319
	SystemVerilogParserKUNTIL               = 320
	SystemVerilogParserKUNTIL_WITH          = 321
	SystemVerilogParserKUNTYPED             = 322
	SystemVerilogParserKUSE                 = 323
	SystemVerilogParserKUWIRE               = 324
	SystemVerilogParserKVAR                 = 325
	SystemVerilogParserKVECTORED            = 326
	SystemVerilogParserKVIRTUAL             = 327
	SystemVerilogParserKVOID                = 328
	SystemVerilogParserKWAIT                = 329
	SystemVerilogParserKWAIT_ORDER          = 330
	SystemVerilogParserKWAND                = 331
	SystemVerilogParserKWEAK                = 332
	SystemVerilogParserKWEAK0               = 333
	SystemVerilogParserKWEAK1               = 334
	SystemVerilogParserKWHILE               = 335
	SystemVerilogParserKWILDCARD            = 336
	SystemVerilogParserKWIRE                = 337
	SystemVerilogParserKWITH                = 338
	SystemVerilogParserKWITHIN              = 339
	SystemVerilogParserKWOR                 = 340
	SystemVerilogParserKXNOR                = 341
	SystemVerilogParserKXOR                 = 342
	SystemVerilogParserCOMPILER_DIRECTIVE   = 343
	SystemVerilogParserFILE_PATH_SPEC       = 344
	SystemVerilogParserTIME_LITERAL         = 345
	SystemVerilogParserDECIMAL_NUMBER       = 346
	SystemVerilogParserBINARY_NUMBER        = 347
	SystemVerilogParserOCTAL_NUMBER         = 348
	SystemVerilogParserHEX_NUMBER           = 349
	SystemVerilogParserREAL_NUMBER          = 350
	SystemVerilogParserUNSIGNED_NUMBER      = 351
	SystemVerilogParserSTRING_LITERAL       = 352
	SystemVerilogParserONE_LINE_COMMENT     = 353
	SystemVerilogParserBLOCK_COMMENT        = 354
	SystemVerilogParserSIMPLE_IDENTIFIER    = 355
	SystemVerilogParserSYSTEM_TF_IDENTIFIER = 356
	SystemVerilogParserWHITE_SPACE          = 357
)

// SystemVerilogParser rules.
const (
	SystemVerilogParserRULE_library_text                             = 0
	SystemVerilogParserRULE_library_description                      = 1
	SystemVerilogParserRULE_library_declaration                      = 2
	SystemVerilogParserRULE_include_statement                        = 3
	SystemVerilogParserRULE_source_text                              = 4
	SystemVerilogParserRULE_description                              = 5
	SystemVerilogParserRULE_module_nonansi_header                    = 6
	SystemVerilogParserRULE_module_ansi_header                       = 7
	SystemVerilogParserRULE_module_declaration                       = 8
	SystemVerilogParserRULE_module_keyword                           = 9
	SystemVerilogParserRULE_interface_declaration                    = 10
	SystemVerilogParserRULE_interface_nonansi_header                 = 11
	SystemVerilogParserRULE_interface_ansi_header                    = 12
	SystemVerilogParserRULE_program_declaration                      = 13
	SystemVerilogParserRULE_program_nonansi_header                   = 14
	SystemVerilogParserRULE_program_ansi_header                      = 15
	SystemVerilogParserRULE_checker_declaration                      = 16
	SystemVerilogParserRULE_class_declaration                        = 17
	SystemVerilogParserRULE_interface_class_type                     = 18
	SystemVerilogParserRULE_interface_class_declaration              = 19
	SystemVerilogParserRULE_interface_class_item                     = 20
	SystemVerilogParserRULE_interface_class_method                   = 21
	SystemVerilogParserRULE_package_declaration                      = 22
	SystemVerilogParserRULE_timeunits_declaration                    = 23
	SystemVerilogParserRULE_parameter_port_list                      = 24
	SystemVerilogParserRULE_parameter_port_declaration               = 25
	SystemVerilogParserRULE_list_of_ports                            = 26
	SystemVerilogParserRULE_list_of_port_declarations                = 27
	SystemVerilogParserRULE_port_declaration                         = 28
	SystemVerilogParserRULE_port                                     = 29
	SystemVerilogParserRULE_port_expression                          = 30
	SystemVerilogParserRULE_port_reference                           = 31
	SystemVerilogParserRULE_port_direction                           = 32
	SystemVerilogParserRULE_net_port_header                          = 33
	SystemVerilogParserRULE_variable_port_header                     = 34
	SystemVerilogParserRULE_interface_port_header                    = 35
	SystemVerilogParserRULE_ansi_port_declaration                    = 36
	SystemVerilogParserRULE_elaboration_system_task                  = 37
	SystemVerilogParserRULE_module_common_item                       = 38
	SystemVerilogParserRULE_module_item                              = 39
	SystemVerilogParserRULE_module_or_generate_item                  = 40
	SystemVerilogParserRULE_module_or_generate_item_declaration      = 41
	SystemVerilogParserRULE_non_port_module_item                     = 42
	SystemVerilogParserRULE_parameter_override                       = 43
	SystemVerilogParserRULE_bind_directive                           = 44
	SystemVerilogParserRULE_bind_target_scope                        = 45
	SystemVerilogParserRULE_bind_target_instance                     = 46
	SystemVerilogParserRULE_bind_target_instance_list                = 47
	SystemVerilogParserRULE_bind_instantiation                       = 48
	SystemVerilogParserRULE_config_declaration                       = 49
	SystemVerilogParserRULE_design_statement                         = 50
	SystemVerilogParserRULE_config_rule_statement                    = 51
	SystemVerilogParserRULE_default_clause                           = 52
	SystemVerilogParserRULE_inst_clause                              = 53
	SystemVerilogParserRULE_inst_name                                = 54
	SystemVerilogParserRULE_cell_clause                              = 55
	SystemVerilogParserRULE_liblist_clause                           = 56
	SystemVerilogParserRULE_use_clause                               = 57
	SystemVerilogParserRULE_interface_or_generate_item               = 58
	SystemVerilogParserRULE_extern_tf_declaration                    = 59
	SystemVerilogParserRULE_interface_item                           = 60
	SystemVerilogParserRULE_non_port_interface_item                  = 61
	SystemVerilogParserRULE_program_item                             = 62
	SystemVerilogParserRULE_non_port_program_item                    = 63
	SystemVerilogParserRULE_program_generate_item                    = 64
	SystemVerilogParserRULE_checker_port_list                        = 65
	SystemVerilogParserRULE_checker_port_item                        = 66
	SystemVerilogParserRULE_checker_port_direction                   = 67
	SystemVerilogParserRULE_checker_or_generate_item                 = 68
	SystemVerilogParserRULE_checker_or_generate_item_declaration     = 69
	SystemVerilogParserRULE_checker_generate_item                    = 70
	SystemVerilogParserRULE_class_item                               = 71
	SystemVerilogParserRULE_class_property                           = 72
	SystemVerilogParserRULE_class_method                             = 73
	SystemVerilogParserRULE_class_constructor_prototype              = 74
	SystemVerilogParserRULE_class_constraint                         = 75
	SystemVerilogParserRULE_class_item_qualifier                     = 76
	SystemVerilogParserRULE_property_qualifier                       = 77
	SystemVerilogParserRULE_random_qualifier                         = 78
	SystemVerilogParserRULE_method_qualifier                         = 79
	SystemVerilogParserRULE_method_prototype                         = 80
	SystemVerilogParserRULE_class_constructor_declaration            = 81
	SystemVerilogParserRULE_constraint_declaration                   = 82
	SystemVerilogParserRULE_constraint_block                         = 83
	SystemVerilogParserRULE_constraint_block_item                    = 84
	SystemVerilogParserRULE_solve_before_list                        = 85
	SystemVerilogParserRULE_constraint_primary                       = 86
	SystemVerilogParserRULE_constraint_expression                    = 87
	SystemVerilogParserRULE_uniqueness_constraint                    = 88
	SystemVerilogParserRULE_constraint_set                           = 89
	SystemVerilogParserRULE_dist_list                                = 90
	SystemVerilogParserRULE_dist_item                                = 91
	SystemVerilogParserRULE_dist_weight                              = 92
	SystemVerilogParserRULE_constraint_prototype                     = 93
	SystemVerilogParserRULE_constraint_prototype_qualifier           = 94
	SystemVerilogParserRULE_extern_constraint_declaration            = 95
	SystemVerilogParserRULE_identifier_list                          = 96
	SystemVerilogParserRULE_package_item                             = 97
	SystemVerilogParserRULE_package_or_generate_item_declaration     = 98
	SystemVerilogParserRULE_anonymous_program                        = 99
	SystemVerilogParserRULE_anonymous_program_item                   = 100
	SystemVerilogParserRULE_local_parameter_declaration              = 101
	SystemVerilogParserRULE_parameter_declaration                    = 102
	SystemVerilogParserRULE_specparam_declaration                    = 103
	SystemVerilogParserRULE_inout_declaration                        = 104
	SystemVerilogParserRULE_input_declaration                        = 105
	SystemVerilogParserRULE_output_declaration                       = 106
	SystemVerilogParserRULE_interface_port_declaration               = 107
	SystemVerilogParserRULE_ref_declaration                          = 108
	SystemVerilogParserRULE_data_declaration                         = 109
	SystemVerilogParserRULE_package_import_declaration               = 110
	SystemVerilogParserRULE_package_import_item                      = 111
	SystemVerilogParserRULE_package_export_declaration               = 112
	SystemVerilogParserRULE_genvar_declaration                       = 113
	SystemVerilogParserRULE_net_declaration                          = 114
	SystemVerilogParserRULE_type_declaration                         = 115
	SystemVerilogParserRULE_net_type_declaration                     = 116
	SystemVerilogParserRULE_lifetime                                 = 117
	SystemVerilogParserRULE_casting_type                             = 118
	SystemVerilogParserRULE_data_type                                = 119
	SystemVerilogParserRULE_data_type_or_implicit                    = 120
	SystemVerilogParserRULE_implicit_data_type                       = 121
	SystemVerilogParserRULE_enum_base_type                           = 122
	SystemVerilogParserRULE_enum_name_declaration                    = 123
	SystemVerilogParserRULE_class_scope                              = 124
	SystemVerilogParserRULE_class_type                               = 125
	SystemVerilogParserRULE_integer_type                             = 126
	SystemVerilogParserRULE_integer_atom_type                        = 127
	SystemVerilogParserRULE_integer_vector_type                      = 128
	SystemVerilogParserRULE_non_integer_type                         = 129
	SystemVerilogParserRULE_net_type                                 = 130
	SystemVerilogParserRULE_net_port_type                            = 131
	SystemVerilogParserRULE_variable_port_type                       = 132
	SystemVerilogParserRULE_var_data_type                            = 133
	SystemVerilogParserRULE_signing                                  = 134
	SystemVerilogParserRULE_simple_type                              = 135
	SystemVerilogParserRULE_struct_union_member                      = 136
	SystemVerilogParserRULE_data_type_or_void                        = 137
	SystemVerilogParserRULE_struct_union                             = 138
	SystemVerilogParserRULE_type_reference                           = 139
	SystemVerilogParserRULE_drive_strength                           = 140
	SystemVerilogParserRULE_strength0                                = 141
	SystemVerilogParserRULE_strength1                                = 142
	SystemVerilogParserRULE_charge_strength                          = 143
	SystemVerilogParserRULE_delay3                                   = 144
	SystemVerilogParserRULE_delay2                                   = 145
	SystemVerilogParserRULE_delay_value                              = 146
	SystemVerilogParserRULE_list_of_defparam_assignments             = 147
	SystemVerilogParserRULE_list_of_genvar_identifiers               = 148
	SystemVerilogParserRULE_list_of_interface_identifiers            = 149
	SystemVerilogParserRULE_list_of_net_decl_assignments             = 150
	SystemVerilogParserRULE_list_of_param_assignments                = 151
	SystemVerilogParserRULE_list_of_port_identifiers                 = 152
	SystemVerilogParserRULE_list_of_udp_port_identifiers             = 153
	SystemVerilogParserRULE_list_of_specparam_assignments            = 154
	SystemVerilogParserRULE_list_of_tf_variable_identifiers          = 155
	SystemVerilogParserRULE_list_of_type_assignments                 = 156
	SystemVerilogParserRULE_list_of_variable_decl_assignments        = 157
	SystemVerilogParserRULE_list_of_variable_identifiers             = 158
	SystemVerilogParserRULE_list_of_variable_port_identifiers        = 159
	SystemVerilogParserRULE_defparam_assignment                      = 160
	SystemVerilogParserRULE_net_decl_assignment                      = 161
	SystemVerilogParserRULE_param_assignment                         = 162
	SystemVerilogParserRULE_specparam_assignment                     = 163
	SystemVerilogParserRULE_type_assignment                          = 164
	SystemVerilogParserRULE_pulse_control_specparam                  = 165
	SystemVerilogParserRULE_error_limit_value                        = 166
	SystemVerilogParserRULE_reject_limit_value                       = 167
	SystemVerilogParserRULE_limit_value                              = 168
	SystemVerilogParserRULE_variable_decl_assignment                 = 169
	SystemVerilogParserRULE_class_new                                = 170
	SystemVerilogParserRULE_dynamic_array_new                        = 171
	SystemVerilogParserRULE_unpacked_dimension                       = 172
	SystemVerilogParserRULE_packed_dimension                         = 173
	SystemVerilogParserRULE_associative_dimension                    = 174
	SystemVerilogParserRULE_variable_dimension                       = 175
	SystemVerilogParserRULE_queue_dimension                          = 176
	SystemVerilogParserRULE_unsized_dimension                        = 177
	SystemVerilogParserRULE_function_data_type_or_implicit           = 178
	SystemVerilogParserRULE_function_declaration                     = 179
	SystemVerilogParserRULE_function_body_declaration                = 180
	SystemVerilogParserRULE_function_prototype                       = 181
	SystemVerilogParserRULE_dpi_import_export                        = 182
	SystemVerilogParserRULE_dpi_spec_string                          = 183
	SystemVerilogParserRULE_dpi_function_import_property             = 184
	SystemVerilogParserRULE_dpi_task_import_property                 = 185
	SystemVerilogParserRULE_dpi_function_proto                       = 186
	SystemVerilogParserRULE_dpi_task_proto                           = 187
	SystemVerilogParserRULE_task_declaration                         = 188
	SystemVerilogParserRULE_task_body_declaration                    = 189
	SystemVerilogParserRULE_tf_item_declaration                      = 190
	SystemVerilogParserRULE_tf_port_list                             = 191
	SystemVerilogParserRULE_tf_port_item                             = 192
	SystemVerilogParserRULE_tf_port_direction                        = 193
	SystemVerilogParserRULE_tf_port_declaration                      = 194
	SystemVerilogParserRULE_task_prototype                           = 195
	SystemVerilogParserRULE_block_item_declaration                   = 196
	SystemVerilogParserRULE_modport_declaration                      = 197
	SystemVerilogParserRULE_modport_item                             = 198
	SystemVerilogParserRULE_modport_ports_declaration                = 199
	SystemVerilogParserRULE_modport_clocking_declaration             = 200
	SystemVerilogParserRULE_modport_simple_ports_declaration         = 201
	SystemVerilogParserRULE_modport_simple_port                      = 202
	SystemVerilogParserRULE_modport_tf_ports_declaration             = 203
	SystemVerilogParserRULE_modport_tf_port                          = 204
	SystemVerilogParserRULE_import_export                            = 205
	SystemVerilogParserRULE_concurrent_assertion_item                = 206
	SystemVerilogParserRULE_concurrent_assertion_statement           = 207
	SystemVerilogParserRULE_assert_property_statement                = 208
	SystemVerilogParserRULE_assume_property_statement                = 209
	SystemVerilogParserRULE_cover_property_statement                 = 210
	SystemVerilogParserRULE_expect_property_statement                = 211
	SystemVerilogParserRULE_cover_sequence_statement                 = 212
	SystemVerilogParserRULE_restrict_property_statement              = 213
	SystemVerilogParserRULE_property_instance                        = 214
	SystemVerilogParserRULE_property_list_of_arguments               = 215
	SystemVerilogParserRULE_property_actual_arg                      = 216
	SystemVerilogParserRULE_assertion_item_declaration               = 217
	SystemVerilogParserRULE_property_declaration                     = 218
	SystemVerilogParserRULE_property_port_list                       = 219
	SystemVerilogParserRULE_property_port_item                       = 220
	SystemVerilogParserRULE_property_lvar_port_direction             = 221
	SystemVerilogParserRULE_property_formal_type                     = 222
	SystemVerilogParserRULE_property_spec                            = 223
	SystemVerilogParserRULE_property_expr                            = 224
	SystemVerilogParserRULE_property_case_item                       = 225
	SystemVerilogParserRULE_sequence_declaration                     = 226
	SystemVerilogParserRULE_sequence_port_list                       = 227
	SystemVerilogParserRULE_sequence_port_item                       = 228
	SystemVerilogParserRULE_sequence_lvar_port_direction             = 229
	SystemVerilogParserRULE_sequence_formal_type                     = 230
	SystemVerilogParserRULE_sequence_expr                            = 231
	SystemVerilogParserRULE_cycle_delay_range                        = 232
	SystemVerilogParserRULE_sequence_method_call                     = 233
	SystemVerilogParserRULE_sequence_match_item                      = 234
	SystemVerilogParserRULE_sequence_instance                        = 235
	SystemVerilogParserRULE_sequence_list_of_arguments               = 236
	SystemVerilogParserRULE_sequence_actual_arg                      = 237
	SystemVerilogParserRULE_boolean_abbrev                           = 238
	SystemVerilogParserRULE_sequence_abbrev                          = 239
	SystemVerilogParserRULE_consecutive_repetition                   = 240
	SystemVerilogParserRULE_non_consecutive_repetition               = 241
	SystemVerilogParserRULE_goto_repetition                          = 242
	SystemVerilogParserRULE_const_or_range_expression                = 243
	SystemVerilogParserRULE_cycle_delay_const_range_expression       = 244
	SystemVerilogParserRULE_expression_or_dist                       = 245
	SystemVerilogParserRULE_assertion_variable_declaration           = 246
	SystemVerilogParserRULE_covergroup_declaration                   = 247
	SystemVerilogParserRULE_coverage_spec_or_option                  = 248
	SystemVerilogParserRULE_coverage_option                          = 249
	SystemVerilogParserRULE_coverage_spec                            = 250
	SystemVerilogParserRULE_coverage_event                           = 251
	SystemVerilogParserRULE_block_event_expression                   = 252
	SystemVerilogParserRULE_hierarchical_btf_identifier              = 253
	SystemVerilogParserRULE_cover_point                              = 254
	SystemVerilogParserRULE_bins_or_empty                            = 255
	SystemVerilogParserRULE_bins_or_options                          = 256
	SystemVerilogParserRULE_bins_keyword                             = 257
	SystemVerilogParserRULE_trans_list                               = 258
	SystemVerilogParserRULE_trans_set                                = 259
	SystemVerilogParserRULE_trans_range_list                         = 260
	SystemVerilogParserRULE_trans_item                               = 261
	SystemVerilogParserRULE_repeat_range                             = 262
	SystemVerilogParserRULE_cover_cross                              = 263
	SystemVerilogParserRULE_list_of_cross_items                      = 264
	SystemVerilogParserRULE_cross_item                               = 265
	SystemVerilogParserRULE_cross_body                               = 266
	SystemVerilogParserRULE_cross_body_item                          = 267
	SystemVerilogParserRULE_bins_selection_or_option                 = 268
	SystemVerilogParserRULE_bins_selection                           = 269
	SystemVerilogParserRULE_select_expression                        = 270
	SystemVerilogParserRULE_select_condition                         = 271
	SystemVerilogParserRULE_bins_expression                          = 272
	SystemVerilogParserRULE_covergroup_range_list                    = 273
	SystemVerilogParserRULE_covergroup_value_range                   = 274
	SystemVerilogParserRULE_with_covergroup_expression               = 275
	SystemVerilogParserRULE_set_covergroup_expression                = 276
	SystemVerilogParserRULE_integer_covergroup_expression            = 277
	SystemVerilogParserRULE_cross_set_expression                     = 278
	SystemVerilogParserRULE_covergroup_expression                    = 279
	SystemVerilogParserRULE_let_declaration                          = 280
	SystemVerilogParserRULE_let_identifier                           = 281
	SystemVerilogParserRULE_let_port_list                            = 282
	SystemVerilogParserRULE_let_port_item                            = 283
	SystemVerilogParserRULE_let_formal_type                          = 284
	SystemVerilogParserRULE_let_expression                           = 285
	SystemVerilogParserRULE_let_list_of_arguments                    = 286
	SystemVerilogParserRULE_let_actual_arg                           = 287
	SystemVerilogParserRULE_gate_instantiation                       = 288
	SystemVerilogParserRULE_cmos_switch_instance                     = 289
	SystemVerilogParserRULE_enable_gate_instance                     = 290
	SystemVerilogParserRULE_mos_switch_instance                      = 291
	SystemVerilogParserRULE_n_input_gate_instance                    = 292
	SystemVerilogParserRULE_n_output_gate_instance                   = 293
	SystemVerilogParserRULE_pass_switch_instance                     = 294
	SystemVerilogParserRULE_pass_enable_switch_instance              = 295
	SystemVerilogParserRULE_pull_gate_instance                       = 296
	SystemVerilogParserRULE_pulldown_strength                        = 297
	SystemVerilogParserRULE_pullup_strength                          = 298
	SystemVerilogParserRULE_enable_terminal                          = 299
	SystemVerilogParserRULE_inout_terminal                           = 300
	SystemVerilogParserRULE_input_terminal                           = 301
	SystemVerilogParserRULE_ncontrol_terminal                        = 302
	SystemVerilogParserRULE_output_terminal                          = 303
	SystemVerilogParserRULE_pcontrol_terminal                        = 304
	SystemVerilogParserRULE_cmos_switchtype                          = 305
	SystemVerilogParserRULE_enable_gatetype                          = 306
	SystemVerilogParserRULE_mos_switchtype                           = 307
	SystemVerilogParserRULE_n_input_gatetype                         = 308
	SystemVerilogParserRULE_n_output_gatetype                        = 309
	SystemVerilogParserRULE_pass_en_switchtype                       = 310
	SystemVerilogParserRULE_pass_switchtype                          = 311
	SystemVerilogParserRULE_module_instantiation                     = 312
	SystemVerilogParserRULE_parameter_value_assignment               = 313
	SystemVerilogParserRULE_list_of_parameter_assignments            = 314
	SystemVerilogParserRULE_ordered_parameter_assignment             = 315
	SystemVerilogParserRULE_named_parameter_assignment               = 316
	SystemVerilogParserRULE_hierarchical_instance                    = 317
	SystemVerilogParserRULE_name_of_instance                         = 318
	SystemVerilogParserRULE_list_of_port_connections                 = 319
	SystemVerilogParserRULE_ordered_port_connection                  = 320
	SystemVerilogParserRULE_named_port_connection                    = 321
	SystemVerilogParserRULE_interface_instantiation                  = 322
	SystemVerilogParserRULE_program_instantiation                    = 323
	SystemVerilogParserRULE_checker_instantiation                    = 324
	SystemVerilogParserRULE_list_of_checker_port_connections         = 325
	SystemVerilogParserRULE_ordered_checker_port_connection          = 326
	SystemVerilogParserRULE_named_checker_port_connection            = 327
	SystemVerilogParserRULE_generate_region                          = 328
	SystemVerilogParserRULE_loop_generate_construct                  = 329
	SystemVerilogParserRULE_genvar_initialization                    = 330
	SystemVerilogParserRULE_genvar_iteration                         = 331
	SystemVerilogParserRULE_conditional_generate_construct           = 332
	SystemVerilogParserRULE_if_generate_construct                    = 333
	SystemVerilogParserRULE_case_generate_construct                  = 334
	SystemVerilogParserRULE_case_generate_item                       = 335
	SystemVerilogParserRULE_generate_block                           = 336
	SystemVerilogParserRULE_generate_item                            = 337
	SystemVerilogParserRULE_continuous_assign                        = 338
	SystemVerilogParserRULE_list_of_net_assignments                  = 339
	SystemVerilogParserRULE_list_of_variable_assignments             = 340
	SystemVerilogParserRULE_net_alias                                = 341
	SystemVerilogParserRULE_net_assignment                           = 342
	SystemVerilogParserRULE_initial_construct                        = 343
	SystemVerilogParserRULE_always_construct                         = 344
	SystemVerilogParserRULE_always_keyword                           = 345
	SystemVerilogParserRULE_final_construct                          = 346
	SystemVerilogParserRULE_blocking_assignment                      = 347
	SystemVerilogParserRULE_operator_assignment                      = 348
	SystemVerilogParserRULE_assignment_operator                      = 349
	SystemVerilogParserRULE_nonblocking_assignment                   = 350
	SystemVerilogParserRULE_procedural_continuous_assignment         = 351
	SystemVerilogParserRULE_variable_assignment                      = 352
	SystemVerilogParserRULE_action_block                             = 353
	SystemVerilogParserRULE_seq_block                                = 354
	SystemVerilogParserRULE_par_block                                = 355
	SystemVerilogParserRULE_join_keyword                             = 356
	SystemVerilogParserRULE_statement_or_null                        = 357
	SystemVerilogParserRULE_statement                                = 358
	SystemVerilogParserRULE_statement_item                           = 359
	SystemVerilogParserRULE_function_statement                       = 360
	SystemVerilogParserRULE_function_statement_or_null               = 361
	SystemVerilogParserRULE_variable_identifier_list                 = 362
	SystemVerilogParserRULE_procedural_timing_control_statement      = 363
	SystemVerilogParserRULE_delay_or_event_control                   = 364
	SystemVerilogParserRULE_delay_control                            = 365
	SystemVerilogParserRULE_event_control                            = 366
	SystemVerilogParserRULE_event_expression                         = 367
	SystemVerilogParserRULE_procedural_timing_control                = 368
	SystemVerilogParserRULE_jump_statement                           = 369
	SystemVerilogParserRULE_wait_statement                           = 370
	SystemVerilogParserRULE_event_trigger                            = 371
	SystemVerilogParserRULE_disable_statement                        = 372
	SystemVerilogParserRULE_conditional_statement                    = 373
	SystemVerilogParserRULE_unique_priority                          = 374
	SystemVerilogParserRULE_cond_predicate                           = 375
	SystemVerilogParserRULE_expression_or_cond_pattern               = 376
	SystemVerilogParserRULE_cond_pattern                             = 377
	SystemVerilogParserRULE_case_statement                           = 378
	SystemVerilogParserRULE_case_keyword                             = 379
	SystemVerilogParserRULE_case_expression                          = 380
	SystemVerilogParserRULE_case_item                                = 381
	SystemVerilogParserRULE_case_pattern_item                        = 382
	SystemVerilogParserRULE_case_inside_item                         = 383
	SystemVerilogParserRULE_case_item_expression                     = 384
	SystemVerilogParserRULE_randcase_statement                       = 385
	SystemVerilogParserRULE_randcase_item                            = 386
	SystemVerilogParserRULE_open_range_list                          = 387
	SystemVerilogParserRULE_open_value_range                         = 388
	SystemVerilogParserRULE_pattern                                  = 389
	SystemVerilogParserRULE_assignment_pattern                       = 390
	SystemVerilogParserRULE_structure_pattern_key                    = 391
	SystemVerilogParserRULE_array_pattern_key                        = 392
	SystemVerilogParserRULE_assignment_pattern_key                   = 393
	SystemVerilogParserRULE_assignment_pattern_expression            = 394
	SystemVerilogParserRULE_assignment_pattern_expression_type       = 395
	SystemVerilogParserRULE_constant_assignment_pattern_expression   = 396
	SystemVerilogParserRULE_assignment_pattern_net_lvalue            = 397
	SystemVerilogParserRULE_assignment_pattern_variable_lvalue       = 398
	SystemVerilogParserRULE_loop_statement                           = 399
	SystemVerilogParserRULE_for_initialization                       = 400
	SystemVerilogParserRULE_for_variable_declaration                 = 401
	SystemVerilogParserRULE_for_step                                 = 402
	SystemVerilogParserRULE_for_step_assignment                      = 403
	SystemVerilogParserRULE_loop_variables                           = 404
	SystemVerilogParserRULE_subroutine_call_statement                = 405
	SystemVerilogParserRULE_assertion_item                           = 406
	SystemVerilogParserRULE_deferred_immediate_assertion_item        = 407
	SystemVerilogParserRULE_procedural_assertion_statement           = 408
	SystemVerilogParserRULE_immediate_assertion_statement            = 409
	SystemVerilogParserRULE_simple_immediate_assertion_statement     = 410
	SystemVerilogParserRULE_simple_immediate_assert_statement        = 411
	SystemVerilogParserRULE_simple_immediate_assume_statement        = 412
	SystemVerilogParserRULE_simple_immediate_cover_statement         = 413
	SystemVerilogParserRULE_deferred_immediate_assertion_statement   = 414
	SystemVerilogParserRULE_deferred_immediate_assert_statement      = 415
	SystemVerilogParserRULE_deferred_immediate_assume_statement      = 416
	SystemVerilogParserRULE_deferred_immediate_cover_statement       = 417
	SystemVerilogParserRULE_clocking_declaration                     = 418
	SystemVerilogParserRULE_clocking_event                           = 419
	SystemVerilogParserRULE_clocking_item                            = 420
	SystemVerilogParserRULE_default_skew                             = 421
	SystemVerilogParserRULE_clocking_direction                       = 422
	SystemVerilogParserRULE_list_of_clocking_decl_assign             = 423
	SystemVerilogParserRULE_clocking_decl_assign                     = 424
	SystemVerilogParserRULE_clocking_skew                            = 425
	SystemVerilogParserRULE_clocking_drive                           = 426
	SystemVerilogParserRULE_cycle_delay                              = 427
	SystemVerilogParserRULE_clockvar                                 = 428
	SystemVerilogParserRULE_clockvar_expression                      = 429
	SystemVerilogParserRULE_randsequence_statement                   = 430
	SystemVerilogParserRULE_production                               = 431
	SystemVerilogParserRULE_rs_rule                                  = 432
	SystemVerilogParserRULE_rs_production_list                       = 433
	SystemVerilogParserRULE_weight_specification                     = 434
	SystemVerilogParserRULE_rs_code_block                            = 435
	SystemVerilogParserRULE_rs_prod                                  = 436
	SystemVerilogParserRULE_production_item                          = 437
	SystemVerilogParserRULE_rs_if_else                               = 438
	SystemVerilogParserRULE_rs_repeat                                = 439
	SystemVerilogParserRULE_rs_case                                  = 440
	SystemVerilogParserRULE_rs_case_item                             = 441
	SystemVerilogParserRULE_specify_block                            = 442
	SystemVerilogParserRULE_specify_item                             = 443
	SystemVerilogParserRULE_pulsestyle_declaration                   = 444
	SystemVerilogParserRULE_showcancelled_declaration                = 445
	SystemVerilogParserRULE_path_declaration                         = 446
	SystemVerilogParserRULE_simple_path_declaration                  = 447
	SystemVerilogParserRULE_parallel_path_description                = 448
	SystemVerilogParserRULE_full_path_description                    = 449
	SystemVerilogParserRULE_list_of_path_inputs                      = 450
	SystemVerilogParserRULE_list_of_path_outputs                     = 451
	SystemVerilogParserRULE_specify_input_terminal_descriptor        = 452
	SystemVerilogParserRULE_specify_output_terminal_descriptor       = 453
	SystemVerilogParserRULE_input_identifier                         = 454
	SystemVerilogParserRULE_output_identifier                        = 455
	SystemVerilogParserRULE_path_delay_value                         = 456
	SystemVerilogParserRULE_list_of_path_delay_expressions           = 457
	SystemVerilogParserRULE_t_path_delay_expression                  = 458
	SystemVerilogParserRULE_trise_path_delay_expression              = 459
	SystemVerilogParserRULE_tfall_path_delay_expression              = 460
	SystemVerilogParserRULE_tz_path_delay_expression                 = 461
	SystemVerilogParserRULE_t01_path_delay_expression                = 462
	SystemVerilogParserRULE_t10_path_delay_expression                = 463
	SystemVerilogParserRULE_t0z_path_delay_expression                = 464
	SystemVerilogParserRULE_tz1_path_delay_expression                = 465
	SystemVerilogParserRULE_t1z_path_delay_expression                = 466
	SystemVerilogParserRULE_tz0_path_delay_expression                = 467
	SystemVerilogParserRULE_t0x_path_delay_expression                = 468
	SystemVerilogParserRULE_tx1_path_delay_expression                = 469
	SystemVerilogParserRULE_t1x_path_delay_expression                = 470
	SystemVerilogParserRULE_tx0_path_delay_expression                = 471
	SystemVerilogParserRULE_txz_path_delay_expression                = 472
	SystemVerilogParserRULE_tzx_path_delay_expression                = 473
	SystemVerilogParserRULE_path_delay_expression                    = 474
	SystemVerilogParserRULE_edge_sensitive_path_declaration          = 475
	SystemVerilogParserRULE_parallel_edge_sensitive_path_description = 476
	SystemVerilogParserRULE_full_edge_sensitive_path_description     = 477
	SystemVerilogParserRULE_data_source_expression                   = 478
	SystemVerilogParserRULE_edge_identifier                          = 479
	SystemVerilogParserRULE_state_dependent_path_declaration         = 480
	SystemVerilogParserRULE_polarity_operator                        = 481
	SystemVerilogParserRULE_concatenation                            = 482
	SystemVerilogParserRULE_constant_concatenation                   = 483
	SystemVerilogParserRULE_constant_multiple_concatenation          = 484
	SystemVerilogParserRULE_module_path_concatenation                = 485
	SystemVerilogParserRULE_module_path_multiple_concatenation       = 486
	SystemVerilogParserRULE_multiple_concatenation                   = 487
	SystemVerilogParserRULE_streaming_concatenation                  = 488
	SystemVerilogParserRULE_stream_operator                          = 489
	SystemVerilogParserRULE_slice_size                               = 490
	SystemVerilogParserRULE_stream_concatenation                     = 491
	SystemVerilogParserRULE_stream_expression                        = 492
	SystemVerilogParserRULE_array_range_expression                   = 493
	SystemVerilogParserRULE_empty_unpacked_array_concatenation       = 494
	SystemVerilogParserRULE_constant_function_call                   = 495
	SystemVerilogParserRULE_tf_call                                  = 496
	SystemVerilogParserRULE_system_tf_call                           = 497
	SystemVerilogParserRULE_subroutine_call                          = 498
	SystemVerilogParserRULE_function_subroutine_call                 = 499
	SystemVerilogParserRULE_list_of_arguments                        = 500
	SystemVerilogParserRULE_method_call_body                         = 501
	SystemVerilogParserRULE_built_in_method_call                     = 502
	SystemVerilogParserRULE_array_manipulation_call                  = 503
	SystemVerilogParserRULE_randomize_call                           = 504
	SystemVerilogParserRULE_array_method_name                        = 505
	SystemVerilogParserRULE_inc_or_dec_expression                    = 506
	SystemVerilogParserRULE_constant_expression                      = 507
	SystemVerilogParserRULE_constant_mintypmax_expression            = 508
	SystemVerilogParserRULE_constant_param_expression                = 509
	SystemVerilogParserRULE_param_expression                         = 510
	SystemVerilogParserRULE_constant_range_expression                = 511
	SystemVerilogParserRULE_constant_part_select_range               = 512
	SystemVerilogParserRULE_constant_range                           = 513
	SystemVerilogParserRULE_constant_indexed_range                   = 514
	SystemVerilogParserRULE_expression                               = 515
	SystemVerilogParserRULE_value_range                              = 516
	SystemVerilogParserRULE_mintypmax_expression                     = 517
	SystemVerilogParserRULE_module_path_expression                   = 518
	SystemVerilogParserRULE_module_path_mintypmax_expression         = 519
	SystemVerilogParserRULE_part_select_range                        = 520
	SystemVerilogParserRULE_indexed_range                            = 521
	SystemVerilogParserRULE_genvar_expression                        = 522
	SystemVerilogParserRULE_constant_primary                         = 523
	SystemVerilogParserRULE_module_path_primary                      = 524
	SystemVerilogParserRULE_primary                                  = 525
	SystemVerilogParserRULE_class_qualifier                          = 526
	SystemVerilogParserRULE_range_expression                         = 527
	SystemVerilogParserRULE_primary_literal                          = 528
	SystemVerilogParserRULE_implicit_class_handle                    = 529
	SystemVerilogParserRULE_bit_select                               = 530
	SystemVerilogParserRULE_select_                                  = 531
	SystemVerilogParserRULE_nonrange_select                          = 532
	SystemVerilogParserRULE_constant_bit_select                      = 533
	SystemVerilogParserRULE_constant_select                          = 534
	SystemVerilogParserRULE_constant_let_expression                  = 535
	SystemVerilogParserRULE_cast                                     = 536
	SystemVerilogParserRULE_net_lvalue                               = 537
	SystemVerilogParserRULE_variable_lvalue                          = 538
	SystemVerilogParserRULE_nonrange_variable_lvalue                 = 539
	SystemVerilogParserRULE_unary_operator                           = 540
	SystemVerilogParserRULE_binary_operator                          = 541
	SystemVerilogParserRULE_inc_or_dec_operator                      = 542
	SystemVerilogParserRULE_unary_module_path_operator               = 543
	SystemVerilogParserRULE_binary_module_path_operator              = 544
	SystemVerilogParserRULE_number                                   = 545
	SystemVerilogParserRULE_attribute_instance                       = 546
	SystemVerilogParserRULE_attr_spec                                = 547
	SystemVerilogParserRULE_attr_name                                = 548
	SystemVerilogParserRULE_array_identifier                         = 549
	SystemVerilogParserRULE_block_identifier                         = 550
	SystemVerilogParserRULE_bin_identifier                           = 551
	SystemVerilogParserRULE_c_identifier                             = 552
	SystemVerilogParserRULE_cell_identifier                          = 553
	SystemVerilogParserRULE_checker_identifier                       = 554
	SystemVerilogParserRULE_class_identifier                         = 555
	SystemVerilogParserRULE_class_variable_identifier                = 556
	SystemVerilogParserRULE_clocking_identifier                      = 557
	SystemVerilogParserRULE_config_identifier                        = 558
	SystemVerilogParserRULE_const_identifier                         = 559
	SystemVerilogParserRULE_constraint_identifier                    = 560
	SystemVerilogParserRULE_covergroup_identifier                    = 561
	SystemVerilogParserRULE_covergroup_variable_identifier           = 562
	SystemVerilogParserRULE_cover_point_identifier                   = 563
	SystemVerilogParserRULE_cross_identifier                         = 564
	SystemVerilogParserRULE_dynamic_array_variable_identifier        = 565
	SystemVerilogParserRULE_enum_identifier                          = 566
	SystemVerilogParserRULE_formal_port_identifier                   = 567
	SystemVerilogParserRULE_function_identifier                      = 568
	SystemVerilogParserRULE_generate_block_identifier                = 569
	SystemVerilogParserRULE_genvar_identifier                        = 570
	SystemVerilogParserRULE_hierarchical_array_identifier            = 571
	SystemVerilogParserRULE_hierarchical_block_identifier            = 572
	SystemVerilogParserRULE_hierarchical_event_identifier            = 573
	SystemVerilogParserRULE_hierarchical_identifier                  = 574
	SystemVerilogParserRULE_hierarchical_net_identifier              = 575
	SystemVerilogParserRULE_hierarchical_parameter_identifier        = 576
	SystemVerilogParserRULE_hierarchical_property_identifier         = 577
	SystemVerilogParserRULE_hierarchical_sequence_identifier         = 578
	SystemVerilogParserRULE_hierarchical_task_identifier             = 579
	SystemVerilogParserRULE_hierarchical_tf_identifier               = 580
	SystemVerilogParserRULE_hierarchical_variable_identifier         = 581
	SystemVerilogParserRULE_identifier                               = 582
	SystemVerilogParserRULE_index_variable_identifier                = 583
	SystemVerilogParserRULE_interface_identifier                     = 584
	SystemVerilogParserRULE_interface_instance_identifier            = 585
	SystemVerilogParserRULE_inout_port_identifier                    = 586
	SystemVerilogParserRULE_input_port_identifier                    = 587
	SystemVerilogParserRULE_instance_identifier                      = 588
	SystemVerilogParserRULE_library_identifier                       = 589
	SystemVerilogParserRULE_member_identifier                        = 590
	SystemVerilogParserRULE_method_identifier                        = 591
	SystemVerilogParserRULE_modport_identifier                       = 592
	SystemVerilogParserRULE_module_identifier                        = 593
	SystemVerilogParserRULE_net_identifier                           = 594
	SystemVerilogParserRULE_net_type_identifier                      = 595
	SystemVerilogParserRULE_output_port_identifier                   = 596
	SystemVerilogParserRULE_package_identifier                       = 597
	SystemVerilogParserRULE_package_scope                            = 598
	SystemVerilogParserRULE_parameter_identifier                     = 599
	SystemVerilogParserRULE_port_identifier                          = 600
	SystemVerilogParserRULE_production_identifier                    = 601
	SystemVerilogParserRULE_program_identifier                       = 602
	SystemVerilogParserRULE_property_identifier                      = 603
	SystemVerilogParserRULE_ps_class_identifier                      = 604
	SystemVerilogParserRULE_ps_covergroup_identifier                 = 605
	SystemVerilogParserRULE_ps_checker_identifier                    = 606
	SystemVerilogParserRULE_ps_identifier                            = 607
	SystemVerilogParserRULE_ps_or_hierarchical_array_identifier      = 608
	SystemVerilogParserRULE_ps_or_hierarchical_net_identifier        = 609
	SystemVerilogParserRULE_ps_or_hierarchical_property_identifier   = 610
	SystemVerilogParserRULE_ps_or_hierarchical_sequence_identifier   = 611
	SystemVerilogParserRULE_ps_or_hierarchical_tf_identifier         = 612
	SystemVerilogParserRULE_ps_parameter_identifier                  = 613
	SystemVerilogParserRULE_ps_type_identifier                       = 614
	SystemVerilogParserRULE_sequence_identifier                      = 615
	SystemVerilogParserRULE_signal_identifier                        = 616
	SystemVerilogParserRULE_specparam_identifier                     = 617
	SystemVerilogParserRULE_task_identifier                          = 618
	SystemVerilogParserRULE_tf_identifier                            = 619
	SystemVerilogParserRULE_topmodule_identifier                     = 620
	SystemVerilogParserRULE_type_identifier                          = 621
	SystemVerilogParserRULE_variable_identifier                      = 622
)

// ILibrary_textContext is an interface to support dynamic dispatch.
type ILibrary_textContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibrary_textContext differentiates from other interfaces.
	IsLibrary_textContext()
}

type Library_textContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibrary_textContext() *Library_textContext {
	var p = new(Library_textContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_library_text
	return p
}

func (*Library_textContext) IsLibrary_textContext() {}

func NewLibrary_textContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Library_textContext {
	var p = new(Library_textContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_library_text

	return p
}

func (s *Library_textContext) GetParser() antlr.Parser { return s.parser }

func (s *Library_textContext) AllLibrary_description() []ILibrary_descriptionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILibrary_descriptionContext)(nil)).Elem())
	var tst = make([]ILibrary_descriptionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILibrary_descriptionContext)
		}
	}

	return tst
}

func (s *Library_textContext) Library_description(i int) ILibrary_descriptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibrary_descriptionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILibrary_descriptionContext)
}

func (s *Library_textContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Library_textContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Library_textContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterLibrary_text(s)
	}
}

func (s *Library_textContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitLibrary_text(s)
	}
}

func (p *SystemVerilogParser) Library_text() (localctx ILibrary_textContext) {
	this := p
	_ = this

	localctx = NewLibrary_textContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, SystemVerilogParserRULE_library_text)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1249)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserSEMI || _la == SystemVerilogParserKCONFIG || _la == SystemVerilogParserKINCLUDE || _la == SystemVerilogParserKLIBRARY {
		{
			p.SetState(1246)
			p.Library_description()
		}

		p.SetState(1251)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ILibrary_descriptionContext is an interface to support dynamic dispatch.
type ILibrary_descriptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibrary_descriptionContext differentiates from other interfaces.
	IsLibrary_descriptionContext()
}

type Library_descriptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibrary_descriptionContext() *Library_descriptionContext {
	var p = new(Library_descriptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_library_description
	return p
}

func (*Library_descriptionContext) IsLibrary_descriptionContext() {}

func NewLibrary_descriptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Library_descriptionContext {
	var p = new(Library_descriptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_library_description

	return p
}

func (s *Library_descriptionContext) GetParser() antlr.Parser { return s.parser }

func (s *Library_descriptionContext) Library_declaration() ILibrary_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibrary_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILibrary_declarationContext)
}

func (s *Library_descriptionContext) Include_statement() IInclude_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInclude_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInclude_statementContext)
}

func (s *Library_descriptionContext) Config_declaration() IConfig_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConfig_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConfig_declarationContext)
}

func (s *Library_descriptionContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Library_descriptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Library_descriptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Library_descriptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterLibrary_description(s)
	}
}

func (s *Library_descriptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitLibrary_description(s)
	}
}

func (p *SystemVerilogParser) Library_description() (localctx ILibrary_descriptionContext) {
	this := p
	_ = this

	localctx = NewLibrary_descriptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, SystemVerilogParserRULE_library_description)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1256)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserKLIBRARY:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1252)
			p.Library_declaration()
		}

	case SystemVerilogParserKINCLUDE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1253)
			p.Include_statement()
		}

	case SystemVerilogParserKCONFIG:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1254)
			p.Config_declaration()
		}

	case SystemVerilogParserSEMI:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1255)
			p.Match(SystemVerilogParserSEMI)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ILibrary_declarationContext is an interface to support dynamic dispatch.
type ILibrary_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibrary_declarationContext differentiates from other interfaces.
	IsLibrary_declarationContext()
}

type Library_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibrary_declarationContext() *Library_declarationContext {
	var p = new(Library_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_library_declaration
	return p
}

func (*Library_declarationContext) IsLibrary_declarationContext() {}

func NewLibrary_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Library_declarationContext {
	var p = new(Library_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_library_declaration

	return p
}

func (s *Library_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Library_declarationContext) KLIBRARY() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKLIBRARY, 0)
}

func (s *Library_declarationContext) Library_identifier() ILibrary_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibrary_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILibrary_identifierContext)
}

func (s *Library_declarationContext) AllFILE_PATH_SPEC() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserFILE_PATH_SPEC)
}

func (s *Library_declarationContext) FILE_PATH_SPEC(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserFILE_PATH_SPEC, i)
}

func (s *Library_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Library_declarationContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *Library_declarationContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *Library_declarationContext) KINCDIR() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKINCDIR, 0)
}

func (s *Library_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Library_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Library_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterLibrary_declaration(s)
	}
}

func (s *Library_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitLibrary_declaration(s)
	}
}

func (p *SystemVerilogParser) Library_declaration() (localctx ILibrary_declarationContext) {
	this := p
	_ = this

	localctx = NewLibrary_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, SystemVerilogParserRULE_library_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1258)
		p.Match(SystemVerilogParserKLIBRARY)
	}
	{
		p.SetState(1259)
		p.Library_identifier()
	}
	{
		p.SetState(1260)
		p.Match(SystemVerilogParserFILE_PATH_SPEC)
	}
	p.SetState(1265)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserCOMMA {
		{
			p.SetState(1261)
			p.Match(SystemVerilogParserCOMMA)
		}
		{
			p.SetState(1262)
			p.Match(SystemVerilogParserFILE_PATH_SPEC)
		}

		p.SetState(1267)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1277)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserKINCDIR {
		{
			p.SetState(1268)
			p.Match(SystemVerilogParserKINCDIR)
		}
		{
			p.SetState(1269)
			p.Match(SystemVerilogParserFILE_PATH_SPEC)
		}
		p.SetState(1274)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserCOMMA {
			{
				p.SetState(1270)
				p.Match(SystemVerilogParserCOMMA)
			}
			{
				p.SetState(1271)
				p.Match(SystemVerilogParserFILE_PATH_SPEC)
			}

			p.SetState(1276)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(1279)
		p.Match(SystemVerilogParserSEMI)
	}

	return localctx
}

// IInclude_statementContext is an interface to support dynamic dispatch.
type IInclude_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInclude_statementContext differentiates from other interfaces.
	IsInclude_statementContext()
}

type Include_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInclude_statementContext() *Include_statementContext {
	var p = new(Include_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_include_statement
	return p
}

func (*Include_statementContext) IsInclude_statementContext() {}

func NewInclude_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Include_statementContext {
	var p = new(Include_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_include_statement

	return p
}

func (s *Include_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Include_statementContext) KINCLUDE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKINCLUDE, 0)
}

func (s *Include_statementContext) FILE_PATH_SPEC() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserFILE_PATH_SPEC, 0)
}

func (s *Include_statementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Include_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Include_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Include_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterInclude_statement(s)
	}
}

func (s *Include_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitInclude_statement(s)
	}
}

func (p *SystemVerilogParser) Include_statement() (localctx IInclude_statementContext) {
	this := p
	_ = this

	localctx = NewInclude_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, SystemVerilogParserRULE_include_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1281)
		p.Match(SystemVerilogParserKINCLUDE)
	}
	{
		p.SetState(1282)
		p.Match(SystemVerilogParserFILE_PATH_SPEC)
	}
	{
		p.SetState(1283)
		p.Match(SystemVerilogParserSEMI)
	}

	return localctx
}

// ISource_textContext is an interface to support dynamic dispatch.
type ISource_textContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSource_textContext differentiates from other interfaces.
	IsSource_textContext()
}

type Source_textContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySource_textContext() *Source_textContext {
	var p = new(Source_textContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_source_text
	return p
}

func (*Source_textContext) IsSource_textContext() {}

func NewSource_textContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Source_textContext {
	var p = new(Source_textContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_source_text

	return p
}

func (s *Source_textContext) GetParser() antlr.Parser { return s.parser }

func (s *Source_textContext) EOF() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserEOF, 0)
}

func (s *Source_textContext) Timeunits_declaration() ITimeunits_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITimeunits_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITimeunits_declarationContext)
}

func (s *Source_textContext) AllDescription() []IDescriptionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDescriptionContext)(nil)).Elem())
	var tst = make([]IDescriptionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDescriptionContext)
		}
	}

	return tst
}

func (s *Source_textContext) Description(i int) IDescriptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDescriptionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDescriptionContext)
}

func (s *Source_textContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Source_textContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Source_textContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterSource_text(s)
	}
}

func (s *Source_textContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitSource_text(s)
	}
}

func (p *SystemVerilogParser) Source_text() (localctx ISource_textContext) {
	this := p
	_ = this

	localctx = NewSource_textContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, SystemVerilogParserRULE_source_text)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1286)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 5, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1285)
			p.Timeunits_declaration()
		}

	}
	p.SetState(1291)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la-19)&-(0x1f+1)) == 0 && ((1<<uint((_la-19)))&((1<<(SystemVerilogParserDUNIT-19))|(1<<(SystemVerilogParserLPS-19))|(1<<(SystemVerilogParserSEMI-19))|(1<<(SystemVerilogParserLB-19)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(SystemVerilogParserKAUTOMATIC-103))|(1<<(SystemVerilogParserKBIND-103))|(1<<(SystemVerilogParserKBIT-103))|(1<<(SystemVerilogParserKBYTE-103))|(1<<(SystemVerilogParserKCHANDLE-103))|(1<<(SystemVerilogParserKCHECKER-103))|(1<<(SystemVerilogParserKCLASS-103))|(1<<(SystemVerilogParserKCONFIG-103))|(1<<(SystemVerilogParserKCONST-103))|(1<<(SystemVerilogParserKCONSTRAINT-103))|(1<<(SystemVerilogParserKCOVERGROUP-103)))) != 0) || (((_la-159)&-(0x1f+1)) == 0 && ((1<<uint((_la-159)))&((1<<(SystemVerilogParserKENUM-159))|(1<<(SystemVerilogParserKEVENT-159))|(1<<(SystemVerilogParserKEXPORT-159))|(1<<(SystemVerilogParserKEXTERN-159))|(1<<(SystemVerilogParserKFUNCTION-159))|(1<<(SystemVerilogParserKIMPORT-159)))) != 0) || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SystemVerilogParserKINT-195))|(1<<(SystemVerilogParserKINTEGER-195))|(1<<(SystemVerilogParserKINTERCONNECT-195))|(1<<(SystemVerilogParserKINTERFACE-195))|(1<<(SystemVerilogParserKLET-195))|(1<<(SystemVerilogParserKLOCALPARAM-195))|(1<<(SystemVerilogParserKLOGIC-195))|(1<<(SystemVerilogParserKLONGINT-195))|(1<<(SystemVerilogParserKMACROMODULE-195))|(1<<(SystemVerilogParserKMODULE-195))|(1<<(SystemVerilogParserKNETTYPE-195)))) != 0) || (((_la-232)&-(0x1f+1)) == 0 && ((1<<uint((_la-232)))&((1<<(SystemVerilogParserKPACKAGE-232))|(1<<(SystemVerilogParserKPARAMETER-232))|(1<<(SystemVerilogParserKPROGRAM-232))|(1<<(SystemVerilogParserKPROPERTY-232))|(1<<(SystemVerilogParserKREAL-232))|(1<<(SystemVerilogParserKREALTIME-232))|(1<<(SystemVerilogParserKREG-232)))) != 0) || (((_la-275)&-(0x1f+1)) == 0 && ((1<<uint((_la-275)))&((1<<(SystemVerilogParserKSEQUENCE-275))|(1<<(SystemVerilogParserKSHORTINT-275))|(1<<(SystemVerilogParserKSHORTREAL-275))|(1<<(SystemVerilogParserKSIGNED-275))|(1<<(SystemVerilogParserKSTATIC-275))|(1<<(SystemVerilogParserKSTRING-275))|(1<<(SystemVerilogParserKSTRUCT-275))|(1<<(SystemVerilogParserKSUPPLY0-275))|(1<<(SystemVerilogParserKSUPPLY1-275))|(1<<(SystemVerilogParserKTASK-275))|(1<<(SystemVerilogParserKTIME-275))|(1<<(SystemVerilogParserKTIMEPRECISION-275))|(1<<(SystemVerilogParserKTIMEUNIT-275)))) != 0) || (((_la-307)&-(0x1f+1)) == 0 && ((1<<uint((_la-307)))&((1<<(SystemVerilogParserKTRI-307))|(1<<(SystemVerilogParserKTRI0-307))|(1<<(SystemVerilogParserKTRI1-307))|(1<<(SystemVerilogParserKTRIAND-307))|(1<<(SystemVerilogParserKTRIOR-307))|(1<<(SystemVerilogParserKTRIREG-307))|(1<<(SystemVerilogParserKTYPE-307))|(1<<(SystemVerilogParserKTYPEDEF-307))|(1<<(SystemVerilogParserKUNION-307))|(1<<(SystemVerilogParserKUNSIGNED-307))|(1<<(SystemVerilogParserKUWIRE-307))|(1<<(SystemVerilogParserKVAR-307))|(1<<(SystemVerilogParserKVIRTUAL-307))|(1<<(SystemVerilogParserKWAND-307))|(1<<(SystemVerilogParserKWIRE-307)))) != 0) || _la == SystemVerilogParserKWOR || _la == SystemVerilogParserSIMPLE_IDENTIFIER {
		{
			p.SetState(1288)
			p.Description()
		}

		p.SetState(1293)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1294)
		p.Match(SystemVerilogParserEOF)
	}

	return localctx
}

// IDescriptionContext is an interface to support dynamic dispatch.
type IDescriptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDescriptionContext differentiates from other interfaces.
	IsDescriptionContext()
}

type DescriptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDescriptionContext() *DescriptionContext {
	var p = new(DescriptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_description
	return p
}

func (*DescriptionContext) IsDescriptionContext() {}

func NewDescriptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DescriptionContext {
	var p = new(DescriptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_description

	return p
}

func (s *DescriptionContext) GetParser() antlr.Parser { return s.parser }

func (s *DescriptionContext) Module_declaration() IModule_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_declarationContext)
}

func (s *DescriptionContext) Interface_declaration() IInterface_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterface_declarationContext)
}

func (s *DescriptionContext) Program_declaration() IProgram_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProgram_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProgram_declarationContext)
}

func (s *DescriptionContext) Package_declaration() IPackage_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackage_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPackage_declarationContext)
}

func (s *DescriptionContext) Package_item() IPackage_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackage_itemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPackage_itemContext)
}

func (s *DescriptionContext) Bind_directive() IBind_directiveContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBind_directiveContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBind_directiveContext)
}

func (s *DescriptionContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *DescriptionContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *DescriptionContext) Config_declaration() IConfig_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConfig_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConfig_declarationContext)
}

func (s *DescriptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescriptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DescriptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterDescription(s)
	}
}

func (s *DescriptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitDescription(s)
	}
}

func (p *SystemVerilogParser) Description() (localctx IDescriptionContext) {
	this := p
	_ = this

	localctx = NewDescriptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, SystemVerilogParserRULE_description)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1311)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 9, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1296)
			p.Module_declaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1297)
			p.Interface_declaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1298)
			p.Program_declaration()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1299)
			p.Package_declaration()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		p.SetState(1303)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserLPS {
			{
				p.SetState(1300)
				p.Attribute_instance()
			}

			p.SetState(1305)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(1308)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SystemVerilogParserDUNIT, SystemVerilogParserSEMI, SystemVerilogParserLB, SystemVerilogParserKAUTOMATIC, SystemVerilogParserKBIT, SystemVerilogParserKBYTE, SystemVerilogParserKCHANDLE, SystemVerilogParserKCHECKER, SystemVerilogParserKCLASS, SystemVerilogParserKCONST, SystemVerilogParserKCONSTRAINT, SystemVerilogParserKCOVERGROUP, SystemVerilogParserKENUM, SystemVerilogParserKEVENT, SystemVerilogParserKEXPORT, SystemVerilogParserKFUNCTION, SystemVerilogParserKIMPORT, SystemVerilogParserKINT, SystemVerilogParserKINTEGER, SystemVerilogParserKINTERCONNECT, SystemVerilogParserKLET, SystemVerilogParserKLOCALPARAM, SystemVerilogParserKLOGIC, SystemVerilogParserKLONGINT, SystemVerilogParserKNETTYPE, SystemVerilogParserKPARAMETER, SystemVerilogParserKPROGRAM, SystemVerilogParserKPROPERTY, SystemVerilogParserKREAL, SystemVerilogParserKREALTIME, SystemVerilogParserKREG, SystemVerilogParserKSEQUENCE, SystemVerilogParserKSHORTINT, SystemVerilogParserKSHORTREAL, SystemVerilogParserKSIGNED, SystemVerilogParserKSTATIC, SystemVerilogParserKSTRING, SystemVerilogParserKSTRUCT, SystemVerilogParserKSUPPLY0, SystemVerilogParserKSUPPLY1, SystemVerilogParserKTASK, SystemVerilogParserKTIME, SystemVerilogParserKTIMEPRECISION, SystemVerilogParserKTIMEUNIT, SystemVerilogParserKTRI, SystemVerilogParserKTRI0, SystemVerilogParserKTRI1, SystemVerilogParserKTRIAND, SystemVerilogParserKTRIOR, SystemVerilogParserKTRIREG, SystemVerilogParserKTYPE, SystemVerilogParserKTYPEDEF, SystemVerilogParserKUNION, SystemVerilogParserKUNSIGNED, SystemVerilogParserKUWIRE, SystemVerilogParserKVAR, SystemVerilogParserKVIRTUAL, SystemVerilogParserKWAND, SystemVerilogParserKWIRE, SystemVerilogParserKWOR, SystemVerilogParserSIMPLE_IDENTIFIER:
			{
				p.SetState(1306)
				p.Package_item()
			}

		case SystemVerilogParserKBIND:
			{
				p.SetState(1307)
				p.Bind_directive()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1310)
			p.Config_declaration()
		}

	}

	return localctx
}

// IModule_nonansi_headerContext is an interface to support dynamic dispatch.
type IModule_nonansi_headerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModule_nonansi_headerContext differentiates from other interfaces.
	IsModule_nonansi_headerContext()
}

type Module_nonansi_headerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModule_nonansi_headerContext() *Module_nonansi_headerContext {
	var p = new(Module_nonansi_headerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_module_nonansi_header
	return p
}

func (*Module_nonansi_headerContext) IsModule_nonansi_headerContext() {}

func NewModule_nonansi_headerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Module_nonansi_headerContext {
	var p = new(Module_nonansi_headerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_module_nonansi_header

	return p
}

func (s *Module_nonansi_headerContext) GetParser() antlr.Parser { return s.parser }

func (s *Module_nonansi_headerContext) Module_keyword() IModule_keywordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_keywordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_keywordContext)
}

func (s *Module_nonansi_headerContext) Module_identifier() IModule_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_identifierContext)
}

func (s *Module_nonansi_headerContext) List_of_ports() IList_of_portsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_portsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_portsContext)
}

func (s *Module_nonansi_headerContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Module_nonansi_headerContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Module_nonansi_headerContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Module_nonansi_headerContext) Lifetime() ILifetimeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILifetimeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILifetimeContext)
}

func (s *Module_nonansi_headerContext) AllPackage_import_declaration() []IPackage_import_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPackage_import_declarationContext)(nil)).Elem())
	var tst = make([]IPackage_import_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPackage_import_declarationContext)
		}
	}

	return tst
}

func (s *Module_nonansi_headerContext) Package_import_declaration(i int) IPackage_import_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackage_import_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPackage_import_declarationContext)
}

func (s *Module_nonansi_headerContext) Parameter_port_list() IParameter_port_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_port_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_port_listContext)
}

func (s *Module_nonansi_headerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Module_nonansi_headerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Module_nonansi_headerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterModule_nonansi_header(s)
	}
}

func (s *Module_nonansi_headerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitModule_nonansi_header(s)
	}
}

func (p *SystemVerilogParser) Module_nonansi_header() (localctx IModule_nonansi_headerContext) {
	this := p
	_ = this

	localctx = NewModule_nonansi_headerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, SystemVerilogParserRULE_module_nonansi_header)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1316)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserLPS {
		{
			p.SetState(1313)
			p.Attribute_instance()
		}

		p.SetState(1318)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1319)
		p.Module_keyword()
	}
	p.SetState(1321)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserKAUTOMATIC || _la == SystemVerilogParserKSTATIC {
		{
			p.SetState(1320)
			p.Lifetime()
		}

	}
	{
		p.SetState(1323)
		p.Module_identifier()
	}
	p.SetState(1327)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserKIMPORT {
		{
			p.SetState(1324)
			p.Package_import_declaration()
		}

		p.SetState(1329)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1331)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserP {
		{
			p.SetState(1330)
			p.Parameter_port_list()
		}

	}
	{
		p.SetState(1333)
		p.List_of_ports()
	}
	{
		p.SetState(1334)
		p.Match(SystemVerilogParserSEMI)
	}

	return localctx
}

// IModule_ansi_headerContext is an interface to support dynamic dispatch.
type IModule_ansi_headerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModule_ansi_headerContext differentiates from other interfaces.
	IsModule_ansi_headerContext()
}

type Module_ansi_headerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModule_ansi_headerContext() *Module_ansi_headerContext {
	var p = new(Module_ansi_headerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_module_ansi_header
	return p
}

func (*Module_ansi_headerContext) IsModule_ansi_headerContext() {}

func NewModule_ansi_headerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Module_ansi_headerContext {
	var p = new(Module_ansi_headerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_module_ansi_header

	return p
}

func (s *Module_ansi_headerContext) GetParser() antlr.Parser { return s.parser }

func (s *Module_ansi_headerContext) Module_keyword() IModule_keywordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_keywordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_keywordContext)
}

func (s *Module_ansi_headerContext) Module_identifier() IModule_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_identifierContext)
}

func (s *Module_ansi_headerContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Module_ansi_headerContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Module_ansi_headerContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Module_ansi_headerContext) Lifetime() ILifetimeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILifetimeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILifetimeContext)
}

func (s *Module_ansi_headerContext) AllPackage_import_declaration() []IPackage_import_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPackage_import_declarationContext)(nil)).Elem())
	var tst = make([]IPackage_import_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPackage_import_declarationContext)
		}
	}

	return tst
}

func (s *Module_ansi_headerContext) Package_import_declaration(i int) IPackage_import_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackage_import_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPackage_import_declarationContext)
}

func (s *Module_ansi_headerContext) Parameter_port_list() IParameter_port_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_port_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_port_listContext)
}

func (s *Module_ansi_headerContext) List_of_port_declarations() IList_of_port_declarationsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_port_declarationsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_port_declarationsContext)
}

func (s *Module_ansi_headerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Module_ansi_headerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Module_ansi_headerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterModule_ansi_header(s)
	}
}

func (s *Module_ansi_headerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitModule_ansi_header(s)
	}
}

func (p *SystemVerilogParser) Module_ansi_header() (localctx IModule_ansi_headerContext) {
	this := p
	_ = this

	localctx = NewModule_ansi_headerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, SystemVerilogParserRULE_module_ansi_header)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1339)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserLPS {
		{
			p.SetState(1336)
			p.Attribute_instance()
		}

		p.SetState(1341)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1342)
		p.Module_keyword()
	}
	p.SetState(1344)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserKAUTOMATIC || _la == SystemVerilogParserKSTATIC {
		{
			p.SetState(1343)
			p.Lifetime()
		}

	}
	{
		p.SetState(1346)
		p.Module_identifier()
	}
	p.SetState(1350)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserKIMPORT {
		{
			p.SetState(1347)
			p.Package_import_declaration()
		}

		p.SetState(1352)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1354)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserP {
		{
			p.SetState(1353)
			p.Parameter_port_list()
		}

	}
	p.SetState(1357)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserLP {
		{
			p.SetState(1356)
			p.List_of_port_declarations()
		}

	}
	{
		p.SetState(1359)
		p.Match(SystemVerilogParserSEMI)
	}

	return localctx
}

// IModule_declarationContext is an interface to support dynamic dispatch.
type IModule_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModule_declarationContext differentiates from other interfaces.
	IsModule_declarationContext()
}

type Module_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModule_declarationContext() *Module_declarationContext {
	var p = new(Module_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_module_declaration
	return p
}

func (*Module_declarationContext) IsModule_declarationContext() {}

func NewModule_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Module_declarationContext {
	var p = new(Module_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_module_declaration

	return p
}

func (s *Module_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Module_declarationContext) Module_nonansi_header() IModule_nonansi_headerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_nonansi_headerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_nonansi_headerContext)
}

func (s *Module_declarationContext) KENDMODULE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKENDMODULE, 0)
}

func (s *Module_declarationContext) Timeunits_declaration() ITimeunits_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITimeunits_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITimeunits_declarationContext)
}

func (s *Module_declarationContext) AllModule_item() []IModule_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IModule_itemContext)(nil)).Elem())
	var tst = make([]IModule_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IModule_itemContext)
		}
	}

	return tst
}

func (s *Module_declarationContext) Module_item(i int) IModule_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IModule_itemContext)
}

func (s *Module_declarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOLON, 0)
}

func (s *Module_declarationContext) AllModule_identifier() []IModule_identifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IModule_identifierContext)(nil)).Elem())
	var tst = make([]IModule_identifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IModule_identifierContext)
		}
	}

	return tst
}

func (s *Module_declarationContext) Module_identifier(i int) IModule_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_identifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IModule_identifierContext)
}

func (s *Module_declarationContext) Module_ansi_header() IModule_ansi_headerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_ansi_headerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_ansi_headerContext)
}

func (s *Module_declarationContext) AllNon_port_module_item() []INon_port_module_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INon_port_module_itemContext)(nil)).Elem())
	var tst = make([]INon_port_module_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INon_port_module_itemContext)
		}
	}

	return tst
}

func (s *Module_declarationContext) Non_port_module_item(i int) INon_port_module_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INon_port_module_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INon_port_module_itemContext)
}

func (s *Module_declarationContext) Module_keyword() IModule_keywordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_keywordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_keywordContext)
}

func (s *Module_declarationContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Module_declarationContext) DOTSTAR() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserDOTSTAR, 0)
}

func (s *Module_declarationContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Module_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Module_declarationContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Module_declarationContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Module_declarationContext) Lifetime() ILifetimeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILifetimeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILifetimeContext)
}

func (s *Module_declarationContext) KEXTERN() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKEXTERN, 0)
}

func (s *Module_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Module_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Module_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterModule_declaration(s)
	}
}

func (s *Module_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitModule_declaration(s)
	}
}

func (p *SystemVerilogParser) Module_declaration() (localctx IModule_declarationContext) {
	this := p
	_ = this

	localctx = NewModule_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, SystemVerilogParserRULE_module_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1425)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 31, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1361)
			p.Module_nonansi_header()
		}
		p.SetState(1363)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 19, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1362)
				p.Timeunits_declaration()
			}

		}
		p.SetState(1368)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SystemVerilogParserDERROR)|(1<<SystemVerilogParserDFATAL)|(1<<SystemVerilogParserDINFO)|(1<<SystemVerilogParserDUNIT)|(1<<SystemVerilogParserDWARNING)|(1<<SystemVerilogParserLPS))) != 0) || _la == SystemVerilogParserSEMI || _la == SystemVerilogParserLB || (((_la-94)&-(0x1f+1)) == 0 && ((1<<uint((_la-94)))&((1<<(SystemVerilogParserKALIAS-94))|(1<<(SystemVerilogParserKALWAYS-94))|(1<<(SystemVerilogParserKALWAYS_COMB-94))|(1<<(SystemVerilogParserKALWAYS_FF-94))|(1<<(SystemVerilogParserKALWAYS_LATCH-94))|(1<<(SystemVerilogParserKAND-94))|(1<<(SystemVerilogParserKASSERT-94))|(1<<(SystemVerilogParserKASSIGN-94))|(1<<(SystemVerilogParserKASSUME-94))|(1<<(SystemVerilogParserKAUTOMATIC-94))|(1<<(SystemVerilogParserKBIND-94))|(1<<(SystemVerilogParserKBIT-94))|(1<<(SystemVerilogParserKBUF-94))|(1<<(SystemVerilogParserKBUFIF0-94))|(1<<(SystemVerilogParserKBUFIF1-94))|(1<<(SystemVerilogParserKBYTE-94))|(1<<(SystemVerilogParserKCASE-94))|(1<<(SystemVerilogParserKCHANDLE-94))|(1<<(SystemVerilogParserKCHECKER-94))|(1<<(SystemVerilogParserKCLASS-94))|(1<<(SystemVerilogParserKCLOCKING-94))|(1<<(SystemVerilogParserKCMOS-94))|(1<<(SystemVerilogParserKCONST-94)))) != 0) || (((_la-126)&-(0x1f+1)) == 0 && ((1<<uint((_la-126)))&((1<<(SystemVerilogParserKCONSTRAINT-126))|(1<<(SystemVerilogParserKCOVER-126))|(1<<(SystemVerilogParserKCOVERGROUP-126))|(1<<(SystemVerilogParserKDEFAULT-126))|(1<<(SystemVerilogParserKDEFPARAM-126)))) != 0) || (((_la-159)&-(0x1f+1)) == 0 && ((1<<uint((_la-159)))&((1<<(SystemVerilogParserKENUM-159))|(1<<(SystemVerilogParserKEVENT-159))|(1<<(SystemVerilogParserKEXPORT-159))|(1<<(SystemVerilogParserKEXTERN-159))|(1<<(SystemVerilogParserKFINAL-159))|(1<<(SystemVerilogParserKFOR-159))|(1<<(SystemVerilogParserKFUNCTION-159))|(1<<(SystemVerilogParserKGENERATE-159))|(1<<(SystemVerilogParserKGENVAR-159))|(1<<(SystemVerilogParserKGLOBAL-159))|(1<<(SystemVerilogParserKIF-159))|(1<<(SystemVerilogParserKIMPORT-159))|(1<<(SystemVerilogParserKINITIAL-159)))) != 0) || (((_la-191)&-(0x1f+1)) == 0 && ((1<<uint((_la-191)))&((1<<(SystemVerilogParserKINOUT-191))|(1<<(SystemVerilogParserKINPUT-191))|(1<<(SystemVerilogParserKINT-191))|(1<<(SystemVerilogParserKINTEGER-191))|(1<<(SystemVerilogParserKINTERCONNECT-191))|(1<<(SystemVerilogParserKINTERFACE-191))|(1<<(SystemVerilogParserKLET-191))|(1<<(SystemVerilogParserKLOCALPARAM-191))|(1<<(SystemVerilogParserKLOGIC-191))|(1<<(SystemVerilogParserKLONGINT-191))|(1<<(SystemVerilogParserKMACROMODULE-191))|(1<<(SystemVerilogParserKMODULE-191))|(1<<(SystemVerilogParserKNAND-191))|(1<<(SystemVerilogParserKNETTYPE-191))|(1<<(SystemVerilogParserKNMOS-191)))) != 0) || (((_la-223)&-(0x1f+1)) == 0 && ((1<<uint((_la-223)))&((1<<(SystemVerilogParserKNOR-223))|(1<<(SystemVerilogParserKNOT-223))|(1<<(SystemVerilogParserKNOTIF0-223))|(1<<(SystemVerilogParserKNOTIF1-223))|(1<<(SystemVerilogParserKOR-223))|(1<<(SystemVerilogParserKOUTPUT-223))|(1<<(SystemVerilogParserKPARAMETER-223))|(1<<(SystemVerilogParserKPMOS-223))|(1<<(SystemVerilogParserKPROGRAM-223))|(1<<(SystemVerilogParserKPROPERTY-223))|(1<<(SystemVerilogParserKPULLDOWN-223))|(1<<(SystemVerilogParserKPULLUP-223))|(1<<(SystemVerilogParserKRCMOS-223)))) != 0) || (((_la-255)&-(0x1f+1)) == 0 && ((1<<uint((_la-255)))&((1<<(SystemVerilogParserKREAL-255))|(1<<(SystemVerilogParserKREALTIME-255))|(1<<(SystemVerilogParserKREF-255))|(1<<(SystemVerilogParserKREG-255))|(1<<(SystemVerilogParserKRESTRICT-255))|(1<<(SystemVerilogParserKRNMOS-255))|(1<<(SystemVerilogParserKRPMOS-255))|(1<<(SystemVerilogParserKRTRAN-255))|(1<<(SystemVerilogParserKRTRANIF0-255))|(1<<(SystemVerilogParserKRTRANIF1-255))|(1<<(SystemVerilogParserKSEQUENCE-255))|(1<<(SystemVerilogParserKSHORTINT-255))|(1<<(SystemVerilogParserKSHORTREAL-255))|(1<<(SystemVerilogParserKSIGNED-255))|(1<<(SystemVerilogParserKSPECIFY-255))|(1<<(SystemVerilogParserKSPECPARAM-255))|(1<<(SystemVerilogParserKSTATIC-255)))) != 0) || (((_la-287)&-(0x1f+1)) == 0 && ((1<<uint((_la-287)))&((1<<(SystemVerilogParserKSTRING-287))|(1<<(SystemVerilogParserKSTRUCT-287))|(1<<(SystemVerilogParserKSUPPLY0-287))|(1<<(SystemVerilogParserKSUPPLY1-287))|(1<<(SystemVerilogParserKTASK-287))|(1<<(SystemVerilogParserKTIME-287))|(1<<(SystemVerilogParserKTIMEPRECISION-287))|(1<<(SystemVerilogParserKTIMEUNIT-287))|(1<<(SystemVerilogParserKTRAN-287))|(1<<(SystemVerilogParserKTRANIF0-287))|(1<<(SystemVerilogParserKTRANIF1-287))|(1<<(SystemVerilogParserKTRI-287))|(1<<(SystemVerilogParserKTRI0-287))|(1<<(SystemVerilogParserKTRI1-287))|(1<<(SystemVerilogParserKTRIAND-287))|(1<<(SystemVerilogParserKTRIOR-287))|(1<<(SystemVerilogParserKTRIREG-287))|(1<<(SystemVerilogParserKTYPE-287))|(1<<(SystemVerilogParserKTYPEDEF-287))|(1<<(SystemVerilogParserKUNION-287)))) != 0) || (((_la-319)&-(0x1f+1)) == 0 && ((1<<uint((_la-319)))&((1<<(SystemVerilogParserKUNSIGNED-319))|(1<<(SystemVerilogParserKUWIRE-319))|(1<<(SystemVerilogParserKVAR-319))|(1<<(SystemVerilogParserKVIRTUAL-319))|(1<<(SystemVerilogParserKWAND-319))|(1<<(SystemVerilogParserKWIRE-319))|(1<<(SystemVerilogParserKWOR-319))|(1<<(SystemVerilogParserKXNOR-319))|(1<<(SystemVerilogParserKXOR-319)))) != 0) || _la == SystemVerilogParserSIMPLE_IDENTIFIER {
			{
				p.SetState(1365)
				p.Module_item()
			}

			p.SetState(1370)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1371)
			p.Match(SystemVerilogParserKENDMODULE)
		}
		p.SetState(1374)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserCOLON {
			{
				p.SetState(1372)
				p.Match(SystemVerilogParserCOLON)
			}
			{
				p.SetState(1373)
				p.Module_identifier()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1376)
			p.Module_ansi_header()
		}
		p.SetState(1378)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 22, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1377)
				p.Timeunits_declaration()
			}

		}
		p.SetState(1383)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SystemVerilogParserDERROR)|(1<<SystemVerilogParserDFATAL)|(1<<SystemVerilogParserDINFO)|(1<<SystemVerilogParserDUNIT)|(1<<SystemVerilogParserDWARNING)|(1<<SystemVerilogParserLPS))) != 0) || _la == SystemVerilogParserSEMI || _la == SystemVerilogParserLB || (((_la-94)&-(0x1f+1)) == 0 && ((1<<uint((_la-94)))&((1<<(SystemVerilogParserKALIAS-94))|(1<<(SystemVerilogParserKALWAYS-94))|(1<<(SystemVerilogParserKALWAYS_COMB-94))|(1<<(SystemVerilogParserKALWAYS_FF-94))|(1<<(SystemVerilogParserKALWAYS_LATCH-94))|(1<<(SystemVerilogParserKAND-94))|(1<<(SystemVerilogParserKASSERT-94))|(1<<(SystemVerilogParserKASSIGN-94))|(1<<(SystemVerilogParserKASSUME-94))|(1<<(SystemVerilogParserKAUTOMATIC-94))|(1<<(SystemVerilogParserKBIND-94))|(1<<(SystemVerilogParserKBIT-94))|(1<<(SystemVerilogParserKBUF-94))|(1<<(SystemVerilogParserKBUFIF0-94))|(1<<(SystemVerilogParserKBUFIF1-94))|(1<<(SystemVerilogParserKBYTE-94))|(1<<(SystemVerilogParserKCASE-94))|(1<<(SystemVerilogParserKCHANDLE-94))|(1<<(SystemVerilogParserKCHECKER-94))|(1<<(SystemVerilogParserKCLASS-94))|(1<<(SystemVerilogParserKCLOCKING-94))|(1<<(SystemVerilogParserKCMOS-94))|(1<<(SystemVerilogParserKCONST-94)))) != 0) || (((_la-126)&-(0x1f+1)) == 0 && ((1<<uint((_la-126)))&((1<<(SystemVerilogParserKCONSTRAINT-126))|(1<<(SystemVerilogParserKCOVER-126))|(1<<(SystemVerilogParserKCOVERGROUP-126))|(1<<(SystemVerilogParserKDEFAULT-126))|(1<<(SystemVerilogParserKDEFPARAM-126)))) != 0) || (((_la-159)&-(0x1f+1)) == 0 && ((1<<uint((_la-159)))&((1<<(SystemVerilogParserKENUM-159))|(1<<(SystemVerilogParserKEVENT-159))|(1<<(SystemVerilogParserKEXPORT-159))|(1<<(SystemVerilogParserKEXTERN-159))|(1<<(SystemVerilogParserKFINAL-159))|(1<<(SystemVerilogParserKFOR-159))|(1<<(SystemVerilogParserKFUNCTION-159))|(1<<(SystemVerilogParserKGENERATE-159))|(1<<(SystemVerilogParserKGENVAR-159))|(1<<(SystemVerilogParserKGLOBAL-159))|(1<<(SystemVerilogParserKIF-159))|(1<<(SystemVerilogParserKIMPORT-159))|(1<<(SystemVerilogParserKINITIAL-159)))) != 0) || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SystemVerilogParserKINT-195))|(1<<(SystemVerilogParserKINTEGER-195))|(1<<(SystemVerilogParserKINTERCONNECT-195))|(1<<(SystemVerilogParserKINTERFACE-195))|(1<<(SystemVerilogParserKLET-195))|(1<<(SystemVerilogParserKLOCALPARAM-195))|(1<<(SystemVerilogParserKLOGIC-195))|(1<<(SystemVerilogParserKLONGINT-195))|(1<<(SystemVerilogParserKMACROMODULE-195))|(1<<(SystemVerilogParserKMODULE-195))|(1<<(SystemVerilogParserKNAND-195))|(1<<(SystemVerilogParserKNETTYPE-195))|(1<<(SystemVerilogParserKNMOS-195))|(1<<(SystemVerilogParserKNOR-195))|(1<<(SystemVerilogParserKNOT-195))|(1<<(SystemVerilogParserKNOTIF0-195)))) != 0) || (((_la-227)&-(0x1f+1)) == 0 && ((1<<uint((_la-227)))&((1<<(SystemVerilogParserKNOTIF1-227))|(1<<(SystemVerilogParserKOR-227))|(1<<(SystemVerilogParserKPARAMETER-227))|(1<<(SystemVerilogParserKPMOS-227))|(1<<(SystemVerilogParserKPROGRAM-227))|(1<<(SystemVerilogParserKPROPERTY-227))|(1<<(SystemVerilogParserKPULLDOWN-227))|(1<<(SystemVerilogParserKPULLUP-227))|(1<<(SystemVerilogParserKRCMOS-227))|(1<<(SystemVerilogParserKREAL-227))|(1<<(SystemVerilogParserKREALTIME-227))|(1<<(SystemVerilogParserKREG-227)))) != 0) || (((_la-262)&-(0x1f+1)) == 0 && ((1<<uint((_la-262)))&((1<<(SystemVerilogParserKRESTRICT-262))|(1<<(SystemVerilogParserKRNMOS-262))|(1<<(SystemVerilogParserKRPMOS-262))|(1<<(SystemVerilogParserKRTRAN-262))|(1<<(SystemVerilogParserKRTRANIF0-262))|(1<<(SystemVerilogParserKRTRANIF1-262))|(1<<(SystemVerilogParserKSEQUENCE-262))|(1<<(SystemVerilogParserKSHORTINT-262))|(1<<(SystemVerilogParserKSHORTREAL-262))|(1<<(SystemVerilogParserKSIGNED-262))|(1<<(SystemVerilogParserKSPECIFY-262))|(1<<(SystemVerilogParserKSPECPARAM-262))|(1<<(SystemVerilogParserKSTATIC-262))|(1<<(SystemVerilogParserKSTRING-262))|(1<<(SystemVerilogParserKSTRUCT-262))|(1<<(SystemVerilogParserKSUPPLY0-262)))) != 0) || (((_la-294)&-(0x1f+1)) == 0 && ((1<<uint((_la-294)))&((1<<(SystemVerilogParserKSUPPLY1-294))|(1<<(SystemVerilogParserKTASK-294))|(1<<(SystemVerilogParserKTIME-294))|(1<<(SystemVerilogParserKTIMEPRECISION-294))|(1<<(SystemVerilogParserKTIMEUNIT-294))|(1<<(SystemVerilogParserKTRAN-294))|(1<<(SystemVerilogParserKTRANIF0-294))|(1<<(SystemVerilogParserKTRANIF1-294))|(1<<(SystemVerilogParserKTRI-294))|(1<<(SystemVerilogParserKTRI0-294))|(1<<(SystemVerilogParserKTRI1-294))|(1<<(SystemVerilogParserKTRIAND-294))|(1<<(SystemVerilogParserKTRIOR-294))|(1<<(SystemVerilogParserKTRIREG-294))|(1<<(SystemVerilogParserKTYPE-294))|(1<<(SystemVerilogParserKTYPEDEF-294))|(1<<(SystemVerilogParserKUNION-294))|(1<<(SystemVerilogParserKUNSIGNED-294))|(1<<(SystemVerilogParserKUWIRE-294))|(1<<(SystemVerilogParserKVAR-294)))) != 0) || (((_la-327)&-(0x1f+1)) == 0 && ((1<<uint((_la-327)))&((1<<(SystemVerilogParserKVIRTUAL-327))|(1<<(SystemVerilogParserKWAND-327))|(1<<(SystemVerilogParserKWIRE-327))|(1<<(SystemVerilogParserKWOR-327))|(1<<(SystemVerilogParserKXNOR-327))|(1<<(SystemVerilogParserKXOR-327))|(1<<(SystemVerilogParserSIMPLE_IDENTIFIER-327)))) != 0) {
			{
				p.SetState(1380)
				p.Non_port_module_item()
			}

			p.SetState(1385)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1386)
			p.Match(SystemVerilogParserKENDMODULE)
		}
		p.SetState(1389)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserCOLON {
			{
				p.SetState(1387)
				p.Match(SystemVerilogParserCOLON)
			}
			{
				p.SetState(1388)
				p.Module_identifier()
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(1394)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserLPS {
			{
				p.SetState(1391)
				p.Attribute_instance()
			}

			p.SetState(1396)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1397)
			p.Module_keyword()
		}
		p.SetState(1399)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserKAUTOMATIC || _la == SystemVerilogParserKSTATIC {
			{
				p.SetState(1398)
				p.Lifetime()
			}

		}
		{
			p.SetState(1401)
			p.Module_identifier()
		}
		{
			p.SetState(1402)
			p.Match(SystemVerilogParserLP)
		}
		{
			p.SetState(1403)
			p.Match(SystemVerilogParserDOTSTAR)
		}
		{
			p.SetState(1404)
			p.Match(SystemVerilogParserRP)
		}
		{
			p.SetState(1405)
			p.Match(SystemVerilogParserSEMI)
		}
		p.SetState(1407)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 27, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1406)
				p.Timeunits_declaration()
			}

		}
		p.SetState(1412)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SystemVerilogParserDERROR)|(1<<SystemVerilogParserDFATAL)|(1<<SystemVerilogParserDINFO)|(1<<SystemVerilogParserDUNIT)|(1<<SystemVerilogParserDWARNING)|(1<<SystemVerilogParserLPS))) != 0) || _la == SystemVerilogParserSEMI || _la == SystemVerilogParserLB || (((_la-94)&-(0x1f+1)) == 0 && ((1<<uint((_la-94)))&((1<<(SystemVerilogParserKALIAS-94))|(1<<(SystemVerilogParserKALWAYS-94))|(1<<(SystemVerilogParserKALWAYS_COMB-94))|(1<<(SystemVerilogParserKALWAYS_FF-94))|(1<<(SystemVerilogParserKALWAYS_LATCH-94))|(1<<(SystemVerilogParserKAND-94))|(1<<(SystemVerilogParserKASSERT-94))|(1<<(SystemVerilogParserKASSIGN-94))|(1<<(SystemVerilogParserKASSUME-94))|(1<<(SystemVerilogParserKAUTOMATIC-94))|(1<<(SystemVerilogParserKBIND-94))|(1<<(SystemVerilogParserKBIT-94))|(1<<(SystemVerilogParserKBUF-94))|(1<<(SystemVerilogParserKBUFIF0-94))|(1<<(SystemVerilogParserKBUFIF1-94))|(1<<(SystemVerilogParserKBYTE-94))|(1<<(SystemVerilogParserKCASE-94))|(1<<(SystemVerilogParserKCHANDLE-94))|(1<<(SystemVerilogParserKCHECKER-94))|(1<<(SystemVerilogParserKCLASS-94))|(1<<(SystemVerilogParserKCLOCKING-94))|(1<<(SystemVerilogParserKCMOS-94))|(1<<(SystemVerilogParserKCONST-94)))) != 0) || (((_la-126)&-(0x1f+1)) == 0 && ((1<<uint((_la-126)))&((1<<(SystemVerilogParserKCONSTRAINT-126))|(1<<(SystemVerilogParserKCOVER-126))|(1<<(SystemVerilogParserKCOVERGROUP-126))|(1<<(SystemVerilogParserKDEFAULT-126))|(1<<(SystemVerilogParserKDEFPARAM-126)))) != 0) || (((_la-159)&-(0x1f+1)) == 0 && ((1<<uint((_la-159)))&((1<<(SystemVerilogParserKENUM-159))|(1<<(SystemVerilogParserKEVENT-159))|(1<<(SystemVerilogParserKEXPORT-159))|(1<<(SystemVerilogParserKEXTERN-159))|(1<<(SystemVerilogParserKFINAL-159))|(1<<(SystemVerilogParserKFOR-159))|(1<<(SystemVerilogParserKFUNCTION-159))|(1<<(SystemVerilogParserKGENERATE-159))|(1<<(SystemVerilogParserKGENVAR-159))|(1<<(SystemVerilogParserKGLOBAL-159))|(1<<(SystemVerilogParserKIF-159))|(1<<(SystemVerilogParserKIMPORT-159))|(1<<(SystemVerilogParserKINITIAL-159)))) != 0) || (((_la-191)&-(0x1f+1)) == 0 && ((1<<uint((_la-191)))&((1<<(SystemVerilogParserKINOUT-191))|(1<<(SystemVerilogParserKINPUT-191))|(1<<(SystemVerilogParserKINT-191))|(1<<(SystemVerilogParserKINTEGER-191))|(1<<(SystemVerilogParserKINTERCONNECT-191))|(1<<(SystemVerilogParserKINTERFACE-191))|(1<<(SystemVerilogParserKLET-191))|(1<<(SystemVerilogParserKLOCALPARAM-191))|(1<<(SystemVerilogParserKLOGIC-191))|(1<<(SystemVerilogParserKLONGINT-191))|(1<<(SystemVerilogParserKMACROMODULE-191))|(1<<(SystemVerilogParserKMODULE-191))|(1<<(SystemVerilogParserKNAND-191))|(1<<(SystemVerilogParserKNETTYPE-191))|(1<<(SystemVerilogParserKNMOS-191)))) != 0) || (((_la-223)&-(0x1f+1)) == 0 && ((1<<uint((_la-223)))&((1<<(SystemVerilogParserKNOR-223))|(1<<(SystemVerilogParserKNOT-223))|(1<<(SystemVerilogParserKNOTIF0-223))|(1<<(SystemVerilogParserKNOTIF1-223))|(1<<(SystemVerilogParserKOR-223))|(1<<(SystemVerilogParserKOUTPUT-223))|(1<<(SystemVerilogParserKPARAMETER-223))|(1<<(SystemVerilogParserKPMOS-223))|(1<<(SystemVerilogParserKPROGRAM-223))|(1<<(SystemVerilogParserKPROPERTY-223))|(1<<(SystemVerilogParserKPULLDOWN-223))|(1<<(SystemVerilogParserKPULLUP-223))|(1<<(SystemVerilogParserKRCMOS-223)))) != 0) || (((_la-255)&-(0x1f+1)) == 0 && ((1<<uint((_la-255)))&((1<<(SystemVerilogParserKREAL-255))|(1<<(SystemVerilogParserKREALTIME-255))|(1<<(SystemVerilogParserKREF-255))|(1<<(SystemVerilogParserKREG-255))|(1<<(SystemVerilogParserKRESTRICT-255))|(1<<(SystemVerilogParserKRNMOS-255))|(1<<(SystemVerilogParserKRPMOS-255))|(1<<(SystemVerilogParserKRTRAN-255))|(1<<(SystemVerilogParserKRTRANIF0-255))|(1<<(SystemVerilogParserKRTRANIF1-255))|(1<<(SystemVerilogParserKSEQUENCE-255))|(1<<(SystemVerilogParserKSHORTINT-255))|(1<<(SystemVerilogParserKSHORTREAL-255))|(1<<(SystemVerilogParserKSIGNED-255))|(1<<(SystemVerilogParserKSPECIFY-255))|(1<<(SystemVerilogParserKSPECPARAM-255))|(1<<(SystemVerilogParserKSTATIC-255)))) != 0) || (((_la-287)&-(0x1f+1)) == 0 && ((1<<uint((_la-287)))&((1<<(SystemVerilogParserKSTRING-287))|(1<<(SystemVerilogParserKSTRUCT-287))|(1<<(SystemVerilogParserKSUPPLY0-287))|(1<<(SystemVerilogParserKSUPPLY1-287))|(1<<(SystemVerilogParserKTASK-287))|(1<<(SystemVerilogParserKTIME-287))|(1<<(SystemVerilogParserKTIMEPRECISION-287))|(1<<(SystemVerilogParserKTIMEUNIT-287))|(1<<(SystemVerilogParserKTRAN-287))|(1<<(SystemVerilogParserKTRANIF0-287))|(1<<(SystemVerilogParserKTRANIF1-287))|(1<<(SystemVerilogParserKTRI-287))|(1<<(SystemVerilogParserKTRI0-287))|(1<<(SystemVerilogParserKTRI1-287))|(1<<(SystemVerilogParserKTRIAND-287))|(1<<(SystemVerilogParserKTRIOR-287))|(1<<(SystemVerilogParserKTRIREG-287))|(1<<(SystemVerilogParserKTYPE-287))|(1<<(SystemVerilogParserKTYPEDEF-287))|(1<<(SystemVerilogParserKUNION-287)))) != 0) || (((_la-319)&-(0x1f+1)) == 0 && ((1<<uint((_la-319)))&((1<<(SystemVerilogParserKUNSIGNED-319))|(1<<(SystemVerilogParserKUWIRE-319))|(1<<(SystemVerilogParserKVAR-319))|(1<<(SystemVerilogParserKVIRTUAL-319))|(1<<(SystemVerilogParserKWAND-319))|(1<<(SystemVerilogParserKWIRE-319))|(1<<(SystemVerilogParserKWOR-319))|(1<<(SystemVerilogParserKXNOR-319))|(1<<(SystemVerilogParserKXOR-319)))) != 0) || _la == SystemVerilogParserSIMPLE_IDENTIFIER {
			{
				p.SetState(1409)
				p.Module_item()
			}

			p.SetState(1414)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1415)
			p.Match(SystemVerilogParserKENDMODULE)
		}
		p.SetState(1418)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserCOLON {
			{
				p.SetState(1416)
				p.Match(SystemVerilogParserCOLON)
			}
			{
				p.SetState(1417)
				p.Module_identifier()
			}

		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1420)
			p.Match(SystemVerilogParserKEXTERN)
		}
		p.SetState(1423)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 30, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1421)
				p.Module_nonansi_header()
			}

		case 2:
			{
				p.SetState(1422)
				p.Module_ansi_header()
			}

		}

	}

	return localctx
}

// IModule_keywordContext is an interface to support dynamic dispatch.
type IModule_keywordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModule_keywordContext differentiates from other interfaces.
	IsModule_keywordContext()
}

type Module_keywordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModule_keywordContext() *Module_keywordContext {
	var p = new(Module_keywordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_module_keyword
	return p
}

func (*Module_keywordContext) IsModule_keywordContext() {}

func NewModule_keywordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Module_keywordContext {
	var p = new(Module_keywordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_module_keyword

	return p
}

func (s *Module_keywordContext) GetParser() antlr.Parser { return s.parser }

func (s *Module_keywordContext) KMODULE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKMODULE, 0)
}

func (s *Module_keywordContext) KMACROMODULE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKMACROMODULE, 0)
}

func (s *Module_keywordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Module_keywordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Module_keywordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterModule_keyword(s)
	}
}

func (s *Module_keywordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitModule_keyword(s)
	}
}

func (p *SystemVerilogParser) Module_keyword() (localctx IModule_keywordContext) {
	this := p
	_ = this

	localctx = NewModule_keywordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, SystemVerilogParserRULE_module_keyword)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1427)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SystemVerilogParserKMACROMODULE || _la == SystemVerilogParserKMODULE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IInterface_declarationContext is an interface to support dynamic dispatch.
type IInterface_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterface_declarationContext differentiates from other interfaces.
	IsInterface_declarationContext()
}

type Interface_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterface_declarationContext() *Interface_declarationContext {
	var p = new(Interface_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_interface_declaration
	return p
}

func (*Interface_declarationContext) IsInterface_declarationContext() {}

func NewInterface_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Interface_declarationContext {
	var p = new(Interface_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_interface_declaration

	return p
}

func (s *Interface_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Interface_declarationContext) Interface_nonansi_header() IInterface_nonansi_headerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_nonansi_headerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterface_nonansi_headerContext)
}

func (s *Interface_declarationContext) KENDINTERFACE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKENDINTERFACE, 0)
}

func (s *Interface_declarationContext) Timeunits_declaration() ITimeunits_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITimeunits_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITimeunits_declarationContext)
}

func (s *Interface_declarationContext) AllInterface_item() []IInterface_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInterface_itemContext)(nil)).Elem())
	var tst = make([]IInterface_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInterface_itemContext)
		}
	}

	return tst
}

func (s *Interface_declarationContext) Interface_item(i int) IInterface_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInterface_itemContext)
}

func (s *Interface_declarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOLON, 0)
}

func (s *Interface_declarationContext) AllInterface_identifier() []IInterface_identifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInterface_identifierContext)(nil)).Elem())
	var tst = make([]IInterface_identifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInterface_identifierContext)
		}
	}

	return tst
}

func (s *Interface_declarationContext) Interface_identifier(i int) IInterface_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_identifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInterface_identifierContext)
}

func (s *Interface_declarationContext) Interface_ansi_header() IInterface_ansi_headerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_ansi_headerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterface_ansi_headerContext)
}

func (s *Interface_declarationContext) AllNon_port_interface_item() []INon_port_interface_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INon_port_interface_itemContext)(nil)).Elem())
	var tst = make([]INon_port_interface_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INon_port_interface_itemContext)
		}
	}

	return tst
}

func (s *Interface_declarationContext) Non_port_interface_item(i int) INon_port_interface_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INon_port_interface_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INon_port_interface_itemContext)
}

func (s *Interface_declarationContext) KINTERFACE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKINTERFACE, 0)
}

func (s *Interface_declarationContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Interface_declarationContext) DOTSTAR() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserDOTSTAR, 0)
}

func (s *Interface_declarationContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Interface_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Interface_declarationContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Interface_declarationContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Interface_declarationContext) KEXTERN() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKEXTERN, 0)
}

func (s *Interface_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Interface_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Interface_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterInterface_declaration(s)
	}
}

func (s *Interface_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitInterface_declaration(s)
	}
}

func (p *SystemVerilogParser) Interface_declaration() (localctx IInterface_declarationContext) {
	this := p
	_ = this

	localctx = NewInterface_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, SystemVerilogParserRULE_interface_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1490)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 43, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1429)
			p.Interface_nonansi_header()
		}
		p.SetState(1431)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 32, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1430)
				p.Timeunits_declaration()
			}

		}
		p.SetState(1436)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SystemVerilogParserDERROR)|(1<<SystemVerilogParserDFATAL)|(1<<SystemVerilogParserDINFO)|(1<<SystemVerilogParserDUNIT)|(1<<SystemVerilogParserDWARNING)|(1<<SystemVerilogParserLPS))) != 0) || _la == SystemVerilogParserSEMI || _la == SystemVerilogParserLB || (((_la-94)&-(0x1f+1)) == 0 && ((1<<uint((_la-94)))&((1<<(SystemVerilogParserKALIAS-94))|(1<<(SystemVerilogParserKALWAYS-94))|(1<<(SystemVerilogParserKALWAYS_COMB-94))|(1<<(SystemVerilogParserKALWAYS_FF-94))|(1<<(SystemVerilogParserKALWAYS_LATCH-94))|(1<<(SystemVerilogParserKASSERT-94))|(1<<(SystemVerilogParserKASSIGN-94))|(1<<(SystemVerilogParserKASSUME-94))|(1<<(SystemVerilogParserKAUTOMATIC-94))|(1<<(SystemVerilogParserKBIND-94))|(1<<(SystemVerilogParserKBIT-94))|(1<<(SystemVerilogParserKBYTE-94))|(1<<(SystemVerilogParserKCASE-94))|(1<<(SystemVerilogParserKCHANDLE-94))|(1<<(SystemVerilogParserKCHECKER-94))|(1<<(SystemVerilogParserKCLASS-94))|(1<<(SystemVerilogParserKCLOCKING-94))|(1<<(SystemVerilogParserKCONST-94)))) != 0) || (((_la-126)&-(0x1f+1)) == 0 && ((1<<uint((_la-126)))&((1<<(SystemVerilogParserKCONSTRAINT-126))|(1<<(SystemVerilogParserKCOVER-126))|(1<<(SystemVerilogParserKCOVERGROUP-126))|(1<<(SystemVerilogParserKDEFAULT-126)))) != 0) || (((_la-159)&-(0x1f+1)) == 0 && ((1<<uint((_la-159)))&((1<<(SystemVerilogParserKENUM-159))|(1<<(SystemVerilogParserKEVENT-159))|(1<<(SystemVerilogParserKEXPORT-159))|(1<<(SystemVerilogParserKEXTERN-159))|(1<<(SystemVerilogParserKFINAL-159))|(1<<(SystemVerilogParserKFOR-159))|(1<<(SystemVerilogParserKFUNCTION-159))|(1<<(SystemVerilogParserKGENERATE-159))|(1<<(SystemVerilogParserKGENVAR-159))|(1<<(SystemVerilogParserKGLOBAL-159))|(1<<(SystemVerilogParserKIF-159))|(1<<(SystemVerilogParserKIMPORT-159))|(1<<(SystemVerilogParserKINITIAL-159)))) != 0) || (((_la-191)&-(0x1f+1)) == 0 && ((1<<uint((_la-191)))&((1<<(SystemVerilogParserKINOUT-191))|(1<<(SystemVerilogParserKINPUT-191))|(1<<(SystemVerilogParserKINT-191))|(1<<(SystemVerilogParserKINTEGER-191))|(1<<(SystemVerilogParserKINTERCONNECT-191))|(1<<(SystemVerilogParserKINTERFACE-191))|(1<<(SystemVerilogParserKLET-191))|(1<<(SystemVerilogParserKLOCALPARAM-191))|(1<<(SystemVerilogParserKLOGIC-191))|(1<<(SystemVerilogParserKLONGINT-191))|(1<<(SystemVerilogParserKMODPORT-191))|(1<<(SystemVerilogParserKNETTYPE-191)))) != 0) || (((_la-231)&-(0x1f+1)) == 0 && ((1<<uint((_la-231)))&((1<<(SystemVerilogParserKOUTPUT-231))|(1<<(SystemVerilogParserKPARAMETER-231))|(1<<(SystemVerilogParserKPROGRAM-231))|(1<<(SystemVerilogParserKPROPERTY-231))|(1<<(SystemVerilogParserKREAL-231))|(1<<(SystemVerilogParserKREALTIME-231))|(1<<(SystemVerilogParserKREF-231))|(1<<(SystemVerilogParserKREG-231))|(1<<(SystemVerilogParserKRESTRICT-231)))) != 0) || (((_la-275)&-(0x1f+1)) == 0 && ((1<<uint((_la-275)))&((1<<(SystemVerilogParserKSEQUENCE-275))|(1<<(SystemVerilogParserKSHORTINT-275))|(1<<(SystemVerilogParserKSHORTREAL-275))|(1<<(SystemVerilogParserKSIGNED-275))|(1<<(SystemVerilogParserKSTATIC-275))|(1<<(SystemVerilogParserKSTRING-275))|(1<<(SystemVerilogParserKSTRUCT-275))|(1<<(SystemVerilogParserKSUPPLY0-275))|(1<<(SystemVerilogParserKSUPPLY1-275))|(1<<(SystemVerilogParserKTASK-275))|(1<<(SystemVerilogParserKTIME-275))|(1<<(SystemVerilogParserKTIMEPRECISION-275))|(1<<(SystemVerilogParserKTIMEUNIT-275)))) != 0) || (((_la-307)&-(0x1f+1)) == 0 && ((1<<uint((_la-307)))&((1<<(SystemVerilogParserKTRI-307))|(1<<(SystemVerilogParserKTRI0-307))|(1<<(SystemVerilogParserKTRI1-307))|(1<<(SystemVerilogParserKTRIAND-307))|(1<<(SystemVerilogParserKTRIOR-307))|(1<<(SystemVerilogParserKTRIREG-307))|(1<<(SystemVerilogParserKTYPE-307))|(1<<(SystemVerilogParserKTYPEDEF-307))|(1<<(SystemVerilogParserKUNION-307))|(1<<(SystemVerilogParserKUNSIGNED-307))|(1<<(SystemVerilogParserKUWIRE-307))|(1<<(SystemVerilogParserKVAR-307))|(1<<(SystemVerilogParserKVIRTUAL-307))|(1<<(SystemVerilogParserKWAND-307))|(1<<(SystemVerilogParserKWIRE-307)))) != 0) || _la == SystemVerilogParserKWOR || _la == SystemVerilogParserSIMPLE_IDENTIFIER {
			{
				p.SetState(1433)
				p.Interface_item()
			}

			p.SetState(1438)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1439)
			p.Match(SystemVerilogParserKENDINTERFACE)
		}
		p.SetState(1442)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserCOLON {
			{
				p.SetState(1440)
				p.Match(SystemVerilogParserCOLON)
			}
			{
				p.SetState(1441)
				p.Interface_identifier()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1444)
			p.Interface_ansi_header()
		}
		p.SetState(1446)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 35, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1445)
				p.Timeunits_declaration()
			}

		}
		p.SetState(1451)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SystemVerilogParserDERROR)|(1<<SystemVerilogParserDFATAL)|(1<<SystemVerilogParserDINFO)|(1<<SystemVerilogParserDUNIT)|(1<<SystemVerilogParserDWARNING)|(1<<SystemVerilogParserLPS))) != 0) || _la == SystemVerilogParserSEMI || _la == SystemVerilogParserLB || (((_la-94)&-(0x1f+1)) == 0 && ((1<<uint((_la-94)))&((1<<(SystemVerilogParserKALIAS-94))|(1<<(SystemVerilogParserKALWAYS-94))|(1<<(SystemVerilogParserKALWAYS_COMB-94))|(1<<(SystemVerilogParserKALWAYS_FF-94))|(1<<(SystemVerilogParserKALWAYS_LATCH-94))|(1<<(SystemVerilogParserKASSERT-94))|(1<<(SystemVerilogParserKASSIGN-94))|(1<<(SystemVerilogParserKASSUME-94))|(1<<(SystemVerilogParserKAUTOMATIC-94))|(1<<(SystemVerilogParserKBIND-94))|(1<<(SystemVerilogParserKBIT-94))|(1<<(SystemVerilogParserKBYTE-94))|(1<<(SystemVerilogParserKCASE-94))|(1<<(SystemVerilogParserKCHANDLE-94))|(1<<(SystemVerilogParserKCHECKER-94))|(1<<(SystemVerilogParserKCLASS-94))|(1<<(SystemVerilogParserKCLOCKING-94))|(1<<(SystemVerilogParserKCONST-94)))) != 0) || (((_la-126)&-(0x1f+1)) == 0 && ((1<<uint((_la-126)))&((1<<(SystemVerilogParserKCONSTRAINT-126))|(1<<(SystemVerilogParserKCOVER-126))|(1<<(SystemVerilogParserKCOVERGROUP-126))|(1<<(SystemVerilogParserKDEFAULT-126)))) != 0) || (((_la-159)&-(0x1f+1)) == 0 && ((1<<uint((_la-159)))&((1<<(SystemVerilogParserKENUM-159))|(1<<(SystemVerilogParserKEVENT-159))|(1<<(SystemVerilogParserKEXPORT-159))|(1<<(SystemVerilogParserKEXTERN-159))|(1<<(SystemVerilogParserKFINAL-159))|(1<<(SystemVerilogParserKFOR-159))|(1<<(SystemVerilogParserKFUNCTION-159))|(1<<(SystemVerilogParserKGENERATE-159))|(1<<(SystemVerilogParserKGENVAR-159))|(1<<(SystemVerilogParserKGLOBAL-159))|(1<<(SystemVerilogParserKIF-159))|(1<<(SystemVerilogParserKIMPORT-159))|(1<<(SystemVerilogParserKINITIAL-159)))) != 0) || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SystemVerilogParserKINT-195))|(1<<(SystemVerilogParserKINTEGER-195))|(1<<(SystemVerilogParserKINTERCONNECT-195))|(1<<(SystemVerilogParserKINTERFACE-195))|(1<<(SystemVerilogParserKLET-195))|(1<<(SystemVerilogParserKLOCALPARAM-195))|(1<<(SystemVerilogParserKLOGIC-195))|(1<<(SystemVerilogParserKLONGINT-195))|(1<<(SystemVerilogParserKMODPORT-195))|(1<<(SystemVerilogParserKNETTYPE-195)))) != 0) || (((_la-234)&-(0x1f+1)) == 0 && ((1<<uint((_la-234)))&((1<<(SystemVerilogParserKPARAMETER-234))|(1<<(SystemVerilogParserKPROGRAM-234))|(1<<(SystemVerilogParserKPROPERTY-234))|(1<<(SystemVerilogParserKREAL-234))|(1<<(SystemVerilogParserKREALTIME-234))|(1<<(SystemVerilogParserKREG-234))|(1<<(SystemVerilogParserKRESTRICT-234)))) != 0) || (((_la-275)&-(0x1f+1)) == 0 && ((1<<uint((_la-275)))&((1<<(SystemVerilogParserKSEQUENCE-275))|(1<<(SystemVerilogParserKSHORTINT-275))|(1<<(SystemVerilogParserKSHORTREAL-275))|(1<<(SystemVerilogParserKSIGNED-275))|(1<<(SystemVerilogParserKSTATIC-275))|(1<<(SystemVerilogParserKSTRING-275))|(1<<(SystemVerilogParserKSTRUCT-275))|(1<<(SystemVerilogParserKSUPPLY0-275))|(1<<(SystemVerilogParserKSUPPLY1-275))|(1<<(SystemVerilogParserKTASK-275))|(1<<(SystemVerilogParserKTIME-275))|(1<<(SystemVerilogParserKTIMEPRECISION-275))|(1<<(SystemVerilogParserKTIMEUNIT-275)))) != 0) || (((_la-307)&-(0x1f+1)) == 0 && ((1<<uint((_la-307)))&((1<<(SystemVerilogParserKTRI-307))|(1<<(SystemVerilogParserKTRI0-307))|(1<<(SystemVerilogParserKTRI1-307))|(1<<(SystemVerilogParserKTRIAND-307))|(1<<(SystemVerilogParserKTRIOR-307))|(1<<(SystemVerilogParserKTRIREG-307))|(1<<(SystemVerilogParserKTYPE-307))|(1<<(SystemVerilogParserKTYPEDEF-307))|(1<<(SystemVerilogParserKUNION-307))|(1<<(SystemVerilogParserKUNSIGNED-307))|(1<<(SystemVerilogParserKUWIRE-307))|(1<<(SystemVerilogParserKVAR-307))|(1<<(SystemVerilogParserKVIRTUAL-307))|(1<<(SystemVerilogParserKWAND-307))|(1<<(SystemVerilogParserKWIRE-307)))) != 0) || _la == SystemVerilogParserKWOR || _la == SystemVerilogParserSIMPLE_IDENTIFIER {
			{
				p.SetState(1448)
				p.Non_port_interface_item()
			}

			p.SetState(1453)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1454)
			p.Match(SystemVerilogParserKENDINTERFACE)
		}
		p.SetState(1457)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserCOLON {
			{
				p.SetState(1455)
				p.Match(SystemVerilogParserCOLON)
			}
			{
				p.SetState(1456)
				p.Interface_identifier()
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(1462)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserLPS {
			{
				p.SetState(1459)
				p.Attribute_instance()
			}

			p.SetState(1464)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1465)
			p.Match(SystemVerilogParserKINTERFACE)
		}
		{
			p.SetState(1466)
			p.Interface_identifier()
		}
		{
			p.SetState(1467)
			p.Match(SystemVerilogParserLP)
		}
		{
			p.SetState(1468)
			p.Match(SystemVerilogParserDOTSTAR)
		}
		{
			p.SetState(1469)
			p.Match(SystemVerilogParserRP)
		}
		{
			p.SetState(1470)
			p.Match(SystemVerilogParserSEMI)
		}
		p.SetState(1472)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 39, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1471)
				p.Timeunits_declaration()
			}

		}
		p.SetState(1477)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SystemVerilogParserDERROR)|(1<<SystemVerilogParserDFATAL)|(1<<SystemVerilogParserDINFO)|(1<<SystemVerilogParserDUNIT)|(1<<SystemVerilogParserDWARNING)|(1<<SystemVerilogParserLPS))) != 0) || _la == SystemVerilogParserSEMI || _la == SystemVerilogParserLB || (((_la-94)&-(0x1f+1)) == 0 && ((1<<uint((_la-94)))&((1<<(SystemVerilogParserKALIAS-94))|(1<<(SystemVerilogParserKALWAYS-94))|(1<<(SystemVerilogParserKALWAYS_COMB-94))|(1<<(SystemVerilogParserKALWAYS_FF-94))|(1<<(SystemVerilogParserKALWAYS_LATCH-94))|(1<<(SystemVerilogParserKASSERT-94))|(1<<(SystemVerilogParserKASSIGN-94))|(1<<(SystemVerilogParserKASSUME-94))|(1<<(SystemVerilogParserKAUTOMATIC-94))|(1<<(SystemVerilogParserKBIND-94))|(1<<(SystemVerilogParserKBIT-94))|(1<<(SystemVerilogParserKBYTE-94))|(1<<(SystemVerilogParserKCASE-94))|(1<<(SystemVerilogParserKCHANDLE-94))|(1<<(SystemVerilogParserKCHECKER-94))|(1<<(SystemVerilogParserKCLASS-94))|(1<<(SystemVerilogParserKCLOCKING-94))|(1<<(SystemVerilogParserKCONST-94)))) != 0) || (((_la-126)&-(0x1f+1)) == 0 && ((1<<uint((_la-126)))&((1<<(SystemVerilogParserKCONSTRAINT-126))|(1<<(SystemVerilogParserKCOVER-126))|(1<<(SystemVerilogParserKCOVERGROUP-126))|(1<<(SystemVerilogParserKDEFAULT-126)))) != 0) || (((_la-159)&-(0x1f+1)) == 0 && ((1<<uint((_la-159)))&((1<<(SystemVerilogParserKENUM-159))|(1<<(SystemVerilogParserKEVENT-159))|(1<<(SystemVerilogParserKEXPORT-159))|(1<<(SystemVerilogParserKEXTERN-159))|(1<<(SystemVerilogParserKFINAL-159))|(1<<(SystemVerilogParserKFOR-159))|(1<<(SystemVerilogParserKFUNCTION-159))|(1<<(SystemVerilogParserKGENERATE-159))|(1<<(SystemVerilogParserKGENVAR-159))|(1<<(SystemVerilogParserKGLOBAL-159))|(1<<(SystemVerilogParserKIF-159))|(1<<(SystemVerilogParserKIMPORT-159))|(1<<(SystemVerilogParserKINITIAL-159)))) != 0) || (((_la-191)&-(0x1f+1)) == 0 && ((1<<uint((_la-191)))&((1<<(SystemVerilogParserKINOUT-191))|(1<<(SystemVerilogParserKINPUT-191))|(1<<(SystemVerilogParserKINT-191))|(1<<(SystemVerilogParserKINTEGER-191))|(1<<(SystemVerilogParserKINTERCONNECT-191))|(1<<(SystemVerilogParserKINTERFACE-191))|(1<<(SystemVerilogParserKLET-191))|(1<<(SystemVerilogParserKLOCALPARAM-191))|(1<<(SystemVerilogParserKLOGIC-191))|(1<<(SystemVerilogParserKLONGINT-191))|(1<<(SystemVerilogParserKMODPORT-191))|(1<<(SystemVerilogParserKNETTYPE-191)))) != 0) || (((_la-231)&-(0x1f+1)) == 0 && ((1<<uint((_la-231)))&((1<<(SystemVerilogParserKOUTPUT-231))|(1<<(SystemVerilogParserKPARAMETER-231))|(1<<(SystemVerilogParserKPROGRAM-231))|(1<<(SystemVerilogParserKPROPERTY-231))|(1<<(SystemVerilogParserKREAL-231))|(1<<(SystemVerilogParserKREALTIME-231))|(1<<(SystemVerilogParserKREF-231))|(1<<(SystemVerilogParserKREG-231))|(1<<(SystemVerilogParserKRESTRICT-231)))) != 0) || (((_la-275)&-(0x1f+1)) == 0 && ((1<<uint((_la-275)))&((1<<(SystemVerilogParserKSEQUENCE-275))|(1<<(SystemVerilogParserKSHORTINT-275))|(1<<(SystemVerilogParserKSHORTREAL-275))|(1<<(SystemVerilogParserKSIGNED-275))|(1<<(SystemVerilogParserKSTATIC-275))|(1<<(SystemVerilogParserKSTRING-275))|(1<<(SystemVerilogParserKSTRUCT-275))|(1<<(SystemVerilogParserKSUPPLY0-275))|(1<<(SystemVerilogParserKSUPPLY1-275))|(1<<(SystemVerilogParserKTASK-275))|(1<<(SystemVerilogParserKTIME-275))|(1<<(SystemVerilogParserKTIMEPRECISION-275))|(1<<(SystemVerilogParserKTIMEUNIT-275)))) != 0) || (((_la-307)&-(0x1f+1)) == 0 && ((1<<uint((_la-307)))&((1<<(SystemVerilogParserKTRI-307))|(1<<(SystemVerilogParserKTRI0-307))|(1<<(SystemVerilogParserKTRI1-307))|(1<<(SystemVerilogParserKTRIAND-307))|(1<<(SystemVerilogParserKTRIOR-307))|(1<<(SystemVerilogParserKTRIREG-307))|(1<<(SystemVerilogParserKTYPE-307))|(1<<(SystemVerilogParserKTYPEDEF-307))|(1<<(SystemVerilogParserKUNION-307))|(1<<(SystemVerilogParserKUNSIGNED-307))|(1<<(SystemVerilogParserKUWIRE-307))|(1<<(SystemVerilogParserKVAR-307))|(1<<(SystemVerilogParserKVIRTUAL-307))|(1<<(SystemVerilogParserKWAND-307))|(1<<(SystemVerilogParserKWIRE-307)))) != 0) || _la == SystemVerilogParserKWOR || _la == SystemVerilogParserSIMPLE_IDENTIFIER {
			{
				p.SetState(1474)
				p.Interface_item()
			}

			p.SetState(1479)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1480)
			p.Match(SystemVerilogParserKENDINTERFACE)
		}
		p.SetState(1483)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserCOLON {
			{
				p.SetState(1481)
				p.Match(SystemVerilogParserCOLON)
			}
			{
				p.SetState(1482)
				p.Interface_identifier()
			}

		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1485)
			p.Match(SystemVerilogParserKEXTERN)
		}
		p.SetState(1488)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 42, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1486)
				p.Interface_nonansi_header()
			}

		case 2:
			{
				p.SetState(1487)
				p.Interface_ansi_header()
			}

		}

	}

	return localctx
}

// IInterface_nonansi_headerContext is an interface to support dynamic dispatch.
type IInterface_nonansi_headerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterface_nonansi_headerContext differentiates from other interfaces.
	IsInterface_nonansi_headerContext()
}

type Interface_nonansi_headerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterface_nonansi_headerContext() *Interface_nonansi_headerContext {
	var p = new(Interface_nonansi_headerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_interface_nonansi_header
	return p
}

func (*Interface_nonansi_headerContext) IsInterface_nonansi_headerContext() {}

func NewInterface_nonansi_headerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Interface_nonansi_headerContext {
	var p = new(Interface_nonansi_headerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_interface_nonansi_header

	return p
}

func (s *Interface_nonansi_headerContext) GetParser() antlr.Parser { return s.parser }

func (s *Interface_nonansi_headerContext) KINTERFACE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKINTERFACE, 0)
}

func (s *Interface_nonansi_headerContext) Interface_identifier() IInterface_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterface_identifierContext)
}

func (s *Interface_nonansi_headerContext) List_of_ports() IList_of_portsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_portsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_portsContext)
}

func (s *Interface_nonansi_headerContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Interface_nonansi_headerContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Interface_nonansi_headerContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Interface_nonansi_headerContext) Lifetime() ILifetimeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILifetimeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILifetimeContext)
}

func (s *Interface_nonansi_headerContext) AllPackage_import_declaration() []IPackage_import_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPackage_import_declarationContext)(nil)).Elem())
	var tst = make([]IPackage_import_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPackage_import_declarationContext)
		}
	}

	return tst
}

func (s *Interface_nonansi_headerContext) Package_import_declaration(i int) IPackage_import_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackage_import_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPackage_import_declarationContext)
}

func (s *Interface_nonansi_headerContext) Parameter_port_list() IParameter_port_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_port_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_port_listContext)
}

func (s *Interface_nonansi_headerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Interface_nonansi_headerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Interface_nonansi_headerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterInterface_nonansi_header(s)
	}
}

func (s *Interface_nonansi_headerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitInterface_nonansi_header(s)
	}
}

func (p *SystemVerilogParser) Interface_nonansi_header() (localctx IInterface_nonansi_headerContext) {
	this := p
	_ = this

	localctx = NewInterface_nonansi_headerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, SystemVerilogParserRULE_interface_nonansi_header)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1495)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserLPS {
		{
			p.SetState(1492)
			p.Attribute_instance()
		}

		p.SetState(1497)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1498)
		p.Match(SystemVerilogParserKINTERFACE)
	}
	p.SetState(1500)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserKAUTOMATIC || _la == SystemVerilogParserKSTATIC {
		{
			p.SetState(1499)
			p.Lifetime()
		}

	}
	{
		p.SetState(1502)
		p.Interface_identifier()
	}
	p.SetState(1506)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserKIMPORT {
		{
			p.SetState(1503)
			p.Package_import_declaration()
		}

		p.SetState(1508)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1510)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserP {
		{
			p.SetState(1509)
			p.Parameter_port_list()
		}

	}
	{
		p.SetState(1512)
		p.List_of_ports()
	}
	{
		p.SetState(1513)
		p.Match(SystemVerilogParserSEMI)
	}

	return localctx
}

// IInterface_ansi_headerContext is an interface to support dynamic dispatch.
type IInterface_ansi_headerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterface_ansi_headerContext differentiates from other interfaces.
	IsInterface_ansi_headerContext()
}

type Interface_ansi_headerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterface_ansi_headerContext() *Interface_ansi_headerContext {
	var p = new(Interface_ansi_headerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_interface_ansi_header
	return p
}

func (*Interface_ansi_headerContext) IsInterface_ansi_headerContext() {}

func NewInterface_ansi_headerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Interface_ansi_headerContext {
	var p = new(Interface_ansi_headerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_interface_ansi_header

	return p
}

func (s *Interface_ansi_headerContext) GetParser() antlr.Parser { return s.parser }

func (s *Interface_ansi_headerContext) KINTERFACE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKINTERFACE, 0)
}

func (s *Interface_ansi_headerContext) Interface_identifier() IInterface_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterface_identifierContext)
}

func (s *Interface_ansi_headerContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Interface_ansi_headerContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Interface_ansi_headerContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Interface_ansi_headerContext) Lifetime() ILifetimeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILifetimeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILifetimeContext)
}

func (s *Interface_ansi_headerContext) AllPackage_import_declaration() []IPackage_import_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPackage_import_declarationContext)(nil)).Elem())
	var tst = make([]IPackage_import_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPackage_import_declarationContext)
		}
	}

	return tst
}

func (s *Interface_ansi_headerContext) Package_import_declaration(i int) IPackage_import_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackage_import_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPackage_import_declarationContext)
}

func (s *Interface_ansi_headerContext) Parameter_port_list() IParameter_port_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_port_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_port_listContext)
}

func (s *Interface_ansi_headerContext) List_of_port_declarations() IList_of_port_declarationsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_port_declarationsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_port_declarationsContext)
}

func (s *Interface_ansi_headerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Interface_ansi_headerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Interface_ansi_headerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterInterface_ansi_header(s)
	}
}

func (s *Interface_ansi_headerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitInterface_ansi_header(s)
	}
}

func (p *SystemVerilogParser) Interface_ansi_header() (localctx IInterface_ansi_headerContext) {
	this := p
	_ = this

	localctx = NewInterface_ansi_headerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, SystemVerilogParserRULE_interface_ansi_header)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1518)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserLPS {
		{
			p.SetState(1515)
			p.Attribute_instance()
		}

		p.SetState(1520)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1521)
		p.Match(SystemVerilogParserKINTERFACE)
	}
	p.SetState(1523)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserKAUTOMATIC || _la == SystemVerilogParserKSTATIC {
		{
			p.SetState(1522)
			p.Lifetime()
		}

	}
	{
		p.SetState(1525)
		p.Interface_identifier()
	}
	p.SetState(1529)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserKIMPORT {
		{
			p.SetState(1526)
			p.Package_import_declaration()
		}

		p.SetState(1531)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1533)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserP {
		{
			p.SetState(1532)
			p.Parameter_port_list()
		}

	}
	p.SetState(1536)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserLP {
		{
			p.SetState(1535)
			p.List_of_port_declarations()
		}

	}
	{
		p.SetState(1538)
		p.Match(SystemVerilogParserSEMI)
	}

	return localctx
}

// IProgram_declarationContext is an interface to support dynamic dispatch.
type IProgram_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProgram_declarationContext differentiates from other interfaces.
	IsProgram_declarationContext()
}

type Program_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProgram_declarationContext() *Program_declarationContext {
	var p = new(Program_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_program_declaration
	return p
}

func (*Program_declarationContext) IsProgram_declarationContext() {}

func NewProgram_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Program_declarationContext {
	var p = new(Program_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_program_declaration

	return p
}

func (s *Program_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Program_declarationContext) Program_nonansi_header() IProgram_nonansi_headerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProgram_nonansi_headerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProgram_nonansi_headerContext)
}

func (s *Program_declarationContext) KENDPROGRAM() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKENDPROGRAM, 0)
}

func (s *Program_declarationContext) Timeunits_declaration() ITimeunits_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITimeunits_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITimeunits_declarationContext)
}

func (s *Program_declarationContext) AllProgram_item() []IProgram_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IProgram_itemContext)(nil)).Elem())
	var tst = make([]IProgram_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IProgram_itemContext)
		}
	}

	return tst
}

func (s *Program_declarationContext) Program_item(i int) IProgram_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProgram_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IProgram_itemContext)
}

func (s *Program_declarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOLON, 0)
}

func (s *Program_declarationContext) AllProgram_identifier() []IProgram_identifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IProgram_identifierContext)(nil)).Elem())
	var tst = make([]IProgram_identifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IProgram_identifierContext)
		}
	}

	return tst
}

func (s *Program_declarationContext) Program_identifier(i int) IProgram_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProgram_identifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IProgram_identifierContext)
}

func (s *Program_declarationContext) Program_ansi_header() IProgram_ansi_headerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProgram_ansi_headerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProgram_ansi_headerContext)
}

func (s *Program_declarationContext) AllNon_port_program_item() []INon_port_program_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INon_port_program_itemContext)(nil)).Elem())
	var tst = make([]INon_port_program_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INon_port_program_itemContext)
		}
	}

	return tst
}

func (s *Program_declarationContext) Non_port_program_item(i int) INon_port_program_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INon_port_program_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INon_port_program_itemContext)
}

func (s *Program_declarationContext) KPROGRAM() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKPROGRAM, 0)
}

func (s *Program_declarationContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Program_declarationContext) DOTSTAR() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserDOTSTAR, 0)
}

func (s *Program_declarationContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Program_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Program_declarationContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Program_declarationContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Program_declarationContext) KEXTERN() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKEXTERN, 0)
}

func (s *Program_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Program_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Program_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterProgram_declaration(s)
	}
}

func (s *Program_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitProgram_declaration(s)
	}
}

func (p *SystemVerilogParser) Program_declaration() (localctx IProgram_declarationContext) {
	this := p
	_ = this

	localctx = NewProgram_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, SystemVerilogParserRULE_program_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1601)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 64, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1540)
			p.Program_nonansi_header()
		}
		p.SetState(1542)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 53, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1541)
				p.Timeunits_declaration()
			}

		}
		p.SetState(1547)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SystemVerilogParserDERROR)|(1<<SystemVerilogParserDFATAL)|(1<<SystemVerilogParserDINFO)|(1<<SystemVerilogParserDUNIT)|(1<<SystemVerilogParserDWARNING)|(1<<SystemVerilogParserLPS))) != 0) || _la == SystemVerilogParserSEMI || _la == SystemVerilogParserLB || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(SystemVerilogParserKASSERT-100))|(1<<(SystemVerilogParserKASSIGN-100))|(1<<(SystemVerilogParserKASSUME-100))|(1<<(SystemVerilogParserKAUTOMATIC-100))|(1<<(SystemVerilogParserKBIT-100))|(1<<(SystemVerilogParserKBYTE-100))|(1<<(SystemVerilogParserKCASE-100))|(1<<(SystemVerilogParserKCHANDLE-100))|(1<<(SystemVerilogParserKCHECKER-100))|(1<<(SystemVerilogParserKCLASS-100))|(1<<(SystemVerilogParserKCLOCKING-100))|(1<<(SystemVerilogParserKCONST-100))|(1<<(SystemVerilogParserKCONSTRAINT-100))|(1<<(SystemVerilogParserKCOVER-100))|(1<<(SystemVerilogParserKCOVERGROUP-100)))) != 0) || (((_la-134)&-(0x1f+1)) == 0 && ((1<<uint((_la-134)))&((1<<(SystemVerilogParserKDEFAULT-134))|(1<<(SystemVerilogParserKENUM-134))|(1<<(SystemVerilogParserKEVENT-134))|(1<<(SystemVerilogParserKEXPORT-134)))) != 0) || (((_la-166)&-(0x1f+1)) == 0 && ((1<<uint((_la-166)))&((1<<(SystemVerilogParserKFINAL-166))|(1<<(SystemVerilogParserKFOR-166))|(1<<(SystemVerilogParserKFUNCTION-166))|(1<<(SystemVerilogParserKGENERATE-166))|(1<<(SystemVerilogParserKGENVAR-166))|(1<<(SystemVerilogParserKGLOBAL-166))|(1<<(SystemVerilogParserKIF-166))|(1<<(SystemVerilogParserKIMPORT-166))|(1<<(SystemVerilogParserKINITIAL-166))|(1<<(SystemVerilogParserKINOUT-166))|(1<<(SystemVerilogParserKINPUT-166))|(1<<(SystemVerilogParserKINT-166))|(1<<(SystemVerilogParserKINTEGER-166))|(1<<(SystemVerilogParserKINTERCONNECT-166)))) != 0) || (((_la-204)&-(0x1f+1)) == 0 && ((1<<uint((_la-204)))&((1<<(SystemVerilogParserKLET-204))|(1<<(SystemVerilogParserKLOCALPARAM-204))|(1<<(SystemVerilogParserKLOGIC-204))|(1<<(SystemVerilogParserKLONGINT-204))|(1<<(SystemVerilogParserKNETTYPE-204))|(1<<(SystemVerilogParserKOUTPUT-204))|(1<<(SystemVerilogParserKPARAMETER-204)))) != 0) || (((_la-240)&-(0x1f+1)) == 0 && ((1<<uint((_la-240)))&((1<<(SystemVerilogParserKPROPERTY-240))|(1<<(SystemVerilogParserKREAL-240))|(1<<(SystemVerilogParserKREALTIME-240))|(1<<(SystemVerilogParserKREF-240))|(1<<(SystemVerilogParserKREG-240))|(1<<(SystemVerilogParserKRESTRICT-240)))) != 0) || (((_la-275)&-(0x1f+1)) == 0 && ((1<<uint((_la-275)))&((1<<(SystemVerilogParserKSEQUENCE-275))|(1<<(SystemVerilogParserKSHORTINT-275))|(1<<(SystemVerilogParserKSHORTREAL-275))|(1<<(SystemVerilogParserKSIGNED-275))|(1<<(SystemVerilogParserKSTATIC-275))|(1<<(SystemVerilogParserKSTRING-275))|(1<<(SystemVerilogParserKSTRUCT-275))|(1<<(SystemVerilogParserKSUPPLY0-275))|(1<<(SystemVerilogParserKSUPPLY1-275))|(1<<(SystemVerilogParserKTASK-275))|(1<<(SystemVerilogParserKTIME-275))|(1<<(SystemVerilogParserKTIMEPRECISION-275))|(1<<(SystemVerilogParserKTIMEUNIT-275)))) != 0) || (((_la-307)&-(0x1f+1)) == 0 && ((1<<uint((_la-307)))&((1<<(SystemVerilogParserKTRI-307))|(1<<(SystemVerilogParserKTRI0-307))|(1<<(SystemVerilogParserKTRI1-307))|(1<<(SystemVerilogParserKTRIAND-307))|(1<<(SystemVerilogParserKTRIOR-307))|(1<<(SystemVerilogParserKTRIREG-307))|(1<<(SystemVerilogParserKTYPE-307))|(1<<(SystemVerilogParserKTYPEDEF-307))|(1<<(SystemVerilogParserKUNION-307))|(1<<(SystemVerilogParserKUNSIGNED-307))|(1<<(SystemVerilogParserKUWIRE-307))|(1<<(SystemVerilogParserKVAR-307))|(1<<(SystemVerilogParserKVIRTUAL-307))|(1<<(SystemVerilogParserKWAND-307))|(1<<(SystemVerilogParserKWIRE-307)))) != 0) || _la == SystemVerilogParserKWOR || _la == SystemVerilogParserSIMPLE_IDENTIFIER {
			{
				p.SetState(1544)
				p.Program_item()
			}

			p.SetState(1549)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1550)
			p.Match(SystemVerilogParserKENDPROGRAM)
		}
		p.SetState(1553)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserCOLON {
			{
				p.SetState(1551)
				p.Match(SystemVerilogParserCOLON)
			}
			{
				p.SetState(1552)
				p.Program_identifier()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1555)
			p.Program_ansi_header()
		}
		p.SetState(1557)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 56, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1556)
				p.Timeunits_declaration()
			}

		}
		p.SetState(1562)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SystemVerilogParserDERROR)|(1<<SystemVerilogParserDFATAL)|(1<<SystemVerilogParserDINFO)|(1<<SystemVerilogParserDUNIT)|(1<<SystemVerilogParserDWARNING)|(1<<SystemVerilogParserLPS))) != 0) || _la == SystemVerilogParserSEMI || _la == SystemVerilogParserLB || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(SystemVerilogParserKASSERT-100))|(1<<(SystemVerilogParserKASSIGN-100))|(1<<(SystemVerilogParserKASSUME-100))|(1<<(SystemVerilogParserKAUTOMATIC-100))|(1<<(SystemVerilogParserKBIT-100))|(1<<(SystemVerilogParserKBYTE-100))|(1<<(SystemVerilogParserKCASE-100))|(1<<(SystemVerilogParserKCHANDLE-100))|(1<<(SystemVerilogParserKCHECKER-100))|(1<<(SystemVerilogParserKCLASS-100))|(1<<(SystemVerilogParserKCLOCKING-100))|(1<<(SystemVerilogParserKCONST-100))|(1<<(SystemVerilogParserKCONSTRAINT-100))|(1<<(SystemVerilogParserKCOVER-100))|(1<<(SystemVerilogParserKCOVERGROUP-100)))) != 0) || (((_la-134)&-(0x1f+1)) == 0 && ((1<<uint((_la-134)))&((1<<(SystemVerilogParserKDEFAULT-134))|(1<<(SystemVerilogParserKENUM-134))|(1<<(SystemVerilogParserKEVENT-134))|(1<<(SystemVerilogParserKEXPORT-134)))) != 0) || (((_la-166)&-(0x1f+1)) == 0 && ((1<<uint((_la-166)))&((1<<(SystemVerilogParserKFINAL-166))|(1<<(SystemVerilogParserKFOR-166))|(1<<(SystemVerilogParserKFUNCTION-166))|(1<<(SystemVerilogParserKGENERATE-166))|(1<<(SystemVerilogParserKGENVAR-166))|(1<<(SystemVerilogParserKGLOBAL-166))|(1<<(SystemVerilogParserKIF-166))|(1<<(SystemVerilogParserKIMPORT-166))|(1<<(SystemVerilogParserKINITIAL-166))|(1<<(SystemVerilogParserKINT-166))|(1<<(SystemVerilogParserKINTEGER-166))|(1<<(SystemVerilogParserKINTERCONNECT-166)))) != 0) || (((_la-204)&-(0x1f+1)) == 0 && ((1<<uint((_la-204)))&((1<<(SystemVerilogParserKLET-204))|(1<<(SystemVerilogParserKLOCALPARAM-204))|(1<<(SystemVerilogParserKLOGIC-204))|(1<<(SystemVerilogParserKLONGINT-204))|(1<<(SystemVerilogParserKNETTYPE-204))|(1<<(SystemVerilogParserKPARAMETER-204)))) != 0) || (((_la-240)&-(0x1f+1)) == 0 && ((1<<uint((_la-240)))&((1<<(SystemVerilogParserKPROPERTY-240))|(1<<(SystemVerilogParserKREAL-240))|(1<<(SystemVerilogParserKREALTIME-240))|(1<<(SystemVerilogParserKREG-240))|(1<<(SystemVerilogParserKRESTRICT-240)))) != 0) || (((_la-275)&-(0x1f+1)) == 0 && ((1<<uint((_la-275)))&((1<<(SystemVerilogParserKSEQUENCE-275))|(1<<(SystemVerilogParserKSHORTINT-275))|(1<<(SystemVerilogParserKSHORTREAL-275))|(1<<(SystemVerilogParserKSIGNED-275))|(1<<(SystemVerilogParserKSTATIC-275))|(1<<(SystemVerilogParserKSTRING-275))|(1<<(SystemVerilogParserKSTRUCT-275))|(1<<(SystemVerilogParserKSUPPLY0-275))|(1<<(SystemVerilogParserKSUPPLY1-275))|(1<<(SystemVerilogParserKTASK-275))|(1<<(SystemVerilogParserKTIME-275))|(1<<(SystemVerilogParserKTIMEPRECISION-275))|(1<<(SystemVerilogParserKTIMEUNIT-275)))) != 0) || (((_la-307)&-(0x1f+1)) == 0 && ((1<<uint((_la-307)))&((1<<(SystemVerilogParserKTRI-307))|(1<<(SystemVerilogParserKTRI0-307))|(1<<(SystemVerilogParserKTRI1-307))|(1<<(SystemVerilogParserKTRIAND-307))|(1<<(SystemVerilogParserKTRIOR-307))|(1<<(SystemVerilogParserKTRIREG-307))|(1<<(SystemVerilogParserKTYPE-307))|(1<<(SystemVerilogParserKTYPEDEF-307))|(1<<(SystemVerilogParserKUNION-307))|(1<<(SystemVerilogParserKUNSIGNED-307))|(1<<(SystemVerilogParserKUWIRE-307))|(1<<(SystemVerilogParserKVAR-307))|(1<<(SystemVerilogParserKVIRTUAL-307))|(1<<(SystemVerilogParserKWAND-307))|(1<<(SystemVerilogParserKWIRE-307)))) != 0) || _la == SystemVerilogParserKWOR || _la == SystemVerilogParserSIMPLE_IDENTIFIER {
			{
				p.SetState(1559)
				p.Non_port_program_item()
			}

			p.SetState(1564)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1565)
			p.Match(SystemVerilogParserKENDPROGRAM)
		}
		p.SetState(1568)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserCOLON {
			{
				p.SetState(1566)
				p.Match(SystemVerilogParserCOLON)
			}
			{
				p.SetState(1567)
				p.Program_identifier()
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(1573)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserLPS {
			{
				p.SetState(1570)
				p.Attribute_instance()
			}

			p.SetState(1575)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1576)
			p.Match(SystemVerilogParserKPROGRAM)
		}
		{
			p.SetState(1577)
			p.Program_identifier()
		}
		{
			p.SetState(1578)
			p.Match(SystemVerilogParserLP)
		}
		{
			p.SetState(1579)
			p.Match(SystemVerilogParserDOTSTAR)
		}
		{
			p.SetState(1580)
			p.Match(SystemVerilogParserRP)
		}
		{
			p.SetState(1581)
			p.Match(SystemVerilogParserSEMI)
		}
		p.SetState(1583)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 60, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1582)
				p.Timeunits_declaration()
			}

		}
		p.SetState(1588)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SystemVerilogParserDERROR)|(1<<SystemVerilogParserDFATAL)|(1<<SystemVerilogParserDINFO)|(1<<SystemVerilogParserDUNIT)|(1<<SystemVerilogParserDWARNING)|(1<<SystemVerilogParserLPS))) != 0) || _la == SystemVerilogParserSEMI || _la == SystemVerilogParserLB || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(SystemVerilogParserKASSERT-100))|(1<<(SystemVerilogParserKASSIGN-100))|(1<<(SystemVerilogParserKASSUME-100))|(1<<(SystemVerilogParserKAUTOMATIC-100))|(1<<(SystemVerilogParserKBIT-100))|(1<<(SystemVerilogParserKBYTE-100))|(1<<(SystemVerilogParserKCASE-100))|(1<<(SystemVerilogParserKCHANDLE-100))|(1<<(SystemVerilogParserKCHECKER-100))|(1<<(SystemVerilogParserKCLASS-100))|(1<<(SystemVerilogParserKCLOCKING-100))|(1<<(SystemVerilogParserKCONST-100))|(1<<(SystemVerilogParserKCONSTRAINT-100))|(1<<(SystemVerilogParserKCOVER-100))|(1<<(SystemVerilogParserKCOVERGROUP-100)))) != 0) || (((_la-134)&-(0x1f+1)) == 0 && ((1<<uint((_la-134)))&((1<<(SystemVerilogParserKDEFAULT-134))|(1<<(SystemVerilogParserKENUM-134))|(1<<(SystemVerilogParserKEVENT-134))|(1<<(SystemVerilogParserKEXPORT-134)))) != 0) || (((_la-166)&-(0x1f+1)) == 0 && ((1<<uint((_la-166)))&((1<<(SystemVerilogParserKFINAL-166))|(1<<(SystemVerilogParserKFOR-166))|(1<<(SystemVerilogParserKFUNCTION-166))|(1<<(SystemVerilogParserKGENERATE-166))|(1<<(SystemVerilogParserKGENVAR-166))|(1<<(SystemVerilogParserKGLOBAL-166))|(1<<(SystemVerilogParserKIF-166))|(1<<(SystemVerilogParserKIMPORT-166))|(1<<(SystemVerilogParserKINITIAL-166))|(1<<(SystemVerilogParserKINOUT-166))|(1<<(SystemVerilogParserKINPUT-166))|(1<<(SystemVerilogParserKINT-166))|(1<<(SystemVerilogParserKINTEGER-166))|(1<<(SystemVerilogParserKINTERCONNECT-166)))) != 0) || (((_la-204)&-(0x1f+1)) == 0 && ((1<<uint((_la-204)))&((1<<(SystemVerilogParserKLET-204))|(1<<(SystemVerilogParserKLOCALPARAM-204))|(1<<(SystemVerilogParserKLOGIC-204))|(1<<(SystemVerilogParserKLONGINT-204))|(1<<(SystemVerilogParserKNETTYPE-204))|(1<<(SystemVerilogParserKOUTPUT-204))|(1<<(SystemVerilogParserKPARAMETER-204)))) != 0) || (((_la-240)&-(0x1f+1)) == 0 && ((1<<uint((_la-240)))&((1<<(SystemVerilogParserKPROPERTY-240))|(1<<(SystemVerilogParserKREAL-240))|(1<<(SystemVerilogParserKREALTIME-240))|(1<<(SystemVerilogParserKREF-240))|(1<<(SystemVerilogParserKREG-240))|(1<<(SystemVerilogParserKRESTRICT-240)))) != 0) || (((_la-275)&-(0x1f+1)) == 0 && ((1<<uint((_la-275)))&((1<<(SystemVerilogParserKSEQUENCE-275))|(1<<(SystemVerilogParserKSHORTINT-275))|(1<<(SystemVerilogParserKSHORTREAL-275))|(1<<(SystemVerilogParserKSIGNED-275))|(1<<(SystemVerilogParserKSTATIC-275))|(1<<(SystemVerilogParserKSTRING-275))|(1<<(SystemVerilogParserKSTRUCT-275))|(1<<(SystemVerilogParserKSUPPLY0-275))|(1<<(SystemVerilogParserKSUPPLY1-275))|(1<<(SystemVerilogParserKTASK-275))|(1<<(SystemVerilogParserKTIME-275))|(1<<(SystemVerilogParserKTIMEPRECISION-275))|(1<<(SystemVerilogParserKTIMEUNIT-275)))) != 0) || (((_la-307)&-(0x1f+1)) == 0 && ((1<<uint((_la-307)))&((1<<(SystemVerilogParserKTRI-307))|(1<<(SystemVerilogParserKTRI0-307))|(1<<(SystemVerilogParserKTRI1-307))|(1<<(SystemVerilogParserKTRIAND-307))|(1<<(SystemVerilogParserKTRIOR-307))|(1<<(SystemVerilogParserKTRIREG-307))|(1<<(SystemVerilogParserKTYPE-307))|(1<<(SystemVerilogParserKTYPEDEF-307))|(1<<(SystemVerilogParserKUNION-307))|(1<<(SystemVerilogParserKUNSIGNED-307))|(1<<(SystemVerilogParserKUWIRE-307))|(1<<(SystemVerilogParserKVAR-307))|(1<<(SystemVerilogParserKVIRTUAL-307))|(1<<(SystemVerilogParserKWAND-307))|(1<<(SystemVerilogParserKWIRE-307)))) != 0) || _la == SystemVerilogParserKWOR || _la == SystemVerilogParserSIMPLE_IDENTIFIER {
			{
				p.SetState(1585)
				p.Program_item()
			}

			p.SetState(1590)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1591)
			p.Match(SystemVerilogParserKENDPROGRAM)
		}
		p.SetState(1594)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserCOLON {
			{
				p.SetState(1592)
				p.Match(SystemVerilogParserCOLON)
			}
			{
				p.SetState(1593)
				p.Program_identifier()
			}

		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1596)
			p.Match(SystemVerilogParserKEXTERN)
		}
		p.SetState(1599)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 63, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1597)
				p.Program_nonansi_header()
			}

		case 2:
			{
				p.SetState(1598)
				p.Program_ansi_header()
			}

		}

	}

	return localctx
}

// IProgram_nonansi_headerContext is an interface to support dynamic dispatch.
type IProgram_nonansi_headerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProgram_nonansi_headerContext differentiates from other interfaces.
	IsProgram_nonansi_headerContext()
}

type Program_nonansi_headerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProgram_nonansi_headerContext() *Program_nonansi_headerContext {
	var p = new(Program_nonansi_headerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_program_nonansi_header
	return p
}

func (*Program_nonansi_headerContext) IsProgram_nonansi_headerContext() {}

func NewProgram_nonansi_headerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Program_nonansi_headerContext {
	var p = new(Program_nonansi_headerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_program_nonansi_header

	return p
}

func (s *Program_nonansi_headerContext) GetParser() antlr.Parser { return s.parser }

func (s *Program_nonansi_headerContext) KPROGRAM() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKPROGRAM, 0)
}

func (s *Program_nonansi_headerContext) Program_identifier() IProgram_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProgram_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProgram_identifierContext)
}

func (s *Program_nonansi_headerContext) List_of_ports() IList_of_portsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_portsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_portsContext)
}

func (s *Program_nonansi_headerContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Program_nonansi_headerContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Program_nonansi_headerContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Program_nonansi_headerContext) Lifetime() ILifetimeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILifetimeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILifetimeContext)
}

func (s *Program_nonansi_headerContext) AllPackage_import_declaration() []IPackage_import_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPackage_import_declarationContext)(nil)).Elem())
	var tst = make([]IPackage_import_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPackage_import_declarationContext)
		}
	}

	return tst
}

func (s *Program_nonansi_headerContext) Package_import_declaration(i int) IPackage_import_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackage_import_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPackage_import_declarationContext)
}

func (s *Program_nonansi_headerContext) Parameter_port_list() IParameter_port_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_port_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_port_listContext)
}

func (s *Program_nonansi_headerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Program_nonansi_headerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Program_nonansi_headerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterProgram_nonansi_header(s)
	}
}

func (s *Program_nonansi_headerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitProgram_nonansi_header(s)
	}
}

func (p *SystemVerilogParser) Program_nonansi_header() (localctx IProgram_nonansi_headerContext) {
	this := p
	_ = this

	localctx = NewProgram_nonansi_headerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, SystemVerilogParserRULE_program_nonansi_header)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1606)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserLPS {
		{
			p.SetState(1603)
			p.Attribute_instance()
		}

		p.SetState(1608)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1609)
		p.Match(SystemVerilogParserKPROGRAM)
	}
	p.SetState(1611)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserKAUTOMATIC || _la == SystemVerilogParserKSTATIC {
		{
			p.SetState(1610)
			p.Lifetime()
		}

	}
	{
		p.SetState(1613)
		p.Program_identifier()
	}
	p.SetState(1617)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserKIMPORT {
		{
			p.SetState(1614)
			p.Package_import_declaration()
		}

		p.SetState(1619)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1621)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserP {
		{
			p.SetState(1620)
			p.Parameter_port_list()
		}

	}
	{
		p.SetState(1623)
		p.List_of_ports()
	}
	{
		p.SetState(1624)
		p.Match(SystemVerilogParserSEMI)
	}

	return localctx
}

// IProgram_ansi_headerContext is an interface to support dynamic dispatch.
type IProgram_ansi_headerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProgram_ansi_headerContext differentiates from other interfaces.
	IsProgram_ansi_headerContext()
}

type Program_ansi_headerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProgram_ansi_headerContext() *Program_ansi_headerContext {
	var p = new(Program_ansi_headerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_program_ansi_header
	return p
}

func (*Program_ansi_headerContext) IsProgram_ansi_headerContext() {}

func NewProgram_ansi_headerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Program_ansi_headerContext {
	var p = new(Program_ansi_headerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_program_ansi_header

	return p
}

func (s *Program_ansi_headerContext) GetParser() antlr.Parser { return s.parser }

func (s *Program_ansi_headerContext) KPROGRAM() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKPROGRAM, 0)
}

func (s *Program_ansi_headerContext) Program_identifier() IProgram_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProgram_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProgram_identifierContext)
}

func (s *Program_ansi_headerContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Program_ansi_headerContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Program_ansi_headerContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Program_ansi_headerContext) Lifetime() ILifetimeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILifetimeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILifetimeContext)
}

func (s *Program_ansi_headerContext) AllPackage_import_declaration() []IPackage_import_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPackage_import_declarationContext)(nil)).Elem())
	var tst = make([]IPackage_import_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPackage_import_declarationContext)
		}
	}

	return tst
}

func (s *Program_ansi_headerContext) Package_import_declaration(i int) IPackage_import_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackage_import_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPackage_import_declarationContext)
}

func (s *Program_ansi_headerContext) Parameter_port_list() IParameter_port_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_port_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_port_listContext)
}

func (s *Program_ansi_headerContext) List_of_port_declarations() IList_of_port_declarationsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_port_declarationsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_port_declarationsContext)
}

func (s *Program_ansi_headerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Program_ansi_headerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Program_ansi_headerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterProgram_ansi_header(s)
	}
}

func (s *Program_ansi_headerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitProgram_ansi_header(s)
	}
}

func (p *SystemVerilogParser) Program_ansi_header() (localctx IProgram_ansi_headerContext) {
	this := p
	_ = this

	localctx = NewProgram_ansi_headerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, SystemVerilogParserRULE_program_ansi_header)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1629)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserLPS {
		{
			p.SetState(1626)
			p.Attribute_instance()
		}

		p.SetState(1631)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1632)
		p.Match(SystemVerilogParserKPROGRAM)
	}
	p.SetState(1634)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserKAUTOMATIC || _la == SystemVerilogParserKSTATIC {
		{
			p.SetState(1633)
			p.Lifetime()
		}

	}
	{
		p.SetState(1636)
		p.Program_identifier()
	}
	p.SetState(1640)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserKIMPORT {
		{
			p.SetState(1637)
			p.Package_import_declaration()
		}

		p.SetState(1642)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1644)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserP {
		{
			p.SetState(1643)
			p.Parameter_port_list()
		}

	}
	p.SetState(1647)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserLP {
		{
			p.SetState(1646)
			p.List_of_port_declarations()
		}

	}
	{
		p.SetState(1649)
		p.Match(SystemVerilogParserSEMI)
	}

	return localctx
}

// IChecker_declarationContext is an interface to support dynamic dispatch.
type IChecker_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsChecker_declarationContext differentiates from other interfaces.
	IsChecker_declarationContext()
}

type Checker_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChecker_declarationContext() *Checker_declarationContext {
	var p = new(Checker_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_checker_declaration
	return p
}

func (*Checker_declarationContext) IsChecker_declarationContext() {}

func NewChecker_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Checker_declarationContext {
	var p = new(Checker_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_checker_declaration

	return p
}

func (s *Checker_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Checker_declarationContext) KCHECKER() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKCHECKER, 0)
}

func (s *Checker_declarationContext) AllChecker_identifier() []IChecker_identifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IChecker_identifierContext)(nil)).Elem())
	var tst = make([]IChecker_identifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IChecker_identifierContext)
		}
	}

	return tst
}

func (s *Checker_declarationContext) Checker_identifier(i int) IChecker_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IChecker_identifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IChecker_identifierContext)
}

func (s *Checker_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Checker_declarationContext) KENDCHECKER() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKENDCHECKER, 0)
}

func (s *Checker_declarationContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Checker_declarationContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Checker_declarationContext) AllChecker_or_generate_item() []IChecker_or_generate_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IChecker_or_generate_itemContext)(nil)).Elem())
	var tst = make([]IChecker_or_generate_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IChecker_or_generate_itemContext)
		}
	}

	return tst
}

func (s *Checker_declarationContext) Checker_or_generate_item(i int) IChecker_or_generate_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IChecker_or_generate_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IChecker_or_generate_itemContext)
}

func (s *Checker_declarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOLON, 0)
}

func (s *Checker_declarationContext) Checker_port_list() IChecker_port_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IChecker_port_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IChecker_port_listContext)
}

func (s *Checker_declarationContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Checker_declarationContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Checker_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Checker_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Checker_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterChecker_declaration(s)
	}
}

func (s *Checker_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitChecker_declaration(s)
	}
}

func (p *SystemVerilogParser) Checker_declaration() (localctx IChecker_declarationContext) {
	this := p
	_ = this

	localctx = NewChecker_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, SystemVerilogParserRULE_checker_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1651)
		p.Match(SystemVerilogParserKCHECKER)
	}
	{
		p.SetState(1652)
		p.Checker_identifier()
	}
	p.SetState(1658)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserLP {
		{
			p.SetState(1653)
			p.Match(SystemVerilogParserLP)
		}
		p.SetState(1655)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la-19)&-(0x1f+1)) == 0 && ((1<<uint((_la-19)))&((1<<(SystemVerilogParserDUNIT-19))|(1<<(SystemVerilogParserLPS-19))|(1<<(SystemVerilogParserLB-19)))) != 0) || (((_la-109)&-(0x1f+1)) == 0 && ((1<<uint((_la-109)))&((1<<(SystemVerilogParserKBIT-109))|(1<<(SystemVerilogParserKBYTE-109))|(1<<(SystemVerilogParserKCHANDLE-109)))) != 0) || _la == SystemVerilogParserKENUM || _la == SystemVerilogParserKEVENT || (((_la-192)&-(0x1f+1)) == 0 && ((1<<uint((_la-192)))&((1<<(SystemVerilogParserKINPUT-192))|(1<<(SystemVerilogParserKINT-192))|(1<<(SystemVerilogParserKINTEGER-192))|(1<<(SystemVerilogParserKLOGIC-192))|(1<<(SystemVerilogParserKLONGINT-192)))) != 0) || (((_la-231)&-(0x1f+1)) == 0 && ((1<<uint((_la-231)))&((1<<(SystemVerilogParserKOUTPUT-231))|(1<<(SystemVerilogParserKPROPERTY-231))|(1<<(SystemVerilogParserKREAL-231))|(1<<(SystemVerilogParserKREALTIME-231))|(1<<(SystemVerilogParserKREG-231)))) != 0) || (((_la-275)&-(0x1f+1)) == 0 && ((1<<uint((_la-275)))&((1<<(SystemVerilogParserKSEQUENCE-275))|(1<<(SystemVerilogParserKSHORTINT-275))|(1<<(SystemVerilogParserKSHORTREAL-275))|(1<<(SystemVerilogParserKSIGNED-275))|(1<<(SystemVerilogParserKSTRING-275))|(1<<(SystemVerilogParserKSTRUCT-275))|(1<<(SystemVerilogParserKTIME-275)))) != 0) || (((_la-313)&-(0x1f+1)) == 0 && ((1<<uint((_la-313)))&((1<<(SystemVerilogParserKTYPE-313))|(1<<(SystemVerilogParserKUNION-313))|(1<<(SystemVerilogParserKUNSIGNED-313))|(1<<(SystemVerilogParserKUNTYPED-313))|(1<<(SystemVerilogParserKVIRTUAL-313)))) != 0) || _la == SystemVerilogParserSIMPLE_IDENTIFIER {
			{
				p.SetState(1654)
				p.Checker_port_list()
			}

		}
		{
			p.SetState(1657)
			p.Match(SystemVerilogParserRP)
		}

	}
	{
		p.SetState(1660)
		p.Match(SystemVerilogParserSEMI)
	}
	p.SetState(1670)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SystemVerilogParserDERROR)|(1<<SystemVerilogParserDFATAL)|(1<<SystemVerilogParserDINFO)|(1<<SystemVerilogParserDUNIT)|(1<<SystemVerilogParserDWARNING)|(1<<SystemVerilogParserLPS))) != 0) || _la == SystemVerilogParserSEMI || _la == SystemVerilogParserLB || (((_la-95)&-(0x1f+1)) == 0 && ((1<<uint((_la-95)))&((1<<(SystemVerilogParserKALWAYS-95))|(1<<(SystemVerilogParserKALWAYS_COMB-95))|(1<<(SystemVerilogParserKALWAYS_FF-95))|(1<<(SystemVerilogParserKALWAYS_LATCH-95))|(1<<(SystemVerilogParserKASSERT-95))|(1<<(SystemVerilogParserKASSIGN-95))|(1<<(SystemVerilogParserKASSUME-95))|(1<<(SystemVerilogParserKAUTOMATIC-95))|(1<<(SystemVerilogParserKBIT-95))|(1<<(SystemVerilogParserKBYTE-95))|(1<<(SystemVerilogParserKCASE-95))|(1<<(SystemVerilogParserKCHANDLE-95))|(1<<(SystemVerilogParserKCHECKER-95))|(1<<(SystemVerilogParserKCLOCKING-95))|(1<<(SystemVerilogParserKCONST-95)))) != 0) || (((_la-129)&-(0x1f+1)) == 0 && ((1<<uint((_la-129)))&((1<<(SystemVerilogParserKCOVER-129))|(1<<(SystemVerilogParserKCOVERGROUP-129))|(1<<(SystemVerilogParserKDEFAULT-129))|(1<<(SystemVerilogParserKENUM-129))|(1<<(SystemVerilogParserKEVENT-129)))) != 0) || (((_la-166)&-(0x1f+1)) == 0 && ((1<<uint((_la-166)))&((1<<(SystemVerilogParserKFINAL-166))|(1<<(SystemVerilogParserKFOR-166))|(1<<(SystemVerilogParserKFUNCTION-166))|(1<<(SystemVerilogParserKGENERATE-166))|(1<<(SystemVerilogParserKGENVAR-166))|(1<<(SystemVerilogParserKGLOBAL-166))|(1<<(SystemVerilogParserKIF-166))|(1<<(SystemVerilogParserKIMPORT-166))|(1<<(SystemVerilogParserKINITIAL-166))|(1<<(SystemVerilogParserKINT-166))|(1<<(SystemVerilogParserKINTEGER-166)))) != 0) || (((_la-204)&-(0x1f+1)) == 0 && ((1<<uint((_la-204)))&((1<<(SystemVerilogParserKLET-204))|(1<<(SystemVerilogParserKLOGIC-204))|(1<<(SystemVerilogParserKLONGINT-204))|(1<<(SystemVerilogParserKNETTYPE-204)))) != 0) || (((_la-240)&-(0x1f+1)) == 0 && ((1<<uint((_la-240)))&((1<<(SystemVerilogParserKPROPERTY-240))|(1<<(SystemVerilogParserKRAND-240))|(1<<(SystemVerilogParserKREAL-240))|(1<<(SystemVerilogParserKREALTIME-240))|(1<<(SystemVerilogParserKREG-240))|(1<<(SystemVerilogParserKRESTRICT-240)))) != 0) || (((_la-275)&-(0x1f+1)) == 0 && ((1<<uint((_la-275)))&((1<<(SystemVerilogParserKSEQUENCE-275))|(1<<(SystemVerilogParserKSHORTINT-275))|(1<<(SystemVerilogParserKSHORTREAL-275))|(1<<(SystemVerilogParserKSIGNED-275))|(1<<(SystemVerilogParserKSTATIC-275))|(1<<(SystemVerilogParserKSTRING-275))|(1<<(SystemVerilogParserKSTRUCT-275))|(1<<(SystemVerilogParserKTIME-275)))) != 0) || (((_la-313)&-(0x1f+1)) == 0 && ((1<<uint((_la-313)))&((1<<(SystemVerilogParserKTYPE-313))|(1<<(SystemVerilogParserKTYPEDEF-313))|(1<<(SystemVerilogParserKUNION-313))|(1<<(SystemVerilogParserKUNSIGNED-313))|(1<<(SystemVerilogParserKVAR-313))|(1<<(SystemVerilogParserKVIRTUAL-313)))) != 0) || _la == SystemVerilogParserSIMPLE_IDENTIFIER {
		p.SetState(1664)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserLPS {
			{
				p.SetState(1661)
				p.Attribute_instance()
			}

			p.SetState(1666)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1667)
			p.Checker_or_generate_item()
		}

		p.SetState(1672)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1673)
		p.Match(SystemVerilogParserKENDCHECKER)
	}
	p.SetState(1676)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserCOLON {
		{
			p.SetState(1674)
			p.Match(SystemVerilogParserCOLON)
		}
		{
			p.SetState(1675)
			p.Checker_identifier()
		}

	}

	return localctx
}

// IClass_declarationContext is an interface to support dynamic dispatch.
type IClass_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClass_declarationContext differentiates from other interfaces.
	IsClass_declarationContext()
}

type Class_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClass_declarationContext() *Class_declarationContext {
	var p = new(Class_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_class_declaration
	return p
}

func (*Class_declarationContext) IsClass_declarationContext() {}

func NewClass_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Class_declarationContext {
	var p = new(Class_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_class_declaration

	return p
}

func (s *Class_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Class_declarationContext) KCLASS() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKCLASS, 0)
}

func (s *Class_declarationContext) AllClass_identifier() []IClass_identifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IClass_identifierContext)(nil)).Elem())
	var tst = make([]IClass_identifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IClass_identifierContext)
		}
	}

	return tst
}

func (s *Class_declarationContext) Class_identifier(i int) IClass_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_identifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IClass_identifierContext)
}

func (s *Class_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Class_declarationContext) KENDCLASS() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKENDCLASS, 0)
}

func (s *Class_declarationContext) KVIRTUAL() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKVIRTUAL, 0)
}

func (s *Class_declarationContext) Lifetime() ILifetimeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILifetimeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILifetimeContext)
}

func (s *Class_declarationContext) Parameter_port_list() IParameter_port_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_port_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_port_listContext)
}

func (s *Class_declarationContext) KEXTENDS() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKEXTENDS, 0)
}

func (s *Class_declarationContext) Class_type() IClass_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClass_typeContext)
}

func (s *Class_declarationContext) KIMPLEMENTS() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKIMPLEMENTS, 0)
}

func (s *Class_declarationContext) AllInterface_class_type() []IInterface_class_typeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInterface_class_typeContext)(nil)).Elem())
	var tst = make([]IInterface_class_typeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInterface_class_typeContext)
		}
	}

	return tst
}

func (s *Class_declarationContext) Interface_class_type(i int) IInterface_class_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_class_typeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInterface_class_typeContext)
}

func (s *Class_declarationContext) AllClass_item() []IClass_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IClass_itemContext)(nil)).Elem())
	var tst = make([]IClass_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IClass_itemContext)
		}
	}

	return tst
}

func (s *Class_declarationContext) Class_item(i int) IClass_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IClass_itemContext)
}

func (s *Class_declarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOLON, 0)
}

func (s *Class_declarationContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Class_declarationContext) List_of_arguments() IList_of_argumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_argumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_argumentsContext)
}

func (s *Class_declarationContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Class_declarationContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *Class_declarationContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *Class_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Class_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Class_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterClass_declaration(s)
	}
}

func (s *Class_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitClass_declaration(s)
	}
}

func (p *SystemVerilogParser) Class_declaration() (localctx IClass_declarationContext) {
	this := p
	_ = this

	localctx = NewClass_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, SystemVerilogParserRULE_class_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1679)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserKVIRTUAL {
		{
			p.SetState(1678)
			p.Match(SystemVerilogParserKVIRTUAL)
		}

	}
	{
		p.SetState(1681)
		p.Match(SystemVerilogParserKCLASS)
	}
	p.SetState(1683)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserKAUTOMATIC || _la == SystemVerilogParserKSTATIC {
		{
			p.SetState(1682)
			p.Lifetime()
		}

	}
	{
		p.SetState(1685)
		p.Class_identifier()
	}
	p.SetState(1687)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserP {
		{
			p.SetState(1686)
			p.Parameter_port_list()
		}

	}
	p.SetState(1697)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserKEXTENDS {
		{
			p.SetState(1689)
			p.Match(SystemVerilogParserKEXTENDS)
		}
		{
			p.SetState(1690)
			p.Class_type()
		}
		p.SetState(1695)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserLP {
			{
				p.SetState(1691)
				p.Match(SystemVerilogParserLP)
			}
			{
				p.SetState(1692)
				p.List_of_arguments()
			}
			{
				p.SetState(1693)
				p.Match(SystemVerilogParserRP)
			}

		}

	}
	p.SetState(1708)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserKIMPLEMENTS {
		{
			p.SetState(1699)
			p.Match(SystemVerilogParserKIMPLEMENTS)
		}
		{
			p.SetState(1700)
			p.Interface_class_type()
		}
		p.SetState(1705)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserCOMMA {
			{
				p.SetState(1701)
				p.Match(SystemVerilogParserCOMMA)
			}
			{
				p.SetState(1702)
				p.Interface_class_type()
			}

			p.SetState(1707)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(1710)
		p.Match(SystemVerilogParserSEMI)
	}
	p.SetState(1714)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la-19)&-(0x1f+1)) == 0 && ((1<<uint((_la-19)))&((1<<(SystemVerilogParserDUNIT-19))|(1<<(SystemVerilogParserLPS-19))|(1<<(SystemVerilogParserSEMI-19))|(1<<(SystemVerilogParserLB-19)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(SystemVerilogParserKAUTOMATIC-103))|(1<<(SystemVerilogParserKBIT-103))|(1<<(SystemVerilogParserKBYTE-103))|(1<<(SystemVerilogParserKCHANDLE-103))|(1<<(SystemVerilogParserKCLASS-103))|(1<<(SystemVerilogParserKCONST-103))|(1<<(SystemVerilogParserKCONSTRAINT-103))|(1<<(SystemVerilogParserKCOVERGROUP-103)))) != 0) || (((_la-159)&-(0x1f+1)) == 0 && ((1<<uint((_la-159)))&((1<<(SystemVerilogParserKENUM-159))|(1<<(SystemVerilogParserKEVENT-159))|(1<<(SystemVerilogParserKEXTERN-159))|(1<<(SystemVerilogParserKFUNCTION-159))|(1<<(SystemVerilogParserKIMPORT-159)))) != 0) || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SystemVerilogParserKINT-195))|(1<<(SystemVerilogParserKINTEGER-195))|(1<<(SystemVerilogParserKLOCAL-195))|(1<<(SystemVerilogParserKLOCALPARAM-195))|(1<<(SystemVerilogParserKLOGIC-195))|(1<<(SystemVerilogParserKLONGINT-195))|(1<<(SystemVerilogParserKNETTYPE-195)))) != 0) || (((_la-234)&-(0x1f+1)) == 0 && ((1<<uint((_la-234)))&((1<<(SystemVerilogParserKPARAMETER-234))|(1<<(SystemVerilogParserKPROTECTED-234))|(1<<(SystemVerilogParserKPURE-234))|(1<<(SystemVerilogParserKRAND-234))|(1<<(SystemVerilogParserKRANDC-234))|(1<<(SystemVerilogParserKREAL-234))|(1<<(SystemVerilogParserKREALTIME-234))|(1<<(SystemVerilogParserKREG-234)))) != 0) || (((_la-276)&-(0x1f+1)) == 0 && ((1<<uint((_la-276)))&((1<<(SystemVerilogParserKSHORTINT-276))|(1<<(SystemVerilogParserKSHORTREAL-276))|(1<<(SystemVerilogParserKSIGNED-276))|(1<<(SystemVerilogParserKSTATIC-276))|(1<<(SystemVerilogParserKSTRING-276))|(1<<(SystemVerilogParserKSTRUCT-276))|(1<<(SystemVerilogParserKTASK-276))|(1<<(SystemVerilogParserKTIME-276)))) != 0) || (((_la-313)&-(0x1f+1)) == 0 && ((1<<uint((_la-313)))&((1<<(SystemVerilogParserKTYPE-313))|(1<<(SystemVerilogParserKTYPEDEF-313))|(1<<(SystemVerilogParserKUNION-313))|(1<<(SystemVerilogParserKUNSIGNED-313))|(1<<(SystemVerilogParserKVAR-313))|(1<<(SystemVerilogParserKVIRTUAL-313)))) != 0) || _la == SystemVerilogParserSIMPLE_IDENTIFIER {
		{
			p.SetState(1711)
			p.Class_item()
		}

		p.SetState(1716)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1717)
		p.Match(SystemVerilogParserKENDCLASS)
	}
	p.SetState(1720)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserCOLON {
		{
			p.SetState(1718)
			p.Match(SystemVerilogParserCOLON)
		}
		{
			p.SetState(1719)
			p.Class_identifier()
		}

	}

	return localctx
}

// IInterface_class_typeContext is an interface to support dynamic dispatch.
type IInterface_class_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterface_class_typeContext differentiates from other interfaces.
	IsInterface_class_typeContext()
}

type Interface_class_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterface_class_typeContext() *Interface_class_typeContext {
	var p = new(Interface_class_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_interface_class_type
	return p
}

func (*Interface_class_typeContext) IsInterface_class_typeContext() {}

func NewInterface_class_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Interface_class_typeContext {
	var p = new(Interface_class_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_interface_class_type

	return p
}

func (s *Interface_class_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Interface_class_typeContext) Ps_class_identifier() IPs_class_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPs_class_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPs_class_identifierContext)
}

func (s *Interface_class_typeContext) Parameter_value_assignment() IParameter_value_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_value_assignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_value_assignmentContext)
}

func (s *Interface_class_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Interface_class_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Interface_class_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterInterface_class_type(s)
	}
}

func (s *Interface_class_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitInterface_class_type(s)
	}
}

func (p *SystemVerilogParser) Interface_class_type() (localctx IInterface_class_typeContext) {
	this := p
	_ = this

	localctx = NewInterface_class_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, SystemVerilogParserRULE_interface_class_type)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1722)
		p.Ps_class_identifier()
	}
	p.SetState(1724)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserP {
		{
			p.SetState(1723)
			p.Parameter_value_assignment()
		}

	}

	return localctx
}

// IInterface_class_declarationContext is an interface to support dynamic dispatch.
type IInterface_class_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterface_class_declarationContext differentiates from other interfaces.
	IsInterface_class_declarationContext()
}

type Interface_class_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterface_class_declarationContext() *Interface_class_declarationContext {
	var p = new(Interface_class_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_interface_class_declaration
	return p
}

func (*Interface_class_declarationContext) IsInterface_class_declarationContext() {}

func NewInterface_class_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Interface_class_declarationContext {
	var p = new(Interface_class_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_interface_class_declaration

	return p
}

func (s *Interface_class_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Interface_class_declarationContext) KINTERFACE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKINTERFACE, 0)
}

func (s *Interface_class_declarationContext) KCLASS() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKCLASS, 0)
}

func (s *Interface_class_declarationContext) AllClass_identifier() []IClass_identifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IClass_identifierContext)(nil)).Elem())
	var tst = make([]IClass_identifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IClass_identifierContext)
		}
	}

	return tst
}

func (s *Interface_class_declarationContext) Class_identifier(i int) IClass_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_identifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IClass_identifierContext)
}

func (s *Interface_class_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Interface_class_declarationContext) KENDCLASS() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKENDCLASS, 0)
}

func (s *Interface_class_declarationContext) Parameter_port_list() IParameter_port_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_port_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_port_listContext)
}

func (s *Interface_class_declarationContext) KEXTENDS() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKEXTENDS, 0)
}

func (s *Interface_class_declarationContext) AllInterface_class_type() []IInterface_class_typeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInterface_class_typeContext)(nil)).Elem())
	var tst = make([]IInterface_class_typeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInterface_class_typeContext)
		}
	}

	return tst
}

func (s *Interface_class_declarationContext) Interface_class_type(i int) IInterface_class_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_class_typeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInterface_class_typeContext)
}

func (s *Interface_class_declarationContext) AllInterface_class_item() []IInterface_class_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInterface_class_itemContext)(nil)).Elem())
	var tst = make([]IInterface_class_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInterface_class_itemContext)
		}
	}

	return tst
}

func (s *Interface_class_declarationContext) Interface_class_item(i int) IInterface_class_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_class_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInterface_class_itemContext)
}

func (s *Interface_class_declarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOLON, 0)
}

func (s *Interface_class_declarationContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *Interface_class_declarationContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *Interface_class_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Interface_class_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Interface_class_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterInterface_class_declaration(s)
	}
}

func (s *Interface_class_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitInterface_class_declaration(s)
	}
}

func (p *SystemVerilogParser) Interface_class_declaration() (localctx IInterface_class_declarationContext) {
	this := p
	_ = this

	localctx = NewInterface_class_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, SystemVerilogParserRULE_interface_class_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1726)
		p.Match(SystemVerilogParserKINTERFACE)
	}
	{
		p.SetState(1727)
		p.Match(SystemVerilogParserKCLASS)
	}
	{
		p.SetState(1728)
		p.Class_identifier()
	}
	p.SetState(1730)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserP {
		{
			p.SetState(1729)
			p.Parameter_port_list()
		}

	}
	p.SetState(1741)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserKEXTENDS {
		{
			p.SetState(1732)
			p.Match(SystemVerilogParserKEXTENDS)
		}
		{
			p.SetState(1733)
			p.Interface_class_type()
		}
		p.SetState(1738)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserCOMMA {
			{
				p.SetState(1734)
				p.Match(SystemVerilogParserCOMMA)
			}
			{
				p.SetState(1735)
				p.Interface_class_type()
			}

			p.SetState(1740)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(1743)
		p.Match(SystemVerilogParserSEMI)
	}
	p.SetState(1747)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserLPS || _la == SystemVerilogParserSEMI || _la == SystemVerilogParserKLOCALPARAM || _la == SystemVerilogParserKPARAMETER || _la == SystemVerilogParserKPURE || _la == SystemVerilogParserKTYPEDEF {
		{
			p.SetState(1744)
			p.Interface_class_item()
		}

		p.SetState(1749)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1750)
		p.Match(SystemVerilogParserKENDCLASS)
	}
	p.SetState(1753)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserCOLON {
		{
			p.SetState(1751)
			p.Match(SystemVerilogParserCOLON)
		}
		{
			p.SetState(1752)
			p.Class_identifier()
		}

	}

	return localctx
}

// IInterface_class_itemContext is an interface to support dynamic dispatch.
type IInterface_class_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterface_class_itemContext differentiates from other interfaces.
	IsInterface_class_itemContext()
}

type Interface_class_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterface_class_itemContext() *Interface_class_itemContext {
	var p = new(Interface_class_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_interface_class_item
	return p
}

func (*Interface_class_itemContext) IsInterface_class_itemContext() {}

func NewInterface_class_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Interface_class_itemContext {
	var p = new(Interface_class_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_interface_class_item

	return p
}

func (s *Interface_class_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Interface_class_itemContext) Type_declaration() IType_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_declarationContext)
}

func (s *Interface_class_itemContext) Interface_class_method() IInterface_class_methodContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_class_methodContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterface_class_methodContext)
}

func (s *Interface_class_itemContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Interface_class_itemContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Interface_class_itemContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Interface_class_itemContext) Local_parameter_declaration() ILocal_parameter_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILocal_parameter_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILocal_parameter_declarationContext)
}

func (s *Interface_class_itemContext) Parameter_declaration() IParameter_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_declarationContext)
}

func (s *Interface_class_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Interface_class_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Interface_class_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterInterface_class_item(s)
	}
}

func (s *Interface_class_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitInterface_class_item(s)
	}
}

func (p *SystemVerilogParser) Interface_class_item() (localctx IInterface_class_itemContext) {
	this := p
	_ = this

	localctx = NewInterface_class_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, SystemVerilogParserRULE_interface_class_item)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1768)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserKTYPEDEF:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1755)
			p.Type_declaration()
		}

	case SystemVerilogParserLPS, SystemVerilogParserKPURE:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1759)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserLPS {
			{
				p.SetState(1756)
				p.Attribute_instance()
			}

			p.SetState(1761)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1762)
			p.Interface_class_method()
		}

	case SystemVerilogParserSEMI, SystemVerilogParserKLOCALPARAM, SystemVerilogParserKPARAMETER:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(1765)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SystemVerilogParserKLOCALPARAM:
			{
				p.SetState(1763)
				p.Local_parameter_declaration()
			}

		case SystemVerilogParserKPARAMETER:
			{
				p.SetState(1764)
				p.Parameter_declaration()
			}

		case SystemVerilogParserSEMI:

		default:
		}
		{
			p.SetState(1767)
			p.Match(SystemVerilogParserSEMI)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IInterface_class_methodContext is an interface to support dynamic dispatch.
type IInterface_class_methodContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterface_class_methodContext differentiates from other interfaces.
	IsInterface_class_methodContext()
}

type Interface_class_methodContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterface_class_methodContext() *Interface_class_methodContext {
	var p = new(Interface_class_methodContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_interface_class_method
	return p
}

func (*Interface_class_methodContext) IsInterface_class_methodContext() {}

func NewInterface_class_methodContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Interface_class_methodContext {
	var p = new(Interface_class_methodContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_interface_class_method

	return p
}

func (s *Interface_class_methodContext) GetParser() antlr.Parser { return s.parser }

func (s *Interface_class_methodContext) KPURE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKPURE, 0)
}

func (s *Interface_class_methodContext) KVIRTUAL() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKVIRTUAL, 0)
}

func (s *Interface_class_methodContext) Method_prototype() IMethod_prototypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMethod_prototypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMethod_prototypeContext)
}

func (s *Interface_class_methodContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Interface_class_methodContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Interface_class_methodContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Interface_class_methodContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterInterface_class_method(s)
	}
}

func (s *Interface_class_methodContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitInterface_class_method(s)
	}
}

func (p *SystemVerilogParser) Interface_class_method() (localctx IInterface_class_methodContext) {
	this := p
	_ = this

	localctx = NewInterface_class_methodContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, SystemVerilogParserRULE_interface_class_method)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1770)
		p.Match(SystemVerilogParserKPURE)
	}
	{
		p.SetState(1771)
		p.Match(SystemVerilogParserKVIRTUAL)
	}
	{
		p.SetState(1772)
		p.Method_prototype()
	}
	{
		p.SetState(1773)
		p.Match(SystemVerilogParserSEMI)
	}

	return localctx
}

// IPackage_declarationContext is an interface to support dynamic dispatch.
type IPackage_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPackage_declarationContext differentiates from other interfaces.
	IsPackage_declarationContext()
}

type Package_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackage_declarationContext() *Package_declarationContext {
	var p = new(Package_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_package_declaration
	return p
}

func (*Package_declarationContext) IsPackage_declarationContext() {}

func NewPackage_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Package_declarationContext {
	var p = new(Package_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_package_declaration

	return p
}

func (s *Package_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Package_declarationContext) KPACKAGE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKPACKAGE, 0)
}

func (s *Package_declarationContext) AllPackage_identifier() []IPackage_identifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPackage_identifierContext)(nil)).Elem())
	var tst = make([]IPackage_identifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPackage_identifierContext)
		}
	}

	return tst
}

func (s *Package_declarationContext) Package_identifier(i int) IPackage_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackage_identifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPackage_identifierContext)
}

func (s *Package_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Package_declarationContext) KENDPACKAGE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKENDPACKAGE, 0)
}

func (s *Package_declarationContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Package_declarationContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Package_declarationContext) Lifetime() ILifetimeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILifetimeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILifetimeContext)
}

func (s *Package_declarationContext) Timeunits_declaration() ITimeunits_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITimeunits_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITimeunits_declarationContext)
}

func (s *Package_declarationContext) AllPackage_item() []IPackage_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPackage_itemContext)(nil)).Elem())
	var tst = make([]IPackage_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPackage_itemContext)
		}
	}

	return tst
}

func (s *Package_declarationContext) Package_item(i int) IPackage_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackage_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPackage_itemContext)
}

func (s *Package_declarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOLON, 0)
}

func (s *Package_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Package_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Package_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterPackage_declaration(s)
	}
}

func (s *Package_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitPackage_declaration(s)
	}
}

func (p *SystemVerilogParser) Package_declaration() (localctx IPackage_declarationContext) {
	this := p
	_ = this

	localctx = NewPackage_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, SystemVerilogParserRULE_package_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1778)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserLPS {
		{
			p.SetState(1775)
			p.Attribute_instance()
		}

		p.SetState(1780)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1781)
		p.Match(SystemVerilogParserKPACKAGE)
	}
	p.SetState(1783)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserKAUTOMATIC || _la == SystemVerilogParserKSTATIC {
		{
			p.SetState(1782)
			p.Lifetime()
		}

	}
	{
		p.SetState(1785)
		p.Package_identifier()
	}
	{
		p.SetState(1786)
		p.Match(SystemVerilogParserSEMI)
	}
	p.SetState(1788)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 99, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1787)
			p.Timeunits_declaration()
		}

	}
	p.SetState(1799)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la-19)&-(0x1f+1)) == 0 && ((1<<uint((_la-19)))&((1<<(SystemVerilogParserDUNIT-19))|(1<<(SystemVerilogParserLPS-19))|(1<<(SystemVerilogParserSEMI-19))|(1<<(SystemVerilogParserLB-19)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(SystemVerilogParserKAUTOMATIC-103))|(1<<(SystemVerilogParserKBIT-103))|(1<<(SystemVerilogParserKBYTE-103))|(1<<(SystemVerilogParserKCHANDLE-103))|(1<<(SystemVerilogParserKCHECKER-103))|(1<<(SystemVerilogParserKCLASS-103))|(1<<(SystemVerilogParserKCONST-103))|(1<<(SystemVerilogParserKCONSTRAINT-103))|(1<<(SystemVerilogParserKCOVERGROUP-103)))) != 0) || (((_la-159)&-(0x1f+1)) == 0 && ((1<<uint((_la-159)))&((1<<(SystemVerilogParserKENUM-159))|(1<<(SystemVerilogParserKEVENT-159))|(1<<(SystemVerilogParserKEXPORT-159))|(1<<(SystemVerilogParserKFUNCTION-159))|(1<<(SystemVerilogParserKIMPORT-159)))) != 0) || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SystemVerilogParserKINT-195))|(1<<(SystemVerilogParserKINTEGER-195))|(1<<(SystemVerilogParserKINTERCONNECT-195))|(1<<(SystemVerilogParserKLET-195))|(1<<(SystemVerilogParserKLOCALPARAM-195))|(1<<(SystemVerilogParserKLOGIC-195))|(1<<(SystemVerilogParserKLONGINT-195))|(1<<(SystemVerilogParserKNETTYPE-195)))) != 0) || (((_la-234)&-(0x1f+1)) == 0 && ((1<<uint((_la-234)))&((1<<(SystemVerilogParserKPARAMETER-234))|(1<<(SystemVerilogParserKPROGRAM-234))|(1<<(SystemVerilogParserKPROPERTY-234))|(1<<(SystemVerilogParserKREAL-234))|(1<<(SystemVerilogParserKREALTIME-234))|(1<<(SystemVerilogParserKREG-234)))) != 0) || (((_la-275)&-(0x1f+1)) == 0 && ((1<<uint((_la-275)))&((1<<(SystemVerilogParserKSEQUENCE-275))|(1<<(SystemVerilogParserKSHORTINT-275))|(1<<(SystemVerilogParserKSHORTREAL-275))|(1<<(SystemVerilogParserKSIGNED-275))|(1<<(SystemVerilogParserKSTATIC-275))|(1<<(SystemVerilogParserKSTRING-275))|(1<<(SystemVerilogParserKSTRUCT-275))|(1<<(SystemVerilogParserKSUPPLY0-275))|(1<<(SystemVerilogParserKSUPPLY1-275))|(1<<(SystemVerilogParserKTASK-275))|(1<<(SystemVerilogParserKTIME-275))|(1<<(SystemVerilogParserKTIMEPRECISION-275))|(1<<(SystemVerilogParserKTIMEUNIT-275)))) != 0) || (((_la-307)&-(0x1f+1)) == 0 && ((1<<uint((_la-307)))&((1<<(SystemVerilogParserKTRI-307))|(1<<(SystemVerilogParserKTRI0-307))|(1<<(SystemVerilogParserKTRI1-307))|(1<<(SystemVerilogParserKTRIAND-307))|(1<<(SystemVerilogParserKTRIOR-307))|(1<<(SystemVerilogParserKTRIREG-307))|(1<<(SystemVerilogParserKTYPE-307))|(1<<(SystemVerilogParserKTYPEDEF-307))|(1<<(SystemVerilogParserKUNION-307))|(1<<(SystemVerilogParserKUNSIGNED-307))|(1<<(SystemVerilogParserKUWIRE-307))|(1<<(SystemVerilogParserKVAR-307))|(1<<(SystemVerilogParserKVIRTUAL-307))|(1<<(SystemVerilogParserKWAND-307))|(1<<(SystemVerilogParserKWIRE-307)))) != 0) || _la == SystemVerilogParserKWOR || _la == SystemVerilogParserSIMPLE_IDENTIFIER {
		p.SetState(1793)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserLPS {
			{
				p.SetState(1790)
				p.Attribute_instance()
			}

			p.SetState(1795)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1796)
			p.Package_item()
		}

		p.SetState(1801)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1802)
		p.Match(SystemVerilogParserKENDPACKAGE)
	}
	p.SetState(1805)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserCOLON {
		{
			p.SetState(1803)
			p.Match(SystemVerilogParserCOLON)
		}
		{
			p.SetState(1804)
			p.Package_identifier()
		}

	}

	return localctx
}

// ITimeunits_declarationContext is an interface to support dynamic dispatch.
type ITimeunits_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTimeunits_declarationContext differentiates from other interfaces.
	IsTimeunits_declarationContext()
}

type Timeunits_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTimeunits_declarationContext() *Timeunits_declarationContext {
	var p = new(Timeunits_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_timeunits_declaration
	return p
}

func (*Timeunits_declarationContext) IsTimeunits_declarationContext() {}

func NewTimeunits_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Timeunits_declarationContext {
	var p = new(Timeunits_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_timeunits_declaration

	return p
}

func (s *Timeunits_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Timeunits_declarationContext) KTIMEUNIT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKTIMEUNIT, 0)
}

func (s *Timeunits_declarationContext) AllTIME_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserTIME_LITERAL)
}

func (s *Timeunits_declarationContext) TIME_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserTIME_LITERAL, i)
}

func (s *Timeunits_declarationContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserSEMI)
}

func (s *Timeunits_declarationContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, i)
}

func (s *Timeunits_declarationContext) KTIMEPRECISION() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKTIMEPRECISION, 0)
}

func (s *Timeunits_declarationContext) SLASH() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSLASH, 0)
}

func (s *Timeunits_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Timeunits_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Timeunits_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterTimeunits_declaration(s)
	}
}

func (s *Timeunits_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitTimeunits_declaration(s)
	}
}

func (p *SystemVerilogParser) Timeunits_declaration() (localctx ITimeunits_declarationContext) {
	this := p
	_ = this

	localctx = NewTimeunits_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, SystemVerilogParserRULE_timeunits_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1827)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserKTIMEUNIT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1807)
			p.Match(SystemVerilogParserKTIMEUNIT)
		}
		{
			p.SetState(1808)
			p.Match(SystemVerilogParserTIME_LITERAL)
		}
		p.SetState(1816)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 104, p.GetParserRuleContext()) {
		case 1:
			p.SetState(1811)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == SystemVerilogParserSLASH {
				{
					p.SetState(1809)
					p.Match(SystemVerilogParserSLASH)
				}
				{
					p.SetState(1810)
					p.Match(SystemVerilogParserTIME_LITERAL)
				}

			}

		case 2:
			{
				p.SetState(1813)
				p.Match(SystemVerilogParserSEMI)
			}
			{
				p.SetState(1814)
				p.Match(SystemVerilogParserKTIMEPRECISION)
			}
			{
				p.SetState(1815)
				p.Match(SystemVerilogParserTIME_LITERAL)
			}

		}
		{
			p.SetState(1818)
			p.Match(SystemVerilogParserSEMI)
		}

	case SystemVerilogParserKTIMEPRECISION:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1819)
			p.Match(SystemVerilogParserKTIMEPRECISION)
		}
		{
			p.SetState(1820)
			p.Match(SystemVerilogParserTIME_LITERAL)
		}
		{
			p.SetState(1821)
			p.Match(SystemVerilogParserSEMI)
		}
		p.SetState(1825)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 105, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1822)
				p.Match(SystemVerilogParserKTIMEUNIT)
			}
			{
				p.SetState(1823)
				p.Match(SystemVerilogParserTIME_LITERAL)
			}
			{
				p.SetState(1824)
				p.Match(SystemVerilogParserSEMI)
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IParameter_port_listContext is an interface to support dynamic dispatch.
type IParameter_port_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameter_port_listContext differentiates from other interfaces.
	IsParameter_port_listContext()
}

type Parameter_port_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameter_port_listContext() *Parameter_port_listContext {
	var p = new(Parameter_port_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_parameter_port_list
	return p
}

func (*Parameter_port_listContext) IsParameter_port_listContext() {}

func NewParameter_port_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Parameter_port_listContext {
	var p = new(Parameter_port_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_parameter_port_list

	return p
}

func (s *Parameter_port_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Parameter_port_listContext) P() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserP, 0)
}

func (s *Parameter_port_listContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Parameter_port_listContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Parameter_port_listContext) List_of_param_assignments() IList_of_param_assignmentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_param_assignmentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_param_assignmentsContext)
}

func (s *Parameter_port_listContext) AllParameter_port_declaration() []IParameter_port_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IParameter_port_declarationContext)(nil)).Elem())
	var tst = make([]IParameter_port_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IParameter_port_declarationContext)
		}
	}

	return tst
}

func (s *Parameter_port_listContext) Parameter_port_declaration(i int) IParameter_port_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_port_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IParameter_port_declarationContext)
}

func (s *Parameter_port_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *Parameter_port_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *Parameter_port_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parameter_port_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Parameter_port_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterParameter_port_list(s)
	}
}

func (s *Parameter_port_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitParameter_port_list(s)
	}
}

func (p *SystemVerilogParser) Parameter_port_list() (localctx IParameter_port_listContext) {
	this := p
	_ = this

	localctx = NewParameter_port_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, SystemVerilogParserRULE_parameter_port_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1829)
		p.Match(SystemVerilogParserP)
	}
	{
		p.SetState(1830)
		p.Match(SystemVerilogParserLP)
	}
	p.SetState(1842)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserDUNIT || (((_la-109)&-(0x1f+1)) == 0 && ((1<<uint((_la-109)))&((1<<(SystemVerilogParserKBIT-109))|(1<<(SystemVerilogParserKBYTE-109))|(1<<(SystemVerilogParserKCHANDLE-109)))) != 0) || _la == SystemVerilogParserKENUM || _la == SystemVerilogParserKEVENT || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SystemVerilogParserKINT-195))|(1<<(SystemVerilogParserKINTEGER-195))|(1<<(SystemVerilogParserKLOCALPARAM-195))|(1<<(SystemVerilogParserKLOGIC-195))|(1<<(SystemVerilogParserKLONGINT-195)))) != 0) || (((_la-234)&-(0x1f+1)) == 0 && ((1<<uint((_la-234)))&((1<<(SystemVerilogParserKPARAMETER-234))|(1<<(SystemVerilogParserKREAL-234))|(1<<(SystemVerilogParserKREALTIME-234))|(1<<(SystemVerilogParserKREG-234)))) != 0) || (((_la-276)&-(0x1f+1)) == 0 && ((1<<uint((_la-276)))&((1<<(SystemVerilogParserKSHORTINT-276))|(1<<(SystemVerilogParserKSHORTREAL-276))|(1<<(SystemVerilogParserKSTRING-276))|(1<<(SystemVerilogParserKSTRUCT-276))|(1<<(SystemVerilogParserKTIME-276)))) != 0) || (((_la-313)&-(0x1f+1)) == 0 && ((1<<uint((_la-313)))&((1<<(SystemVerilogParserKTYPE-313))|(1<<(SystemVerilogParserKUNION-313))|(1<<(SystemVerilogParserKVIRTUAL-313)))) != 0) || _la == SystemVerilogParserSIMPLE_IDENTIFIER {
		p.SetState(1833)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 107, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1831)
				p.List_of_param_assignments()
			}

		case 2:
			{
				p.SetState(1832)
				p.Parameter_port_declaration()
			}

		}
		p.SetState(1839)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserCOMMA {
			{
				p.SetState(1835)
				p.Match(SystemVerilogParserCOMMA)
			}
			{
				p.SetState(1836)
				p.Parameter_port_declaration()
			}

			p.SetState(1841)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(1844)
		p.Match(SystemVerilogParserRP)
	}

	return localctx
}

// IParameter_port_declarationContext is an interface to support dynamic dispatch.
type IParameter_port_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameter_port_declarationContext differentiates from other interfaces.
	IsParameter_port_declarationContext()
}

type Parameter_port_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameter_port_declarationContext() *Parameter_port_declarationContext {
	var p = new(Parameter_port_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_parameter_port_declaration
	return p
}

func (*Parameter_port_declarationContext) IsParameter_port_declarationContext() {}

func NewParameter_port_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Parameter_port_declarationContext {
	var p = new(Parameter_port_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_parameter_port_declaration

	return p
}

func (s *Parameter_port_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Parameter_port_declarationContext) Parameter_declaration() IParameter_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_declarationContext)
}

func (s *Parameter_port_declarationContext) Local_parameter_declaration() ILocal_parameter_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILocal_parameter_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILocal_parameter_declarationContext)
}

func (s *Parameter_port_declarationContext) Data_type() IData_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IData_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IData_typeContext)
}

func (s *Parameter_port_declarationContext) List_of_param_assignments() IList_of_param_assignmentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_param_assignmentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_param_assignmentsContext)
}

func (s *Parameter_port_declarationContext) KTYPE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKTYPE, 0)
}

func (s *Parameter_port_declarationContext) List_of_type_assignments() IList_of_type_assignmentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_type_assignmentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_type_assignmentsContext)
}

func (s *Parameter_port_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parameter_port_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Parameter_port_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterParameter_port_declaration(s)
	}
}

func (s *Parameter_port_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitParameter_port_declaration(s)
	}
}

func (p *SystemVerilogParser) Parameter_port_declaration() (localctx IParameter_port_declarationContext) {
	this := p
	_ = this

	localctx = NewParameter_port_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, SystemVerilogParserRULE_parameter_port_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1853)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 110, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1846)
			p.Parameter_declaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1847)
			p.Local_parameter_declaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1848)
			p.Data_type()
		}
		{
			p.SetState(1849)
			p.List_of_param_assignments()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1851)
			p.Match(SystemVerilogParserKTYPE)
		}
		{
			p.SetState(1852)
			p.List_of_type_assignments()
		}

	}

	return localctx
}

// IList_of_portsContext is an interface to support dynamic dispatch.
type IList_of_portsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_portsContext differentiates from other interfaces.
	IsList_of_portsContext()
}

type List_of_portsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_portsContext() *List_of_portsContext {
	var p = new(List_of_portsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_list_of_ports
	return p
}

func (*List_of_portsContext) IsList_of_portsContext() {}

func NewList_of_portsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_portsContext {
	var p = new(List_of_portsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_list_of_ports

	return p
}

func (s *List_of_portsContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_portsContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *List_of_portsContext) AllPort() []IPortContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPortContext)(nil)).Elem())
	var tst = make([]IPortContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPortContext)
		}
	}

	return tst
}

func (s *List_of_portsContext) Port(i int) IPortContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPortContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPortContext)
}

func (s *List_of_portsContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *List_of_portsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *List_of_portsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *List_of_portsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_portsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_portsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterList_of_ports(s)
	}
}

func (s *List_of_portsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitList_of_ports(s)
	}
}

func (p *SystemVerilogParser) List_of_ports() (localctx IList_of_portsContext) {
	this := p
	_ = this

	localctx = NewList_of_portsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, SystemVerilogParserRULE_list_of_ports)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1855)
		p.Match(SystemVerilogParserLP)
	}
	{
		p.SetState(1856)
		p.Port()
	}
	p.SetState(1861)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserCOMMA {
		{
			p.SetState(1857)
			p.Match(SystemVerilogParserCOMMA)
		}
		{
			p.SetState(1858)
			p.Port()
		}

		p.SetState(1863)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1864)
		p.Match(SystemVerilogParserRP)
	}

	return localctx
}

// IList_of_port_declarationsContext is an interface to support dynamic dispatch.
type IList_of_port_declarationsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_port_declarationsContext differentiates from other interfaces.
	IsList_of_port_declarationsContext()
}

type List_of_port_declarationsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_port_declarationsContext() *List_of_port_declarationsContext {
	var p = new(List_of_port_declarationsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_list_of_port_declarations
	return p
}

func (*List_of_port_declarationsContext) IsList_of_port_declarationsContext() {}

func NewList_of_port_declarationsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_port_declarationsContext {
	var p = new(List_of_port_declarationsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_list_of_port_declarations

	return p
}

func (s *List_of_port_declarationsContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_port_declarationsContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *List_of_port_declarationsContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *List_of_port_declarationsContext) AllAnsi_port_declaration() []IAnsi_port_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnsi_port_declarationContext)(nil)).Elem())
	var tst = make([]IAnsi_port_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnsi_port_declarationContext)
		}
	}

	return tst
}

func (s *List_of_port_declarationsContext) Ansi_port_declaration(i int) IAnsi_port_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnsi_port_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnsi_port_declarationContext)
}

func (s *List_of_port_declarationsContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *List_of_port_declarationsContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *List_of_port_declarationsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *List_of_port_declarationsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *List_of_port_declarationsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_port_declarationsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_port_declarationsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterList_of_port_declarations(s)
	}
}

func (s *List_of_port_declarationsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitList_of_port_declarations(s)
	}
}

func (p *SystemVerilogParser) List_of_port_declarations() (localctx IList_of_port_declarationsContext) {
	this := p
	_ = this

	localctx = NewList_of_port_declarationsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, SystemVerilogParserRULE_list_of_port_declarations)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1866)
		p.Match(SystemVerilogParserLP)
	}
	p.SetState(1887)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-19)&-(0x1f+1)) == 0 && ((1<<uint((_la-19)))&((1<<(SystemVerilogParserDUNIT-19))|(1<<(SystemVerilogParserLPS-19))|(1<<(SystemVerilogParserDOT-19))|(1<<(SystemVerilogParserLB-19)))) != 0) || (((_la-109)&-(0x1f+1)) == 0 && ((1<<uint((_la-109)))&((1<<(SystemVerilogParserKBIT-109))|(1<<(SystemVerilogParserKBYTE-109))|(1<<(SystemVerilogParserKCHANDLE-109)))) != 0) || _la == SystemVerilogParserKENUM || _la == SystemVerilogParserKEVENT || (((_la-191)&-(0x1f+1)) == 0 && ((1<<uint((_la-191)))&((1<<(SystemVerilogParserKINOUT-191))|(1<<(SystemVerilogParserKINPUT-191))|(1<<(SystemVerilogParserKINT-191))|(1<<(SystemVerilogParserKINTEGER-191))|(1<<(SystemVerilogParserKINTERCONNECT-191))|(1<<(SystemVerilogParserKINTERFACE-191))|(1<<(SystemVerilogParserKLOGIC-191))|(1<<(SystemVerilogParserKLONGINT-191)))) != 0) || (((_la-231)&-(0x1f+1)) == 0 && ((1<<uint((_la-231)))&((1<<(SystemVerilogParserKOUTPUT-231))|(1<<(SystemVerilogParserKREAL-231))|(1<<(SystemVerilogParserKREALTIME-231))|(1<<(SystemVerilogParserKREF-231))|(1<<(SystemVerilogParserKREG-231)))) != 0) || (((_la-276)&-(0x1f+1)) == 0 && ((1<<uint((_la-276)))&((1<<(SystemVerilogParserKSHORTINT-276))|(1<<(SystemVerilogParserKSHORTREAL-276))|(1<<(SystemVerilogParserKSIGNED-276))|(1<<(SystemVerilogParserKSTRING-276))|(1<<(SystemVerilogParserKSTRUCT-276))|(1<<(SystemVerilogParserKSUPPLY0-276))|(1<<(SystemVerilogParserKSUPPLY1-276))|(1<<(SystemVerilogParserKTIME-276))|(1<<(SystemVerilogParserKTRI-276)))) != 0) || (((_la-308)&-(0x1f+1)) == 0 && ((1<<uint((_la-308)))&((1<<(SystemVerilogParserKTRI0-308))|(1<<(SystemVerilogParserKTRI1-308))|(1<<(SystemVerilogParserKTRIAND-308))|(1<<(SystemVerilogParserKTRIOR-308))|(1<<(SystemVerilogParserKTRIREG-308))|(1<<(SystemVerilogParserKTYPE-308))|(1<<(SystemVerilogParserKUNION-308))|(1<<(SystemVerilogParserKUNSIGNED-308))|(1<<(SystemVerilogParserKUWIRE-308))|(1<<(SystemVerilogParserKVAR-308))|(1<<(SystemVerilogParserKVIRTUAL-308))|(1<<(SystemVerilogParserKWAND-308))|(1<<(SystemVerilogParserKWIRE-308)))) != 0) || _la == SystemVerilogParserKWOR || _la == SystemVerilogParserSIMPLE_IDENTIFIER {
		p.SetState(1870)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserLPS {
			{
				p.SetState(1867)
				p.Attribute_instance()
			}

			p.SetState(1872)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1873)
			p.Ansi_port_declaration()
		}
		p.SetState(1884)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserCOMMA {
			{
				p.SetState(1874)
				p.Match(SystemVerilogParserCOMMA)
			}
			p.SetState(1878)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SystemVerilogParserLPS {
				{
					p.SetState(1875)
					p.Attribute_instance()
				}

				p.SetState(1880)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1881)
				p.Ansi_port_declaration()
			}

			p.SetState(1886)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(1889)
		p.Match(SystemVerilogParserRP)
	}

	return localctx
}

// IPort_declarationContext is an interface to support dynamic dispatch.
type IPort_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPort_declarationContext differentiates from other interfaces.
	IsPort_declarationContext()
}

type Port_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPort_declarationContext() *Port_declarationContext {
	var p = new(Port_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_port_declaration
	return p
}

func (*Port_declarationContext) IsPort_declarationContext() {}

func NewPort_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Port_declarationContext {
	var p = new(Port_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_port_declaration

	return p
}

func (s *Port_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Port_declarationContext) Inout_declaration() IInout_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInout_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInout_declarationContext)
}

func (s *Port_declarationContext) Input_declaration() IInput_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInput_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInput_declarationContext)
}

func (s *Port_declarationContext) Output_declaration() IOutput_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOutput_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOutput_declarationContext)
}

func (s *Port_declarationContext) Ref_declaration() IRef_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRef_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRef_declarationContext)
}

func (s *Port_declarationContext) Interface_port_declaration() IInterface_port_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_port_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterface_port_declarationContext)
}

func (s *Port_declarationContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Port_declarationContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Port_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Port_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Port_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterPort_declaration(s)
	}
}

func (s *Port_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitPort_declaration(s)
	}
}

func (p *SystemVerilogParser) Port_declaration() (localctx IPort_declarationContext) {
	this := p
	_ = this

	localctx = NewPort_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, SystemVerilogParserRULE_port_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1894)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserLPS {
		{
			p.SetState(1891)
			p.Attribute_instance()
		}

		p.SetState(1896)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1902)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserKINOUT:
		{
			p.SetState(1897)
			p.Inout_declaration()
		}

	case SystemVerilogParserKINPUT:
		{
			p.SetState(1898)
			p.Input_declaration()
		}

	case SystemVerilogParserKOUTPUT:
		{
			p.SetState(1899)
			p.Output_declaration()
		}

	case SystemVerilogParserKREF:
		{
			p.SetState(1900)
			p.Ref_declaration()
		}

	case SystemVerilogParserSIMPLE_IDENTIFIER:
		{
			p.SetState(1901)
			p.Interface_port_declaration()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPortContext is an interface to support dynamic dispatch.
type IPortContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPortContext differentiates from other interfaces.
	IsPortContext()
}

type PortContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPortContext() *PortContext {
	var p = new(PortContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_port
	return p
}

func (*PortContext) IsPortContext() {}

func NewPortContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PortContext {
	var p = new(PortContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_port

	return p
}

func (s *PortContext) GetParser() antlr.Parser { return s.parser }

func (s *PortContext) Port_expression() IPort_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPort_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPort_expressionContext)
}

func (s *PortContext) DOT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserDOT, 0)
}

func (s *PortContext) Port_identifier() IPort_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPort_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPort_identifierContext)
}

func (s *PortContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *PortContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *PortContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PortContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PortContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterPort(s)
	}
}

func (s *PortContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitPort(s)
	}
}

func (p *SystemVerilogParser) Port() (localctx IPortContext) {
	this := p
	_ = this

	localctx = NewPortContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, SystemVerilogParserRULE_port)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1915)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserRP, SystemVerilogParserCOMMA, SystemVerilogParserLC, SystemVerilogParserSIMPLE_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1905)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserLC || _la == SystemVerilogParserSIMPLE_IDENTIFIER {
			{
				p.SetState(1904)
				p.Port_expression()
			}

		}

	case SystemVerilogParserDOT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1907)
			p.Match(SystemVerilogParserDOT)
		}
		{
			p.SetState(1908)
			p.Port_identifier()
		}
		{
			p.SetState(1909)
			p.Match(SystemVerilogParserLP)
		}
		p.SetState(1911)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserLC || _la == SystemVerilogParserSIMPLE_IDENTIFIER {
			{
				p.SetState(1910)
				p.Port_expression()
			}

		}
		{
			p.SetState(1913)
			p.Match(SystemVerilogParserRP)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPort_expressionContext is an interface to support dynamic dispatch.
type IPort_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPort_expressionContext differentiates from other interfaces.
	IsPort_expressionContext()
}

type Port_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPort_expressionContext() *Port_expressionContext {
	var p = new(Port_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_port_expression
	return p
}

func (*Port_expressionContext) IsPort_expressionContext() {}

func NewPort_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Port_expressionContext {
	var p = new(Port_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_port_expression

	return p
}

func (s *Port_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Port_expressionContext) AllPort_reference() []IPort_referenceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPort_referenceContext)(nil)).Elem())
	var tst = make([]IPort_referenceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPort_referenceContext)
		}
	}

	return tst
}

func (s *Port_expressionContext) Port_reference(i int) IPort_referenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPort_referenceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPort_referenceContext)
}

func (s *Port_expressionContext) LC() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLC, 0)
}

func (s *Port_expressionContext) RC() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRC, 0)
}

func (s *Port_expressionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *Port_expressionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *Port_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Port_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Port_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterPort_expression(s)
	}
}

func (s *Port_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitPort_expression(s)
	}
}

func (p *SystemVerilogParser) Port_expression() (localctx IPort_expressionContext) {
	this := p
	_ = this

	localctx = NewPort_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, SystemVerilogParserRULE_port_expression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1929)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserSIMPLE_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1917)
			p.Port_reference()
		}

	case SystemVerilogParserLC:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1918)
			p.Match(SystemVerilogParserLC)
		}
		{
			p.SetState(1919)
			p.Port_reference()
		}
		p.SetState(1924)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserCOMMA {
			{
				p.SetState(1920)
				p.Match(SystemVerilogParserCOMMA)
			}
			{
				p.SetState(1921)
				p.Port_reference()
			}

			p.SetState(1926)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1927)
			p.Match(SystemVerilogParserRC)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPort_referenceContext is an interface to support dynamic dispatch.
type IPort_referenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPort_referenceContext differentiates from other interfaces.
	IsPort_referenceContext()
}

type Port_referenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPort_referenceContext() *Port_referenceContext {
	var p = new(Port_referenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_port_reference
	return p
}

func (*Port_referenceContext) IsPort_referenceContext() {}

func NewPort_referenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Port_referenceContext {
	var p = new(Port_referenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_port_reference

	return p
}

func (s *Port_referenceContext) GetParser() antlr.Parser { return s.parser }

func (s *Port_referenceContext) Port_identifier() IPort_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPort_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPort_identifierContext)
}

func (s *Port_referenceContext) Constant_select() IConstant_selectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_selectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_selectContext)
}

func (s *Port_referenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Port_referenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Port_referenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterPort_reference(s)
	}
}

func (s *Port_referenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitPort_reference(s)
	}
}

func (p *SystemVerilogParser) Port_reference() (localctx IPort_referenceContext) {
	this := p
	_ = this

	localctx = NewPort_referenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, SystemVerilogParserRULE_port_reference)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1931)
		p.Port_identifier()
	}
	{
		p.SetState(1932)
		p.Constant_select()
	}

	return localctx
}

// IPort_directionContext is an interface to support dynamic dispatch.
type IPort_directionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPort_directionContext differentiates from other interfaces.
	IsPort_directionContext()
}

type Port_directionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPort_directionContext() *Port_directionContext {
	var p = new(Port_directionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_port_direction
	return p
}

func (*Port_directionContext) IsPort_directionContext() {}

func NewPort_directionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Port_directionContext {
	var p = new(Port_directionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_port_direction

	return p
}

func (s *Port_directionContext) GetParser() antlr.Parser { return s.parser }

func (s *Port_directionContext) KINPUT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKINPUT, 0)
}

func (s *Port_directionContext) KOUTPUT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKOUTPUT, 0)
}

func (s *Port_directionContext) KINOUT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKINOUT, 0)
}

func (s *Port_directionContext) KREF() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKREF, 0)
}

func (s *Port_directionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Port_directionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Port_directionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterPort_direction(s)
	}
}

func (s *Port_directionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitPort_direction(s)
	}
}

func (p *SystemVerilogParser) Port_direction() (localctx IPort_directionContext) {
	this := p
	_ = this

	localctx = NewPort_directionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, SystemVerilogParserRULE_port_direction)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1934)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SystemVerilogParserKINOUT || _la == SystemVerilogParserKINPUT || _la == SystemVerilogParserKOUTPUT || _la == SystemVerilogParserKREF) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// INet_port_headerContext is an interface to support dynamic dispatch.
type INet_port_headerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNet_port_headerContext differentiates from other interfaces.
	IsNet_port_headerContext()
}

type Net_port_headerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNet_port_headerContext() *Net_port_headerContext {
	var p = new(Net_port_headerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_net_port_header
	return p
}

func (*Net_port_headerContext) IsNet_port_headerContext() {}

func NewNet_port_headerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Net_port_headerContext {
	var p = new(Net_port_headerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_net_port_header

	return p
}

func (s *Net_port_headerContext) GetParser() antlr.Parser { return s.parser }

func (s *Net_port_headerContext) Net_port_type() INet_port_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_port_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INet_port_typeContext)
}

func (s *Net_port_headerContext) Port_direction() IPort_directionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPort_directionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPort_directionContext)
}

func (s *Net_port_headerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Net_port_headerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Net_port_headerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterNet_port_header(s)
	}
}

func (s *Net_port_headerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitNet_port_header(s)
	}
}

func (p *SystemVerilogParser) Net_port_header() (localctx INet_port_headerContext) {
	this := p
	_ = this

	localctx = NewNet_port_headerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, SystemVerilogParserRULE_net_port_header)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1937)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserKINOUT || _la == SystemVerilogParserKINPUT || _la == SystemVerilogParserKOUTPUT || _la == SystemVerilogParserKREF {
		{
			p.SetState(1936)
			p.Port_direction()
		}

	}
	{
		p.SetState(1939)
		p.Net_port_type()
	}

	return localctx
}

// IVariable_port_headerContext is an interface to support dynamic dispatch.
type IVariable_port_headerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariable_port_headerContext differentiates from other interfaces.
	IsVariable_port_headerContext()
}

type Variable_port_headerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariable_port_headerContext() *Variable_port_headerContext {
	var p = new(Variable_port_headerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_variable_port_header
	return p
}

func (*Variable_port_headerContext) IsVariable_port_headerContext() {}

func NewVariable_port_headerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Variable_port_headerContext {
	var p = new(Variable_port_headerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_variable_port_header

	return p
}

func (s *Variable_port_headerContext) GetParser() antlr.Parser { return s.parser }

func (s *Variable_port_headerContext) Variable_port_type() IVariable_port_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_port_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_port_typeContext)
}

func (s *Variable_port_headerContext) Port_direction() IPort_directionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPort_directionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPort_directionContext)
}

func (s *Variable_port_headerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Variable_port_headerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Variable_port_headerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterVariable_port_header(s)
	}
}

func (s *Variable_port_headerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitVariable_port_header(s)
	}
}

func (p *SystemVerilogParser) Variable_port_header() (localctx IVariable_port_headerContext) {
	this := p
	_ = this

	localctx = NewVariable_port_headerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, SystemVerilogParserRULE_variable_port_header)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1942)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserKINOUT || _la == SystemVerilogParserKINPUT || _la == SystemVerilogParserKOUTPUT || _la == SystemVerilogParserKREF {
		{
			p.SetState(1941)
			p.Port_direction()
		}

	}
	{
		p.SetState(1944)
		p.Variable_port_type()
	}

	return localctx
}

// IInterface_port_headerContext is an interface to support dynamic dispatch.
type IInterface_port_headerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterface_port_headerContext differentiates from other interfaces.
	IsInterface_port_headerContext()
}

type Interface_port_headerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterface_port_headerContext() *Interface_port_headerContext {
	var p = new(Interface_port_headerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_interface_port_header
	return p
}

func (*Interface_port_headerContext) IsInterface_port_headerContext() {}

func NewInterface_port_headerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Interface_port_headerContext {
	var p = new(Interface_port_headerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_interface_port_header

	return p
}

func (s *Interface_port_headerContext) GetParser() antlr.Parser { return s.parser }

func (s *Interface_port_headerContext) Interface_identifier() IInterface_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterface_identifierContext)
}

func (s *Interface_port_headerContext) DOT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserDOT, 0)
}

func (s *Interface_port_headerContext) Modport_identifier() IModport_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModport_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModport_identifierContext)
}

func (s *Interface_port_headerContext) KINTERFACE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKINTERFACE, 0)
}

func (s *Interface_port_headerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Interface_port_headerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Interface_port_headerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterInterface_port_header(s)
	}
}

func (s *Interface_port_headerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitInterface_port_header(s)
	}
}

func (p *SystemVerilogParser) Interface_port_header() (localctx IInterface_port_headerContext) {
	this := p
	_ = this

	localctx = NewInterface_port_headerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, SystemVerilogParserRULE_interface_port_header)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1956)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserSIMPLE_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1946)
			p.Interface_identifier()
		}
		p.SetState(1949)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserDOT {
			{
				p.SetState(1947)
				p.Match(SystemVerilogParserDOT)
			}
			{
				p.SetState(1948)
				p.Modport_identifier()
			}

		}

	case SystemVerilogParserKINTERFACE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1951)
			p.Match(SystemVerilogParserKINTERFACE)
		}
		p.SetState(1954)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserDOT {
			{
				p.SetState(1952)
				p.Match(SystemVerilogParserDOT)
			}
			{
				p.SetState(1953)
				p.Modport_identifier()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAnsi_port_declarationContext is an interface to support dynamic dispatch.
type IAnsi_port_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnsi_port_declarationContext differentiates from other interfaces.
	IsAnsi_port_declarationContext()
}

type Ansi_port_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnsi_port_declarationContext() *Ansi_port_declarationContext {
	var p = new(Ansi_port_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_ansi_port_declaration
	return p
}

func (*Ansi_port_declarationContext) IsAnsi_port_declarationContext() {}

func NewAnsi_port_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Ansi_port_declarationContext {
	var p = new(Ansi_port_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_ansi_port_declaration

	return p
}

func (s *Ansi_port_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Ansi_port_declarationContext) Port_identifier() IPort_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPort_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPort_identifierContext)
}

func (s *Ansi_port_declarationContext) Net_port_header() INet_port_headerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_port_headerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INet_port_headerContext)
}

func (s *Ansi_port_declarationContext) Interface_port_header() IInterface_port_headerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_port_headerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterface_port_headerContext)
}

func (s *Ansi_port_declarationContext) AllUnpacked_dimension() []IUnpacked_dimensionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IUnpacked_dimensionContext)(nil)).Elem())
	var tst = make([]IUnpacked_dimensionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IUnpacked_dimensionContext)
		}
	}

	return tst
}

func (s *Ansi_port_declarationContext) Unpacked_dimension(i int) IUnpacked_dimensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnpacked_dimensionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IUnpacked_dimensionContext)
}

func (s *Ansi_port_declarationContext) EQ() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserEQ, 0)
}

func (s *Ansi_port_declarationContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Ansi_port_declarationContext) Variable_port_header() IVariable_port_headerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_port_headerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_port_headerContext)
}

func (s *Ansi_port_declarationContext) AllVariable_dimension() []IVariable_dimensionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariable_dimensionContext)(nil)).Elem())
	var tst = make([]IVariable_dimensionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariable_dimensionContext)
		}
	}

	return tst
}

func (s *Ansi_port_declarationContext) Variable_dimension(i int) IVariable_dimensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_dimensionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariable_dimensionContext)
}

func (s *Ansi_port_declarationContext) DOT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserDOT, 0)
}

func (s *Ansi_port_declarationContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Ansi_port_declarationContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Ansi_port_declarationContext) Port_direction() IPort_directionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPort_directionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPort_directionContext)
}

func (s *Ansi_port_declarationContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Ansi_port_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ansi_port_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Ansi_port_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterAnsi_port_declaration(s)
	}
}

func (s *Ansi_port_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitAnsi_port_declaration(s)
	}
}

func (p *SystemVerilogParser) Ansi_port_declaration() (localctx IAnsi_port_declarationContext) {
	this := p
	_ = this

	localctx = NewAnsi_port_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, SystemVerilogParserRULE_ansi_port_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1998)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 136, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1960)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 128, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1958)
				p.Net_port_header()
			}

		} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 128, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(1959)
				p.Interface_port_header()
			}

		}
		{
			p.SetState(1962)
			p.Port_identifier()
		}
		p.SetState(1966)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserLB {
			{
				p.SetState(1963)
				p.Unpacked_dimension()
			}

			p.SetState(1968)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(1971)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserEQ {
			{
				p.SetState(1969)
				p.Match(SystemVerilogParserEQ)
			}
			{
				p.SetState(1970)
				p.constant_expression(0)
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1974)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 131, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1973)
				p.Variable_port_header()
			}

		}
		{
			p.SetState(1976)
			p.Port_identifier()
		}
		p.SetState(1980)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserLB {
			{
				p.SetState(1977)
				p.Variable_dimension()
			}

			p.SetState(1982)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(1985)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserEQ {
			{
				p.SetState(1983)
				p.Match(SystemVerilogParserEQ)
			}
			{
				p.SetState(1984)
				p.constant_expression(0)
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(1988)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserKINOUT || _la == SystemVerilogParserKINPUT || _la == SystemVerilogParserKOUTPUT || _la == SystemVerilogParserKREF {
			{
				p.SetState(1987)
				p.Port_direction()
			}

		}
		{
			p.SetState(1990)
			p.Match(SystemVerilogParserDOT)
		}
		{
			p.SetState(1991)
			p.Port_identifier()
		}
		{
			p.SetState(1992)
			p.Match(SystemVerilogParserLP)
		}
		p.SetState(1994)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SystemVerilogParserMINUS)|(1<<SystemVerilogParserMINUSMINS)|(1<<SystemVerilogParserNOT)|(1<<SystemVerilogParserDOLLAR)|(1<<SystemVerilogParserDROOT)|(1<<SystemVerilogParserDUNIT)|(1<<SystemVerilogParserAND)|(1<<SystemVerilogParserLP))) != 0) || (((_la-51)&-(0x1f+1)) == 0 && ((1<<uint((_la-51)))&((1<<(SystemVerilogParserQUOTE-51))|(1<<(SystemVerilogParserCARET-51))|(1<<(SystemVerilogParserCARETSQUIG-51))|(1<<(SystemVerilogParserLC-51))|(1<<(SystemVerilogParserBAR-51))|(1<<(SystemVerilogParserSQUIG-51))|(1<<(SystemVerilogParserSQUIGAND-51))|(1<<(SystemVerilogParserSQUIGCARET-51))|(1<<(SystemVerilogParserSQUIGBAR-51))|(1<<(SystemVerilogParserPLUS-51))|(1<<(SystemVerilogParserPLUSPLUS-51)))) != 0) || (((_la-109)&-(0x1f+1)) == 0 && ((1<<uint((_la-109)))&((1<<(SystemVerilogParserKBIT-109))|(1<<(SystemVerilogParserKBYTE-109))|(1<<(SystemVerilogParserKCONST-109)))) != 0) || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SystemVerilogParserKINT-195))|(1<<(SystemVerilogParserKINTEGER-195))|(1<<(SystemVerilogParserKLOCAL-195))|(1<<(SystemVerilogParserKLOGIC-195))|(1<<(SystemVerilogParserKLONGINT-195)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(SystemVerilogParserKNULL-228))|(1<<(SystemVerilogParserKRANDOMIZE-228))|(1<<(SystemVerilogParserKREAL-228))|(1<<(SystemVerilogParserKREALTIME-228))|(1<<(SystemVerilogParserKREG-228)))) != 0) || (((_la-276)&-(0x1f+1)) == 0 && ((1<<uint((_la-276)))&((1<<(SystemVerilogParserKSHORTINT-276))|(1<<(SystemVerilogParserKSHORTREAL-276))|(1<<(SystemVerilogParserKSIGNED-276))|(1<<(SystemVerilogParserKSTD-276))|(1<<(SystemVerilogParserKSTRING-276))|(1<<(SystemVerilogParserKSUPER-276))|(1<<(SystemVerilogParserKTAGGED-276))|(1<<(SystemVerilogParserKTHIS-276))|(1<<(SystemVerilogParserKTIME-276)))) != 0) || _la == SystemVerilogParserKTYPE || _la == SystemVerilogParserKUNSIGNED || (((_la-345)&-(0x1f+1)) == 0 && ((1<<uint((_la-345)))&((1<<(SystemVerilogParserTIME_LITERAL-345))|(1<<(SystemVerilogParserDECIMAL_NUMBER-345))|(1<<(SystemVerilogParserBINARY_NUMBER-345))|(1<<(SystemVerilogParserOCTAL_NUMBER-345))|(1<<(SystemVerilogParserHEX_NUMBER-345))|(1<<(SystemVerilogParserREAL_NUMBER-345))|(1<<(SystemVerilogParserUNSIGNED_NUMBER-345))|(1<<(SystemVerilogParserSTRING_LITERAL-345))|(1<<(SystemVerilogParserSIMPLE_IDENTIFIER-345))|(1<<(SystemVerilogParserSYSTEM_TF_IDENTIFIER-345)))) != 0) {
			{
				p.SetState(1993)
				p.expression(0)
			}

		}
		{
			p.SetState(1996)
			p.Match(SystemVerilogParserRP)
		}

	}

	return localctx
}

// IElaboration_system_taskContext is an interface to support dynamic dispatch.
type IElaboration_system_taskContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElaboration_system_taskContext differentiates from other interfaces.
	IsElaboration_system_taskContext()
}

type Elaboration_system_taskContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElaboration_system_taskContext() *Elaboration_system_taskContext {
	var p = new(Elaboration_system_taskContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_elaboration_system_task
	return p
}

func (*Elaboration_system_taskContext) IsElaboration_system_taskContext() {}

func NewElaboration_system_taskContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Elaboration_system_taskContext {
	var p = new(Elaboration_system_taskContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_elaboration_system_task

	return p
}

func (s *Elaboration_system_taskContext) GetParser() antlr.Parser { return s.parser }

func (s *Elaboration_system_taskContext) DFATAL() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserDFATAL, 0)
}

func (s *Elaboration_system_taskContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Elaboration_system_taskContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Elaboration_system_taskContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Elaboration_system_taskContext) List_of_arguments() IList_of_argumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_argumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_argumentsContext)
}

func (s *Elaboration_system_taskContext) DERROR() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserDERROR, 0)
}

func (s *Elaboration_system_taskContext) DWARNING() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserDWARNING, 0)
}

func (s *Elaboration_system_taskContext) DINFO() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserDINFO, 0)
}

func (s *Elaboration_system_taskContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Elaboration_system_taskContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Elaboration_system_taskContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterElaboration_system_task(s)
	}
}

func (s *Elaboration_system_taskContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitElaboration_system_task(s)
	}
}

func (p *SystemVerilogParser) Elaboration_system_task() (localctx IElaboration_system_taskContext) {
	this := p
	_ = this

	localctx = NewElaboration_system_taskContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, SystemVerilogParserRULE_elaboration_system_task)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2018)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserDFATAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2000)
			p.Match(SystemVerilogParserDFATAL)
		}
		p.SetState(2006)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserLP {
			{
				p.SetState(2001)
				p.Match(SystemVerilogParserLP)
			}
			p.SetState(2003)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 137, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(2002)
					p.List_of_arguments()
				}

			}
			{
				p.SetState(2005)
				p.Match(SystemVerilogParserRP)
			}

		}
		{
			p.SetState(2008)
			p.Match(SystemVerilogParserSEMI)
		}

	case SystemVerilogParserDERROR, SystemVerilogParserDINFO, SystemVerilogParserDWARNING:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2009)
			_la = p.GetTokenStream().LA(1)

			if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SystemVerilogParserDERROR)|(1<<SystemVerilogParserDINFO)|(1<<SystemVerilogParserDWARNING))) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(2015)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserLP {
			{
				p.SetState(2010)
				p.Match(SystemVerilogParserLP)
			}
			p.SetState(2012)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 139, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(2011)
					p.List_of_arguments()
				}

			}
			{
				p.SetState(2014)
				p.Match(SystemVerilogParserRP)
			}

		}
		{
			p.SetState(2017)
			p.Match(SystemVerilogParserSEMI)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IModule_common_itemContext is an interface to support dynamic dispatch.
type IModule_common_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModule_common_itemContext differentiates from other interfaces.
	IsModule_common_itemContext()
}

type Module_common_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModule_common_itemContext() *Module_common_itemContext {
	var p = new(Module_common_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_module_common_item
	return p
}

func (*Module_common_itemContext) IsModule_common_itemContext() {}

func NewModule_common_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Module_common_itemContext {
	var p = new(Module_common_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_module_common_item

	return p
}

func (s *Module_common_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Module_common_itemContext) Module_or_generate_item_declaration() IModule_or_generate_item_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_or_generate_item_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_or_generate_item_declarationContext)
}

func (s *Module_common_itemContext) Interface_instantiation() IInterface_instantiationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_instantiationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterface_instantiationContext)
}

func (s *Module_common_itemContext) Program_instantiation() IProgram_instantiationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProgram_instantiationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProgram_instantiationContext)
}

func (s *Module_common_itemContext) Assertion_item() IAssertion_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssertion_itemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssertion_itemContext)
}

func (s *Module_common_itemContext) Bind_directive() IBind_directiveContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBind_directiveContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBind_directiveContext)
}

func (s *Module_common_itemContext) Continuous_assign() IContinuous_assignContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IContinuous_assignContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IContinuous_assignContext)
}

func (s *Module_common_itemContext) Net_alias() INet_aliasContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_aliasContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INet_aliasContext)
}

func (s *Module_common_itemContext) Initial_construct() IInitial_constructContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInitial_constructContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInitial_constructContext)
}

func (s *Module_common_itemContext) Final_construct() IFinal_constructContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFinal_constructContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFinal_constructContext)
}

func (s *Module_common_itemContext) Always_construct() IAlways_constructContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlways_constructContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlways_constructContext)
}

func (s *Module_common_itemContext) Loop_generate_construct() ILoop_generate_constructContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILoop_generate_constructContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILoop_generate_constructContext)
}

func (s *Module_common_itemContext) Conditional_generate_construct() IConditional_generate_constructContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditional_generate_constructContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditional_generate_constructContext)
}

func (s *Module_common_itemContext) Elaboration_system_task() IElaboration_system_taskContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElaboration_system_taskContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElaboration_system_taskContext)
}

func (s *Module_common_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Module_common_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Module_common_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterModule_common_item(s)
	}
}

func (s *Module_common_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitModule_common_item(s)
	}
}

func (p *SystemVerilogParser) Module_common_item() (localctx IModule_common_itemContext) {
	this := p
	_ = this

	localctx = NewModule_common_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, SystemVerilogParserRULE_module_common_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2033)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 142, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2020)
			p.Module_or_generate_item_declaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2021)
			p.Interface_instantiation()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2022)
			p.Program_instantiation()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2023)
			p.Assertion_item()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2024)
			p.Bind_directive()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2025)
			p.Continuous_assign()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2026)
			p.Net_alias()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(2027)
			p.Initial_construct()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(2028)
			p.Final_construct()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(2029)
			p.Always_construct()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(2030)
			p.Loop_generate_construct()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(2031)
			p.Conditional_generate_construct()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(2032)
			p.Elaboration_system_task()
		}

	}

	return localctx
}

// IModule_itemContext is an interface to support dynamic dispatch.
type IModule_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModule_itemContext differentiates from other interfaces.
	IsModule_itemContext()
}

type Module_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModule_itemContext() *Module_itemContext {
	var p = new(Module_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_module_item
	return p
}

func (*Module_itemContext) IsModule_itemContext() {}

func NewModule_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Module_itemContext {
	var p = new(Module_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_module_item

	return p
}

func (s *Module_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Module_itemContext) Port_declaration() IPort_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPort_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPort_declarationContext)
}

func (s *Module_itemContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Module_itemContext) Non_port_module_item() INon_port_module_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INon_port_module_itemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INon_port_module_itemContext)
}

func (s *Module_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Module_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Module_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterModule_item(s)
	}
}

func (s *Module_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitModule_item(s)
	}
}

func (p *SystemVerilogParser) Module_item() (localctx IModule_itemContext) {
	this := p
	_ = this

	localctx = NewModule_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, SystemVerilogParserRULE_module_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2039)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 143, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2035)
			p.Port_declaration()
		}
		{
			p.SetState(2036)
			p.Match(SystemVerilogParserSEMI)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2038)
			p.Non_port_module_item()
		}

	}

	return localctx
}

// IModule_or_generate_itemContext is an interface to support dynamic dispatch.
type IModule_or_generate_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModule_or_generate_itemContext differentiates from other interfaces.
	IsModule_or_generate_itemContext()
}

type Module_or_generate_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModule_or_generate_itemContext() *Module_or_generate_itemContext {
	var p = new(Module_or_generate_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_module_or_generate_item
	return p
}

func (*Module_or_generate_itemContext) IsModule_or_generate_itemContext() {}

func NewModule_or_generate_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Module_or_generate_itemContext {
	var p = new(Module_or_generate_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_module_or_generate_item

	return p
}

func (s *Module_or_generate_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Module_or_generate_itemContext) Parameter_override() IParameter_overrideContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_overrideContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_overrideContext)
}

func (s *Module_or_generate_itemContext) Gate_instantiation() IGate_instantiationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGate_instantiationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGate_instantiationContext)
}

func (s *Module_or_generate_itemContext) Module_instantiation() IModule_instantiationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_instantiationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_instantiationContext)
}

func (s *Module_or_generate_itemContext) Module_common_item() IModule_common_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_common_itemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_common_itemContext)
}

func (s *Module_or_generate_itemContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Module_or_generate_itemContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Module_or_generate_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Module_or_generate_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Module_or_generate_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterModule_or_generate_item(s)
	}
}

func (s *Module_or_generate_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitModule_or_generate_item(s)
	}
}

func (p *SystemVerilogParser) Module_or_generate_item() (localctx IModule_or_generate_itemContext) {
	this := p
	_ = this

	localctx = NewModule_or_generate_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, SystemVerilogParserRULE_module_or_generate_item)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2044)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserLPS {
		{
			p.SetState(2041)
			p.Attribute_instance()
		}

		p.SetState(2046)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(2051)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 145, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2047)
			p.Parameter_override()
		}

	case 2:
		{
			p.SetState(2048)
			p.Gate_instantiation()
		}

	case 3:
		{
			p.SetState(2049)
			p.Module_instantiation()
		}

	case 4:
		{
			p.SetState(2050)
			p.Module_common_item()
		}

	}

	return localctx
}

// IModule_or_generate_item_declarationContext is an interface to support dynamic dispatch.
type IModule_or_generate_item_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModule_or_generate_item_declarationContext differentiates from other interfaces.
	IsModule_or_generate_item_declarationContext()
}

type Module_or_generate_item_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModule_or_generate_item_declarationContext() *Module_or_generate_item_declarationContext {
	var p = new(Module_or_generate_item_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_module_or_generate_item_declaration
	return p
}

func (*Module_or_generate_item_declarationContext) IsModule_or_generate_item_declarationContext() {}

func NewModule_or_generate_item_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Module_or_generate_item_declarationContext {
	var p = new(Module_or_generate_item_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_module_or_generate_item_declaration

	return p
}

func (s *Module_or_generate_item_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Module_or_generate_item_declarationContext) Package_or_generate_item_declaration() IPackage_or_generate_item_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackage_or_generate_item_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPackage_or_generate_item_declarationContext)
}

func (s *Module_or_generate_item_declarationContext) Genvar_declaration() IGenvar_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenvar_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenvar_declarationContext)
}

func (s *Module_or_generate_item_declarationContext) Clocking_declaration() IClocking_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClocking_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClocking_declarationContext)
}

func (s *Module_or_generate_item_declarationContext) KDEFAULT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKDEFAULT, 0)
}

func (s *Module_or_generate_item_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Module_or_generate_item_declarationContext) KCLOCKING() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKCLOCKING, 0)
}

func (s *Module_or_generate_item_declarationContext) Clocking_identifier() IClocking_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClocking_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClocking_identifierContext)
}

func (s *Module_or_generate_item_declarationContext) KDISABLE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKDISABLE, 0)
}

func (s *Module_or_generate_item_declarationContext) KIFF() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKIFF, 0)
}

func (s *Module_or_generate_item_declarationContext) Expression_or_dist() IExpression_or_distContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpression_or_distContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpression_or_distContext)
}

func (s *Module_or_generate_item_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Module_or_generate_item_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Module_or_generate_item_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterModule_or_generate_item_declaration(s)
	}
}

func (s *Module_or_generate_item_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitModule_or_generate_item_declaration(s)
	}
}

func (p *SystemVerilogParser) Module_or_generate_item_declaration() (localctx IModule_or_generate_item_declarationContext) {
	this := p
	_ = this

	localctx = NewModule_or_generate_item_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, SystemVerilogParserRULE_module_or_generate_item_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2066)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 147, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2053)
			p.Package_or_generate_item_declaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2054)
			p.Genvar_declaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2055)
			p.Clocking_declaration()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2056)
			p.Match(SystemVerilogParserKDEFAULT)
		}
		p.SetState(2062)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SystemVerilogParserKCLOCKING:
			{
				p.SetState(2057)
				p.Match(SystemVerilogParserKCLOCKING)
			}
			{
				p.SetState(2058)
				p.Clocking_identifier()
			}

		case SystemVerilogParserKDISABLE:
			{
				p.SetState(2059)
				p.Match(SystemVerilogParserKDISABLE)
			}
			{
				p.SetState(2060)
				p.Match(SystemVerilogParserKIFF)
			}
			{
				p.SetState(2061)
				p.Expression_or_dist()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(2064)
			p.Match(SystemVerilogParserSEMI)
		}

	}

	return localctx
}

// INon_port_module_itemContext is an interface to support dynamic dispatch.
type INon_port_module_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNon_port_module_itemContext differentiates from other interfaces.
	IsNon_port_module_itemContext()
}

type Non_port_module_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNon_port_module_itemContext() *Non_port_module_itemContext {
	var p = new(Non_port_module_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_non_port_module_item
	return p
}

func (*Non_port_module_itemContext) IsNon_port_module_itemContext() {}

func NewNon_port_module_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Non_port_module_itemContext {
	var p = new(Non_port_module_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_non_port_module_item

	return p
}

func (s *Non_port_module_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Non_port_module_itemContext) Generate_region() IGenerate_regionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenerate_regionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenerate_regionContext)
}

func (s *Non_port_module_itemContext) Module_or_generate_item() IModule_or_generate_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_or_generate_itemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_or_generate_itemContext)
}

func (s *Non_port_module_itemContext) Specify_block() ISpecify_blockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecify_blockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpecify_blockContext)
}

func (s *Non_port_module_itemContext) Specparam_declaration() ISpecparam_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecparam_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpecparam_declarationContext)
}

func (s *Non_port_module_itemContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Non_port_module_itemContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Non_port_module_itemContext) Program_declaration() IProgram_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProgram_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProgram_declarationContext)
}

func (s *Non_port_module_itemContext) Module_declaration() IModule_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_declarationContext)
}

func (s *Non_port_module_itemContext) Interface_declaration() IInterface_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterface_declarationContext)
}

func (s *Non_port_module_itemContext) Timeunits_declaration() ITimeunits_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITimeunits_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITimeunits_declarationContext)
}

func (s *Non_port_module_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Non_port_module_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Non_port_module_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterNon_port_module_item(s)
	}
}

func (s *Non_port_module_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitNon_port_module_item(s)
	}
}

func (p *SystemVerilogParser) Non_port_module_item() (localctx INon_port_module_itemContext) {
	this := p
	_ = this

	localctx = NewNon_port_module_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, SystemVerilogParserRULE_non_port_module_item)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2082)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 149, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2068)
			p.Generate_region()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2069)
			p.Module_or_generate_item()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2070)
			p.Specify_block()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(2074)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserLPS {
			{
				p.SetState(2071)
				p.Attribute_instance()
			}

			p.SetState(2076)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2077)
			p.Specparam_declaration()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2078)
			p.Program_declaration()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2079)
			p.Module_declaration()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2080)
			p.Interface_declaration()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(2081)
			p.Timeunits_declaration()
		}

	}

	return localctx
}

// IParameter_overrideContext is an interface to support dynamic dispatch.
type IParameter_overrideContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameter_overrideContext differentiates from other interfaces.
	IsParameter_overrideContext()
}

type Parameter_overrideContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameter_overrideContext() *Parameter_overrideContext {
	var p = new(Parameter_overrideContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_parameter_override
	return p
}

func (*Parameter_overrideContext) IsParameter_overrideContext() {}

func NewParameter_overrideContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Parameter_overrideContext {
	var p = new(Parameter_overrideContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_parameter_override

	return p
}

func (s *Parameter_overrideContext) GetParser() antlr.Parser { return s.parser }

func (s *Parameter_overrideContext) KDEFPARAM() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKDEFPARAM, 0)
}

func (s *Parameter_overrideContext) List_of_defparam_assignments() IList_of_defparam_assignmentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_defparam_assignmentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_defparam_assignmentsContext)
}

func (s *Parameter_overrideContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Parameter_overrideContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parameter_overrideContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Parameter_overrideContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterParameter_override(s)
	}
}

func (s *Parameter_overrideContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitParameter_override(s)
	}
}

func (p *SystemVerilogParser) Parameter_override() (localctx IParameter_overrideContext) {
	this := p
	_ = this

	localctx = NewParameter_overrideContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, SystemVerilogParserRULE_parameter_override)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2084)
		p.Match(SystemVerilogParserKDEFPARAM)
	}
	{
		p.SetState(2085)
		p.List_of_defparam_assignments()
	}
	{
		p.SetState(2086)
		p.Match(SystemVerilogParserSEMI)
	}

	return localctx
}

// IBind_directiveContext is an interface to support dynamic dispatch.
type IBind_directiveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBind_directiveContext differentiates from other interfaces.
	IsBind_directiveContext()
}

type Bind_directiveContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBind_directiveContext() *Bind_directiveContext {
	var p = new(Bind_directiveContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_bind_directive
	return p
}

func (*Bind_directiveContext) IsBind_directiveContext() {}

func NewBind_directiveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bind_directiveContext {
	var p = new(Bind_directiveContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_bind_directive

	return p
}

func (s *Bind_directiveContext) GetParser() antlr.Parser { return s.parser }

func (s *Bind_directiveContext) KBIND() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKBIND, 0)
}

func (s *Bind_directiveContext) Bind_instantiation() IBind_instantiationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBind_instantiationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBind_instantiationContext)
}

func (s *Bind_directiveContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Bind_directiveContext) Bind_target_scope() IBind_target_scopeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBind_target_scopeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBind_target_scopeContext)
}

func (s *Bind_directiveContext) Bind_target_instance() IBind_target_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBind_target_instanceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBind_target_instanceContext)
}

func (s *Bind_directiveContext) COLON() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOLON, 0)
}

func (s *Bind_directiveContext) Bind_target_instance_list() IBind_target_instance_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBind_target_instance_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBind_target_instance_listContext)
}

func (s *Bind_directiveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bind_directiveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Bind_directiveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterBind_directive(s)
	}
}

func (s *Bind_directiveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitBind_directive(s)
	}
}

func (p *SystemVerilogParser) Bind_directive() (localctx IBind_directiveContext) {
	this := p
	_ = this

	localctx = NewBind_directiveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, SystemVerilogParserRULE_bind_directive)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2088)
		p.Match(SystemVerilogParserKBIND)
	}
	p.SetState(2095)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 151, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2089)
			p.Bind_target_scope()
		}
		p.SetState(2092)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserCOLON {
			{
				p.SetState(2090)
				p.Match(SystemVerilogParserCOLON)
			}
			{
				p.SetState(2091)
				p.Bind_target_instance_list()
			}

		}

	case 2:
		{
			p.SetState(2094)
			p.Bind_target_instance()
		}

	}
	{
		p.SetState(2097)
		p.Bind_instantiation()
	}
	{
		p.SetState(2098)
		p.Match(SystemVerilogParserSEMI)
	}

	return localctx
}

// IBind_target_scopeContext is an interface to support dynamic dispatch.
type IBind_target_scopeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBind_target_scopeContext differentiates from other interfaces.
	IsBind_target_scopeContext()
}

type Bind_target_scopeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBind_target_scopeContext() *Bind_target_scopeContext {
	var p = new(Bind_target_scopeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_bind_target_scope
	return p
}

func (*Bind_target_scopeContext) IsBind_target_scopeContext() {}

func NewBind_target_scopeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bind_target_scopeContext {
	var p = new(Bind_target_scopeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_bind_target_scope

	return p
}

func (s *Bind_target_scopeContext) GetParser() antlr.Parser { return s.parser }

func (s *Bind_target_scopeContext) Module_identifier() IModule_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_identifierContext)
}

func (s *Bind_target_scopeContext) Interface_identifier() IInterface_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterface_identifierContext)
}

func (s *Bind_target_scopeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bind_target_scopeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Bind_target_scopeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterBind_target_scope(s)
	}
}

func (s *Bind_target_scopeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitBind_target_scope(s)
	}
}

func (p *SystemVerilogParser) Bind_target_scope() (localctx IBind_target_scopeContext) {
	this := p
	_ = this

	localctx = NewBind_target_scopeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, SystemVerilogParserRULE_bind_target_scope)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2102)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 152, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2100)
			p.Module_identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2101)
			p.Interface_identifier()
		}

	}

	return localctx
}

// IBind_target_instanceContext is an interface to support dynamic dispatch.
type IBind_target_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBind_target_instanceContext differentiates from other interfaces.
	IsBind_target_instanceContext()
}

type Bind_target_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBind_target_instanceContext() *Bind_target_instanceContext {
	var p = new(Bind_target_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_bind_target_instance
	return p
}

func (*Bind_target_instanceContext) IsBind_target_instanceContext() {}

func NewBind_target_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bind_target_instanceContext {
	var p = new(Bind_target_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_bind_target_instance

	return p
}

func (s *Bind_target_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *Bind_target_instanceContext) Hierarchical_identifier() IHierarchical_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_identifierContext)
}

func (s *Bind_target_instanceContext) Constant_bit_select() IConstant_bit_selectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_bit_selectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_bit_selectContext)
}

func (s *Bind_target_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bind_target_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Bind_target_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterBind_target_instance(s)
	}
}

func (s *Bind_target_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitBind_target_instance(s)
	}
}

func (p *SystemVerilogParser) Bind_target_instance() (localctx IBind_target_instanceContext) {
	this := p
	_ = this

	localctx = NewBind_target_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, SystemVerilogParserRULE_bind_target_instance)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2104)
		p.Hierarchical_identifier()
	}
	{
		p.SetState(2105)
		p.Constant_bit_select()
	}

	return localctx
}

// IBind_target_instance_listContext is an interface to support dynamic dispatch.
type IBind_target_instance_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBind_target_instance_listContext differentiates from other interfaces.
	IsBind_target_instance_listContext()
}

type Bind_target_instance_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBind_target_instance_listContext() *Bind_target_instance_listContext {
	var p = new(Bind_target_instance_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_bind_target_instance_list
	return p
}

func (*Bind_target_instance_listContext) IsBind_target_instance_listContext() {}

func NewBind_target_instance_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bind_target_instance_listContext {
	var p = new(Bind_target_instance_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_bind_target_instance_list

	return p
}

func (s *Bind_target_instance_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Bind_target_instance_listContext) AllBind_target_instance() []IBind_target_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBind_target_instanceContext)(nil)).Elem())
	var tst = make([]IBind_target_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBind_target_instanceContext)
		}
	}

	return tst
}

func (s *Bind_target_instance_listContext) Bind_target_instance(i int) IBind_target_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBind_target_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBind_target_instanceContext)
}

func (s *Bind_target_instance_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *Bind_target_instance_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *Bind_target_instance_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bind_target_instance_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Bind_target_instance_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterBind_target_instance_list(s)
	}
}

func (s *Bind_target_instance_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitBind_target_instance_list(s)
	}
}

func (p *SystemVerilogParser) Bind_target_instance_list() (localctx IBind_target_instance_listContext) {
	this := p
	_ = this

	localctx = NewBind_target_instance_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, SystemVerilogParserRULE_bind_target_instance_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2107)
		p.Bind_target_instance()
	}
	p.SetState(2112)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserCOMMA {
		{
			p.SetState(2108)
			p.Match(SystemVerilogParserCOMMA)
		}
		{
			p.SetState(2109)
			p.Bind_target_instance()
		}

		p.SetState(2114)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IBind_instantiationContext is an interface to support dynamic dispatch.
type IBind_instantiationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBind_instantiationContext differentiates from other interfaces.
	IsBind_instantiationContext()
}

type Bind_instantiationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBind_instantiationContext() *Bind_instantiationContext {
	var p = new(Bind_instantiationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_bind_instantiation
	return p
}

func (*Bind_instantiationContext) IsBind_instantiationContext() {}

func NewBind_instantiationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bind_instantiationContext {
	var p = new(Bind_instantiationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_bind_instantiation

	return p
}

func (s *Bind_instantiationContext) GetParser() antlr.Parser { return s.parser }

func (s *Bind_instantiationContext) Program_instantiation() IProgram_instantiationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProgram_instantiationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProgram_instantiationContext)
}

func (s *Bind_instantiationContext) Module_instantiation() IModule_instantiationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_instantiationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_instantiationContext)
}

func (s *Bind_instantiationContext) Interface_instantiation() IInterface_instantiationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_instantiationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterface_instantiationContext)
}

func (s *Bind_instantiationContext) Checker_instantiation() IChecker_instantiationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IChecker_instantiationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IChecker_instantiationContext)
}

func (s *Bind_instantiationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bind_instantiationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Bind_instantiationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterBind_instantiation(s)
	}
}

func (s *Bind_instantiationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitBind_instantiation(s)
	}
}

func (p *SystemVerilogParser) Bind_instantiation() (localctx IBind_instantiationContext) {
	this := p
	_ = this

	localctx = NewBind_instantiationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, SystemVerilogParserRULE_bind_instantiation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2119)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 154, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2115)
			p.Program_instantiation()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2116)
			p.Module_instantiation()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2117)
			p.Interface_instantiation()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2118)
			p.Checker_instantiation()
		}

	}

	return localctx
}

// IConfig_declarationContext is an interface to support dynamic dispatch.
type IConfig_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConfig_declarationContext differentiates from other interfaces.
	IsConfig_declarationContext()
}

type Config_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConfig_declarationContext() *Config_declarationContext {
	var p = new(Config_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_config_declaration
	return p
}

func (*Config_declarationContext) IsConfig_declarationContext() {}

func NewConfig_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Config_declarationContext {
	var p = new(Config_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_config_declaration

	return p
}

func (s *Config_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Config_declarationContext) KCONFIG() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKCONFIG, 0)
}

func (s *Config_declarationContext) AllConfig_identifier() []IConfig_identifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConfig_identifierContext)(nil)).Elem())
	var tst = make([]IConfig_identifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConfig_identifierContext)
		}
	}

	return tst
}

func (s *Config_declarationContext) Config_identifier(i int) IConfig_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConfig_identifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConfig_identifierContext)
}

func (s *Config_declarationContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserSEMI)
}

func (s *Config_declarationContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, i)
}

func (s *Config_declarationContext) Design_statement() IDesign_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDesign_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDesign_statementContext)
}

func (s *Config_declarationContext) KENDCONFIG() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKENDCONFIG, 0)
}

func (s *Config_declarationContext) AllLocal_parameter_declaration() []ILocal_parameter_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILocal_parameter_declarationContext)(nil)).Elem())
	var tst = make([]ILocal_parameter_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILocal_parameter_declarationContext)
		}
	}

	return tst
}

func (s *Config_declarationContext) Local_parameter_declaration(i int) ILocal_parameter_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILocal_parameter_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILocal_parameter_declarationContext)
}

func (s *Config_declarationContext) AllConfig_rule_statement() []IConfig_rule_statementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConfig_rule_statementContext)(nil)).Elem())
	var tst = make([]IConfig_rule_statementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConfig_rule_statementContext)
		}
	}

	return tst
}

func (s *Config_declarationContext) Config_rule_statement(i int) IConfig_rule_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConfig_rule_statementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConfig_rule_statementContext)
}

func (s *Config_declarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOLON, 0)
}

func (s *Config_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Config_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Config_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterConfig_declaration(s)
	}
}

func (s *Config_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitConfig_declaration(s)
	}
}

func (p *SystemVerilogParser) Config_declaration() (localctx IConfig_declarationContext) {
	this := p
	_ = this

	localctx = NewConfig_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, SystemVerilogParserRULE_config_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2121)
		p.Match(SystemVerilogParserKCONFIG)
	}
	{
		p.SetState(2122)
		p.Config_identifier()
	}
	{
		p.SetState(2123)
		p.Match(SystemVerilogParserSEMI)
	}
	p.SetState(2129)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserKLOCALPARAM {
		{
			p.SetState(2124)
			p.Local_parameter_declaration()
		}
		{
			p.SetState(2125)
			p.Match(SystemVerilogParserSEMI)
		}

		p.SetState(2131)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2132)
		p.Design_statement()
	}
	p.SetState(2136)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserKCELL || _la == SystemVerilogParserKDEFAULT || _la == SystemVerilogParserKINSTANCE {
		{
			p.SetState(2133)
			p.Config_rule_statement()
		}

		p.SetState(2138)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2139)
		p.Match(SystemVerilogParserKENDCONFIG)
	}
	p.SetState(2142)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserCOLON {
		{
			p.SetState(2140)
			p.Match(SystemVerilogParserCOLON)
		}
		{
			p.SetState(2141)
			p.Config_identifier()
		}

	}

	return localctx
}

// IDesign_statementContext is an interface to support dynamic dispatch.
type IDesign_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDesign_statementContext differentiates from other interfaces.
	IsDesign_statementContext()
}

type Design_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDesign_statementContext() *Design_statementContext {
	var p = new(Design_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_design_statement
	return p
}

func (*Design_statementContext) IsDesign_statementContext() {}

func NewDesign_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Design_statementContext {
	var p = new(Design_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_design_statement

	return p
}

func (s *Design_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Design_statementContext) KDESIGN() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKDESIGN, 0)
}

func (s *Design_statementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Design_statementContext) AllCell_identifier() []ICell_identifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICell_identifierContext)(nil)).Elem())
	var tst = make([]ICell_identifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICell_identifierContext)
		}
	}

	return tst
}

func (s *Design_statementContext) Cell_identifier(i int) ICell_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICell_identifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICell_identifierContext)
}

func (s *Design_statementContext) AllLibrary_identifier() []ILibrary_identifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILibrary_identifierContext)(nil)).Elem())
	var tst = make([]ILibrary_identifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILibrary_identifierContext)
		}
	}

	return tst
}

func (s *Design_statementContext) Library_identifier(i int) ILibrary_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibrary_identifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILibrary_identifierContext)
}

func (s *Design_statementContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserDOT)
}

func (s *Design_statementContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserDOT, i)
}

func (s *Design_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Design_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Design_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterDesign_statement(s)
	}
}

func (s *Design_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitDesign_statement(s)
	}
}

func (p *SystemVerilogParser) Design_statement() (localctx IDesign_statementContext) {
	this := p
	_ = this

	localctx = NewDesign_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, SystemVerilogParserRULE_design_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2144)
		p.Match(SystemVerilogParserKDESIGN)
	}
	p.SetState(2153)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserSIMPLE_IDENTIFIER {
		p.SetState(2148)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 158, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2145)
				p.Library_identifier()
			}
			{
				p.SetState(2146)
				p.Match(SystemVerilogParserDOT)
			}

		}
		{
			p.SetState(2150)
			p.Cell_identifier()
		}

		p.SetState(2155)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2156)
		p.Match(SystemVerilogParserSEMI)
	}

	return localctx
}

// IConfig_rule_statementContext is an interface to support dynamic dispatch.
type IConfig_rule_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConfig_rule_statementContext differentiates from other interfaces.
	IsConfig_rule_statementContext()
}

type Config_rule_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConfig_rule_statementContext() *Config_rule_statementContext {
	var p = new(Config_rule_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_config_rule_statement
	return p
}

func (*Config_rule_statementContext) IsConfig_rule_statementContext() {}

func NewConfig_rule_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Config_rule_statementContext {
	var p = new(Config_rule_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_config_rule_statement

	return p
}

func (s *Config_rule_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Config_rule_statementContext) Liblist_clause() ILiblist_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiblist_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiblist_clauseContext)
}

func (s *Config_rule_statementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Config_rule_statementContext) Default_clause() IDefault_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefault_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefault_clauseContext)
}

func (s *Config_rule_statementContext) Inst_clause() IInst_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInst_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInst_clauseContext)
}

func (s *Config_rule_statementContext) Cell_clause() ICell_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICell_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICell_clauseContext)
}

func (s *Config_rule_statementContext) Use_clause() IUse_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUse_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUse_clauseContext)
}

func (s *Config_rule_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Config_rule_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Config_rule_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterConfig_rule_statement(s)
	}
}

func (s *Config_rule_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitConfig_rule_statement(s)
	}
}

func (p *SystemVerilogParser) Config_rule_statement() (localctx IConfig_rule_statementContext) {
	this := p
	_ = this

	localctx = NewConfig_rule_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, SystemVerilogParserRULE_config_rule_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2173)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 162, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(2161)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SystemVerilogParserKDEFAULT:
			{
				p.SetState(2158)
				p.Default_clause()
			}

		case SystemVerilogParserKINSTANCE:
			{
				p.SetState(2159)
				p.Inst_clause()
			}

		case SystemVerilogParserKCELL:
			{
				p.SetState(2160)
				p.Cell_clause()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(2163)
			p.Liblist_clause()
		}
		{
			p.SetState(2164)
			p.Match(SystemVerilogParserSEMI)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(2168)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SystemVerilogParserKINSTANCE:
			{
				p.SetState(2166)
				p.Inst_clause()
			}

		case SystemVerilogParserKCELL:
			{
				p.SetState(2167)
				p.Cell_clause()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(2170)
			p.Use_clause()
		}
		{
			p.SetState(2171)
			p.Match(SystemVerilogParserSEMI)
		}

	}

	return localctx
}

// IDefault_clauseContext is an interface to support dynamic dispatch.
type IDefault_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDefault_clauseContext differentiates from other interfaces.
	IsDefault_clauseContext()
}

type Default_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefault_clauseContext() *Default_clauseContext {
	var p = new(Default_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_default_clause
	return p
}

func (*Default_clauseContext) IsDefault_clauseContext() {}

func NewDefault_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Default_clauseContext {
	var p = new(Default_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_default_clause

	return p
}

func (s *Default_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Default_clauseContext) KDEFAULT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKDEFAULT, 0)
}

func (s *Default_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Default_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Default_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterDefault_clause(s)
	}
}

func (s *Default_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitDefault_clause(s)
	}
}

func (p *SystemVerilogParser) Default_clause() (localctx IDefault_clauseContext) {
	this := p
	_ = this

	localctx = NewDefault_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, SystemVerilogParserRULE_default_clause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2175)
		p.Match(SystemVerilogParserKDEFAULT)
	}

	return localctx
}

// IInst_clauseContext is an interface to support dynamic dispatch.
type IInst_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInst_clauseContext differentiates from other interfaces.
	IsInst_clauseContext()
}

type Inst_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInst_clauseContext() *Inst_clauseContext {
	var p = new(Inst_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_inst_clause
	return p
}

func (*Inst_clauseContext) IsInst_clauseContext() {}

func NewInst_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Inst_clauseContext {
	var p = new(Inst_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_inst_clause

	return p
}

func (s *Inst_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Inst_clauseContext) KINSTANCE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKINSTANCE, 0)
}

func (s *Inst_clauseContext) Inst_name() IInst_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInst_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInst_nameContext)
}

func (s *Inst_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Inst_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Inst_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterInst_clause(s)
	}
}

func (s *Inst_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitInst_clause(s)
	}
}

func (p *SystemVerilogParser) Inst_clause() (localctx IInst_clauseContext) {
	this := p
	_ = this

	localctx = NewInst_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, SystemVerilogParserRULE_inst_clause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2177)
		p.Match(SystemVerilogParserKINSTANCE)
	}
	{
		p.SetState(2178)
		p.Inst_name()
	}

	return localctx
}

// IInst_nameContext is an interface to support dynamic dispatch.
type IInst_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInst_nameContext differentiates from other interfaces.
	IsInst_nameContext()
}

type Inst_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInst_nameContext() *Inst_nameContext {
	var p = new(Inst_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_inst_name
	return p
}

func (*Inst_nameContext) IsInst_nameContext() {}

func NewInst_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Inst_nameContext {
	var p = new(Inst_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_inst_name

	return p
}

func (s *Inst_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Inst_nameContext) Topmodule_identifier() ITopmodule_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITopmodule_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITopmodule_identifierContext)
}

func (s *Inst_nameContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserDOT)
}

func (s *Inst_nameContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserDOT, i)
}

func (s *Inst_nameContext) AllInstance_identifier() []IInstance_identifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInstance_identifierContext)(nil)).Elem())
	var tst = make([]IInstance_identifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInstance_identifierContext)
		}
	}

	return tst
}

func (s *Inst_nameContext) Instance_identifier(i int) IInstance_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInstance_identifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInstance_identifierContext)
}

func (s *Inst_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Inst_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Inst_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterInst_name(s)
	}
}

func (s *Inst_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitInst_name(s)
	}
}

func (p *SystemVerilogParser) Inst_name() (localctx IInst_nameContext) {
	this := p
	_ = this

	localctx = NewInst_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, SystemVerilogParserRULE_inst_name)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2180)
		p.Topmodule_identifier()
	}
	p.SetState(2185)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserDOT {
		{
			p.SetState(2181)
			p.Match(SystemVerilogParserDOT)
		}
		{
			p.SetState(2182)
			p.Instance_identifier()
		}

		p.SetState(2187)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ICell_clauseContext is an interface to support dynamic dispatch.
type ICell_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCell_clauseContext differentiates from other interfaces.
	IsCell_clauseContext()
}

type Cell_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCell_clauseContext() *Cell_clauseContext {
	var p = new(Cell_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_cell_clause
	return p
}

func (*Cell_clauseContext) IsCell_clauseContext() {}

func NewCell_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cell_clauseContext {
	var p = new(Cell_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_cell_clause

	return p
}

func (s *Cell_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Cell_clauseContext) KCELL() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKCELL, 0)
}

func (s *Cell_clauseContext) Cell_identifier() ICell_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICell_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICell_identifierContext)
}

func (s *Cell_clauseContext) Library_identifier() ILibrary_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibrary_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILibrary_identifierContext)
}

func (s *Cell_clauseContext) DOT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserDOT, 0)
}

func (s *Cell_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cell_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cell_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterCell_clause(s)
	}
}

func (s *Cell_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitCell_clause(s)
	}
}

func (p *SystemVerilogParser) Cell_clause() (localctx ICell_clauseContext) {
	this := p
	_ = this

	localctx = NewCell_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, SystemVerilogParserRULE_cell_clause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2188)
		p.Match(SystemVerilogParserKCELL)
	}
	p.SetState(2192)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 164, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2189)
			p.Library_identifier()
		}
		{
			p.SetState(2190)
			p.Match(SystemVerilogParserDOT)
		}

	}
	{
		p.SetState(2194)
		p.Cell_identifier()
	}

	return localctx
}

// ILiblist_clauseContext is an interface to support dynamic dispatch.
type ILiblist_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLiblist_clauseContext differentiates from other interfaces.
	IsLiblist_clauseContext()
}

type Liblist_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiblist_clauseContext() *Liblist_clauseContext {
	var p = new(Liblist_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_liblist_clause
	return p
}

func (*Liblist_clauseContext) IsLiblist_clauseContext() {}

func NewLiblist_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Liblist_clauseContext {
	var p = new(Liblist_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_liblist_clause

	return p
}

func (s *Liblist_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Liblist_clauseContext) KLIBLIST() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKLIBLIST, 0)
}

func (s *Liblist_clauseContext) AllLibrary_identifier() []ILibrary_identifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILibrary_identifierContext)(nil)).Elem())
	var tst = make([]ILibrary_identifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILibrary_identifierContext)
		}
	}

	return tst
}

func (s *Liblist_clauseContext) Library_identifier(i int) ILibrary_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibrary_identifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILibrary_identifierContext)
}

func (s *Liblist_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Liblist_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Liblist_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterLiblist_clause(s)
	}
}

func (s *Liblist_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitLiblist_clause(s)
	}
}

func (p *SystemVerilogParser) Liblist_clause() (localctx ILiblist_clauseContext) {
	this := p
	_ = this

	localctx = NewLiblist_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, SystemVerilogParserRULE_liblist_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2196)
		p.Match(SystemVerilogParserKLIBLIST)
	}
	p.SetState(2200)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserSIMPLE_IDENTIFIER {
		{
			p.SetState(2197)
			p.Library_identifier()
		}

		p.SetState(2202)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IUse_clauseContext is an interface to support dynamic dispatch.
type IUse_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUse_clauseContext differentiates from other interfaces.
	IsUse_clauseContext()
}

type Use_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUse_clauseContext() *Use_clauseContext {
	var p = new(Use_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_use_clause
	return p
}

func (*Use_clauseContext) IsUse_clauseContext() {}

func NewUse_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Use_clauseContext {
	var p = new(Use_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_use_clause

	return p
}

func (s *Use_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Use_clauseContext) KUSE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKUSE, 0)
}

func (s *Use_clauseContext) Cell_identifier() ICell_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICell_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICell_identifierContext)
}

func (s *Use_clauseContext) Library_identifier() ILibrary_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibrary_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILibrary_identifierContext)
}

func (s *Use_clauseContext) DOT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserDOT, 0)
}

func (s *Use_clauseContext) AllNamed_parameter_assignment() []INamed_parameter_assignmentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INamed_parameter_assignmentContext)(nil)).Elem())
	var tst = make([]INamed_parameter_assignmentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INamed_parameter_assignmentContext)
		}
	}

	return tst
}

func (s *Use_clauseContext) Named_parameter_assignment(i int) INamed_parameter_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamed_parameter_assignmentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INamed_parameter_assignmentContext)
}

func (s *Use_clauseContext) COLON() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOLON, 0)
}

func (s *Use_clauseContext) KCONFIG() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKCONFIG, 0)
}

func (s *Use_clauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *Use_clauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *Use_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Use_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Use_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterUse_clause(s)
	}
}

func (s *Use_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitUse_clause(s)
	}
}

func (p *SystemVerilogParser) Use_clause() (localctx IUse_clauseContext) {
	this := p
	_ = this

	localctx = NewUse_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, SystemVerilogParserRULE_use_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2237)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 172, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2203)
			p.Match(SystemVerilogParserKUSE)
		}
		p.SetState(2207)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 166, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2204)
				p.Library_identifier()
			}
			{
				p.SetState(2205)
				p.Match(SystemVerilogParserDOT)
			}

		}
		{
			p.SetState(2209)
			p.Cell_identifier()
		}
		p.SetState(2218)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserDOT {
			{
				p.SetState(2210)
				p.Named_parameter_assignment()
			}
			p.SetState(2215)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SystemVerilogParserCOMMA {
				{
					p.SetState(2211)
					p.Match(SystemVerilogParserCOMMA)
				}
				{
					p.SetState(2212)
					p.Named_parameter_assignment()
				}

				p.SetState(2217)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		p.SetState(2222)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserCOLON {
			{
				p.SetState(2220)
				p.Match(SystemVerilogParserCOLON)
			}
			{
				p.SetState(2221)
				p.Match(SystemVerilogParserKCONFIG)
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2224)
			p.Match(SystemVerilogParserKUSE)
		}
		{
			p.SetState(2225)
			p.Named_parameter_assignment()
		}
		p.SetState(2230)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserCOMMA {
			{
				p.SetState(2226)
				p.Match(SystemVerilogParserCOMMA)
			}
			{
				p.SetState(2227)
				p.Named_parameter_assignment()
			}

			p.SetState(2232)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(2235)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserCOLON {
			{
				p.SetState(2233)
				p.Match(SystemVerilogParserCOLON)
			}
			{
				p.SetState(2234)
				p.Match(SystemVerilogParserKCONFIG)
			}

		}

	}

	return localctx
}

// IInterface_or_generate_itemContext is an interface to support dynamic dispatch.
type IInterface_or_generate_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterface_or_generate_itemContext differentiates from other interfaces.
	IsInterface_or_generate_itemContext()
}

type Interface_or_generate_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterface_or_generate_itemContext() *Interface_or_generate_itemContext {
	var p = new(Interface_or_generate_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_interface_or_generate_item
	return p
}

func (*Interface_or_generate_itemContext) IsInterface_or_generate_itemContext() {}

func NewInterface_or_generate_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Interface_or_generate_itemContext {
	var p = new(Interface_or_generate_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_interface_or_generate_item

	return p
}

func (s *Interface_or_generate_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Interface_or_generate_itemContext) Module_common_item() IModule_common_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_common_itemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_common_itemContext)
}

func (s *Interface_or_generate_itemContext) Extern_tf_declaration() IExtern_tf_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtern_tf_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtern_tf_declarationContext)
}

func (s *Interface_or_generate_itemContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Interface_or_generate_itemContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Interface_or_generate_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Interface_or_generate_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Interface_or_generate_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterInterface_or_generate_item(s)
	}
}

func (s *Interface_or_generate_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitInterface_or_generate_item(s)
	}
}

func (p *SystemVerilogParser) Interface_or_generate_item() (localctx IInterface_or_generate_itemContext) {
	this := p
	_ = this

	localctx = NewInterface_or_generate_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, SystemVerilogParserRULE_interface_or_generate_item)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2242)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserLPS {
		{
			p.SetState(2239)
			p.Attribute_instance()
		}

		p.SetState(2244)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(2247)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserDERROR, SystemVerilogParserDFATAL, SystemVerilogParserDINFO, SystemVerilogParserDUNIT, SystemVerilogParserDWARNING, SystemVerilogParserSEMI, SystemVerilogParserLB, SystemVerilogParserKALIAS, SystemVerilogParserKALWAYS, SystemVerilogParserKALWAYS_COMB, SystemVerilogParserKALWAYS_FF, SystemVerilogParserKALWAYS_LATCH, SystemVerilogParserKASSERT, SystemVerilogParserKASSIGN, SystemVerilogParserKASSUME, SystemVerilogParserKAUTOMATIC, SystemVerilogParserKBIND, SystemVerilogParserKBIT, SystemVerilogParserKBYTE, SystemVerilogParserKCASE, SystemVerilogParserKCHANDLE, SystemVerilogParserKCHECKER, SystemVerilogParserKCLASS, SystemVerilogParserKCLOCKING, SystemVerilogParserKCONST, SystemVerilogParserKCONSTRAINT, SystemVerilogParserKCOVER, SystemVerilogParserKCOVERGROUP, SystemVerilogParserKDEFAULT, SystemVerilogParserKENUM, SystemVerilogParserKEVENT, SystemVerilogParserKEXPORT, SystemVerilogParserKFINAL, SystemVerilogParserKFOR, SystemVerilogParserKFUNCTION, SystemVerilogParserKGENVAR, SystemVerilogParserKGLOBAL, SystemVerilogParserKIF, SystemVerilogParserKIMPORT, SystemVerilogParserKINITIAL, SystemVerilogParserKINT, SystemVerilogParserKINTEGER, SystemVerilogParserKINTERCONNECT, SystemVerilogParserKLET, SystemVerilogParserKLOCALPARAM, SystemVerilogParserKLOGIC, SystemVerilogParserKLONGINT, SystemVerilogParserKNETTYPE, SystemVerilogParserKPARAMETER, SystemVerilogParserKPROPERTY, SystemVerilogParserKREAL, SystemVerilogParserKREALTIME, SystemVerilogParserKREG, SystemVerilogParserKRESTRICT, SystemVerilogParserKSEQUENCE, SystemVerilogParserKSHORTINT, SystemVerilogParserKSHORTREAL, SystemVerilogParserKSIGNED, SystemVerilogParserKSTATIC, SystemVerilogParserKSTRING, SystemVerilogParserKSTRUCT, SystemVerilogParserKSUPPLY0, SystemVerilogParserKSUPPLY1, SystemVerilogParserKTASK, SystemVerilogParserKTIME, SystemVerilogParserKTRI, SystemVerilogParserKTRI0, SystemVerilogParserKTRI1, SystemVerilogParserKTRIAND, SystemVerilogParserKTRIOR, SystemVerilogParserKTRIREG, SystemVerilogParserKTYPE, SystemVerilogParserKTYPEDEF, SystemVerilogParserKUNION, SystemVerilogParserKUNSIGNED, SystemVerilogParserKUWIRE, SystemVerilogParserKVAR, SystemVerilogParserKVIRTUAL, SystemVerilogParserKWAND, SystemVerilogParserKWIRE, SystemVerilogParserKWOR, SystemVerilogParserSIMPLE_IDENTIFIER:
		{
			p.SetState(2245)
			p.Module_common_item()
		}

	case SystemVerilogParserKEXTERN:
		{
			p.SetState(2246)
			p.Extern_tf_declaration()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IExtern_tf_declarationContext is an interface to support dynamic dispatch.
type IExtern_tf_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExtern_tf_declarationContext differentiates from other interfaces.
	IsExtern_tf_declarationContext()
}

type Extern_tf_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtern_tf_declarationContext() *Extern_tf_declarationContext {
	var p = new(Extern_tf_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_extern_tf_declaration
	return p
}

func (*Extern_tf_declarationContext) IsExtern_tf_declarationContext() {}

func NewExtern_tf_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Extern_tf_declarationContext {
	var p = new(Extern_tf_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_extern_tf_declaration

	return p
}

func (s *Extern_tf_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Extern_tf_declarationContext) KEXTERN() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKEXTERN, 0)
}

func (s *Extern_tf_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Extern_tf_declarationContext) Method_prototype() IMethod_prototypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMethod_prototypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMethod_prototypeContext)
}

func (s *Extern_tf_declarationContext) KFORKJOIN() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKFORKJOIN, 0)
}

func (s *Extern_tf_declarationContext) Task_prototype() ITask_prototypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITask_prototypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITask_prototypeContext)
}

func (s *Extern_tf_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Extern_tf_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Extern_tf_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterExtern_tf_declaration(s)
	}
}

func (s *Extern_tf_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitExtern_tf_declaration(s)
	}
}

func (p *SystemVerilogParser) Extern_tf_declaration() (localctx IExtern_tf_declarationContext) {
	this := p
	_ = this

	localctx = NewExtern_tf_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, SystemVerilogParserRULE_extern_tf_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2249)
		p.Match(SystemVerilogParserKEXTERN)
	}
	p.SetState(2253)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserKFUNCTION, SystemVerilogParserKTASK:
		{
			p.SetState(2250)
			p.Method_prototype()
		}

	case SystemVerilogParserKFORKJOIN:
		{
			p.SetState(2251)
			p.Match(SystemVerilogParserKFORKJOIN)
		}
		{
			p.SetState(2252)
			p.Task_prototype()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(2255)
		p.Match(SystemVerilogParserSEMI)
	}

	return localctx
}

// IInterface_itemContext is an interface to support dynamic dispatch.
type IInterface_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterface_itemContext differentiates from other interfaces.
	IsInterface_itemContext()
}

type Interface_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterface_itemContext() *Interface_itemContext {
	var p = new(Interface_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_interface_item
	return p
}

func (*Interface_itemContext) IsInterface_itemContext() {}

func NewInterface_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Interface_itemContext {
	var p = new(Interface_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_interface_item

	return p
}

func (s *Interface_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Interface_itemContext) Port_declaration() IPort_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPort_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPort_declarationContext)
}

func (s *Interface_itemContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Interface_itemContext) Non_port_interface_item() INon_port_interface_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INon_port_interface_itemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INon_port_interface_itemContext)
}

func (s *Interface_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Interface_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Interface_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterInterface_item(s)
	}
}

func (s *Interface_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitInterface_item(s)
	}
}

func (p *SystemVerilogParser) Interface_item() (localctx IInterface_itemContext) {
	this := p
	_ = this

	localctx = NewInterface_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, SystemVerilogParserRULE_interface_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2261)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 176, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2257)
			p.Port_declaration()
		}
		{
			p.SetState(2258)
			p.Match(SystemVerilogParserSEMI)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2260)
			p.Non_port_interface_item()
		}

	}

	return localctx
}

// INon_port_interface_itemContext is an interface to support dynamic dispatch.
type INon_port_interface_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNon_port_interface_itemContext differentiates from other interfaces.
	IsNon_port_interface_itemContext()
}

type Non_port_interface_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNon_port_interface_itemContext() *Non_port_interface_itemContext {
	var p = new(Non_port_interface_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_non_port_interface_item
	return p
}

func (*Non_port_interface_itemContext) IsNon_port_interface_itemContext() {}

func NewNon_port_interface_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Non_port_interface_itemContext {
	var p = new(Non_port_interface_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_non_port_interface_item

	return p
}

func (s *Non_port_interface_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Non_port_interface_itemContext) Generate_region() IGenerate_regionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenerate_regionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenerate_regionContext)
}

func (s *Non_port_interface_itemContext) Interface_or_generate_item() IInterface_or_generate_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_or_generate_itemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterface_or_generate_itemContext)
}

func (s *Non_port_interface_itemContext) Program_declaration() IProgram_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProgram_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProgram_declarationContext)
}

func (s *Non_port_interface_itemContext) Modport_declaration() IModport_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModport_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModport_declarationContext)
}

func (s *Non_port_interface_itemContext) Interface_declaration() IInterface_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterface_declarationContext)
}

func (s *Non_port_interface_itemContext) Timeunits_declaration() ITimeunits_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITimeunits_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITimeunits_declarationContext)
}

func (s *Non_port_interface_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Non_port_interface_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Non_port_interface_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterNon_port_interface_item(s)
	}
}

func (s *Non_port_interface_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitNon_port_interface_item(s)
	}
}

func (p *SystemVerilogParser) Non_port_interface_item() (localctx INon_port_interface_itemContext) {
	this := p
	_ = this

	localctx = NewNon_port_interface_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, SystemVerilogParserRULE_non_port_interface_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2269)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 177, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2263)
			p.Generate_region()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2264)
			p.Interface_or_generate_item()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2265)
			p.Program_declaration()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2266)
			p.Modport_declaration()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2267)
			p.Interface_declaration()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2268)
			p.Timeunits_declaration()
		}

	}

	return localctx
}

// IProgram_itemContext is an interface to support dynamic dispatch.
type IProgram_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProgram_itemContext differentiates from other interfaces.
	IsProgram_itemContext()
}

type Program_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProgram_itemContext() *Program_itemContext {
	var p = new(Program_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_program_item
	return p
}

func (*Program_itemContext) IsProgram_itemContext() {}

func NewProgram_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Program_itemContext {
	var p = new(Program_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_program_item

	return p
}

func (s *Program_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Program_itemContext) Port_declaration() IPort_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPort_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPort_declarationContext)
}

func (s *Program_itemContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Program_itemContext) Non_port_program_item() INon_port_program_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INon_port_program_itemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INon_port_program_itemContext)
}

func (s *Program_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Program_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Program_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterProgram_item(s)
	}
}

func (s *Program_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitProgram_item(s)
	}
}

func (p *SystemVerilogParser) Program_item() (localctx IProgram_itemContext) {
	this := p
	_ = this

	localctx = NewProgram_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, SystemVerilogParserRULE_program_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2275)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 178, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2271)
			p.Port_declaration()
		}
		{
			p.SetState(2272)
			p.Match(SystemVerilogParserSEMI)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2274)
			p.Non_port_program_item()
		}

	}

	return localctx
}

// INon_port_program_itemContext is an interface to support dynamic dispatch.
type INon_port_program_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNon_port_program_itemContext differentiates from other interfaces.
	IsNon_port_program_itemContext()
}

type Non_port_program_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNon_port_program_itemContext() *Non_port_program_itemContext {
	var p = new(Non_port_program_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_non_port_program_item
	return p
}

func (*Non_port_program_itemContext) IsNon_port_program_itemContext() {}

func NewNon_port_program_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Non_port_program_itemContext {
	var p = new(Non_port_program_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_non_port_program_item

	return p
}

func (s *Non_port_program_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Non_port_program_itemContext) Continuous_assign() IContinuous_assignContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IContinuous_assignContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IContinuous_assignContext)
}

func (s *Non_port_program_itemContext) Module_or_generate_item_declaration() IModule_or_generate_item_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_or_generate_item_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_or_generate_item_declarationContext)
}

func (s *Non_port_program_itemContext) Initial_construct() IInitial_constructContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInitial_constructContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInitial_constructContext)
}

func (s *Non_port_program_itemContext) Final_construct() IFinal_constructContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFinal_constructContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFinal_constructContext)
}

func (s *Non_port_program_itemContext) Concurrent_assertion_item() IConcurrent_assertion_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConcurrent_assertion_itemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConcurrent_assertion_itemContext)
}

func (s *Non_port_program_itemContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Non_port_program_itemContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Non_port_program_itemContext) Timeunits_declaration() ITimeunits_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITimeunits_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITimeunits_declarationContext)
}

func (s *Non_port_program_itemContext) Program_generate_item() IProgram_generate_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProgram_generate_itemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProgram_generate_itemContext)
}

func (s *Non_port_program_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Non_port_program_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Non_port_program_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterNon_port_program_item(s)
	}
}

func (s *Non_port_program_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitNon_port_program_item(s)
	}
}

func (p *SystemVerilogParser) Non_port_program_item() (localctx INon_port_program_itemContext) {
	this := p
	_ = this

	localctx = NewNon_port_program_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, SystemVerilogParserRULE_non_port_program_item)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2292)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserDUNIT, SystemVerilogParserLPS, SystemVerilogParserSEMI, SystemVerilogParserLB, SystemVerilogParserKASSERT, SystemVerilogParserKASSIGN, SystemVerilogParserKASSUME, SystemVerilogParserKAUTOMATIC, SystemVerilogParserKBIT, SystemVerilogParserKBYTE, SystemVerilogParserKCHANDLE, SystemVerilogParserKCHECKER, SystemVerilogParserKCLASS, SystemVerilogParserKCLOCKING, SystemVerilogParserKCONST, SystemVerilogParserKCONSTRAINT, SystemVerilogParserKCOVER, SystemVerilogParserKCOVERGROUP, SystemVerilogParserKDEFAULT, SystemVerilogParserKENUM, SystemVerilogParserKEVENT, SystemVerilogParserKEXPORT, SystemVerilogParserKFINAL, SystemVerilogParserKFUNCTION, SystemVerilogParserKGENVAR, SystemVerilogParserKGLOBAL, SystemVerilogParserKIMPORT, SystemVerilogParserKINITIAL, SystemVerilogParserKINT, SystemVerilogParserKINTEGER, SystemVerilogParserKINTERCONNECT, SystemVerilogParserKLET, SystemVerilogParserKLOCALPARAM, SystemVerilogParserKLOGIC, SystemVerilogParserKLONGINT, SystemVerilogParserKNETTYPE, SystemVerilogParserKPARAMETER, SystemVerilogParserKPROPERTY, SystemVerilogParserKREAL, SystemVerilogParserKREALTIME, SystemVerilogParserKREG, SystemVerilogParserKRESTRICT, SystemVerilogParserKSEQUENCE, SystemVerilogParserKSHORTINT, SystemVerilogParserKSHORTREAL, SystemVerilogParserKSIGNED, SystemVerilogParserKSTATIC, SystemVerilogParserKSTRING, SystemVerilogParserKSTRUCT, SystemVerilogParserKSUPPLY0, SystemVerilogParserKSUPPLY1, SystemVerilogParserKTASK, SystemVerilogParserKTIME, SystemVerilogParserKTRI, SystemVerilogParserKTRI0, SystemVerilogParserKTRI1, SystemVerilogParserKTRIAND, SystemVerilogParserKTRIOR, SystemVerilogParserKTRIREG, SystemVerilogParserKTYPE, SystemVerilogParserKTYPEDEF, SystemVerilogParserKUNION, SystemVerilogParserKUNSIGNED, SystemVerilogParserKUWIRE, SystemVerilogParserKVAR, SystemVerilogParserKVIRTUAL, SystemVerilogParserKWAND, SystemVerilogParserKWIRE, SystemVerilogParserKWOR, SystemVerilogParserSIMPLE_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(2280)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserLPS {
			{
				p.SetState(2277)
				p.Attribute_instance()
			}

			p.SetState(2282)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(2288)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 180, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(2283)
				p.Continuous_assign()
			}

		case 2:
			{
				p.SetState(2284)
				p.Module_or_generate_item_declaration()
			}

		case 3:
			{
				p.SetState(2285)
				p.Initial_construct()
			}

		case 4:
			{
				p.SetState(2286)
				p.Final_construct()
			}

		case 5:
			{
				p.SetState(2287)
				p.Concurrent_assertion_item()
			}

		}

	case SystemVerilogParserKTIMEPRECISION, SystemVerilogParserKTIMEUNIT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2290)
			p.Timeunits_declaration()
		}

	case SystemVerilogParserDERROR, SystemVerilogParserDFATAL, SystemVerilogParserDINFO, SystemVerilogParserDWARNING, SystemVerilogParserKCASE, SystemVerilogParserKFOR, SystemVerilogParserKGENERATE, SystemVerilogParserKIF:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2291)
			p.Program_generate_item()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IProgram_generate_itemContext is an interface to support dynamic dispatch.
type IProgram_generate_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProgram_generate_itemContext differentiates from other interfaces.
	IsProgram_generate_itemContext()
}

type Program_generate_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProgram_generate_itemContext() *Program_generate_itemContext {
	var p = new(Program_generate_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_program_generate_item
	return p
}

func (*Program_generate_itemContext) IsProgram_generate_itemContext() {}

func NewProgram_generate_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Program_generate_itemContext {
	var p = new(Program_generate_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_program_generate_item

	return p
}

func (s *Program_generate_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Program_generate_itemContext) Loop_generate_construct() ILoop_generate_constructContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILoop_generate_constructContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILoop_generate_constructContext)
}

func (s *Program_generate_itemContext) Conditional_generate_construct() IConditional_generate_constructContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditional_generate_constructContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditional_generate_constructContext)
}

func (s *Program_generate_itemContext) Generate_region() IGenerate_regionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenerate_regionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenerate_regionContext)
}

func (s *Program_generate_itemContext) Elaboration_system_task() IElaboration_system_taskContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElaboration_system_taskContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElaboration_system_taskContext)
}

func (s *Program_generate_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Program_generate_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Program_generate_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterProgram_generate_item(s)
	}
}

func (s *Program_generate_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitProgram_generate_item(s)
	}
}

func (p *SystemVerilogParser) Program_generate_item() (localctx IProgram_generate_itemContext) {
	this := p
	_ = this

	localctx = NewProgram_generate_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, SystemVerilogParserRULE_program_generate_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2298)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserKFOR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2294)
			p.Loop_generate_construct()
		}

	case SystemVerilogParserKCASE, SystemVerilogParserKIF:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2295)
			p.Conditional_generate_construct()
		}

	case SystemVerilogParserKGENERATE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2296)
			p.Generate_region()
		}

	case SystemVerilogParserDERROR, SystemVerilogParserDFATAL, SystemVerilogParserDINFO, SystemVerilogParserDWARNING:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2297)
			p.Elaboration_system_task()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IChecker_port_listContext is an interface to support dynamic dispatch.
type IChecker_port_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsChecker_port_listContext differentiates from other interfaces.
	IsChecker_port_listContext()
}

type Checker_port_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChecker_port_listContext() *Checker_port_listContext {
	var p = new(Checker_port_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_checker_port_list
	return p
}

func (*Checker_port_listContext) IsChecker_port_listContext() {}

func NewChecker_port_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Checker_port_listContext {
	var p = new(Checker_port_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_checker_port_list

	return p
}

func (s *Checker_port_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Checker_port_listContext) AllChecker_port_item() []IChecker_port_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IChecker_port_itemContext)(nil)).Elem())
	var tst = make([]IChecker_port_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IChecker_port_itemContext)
		}
	}

	return tst
}

func (s *Checker_port_listContext) Checker_port_item(i int) IChecker_port_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IChecker_port_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IChecker_port_itemContext)
}

func (s *Checker_port_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *Checker_port_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *Checker_port_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Checker_port_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Checker_port_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterChecker_port_list(s)
	}
}

func (s *Checker_port_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitChecker_port_list(s)
	}
}

func (p *SystemVerilogParser) Checker_port_list() (localctx IChecker_port_listContext) {
	this := p
	_ = this

	localctx = NewChecker_port_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, SystemVerilogParserRULE_checker_port_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2300)
		p.Checker_port_item()
	}
	p.SetState(2305)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserCOMMA {
		{
			p.SetState(2301)
			p.Match(SystemVerilogParserCOMMA)
		}
		{
			p.SetState(2302)
			p.Checker_port_item()
		}

		p.SetState(2307)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IChecker_port_itemContext is an interface to support dynamic dispatch.
type IChecker_port_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsChecker_port_itemContext differentiates from other interfaces.
	IsChecker_port_itemContext()
}

type Checker_port_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChecker_port_itemContext() *Checker_port_itemContext {
	var p = new(Checker_port_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_checker_port_item
	return p
}

func (*Checker_port_itemContext) IsChecker_port_itemContext() {}

func NewChecker_port_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Checker_port_itemContext {
	var p = new(Checker_port_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_checker_port_item

	return p
}

func (s *Checker_port_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Checker_port_itemContext) Property_formal_type() IProperty_formal_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProperty_formal_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProperty_formal_typeContext)
}

func (s *Checker_port_itemContext) Formal_port_identifier() IFormal_port_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormal_port_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFormal_port_identifierContext)
}

func (s *Checker_port_itemContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Checker_port_itemContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Checker_port_itemContext) Checker_port_direction() IChecker_port_directionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IChecker_port_directionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IChecker_port_directionContext)
}

func (s *Checker_port_itemContext) AllVariable_dimension() []IVariable_dimensionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariable_dimensionContext)(nil)).Elem())
	var tst = make([]IVariable_dimensionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariable_dimensionContext)
		}
	}

	return tst
}

func (s *Checker_port_itemContext) Variable_dimension(i int) IVariable_dimensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_dimensionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariable_dimensionContext)
}

func (s *Checker_port_itemContext) EQ() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserEQ, 0)
}

func (s *Checker_port_itemContext) Property_actual_arg() IProperty_actual_argContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProperty_actual_argContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProperty_actual_argContext)
}

func (s *Checker_port_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Checker_port_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Checker_port_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterChecker_port_item(s)
	}
}

func (s *Checker_port_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitChecker_port_item(s)
	}
}

func (p *SystemVerilogParser) Checker_port_item() (localctx IChecker_port_itemContext) {
	this := p
	_ = this

	localctx = NewChecker_port_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, SystemVerilogParserRULE_checker_port_item)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2311)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserLPS {
		{
			p.SetState(2308)
			p.Attribute_instance()
		}

		p.SetState(2313)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(2315)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserKINPUT || _la == SystemVerilogParserKOUTPUT {
		{
			p.SetState(2314)
			p.Checker_port_direction()
		}

	}
	{
		p.SetState(2317)
		p.Property_formal_type()
	}
	{
		p.SetState(2318)
		p.Formal_port_identifier()
	}
	p.SetState(2322)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserLB {
		{
			p.SetState(2319)
			p.Variable_dimension()
		}

		p.SetState(2324)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(2327)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserEQ {
		{
			p.SetState(2325)
			p.Match(SystemVerilogParserEQ)
		}
		{
			p.SetState(2326)
			p.Property_actual_arg()
		}

	}

	return localctx
}

// IChecker_port_directionContext is an interface to support dynamic dispatch.
type IChecker_port_directionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsChecker_port_directionContext differentiates from other interfaces.
	IsChecker_port_directionContext()
}

type Checker_port_directionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChecker_port_directionContext() *Checker_port_directionContext {
	var p = new(Checker_port_directionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_checker_port_direction
	return p
}

func (*Checker_port_directionContext) IsChecker_port_directionContext() {}

func NewChecker_port_directionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Checker_port_directionContext {
	var p = new(Checker_port_directionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_checker_port_direction

	return p
}

func (s *Checker_port_directionContext) GetParser() antlr.Parser { return s.parser }

func (s *Checker_port_directionContext) KINPUT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKINPUT, 0)
}

func (s *Checker_port_directionContext) KOUTPUT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKOUTPUT, 0)
}

func (s *Checker_port_directionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Checker_port_directionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Checker_port_directionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterChecker_port_direction(s)
	}
}

func (s *Checker_port_directionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitChecker_port_direction(s)
	}
}

func (p *SystemVerilogParser) Checker_port_direction() (localctx IChecker_port_directionContext) {
	this := p
	_ = this

	localctx = NewChecker_port_directionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, SystemVerilogParserRULE_checker_port_direction)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2329)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SystemVerilogParserKINPUT || _la == SystemVerilogParserKOUTPUT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IChecker_or_generate_itemContext is an interface to support dynamic dispatch.
type IChecker_or_generate_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsChecker_or_generate_itemContext differentiates from other interfaces.
	IsChecker_or_generate_itemContext()
}

type Checker_or_generate_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChecker_or_generate_itemContext() *Checker_or_generate_itemContext {
	var p = new(Checker_or_generate_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_checker_or_generate_item
	return p
}

func (*Checker_or_generate_itemContext) IsChecker_or_generate_itemContext() {}

func NewChecker_or_generate_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Checker_or_generate_itemContext {
	var p = new(Checker_or_generate_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_checker_or_generate_item

	return p
}

func (s *Checker_or_generate_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Checker_or_generate_itemContext) Checker_or_generate_item_declaration() IChecker_or_generate_item_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IChecker_or_generate_item_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IChecker_or_generate_item_declarationContext)
}

func (s *Checker_or_generate_itemContext) Initial_construct() IInitial_constructContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInitial_constructContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInitial_constructContext)
}

func (s *Checker_or_generate_itemContext) Always_construct() IAlways_constructContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlways_constructContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlways_constructContext)
}

func (s *Checker_or_generate_itemContext) Final_construct() IFinal_constructContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFinal_constructContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFinal_constructContext)
}

func (s *Checker_or_generate_itemContext) Assertion_item() IAssertion_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssertion_itemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssertion_itemContext)
}

func (s *Checker_or_generate_itemContext) Continuous_assign() IContinuous_assignContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IContinuous_assignContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IContinuous_assignContext)
}

func (s *Checker_or_generate_itemContext) Checker_generate_item() IChecker_generate_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IChecker_generate_itemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IChecker_generate_itemContext)
}

func (s *Checker_or_generate_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Checker_or_generate_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Checker_or_generate_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterChecker_or_generate_item(s)
	}
}

func (s *Checker_or_generate_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitChecker_or_generate_item(s)
	}
}

func (p *SystemVerilogParser) Checker_or_generate_item() (localctx IChecker_or_generate_itemContext) {
	this := p
	_ = this

	localctx = NewChecker_or_generate_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, SystemVerilogParserRULE_checker_or_generate_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2338)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 188, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2331)
			p.Checker_or_generate_item_declaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2332)
			p.Initial_construct()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2333)
			p.Always_construct()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2334)
			p.Final_construct()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2335)
			p.Assertion_item()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2336)
			p.Continuous_assign()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2337)
			p.Checker_generate_item()
		}

	}

	return localctx
}

// IChecker_or_generate_item_declarationContext is an interface to support dynamic dispatch.
type IChecker_or_generate_item_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsChecker_or_generate_item_declarationContext differentiates from other interfaces.
	IsChecker_or_generate_item_declarationContext()
}

type Checker_or_generate_item_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChecker_or_generate_item_declarationContext() *Checker_or_generate_item_declarationContext {
	var p = new(Checker_or_generate_item_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_checker_or_generate_item_declaration
	return p
}

func (*Checker_or_generate_item_declarationContext) IsChecker_or_generate_item_declarationContext() {}

func NewChecker_or_generate_item_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Checker_or_generate_item_declarationContext {
	var p = new(Checker_or_generate_item_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_checker_or_generate_item_declaration

	return p
}

func (s *Checker_or_generate_item_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Checker_or_generate_item_declarationContext) Data_declaration() IData_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IData_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IData_declarationContext)
}

func (s *Checker_or_generate_item_declarationContext) KRAND() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKRAND, 0)
}

func (s *Checker_or_generate_item_declarationContext) Function_declaration() IFunction_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_declarationContext)
}

func (s *Checker_or_generate_item_declarationContext) Checker_declaration() IChecker_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IChecker_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IChecker_declarationContext)
}

func (s *Checker_or_generate_item_declarationContext) Assertion_item_declaration() IAssertion_item_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssertion_item_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssertion_item_declarationContext)
}

func (s *Checker_or_generate_item_declarationContext) Covergroup_declaration() ICovergroup_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICovergroup_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICovergroup_declarationContext)
}

func (s *Checker_or_generate_item_declarationContext) Genvar_declaration() IGenvar_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenvar_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenvar_declarationContext)
}

func (s *Checker_or_generate_item_declarationContext) Clocking_declaration() IClocking_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClocking_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClocking_declarationContext)
}

func (s *Checker_or_generate_item_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Checker_or_generate_item_declarationContext) KDEFAULT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKDEFAULT, 0)
}

func (s *Checker_or_generate_item_declarationContext) KCLOCKING() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKCLOCKING, 0)
}

func (s *Checker_or_generate_item_declarationContext) Clocking_identifier() IClocking_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClocking_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClocking_identifierContext)
}

func (s *Checker_or_generate_item_declarationContext) KDISABLE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKDISABLE, 0)
}

func (s *Checker_or_generate_item_declarationContext) KIFF() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKIFF, 0)
}

func (s *Checker_or_generate_item_declarationContext) Expression_or_dist() IExpression_or_distContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpression_or_distContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpression_or_distContext)
}

func (s *Checker_or_generate_item_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Checker_or_generate_item_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Checker_or_generate_item_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterChecker_or_generate_item_declaration(s)
	}
}

func (s *Checker_or_generate_item_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitChecker_or_generate_item_declaration(s)
	}
}

func (p *SystemVerilogParser) Checker_or_generate_item_declaration() (localctx IChecker_or_generate_item_declarationContext) {
	this := p
	_ = this

	localctx = NewChecker_or_generate_item_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, SystemVerilogParserRULE_checker_or_generate_item_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2361)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 192, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(2341)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserKRAND {
			{
				p.SetState(2340)
				p.Match(SystemVerilogParserKRAND)
			}

		}
		{
			p.SetState(2343)
			p.Data_declaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2344)
			p.Function_declaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2345)
			p.Checker_declaration()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2346)
			p.Assertion_item_declaration()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2347)
			p.Covergroup_declaration()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2348)
			p.Genvar_declaration()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2349)
			p.Clocking_declaration()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		p.SetState(2358)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserKDEFAULT {
			{
				p.SetState(2350)
				p.Match(SystemVerilogParserKDEFAULT)
			}
			p.SetState(2356)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case SystemVerilogParserKCLOCKING:
				{
					p.SetState(2351)
					p.Match(SystemVerilogParserKCLOCKING)
				}
				{
					p.SetState(2352)
					p.Clocking_identifier()
				}

			case SystemVerilogParserKDISABLE:
				{
					p.SetState(2353)
					p.Match(SystemVerilogParserKDISABLE)
				}
				{
					p.SetState(2354)
					p.Match(SystemVerilogParserKIFF)
				}
				{
					p.SetState(2355)
					p.Expression_or_dist()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		}
		{
			p.SetState(2360)
			p.Match(SystemVerilogParserSEMI)
		}

	}

	return localctx
}

// IChecker_generate_itemContext is an interface to support dynamic dispatch.
type IChecker_generate_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsChecker_generate_itemContext differentiates from other interfaces.
	IsChecker_generate_itemContext()
}

type Checker_generate_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChecker_generate_itemContext() *Checker_generate_itemContext {
	var p = new(Checker_generate_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_checker_generate_item
	return p
}

func (*Checker_generate_itemContext) IsChecker_generate_itemContext() {}

func NewChecker_generate_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Checker_generate_itemContext {
	var p = new(Checker_generate_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_checker_generate_item

	return p
}

func (s *Checker_generate_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Checker_generate_itemContext) Loop_generate_construct() ILoop_generate_constructContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILoop_generate_constructContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILoop_generate_constructContext)
}

func (s *Checker_generate_itemContext) Conditional_generate_construct() IConditional_generate_constructContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditional_generate_constructContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditional_generate_constructContext)
}

func (s *Checker_generate_itemContext) Generate_region() IGenerate_regionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenerate_regionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenerate_regionContext)
}

func (s *Checker_generate_itemContext) Elaboration_system_task() IElaboration_system_taskContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElaboration_system_taskContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElaboration_system_taskContext)
}

func (s *Checker_generate_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Checker_generate_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Checker_generate_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterChecker_generate_item(s)
	}
}

func (s *Checker_generate_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitChecker_generate_item(s)
	}
}

func (p *SystemVerilogParser) Checker_generate_item() (localctx IChecker_generate_itemContext) {
	this := p
	_ = this

	localctx = NewChecker_generate_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, SystemVerilogParserRULE_checker_generate_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2367)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserKFOR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2363)
			p.Loop_generate_construct()
		}

	case SystemVerilogParserKCASE, SystemVerilogParserKIF:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2364)
			p.Conditional_generate_construct()
		}

	case SystemVerilogParserKGENERATE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2365)
			p.Generate_region()
		}

	case SystemVerilogParserDERROR, SystemVerilogParserDFATAL, SystemVerilogParserDINFO, SystemVerilogParserDWARNING:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2366)
			p.Elaboration_system_task()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IClass_itemContext is an interface to support dynamic dispatch.
type IClass_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClass_itemContext differentiates from other interfaces.
	IsClass_itemContext()
}

type Class_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClass_itemContext() *Class_itemContext {
	var p = new(Class_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_class_item
	return p
}

func (*Class_itemContext) IsClass_itemContext() {}

func NewClass_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Class_itemContext {
	var p = new(Class_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_class_item

	return p
}

func (s *Class_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Class_itemContext) Class_property() IClass_propertyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_propertyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClass_propertyContext)
}

func (s *Class_itemContext) Class_method() IClass_methodContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_methodContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClass_methodContext)
}

func (s *Class_itemContext) Class_constraint() IClass_constraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_constraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClass_constraintContext)
}

func (s *Class_itemContext) Class_declaration() IClass_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClass_declarationContext)
}

func (s *Class_itemContext) Covergroup_declaration() ICovergroup_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICovergroup_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICovergroup_declarationContext)
}

func (s *Class_itemContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Class_itemContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Class_itemContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Class_itemContext) Local_parameter_declaration() ILocal_parameter_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILocal_parameter_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILocal_parameter_declarationContext)
}

func (s *Class_itemContext) Parameter_declaration() IParameter_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_declarationContext)
}

func (s *Class_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Class_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Class_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterClass_item(s)
	}
}

func (s *Class_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitClass_item(s)
	}
}

func (p *SystemVerilogParser) Class_item() (localctx IClass_itemContext) {
	this := p
	_ = this

	localctx = NewClass_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, SystemVerilogParserRULE_class_item)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2387)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserDUNIT, SystemVerilogParserLPS, SystemVerilogParserLB, SystemVerilogParserKAUTOMATIC, SystemVerilogParserKBIT, SystemVerilogParserKBYTE, SystemVerilogParserKCHANDLE, SystemVerilogParserKCLASS, SystemVerilogParserKCONST, SystemVerilogParserKCONSTRAINT, SystemVerilogParserKCOVERGROUP, SystemVerilogParserKENUM, SystemVerilogParserKEVENT, SystemVerilogParserKEXTERN, SystemVerilogParserKFUNCTION, SystemVerilogParserKIMPORT, SystemVerilogParserKINT, SystemVerilogParserKINTEGER, SystemVerilogParserKLOCAL, SystemVerilogParserKLOGIC, SystemVerilogParserKLONGINT, SystemVerilogParserKNETTYPE, SystemVerilogParserKPROTECTED, SystemVerilogParserKPURE, SystemVerilogParserKRAND, SystemVerilogParserKRANDC, SystemVerilogParserKREAL, SystemVerilogParserKREALTIME, SystemVerilogParserKREG, SystemVerilogParserKSHORTINT, SystemVerilogParserKSHORTREAL, SystemVerilogParserKSIGNED, SystemVerilogParserKSTATIC, SystemVerilogParserKSTRING, SystemVerilogParserKSTRUCT, SystemVerilogParserKTASK, SystemVerilogParserKTIME, SystemVerilogParserKTYPE, SystemVerilogParserKTYPEDEF, SystemVerilogParserKUNION, SystemVerilogParserKUNSIGNED, SystemVerilogParserKVAR, SystemVerilogParserKVIRTUAL, SystemVerilogParserSIMPLE_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(2372)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserLPS {
			{
				p.SetState(2369)
				p.Attribute_instance()
			}

			p.SetState(2374)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(2380)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 195, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(2375)
				p.Class_property()
			}

		case 2:
			{
				p.SetState(2376)
				p.Class_method()
			}

		case 3:
			{
				p.SetState(2377)
				p.Class_constraint()
			}

		case 4:
			{
				p.SetState(2378)
				p.Class_declaration()
			}

		case 5:
			{
				p.SetState(2379)
				p.Covergroup_declaration()
			}

		}

	case SystemVerilogParserSEMI, SystemVerilogParserKLOCALPARAM, SystemVerilogParserKPARAMETER:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(2384)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SystemVerilogParserKLOCALPARAM:
			{
				p.SetState(2382)
				p.Local_parameter_declaration()
			}

		case SystemVerilogParserKPARAMETER:
			{
				p.SetState(2383)
				p.Parameter_declaration()
			}

		case SystemVerilogParserSEMI:

		default:
		}
		{
			p.SetState(2386)
			p.Match(SystemVerilogParserSEMI)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IClass_propertyContext is an interface to support dynamic dispatch.
type IClass_propertyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClass_propertyContext differentiates from other interfaces.
	IsClass_propertyContext()
}

type Class_propertyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClass_propertyContext() *Class_propertyContext {
	var p = new(Class_propertyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_class_property
	return p
}

func (*Class_propertyContext) IsClass_propertyContext() {}

func NewClass_propertyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Class_propertyContext {
	var p = new(Class_propertyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_class_property

	return p
}

func (s *Class_propertyContext) GetParser() antlr.Parser { return s.parser }

func (s *Class_propertyContext) Data_declaration() IData_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IData_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IData_declarationContext)
}

func (s *Class_propertyContext) AllProperty_qualifier() []IProperty_qualifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IProperty_qualifierContext)(nil)).Elem())
	var tst = make([]IProperty_qualifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IProperty_qualifierContext)
		}
	}

	return tst
}

func (s *Class_propertyContext) Property_qualifier(i int) IProperty_qualifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProperty_qualifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IProperty_qualifierContext)
}

func (s *Class_propertyContext) KCONST() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKCONST, 0)
}

func (s *Class_propertyContext) Data_type() IData_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IData_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IData_typeContext)
}

func (s *Class_propertyContext) Const_identifier() IConst_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConst_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConst_identifierContext)
}

func (s *Class_propertyContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Class_propertyContext) AllClass_item_qualifier() []IClass_item_qualifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IClass_item_qualifierContext)(nil)).Elem())
	var tst = make([]IClass_item_qualifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IClass_item_qualifierContext)
		}
	}

	return tst
}

func (s *Class_propertyContext) Class_item_qualifier(i int) IClass_item_qualifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_item_qualifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IClass_item_qualifierContext)
}

func (s *Class_propertyContext) EQ() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserEQ, 0)
}

func (s *Class_propertyContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Class_propertyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Class_propertyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Class_propertyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterClass_property(s)
	}
}

func (s *Class_propertyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitClass_property(s)
	}
}

func (p *SystemVerilogParser) Class_property() (localctx IClass_propertyContext) {
	this := p
	_ = this

	localctx = NewClass_propertyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, SystemVerilogParserRULE_class_property)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(2411)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 201, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(2392)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 198, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2389)
					p.Property_qualifier()
				}

			}
			p.SetState(2394)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 198, p.GetParserRuleContext())
		}
		{
			p.SetState(2395)
			p.Data_declaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2396)
			p.Match(SystemVerilogParserKCONST)
		}
		p.SetState(2400)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserKLOCAL || _la == SystemVerilogParserKPROTECTED || _la == SystemVerilogParserKSTATIC {
			{
				p.SetState(2397)
				p.Class_item_qualifier()
			}

			p.SetState(2402)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2403)
			p.Data_type()
		}
		{
			p.SetState(2404)
			p.Const_identifier()
		}
		p.SetState(2407)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserEQ {
			{
				p.SetState(2405)
				p.Match(SystemVerilogParserEQ)
			}
			{
				p.SetState(2406)
				p.constant_expression(0)
			}

		}
		{
			p.SetState(2409)
			p.Match(SystemVerilogParserSEMI)
		}

	}

	return localctx
}

// IClass_methodContext is an interface to support dynamic dispatch.
type IClass_methodContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClass_methodContext differentiates from other interfaces.
	IsClass_methodContext()
}

type Class_methodContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClass_methodContext() *Class_methodContext {
	var p = new(Class_methodContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_class_method
	return p
}

func (*Class_methodContext) IsClass_methodContext() {}

func NewClass_methodContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Class_methodContext {
	var p = new(Class_methodContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_class_method

	return p
}

func (s *Class_methodContext) GetParser() antlr.Parser { return s.parser }

func (s *Class_methodContext) Task_declaration() ITask_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITask_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITask_declarationContext)
}

func (s *Class_methodContext) Function_declaration() IFunction_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_declarationContext)
}

func (s *Class_methodContext) Class_constructor_declaration() IClass_constructor_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_constructor_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClass_constructor_declarationContext)
}

func (s *Class_methodContext) AllMethod_qualifier() []IMethod_qualifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMethod_qualifierContext)(nil)).Elem())
	var tst = make([]IMethod_qualifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMethod_qualifierContext)
		}
	}

	return tst
}

func (s *Class_methodContext) Method_qualifier(i int) IMethod_qualifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMethod_qualifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMethod_qualifierContext)
}

func (s *Class_methodContext) KPURE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKPURE, 0)
}

func (s *Class_methodContext) KVIRTUAL() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKVIRTUAL, 0)
}

func (s *Class_methodContext) Method_prototype() IMethod_prototypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMethod_prototypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMethod_prototypeContext)
}

func (s *Class_methodContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Class_methodContext) AllClass_item_qualifier() []IClass_item_qualifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IClass_item_qualifierContext)(nil)).Elem())
	var tst = make([]IClass_item_qualifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IClass_item_qualifierContext)
		}
	}

	return tst
}

func (s *Class_methodContext) Class_item_qualifier(i int) IClass_item_qualifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_item_qualifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IClass_item_qualifierContext)
}

func (s *Class_methodContext) KEXTERN() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKEXTERN, 0)
}

func (s *Class_methodContext) Class_constructor_prototype() IClass_constructor_prototypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_constructor_prototypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClass_constructor_prototypeContext)
}

func (s *Class_methodContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Class_methodContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Class_methodContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterClass_method(s)
	}
}

func (s *Class_methodContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitClass_method(s)
	}
}

func (p *SystemVerilogParser) Class_method() (localctx IClass_methodContext) {
	this := p
	_ = this

	localctx = NewClass_methodContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, SystemVerilogParserRULE_class_method)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2448)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 207, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(2416)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserKLOCAL || _la == SystemVerilogParserKPROTECTED || _la == SystemVerilogParserKPURE || _la == SystemVerilogParserKSTATIC || _la == SystemVerilogParserKVIRTUAL {
			{
				p.SetState(2413)
				p.Method_qualifier()
			}

			p.SetState(2418)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(2422)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 203, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(2419)
				p.Task_declaration()
			}

		case 2:
			{
				p.SetState(2420)
				p.Function_declaration()
			}

		case 3:
			{
				p.SetState(2421)
				p.Class_constructor_declaration()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2424)
			p.Match(SystemVerilogParserKPURE)
		}
		{
			p.SetState(2425)
			p.Match(SystemVerilogParserKVIRTUAL)
		}
		p.SetState(2429)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserKLOCAL || _la == SystemVerilogParserKPROTECTED || _la == SystemVerilogParserKSTATIC {
			{
				p.SetState(2426)
				p.Class_item_qualifier()
			}

			p.SetState(2431)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2432)
			p.Method_prototype()
		}
		{
			p.SetState(2433)
			p.Match(SystemVerilogParserSEMI)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2435)
			p.Match(SystemVerilogParserKEXTERN)
		}
		p.SetState(2439)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserKLOCAL || _la == SystemVerilogParserKPROTECTED || _la == SystemVerilogParserKPURE || _la == SystemVerilogParserKSTATIC || _la == SystemVerilogParserKVIRTUAL {
			{
				p.SetState(2436)
				p.Method_qualifier()
			}

			p.SetState(2441)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(2446)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 206, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(2442)
				p.Method_prototype()
			}
			{
				p.SetState(2443)
				p.Match(SystemVerilogParserSEMI)
			}

		case 2:
			{
				p.SetState(2445)
				p.Class_constructor_prototype()
			}

		}

	}

	return localctx
}

// IClass_constructor_prototypeContext is an interface to support dynamic dispatch.
type IClass_constructor_prototypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClass_constructor_prototypeContext differentiates from other interfaces.
	IsClass_constructor_prototypeContext()
}

type Class_constructor_prototypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClass_constructor_prototypeContext() *Class_constructor_prototypeContext {
	var p = new(Class_constructor_prototypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_class_constructor_prototype
	return p
}

func (*Class_constructor_prototypeContext) IsClass_constructor_prototypeContext() {}

func NewClass_constructor_prototypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Class_constructor_prototypeContext {
	var p = new(Class_constructor_prototypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_class_constructor_prototype

	return p
}

func (s *Class_constructor_prototypeContext) GetParser() antlr.Parser { return s.parser }

func (s *Class_constructor_prototypeContext) KFUNCTION() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKFUNCTION, 0)
}

func (s *Class_constructor_prototypeContext) KNEW() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKNEW, 0)
}

func (s *Class_constructor_prototypeContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Class_constructor_prototypeContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Class_constructor_prototypeContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Class_constructor_prototypeContext) Tf_port_list() ITf_port_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITf_port_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITf_port_listContext)
}

func (s *Class_constructor_prototypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Class_constructor_prototypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Class_constructor_prototypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterClass_constructor_prototype(s)
	}
}

func (s *Class_constructor_prototypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitClass_constructor_prototype(s)
	}
}

func (p *SystemVerilogParser) Class_constructor_prototype() (localctx IClass_constructor_prototypeContext) {
	this := p
	_ = this

	localctx = NewClass_constructor_prototypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, SystemVerilogParserRULE_class_constructor_prototype)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2450)
		p.Match(SystemVerilogParserKFUNCTION)
	}
	{
		p.SetState(2451)
		p.Match(SystemVerilogParserKNEW)
	}
	p.SetState(2457)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserLP {
		{
			p.SetState(2452)
			p.Match(SystemVerilogParserLP)
		}
		p.SetState(2454)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 208, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2453)
				p.Tf_port_list()
			}

		}
		{
			p.SetState(2456)
			p.Match(SystemVerilogParserRP)
		}

	}
	{
		p.SetState(2459)
		p.Match(SystemVerilogParserSEMI)
	}

	return localctx
}

// IClass_constraintContext is an interface to support dynamic dispatch.
type IClass_constraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClass_constraintContext differentiates from other interfaces.
	IsClass_constraintContext()
}

type Class_constraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClass_constraintContext() *Class_constraintContext {
	var p = new(Class_constraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_class_constraint
	return p
}

func (*Class_constraintContext) IsClass_constraintContext() {}

func NewClass_constraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Class_constraintContext {
	var p = new(Class_constraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_class_constraint

	return p
}

func (s *Class_constraintContext) GetParser() antlr.Parser { return s.parser }

func (s *Class_constraintContext) Constraint_prototype() IConstraint_prototypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstraint_prototypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstraint_prototypeContext)
}

func (s *Class_constraintContext) Constraint_declaration() IConstraint_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstraint_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstraint_declarationContext)
}

func (s *Class_constraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Class_constraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Class_constraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterClass_constraint(s)
	}
}

func (s *Class_constraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitClass_constraint(s)
	}
}

func (p *SystemVerilogParser) Class_constraint() (localctx IClass_constraintContext) {
	this := p
	_ = this

	localctx = NewClass_constraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, SystemVerilogParserRULE_class_constraint)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2463)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 210, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2461)
			p.Constraint_prototype()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2462)
			p.Constraint_declaration()
		}

	}

	return localctx
}

// IClass_item_qualifierContext is an interface to support dynamic dispatch.
type IClass_item_qualifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClass_item_qualifierContext differentiates from other interfaces.
	IsClass_item_qualifierContext()
}

type Class_item_qualifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClass_item_qualifierContext() *Class_item_qualifierContext {
	var p = new(Class_item_qualifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_class_item_qualifier
	return p
}

func (*Class_item_qualifierContext) IsClass_item_qualifierContext() {}

func NewClass_item_qualifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Class_item_qualifierContext {
	var p = new(Class_item_qualifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_class_item_qualifier

	return p
}

func (s *Class_item_qualifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Class_item_qualifierContext) KSTATIC() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKSTATIC, 0)
}

func (s *Class_item_qualifierContext) KPROTECTED() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKPROTECTED, 0)
}

func (s *Class_item_qualifierContext) KLOCAL() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKLOCAL, 0)
}

func (s *Class_item_qualifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Class_item_qualifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Class_item_qualifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterClass_item_qualifier(s)
	}
}

func (s *Class_item_qualifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitClass_item_qualifier(s)
	}
}

func (p *SystemVerilogParser) Class_item_qualifier() (localctx IClass_item_qualifierContext) {
	this := p
	_ = this

	localctx = NewClass_item_qualifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, SystemVerilogParserRULE_class_item_qualifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2465)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SystemVerilogParserKLOCAL || _la == SystemVerilogParserKPROTECTED || _la == SystemVerilogParserKSTATIC) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IProperty_qualifierContext is an interface to support dynamic dispatch.
type IProperty_qualifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProperty_qualifierContext differentiates from other interfaces.
	IsProperty_qualifierContext()
}

type Property_qualifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProperty_qualifierContext() *Property_qualifierContext {
	var p = new(Property_qualifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_property_qualifier
	return p
}

func (*Property_qualifierContext) IsProperty_qualifierContext() {}

func NewProperty_qualifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Property_qualifierContext {
	var p = new(Property_qualifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_property_qualifier

	return p
}

func (s *Property_qualifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Property_qualifierContext) Random_qualifier() IRandom_qualifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRandom_qualifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRandom_qualifierContext)
}

func (s *Property_qualifierContext) Class_item_qualifier() IClass_item_qualifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_item_qualifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClass_item_qualifierContext)
}

func (s *Property_qualifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Property_qualifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Property_qualifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterProperty_qualifier(s)
	}
}

func (s *Property_qualifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitProperty_qualifier(s)
	}
}

func (p *SystemVerilogParser) Property_qualifier() (localctx IProperty_qualifierContext) {
	this := p
	_ = this

	localctx = NewProperty_qualifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, SystemVerilogParserRULE_property_qualifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2469)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserKRAND, SystemVerilogParserKRANDC:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2467)
			p.Random_qualifier()
		}

	case SystemVerilogParserKLOCAL, SystemVerilogParserKPROTECTED, SystemVerilogParserKSTATIC:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2468)
			p.Class_item_qualifier()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IRandom_qualifierContext is an interface to support dynamic dispatch.
type IRandom_qualifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRandom_qualifierContext differentiates from other interfaces.
	IsRandom_qualifierContext()
}

type Random_qualifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRandom_qualifierContext() *Random_qualifierContext {
	var p = new(Random_qualifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_random_qualifier
	return p
}

func (*Random_qualifierContext) IsRandom_qualifierContext() {}

func NewRandom_qualifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Random_qualifierContext {
	var p = new(Random_qualifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_random_qualifier

	return p
}

func (s *Random_qualifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Random_qualifierContext) KRAND() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKRAND, 0)
}

func (s *Random_qualifierContext) KRANDC() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKRANDC, 0)
}

func (s *Random_qualifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Random_qualifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Random_qualifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterRandom_qualifier(s)
	}
}

func (s *Random_qualifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitRandom_qualifier(s)
	}
}

func (p *SystemVerilogParser) Random_qualifier() (localctx IRandom_qualifierContext) {
	this := p
	_ = this

	localctx = NewRandom_qualifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, SystemVerilogParserRULE_random_qualifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2471)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SystemVerilogParserKRAND || _la == SystemVerilogParserKRANDC) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IMethod_qualifierContext is an interface to support dynamic dispatch.
type IMethod_qualifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMethod_qualifierContext differentiates from other interfaces.
	IsMethod_qualifierContext()
}

type Method_qualifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethod_qualifierContext() *Method_qualifierContext {
	var p = new(Method_qualifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_method_qualifier
	return p
}

func (*Method_qualifierContext) IsMethod_qualifierContext() {}

func NewMethod_qualifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Method_qualifierContext {
	var p = new(Method_qualifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_method_qualifier

	return p
}

func (s *Method_qualifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Method_qualifierContext) KVIRTUAL() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKVIRTUAL, 0)
}

func (s *Method_qualifierContext) KPURE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKPURE, 0)
}

func (s *Method_qualifierContext) Class_item_qualifier() IClass_item_qualifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_item_qualifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClass_item_qualifierContext)
}

func (s *Method_qualifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Method_qualifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Method_qualifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterMethod_qualifier(s)
	}
}

func (s *Method_qualifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitMethod_qualifier(s)
	}
}

func (p *SystemVerilogParser) Method_qualifier() (localctx IMethod_qualifierContext) {
	this := p
	_ = this

	localctx = NewMethod_qualifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, SystemVerilogParserRULE_method_qualifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2478)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserKPURE, SystemVerilogParserKVIRTUAL:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(2474)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserKPURE {
			{
				p.SetState(2473)
				p.Match(SystemVerilogParserKPURE)
			}

		}
		{
			p.SetState(2476)
			p.Match(SystemVerilogParserKVIRTUAL)
		}

	case SystemVerilogParserKLOCAL, SystemVerilogParserKPROTECTED, SystemVerilogParserKSTATIC:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2477)
			p.Class_item_qualifier()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IMethod_prototypeContext is an interface to support dynamic dispatch.
type IMethod_prototypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMethod_prototypeContext differentiates from other interfaces.
	IsMethod_prototypeContext()
}

type Method_prototypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethod_prototypeContext() *Method_prototypeContext {
	var p = new(Method_prototypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_method_prototype
	return p
}

func (*Method_prototypeContext) IsMethod_prototypeContext() {}

func NewMethod_prototypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Method_prototypeContext {
	var p = new(Method_prototypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_method_prototype

	return p
}

func (s *Method_prototypeContext) GetParser() antlr.Parser { return s.parser }

func (s *Method_prototypeContext) Task_prototype() ITask_prototypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITask_prototypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITask_prototypeContext)
}

func (s *Method_prototypeContext) Function_prototype() IFunction_prototypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_prototypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_prototypeContext)
}

func (s *Method_prototypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Method_prototypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Method_prototypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterMethod_prototype(s)
	}
}

func (s *Method_prototypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitMethod_prototype(s)
	}
}

func (p *SystemVerilogParser) Method_prototype() (localctx IMethod_prototypeContext) {
	this := p
	_ = this

	localctx = NewMethod_prototypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, SystemVerilogParserRULE_method_prototype)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2482)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserKTASK:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2480)
			p.Task_prototype()
		}

	case SystemVerilogParserKFUNCTION:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2481)
			p.Function_prototype()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IClass_constructor_declarationContext is an interface to support dynamic dispatch.
type IClass_constructor_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClass_constructor_declarationContext differentiates from other interfaces.
	IsClass_constructor_declarationContext()
}

type Class_constructor_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClass_constructor_declarationContext() *Class_constructor_declarationContext {
	var p = new(Class_constructor_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_class_constructor_declaration
	return p
}

func (*Class_constructor_declarationContext) IsClass_constructor_declarationContext() {}

func NewClass_constructor_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Class_constructor_declarationContext {
	var p = new(Class_constructor_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_class_constructor_declaration

	return p
}

func (s *Class_constructor_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Class_constructor_declarationContext) KFUNCTION() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKFUNCTION, 0)
}

func (s *Class_constructor_declarationContext) AllKNEW() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserKNEW)
}

func (s *Class_constructor_declarationContext) KNEW(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKNEW, i)
}

func (s *Class_constructor_declarationContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserSEMI)
}

func (s *Class_constructor_declarationContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, i)
}

func (s *Class_constructor_declarationContext) KENDFUNCTION() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKENDFUNCTION, 0)
}

func (s *Class_constructor_declarationContext) Class_scope() IClass_scopeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_scopeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClass_scopeContext)
}

func (s *Class_constructor_declarationContext) AllLP() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserLP)
}

func (s *Class_constructor_declarationContext) LP(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, i)
}

func (s *Class_constructor_declarationContext) AllRP() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserRP)
}

func (s *Class_constructor_declarationContext) RP(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, i)
}

func (s *Class_constructor_declarationContext) AllBlock_item_declaration() []IBlock_item_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBlock_item_declarationContext)(nil)).Elem())
	var tst = make([]IBlock_item_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBlock_item_declarationContext)
		}
	}

	return tst
}

func (s *Class_constructor_declarationContext) Block_item_declaration(i int) IBlock_item_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_item_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBlock_item_declarationContext)
}

func (s *Class_constructor_declarationContext) KSUPER() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKSUPER, 0)
}

func (s *Class_constructor_declarationContext) DOT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserDOT, 0)
}

func (s *Class_constructor_declarationContext) AllFunction_statement_or_null() []IFunction_statement_or_nullContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFunction_statement_or_nullContext)(nil)).Elem())
	var tst = make([]IFunction_statement_or_nullContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFunction_statement_or_nullContext)
		}
	}

	return tst
}

func (s *Class_constructor_declarationContext) Function_statement_or_null(i int) IFunction_statement_or_nullContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_statement_or_nullContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFunction_statement_or_nullContext)
}

func (s *Class_constructor_declarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOLON, 0)
}

func (s *Class_constructor_declarationContext) Tf_port_list() ITf_port_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITf_port_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITf_port_listContext)
}

func (s *Class_constructor_declarationContext) List_of_arguments() IList_of_argumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_argumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_argumentsContext)
}

func (s *Class_constructor_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Class_constructor_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Class_constructor_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterClass_constructor_declaration(s)
	}
}

func (s *Class_constructor_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitClass_constructor_declaration(s)
	}
}

func (p *SystemVerilogParser) Class_constructor_declaration() (localctx IClass_constructor_declarationContext) {
	this := p
	_ = this

	localctx = NewClass_constructor_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, SystemVerilogParserRULE_class_constructor_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2484)
		p.Match(SystemVerilogParserKFUNCTION)
	}
	p.SetState(2486)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserDUNIT || _la == SystemVerilogParserSIMPLE_IDENTIFIER {
		{
			p.SetState(2485)
			p.Class_scope()
		}

	}
	{
		p.SetState(2488)
		p.Match(SystemVerilogParserKNEW)
	}
	p.SetState(2494)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserLP {
		{
			p.SetState(2489)
			p.Match(SystemVerilogParserLP)
		}
		p.SetState(2491)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 216, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2490)
				p.Tf_port_list()
			}

		}
		{
			p.SetState(2493)
			p.Match(SystemVerilogParserRP)
		}

	}
	{
		p.SetState(2496)
		p.Match(SystemVerilogParserSEMI)
	}
	p.SetState(2500)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 218, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2497)
				p.Block_item_declaration()
			}

		}
		p.SetState(2502)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 218, p.GetParserRuleContext())
	}
	p.SetState(2513)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 220, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2503)
			p.Match(SystemVerilogParserKSUPER)
		}
		{
			p.SetState(2504)
			p.Match(SystemVerilogParserDOT)
		}
		{
			p.SetState(2505)
			p.Match(SystemVerilogParserKNEW)
		}
		p.SetState(2510)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserLP {
			{
				p.SetState(2506)
				p.Match(SystemVerilogParserLP)
			}
			{
				p.SetState(2507)
				p.List_of_arguments()
			}
			{
				p.SetState(2508)
				p.Match(SystemVerilogParserRP)
			}

		}
		{
			p.SetState(2512)
			p.Match(SystemVerilogParserSEMI)
		}

	}
	p.SetState(2518)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SystemVerilogParserMINUSMINS)|(1<<SystemVerilogParserP)|(1<<SystemVerilogParserPP)|(1<<SystemVerilogParserDOLLAR)|(1<<SystemVerilogParserDERROR)|(1<<SystemVerilogParserDFATAL)|(1<<SystemVerilogParserDINFO)|(1<<SystemVerilogParserDROOT)|(1<<SystemVerilogParserDUNIT)|(1<<SystemVerilogParserDWARNING)|(1<<SystemVerilogParserLP)|(1<<SystemVerilogParserLPS))) != 0) || (((_la-46)&-(0x1f+1)) == 0 && ((1<<uint((_la-46)))&((1<<(SystemVerilogParserSEMI-46))|(1<<(SystemVerilogParserAT-46))|(1<<(SystemVerilogParserQUOTE-46))|(1<<(SystemVerilogParserLC-46))|(1<<(SystemVerilogParserPLUSPLUS-46)))) != 0) || (((_la-85)&-(0x1f+1)) == 0 && ((1<<uint((_la-85)))&((1<<(SystemVerilogParserARROW-85))|(1<<(SystemVerilogParserMINUSGTGT-85))|(1<<(SystemVerilogParserKASSERT-85))|(1<<(SystemVerilogParserKASSIGN-85))|(1<<(SystemVerilogParserKASSUME-85))|(1<<(SystemVerilogParserKBEGIN-85))|(1<<(SystemVerilogParserKBREAK-85))|(1<<(SystemVerilogParserKBYTE-85))|(1<<(SystemVerilogParserKCASE-85))|(1<<(SystemVerilogParserKCASEX-85)))) != 0) || (((_la-117)&-(0x1f+1)) == 0 && ((1<<uint((_la-117)))&((1<<(SystemVerilogParserKCASEZ-117))|(1<<(SystemVerilogParserKCONTINUE-117))|(1<<(SystemVerilogParserKCOVER-117))|(1<<(SystemVerilogParserKDEASSIGN-117))|(1<<(SystemVerilogParserKDISABLE-117))|(1<<(SystemVerilogParserKDO-117)))) != 0) || (((_la-162)&-(0x1f+1)) == 0 && ((1<<uint((_la-162)))&((1<<(SystemVerilogParserKEXPECT-162))|(1<<(SystemVerilogParserKFOR-162))|(1<<(SystemVerilogParserKFORCE-162))|(1<<(SystemVerilogParserKFOREACH-162))|(1<<(SystemVerilogParserKFOREVER-162))|(1<<(SystemVerilogParserKFORK-162))|(1<<(SystemVerilogParserKIF-162)))) != 0) || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SystemVerilogParserKINT-195))|(1<<(SystemVerilogParserKINTEGER-195))|(1<<(SystemVerilogParserKLOCAL-195))|(1<<(SystemVerilogParserKLONGINT-195)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(SystemVerilogParserKNULL-228))|(1<<(SystemVerilogParserKPRIORITY-228))|(1<<(SystemVerilogParserKRANDCASE-228))|(1<<(SystemVerilogParserKRANDOMIZE-228))|(1<<(SystemVerilogParserKRANDSEQUENCE-228)))) != 0) || (((_la-260)&-(0x1f+1)) == 0 && ((1<<uint((_la-260)))&((1<<(SystemVerilogParserKRELEASE-260))|(1<<(SystemVerilogParserKREPEAT-260))|(1<<(SystemVerilogParserKRESTRICT-260))|(1<<(SystemVerilogParserKRETURN-260))|(1<<(SystemVerilogParserKSHORTINT-260))|(1<<(SystemVerilogParserKSTD-260)))) != 0) || (((_la-292)&-(0x1f+1)) == 0 && ((1<<uint((_la-292)))&((1<<(SystemVerilogParserKSUPER-292))|(1<<(SystemVerilogParserKTHIS-292))|(1<<(SystemVerilogParserKTIME-292))|(1<<(SystemVerilogParserKTYPE-292))|(1<<(SystemVerilogParserKUNIQUE-292))|(1<<(SystemVerilogParserKUNIQUE0-292)))) != 0) || (((_la-328)&-(0x1f+1)) == 0 && ((1<<uint((_la-328)))&((1<<(SystemVerilogParserKVOID-328))|(1<<(SystemVerilogParserKWAIT-328))|(1<<(SystemVerilogParserKWAIT_ORDER-328))|(1<<(SystemVerilogParserKWHILE-328))|(1<<(SystemVerilogParserTIME_LITERAL-328))|(1<<(SystemVerilogParserDECIMAL_NUMBER-328))|(1<<(SystemVerilogParserBINARY_NUMBER-328))|(1<<(SystemVerilogParserOCTAL_NUMBER-328))|(1<<(SystemVerilogParserHEX_NUMBER-328))|(1<<(SystemVerilogParserREAL_NUMBER-328))|(1<<(SystemVerilogParserUNSIGNED_NUMBER-328))|(1<<(SystemVerilogParserSTRING_LITERAL-328))|(1<<(SystemVerilogParserSIMPLE_IDENTIFIER-328))|(1<<(SystemVerilogParserSYSTEM_TF_IDENTIFIER-328)))) != 0) {
		{
			p.SetState(2515)
			p.Function_statement_or_null()
		}

		p.SetState(2520)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2521)
		p.Match(SystemVerilogParserKENDFUNCTION)
	}
	p.SetState(2524)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserCOLON {
		{
			p.SetState(2522)
			p.Match(SystemVerilogParserCOLON)
		}
		{
			p.SetState(2523)
			p.Match(SystemVerilogParserKNEW)
		}

	}

	return localctx
}

// IConstraint_declarationContext is an interface to support dynamic dispatch.
type IConstraint_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstraint_declarationContext differentiates from other interfaces.
	IsConstraint_declarationContext()
}

type Constraint_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstraint_declarationContext() *Constraint_declarationContext {
	var p = new(Constraint_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_constraint_declaration
	return p
}

func (*Constraint_declarationContext) IsConstraint_declarationContext() {}

func NewConstraint_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constraint_declarationContext {
	var p = new(Constraint_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_constraint_declaration

	return p
}

func (s *Constraint_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Constraint_declarationContext) KCONSTRAINT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKCONSTRAINT, 0)
}

func (s *Constraint_declarationContext) Constraint_identifier() IConstraint_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstraint_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstraint_identifierContext)
}

func (s *Constraint_declarationContext) Constraint_block() IConstraint_blockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstraint_blockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstraint_blockContext)
}

func (s *Constraint_declarationContext) KSTATIC() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKSTATIC, 0)
}

func (s *Constraint_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constraint_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constraint_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterConstraint_declaration(s)
	}
}

func (s *Constraint_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitConstraint_declaration(s)
	}
}

func (p *SystemVerilogParser) Constraint_declaration() (localctx IConstraint_declarationContext) {
	this := p
	_ = this

	localctx = NewConstraint_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, SystemVerilogParserRULE_constraint_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2527)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserKSTATIC {
		{
			p.SetState(2526)
			p.Match(SystemVerilogParserKSTATIC)
		}

	}
	{
		p.SetState(2529)
		p.Match(SystemVerilogParserKCONSTRAINT)
	}
	{
		p.SetState(2530)
		p.Constraint_identifier()
	}
	{
		p.SetState(2531)
		p.Constraint_block()
	}

	return localctx
}

// IConstraint_blockContext is an interface to support dynamic dispatch.
type IConstraint_blockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstraint_blockContext differentiates from other interfaces.
	IsConstraint_blockContext()
}

type Constraint_blockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstraint_blockContext() *Constraint_blockContext {
	var p = new(Constraint_blockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_constraint_block
	return p
}

func (*Constraint_blockContext) IsConstraint_blockContext() {}

func NewConstraint_blockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constraint_blockContext {
	var p = new(Constraint_blockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_constraint_block

	return p
}

func (s *Constraint_blockContext) GetParser() antlr.Parser { return s.parser }

func (s *Constraint_blockContext) LC() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLC, 0)
}

func (s *Constraint_blockContext) RC() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRC, 0)
}

func (s *Constraint_blockContext) AllConstraint_block_item() []IConstraint_block_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConstraint_block_itemContext)(nil)).Elem())
	var tst = make([]IConstraint_block_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConstraint_block_itemContext)
		}
	}

	return tst
}

func (s *Constraint_blockContext) Constraint_block_item(i int) IConstraint_block_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstraint_block_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConstraint_block_itemContext)
}

func (s *Constraint_blockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constraint_blockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constraint_blockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterConstraint_block(s)
	}
}

func (s *Constraint_blockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitConstraint_block(s)
	}
}

func (p *SystemVerilogParser) Constraint_block() (localctx IConstraint_blockContext) {
	this := p
	_ = this

	localctx = NewConstraint_blockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, SystemVerilogParserRULE_constraint_block)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2533)
		p.Match(SystemVerilogParserLC)
	}
	p.SetState(2537)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SystemVerilogParserMINUS)|(1<<SystemVerilogParserMINUSMINS)|(1<<SystemVerilogParserNOT)|(1<<SystemVerilogParserDOLLAR)|(1<<SystemVerilogParserDROOT)|(1<<SystemVerilogParserDUNIT)|(1<<SystemVerilogParserAND)|(1<<SystemVerilogParserLP))) != 0) || (((_la-51)&-(0x1f+1)) == 0 && ((1<<uint((_la-51)))&((1<<(SystemVerilogParserQUOTE-51))|(1<<(SystemVerilogParserCARET-51))|(1<<(SystemVerilogParserCARETSQUIG-51))|(1<<(SystemVerilogParserLC-51))|(1<<(SystemVerilogParserBAR-51))|(1<<(SystemVerilogParserSQUIG-51))|(1<<(SystemVerilogParserSQUIGAND-51))|(1<<(SystemVerilogParserSQUIGCARET-51))|(1<<(SystemVerilogParserSQUIGBAR-51))|(1<<(SystemVerilogParserPLUS-51))|(1<<(SystemVerilogParserPLUSPLUS-51)))) != 0) || (((_la-109)&-(0x1f+1)) == 0 && ((1<<uint((_la-109)))&((1<<(SystemVerilogParserKBIT-109))|(1<<(SystemVerilogParserKBYTE-109))|(1<<(SystemVerilogParserKCONST-109))|(1<<(SystemVerilogParserKDISABLE-109)))) != 0) || (((_la-170)&-(0x1f+1)) == 0 && ((1<<uint((_la-170)))&((1<<(SystemVerilogParserKFOREACH-170))|(1<<(SystemVerilogParserKIF-170))|(1<<(SystemVerilogParserKINT-170))|(1<<(SystemVerilogParserKINTEGER-170)))) != 0) || (((_la-207)&-(0x1f+1)) == 0 && ((1<<uint((_la-207)))&((1<<(SystemVerilogParserKLOCAL-207))|(1<<(SystemVerilogParserKLOGIC-207))|(1<<(SystemVerilogParserKLONGINT-207))|(1<<(SystemVerilogParserKNULL-207)))) != 0) || (((_la-252)&-(0x1f+1)) == 0 && ((1<<uint((_la-252)))&((1<<(SystemVerilogParserKRANDOMIZE-252))|(1<<(SystemVerilogParserKREAL-252))|(1<<(SystemVerilogParserKREALTIME-252))|(1<<(SystemVerilogParserKREG-252))|(1<<(SystemVerilogParserKSHORTINT-252))|(1<<(SystemVerilogParserKSHORTREAL-252))|(1<<(SystemVerilogParserKSIGNED-252))|(1<<(SystemVerilogParserKSOFT-252))|(1<<(SystemVerilogParserKSOLVE-252)))) != 0) || (((_la-286)&-(0x1f+1)) == 0 && ((1<<uint((_la-286)))&((1<<(SystemVerilogParserKSTD-286))|(1<<(SystemVerilogParserKSTRING-286))|(1<<(SystemVerilogParserKSUPER-286))|(1<<(SystemVerilogParserKTAGGED-286))|(1<<(SystemVerilogParserKTHIS-286))|(1<<(SystemVerilogParserKTIME-286))|(1<<(SystemVerilogParserKTYPE-286))|(1<<(SystemVerilogParserKUNIQUE-286)))) != 0) || (((_la-319)&-(0x1f+1)) == 0 && ((1<<uint((_la-319)))&((1<<(SystemVerilogParserKUNSIGNED-319))|(1<<(SystemVerilogParserTIME_LITERAL-319))|(1<<(SystemVerilogParserDECIMAL_NUMBER-319))|(1<<(SystemVerilogParserBINARY_NUMBER-319))|(1<<(SystemVerilogParserOCTAL_NUMBER-319))|(1<<(SystemVerilogParserHEX_NUMBER-319))|(1<<(SystemVerilogParserREAL_NUMBER-319)))) != 0) || (((_la-351)&-(0x1f+1)) == 0 && ((1<<uint((_la-351)))&((1<<(SystemVerilogParserUNSIGNED_NUMBER-351))|(1<<(SystemVerilogParserSTRING_LITERAL-351))|(1<<(SystemVerilogParserSIMPLE_IDENTIFIER-351))|(1<<(SystemVerilogParserSYSTEM_TF_IDENTIFIER-351)))) != 0) {
		{
			p.SetState(2534)
			p.Constraint_block_item()
		}

		p.SetState(2539)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2540)
		p.Match(SystemVerilogParserRC)
	}

	return localctx
}

// IConstraint_block_itemContext is an interface to support dynamic dispatch.
type IConstraint_block_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstraint_block_itemContext differentiates from other interfaces.
	IsConstraint_block_itemContext()
}

type Constraint_block_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstraint_block_itemContext() *Constraint_block_itemContext {
	var p = new(Constraint_block_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_constraint_block_item
	return p
}

func (*Constraint_block_itemContext) IsConstraint_block_itemContext() {}

func NewConstraint_block_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constraint_block_itemContext {
	var p = new(Constraint_block_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_constraint_block_item

	return p
}

func (s *Constraint_block_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Constraint_block_itemContext) KSOLVE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKSOLVE, 0)
}

func (s *Constraint_block_itemContext) AllSolve_before_list() []ISolve_before_listContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISolve_before_listContext)(nil)).Elem())
	var tst = make([]ISolve_before_listContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISolve_before_listContext)
		}
	}

	return tst
}

func (s *Constraint_block_itemContext) Solve_before_list(i int) ISolve_before_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISolve_before_listContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISolve_before_listContext)
}

func (s *Constraint_block_itemContext) KBEFORE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKBEFORE, 0)
}

func (s *Constraint_block_itemContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Constraint_block_itemContext) Constraint_expression() IConstraint_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstraint_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstraint_expressionContext)
}

func (s *Constraint_block_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constraint_block_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constraint_block_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterConstraint_block_item(s)
	}
}

func (s *Constraint_block_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitConstraint_block_item(s)
	}
}

func (p *SystemVerilogParser) Constraint_block_item() (localctx IConstraint_block_itemContext) {
	this := p
	_ = this

	localctx = NewConstraint_block_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, SystemVerilogParserRULE_constraint_block_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2549)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserKSOLVE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2542)
			p.Match(SystemVerilogParserKSOLVE)
		}
		{
			p.SetState(2543)
			p.Solve_before_list()
		}
		{
			p.SetState(2544)
			p.Match(SystemVerilogParserKBEFORE)
		}
		{
			p.SetState(2545)
			p.Solve_before_list()
		}
		{
			p.SetState(2546)
			p.Match(SystemVerilogParserSEMI)
		}

	case SystemVerilogParserMINUS, SystemVerilogParserMINUSMINS, SystemVerilogParserNOT, SystemVerilogParserDOLLAR, SystemVerilogParserDROOT, SystemVerilogParserDUNIT, SystemVerilogParserAND, SystemVerilogParserLP, SystemVerilogParserQUOTE, SystemVerilogParserCARET, SystemVerilogParserCARETSQUIG, SystemVerilogParserLC, SystemVerilogParserBAR, SystemVerilogParserSQUIG, SystemVerilogParserSQUIGAND, SystemVerilogParserSQUIGCARET, SystemVerilogParserSQUIGBAR, SystemVerilogParserPLUS, SystemVerilogParserPLUSPLUS, SystemVerilogParserKBIT, SystemVerilogParserKBYTE, SystemVerilogParserKCONST, SystemVerilogParserKDISABLE, SystemVerilogParserKFOREACH, SystemVerilogParserKIF, SystemVerilogParserKINT, SystemVerilogParserKINTEGER, SystemVerilogParserKLOCAL, SystemVerilogParserKLOGIC, SystemVerilogParserKLONGINT, SystemVerilogParserKNULL, SystemVerilogParserKRANDOMIZE, SystemVerilogParserKREAL, SystemVerilogParserKREALTIME, SystemVerilogParserKREG, SystemVerilogParserKSHORTINT, SystemVerilogParserKSHORTREAL, SystemVerilogParserKSIGNED, SystemVerilogParserKSOFT, SystemVerilogParserKSTD, SystemVerilogParserKSTRING, SystemVerilogParserKSUPER, SystemVerilogParserKTAGGED, SystemVerilogParserKTHIS, SystemVerilogParserKTIME, SystemVerilogParserKTYPE, SystemVerilogParserKUNIQUE, SystemVerilogParserKUNSIGNED, SystemVerilogParserTIME_LITERAL, SystemVerilogParserDECIMAL_NUMBER, SystemVerilogParserBINARY_NUMBER, SystemVerilogParserOCTAL_NUMBER, SystemVerilogParserHEX_NUMBER, SystemVerilogParserREAL_NUMBER, SystemVerilogParserUNSIGNED_NUMBER, SystemVerilogParserSTRING_LITERAL, SystemVerilogParserSIMPLE_IDENTIFIER, SystemVerilogParserSYSTEM_TF_IDENTIFIER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2548)
			p.Constraint_expression()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISolve_before_listContext is an interface to support dynamic dispatch.
type ISolve_before_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSolve_before_listContext differentiates from other interfaces.
	IsSolve_before_listContext()
}

type Solve_before_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySolve_before_listContext() *Solve_before_listContext {
	var p = new(Solve_before_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_solve_before_list
	return p
}

func (*Solve_before_listContext) IsSolve_before_listContext() {}

func NewSolve_before_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Solve_before_listContext {
	var p = new(Solve_before_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_solve_before_list

	return p
}

func (s *Solve_before_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Solve_before_listContext) AllConstraint_primary() []IConstraint_primaryContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConstraint_primaryContext)(nil)).Elem())
	var tst = make([]IConstraint_primaryContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConstraint_primaryContext)
		}
	}

	return tst
}

func (s *Solve_before_listContext) Constraint_primary(i int) IConstraint_primaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstraint_primaryContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConstraint_primaryContext)
}

func (s *Solve_before_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *Solve_before_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *Solve_before_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Solve_before_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Solve_before_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterSolve_before_list(s)
	}
}

func (s *Solve_before_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitSolve_before_list(s)
	}
}

func (p *SystemVerilogParser) Solve_before_list() (localctx ISolve_before_listContext) {
	this := p
	_ = this

	localctx = NewSolve_before_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, SystemVerilogParserRULE_solve_before_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2551)
		p.Constraint_primary()
	}
	p.SetState(2556)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserCOMMA {
		{
			p.SetState(2552)
			p.Match(SystemVerilogParserCOMMA)
		}
		{
			p.SetState(2553)
			p.Constraint_primary()
		}

		p.SetState(2558)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IConstraint_primaryContext is an interface to support dynamic dispatch.
type IConstraint_primaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstraint_primaryContext differentiates from other interfaces.
	IsConstraint_primaryContext()
}

type Constraint_primaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstraint_primaryContext() *Constraint_primaryContext {
	var p = new(Constraint_primaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_constraint_primary
	return p
}

func (*Constraint_primaryContext) IsConstraint_primaryContext() {}

func NewConstraint_primaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constraint_primaryContext {
	var p = new(Constraint_primaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_constraint_primary

	return p
}

func (s *Constraint_primaryContext) GetParser() antlr.Parser { return s.parser }

func (s *Constraint_primaryContext) Hierarchical_identifier() IHierarchical_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_identifierContext)
}

func (s *Constraint_primaryContext) Select_() ISelect_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelect_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelect_Context)
}

func (s *Constraint_primaryContext) Implicit_class_handle() IImplicit_class_handleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImplicit_class_handleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImplicit_class_handleContext)
}

func (s *Constraint_primaryContext) DOT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserDOT, 0)
}

func (s *Constraint_primaryContext) Class_scope() IClass_scopeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_scopeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClass_scopeContext)
}

func (s *Constraint_primaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constraint_primaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constraint_primaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterConstraint_primary(s)
	}
}

func (s *Constraint_primaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitConstraint_primary(s)
	}
}

func (p *SystemVerilogParser) Constraint_primary() (localctx IConstraint_primaryContext) {
	this := p
	_ = this

	localctx = NewConstraint_primaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, SystemVerilogParserRULE_constraint_primary)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2563)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 227, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2559)
			p.Implicit_class_handle()
		}
		{
			p.SetState(2560)
			p.Match(SystemVerilogParserDOT)
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 227, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(2562)
			p.Class_scope()
		}

	}
	{
		p.SetState(2565)
		p.Hierarchical_identifier()
	}
	{
		p.SetState(2566)
		p.Select_()
	}

	return localctx
}

// IConstraint_expressionContext is an interface to support dynamic dispatch.
type IConstraint_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstraint_expressionContext differentiates from other interfaces.
	IsConstraint_expressionContext()
}

type Constraint_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstraint_expressionContext() *Constraint_expressionContext {
	var p = new(Constraint_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_constraint_expression
	return p
}

func (*Constraint_expressionContext) IsConstraint_expressionContext() {}

func NewConstraint_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constraint_expressionContext {
	var p = new(Constraint_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_constraint_expression

	return p
}

func (s *Constraint_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Constraint_expressionContext) Expression_or_dist() IExpression_or_distContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpression_or_distContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpression_or_distContext)
}

func (s *Constraint_expressionContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Constraint_expressionContext) KSOFT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKSOFT, 0)
}

func (s *Constraint_expressionContext) Uniqueness_constraint() IUniqueness_constraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUniqueness_constraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUniqueness_constraintContext)
}

func (s *Constraint_expressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Constraint_expressionContext) ARROW() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserARROW, 0)
}

func (s *Constraint_expressionContext) AllConstraint_set() []IConstraint_setContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConstraint_setContext)(nil)).Elem())
	var tst = make([]IConstraint_setContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConstraint_setContext)
		}
	}

	return tst
}

func (s *Constraint_expressionContext) Constraint_set(i int) IConstraint_setContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstraint_setContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConstraint_setContext)
}

func (s *Constraint_expressionContext) KIF() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKIF, 0)
}

func (s *Constraint_expressionContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Constraint_expressionContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Constraint_expressionContext) KELSE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKELSE, 0)
}

func (s *Constraint_expressionContext) KFOREACH() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKFOREACH, 0)
}

func (s *Constraint_expressionContext) Ps_or_hierarchical_array_identifier() IPs_or_hierarchical_array_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPs_or_hierarchical_array_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPs_or_hierarchical_array_identifierContext)
}

func (s *Constraint_expressionContext) LB() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLB, 0)
}

func (s *Constraint_expressionContext) Loop_variables() ILoop_variablesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILoop_variablesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILoop_variablesContext)
}

func (s *Constraint_expressionContext) RB() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRB, 0)
}

func (s *Constraint_expressionContext) KDISABLE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKDISABLE, 0)
}

func (s *Constraint_expressionContext) Constraint_primary() IConstraint_primaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstraint_primaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstraint_primaryContext)
}

func (s *Constraint_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constraint_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constraint_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterConstraint_expression(s)
	}
}

func (s *Constraint_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitConstraint_expression(s)
	}
}

func (p *SystemVerilogParser) Constraint_expression() (localctx IConstraint_expressionContext) {
	this := p
	_ = this

	localctx = NewConstraint_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, SystemVerilogParserRULE_constraint_expression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2604)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 230, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(2569)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserKSOFT {
			{
				p.SetState(2568)
				p.Match(SystemVerilogParserKSOFT)
			}

		}
		{
			p.SetState(2571)
			p.Expression_or_dist()
		}
		{
			p.SetState(2572)
			p.Match(SystemVerilogParserSEMI)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2574)
			p.Uniqueness_constraint()
		}
		{
			p.SetState(2575)
			p.Match(SystemVerilogParserSEMI)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2577)
			p.expression(0)
		}
		{
			p.SetState(2578)
			p.Match(SystemVerilogParserARROW)
		}
		{
			p.SetState(2579)
			p.Constraint_set()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2581)
			p.Match(SystemVerilogParserKIF)
		}
		{
			p.SetState(2582)
			p.Match(SystemVerilogParserLP)
		}
		{
			p.SetState(2583)
			p.expression(0)
		}
		{
			p.SetState(2584)
			p.Match(SystemVerilogParserRP)
		}
		{
			p.SetState(2585)
			p.Constraint_set()
		}
		p.SetState(2588)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 229, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2586)
				p.Match(SystemVerilogParserKELSE)
			}
			{
				p.SetState(2587)
				p.Constraint_set()
			}

		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2590)
			p.Match(SystemVerilogParserKFOREACH)
		}
		{
			p.SetState(2591)
			p.Match(SystemVerilogParserLP)
		}
		{
			p.SetState(2592)
			p.Ps_or_hierarchical_array_identifier()
		}
		{
			p.SetState(2593)
			p.Match(SystemVerilogParserLB)
		}
		{
			p.SetState(2594)
			p.Loop_variables()
		}
		{
			p.SetState(2595)
			p.Match(SystemVerilogParserRB)
		}
		{
			p.SetState(2596)
			p.Match(SystemVerilogParserRP)
		}
		{
			p.SetState(2597)
			p.Constraint_set()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2599)
			p.Match(SystemVerilogParserKDISABLE)
		}
		{
			p.SetState(2600)
			p.Match(SystemVerilogParserKSOFT)
		}
		{
			p.SetState(2601)
			p.Constraint_primary()
		}
		{
			p.SetState(2602)
			p.Match(SystemVerilogParserSEMI)
		}

	}

	return localctx
}

// IUniqueness_constraintContext is an interface to support dynamic dispatch.
type IUniqueness_constraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUniqueness_constraintContext differentiates from other interfaces.
	IsUniqueness_constraintContext()
}

type Uniqueness_constraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUniqueness_constraintContext() *Uniqueness_constraintContext {
	var p = new(Uniqueness_constraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_uniqueness_constraint
	return p
}

func (*Uniqueness_constraintContext) IsUniqueness_constraintContext() {}

func NewUniqueness_constraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Uniqueness_constraintContext {
	var p = new(Uniqueness_constraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_uniqueness_constraint

	return p
}

func (s *Uniqueness_constraintContext) GetParser() antlr.Parser { return s.parser }

func (s *Uniqueness_constraintContext) KUNIQUE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKUNIQUE, 0)
}

func (s *Uniqueness_constraintContext) AllOpen_range_list() []IOpen_range_listContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOpen_range_listContext)(nil)).Elem())
	var tst = make([]IOpen_range_listContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOpen_range_listContext)
		}
	}

	return tst
}

func (s *Uniqueness_constraintContext) Open_range_list(i int) IOpen_range_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOpen_range_listContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOpen_range_listContext)
}

func (s *Uniqueness_constraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Uniqueness_constraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Uniqueness_constraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterUniqueness_constraint(s)
	}
}

func (s *Uniqueness_constraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitUniqueness_constraint(s)
	}
}

func (p *SystemVerilogParser) Uniqueness_constraint() (localctx IUniqueness_constraintContext) {
	this := p
	_ = this

	localctx = NewUniqueness_constraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, SystemVerilogParserRULE_uniqueness_constraint)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2606)
		p.Match(SystemVerilogParserKUNIQUE)
	}
	p.SetState(2610)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SystemVerilogParserMINUS)|(1<<SystemVerilogParserMINUSMINS)|(1<<SystemVerilogParserNOT)|(1<<SystemVerilogParserDOLLAR)|(1<<SystemVerilogParserDROOT)|(1<<SystemVerilogParserDUNIT)|(1<<SystemVerilogParserAND)|(1<<SystemVerilogParserLP))) != 0) || (((_la-50)&-(0x1f+1)) == 0 && ((1<<uint((_la-50)))&((1<<(SystemVerilogParserLB-50))|(1<<(SystemVerilogParserQUOTE-50))|(1<<(SystemVerilogParserCARET-50))|(1<<(SystemVerilogParserCARETSQUIG-50))|(1<<(SystemVerilogParserLC-50))|(1<<(SystemVerilogParserBAR-50))|(1<<(SystemVerilogParserSQUIG-50))|(1<<(SystemVerilogParserSQUIGAND-50))|(1<<(SystemVerilogParserSQUIGCARET-50))|(1<<(SystemVerilogParserSQUIGBAR-50))|(1<<(SystemVerilogParserPLUS-50))|(1<<(SystemVerilogParserPLUSPLUS-50)))) != 0) || (((_la-109)&-(0x1f+1)) == 0 && ((1<<uint((_la-109)))&((1<<(SystemVerilogParserKBIT-109))|(1<<(SystemVerilogParserKBYTE-109))|(1<<(SystemVerilogParserKCONST-109)))) != 0) || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SystemVerilogParserKINT-195))|(1<<(SystemVerilogParserKINTEGER-195))|(1<<(SystemVerilogParserKLOCAL-195))|(1<<(SystemVerilogParserKLOGIC-195))|(1<<(SystemVerilogParserKLONGINT-195)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(SystemVerilogParserKNULL-228))|(1<<(SystemVerilogParserKRANDOMIZE-228))|(1<<(SystemVerilogParserKREAL-228))|(1<<(SystemVerilogParserKREALTIME-228))|(1<<(SystemVerilogParserKREG-228)))) != 0) || (((_la-276)&-(0x1f+1)) == 0 && ((1<<uint((_la-276)))&((1<<(SystemVerilogParserKSHORTINT-276))|(1<<(SystemVerilogParserKSHORTREAL-276))|(1<<(SystemVerilogParserKSIGNED-276))|(1<<(SystemVerilogParserKSTD-276))|(1<<(SystemVerilogParserKSTRING-276))|(1<<(SystemVerilogParserKSUPER-276))|(1<<(SystemVerilogParserKTAGGED-276))|(1<<(SystemVerilogParserKTHIS-276))|(1<<(SystemVerilogParserKTIME-276)))) != 0) || _la == SystemVerilogParserKTYPE || _la == SystemVerilogParserKUNSIGNED || (((_la-345)&-(0x1f+1)) == 0 && ((1<<uint((_la-345)))&((1<<(SystemVerilogParserTIME_LITERAL-345))|(1<<(SystemVerilogParserDECIMAL_NUMBER-345))|(1<<(SystemVerilogParserBINARY_NUMBER-345))|(1<<(SystemVerilogParserOCTAL_NUMBER-345))|(1<<(SystemVerilogParserHEX_NUMBER-345))|(1<<(SystemVerilogParserREAL_NUMBER-345))|(1<<(SystemVerilogParserUNSIGNED_NUMBER-345))|(1<<(SystemVerilogParserSTRING_LITERAL-345))|(1<<(SystemVerilogParserSIMPLE_IDENTIFIER-345))|(1<<(SystemVerilogParserSYSTEM_TF_IDENTIFIER-345)))) != 0) {
		{
			p.SetState(2607)
			p.Open_range_list()
		}

		p.SetState(2612)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IConstraint_setContext is an interface to support dynamic dispatch.
type IConstraint_setContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstraint_setContext differentiates from other interfaces.
	IsConstraint_setContext()
}

type Constraint_setContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstraint_setContext() *Constraint_setContext {
	var p = new(Constraint_setContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_constraint_set
	return p
}

func (*Constraint_setContext) IsConstraint_setContext() {}

func NewConstraint_setContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constraint_setContext {
	var p = new(Constraint_setContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_constraint_set

	return p
}

func (s *Constraint_setContext) GetParser() antlr.Parser { return s.parser }

func (s *Constraint_setContext) AllConstraint_expression() []IConstraint_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConstraint_expressionContext)(nil)).Elem())
	var tst = make([]IConstraint_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConstraint_expressionContext)
		}
	}

	return tst
}

func (s *Constraint_setContext) Constraint_expression(i int) IConstraint_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstraint_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConstraint_expressionContext)
}

func (s *Constraint_setContext) LC() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLC, 0)
}

func (s *Constraint_setContext) RC() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRC, 0)
}

func (s *Constraint_setContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constraint_setContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constraint_setContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterConstraint_set(s)
	}
}

func (s *Constraint_setContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitConstraint_set(s)
	}
}

func (p *SystemVerilogParser) Constraint_set() (localctx IConstraint_setContext) {
	this := p
	_ = this

	localctx = NewConstraint_setContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, SystemVerilogParserRULE_constraint_set)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2622)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 233, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2613)
			p.Constraint_expression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2614)
			p.Match(SystemVerilogParserLC)
		}
		p.SetState(2618)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SystemVerilogParserMINUS)|(1<<SystemVerilogParserMINUSMINS)|(1<<SystemVerilogParserNOT)|(1<<SystemVerilogParserDOLLAR)|(1<<SystemVerilogParserDROOT)|(1<<SystemVerilogParserDUNIT)|(1<<SystemVerilogParserAND)|(1<<SystemVerilogParserLP))) != 0) || (((_la-51)&-(0x1f+1)) == 0 && ((1<<uint((_la-51)))&((1<<(SystemVerilogParserQUOTE-51))|(1<<(SystemVerilogParserCARET-51))|(1<<(SystemVerilogParserCARETSQUIG-51))|(1<<(SystemVerilogParserLC-51))|(1<<(SystemVerilogParserBAR-51))|(1<<(SystemVerilogParserSQUIG-51))|(1<<(SystemVerilogParserSQUIGAND-51))|(1<<(SystemVerilogParserSQUIGCARET-51))|(1<<(SystemVerilogParserSQUIGBAR-51))|(1<<(SystemVerilogParserPLUS-51))|(1<<(SystemVerilogParserPLUSPLUS-51)))) != 0) || (((_la-109)&-(0x1f+1)) == 0 && ((1<<uint((_la-109)))&((1<<(SystemVerilogParserKBIT-109))|(1<<(SystemVerilogParserKBYTE-109))|(1<<(SystemVerilogParserKCONST-109))|(1<<(SystemVerilogParserKDISABLE-109)))) != 0) || (((_la-170)&-(0x1f+1)) == 0 && ((1<<uint((_la-170)))&((1<<(SystemVerilogParserKFOREACH-170))|(1<<(SystemVerilogParserKIF-170))|(1<<(SystemVerilogParserKINT-170))|(1<<(SystemVerilogParserKINTEGER-170)))) != 0) || (((_la-207)&-(0x1f+1)) == 0 && ((1<<uint((_la-207)))&((1<<(SystemVerilogParserKLOCAL-207))|(1<<(SystemVerilogParserKLOGIC-207))|(1<<(SystemVerilogParserKLONGINT-207))|(1<<(SystemVerilogParserKNULL-207)))) != 0) || (((_la-252)&-(0x1f+1)) == 0 && ((1<<uint((_la-252)))&((1<<(SystemVerilogParserKRANDOMIZE-252))|(1<<(SystemVerilogParserKREAL-252))|(1<<(SystemVerilogParserKREALTIME-252))|(1<<(SystemVerilogParserKREG-252))|(1<<(SystemVerilogParserKSHORTINT-252))|(1<<(SystemVerilogParserKSHORTREAL-252))|(1<<(SystemVerilogParserKSIGNED-252))|(1<<(SystemVerilogParserKSOFT-252)))) != 0) || (((_la-286)&-(0x1f+1)) == 0 && ((1<<uint((_la-286)))&((1<<(SystemVerilogParserKSTD-286))|(1<<(SystemVerilogParserKSTRING-286))|(1<<(SystemVerilogParserKSUPER-286))|(1<<(SystemVerilogParserKTAGGED-286))|(1<<(SystemVerilogParserKTHIS-286))|(1<<(SystemVerilogParserKTIME-286))|(1<<(SystemVerilogParserKTYPE-286))|(1<<(SystemVerilogParserKUNIQUE-286)))) != 0) || (((_la-319)&-(0x1f+1)) == 0 && ((1<<uint((_la-319)))&((1<<(SystemVerilogParserKUNSIGNED-319))|(1<<(SystemVerilogParserTIME_LITERAL-319))|(1<<(SystemVerilogParserDECIMAL_NUMBER-319))|(1<<(SystemVerilogParserBINARY_NUMBER-319))|(1<<(SystemVerilogParserOCTAL_NUMBER-319))|(1<<(SystemVerilogParserHEX_NUMBER-319))|(1<<(SystemVerilogParserREAL_NUMBER-319)))) != 0) || (((_la-351)&-(0x1f+1)) == 0 && ((1<<uint((_la-351)))&((1<<(SystemVerilogParserUNSIGNED_NUMBER-351))|(1<<(SystemVerilogParserSTRING_LITERAL-351))|(1<<(SystemVerilogParserSIMPLE_IDENTIFIER-351))|(1<<(SystemVerilogParserSYSTEM_TF_IDENTIFIER-351)))) != 0) {
			{
				p.SetState(2615)
				p.Constraint_expression()
			}

			p.SetState(2620)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2621)
			p.Match(SystemVerilogParserRC)
		}

	}

	return localctx
}

// IDist_listContext is an interface to support dynamic dispatch.
type IDist_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDist_listContext differentiates from other interfaces.
	IsDist_listContext()
}

type Dist_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDist_listContext() *Dist_listContext {
	var p = new(Dist_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_dist_list
	return p
}

func (*Dist_listContext) IsDist_listContext() {}

func NewDist_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dist_listContext {
	var p = new(Dist_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_dist_list

	return p
}

func (s *Dist_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Dist_listContext) AllDist_item() []IDist_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDist_itemContext)(nil)).Elem())
	var tst = make([]IDist_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDist_itemContext)
		}
	}

	return tst
}

func (s *Dist_listContext) Dist_item(i int) IDist_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDist_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDist_itemContext)
}

func (s *Dist_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *Dist_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *Dist_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dist_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dist_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterDist_list(s)
	}
}

func (s *Dist_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitDist_list(s)
	}
}

func (p *SystemVerilogParser) Dist_list() (localctx IDist_listContext) {
	this := p
	_ = this

	localctx = NewDist_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, SystemVerilogParserRULE_dist_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2624)
		p.Dist_item()
	}
	p.SetState(2629)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserCOMMA {
		{
			p.SetState(2625)
			p.Match(SystemVerilogParserCOMMA)
		}
		{
			p.SetState(2626)
			p.Dist_item()
		}

		p.SetState(2631)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IDist_itemContext is an interface to support dynamic dispatch.
type IDist_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDist_itemContext differentiates from other interfaces.
	IsDist_itemContext()
}

type Dist_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDist_itemContext() *Dist_itemContext {
	var p = new(Dist_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_dist_item
	return p
}

func (*Dist_itemContext) IsDist_itemContext() {}

func NewDist_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dist_itemContext {
	var p = new(Dist_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_dist_item

	return p
}

func (s *Dist_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Dist_itemContext) Value_range() IValue_rangeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValue_rangeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValue_rangeContext)
}

func (s *Dist_itemContext) Dist_weight() IDist_weightContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDist_weightContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDist_weightContext)
}

func (s *Dist_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dist_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dist_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterDist_item(s)
	}
}

func (s *Dist_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitDist_item(s)
	}
}

func (p *SystemVerilogParser) Dist_item() (localctx IDist_itemContext) {
	this := p
	_ = this

	localctx = NewDist_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, SystemVerilogParserRULE_dist_item)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2632)
		p.Value_range()
	}
	p.SetState(2634)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserCOLONSLASH || _la == SystemVerilogParserCOLONEQ {
		{
			p.SetState(2633)
			p.Dist_weight()
		}

	}

	return localctx
}

// IDist_weightContext is an interface to support dynamic dispatch.
type IDist_weightContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDist_weightContext differentiates from other interfaces.
	IsDist_weightContext()
}

type Dist_weightContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDist_weightContext() *Dist_weightContext {
	var p = new(Dist_weightContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_dist_weight
	return p
}

func (*Dist_weightContext) IsDist_weightContext() {}

func NewDist_weightContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dist_weightContext {
	var p = new(Dist_weightContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_dist_weight

	return p
}

func (s *Dist_weightContext) GetParser() antlr.Parser { return s.parser }

func (s *Dist_weightContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Dist_weightContext) COLONEQ() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOLONEQ, 0)
}

func (s *Dist_weightContext) COLONSLASH() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOLONSLASH, 0)
}

func (s *Dist_weightContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dist_weightContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dist_weightContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterDist_weight(s)
	}
}

func (s *Dist_weightContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitDist_weight(s)
	}
}

func (p *SystemVerilogParser) Dist_weight() (localctx IDist_weightContext) {
	this := p
	_ = this

	localctx = NewDist_weightContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, SystemVerilogParserRULE_dist_weight)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2636)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SystemVerilogParserCOLONSLASH || _la == SystemVerilogParserCOLONEQ) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(2637)
		p.expression(0)
	}

	return localctx
}

// IConstraint_prototypeContext is an interface to support dynamic dispatch.
type IConstraint_prototypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstraint_prototypeContext differentiates from other interfaces.
	IsConstraint_prototypeContext()
}

type Constraint_prototypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstraint_prototypeContext() *Constraint_prototypeContext {
	var p = new(Constraint_prototypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_constraint_prototype
	return p
}

func (*Constraint_prototypeContext) IsConstraint_prototypeContext() {}

func NewConstraint_prototypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constraint_prototypeContext {
	var p = new(Constraint_prototypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_constraint_prototype

	return p
}

func (s *Constraint_prototypeContext) GetParser() antlr.Parser { return s.parser }

func (s *Constraint_prototypeContext) KCONSTRAINT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKCONSTRAINT, 0)
}

func (s *Constraint_prototypeContext) Constraint_identifier() IConstraint_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstraint_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstraint_identifierContext)
}

func (s *Constraint_prototypeContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Constraint_prototypeContext) Constraint_prototype_qualifier() IConstraint_prototype_qualifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstraint_prototype_qualifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstraint_prototype_qualifierContext)
}

func (s *Constraint_prototypeContext) KSTATIC() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKSTATIC, 0)
}

func (s *Constraint_prototypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constraint_prototypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constraint_prototypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterConstraint_prototype(s)
	}
}

func (s *Constraint_prototypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitConstraint_prototype(s)
	}
}

func (p *SystemVerilogParser) Constraint_prototype() (localctx IConstraint_prototypeContext) {
	this := p
	_ = this

	localctx = NewConstraint_prototypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, SystemVerilogParserRULE_constraint_prototype)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2640)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserKEXTERN || _la == SystemVerilogParserKPURE {
		{
			p.SetState(2639)
			p.Constraint_prototype_qualifier()
		}

	}
	p.SetState(2643)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserKSTATIC {
		{
			p.SetState(2642)
			p.Match(SystemVerilogParserKSTATIC)
		}

	}
	{
		p.SetState(2645)
		p.Match(SystemVerilogParserKCONSTRAINT)
	}
	{
		p.SetState(2646)
		p.Constraint_identifier()
	}
	{
		p.SetState(2647)
		p.Match(SystemVerilogParserSEMI)
	}

	return localctx
}

// IConstraint_prototype_qualifierContext is an interface to support dynamic dispatch.
type IConstraint_prototype_qualifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstraint_prototype_qualifierContext differentiates from other interfaces.
	IsConstraint_prototype_qualifierContext()
}

type Constraint_prototype_qualifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstraint_prototype_qualifierContext() *Constraint_prototype_qualifierContext {
	var p = new(Constraint_prototype_qualifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_constraint_prototype_qualifier
	return p
}

func (*Constraint_prototype_qualifierContext) IsConstraint_prototype_qualifierContext() {}

func NewConstraint_prototype_qualifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constraint_prototype_qualifierContext {
	var p = new(Constraint_prototype_qualifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_constraint_prototype_qualifier

	return p
}

func (s *Constraint_prototype_qualifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Constraint_prototype_qualifierContext) KEXTERN() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKEXTERN, 0)
}

func (s *Constraint_prototype_qualifierContext) KPURE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKPURE, 0)
}

func (s *Constraint_prototype_qualifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constraint_prototype_qualifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constraint_prototype_qualifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterConstraint_prototype_qualifier(s)
	}
}

func (s *Constraint_prototype_qualifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitConstraint_prototype_qualifier(s)
	}
}

func (p *SystemVerilogParser) Constraint_prototype_qualifier() (localctx IConstraint_prototype_qualifierContext) {
	this := p
	_ = this

	localctx = NewConstraint_prototype_qualifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, SystemVerilogParserRULE_constraint_prototype_qualifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2649)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SystemVerilogParserKEXTERN || _la == SystemVerilogParserKPURE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IExtern_constraint_declarationContext is an interface to support dynamic dispatch.
type IExtern_constraint_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExtern_constraint_declarationContext differentiates from other interfaces.
	IsExtern_constraint_declarationContext()
}

type Extern_constraint_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtern_constraint_declarationContext() *Extern_constraint_declarationContext {
	var p = new(Extern_constraint_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_extern_constraint_declaration
	return p
}

func (*Extern_constraint_declarationContext) IsExtern_constraint_declarationContext() {}

func NewExtern_constraint_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Extern_constraint_declarationContext {
	var p = new(Extern_constraint_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_extern_constraint_declaration

	return p
}

func (s *Extern_constraint_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Extern_constraint_declarationContext) KCONSTRAINT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKCONSTRAINT, 0)
}

func (s *Extern_constraint_declarationContext) Class_scope() IClass_scopeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_scopeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClass_scopeContext)
}

func (s *Extern_constraint_declarationContext) Constraint_identifier() IConstraint_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstraint_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstraint_identifierContext)
}

func (s *Extern_constraint_declarationContext) Constraint_block() IConstraint_blockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstraint_blockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstraint_blockContext)
}

func (s *Extern_constraint_declarationContext) KSTATIC() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKSTATIC, 0)
}

func (s *Extern_constraint_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Extern_constraint_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Extern_constraint_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterExtern_constraint_declaration(s)
	}
}

func (s *Extern_constraint_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitExtern_constraint_declaration(s)
	}
}

func (p *SystemVerilogParser) Extern_constraint_declaration() (localctx IExtern_constraint_declarationContext) {
	this := p
	_ = this

	localctx = NewExtern_constraint_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, SystemVerilogParserRULE_extern_constraint_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2652)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserKSTATIC {
		{
			p.SetState(2651)
			p.Match(SystemVerilogParserKSTATIC)
		}

	}
	{
		p.SetState(2654)
		p.Match(SystemVerilogParserKCONSTRAINT)
	}
	{
		p.SetState(2655)
		p.Class_scope()
	}
	{
		p.SetState(2656)
		p.Constraint_identifier()
	}
	{
		p.SetState(2657)
		p.Constraint_block()
	}

	return localctx
}

// IIdentifier_listContext is an interface to support dynamic dispatch.
type IIdentifier_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdentifier_listContext differentiates from other interfaces.
	IsIdentifier_listContext()
}

type Identifier_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifier_listContext() *Identifier_listContext {
	var p = new(Identifier_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_identifier_list
	return p
}

func (*Identifier_listContext) IsIdentifier_listContext() {}

func NewIdentifier_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Identifier_listContext {
	var p = new(Identifier_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_identifier_list

	return p
}

func (s *Identifier_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Identifier_listContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *Identifier_listContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Identifier_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *Identifier_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *Identifier_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Identifier_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Identifier_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterIdentifier_list(s)
	}
}

func (s *Identifier_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitIdentifier_list(s)
	}
}

func (p *SystemVerilogParser) Identifier_list() (localctx IIdentifier_listContext) {
	this := p
	_ = this

	localctx = NewIdentifier_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, SystemVerilogParserRULE_identifier_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2659)
		p.Identifier()
	}
	p.SetState(2664)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserCOMMA {
		{
			p.SetState(2660)
			p.Match(SystemVerilogParserCOMMA)
		}
		{
			p.SetState(2661)
			p.Identifier()
		}

		p.SetState(2666)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IPackage_itemContext is an interface to support dynamic dispatch.
type IPackage_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPackage_itemContext differentiates from other interfaces.
	IsPackage_itemContext()
}

type Package_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackage_itemContext() *Package_itemContext {
	var p = new(Package_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_package_item
	return p
}

func (*Package_itemContext) IsPackage_itemContext() {}

func NewPackage_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Package_itemContext {
	var p = new(Package_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_package_item

	return p
}

func (s *Package_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Package_itemContext) Package_or_generate_item_declaration() IPackage_or_generate_item_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackage_or_generate_item_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPackage_or_generate_item_declarationContext)
}

func (s *Package_itemContext) Anonymous_program() IAnonymous_programContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnonymous_programContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnonymous_programContext)
}

func (s *Package_itemContext) Package_export_declaration() IPackage_export_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackage_export_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPackage_export_declarationContext)
}

func (s *Package_itemContext) Timeunits_declaration() ITimeunits_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITimeunits_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITimeunits_declarationContext)
}

func (s *Package_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Package_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Package_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterPackage_item(s)
	}
}

func (s *Package_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitPackage_item(s)
	}
}

func (p *SystemVerilogParser) Package_item() (localctx IPackage_itemContext) {
	this := p
	_ = this

	localctx = NewPackage_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, SystemVerilogParserRULE_package_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2671)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 240, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2667)
			p.Package_or_generate_item_declaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2668)
			p.Anonymous_program()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2669)
			p.Package_export_declaration()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2670)
			p.Timeunits_declaration()
		}

	}

	return localctx
}

// IPackage_or_generate_item_declarationContext is an interface to support dynamic dispatch.
type IPackage_or_generate_item_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPackage_or_generate_item_declarationContext differentiates from other interfaces.
	IsPackage_or_generate_item_declarationContext()
}

type Package_or_generate_item_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackage_or_generate_item_declarationContext() *Package_or_generate_item_declarationContext {
	var p = new(Package_or_generate_item_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_package_or_generate_item_declaration
	return p
}

func (*Package_or_generate_item_declarationContext) IsPackage_or_generate_item_declarationContext() {}

func NewPackage_or_generate_item_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Package_or_generate_item_declarationContext {
	var p = new(Package_or_generate_item_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_package_or_generate_item_declaration

	return p
}

func (s *Package_or_generate_item_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Package_or_generate_item_declarationContext) Net_declaration() INet_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INet_declarationContext)
}

func (s *Package_or_generate_item_declarationContext) Data_declaration() IData_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IData_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IData_declarationContext)
}

func (s *Package_or_generate_item_declarationContext) Task_declaration() ITask_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITask_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITask_declarationContext)
}

func (s *Package_or_generate_item_declarationContext) Function_declaration() IFunction_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_declarationContext)
}

func (s *Package_or_generate_item_declarationContext) Checker_declaration() IChecker_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IChecker_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IChecker_declarationContext)
}

func (s *Package_or_generate_item_declarationContext) Dpi_import_export() IDpi_import_exportContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDpi_import_exportContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDpi_import_exportContext)
}

func (s *Package_or_generate_item_declarationContext) Extern_constraint_declaration() IExtern_constraint_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtern_constraint_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtern_constraint_declarationContext)
}

func (s *Package_or_generate_item_declarationContext) Class_declaration() IClass_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClass_declarationContext)
}

func (s *Package_or_generate_item_declarationContext) Class_constructor_declaration() IClass_constructor_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_constructor_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClass_constructor_declarationContext)
}

func (s *Package_or_generate_item_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Package_or_generate_item_declarationContext) Local_parameter_declaration() ILocal_parameter_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILocal_parameter_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILocal_parameter_declarationContext)
}

func (s *Package_or_generate_item_declarationContext) Parameter_declaration() IParameter_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_declarationContext)
}

func (s *Package_or_generate_item_declarationContext) Covergroup_declaration() ICovergroup_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICovergroup_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICovergroup_declarationContext)
}

func (s *Package_or_generate_item_declarationContext) Assertion_item_declaration() IAssertion_item_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssertion_item_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssertion_item_declarationContext)
}

func (s *Package_or_generate_item_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Package_or_generate_item_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Package_or_generate_item_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterPackage_or_generate_item_declaration(s)
	}
}

func (s *Package_or_generate_item_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitPackage_or_generate_item_declaration(s)
	}
}

func (p *SystemVerilogParser) Package_or_generate_item_declaration() (localctx IPackage_or_generate_item_declarationContext) {
	this := p
	_ = this

	localctx = NewPackage_or_generate_item_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, SystemVerilogParserRULE_package_or_generate_item_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2689)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 242, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2673)
			p.Net_declaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2674)
			p.Data_declaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2675)
			p.Task_declaration()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2676)
			p.Function_declaration()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2677)
			p.Checker_declaration()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2678)
			p.Dpi_import_export()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2679)
			p.Extern_constraint_declaration()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(2680)
			p.Class_declaration()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(2681)
			p.Class_constructor_declaration()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		p.SetState(2684)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SystemVerilogParserKLOCALPARAM:
			{
				p.SetState(2682)
				p.Local_parameter_declaration()
			}

		case SystemVerilogParserKPARAMETER:
			{
				p.SetState(2683)
				p.Parameter_declaration()
			}

		case SystemVerilogParserSEMI:

		default:
		}
		{
			p.SetState(2686)
			p.Match(SystemVerilogParserSEMI)
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(2687)
			p.Covergroup_declaration()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(2688)
			p.Assertion_item_declaration()
		}

	}

	return localctx
}

// IAnonymous_programContext is an interface to support dynamic dispatch.
type IAnonymous_programContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnonymous_programContext differentiates from other interfaces.
	IsAnonymous_programContext()
}

type Anonymous_programContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnonymous_programContext() *Anonymous_programContext {
	var p = new(Anonymous_programContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_anonymous_program
	return p
}

func (*Anonymous_programContext) IsAnonymous_programContext() {}

func NewAnonymous_programContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Anonymous_programContext {
	var p = new(Anonymous_programContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_anonymous_program

	return p
}

func (s *Anonymous_programContext) GetParser() antlr.Parser { return s.parser }

func (s *Anonymous_programContext) KPROGRAM() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKPROGRAM, 0)
}

func (s *Anonymous_programContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Anonymous_programContext) KENDPROGRAM() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKENDPROGRAM, 0)
}

func (s *Anonymous_programContext) AllAnonymous_program_item() []IAnonymous_program_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnonymous_program_itemContext)(nil)).Elem())
	var tst = make([]IAnonymous_program_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnonymous_program_itemContext)
		}
	}

	return tst
}

func (s *Anonymous_programContext) Anonymous_program_item(i int) IAnonymous_program_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnonymous_program_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnonymous_program_itemContext)
}

func (s *Anonymous_programContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Anonymous_programContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Anonymous_programContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterAnonymous_program(s)
	}
}

func (s *Anonymous_programContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitAnonymous_program(s)
	}
}

func (p *SystemVerilogParser) Anonymous_program() (localctx IAnonymous_programContext) {
	this := p
	_ = this

	localctx = NewAnonymous_programContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, SystemVerilogParserRULE_anonymous_program)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2691)
		p.Match(SystemVerilogParserKPROGRAM)
	}
	{
		p.SetState(2692)
		p.Match(SystemVerilogParserSEMI)
	}
	p.SetState(2696)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserSEMI || _la == SystemVerilogParserKCLASS || _la == SystemVerilogParserKCOVERGROUP || _la == SystemVerilogParserKFUNCTION || _la == SystemVerilogParserKTASK || _la == SystemVerilogParserKVIRTUAL {
		{
			p.SetState(2693)
			p.Anonymous_program_item()
		}

		p.SetState(2698)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2699)
		p.Match(SystemVerilogParserKENDPROGRAM)
	}

	return localctx
}

// IAnonymous_program_itemContext is an interface to support dynamic dispatch.
type IAnonymous_program_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnonymous_program_itemContext differentiates from other interfaces.
	IsAnonymous_program_itemContext()
}

type Anonymous_program_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnonymous_program_itemContext() *Anonymous_program_itemContext {
	var p = new(Anonymous_program_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_anonymous_program_item
	return p
}

func (*Anonymous_program_itemContext) IsAnonymous_program_itemContext() {}

func NewAnonymous_program_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Anonymous_program_itemContext {
	var p = new(Anonymous_program_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_anonymous_program_item

	return p
}

func (s *Anonymous_program_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Anonymous_program_itemContext) Task_declaration() ITask_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITask_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITask_declarationContext)
}

func (s *Anonymous_program_itemContext) Function_declaration() IFunction_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_declarationContext)
}

func (s *Anonymous_program_itemContext) Class_declaration() IClass_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClass_declarationContext)
}

func (s *Anonymous_program_itemContext) Covergroup_declaration() ICovergroup_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICovergroup_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICovergroup_declarationContext)
}

func (s *Anonymous_program_itemContext) Class_constructor_declaration() IClass_constructor_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_constructor_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClass_constructor_declarationContext)
}

func (s *Anonymous_program_itemContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Anonymous_program_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Anonymous_program_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Anonymous_program_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterAnonymous_program_item(s)
	}
}

func (s *Anonymous_program_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitAnonymous_program_item(s)
	}
}

func (p *SystemVerilogParser) Anonymous_program_item() (localctx IAnonymous_program_itemContext) {
	this := p
	_ = this

	localctx = NewAnonymous_program_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, SystemVerilogParserRULE_anonymous_program_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2707)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 244, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2701)
			p.Task_declaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2702)
			p.Function_declaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2703)
			p.Class_declaration()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2704)
			p.Covergroup_declaration()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2705)
			p.Class_constructor_declaration()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2706)
			p.Match(SystemVerilogParserSEMI)
		}

	}

	return localctx
}

// ILocal_parameter_declarationContext is an interface to support dynamic dispatch.
type ILocal_parameter_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLocal_parameter_declarationContext differentiates from other interfaces.
	IsLocal_parameter_declarationContext()
}

type Local_parameter_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLocal_parameter_declarationContext() *Local_parameter_declarationContext {
	var p = new(Local_parameter_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_local_parameter_declaration
	return p
}

func (*Local_parameter_declarationContext) IsLocal_parameter_declarationContext() {}

func NewLocal_parameter_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Local_parameter_declarationContext {
	var p = new(Local_parameter_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_local_parameter_declaration

	return p
}

func (s *Local_parameter_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Local_parameter_declarationContext) KLOCALPARAM() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKLOCALPARAM, 0)
}

func (s *Local_parameter_declarationContext) Data_type_or_implicit() IData_type_or_implicitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IData_type_or_implicitContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IData_type_or_implicitContext)
}

func (s *Local_parameter_declarationContext) List_of_param_assignments() IList_of_param_assignmentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_param_assignmentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_param_assignmentsContext)
}

func (s *Local_parameter_declarationContext) KTYPE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKTYPE, 0)
}

func (s *Local_parameter_declarationContext) List_of_type_assignments() IList_of_type_assignmentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_type_assignmentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_type_assignmentsContext)
}

func (s *Local_parameter_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Local_parameter_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Local_parameter_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterLocal_parameter_declaration(s)
	}
}

func (s *Local_parameter_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitLocal_parameter_declaration(s)
	}
}

func (p *SystemVerilogParser) Local_parameter_declaration() (localctx ILocal_parameter_declarationContext) {
	this := p
	_ = this

	localctx = NewLocal_parameter_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, SystemVerilogParserRULE_local_parameter_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2709)
		p.Match(SystemVerilogParserKLOCALPARAM)
	}
	p.SetState(2715)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 245, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2710)
			p.Data_type_or_implicit()
		}
		{
			p.SetState(2711)
			p.List_of_param_assignments()
		}

	case 2:
		{
			p.SetState(2713)
			p.Match(SystemVerilogParserKTYPE)
		}
		{
			p.SetState(2714)
			p.List_of_type_assignments()
		}

	}

	return localctx
}

// IParameter_declarationContext is an interface to support dynamic dispatch.
type IParameter_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameter_declarationContext differentiates from other interfaces.
	IsParameter_declarationContext()
}

type Parameter_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameter_declarationContext() *Parameter_declarationContext {
	var p = new(Parameter_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_parameter_declaration
	return p
}

func (*Parameter_declarationContext) IsParameter_declarationContext() {}

func NewParameter_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Parameter_declarationContext {
	var p = new(Parameter_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_parameter_declaration

	return p
}

func (s *Parameter_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Parameter_declarationContext) KPARAMETER() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKPARAMETER, 0)
}

func (s *Parameter_declarationContext) Data_type_or_implicit() IData_type_or_implicitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IData_type_or_implicitContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IData_type_or_implicitContext)
}

func (s *Parameter_declarationContext) List_of_param_assignments() IList_of_param_assignmentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_param_assignmentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_param_assignmentsContext)
}

func (s *Parameter_declarationContext) KTYPE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKTYPE, 0)
}

func (s *Parameter_declarationContext) List_of_type_assignments() IList_of_type_assignmentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_type_assignmentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_type_assignmentsContext)
}

func (s *Parameter_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parameter_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Parameter_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterParameter_declaration(s)
	}
}

func (s *Parameter_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitParameter_declaration(s)
	}
}

func (p *SystemVerilogParser) Parameter_declaration() (localctx IParameter_declarationContext) {
	this := p
	_ = this

	localctx = NewParameter_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, SystemVerilogParserRULE_parameter_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2717)
		p.Match(SystemVerilogParserKPARAMETER)
	}
	p.SetState(2723)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 246, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2718)
			p.Data_type_or_implicit()
		}
		{
			p.SetState(2719)
			p.List_of_param_assignments()
		}

	case 2:
		{
			p.SetState(2721)
			p.Match(SystemVerilogParserKTYPE)
		}
		{
			p.SetState(2722)
			p.List_of_type_assignments()
		}

	}

	return localctx
}

// ISpecparam_declarationContext is an interface to support dynamic dispatch.
type ISpecparam_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSpecparam_declarationContext differentiates from other interfaces.
	IsSpecparam_declarationContext()
}

type Specparam_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpecparam_declarationContext() *Specparam_declarationContext {
	var p = new(Specparam_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_specparam_declaration
	return p
}

func (*Specparam_declarationContext) IsSpecparam_declarationContext() {}

func NewSpecparam_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Specparam_declarationContext {
	var p = new(Specparam_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_specparam_declaration

	return p
}

func (s *Specparam_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Specparam_declarationContext) KSPECPARAM() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKSPECPARAM, 0)
}

func (s *Specparam_declarationContext) List_of_specparam_assignments() IList_of_specparam_assignmentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_specparam_assignmentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_specparam_assignmentsContext)
}

func (s *Specparam_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Specparam_declarationContext) Packed_dimension() IPacked_dimensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPacked_dimensionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPacked_dimensionContext)
}

func (s *Specparam_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Specparam_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Specparam_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterSpecparam_declaration(s)
	}
}

func (s *Specparam_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitSpecparam_declaration(s)
	}
}

func (p *SystemVerilogParser) Specparam_declaration() (localctx ISpecparam_declarationContext) {
	this := p
	_ = this

	localctx = NewSpecparam_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, SystemVerilogParserRULE_specparam_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2725)
		p.Match(SystemVerilogParserKSPECPARAM)
	}
	p.SetState(2727)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserLB {
		{
			p.SetState(2726)
			p.Packed_dimension()
		}

	}
	{
		p.SetState(2729)
		p.List_of_specparam_assignments()
	}
	{
		p.SetState(2730)
		p.Match(SystemVerilogParserSEMI)
	}

	return localctx
}

// IInout_declarationContext is an interface to support dynamic dispatch.
type IInout_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInout_declarationContext differentiates from other interfaces.
	IsInout_declarationContext()
}

type Inout_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInout_declarationContext() *Inout_declarationContext {
	var p = new(Inout_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_inout_declaration
	return p
}

func (*Inout_declarationContext) IsInout_declarationContext() {}

func NewInout_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Inout_declarationContext {
	var p = new(Inout_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_inout_declaration

	return p
}

func (s *Inout_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Inout_declarationContext) KINOUT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKINOUT, 0)
}

func (s *Inout_declarationContext) Net_port_type() INet_port_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_port_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INet_port_typeContext)
}

func (s *Inout_declarationContext) List_of_port_identifiers() IList_of_port_identifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_port_identifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_port_identifiersContext)
}

func (s *Inout_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Inout_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Inout_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterInout_declaration(s)
	}
}

func (s *Inout_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitInout_declaration(s)
	}
}

func (p *SystemVerilogParser) Inout_declaration() (localctx IInout_declarationContext) {
	this := p
	_ = this

	localctx = NewInout_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, SystemVerilogParserRULE_inout_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2732)
		p.Match(SystemVerilogParserKINOUT)
	}
	{
		p.SetState(2733)
		p.Net_port_type()
	}
	{
		p.SetState(2734)
		p.List_of_port_identifiers()
	}

	return localctx
}

// IInput_declarationContext is an interface to support dynamic dispatch.
type IInput_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInput_declarationContext differentiates from other interfaces.
	IsInput_declarationContext()
}

type Input_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInput_declarationContext() *Input_declarationContext {
	var p = new(Input_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_input_declaration
	return p
}

func (*Input_declarationContext) IsInput_declarationContext() {}

func NewInput_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Input_declarationContext {
	var p = new(Input_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_input_declaration

	return p
}

func (s *Input_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Input_declarationContext) KINPUT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKINPUT, 0)
}

func (s *Input_declarationContext) Net_port_type() INet_port_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_port_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INet_port_typeContext)
}

func (s *Input_declarationContext) List_of_port_identifiers() IList_of_port_identifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_port_identifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_port_identifiersContext)
}

func (s *Input_declarationContext) Variable_port_type() IVariable_port_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_port_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_port_typeContext)
}

func (s *Input_declarationContext) List_of_variable_identifiers() IList_of_variable_identifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_variable_identifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_variable_identifiersContext)
}

func (s *Input_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Input_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Input_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterInput_declaration(s)
	}
}

func (s *Input_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitInput_declaration(s)
	}
}

func (p *SystemVerilogParser) Input_declaration() (localctx IInput_declarationContext) {
	this := p
	_ = this

	localctx = NewInput_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, SystemVerilogParserRULE_input_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2736)
		p.Match(SystemVerilogParserKINPUT)
	}
	p.SetState(2743)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 248, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2737)
			p.Net_port_type()
		}
		{
			p.SetState(2738)
			p.List_of_port_identifiers()
		}

	case 2:
		{
			p.SetState(2740)
			p.Variable_port_type()
		}
		{
			p.SetState(2741)
			p.List_of_variable_identifiers()
		}

	}

	return localctx
}

// IOutput_declarationContext is an interface to support dynamic dispatch.
type IOutput_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOutput_declarationContext differentiates from other interfaces.
	IsOutput_declarationContext()
}

type Output_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOutput_declarationContext() *Output_declarationContext {
	var p = new(Output_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_output_declaration
	return p
}

func (*Output_declarationContext) IsOutput_declarationContext() {}

func NewOutput_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Output_declarationContext {
	var p = new(Output_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_output_declaration

	return p
}

func (s *Output_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Output_declarationContext) KOUTPUT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKOUTPUT, 0)
}

func (s *Output_declarationContext) Net_port_type() INet_port_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_port_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INet_port_typeContext)
}

func (s *Output_declarationContext) List_of_port_identifiers() IList_of_port_identifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_port_identifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_port_identifiersContext)
}

func (s *Output_declarationContext) Variable_port_type() IVariable_port_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_port_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_port_typeContext)
}

func (s *Output_declarationContext) List_of_variable_port_identifiers() IList_of_variable_port_identifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_variable_port_identifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_variable_port_identifiersContext)
}

func (s *Output_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Output_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Output_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterOutput_declaration(s)
	}
}

func (s *Output_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitOutput_declaration(s)
	}
}

func (p *SystemVerilogParser) Output_declaration() (localctx IOutput_declarationContext) {
	this := p
	_ = this

	localctx = NewOutput_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, SystemVerilogParserRULE_output_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2745)
		p.Match(SystemVerilogParserKOUTPUT)
	}
	p.SetState(2752)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 249, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2746)
			p.Net_port_type()
		}
		{
			p.SetState(2747)
			p.List_of_port_identifiers()
		}

	case 2:
		{
			p.SetState(2749)
			p.Variable_port_type()
		}
		{
			p.SetState(2750)
			p.List_of_variable_port_identifiers()
		}

	}

	return localctx
}

// IInterface_port_declarationContext is an interface to support dynamic dispatch.
type IInterface_port_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterface_port_declarationContext differentiates from other interfaces.
	IsInterface_port_declarationContext()
}

type Interface_port_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterface_port_declarationContext() *Interface_port_declarationContext {
	var p = new(Interface_port_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_interface_port_declaration
	return p
}

func (*Interface_port_declarationContext) IsInterface_port_declarationContext() {}

func NewInterface_port_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Interface_port_declarationContext {
	var p = new(Interface_port_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_interface_port_declaration

	return p
}

func (s *Interface_port_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Interface_port_declarationContext) Interface_identifier() IInterface_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterface_identifierContext)
}

func (s *Interface_port_declarationContext) List_of_interface_identifiers() IList_of_interface_identifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_interface_identifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_interface_identifiersContext)
}

func (s *Interface_port_declarationContext) DOT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserDOT, 0)
}

func (s *Interface_port_declarationContext) Modport_identifier() IModport_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModport_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModport_identifierContext)
}

func (s *Interface_port_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Interface_port_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Interface_port_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterInterface_port_declaration(s)
	}
}

func (s *Interface_port_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitInterface_port_declaration(s)
	}
}

func (p *SystemVerilogParser) Interface_port_declaration() (localctx IInterface_port_declarationContext) {
	this := p
	_ = this

	localctx = NewInterface_port_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, SystemVerilogParserRULE_interface_port_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2754)
		p.Interface_identifier()
	}
	p.SetState(2757)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserDOT {
		{
			p.SetState(2755)
			p.Match(SystemVerilogParserDOT)
		}
		{
			p.SetState(2756)
			p.Modport_identifier()
		}

	}
	{
		p.SetState(2759)
		p.List_of_interface_identifiers()
	}

	return localctx
}

// IRef_declarationContext is an interface to support dynamic dispatch.
type IRef_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRef_declarationContext differentiates from other interfaces.
	IsRef_declarationContext()
}

type Ref_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRef_declarationContext() *Ref_declarationContext {
	var p = new(Ref_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_ref_declaration
	return p
}

func (*Ref_declarationContext) IsRef_declarationContext() {}

func NewRef_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Ref_declarationContext {
	var p = new(Ref_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_ref_declaration

	return p
}

func (s *Ref_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Ref_declarationContext) KREF() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKREF, 0)
}

func (s *Ref_declarationContext) Variable_port_type() IVariable_port_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_port_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_port_typeContext)
}

func (s *Ref_declarationContext) List_of_variable_identifiers() IList_of_variable_identifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_variable_identifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_variable_identifiersContext)
}

func (s *Ref_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ref_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Ref_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterRef_declaration(s)
	}
}

func (s *Ref_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitRef_declaration(s)
	}
}

func (p *SystemVerilogParser) Ref_declaration() (localctx IRef_declarationContext) {
	this := p
	_ = this

	localctx = NewRef_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, SystemVerilogParserRULE_ref_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2761)
		p.Match(SystemVerilogParserKREF)
	}
	{
		p.SetState(2762)
		p.Variable_port_type()
	}
	{
		p.SetState(2763)
		p.List_of_variable_identifiers()
	}

	return localctx
}

// IData_declarationContext is an interface to support dynamic dispatch.
type IData_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsData_declarationContext differentiates from other interfaces.
	IsData_declarationContext()
}

type Data_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyData_declarationContext() *Data_declarationContext {
	var p = new(Data_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_data_declaration
	return p
}

func (*Data_declarationContext) IsData_declarationContext() {}

func NewData_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Data_declarationContext {
	var p = new(Data_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_data_declaration

	return p
}

func (s *Data_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Data_declarationContext) Data_type_or_implicit() IData_type_or_implicitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IData_type_or_implicitContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IData_type_or_implicitContext)
}

func (s *Data_declarationContext) List_of_variable_decl_assignments() IList_of_variable_decl_assignmentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_variable_decl_assignmentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_variable_decl_assignmentsContext)
}

func (s *Data_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Data_declarationContext) KCONST() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKCONST, 0)
}

func (s *Data_declarationContext) KVAR() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKVAR, 0)
}

func (s *Data_declarationContext) Lifetime() ILifetimeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILifetimeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILifetimeContext)
}

func (s *Data_declarationContext) Type_declaration() IType_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_declarationContext)
}

func (s *Data_declarationContext) Package_import_declaration() IPackage_import_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackage_import_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPackage_import_declarationContext)
}

func (s *Data_declarationContext) Net_type_declaration() INet_type_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_type_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INet_type_declarationContext)
}

func (s *Data_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Data_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Data_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterData_declaration(s)
	}
}

func (s *Data_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitData_declaration(s)
	}
}

func (p *SystemVerilogParser) Data_declaration() (localctx IData_declarationContext) {
	this := p
	_ = this

	localctx = NewData_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, SystemVerilogParserRULE_data_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2781)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserDUNIT, SystemVerilogParserLB, SystemVerilogParserKAUTOMATIC, SystemVerilogParserKBIT, SystemVerilogParserKBYTE, SystemVerilogParserKCHANDLE, SystemVerilogParserKCONST, SystemVerilogParserKENUM, SystemVerilogParserKEVENT, SystemVerilogParserKINT, SystemVerilogParserKINTEGER, SystemVerilogParserKLOGIC, SystemVerilogParserKLONGINT, SystemVerilogParserKREAL, SystemVerilogParserKREALTIME, SystemVerilogParserKREG, SystemVerilogParserKSHORTINT, SystemVerilogParserKSHORTREAL, SystemVerilogParserKSIGNED, SystemVerilogParserKSTATIC, SystemVerilogParserKSTRING, SystemVerilogParserKSTRUCT, SystemVerilogParserKTIME, SystemVerilogParserKTYPE, SystemVerilogParserKUNION, SystemVerilogParserKUNSIGNED, SystemVerilogParserKVAR, SystemVerilogParserKVIRTUAL, SystemVerilogParserSIMPLE_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(2766)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserKCONST {
			{
				p.SetState(2765)
				p.Match(SystemVerilogParserKCONST)
			}

		}
		p.SetState(2769)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserKVAR {
			{
				p.SetState(2768)
				p.Match(SystemVerilogParserKVAR)
			}

		}
		p.SetState(2772)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserKAUTOMATIC || _la == SystemVerilogParserKSTATIC {
			{
				p.SetState(2771)
				p.Lifetime()
			}

		}
		{
			p.SetState(2774)
			p.Data_type_or_implicit()
		}
		{
			p.SetState(2775)
			p.List_of_variable_decl_assignments()
		}
		{
			p.SetState(2776)
			p.Match(SystemVerilogParserSEMI)
		}

	case SystemVerilogParserKTYPEDEF:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2778)
			p.Type_declaration()
		}

	case SystemVerilogParserKIMPORT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2779)
			p.Package_import_declaration()
		}

	case SystemVerilogParserKNETTYPE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2780)
			p.Net_type_declaration()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPackage_import_declarationContext is an interface to support dynamic dispatch.
type IPackage_import_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPackage_import_declarationContext differentiates from other interfaces.
	IsPackage_import_declarationContext()
}

type Package_import_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackage_import_declarationContext() *Package_import_declarationContext {
	var p = new(Package_import_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_package_import_declaration
	return p
}

func (*Package_import_declarationContext) IsPackage_import_declarationContext() {}

func NewPackage_import_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Package_import_declarationContext {
	var p = new(Package_import_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_package_import_declaration

	return p
}

func (s *Package_import_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Package_import_declarationContext) KIMPORT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKIMPORT, 0)
}

func (s *Package_import_declarationContext) AllPackage_import_item() []IPackage_import_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPackage_import_itemContext)(nil)).Elem())
	var tst = make([]IPackage_import_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPackage_import_itemContext)
		}
	}

	return tst
}

func (s *Package_import_declarationContext) Package_import_item(i int) IPackage_import_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackage_import_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPackage_import_itemContext)
}

func (s *Package_import_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Package_import_declarationContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *Package_import_declarationContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *Package_import_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Package_import_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Package_import_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterPackage_import_declaration(s)
	}
}

func (s *Package_import_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitPackage_import_declaration(s)
	}
}

func (p *SystemVerilogParser) Package_import_declaration() (localctx IPackage_import_declarationContext) {
	this := p
	_ = this

	localctx = NewPackage_import_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, SystemVerilogParserRULE_package_import_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2783)
		p.Match(SystemVerilogParserKIMPORT)
	}
	{
		p.SetState(2784)
		p.Package_import_item()
	}
	p.SetState(2789)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserCOMMA {
		{
			p.SetState(2785)
			p.Match(SystemVerilogParserCOMMA)
		}
		{
			p.SetState(2786)
			p.Package_import_item()
		}

		p.SetState(2791)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2792)
		p.Match(SystemVerilogParserSEMI)
	}

	return localctx
}

// IPackage_import_itemContext is an interface to support dynamic dispatch.
type IPackage_import_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPackage_import_itemContext differentiates from other interfaces.
	IsPackage_import_itemContext()
}

type Package_import_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackage_import_itemContext() *Package_import_itemContext {
	var p = new(Package_import_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_package_import_item
	return p
}

func (*Package_import_itemContext) IsPackage_import_itemContext() {}

func NewPackage_import_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Package_import_itemContext {
	var p = new(Package_import_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_package_import_item

	return p
}

func (s *Package_import_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Package_import_itemContext) Package_identifier() IPackage_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackage_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPackage_identifierContext)
}

func (s *Package_import_itemContext) COLONCOLON() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOLONCOLON, 0)
}

func (s *Package_import_itemContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Package_import_itemContext) STAR() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSTAR, 0)
}

func (s *Package_import_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Package_import_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Package_import_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterPackage_import_item(s)
	}
}

func (s *Package_import_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitPackage_import_item(s)
	}
}

func (p *SystemVerilogParser) Package_import_item() (localctx IPackage_import_itemContext) {
	this := p
	_ = this

	localctx = NewPackage_import_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, SystemVerilogParserRULE_package_import_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2794)
		p.Package_identifier()
	}
	{
		p.SetState(2795)
		p.Match(SystemVerilogParserCOLONCOLON)
	}
	p.SetState(2798)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserSIMPLE_IDENTIFIER:
		{
			p.SetState(2796)
			p.Identifier()
		}

	case SystemVerilogParserSTAR:
		{
			p.SetState(2797)
			p.Match(SystemVerilogParserSTAR)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPackage_export_declarationContext is an interface to support dynamic dispatch.
type IPackage_export_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPackage_export_declarationContext differentiates from other interfaces.
	IsPackage_export_declarationContext()
}

type Package_export_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackage_export_declarationContext() *Package_export_declarationContext {
	var p = new(Package_export_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_package_export_declaration
	return p
}

func (*Package_export_declarationContext) IsPackage_export_declarationContext() {}

func NewPackage_export_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Package_export_declarationContext {
	var p = new(Package_export_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_package_export_declaration

	return p
}

func (s *Package_export_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Package_export_declarationContext) KEXPORT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKEXPORT, 0)
}

func (s *Package_export_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Package_export_declarationContext) SCCS() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSCCS, 0)
}

func (s *Package_export_declarationContext) AllPackage_import_item() []IPackage_import_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPackage_import_itemContext)(nil)).Elem())
	var tst = make([]IPackage_import_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPackage_import_itemContext)
		}
	}

	return tst
}

func (s *Package_export_declarationContext) Package_import_item(i int) IPackage_import_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackage_import_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPackage_import_itemContext)
}

func (s *Package_export_declarationContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *Package_export_declarationContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *Package_export_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Package_export_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Package_export_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterPackage_export_declaration(s)
	}
}

func (s *Package_export_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitPackage_export_declaration(s)
	}
}

func (p *SystemVerilogParser) Package_export_declaration() (localctx IPackage_export_declarationContext) {
	this := p
	_ = this

	localctx = NewPackage_export_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, SystemVerilogParserRULE_package_export_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2800)
		p.Match(SystemVerilogParserKEXPORT)
	}
	p.SetState(2810)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserSCCS:
		{
			p.SetState(2801)
			p.Match(SystemVerilogParserSCCS)
		}

	case SystemVerilogParserSIMPLE_IDENTIFIER:
		{
			p.SetState(2802)
			p.Package_import_item()
		}
		p.SetState(2807)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserCOMMA {
			{
				p.SetState(2803)
				p.Match(SystemVerilogParserCOMMA)
			}
			{
				p.SetState(2804)
				p.Package_import_item()
			}

			p.SetState(2809)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(2812)
		p.Match(SystemVerilogParserSEMI)
	}

	return localctx
}

// IGenvar_declarationContext is an interface to support dynamic dispatch.
type IGenvar_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenvar_declarationContext differentiates from other interfaces.
	IsGenvar_declarationContext()
}

type Genvar_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenvar_declarationContext() *Genvar_declarationContext {
	var p = new(Genvar_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_genvar_declaration
	return p
}

func (*Genvar_declarationContext) IsGenvar_declarationContext() {}

func NewGenvar_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Genvar_declarationContext {
	var p = new(Genvar_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_genvar_declaration

	return p
}

func (s *Genvar_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Genvar_declarationContext) KGENVAR() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKGENVAR, 0)
}

func (s *Genvar_declarationContext) List_of_genvar_identifiers() IList_of_genvar_identifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_genvar_identifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_genvar_identifiersContext)
}

func (s *Genvar_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Genvar_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Genvar_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Genvar_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterGenvar_declaration(s)
	}
}

func (s *Genvar_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitGenvar_declaration(s)
	}
}

func (p *SystemVerilogParser) Genvar_declaration() (localctx IGenvar_declarationContext) {
	this := p
	_ = this

	localctx = NewGenvar_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, SystemVerilogParserRULE_genvar_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2814)
		p.Match(SystemVerilogParserKGENVAR)
	}
	{
		p.SetState(2815)
		p.List_of_genvar_identifiers()
	}
	{
		p.SetState(2816)
		p.Match(SystemVerilogParserSEMI)
	}

	return localctx
}

// INet_declarationContext is an interface to support dynamic dispatch.
type INet_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNet_declarationContext differentiates from other interfaces.
	IsNet_declarationContext()
}

type Net_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNet_declarationContext() *Net_declarationContext {
	var p = new(Net_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_net_declaration
	return p
}

func (*Net_declarationContext) IsNet_declarationContext() {}

func NewNet_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Net_declarationContext {
	var p = new(Net_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_net_declaration

	return p
}

func (s *Net_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Net_declarationContext) Net_type() INet_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INet_typeContext)
}

func (s *Net_declarationContext) Data_type_or_implicit() IData_type_or_implicitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IData_type_or_implicitContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IData_type_or_implicitContext)
}

func (s *Net_declarationContext) List_of_net_decl_assignments() IList_of_net_decl_assignmentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_net_decl_assignmentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_net_decl_assignmentsContext)
}

func (s *Net_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Net_declarationContext) Drive_strength() IDrive_strengthContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDrive_strengthContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDrive_strengthContext)
}

func (s *Net_declarationContext) Charge_strength() ICharge_strengthContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICharge_strengthContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICharge_strengthContext)
}

func (s *Net_declarationContext) Delay3() IDelay3Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelay3Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelay3Context)
}

func (s *Net_declarationContext) KVECTORED() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKVECTORED, 0)
}

func (s *Net_declarationContext) KSCALARED() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKSCALARED, 0)
}

func (s *Net_declarationContext) Net_type_identifier() INet_type_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_type_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INet_type_identifierContext)
}

func (s *Net_declarationContext) Delay_control() IDelay_controlContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelay_controlContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelay_controlContext)
}

func (s *Net_declarationContext) KINTERCONNECT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKINTERCONNECT, 0)
}

func (s *Net_declarationContext) Implicit_data_type() IImplicit_data_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImplicit_data_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImplicit_data_typeContext)
}

func (s *Net_declarationContext) AllNet_identifier() []INet_identifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INet_identifierContext)(nil)).Elem())
	var tst = make([]INet_identifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INet_identifierContext)
		}
	}

	return tst
}

func (s *Net_declarationContext) Net_identifier(i int) INet_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_identifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INet_identifierContext)
}

func (s *Net_declarationContext) P() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserP, 0)
}

func (s *Net_declarationContext) Delay_value() IDelay_valueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelay_valueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelay_valueContext)
}

func (s *Net_declarationContext) AllUnpacked_dimension() []IUnpacked_dimensionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IUnpacked_dimensionContext)(nil)).Elem())
	var tst = make([]IUnpacked_dimensionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IUnpacked_dimensionContext)
		}
	}

	return tst
}

func (s *Net_declarationContext) Unpacked_dimension(i int) IUnpacked_dimensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnpacked_dimensionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IUnpacked_dimensionContext)
}

func (s *Net_declarationContext) COMMA() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, 0)
}

func (s *Net_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Net_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Net_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterNet_declaration(s)
	}
}

func (s *Net_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitNet_declaration(s)
	}
}

func (p *SystemVerilogParser) Net_declaration() (localctx INet_declarationContext) {
	this := p
	_ = this

	localctx = NewNet_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, SystemVerilogParserRULE_net_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2865)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserKSUPPLY0, SystemVerilogParserKSUPPLY1, SystemVerilogParserKTRI, SystemVerilogParserKTRI0, SystemVerilogParserKTRI1, SystemVerilogParserKTRIAND, SystemVerilogParserKTRIOR, SystemVerilogParserKTRIREG, SystemVerilogParserKUWIRE, SystemVerilogParserKWAND, SystemVerilogParserKWIRE, SystemVerilogParserKWOR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2818)
			p.Net_type()
		}
		p.SetState(2821)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 259, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2819)
				p.Drive_strength()
			}

		} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 259, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(2820)
				p.Charge_strength()
			}

		}
		p.SetState(2824)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserKSCALARED || _la == SystemVerilogParserKVECTORED {
			{
				p.SetState(2823)
				_la = p.GetTokenStream().LA(1)

				if !(_la == SystemVerilogParserKSCALARED || _la == SystemVerilogParserKVECTORED) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(2826)
			p.Data_type_or_implicit()
		}
		p.SetState(2828)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserP {
			{
				p.SetState(2827)
				p.Delay3()
			}

		}
		{
			p.SetState(2830)
			p.List_of_net_decl_assignments()
		}
		{
			p.SetState(2831)
			p.Match(SystemVerilogParserSEMI)
		}

	case SystemVerilogParserSIMPLE_IDENTIFIER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2833)
			p.Net_type_identifier()
		}
		p.SetState(2835)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserP {
			{
				p.SetState(2834)
				p.Delay_control()
			}

		}
		{
			p.SetState(2837)
			p.List_of_net_decl_assignments()
		}
		{
			p.SetState(2838)
			p.Match(SystemVerilogParserSEMI)
		}

	case SystemVerilogParserKINTERCONNECT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2840)
			p.Match(SystemVerilogParserKINTERCONNECT)
		}
		{
			p.SetState(2841)
			p.Implicit_data_type()
		}
		p.SetState(2844)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserP {
			{
				p.SetState(2842)
				p.Match(SystemVerilogParserP)
			}
			{
				p.SetState(2843)
				p.Delay_value()
			}

		}
		{
			p.SetState(2846)
			p.Net_identifier()
		}
		p.SetState(2850)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserLB {
			{
				p.SetState(2847)
				p.Unpacked_dimension()
			}

			p.SetState(2852)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(2861)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserCOMMA {
			{
				p.SetState(2853)
				p.Match(SystemVerilogParserCOMMA)
			}
			{
				p.SetState(2854)
				p.Net_identifier()
			}
			p.SetState(2858)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SystemVerilogParserLB {
				{
					p.SetState(2855)
					p.Unpacked_dimension()
				}

				p.SetState(2860)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(2863)
			p.Match(SystemVerilogParserSEMI)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IType_declarationContext is an interface to support dynamic dispatch.
type IType_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsType_declarationContext differentiates from other interfaces.
	IsType_declarationContext()
}

type Type_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_declarationContext() *Type_declarationContext {
	var p = new(Type_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_type_declaration
	return p
}

func (*Type_declarationContext) IsType_declarationContext() {}

func NewType_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_declarationContext {
	var p = new(Type_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_type_declaration

	return p
}

func (s *Type_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_declarationContext) KTYPEDEF() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKTYPEDEF, 0)
}

func (s *Type_declarationContext) Data_type() IData_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IData_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IData_typeContext)
}

func (s *Type_declarationContext) AllType_identifier() []IType_identifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IType_identifierContext)(nil)).Elem())
	var tst = make([]IType_identifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IType_identifierContext)
		}
	}

	return tst
}

func (s *Type_declarationContext) Type_identifier(i int) IType_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_identifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IType_identifierContext)
}

func (s *Type_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Type_declarationContext) AllVariable_dimension() []IVariable_dimensionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariable_dimensionContext)(nil)).Elem())
	var tst = make([]IVariable_dimensionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariable_dimensionContext)
		}
	}

	return tst
}

func (s *Type_declarationContext) Variable_dimension(i int) IVariable_dimensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_dimensionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariable_dimensionContext)
}

func (s *Type_declarationContext) Interface_instance_identifier() IInterface_instance_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_instance_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterface_instance_identifierContext)
}

func (s *Type_declarationContext) Constant_bit_select() IConstant_bit_selectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_bit_selectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_bit_selectContext)
}

func (s *Type_declarationContext) DOT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserDOT, 0)
}

func (s *Type_declarationContext) KENUM() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKENUM, 0)
}

func (s *Type_declarationContext) KSTRUCT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKSTRUCT, 0)
}

func (s *Type_declarationContext) KUNION() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKUNION, 0)
}

func (s *Type_declarationContext) KCLASS() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKCLASS, 0)
}

func (s *Type_declarationContext) KINTERFACE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKINTERFACE, 0)
}

func (s *Type_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterType_declaration(s)
	}
}

func (s *Type_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitType_declaration(s)
	}
}

func (p *SystemVerilogParser) Type_declaration() (localctx IType_declarationContext) {
	this := p
	_ = this

	localctx = NewType_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, SystemVerilogParserRULE_type_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2898)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 270, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2867)
			p.Match(SystemVerilogParserKTYPEDEF)
		}
		{
			p.SetState(2868)
			p.Data_type()
		}
		{
			p.SetState(2869)
			p.Type_identifier()
		}
		p.SetState(2873)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserLB {
			{
				p.SetState(2870)
				p.Variable_dimension()
			}

			p.SetState(2875)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2876)
			p.Match(SystemVerilogParserSEMI)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2878)
			p.Match(SystemVerilogParserKTYPEDEF)
		}
		{
			p.SetState(2879)
			p.Interface_instance_identifier()
		}
		{
			p.SetState(2880)
			p.Constant_bit_select()
		}
		{
			p.SetState(2881)
			p.Match(SystemVerilogParserDOT)
		}
		{
			p.SetState(2882)
			p.Type_identifier()
		}
		{
			p.SetState(2883)
			p.Type_identifier()
		}
		{
			p.SetState(2884)
			p.Match(SystemVerilogParserSEMI)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2886)
			p.Match(SystemVerilogParserKTYPEDEF)
		}
		p.SetState(2893)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SystemVerilogParserKENUM:
			{
				p.SetState(2887)
				p.Match(SystemVerilogParserKENUM)
			}

		case SystemVerilogParserKSTRUCT:
			{
				p.SetState(2888)
				p.Match(SystemVerilogParserKSTRUCT)
			}

		case SystemVerilogParserKUNION:
			{
				p.SetState(2889)
				p.Match(SystemVerilogParserKUNION)
			}

		case SystemVerilogParserKCLASS:
			{
				p.SetState(2890)
				p.Match(SystemVerilogParserKCLASS)
			}

		case SystemVerilogParserKINTERFACE:
			{
				p.SetState(2891)
				p.Match(SystemVerilogParserKINTERFACE)
			}
			{
				p.SetState(2892)
				p.Match(SystemVerilogParserKCLASS)
			}

		case SystemVerilogParserSIMPLE_IDENTIFIER:

		default:
		}
		{
			p.SetState(2895)
			p.Type_identifier()
		}
		{
			p.SetState(2896)
			p.Match(SystemVerilogParserSEMI)
		}

	}

	return localctx
}

// INet_type_declarationContext is an interface to support dynamic dispatch.
type INet_type_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNet_type_declarationContext differentiates from other interfaces.
	IsNet_type_declarationContext()
}

type Net_type_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNet_type_declarationContext() *Net_type_declarationContext {
	var p = new(Net_type_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_net_type_declaration
	return p
}

func (*Net_type_declarationContext) IsNet_type_declarationContext() {}

func NewNet_type_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Net_type_declarationContext {
	var p = new(Net_type_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_net_type_declaration

	return p
}

func (s *Net_type_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Net_type_declarationContext) KNETTYPE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKNETTYPE, 0)
}

func (s *Net_type_declarationContext) Data_type() IData_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IData_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IData_typeContext)
}

func (s *Net_type_declarationContext) AllNet_type_identifier() []INet_type_identifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INet_type_identifierContext)(nil)).Elem())
	var tst = make([]INet_type_identifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INet_type_identifierContext)
		}
	}

	return tst
}

func (s *Net_type_declarationContext) Net_type_identifier(i int) INet_type_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_type_identifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INet_type_identifierContext)
}

func (s *Net_type_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Net_type_declarationContext) KWITH() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKWITH, 0)
}

func (s *Net_type_declarationContext) Tf_identifier() ITf_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITf_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITf_identifierContext)
}

func (s *Net_type_declarationContext) Package_scope() IPackage_scopeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackage_scopeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPackage_scopeContext)
}

func (s *Net_type_declarationContext) Class_scope() IClass_scopeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_scopeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClass_scopeContext)
}

func (s *Net_type_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Net_type_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Net_type_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterNet_type_declaration(s)
	}
}

func (s *Net_type_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitNet_type_declaration(s)
	}
}

func (p *SystemVerilogParser) Net_type_declaration() (localctx INet_type_declarationContext) {
	this := p
	_ = this

	localctx = NewNet_type_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, SystemVerilogParserRULE_net_type_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2922)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 274, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2900)
			p.Match(SystemVerilogParserKNETTYPE)
		}
		{
			p.SetState(2901)
			p.Data_type()
		}
		{
			p.SetState(2902)
			p.Net_type_identifier()
		}
		p.SetState(2909)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserKWITH {
			{
				p.SetState(2903)
				p.Match(SystemVerilogParserKWITH)
			}
			p.SetState(2906)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 271, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(2904)
					p.Package_scope()
				}

			} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 271, p.GetParserRuleContext()) == 2 {
				{
					p.SetState(2905)
					p.Class_scope()
				}

			}
			{
				p.SetState(2908)
				p.Tf_identifier()
			}

		}
		{
			p.SetState(2911)
			p.Match(SystemVerilogParserSEMI)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2913)
			p.Match(SystemVerilogParserKNETTYPE)
		}
		p.SetState(2916)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 273, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2914)
				p.Package_scope()
			}

		} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 273, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(2915)
				p.Class_scope()
			}

		}
		{
			p.SetState(2918)
			p.Net_type_identifier()
		}
		{
			p.SetState(2919)
			p.Net_type_identifier()
		}
		{
			p.SetState(2920)
			p.Match(SystemVerilogParserSEMI)
		}

	}

	return localctx
}

// ILifetimeContext is an interface to support dynamic dispatch.
type ILifetimeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLifetimeContext differentiates from other interfaces.
	IsLifetimeContext()
}

type LifetimeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLifetimeContext() *LifetimeContext {
	var p = new(LifetimeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_lifetime
	return p
}

func (*LifetimeContext) IsLifetimeContext() {}

func NewLifetimeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LifetimeContext {
	var p = new(LifetimeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_lifetime

	return p
}

func (s *LifetimeContext) GetParser() antlr.Parser { return s.parser }

func (s *LifetimeContext) KSTATIC() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKSTATIC, 0)
}

func (s *LifetimeContext) KAUTOMATIC() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKAUTOMATIC, 0)
}

func (s *LifetimeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LifetimeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LifetimeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterLifetime(s)
	}
}

func (s *LifetimeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitLifetime(s)
	}
}

func (p *SystemVerilogParser) Lifetime() (localctx ILifetimeContext) {
	this := p
	_ = this

	localctx = NewLifetimeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, SystemVerilogParserRULE_lifetime)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2924)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SystemVerilogParserKAUTOMATIC || _la == SystemVerilogParserKSTATIC) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ICasting_typeContext is an interface to support dynamic dispatch.
type ICasting_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCasting_typeContext differentiates from other interfaces.
	IsCasting_typeContext()
}

type Casting_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCasting_typeContext() *Casting_typeContext {
	var p = new(Casting_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_casting_type
	return p
}

func (*Casting_typeContext) IsCasting_typeContext() {}

func NewCasting_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Casting_typeContext {
	var p = new(Casting_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_casting_type

	return p
}

func (s *Casting_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Casting_typeContext) Simple_type() ISimple_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimple_typeContext)
}

func (s *Casting_typeContext) Constant_primary() IConstant_primaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_primaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_primaryContext)
}

func (s *Casting_typeContext) Signing() ISigningContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISigningContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISigningContext)
}

func (s *Casting_typeContext) KSTRING() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKSTRING, 0)
}

func (s *Casting_typeContext) KCONST() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKCONST, 0)
}

func (s *Casting_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Casting_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Casting_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterCasting_type(s)
	}
}

func (s *Casting_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitCasting_type(s)
	}
}

func (p *SystemVerilogParser) Casting_type() (localctx ICasting_typeContext) {
	this := p
	_ = this

	localctx = NewCasting_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, SystemVerilogParserRULE_casting_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2931)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 275, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2926)
			p.Simple_type()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2927)
			p.Constant_primary()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2928)
			p.Signing()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2929)
			p.Match(SystemVerilogParserKSTRING)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2930)
			p.Match(SystemVerilogParserKCONST)
		}

	}

	return localctx
}

// IData_typeContext is an interface to support dynamic dispatch.
type IData_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsData_typeContext differentiates from other interfaces.
	IsData_typeContext()
}

type Data_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyData_typeContext() *Data_typeContext {
	var p = new(Data_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_data_type
	return p
}

func (*Data_typeContext) IsData_typeContext() {}

func NewData_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Data_typeContext {
	var p = new(Data_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_data_type

	return p
}

func (s *Data_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Data_typeContext) Integer_vector_type() IInteger_vector_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInteger_vector_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInteger_vector_typeContext)
}

func (s *Data_typeContext) Signing() ISigningContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISigningContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISigningContext)
}

func (s *Data_typeContext) AllPacked_dimension() []IPacked_dimensionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPacked_dimensionContext)(nil)).Elem())
	var tst = make([]IPacked_dimensionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPacked_dimensionContext)
		}
	}

	return tst
}

func (s *Data_typeContext) Packed_dimension(i int) IPacked_dimensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPacked_dimensionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPacked_dimensionContext)
}

func (s *Data_typeContext) Integer_atom_type() IInteger_atom_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInteger_atom_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInteger_atom_typeContext)
}

func (s *Data_typeContext) Non_integer_type() INon_integer_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INon_integer_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INon_integer_typeContext)
}

func (s *Data_typeContext) Struct_union() IStruct_unionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStruct_unionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStruct_unionContext)
}

func (s *Data_typeContext) LC() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLC, 0)
}

func (s *Data_typeContext) AllStruct_union_member() []IStruct_union_memberContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStruct_union_memberContext)(nil)).Elem())
	var tst = make([]IStruct_union_memberContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStruct_union_memberContext)
		}
	}

	return tst
}

func (s *Data_typeContext) Struct_union_member(i int) IStruct_union_memberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStruct_union_memberContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStruct_union_memberContext)
}

func (s *Data_typeContext) RC() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRC, 0)
}

func (s *Data_typeContext) KPACKED() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKPACKED, 0)
}

func (s *Data_typeContext) KENUM() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKENUM, 0)
}

func (s *Data_typeContext) AllEnum_name_declaration() []IEnum_name_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEnum_name_declarationContext)(nil)).Elem())
	var tst = make([]IEnum_name_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEnum_name_declarationContext)
		}
	}

	return tst
}

func (s *Data_typeContext) Enum_name_declaration(i int) IEnum_name_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnum_name_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEnum_name_declarationContext)
}

func (s *Data_typeContext) Enum_base_type() IEnum_base_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnum_base_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnum_base_typeContext)
}

func (s *Data_typeContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *Data_typeContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *Data_typeContext) KSTRING() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKSTRING, 0)
}

func (s *Data_typeContext) KCHANDLE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKCHANDLE, 0)
}

func (s *Data_typeContext) KVIRTUAL() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKVIRTUAL, 0)
}

func (s *Data_typeContext) Interface_identifier() IInterface_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterface_identifierContext)
}

func (s *Data_typeContext) KINTERFACE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKINTERFACE, 0)
}

func (s *Data_typeContext) Parameter_value_assignment() IParameter_value_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_value_assignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_value_assignmentContext)
}

func (s *Data_typeContext) DOT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserDOT, 0)
}

func (s *Data_typeContext) Modport_identifier() IModport_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModport_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModport_identifierContext)
}

func (s *Data_typeContext) Type_identifier() IType_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_identifierContext)
}

func (s *Data_typeContext) Class_scope() IClass_scopeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_scopeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClass_scopeContext)
}

func (s *Data_typeContext) Package_scope() IPackage_scopeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackage_scopeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPackage_scopeContext)
}

func (s *Data_typeContext) Class_type() IClass_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClass_typeContext)
}

func (s *Data_typeContext) KEVENT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKEVENT, 0)
}

func (s *Data_typeContext) Ps_covergroup_identifier() IPs_covergroup_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPs_covergroup_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPs_covergroup_identifierContext)
}

func (s *Data_typeContext) Type_reference() IType_referenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_referenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_referenceContext)
}

func (s *Data_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Data_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Data_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterData_type(s)
	}
}

func (s *Data_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitData_type(s)
	}
}

func (p *SystemVerilogParser) Data_type() (localctx IData_typeContext) {
	this := p
	_ = this

	localctx = NewData_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, SystemVerilogParserRULE_data_type)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3019)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 291, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2933)
			p.Integer_vector_type()
		}
		p.SetState(2935)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserKSIGNED || _la == SystemVerilogParserKUNSIGNED {
			{
				p.SetState(2934)
				p.Signing()
			}

		}
		p.SetState(2940)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserLB {
			{
				p.SetState(2937)
				p.Packed_dimension()
			}

			p.SetState(2942)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2943)
			p.Integer_atom_type()
		}
		p.SetState(2945)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserKSIGNED || _la == SystemVerilogParserKUNSIGNED {
			{
				p.SetState(2944)
				p.Signing()
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2947)
			p.Non_integer_type()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2948)
			p.Struct_union()
		}
		p.SetState(2953)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserKPACKED {
			{
				p.SetState(2949)
				p.Match(SystemVerilogParserKPACKED)
			}
			p.SetState(2951)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == SystemVerilogParserKSIGNED || _la == SystemVerilogParserKUNSIGNED {
				{
					p.SetState(2950)
					p.Signing()
				}

			}

		}
		{
			p.SetState(2955)
			p.Match(SystemVerilogParserLC)
		}
		{
			p.SetState(2956)
			p.Struct_union_member()
		}
		p.SetState(2960)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserDUNIT || _la == SystemVerilogParserLPS || (((_la-109)&-(0x1f+1)) == 0 && ((1<<uint((_la-109)))&((1<<(SystemVerilogParserKBIT-109))|(1<<(SystemVerilogParserKBYTE-109))|(1<<(SystemVerilogParserKCHANDLE-109)))) != 0) || _la == SystemVerilogParserKENUM || _la == SystemVerilogParserKEVENT || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SystemVerilogParserKINT-195))|(1<<(SystemVerilogParserKINTEGER-195))|(1<<(SystemVerilogParserKLOGIC-195))|(1<<(SystemVerilogParserKLONGINT-195)))) != 0) || (((_la-249)&-(0x1f+1)) == 0 && ((1<<uint((_la-249)))&((1<<(SystemVerilogParserKRAND-249))|(1<<(SystemVerilogParserKRANDC-249))|(1<<(SystemVerilogParserKREAL-249))|(1<<(SystemVerilogParserKREALTIME-249))|(1<<(SystemVerilogParserKREG-249))|(1<<(SystemVerilogParserKSHORTINT-249))|(1<<(SystemVerilogParserKSHORTREAL-249)))) != 0) || (((_la-287)&-(0x1f+1)) == 0 && ((1<<uint((_la-287)))&((1<<(SystemVerilogParserKSTRING-287))|(1<<(SystemVerilogParserKSTRUCT-287))|(1<<(SystemVerilogParserKTIME-287))|(1<<(SystemVerilogParserKTYPE-287))|(1<<(SystemVerilogParserKUNION-287)))) != 0) || (((_la-327)&-(0x1f+1)) == 0 && ((1<<uint((_la-327)))&((1<<(SystemVerilogParserKVIRTUAL-327))|(1<<(SystemVerilogParserKVOID-327))|(1<<(SystemVerilogParserSIMPLE_IDENTIFIER-327)))) != 0) {
			{
				p.SetState(2957)
				p.Struct_union_member()
			}

			p.SetState(2962)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2963)
			p.Match(SystemVerilogParserRC)
		}
		p.SetState(2967)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserLB {
			{
				p.SetState(2964)
				p.Packed_dimension()
			}

			p.SetState(2969)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2970)
			p.Match(SystemVerilogParserKENUM)
		}
		p.SetState(2972)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserKBIT || _la == SystemVerilogParserKBYTE || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SystemVerilogParserKINT-195))|(1<<(SystemVerilogParserKINTEGER-195))|(1<<(SystemVerilogParserKLOGIC-195))|(1<<(SystemVerilogParserKLONGINT-195)))) != 0) || _la == SystemVerilogParserKREG || _la == SystemVerilogParserKSHORTINT || _la == SystemVerilogParserKTIME || _la == SystemVerilogParserSIMPLE_IDENTIFIER {
			{
				p.SetState(2971)
				p.Enum_base_type()
			}

		}
		{
			p.SetState(2974)
			p.Match(SystemVerilogParserLC)
		}
		{
			p.SetState(2975)
			p.Enum_name_declaration()
		}
		p.SetState(2980)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserCOMMA {
			{
				p.SetState(2976)
				p.Match(SystemVerilogParserCOMMA)
			}
			{
				p.SetState(2977)
				p.Enum_name_declaration()
			}

			p.SetState(2982)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2983)
			p.Match(SystemVerilogParserRC)
		}
		p.SetState(2987)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserLB {
			{
				p.SetState(2984)
				p.Packed_dimension()
			}

			p.SetState(2989)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2990)
			p.Match(SystemVerilogParserKSTRING)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2991)
			p.Match(SystemVerilogParserKCHANDLE)
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(2992)
			p.Match(SystemVerilogParserKVIRTUAL)
		}
		p.SetState(2994)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserKINTERFACE {
			{
				p.SetState(2993)
				p.Match(SystemVerilogParserKINTERFACE)
			}

		}
		{
			p.SetState(2996)
			p.Interface_identifier()
		}
		p.SetState(2998)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 287, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2997)
				p.Parameter_value_assignment()
			}

		}
		p.SetState(3002)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserDOT {
			{
				p.SetState(3000)
				p.Match(SystemVerilogParserDOT)
			}
			{
				p.SetState(3001)
				p.Modport_identifier()
			}

		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		p.SetState(3006)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 289, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3004)
				p.Class_scope()
			}

		} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 289, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(3005)
				p.Package_scope()
			}

		}
		{
			p.SetState(3008)
			p.Type_identifier()
		}
		p.SetState(3012)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserLB {
			{
				p.SetState(3009)
				p.Packed_dimension()
			}

			p.SetState(3014)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(3015)
			p.Class_type()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(3016)
			p.Match(SystemVerilogParserKEVENT)
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(3017)
			p.Ps_covergroup_identifier()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(3018)
			p.Type_reference()
		}

	}

	return localctx
}

// IData_type_or_implicitContext is an interface to support dynamic dispatch.
type IData_type_or_implicitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsData_type_or_implicitContext differentiates from other interfaces.
	IsData_type_or_implicitContext()
}

type Data_type_or_implicitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyData_type_or_implicitContext() *Data_type_or_implicitContext {
	var p = new(Data_type_or_implicitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_data_type_or_implicit
	return p
}

func (*Data_type_or_implicitContext) IsData_type_or_implicitContext() {}

func NewData_type_or_implicitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Data_type_or_implicitContext {
	var p = new(Data_type_or_implicitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_data_type_or_implicit

	return p
}

func (s *Data_type_or_implicitContext) GetParser() antlr.Parser { return s.parser }

func (s *Data_type_or_implicitContext) Data_type() IData_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IData_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IData_typeContext)
}

func (s *Data_type_or_implicitContext) Implicit_data_type() IImplicit_data_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImplicit_data_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImplicit_data_typeContext)
}

func (s *Data_type_or_implicitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Data_type_or_implicitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Data_type_or_implicitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterData_type_or_implicit(s)
	}
}

func (s *Data_type_or_implicitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitData_type_or_implicit(s)
	}
}

func (p *SystemVerilogParser) Data_type_or_implicit() (localctx IData_type_or_implicitContext) {
	this := p
	_ = this

	localctx = NewData_type_or_implicitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, SystemVerilogParserRULE_data_type_or_implicit)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3023)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 292, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3021)
			p.Data_type()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3022)
			p.Implicit_data_type()
		}

	}

	return localctx
}

// IImplicit_data_typeContext is an interface to support dynamic dispatch.
type IImplicit_data_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImplicit_data_typeContext differentiates from other interfaces.
	IsImplicit_data_typeContext()
}

type Implicit_data_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImplicit_data_typeContext() *Implicit_data_typeContext {
	var p = new(Implicit_data_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_implicit_data_type
	return p
}

func (*Implicit_data_typeContext) IsImplicit_data_typeContext() {}

func NewImplicit_data_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Implicit_data_typeContext {
	var p = new(Implicit_data_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_implicit_data_type

	return p
}

func (s *Implicit_data_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Implicit_data_typeContext) Signing() ISigningContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISigningContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISigningContext)
}

func (s *Implicit_data_typeContext) AllPacked_dimension() []IPacked_dimensionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPacked_dimensionContext)(nil)).Elem())
	var tst = make([]IPacked_dimensionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPacked_dimensionContext)
		}
	}

	return tst
}

func (s *Implicit_data_typeContext) Packed_dimension(i int) IPacked_dimensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPacked_dimensionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPacked_dimensionContext)
}

func (s *Implicit_data_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Implicit_data_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Implicit_data_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterImplicit_data_type(s)
	}
}

func (s *Implicit_data_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitImplicit_data_type(s)
	}
}

func (p *SystemVerilogParser) Implicit_data_type() (localctx IImplicit_data_typeContext) {
	this := p
	_ = this

	localctx = NewImplicit_data_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, SystemVerilogParserRULE_implicit_data_type)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3026)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserKSIGNED || _la == SystemVerilogParserKUNSIGNED {
		{
			p.SetState(3025)
			p.Signing()
		}

	}
	p.SetState(3031)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserLB {
		{
			p.SetState(3028)
			p.Packed_dimension()
		}

		p.SetState(3033)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IEnum_base_typeContext is an interface to support dynamic dispatch.
type IEnum_base_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnum_base_typeContext differentiates from other interfaces.
	IsEnum_base_typeContext()
}

type Enum_base_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnum_base_typeContext() *Enum_base_typeContext {
	var p = new(Enum_base_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_enum_base_type
	return p
}

func (*Enum_base_typeContext) IsEnum_base_typeContext() {}

func NewEnum_base_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Enum_base_typeContext {
	var p = new(Enum_base_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_enum_base_type

	return p
}

func (s *Enum_base_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Enum_base_typeContext) Integer_atom_type() IInteger_atom_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInteger_atom_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInteger_atom_typeContext)
}

func (s *Enum_base_typeContext) Signing() ISigningContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISigningContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISigningContext)
}

func (s *Enum_base_typeContext) Integer_vector_type() IInteger_vector_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInteger_vector_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInteger_vector_typeContext)
}

func (s *Enum_base_typeContext) Packed_dimension() IPacked_dimensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPacked_dimensionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPacked_dimensionContext)
}

func (s *Enum_base_typeContext) Type_identifier() IType_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_identifierContext)
}

func (s *Enum_base_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Enum_base_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Enum_base_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterEnum_base_type(s)
	}
}

func (s *Enum_base_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitEnum_base_type(s)
	}
}

func (p *SystemVerilogParser) Enum_base_type() (localctx IEnum_base_typeContext) {
	this := p
	_ = this

	localctx = NewEnum_base_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, SystemVerilogParserRULE_enum_base_type)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3049)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserKBYTE, SystemVerilogParserKINT, SystemVerilogParserKINTEGER, SystemVerilogParserKLONGINT, SystemVerilogParserKSHORTINT, SystemVerilogParserKTIME:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3034)
			p.Integer_atom_type()
		}
		p.SetState(3036)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserKSIGNED || _la == SystemVerilogParserKUNSIGNED {
			{
				p.SetState(3035)
				p.Signing()
			}

		}

	case SystemVerilogParserKBIT, SystemVerilogParserKLOGIC, SystemVerilogParserKREG:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3038)
			p.Integer_vector_type()
		}
		p.SetState(3040)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserKSIGNED || _la == SystemVerilogParserKUNSIGNED {
			{
				p.SetState(3039)
				p.Signing()
			}

		}
		p.SetState(3043)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserLB {
			{
				p.SetState(3042)
				p.Packed_dimension()
			}

		}

	case SystemVerilogParserSIMPLE_IDENTIFIER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3045)
			p.Type_identifier()
		}
		p.SetState(3047)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserLB {
			{
				p.SetState(3046)
				p.Packed_dimension()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IEnum_name_declarationContext is an interface to support dynamic dispatch.
type IEnum_name_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnum_name_declarationContext differentiates from other interfaces.
	IsEnum_name_declarationContext()
}

type Enum_name_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnum_name_declarationContext() *Enum_name_declarationContext {
	var p = new(Enum_name_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_enum_name_declaration
	return p
}

func (*Enum_name_declarationContext) IsEnum_name_declarationContext() {}

func NewEnum_name_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Enum_name_declarationContext {
	var p = new(Enum_name_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_enum_name_declaration

	return p
}

func (s *Enum_name_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Enum_name_declarationContext) Enum_identifier() IEnum_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnum_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnum_identifierContext)
}

func (s *Enum_name_declarationContext) LB() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLB, 0)
}

func (s *Enum_name_declarationContext) RB() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRB, 0)
}

func (s *Enum_name_declarationContext) EQ() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserEQ, 0)
}

func (s *Enum_name_declarationContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Enum_name_declarationContext) AllDECIMAL_NUMBER() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserDECIMAL_NUMBER)
}

func (s *Enum_name_declarationContext) DECIMAL_NUMBER(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserDECIMAL_NUMBER, i)
}

func (s *Enum_name_declarationContext) AllUNSIGNED_NUMBER() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserUNSIGNED_NUMBER)
}

func (s *Enum_name_declarationContext) UNSIGNED_NUMBER(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserUNSIGNED_NUMBER, i)
}

func (s *Enum_name_declarationContext) AllOCTAL_NUMBER() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserOCTAL_NUMBER)
}

func (s *Enum_name_declarationContext) OCTAL_NUMBER(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserOCTAL_NUMBER, i)
}

func (s *Enum_name_declarationContext) AllBINARY_NUMBER() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserBINARY_NUMBER)
}

func (s *Enum_name_declarationContext) BINARY_NUMBER(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserBINARY_NUMBER, i)
}

func (s *Enum_name_declarationContext) AllHEX_NUMBER() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserHEX_NUMBER)
}

func (s *Enum_name_declarationContext) HEX_NUMBER(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserHEX_NUMBER, i)
}

func (s *Enum_name_declarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOLON, 0)
}

func (s *Enum_name_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Enum_name_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Enum_name_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterEnum_name_declaration(s)
	}
}

func (s *Enum_name_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitEnum_name_declaration(s)
	}
}

func (p *SystemVerilogParser) Enum_name_declaration() (localctx IEnum_name_declarationContext) {
	this := p
	_ = this

	localctx = NewEnum_name_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, SystemVerilogParserRULE_enum_name_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3051)
		p.Enum_identifier()
	}
	p.SetState(3059)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserLB {
		{
			p.SetState(3052)
			p.Match(SystemVerilogParserLB)
		}
		{
			p.SetState(3053)
			_la = p.GetTokenStream().LA(1)

			if !(((_la-346)&-(0x1f+1)) == 0 && ((1<<uint((_la-346)))&((1<<(SystemVerilogParserDECIMAL_NUMBER-346))|(1<<(SystemVerilogParserBINARY_NUMBER-346))|(1<<(SystemVerilogParserOCTAL_NUMBER-346))|(1<<(SystemVerilogParserHEX_NUMBER-346))|(1<<(SystemVerilogParserUNSIGNED_NUMBER-346)))) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(3056)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserCOLON {
			{
				p.SetState(3054)
				p.Match(SystemVerilogParserCOLON)
			}
			{
				p.SetState(3055)
				_la = p.GetTokenStream().LA(1)

				if !(((_la-346)&-(0x1f+1)) == 0 && ((1<<uint((_la-346)))&((1<<(SystemVerilogParserDECIMAL_NUMBER-346))|(1<<(SystemVerilogParserBINARY_NUMBER-346))|(1<<(SystemVerilogParserOCTAL_NUMBER-346))|(1<<(SystemVerilogParserHEX_NUMBER-346))|(1<<(SystemVerilogParserUNSIGNED_NUMBER-346)))) != 0) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(3058)
			p.Match(SystemVerilogParserRB)
		}

	}
	p.SetState(3063)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserEQ {
		{
			p.SetState(3061)
			p.Match(SystemVerilogParserEQ)
		}
		{
			p.SetState(3062)
			p.constant_expression(0)
		}

	}

	return localctx
}

// IClass_scopeContext is an interface to support dynamic dispatch.
type IClass_scopeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClass_scopeContext differentiates from other interfaces.
	IsClass_scopeContext()
}

type Class_scopeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClass_scopeContext() *Class_scopeContext {
	var p = new(Class_scopeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_class_scope
	return p
}

func (*Class_scopeContext) IsClass_scopeContext() {}

func NewClass_scopeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Class_scopeContext {
	var p = new(Class_scopeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_class_scope

	return p
}

func (s *Class_scopeContext) GetParser() antlr.Parser { return s.parser }

func (s *Class_scopeContext) Class_type() IClass_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClass_typeContext)
}

func (s *Class_scopeContext) COLONCOLON() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOLONCOLON, 0)
}

func (s *Class_scopeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Class_scopeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Class_scopeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterClass_scope(s)
	}
}

func (s *Class_scopeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitClass_scope(s)
	}
}

func (p *SystemVerilogParser) Class_scope() (localctx IClass_scopeContext) {
	this := p
	_ = this

	localctx = NewClass_scopeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, SystemVerilogParserRULE_class_scope)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3065)
		p.Class_type()
	}
	{
		p.SetState(3066)
		p.Match(SystemVerilogParserCOLONCOLON)
	}

	return localctx
}

// IClass_typeContext is an interface to support dynamic dispatch.
type IClass_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClass_typeContext differentiates from other interfaces.
	IsClass_typeContext()
}

type Class_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClass_typeContext() *Class_typeContext {
	var p = new(Class_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_class_type
	return p
}

func (*Class_typeContext) IsClass_typeContext() {}

func NewClass_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Class_typeContext {
	var p = new(Class_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_class_type

	return p
}

func (s *Class_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Class_typeContext) Ps_class_identifier() IPs_class_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPs_class_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPs_class_identifierContext)
}

func (s *Class_typeContext) AllParameter_value_assignment() []IParameter_value_assignmentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IParameter_value_assignmentContext)(nil)).Elem())
	var tst = make([]IParameter_value_assignmentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IParameter_value_assignmentContext)
		}
	}

	return tst
}

func (s *Class_typeContext) Parameter_value_assignment(i int) IParameter_value_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_value_assignmentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IParameter_value_assignmentContext)
}

func (s *Class_typeContext) AllCOLONCOLON() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOLONCOLON)
}

func (s *Class_typeContext) COLONCOLON(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOLONCOLON, i)
}

func (s *Class_typeContext) AllClass_identifier() []IClass_identifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IClass_identifierContext)(nil)).Elem())
	var tst = make([]IClass_identifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IClass_identifierContext)
		}
	}

	return tst
}

func (s *Class_typeContext) Class_identifier(i int) IClass_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_identifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IClass_identifierContext)
}

func (s *Class_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Class_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Class_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterClass_type(s)
	}
}

func (s *Class_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitClass_type(s)
	}
}

func (p *SystemVerilogParser) Class_type() (localctx IClass_typeContext) {
	this := p
	_ = this

	localctx = NewClass_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, SystemVerilogParserRULE_class_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3068)
		p.Ps_class_identifier()
	}
	p.SetState(3070)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 303, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3069)
			p.Parameter_value_assignment()
		}

	}
	p.SetState(3079)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 305, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3072)
				p.Match(SystemVerilogParserCOLONCOLON)
			}
			{
				p.SetState(3073)
				p.Class_identifier()
			}
			p.SetState(3075)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 304, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(3074)
					p.Parameter_value_assignment()
				}

			}

		}
		p.SetState(3081)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 305, p.GetParserRuleContext())
	}

	return localctx
}

// IInteger_typeContext is an interface to support dynamic dispatch.
type IInteger_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInteger_typeContext differentiates from other interfaces.
	IsInteger_typeContext()
}

type Integer_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInteger_typeContext() *Integer_typeContext {
	var p = new(Integer_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_integer_type
	return p
}

func (*Integer_typeContext) IsInteger_typeContext() {}

func NewInteger_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Integer_typeContext {
	var p = new(Integer_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_integer_type

	return p
}

func (s *Integer_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Integer_typeContext) Integer_vector_type() IInteger_vector_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInteger_vector_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInteger_vector_typeContext)
}

func (s *Integer_typeContext) Integer_atom_type() IInteger_atom_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInteger_atom_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInteger_atom_typeContext)
}

func (s *Integer_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Integer_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Integer_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterInteger_type(s)
	}
}

func (s *Integer_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitInteger_type(s)
	}
}

func (p *SystemVerilogParser) Integer_type() (localctx IInteger_typeContext) {
	this := p
	_ = this

	localctx = NewInteger_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, SystemVerilogParserRULE_integer_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3084)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserKBIT, SystemVerilogParserKLOGIC, SystemVerilogParserKREG:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3082)
			p.Integer_vector_type()
		}

	case SystemVerilogParserKBYTE, SystemVerilogParserKINT, SystemVerilogParserKINTEGER, SystemVerilogParserKLONGINT, SystemVerilogParserKSHORTINT, SystemVerilogParserKTIME:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3083)
			p.Integer_atom_type()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IInteger_atom_typeContext is an interface to support dynamic dispatch.
type IInteger_atom_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInteger_atom_typeContext differentiates from other interfaces.
	IsInteger_atom_typeContext()
}

type Integer_atom_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInteger_atom_typeContext() *Integer_atom_typeContext {
	var p = new(Integer_atom_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_integer_atom_type
	return p
}

func (*Integer_atom_typeContext) IsInteger_atom_typeContext() {}

func NewInteger_atom_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Integer_atom_typeContext {
	var p = new(Integer_atom_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_integer_atom_type

	return p
}

func (s *Integer_atom_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Integer_atom_typeContext) KBYTE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKBYTE, 0)
}

func (s *Integer_atom_typeContext) KSHORTINT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKSHORTINT, 0)
}

func (s *Integer_atom_typeContext) KINT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKINT, 0)
}

func (s *Integer_atom_typeContext) KLONGINT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKLONGINT, 0)
}

func (s *Integer_atom_typeContext) KINTEGER() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKINTEGER, 0)
}

func (s *Integer_atom_typeContext) KTIME() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKTIME, 0)
}

func (s *Integer_atom_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Integer_atom_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Integer_atom_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterInteger_atom_type(s)
	}
}

func (s *Integer_atom_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitInteger_atom_type(s)
	}
}

func (p *SystemVerilogParser) Integer_atom_type() (localctx IInteger_atom_typeContext) {
	this := p
	_ = this

	localctx = NewInteger_atom_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, SystemVerilogParserRULE_integer_atom_type)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3086)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SystemVerilogParserKBYTE || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SystemVerilogParserKINT-195))|(1<<(SystemVerilogParserKINTEGER-195))|(1<<(SystemVerilogParserKLONGINT-195)))) != 0) || _la == SystemVerilogParserKSHORTINT || _la == SystemVerilogParserKTIME) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IInteger_vector_typeContext is an interface to support dynamic dispatch.
type IInteger_vector_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInteger_vector_typeContext differentiates from other interfaces.
	IsInteger_vector_typeContext()
}

type Integer_vector_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInteger_vector_typeContext() *Integer_vector_typeContext {
	var p = new(Integer_vector_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_integer_vector_type
	return p
}

func (*Integer_vector_typeContext) IsInteger_vector_typeContext() {}

func NewInteger_vector_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Integer_vector_typeContext {
	var p = new(Integer_vector_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_integer_vector_type

	return p
}

func (s *Integer_vector_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Integer_vector_typeContext) KBIT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKBIT, 0)
}

func (s *Integer_vector_typeContext) KLOGIC() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKLOGIC, 0)
}

func (s *Integer_vector_typeContext) KREG() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKREG, 0)
}

func (s *Integer_vector_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Integer_vector_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Integer_vector_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterInteger_vector_type(s)
	}
}

func (s *Integer_vector_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitInteger_vector_type(s)
	}
}

func (p *SystemVerilogParser) Integer_vector_type() (localctx IInteger_vector_typeContext) {
	this := p
	_ = this

	localctx = NewInteger_vector_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, SystemVerilogParserRULE_integer_vector_type)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3088)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SystemVerilogParserKBIT || _la == SystemVerilogParserKLOGIC || _la == SystemVerilogParserKREG) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// INon_integer_typeContext is an interface to support dynamic dispatch.
type INon_integer_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNon_integer_typeContext differentiates from other interfaces.
	IsNon_integer_typeContext()
}

type Non_integer_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNon_integer_typeContext() *Non_integer_typeContext {
	var p = new(Non_integer_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_non_integer_type
	return p
}

func (*Non_integer_typeContext) IsNon_integer_typeContext() {}

func NewNon_integer_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Non_integer_typeContext {
	var p = new(Non_integer_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_non_integer_type

	return p
}

func (s *Non_integer_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Non_integer_typeContext) KSHORTREAL() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKSHORTREAL, 0)
}

func (s *Non_integer_typeContext) KREAL() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKREAL, 0)
}

func (s *Non_integer_typeContext) KREALTIME() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKREALTIME, 0)
}

func (s *Non_integer_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Non_integer_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Non_integer_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterNon_integer_type(s)
	}
}

func (s *Non_integer_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitNon_integer_type(s)
	}
}

func (p *SystemVerilogParser) Non_integer_type() (localctx INon_integer_typeContext) {
	this := p
	_ = this

	localctx = NewNon_integer_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, SystemVerilogParserRULE_non_integer_type)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3090)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-255)&-(0x1f+1)) == 0 && ((1<<uint((_la-255)))&((1<<(SystemVerilogParserKREAL-255))|(1<<(SystemVerilogParserKREALTIME-255))|(1<<(SystemVerilogParserKSHORTREAL-255)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// INet_typeContext is an interface to support dynamic dispatch.
type INet_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNet_typeContext differentiates from other interfaces.
	IsNet_typeContext()
}

type Net_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNet_typeContext() *Net_typeContext {
	var p = new(Net_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_net_type
	return p
}

func (*Net_typeContext) IsNet_typeContext() {}

func NewNet_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Net_typeContext {
	var p = new(Net_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_net_type

	return p
}

func (s *Net_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Net_typeContext) KSUPPLY0() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKSUPPLY0, 0)
}

func (s *Net_typeContext) KSUPPLY1() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKSUPPLY1, 0)
}

func (s *Net_typeContext) KTRI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKTRI, 0)
}

func (s *Net_typeContext) KTRIAND() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKTRIAND, 0)
}

func (s *Net_typeContext) KTRIOR() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKTRIOR, 0)
}

func (s *Net_typeContext) KTRIREG() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKTRIREG, 0)
}

func (s *Net_typeContext) KTRI0() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKTRI0, 0)
}

func (s *Net_typeContext) KTRI1() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKTRI1, 0)
}

func (s *Net_typeContext) KUWIRE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKUWIRE, 0)
}

func (s *Net_typeContext) KWIRE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKWIRE, 0)
}

func (s *Net_typeContext) KWAND() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKWAND, 0)
}

func (s *Net_typeContext) KWOR() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKWOR, 0)
}

func (s *Net_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Net_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Net_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterNet_type(s)
	}
}

func (s *Net_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitNet_type(s)
	}
}

func (p *SystemVerilogParser) Net_type() (localctx INet_typeContext) {
	this := p
	_ = this

	localctx = NewNet_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, SystemVerilogParserRULE_net_type)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3092)
		_la = p.GetTokenStream().LA(1)

		if !((((_la-293)&-(0x1f+1)) == 0 && ((1<<uint((_la-293)))&((1<<(SystemVerilogParserKSUPPLY0-293))|(1<<(SystemVerilogParserKSUPPLY1-293))|(1<<(SystemVerilogParserKTRI-293))|(1<<(SystemVerilogParserKTRI0-293))|(1<<(SystemVerilogParserKTRI1-293))|(1<<(SystemVerilogParserKTRIAND-293))|(1<<(SystemVerilogParserKTRIOR-293))|(1<<(SystemVerilogParserKTRIREG-293))|(1<<(SystemVerilogParserKUWIRE-293)))) != 0) || (((_la-331)&-(0x1f+1)) == 0 && ((1<<uint((_la-331)))&((1<<(SystemVerilogParserKWAND-331))|(1<<(SystemVerilogParserKWIRE-331))|(1<<(SystemVerilogParserKWOR-331)))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// INet_port_typeContext is an interface to support dynamic dispatch.
type INet_port_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNet_port_typeContext differentiates from other interfaces.
	IsNet_port_typeContext()
}

type Net_port_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNet_port_typeContext() *Net_port_typeContext {
	var p = new(Net_port_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_net_port_type
	return p
}

func (*Net_port_typeContext) IsNet_port_typeContext() {}

func NewNet_port_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Net_port_typeContext {
	var p = new(Net_port_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_net_port_type

	return p
}

func (s *Net_port_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Net_port_typeContext) Data_type_or_implicit() IData_type_or_implicitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IData_type_or_implicitContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IData_type_or_implicitContext)
}

func (s *Net_port_typeContext) Net_type() INet_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INet_typeContext)
}

func (s *Net_port_typeContext) Net_type_identifier() INet_type_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_type_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INet_type_identifierContext)
}

func (s *Net_port_typeContext) KINTERCONNECT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKINTERCONNECT, 0)
}

func (s *Net_port_typeContext) Implicit_data_type() IImplicit_data_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImplicit_data_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImplicit_data_typeContext)
}

func (s *Net_port_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Net_port_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Net_port_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterNet_port_type(s)
	}
}

func (s *Net_port_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitNet_port_type(s)
	}
}

func (p *SystemVerilogParser) Net_port_type() (localctx INet_port_typeContext) {
	this := p
	_ = this

	localctx = NewNet_port_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, SystemVerilogParserRULE_net_port_type)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3101)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 308, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(3095)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la-293)&-(0x1f+1)) == 0 && ((1<<uint((_la-293)))&((1<<(SystemVerilogParserKSUPPLY0-293))|(1<<(SystemVerilogParserKSUPPLY1-293))|(1<<(SystemVerilogParserKTRI-293))|(1<<(SystemVerilogParserKTRI0-293))|(1<<(SystemVerilogParserKTRI1-293))|(1<<(SystemVerilogParserKTRIAND-293))|(1<<(SystemVerilogParserKTRIOR-293))|(1<<(SystemVerilogParserKTRIREG-293))|(1<<(SystemVerilogParserKUWIRE-293)))) != 0) || (((_la-331)&-(0x1f+1)) == 0 && ((1<<uint((_la-331)))&((1<<(SystemVerilogParserKWAND-331))|(1<<(SystemVerilogParserKWIRE-331))|(1<<(SystemVerilogParserKWOR-331)))) != 0) {
			{
				p.SetState(3094)
				p.Net_type()
			}

		}
		{
			p.SetState(3097)
			p.Data_type_or_implicit()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3098)
			p.Net_type_identifier()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3099)
			p.Match(SystemVerilogParserKINTERCONNECT)
		}
		{
			p.SetState(3100)
			p.Implicit_data_type()
		}

	}

	return localctx
}

// IVariable_port_typeContext is an interface to support dynamic dispatch.
type IVariable_port_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariable_port_typeContext differentiates from other interfaces.
	IsVariable_port_typeContext()
}

type Variable_port_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariable_port_typeContext() *Variable_port_typeContext {
	var p = new(Variable_port_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_variable_port_type
	return p
}

func (*Variable_port_typeContext) IsVariable_port_typeContext() {}

func NewVariable_port_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Variable_port_typeContext {
	var p = new(Variable_port_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_variable_port_type

	return p
}

func (s *Variable_port_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Variable_port_typeContext) Var_data_type() IVar_data_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVar_data_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVar_data_typeContext)
}

func (s *Variable_port_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Variable_port_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Variable_port_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterVariable_port_type(s)
	}
}

func (s *Variable_port_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitVariable_port_type(s)
	}
}

func (p *SystemVerilogParser) Variable_port_type() (localctx IVariable_port_typeContext) {
	this := p
	_ = this

	localctx = NewVariable_port_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, SystemVerilogParserRULE_variable_port_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3103)
		p.Var_data_type()
	}

	return localctx
}

// IVar_data_typeContext is an interface to support dynamic dispatch.
type IVar_data_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVar_data_typeContext differentiates from other interfaces.
	IsVar_data_typeContext()
}

type Var_data_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVar_data_typeContext() *Var_data_typeContext {
	var p = new(Var_data_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_var_data_type
	return p
}

func (*Var_data_typeContext) IsVar_data_typeContext() {}

func NewVar_data_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Var_data_typeContext {
	var p = new(Var_data_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_var_data_type

	return p
}

func (s *Var_data_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Var_data_typeContext) Data_type() IData_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IData_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IData_typeContext)
}

func (s *Var_data_typeContext) KVAR() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKVAR, 0)
}

func (s *Var_data_typeContext) Data_type_or_implicit() IData_type_or_implicitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IData_type_or_implicitContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IData_type_or_implicitContext)
}

func (s *Var_data_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Var_data_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Var_data_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterVar_data_type(s)
	}
}

func (s *Var_data_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitVar_data_type(s)
	}
}

func (p *SystemVerilogParser) Var_data_type() (localctx IVar_data_typeContext) {
	this := p
	_ = this

	localctx = NewVar_data_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, SystemVerilogParserRULE_var_data_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3108)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserDUNIT, SystemVerilogParserKBIT, SystemVerilogParserKBYTE, SystemVerilogParserKCHANDLE, SystemVerilogParserKENUM, SystemVerilogParserKEVENT, SystemVerilogParserKINT, SystemVerilogParserKINTEGER, SystemVerilogParserKLOGIC, SystemVerilogParserKLONGINT, SystemVerilogParserKREAL, SystemVerilogParserKREALTIME, SystemVerilogParserKREG, SystemVerilogParserKSHORTINT, SystemVerilogParserKSHORTREAL, SystemVerilogParserKSTRING, SystemVerilogParserKSTRUCT, SystemVerilogParserKTIME, SystemVerilogParserKTYPE, SystemVerilogParserKUNION, SystemVerilogParserKVIRTUAL, SystemVerilogParserSIMPLE_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3105)
			p.Data_type()
		}

	case SystemVerilogParserKVAR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3106)
			p.Match(SystemVerilogParserKVAR)
		}
		{
			p.SetState(3107)
			p.Data_type_or_implicit()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISigningContext is an interface to support dynamic dispatch.
type ISigningContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSigningContext differentiates from other interfaces.
	IsSigningContext()
}

type SigningContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySigningContext() *SigningContext {
	var p = new(SigningContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_signing
	return p
}

func (*SigningContext) IsSigningContext() {}

func NewSigningContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SigningContext {
	var p = new(SigningContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_signing

	return p
}

func (s *SigningContext) GetParser() antlr.Parser { return s.parser }

func (s *SigningContext) KSIGNED() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKSIGNED, 0)
}

func (s *SigningContext) KUNSIGNED() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKUNSIGNED, 0)
}

func (s *SigningContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SigningContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SigningContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterSigning(s)
	}
}

func (s *SigningContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitSigning(s)
	}
}

func (p *SystemVerilogParser) Signing() (localctx ISigningContext) {
	this := p
	_ = this

	localctx = NewSigningContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, SystemVerilogParserRULE_signing)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3110)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SystemVerilogParserKSIGNED || _la == SystemVerilogParserKUNSIGNED) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ISimple_typeContext is an interface to support dynamic dispatch.
type ISimple_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimple_typeContext differentiates from other interfaces.
	IsSimple_typeContext()
}

type Simple_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimple_typeContext() *Simple_typeContext {
	var p = new(Simple_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_simple_type
	return p
}

func (*Simple_typeContext) IsSimple_typeContext() {}

func NewSimple_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Simple_typeContext {
	var p = new(Simple_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_simple_type

	return p
}

func (s *Simple_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Simple_typeContext) Integer_type() IInteger_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInteger_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInteger_typeContext)
}

func (s *Simple_typeContext) Non_integer_type() INon_integer_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INon_integer_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INon_integer_typeContext)
}

func (s *Simple_typeContext) Ps_type_identifier() IPs_type_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPs_type_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPs_type_identifierContext)
}

func (s *Simple_typeContext) Ps_parameter_identifier() IPs_parameter_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPs_parameter_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPs_parameter_identifierContext)
}

func (s *Simple_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Simple_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Simple_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterSimple_type(s)
	}
}

func (s *Simple_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitSimple_type(s)
	}
}

func (p *SystemVerilogParser) Simple_type() (localctx ISimple_typeContext) {
	this := p
	_ = this

	localctx = NewSimple_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, SystemVerilogParserRULE_simple_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3116)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 310, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3112)
			p.Integer_type()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3113)
			p.Non_integer_type()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3114)
			p.Ps_type_identifier()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3115)
			p.Ps_parameter_identifier()
		}

	}

	return localctx
}

// IStruct_union_memberContext is an interface to support dynamic dispatch.
type IStruct_union_memberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStruct_union_memberContext differentiates from other interfaces.
	IsStruct_union_memberContext()
}

type Struct_union_memberContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStruct_union_memberContext() *Struct_union_memberContext {
	var p = new(Struct_union_memberContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_struct_union_member
	return p
}

func (*Struct_union_memberContext) IsStruct_union_memberContext() {}

func NewStruct_union_memberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Struct_union_memberContext {
	var p = new(Struct_union_memberContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_struct_union_member

	return p
}

func (s *Struct_union_memberContext) GetParser() antlr.Parser { return s.parser }

func (s *Struct_union_memberContext) Data_type_or_void() IData_type_or_voidContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IData_type_or_voidContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IData_type_or_voidContext)
}

func (s *Struct_union_memberContext) List_of_variable_decl_assignments() IList_of_variable_decl_assignmentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_variable_decl_assignmentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_variable_decl_assignmentsContext)
}

func (s *Struct_union_memberContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Struct_union_memberContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Struct_union_memberContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Struct_union_memberContext) Random_qualifier() IRandom_qualifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRandom_qualifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRandom_qualifierContext)
}

func (s *Struct_union_memberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Struct_union_memberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Struct_union_memberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterStruct_union_member(s)
	}
}

func (s *Struct_union_memberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitStruct_union_member(s)
	}
}

func (p *SystemVerilogParser) Struct_union_member() (localctx IStruct_union_memberContext) {
	this := p
	_ = this

	localctx = NewStruct_union_memberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, SystemVerilogParserRULE_struct_union_member)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3121)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserLPS {
		{
			p.SetState(3118)
			p.Attribute_instance()
		}

		p.SetState(3123)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(3125)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserKRAND || _la == SystemVerilogParserKRANDC {
		{
			p.SetState(3124)
			p.Random_qualifier()
		}

	}
	{
		p.SetState(3127)
		p.Data_type_or_void()
	}
	{
		p.SetState(3128)
		p.List_of_variable_decl_assignments()
	}
	{
		p.SetState(3129)
		p.Match(SystemVerilogParserSEMI)
	}

	return localctx
}

// IData_type_or_voidContext is an interface to support dynamic dispatch.
type IData_type_or_voidContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsData_type_or_voidContext differentiates from other interfaces.
	IsData_type_or_voidContext()
}

type Data_type_or_voidContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyData_type_or_voidContext() *Data_type_or_voidContext {
	var p = new(Data_type_or_voidContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_data_type_or_void
	return p
}

func (*Data_type_or_voidContext) IsData_type_or_voidContext() {}

func NewData_type_or_voidContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Data_type_or_voidContext {
	var p = new(Data_type_or_voidContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_data_type_or_void

	return p
}

func (s *Data_type_or_voidContext) GetParser() antlr.Parser { return s.parser }

func (s *Data_type_or_voidContext) Data_type() IData_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IData_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IData_typeContext)
}

func (s *Data_type_or_voidContext) KVOID() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKVOID, 0)
}

func (s *Data_type_or_voidContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Data_type_or_voidContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Data_type_or_voidContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterData_type_or_void(s)
	}
}

func (s *Data_type_or_voidContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitData_type_or_void(s)
	}
}

func (p *SystemVerilogParser) Data_type_or_void() (localctx IData_type_or_voidContext) {
	this := p
	_ = this

	localctx = NewData_type_or_voidContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, SystemVerilogParserRULE_data_type_or_void)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3133)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserDUNIT, SystemVerilogParserKBIT, SystemVerilogParserKBYTE, SystemVerilogParserKCHANDLE, SystemVerilogParserKENUM, SystemVerilogParserKEVENT, SystemVerilogParserKINT, SystemVerilogParserKINTEGER, SystemVerilogParserKLOGIC, SystemVerilogParserKLONGINT, SystemVerilogParserKREAL, SystemVerilogParserKREALTIME, SystemVerilogParserKREG, SystemVerilogParserKSHORTINT, SystemVerilogParserKSHORTREAL, SystemVerilogParserKSTRING, SystemVerilogParserKSTRUCT, SystemVerilogParserKTIME, SystemVerilogParserKTYPE, SystemVerilogParserKUNION, SystemVerilogParserKVIRTUAL, SystemVerilogParserSIMPLE_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3131)
			p.Data_type()
		}

	case SystemVerilogParserKVOID:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3132)
			p.Match(SystemVerilogParserKVOID)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IStruct_unionContext is an interface to support dynamic dispatch.
type IStruct_unionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStruct_unionContext differentiates from other interfaces.
	IsStruct_unionContext()
}

type Struct_unionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStruct_unionContext() *Struct_unionContext {
	var p = new(Struct_unionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_struct_union
	return p
}

func (*Struct_unionContext) IsStruct_unionContext() {}

func NewStruct_unionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Struct_unionContext {
	var p = new(Struct_unionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_struct_union

	return p
}

func (s *Struct_unionContext) GetParser() antlr.Parser { return s.parser }

func (s *Struct_unionContext) KSTRUCT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKSTRUCT, 0)
}

func (s *Struct_unionContext) KUNION() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKUNION, 0)
}

func (s *Struct_unionContext) KTAGGED() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKTAGGED, 0)
}

func (s *Struct_unionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Struct_unionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Struct_unionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterStruct_union(s)
	}
}

func (s *Struct_unionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitStruct_union(s)
	}
}

func (p *SystemVerilogParser) Struct_union() (localctx IStruct_unionContext) {
	this := p
	_ = this

	localctx = NewStruct_unionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, SystemVerilogParserRULE_struct_union)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3140)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserKSTRUCT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3135)
			p.Match(SystemVerilogParserKSTRUCT)
		}

	case SystemVerilogParserKUNION:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3136)
			p.Match(SystemVerilogParserKUNION)
		}
		p.SetState(3138)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserKTAGGED {
			{
				p.SetState(3137)
				p.Match(SystemVerilogParserKTAGGED)
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IType_referenceContext is an interface to support dynamic dispatch.
type IType_referenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsType_referenceContext differentiates from other interfaces.
	IsType_referenceContext()
}

type Type_referenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_referenceContext() *Type_referenceContext {
	var p = new(Type_referenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_type_reference
	return p
}

func (*Type_referenceContext) IsType_referenceContext() {}

func NewType_referenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_referenceContext {
	var p = new(Type_referenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_type_reference

	return p
}

func (s *Type_referenceContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_referenceContext) KTYPE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKTYPE, 0)
}

func (s *Type_referenceContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Type_referenceContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Type_referenceContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Type_referenceContext) Data_type() IData_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IData_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IData_typeContext)
}

func (s *Type_referenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_referenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_referenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterType_reference(s)
	}
}

func (s *Type_referenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitType_reference(s)
	}
}

func (p *SystemVerilogParser) Type_reference() (localctx IType_referenceContext) {
	this := p
	_ = this

	localctx = NewType_referenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, SystemVerilogParserRULE_type_reference)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3142)
		p.Match(SystemVerilogParserKTYPE)
	}
	{
		p.SetState(3143)
		p.Match(SystemVerilogParserLP)
	}
	p.SetState(3146)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 316, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(3144)
			p.expression(0)
		}

	case 2:
		{
			p.SetState(3145)
			p.Data_type()
		}

	}
	{
		p.SetState(3148)
		p.Match(SystemVerilogParserRP)
	}

	return localctx
}

// IDrive_strengthContext is an interface to support dynamic dispatch.
type IDrive_strengthContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDrive_strengthContext differentiates from other interfaces.
	IsDrive_strengthContext()
}

type Drive_strengthContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDrive_strengthContext() *Drive_strengthContext {
	var p = new(Drive_strengthContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_drive_strength
	return p
}

func (*Drive_strengthContext) IsDrive_strengthContext() {}

func NewDrive_strengthContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Drive_strengthContext {
	var p = new(Drive_strengthContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_drive_strength

	return p
}

func (s *Drive_strengthContext) GetParser() antlr.Parser { return s.parser }

func (s *Drive_strengthContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Drive_strengthContext) Strength0() IStrength0Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStrength0Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStrength0Context)
}

func (s *Drive_strengthContext) COMMA() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, 0)
}

func (s *Drive_strengthContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Drive_strengthContext) Strength1() IStrength1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStrength1Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStrength1Context)
}

func (s *Drive_strengthContext) KHIGHZ1() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKHIGHZ1, 0)
}

func (s *Drive_strengthContext) KHIGHZ0() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKHIGHZ0, 0)
}

func (s *Drive_strengthContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Drive_strengthContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Drive_strengthContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterDrive_strength(s)
	}
}

func (s *Drive_strengthContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitDrive_strength(s)
	}
}

func (p *SystemVerilogParser) Drive_strength() (localctx IDrive_strengthContext) {
	this := p
	_ = this

	localctx = NewDrive_strengthContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, SystemVerilogParserRULE_drive_strength)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3180)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 319, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3150)
			p.Match(SystemVerilogParserLP)
		}
		{
			p.SetState(3151)
			p.Strength0()
		}
		{
			p.SetState(3152)
			p.Match(SystemVerilogParserCOMMA)
		}
		p.SetState(3155)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SystemVerilogParserKPULL1, SystemVerilogParserKSTRONG1, SystemVerilogParserKSUPPLY1, SystemVerilogParserKWEAK1:
			{
				p.SetState(3153)
				p.Strength1()
			}

		case SystemVerilogParserKHIGHZ1:
			{
				p.SetState(3154)
				p.Match(SystemVerilogParserKHIGHZ1)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(3157)
			p.Match(SystemVerilogParserRP)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3159)
			p.Match(SystemVerilogParserLP)
		}
		{
			p.SetState(3160)
			p.Strength1()
		}
		{
			p.SetState(3161)
			p.Match(SystemVerilogParserCOMMA)
		}
		p.SetState(3164)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SystemVerilogParserKPULL0, SystemVerilogParserKSTRONG0, SystemVerilogParserKSUPPLY0, SystemVerilogParserKWEAK0:
			{
				p.SetState(3162)
				p.Strength0()
			}

		case SystemVerilogParserKHIGHZ0:
			{
				p.SetState(3163)
				p.Match(SystemVerilogParserKHIGHZ0)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(3166)
			p.Match(SystemVerilogParserRP)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3168)
			p.Match(SystemVerilogParserLP)
		}
		{
			p.SetState(3169)
			p.Match(SystemVerilogParserKHIGHZ0)
		}
		{
			p.SetState(3170)
			p.Match(SystemVerilogParserCOMMA)
		}
		{
			p.SetState(3171)
			p.Strength1()
		}
		{
			p.SetState(3172)
			p.Match(SystemVerilogParserRP)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3174)
			p.Match(SystemVerilogParserLP)
		}
		{
			p.SetState(3175)
			p.Match(SystemVerilogParserKHIGHZ1)
		}
		{
			p.SetState(3176)
			p.Match(SystemVerilogParserCOMMA)
		}
		{
			p.SetState(3177)
			p.Strength0()
		}
		{
			p.SetState(3178)
			p.Match(SystemVerilogParserRP)
		}

	}

	return localctx
}

// IStrength0Context is an interface to support dynamic dispatch.
type IStrength0Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStrength0Context differentiates from other interfaces.
	IsStrength0Context()
}

type Strength0Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStrength0Context() *Strength0Context {
	var p = new(Strength0Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_strength0
	return p
}

func (*Strength0Context) IsStrength0Context() {}

func NewStrength0Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Strength0Context {
	var p = new(Strength0Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_strength0

	return p
}

func (s *Strength0Context) GetParser() antlr.Parser { return s.parser }

func (s *Strength0Context) KSUPPLY0() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKSUPPLY0, 0)
}

func (s *Strength0Context) KSTRONG0() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKSTRONG0, 0)
}

func (s *Strength0Context) KPULL0() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKPULL0, 0)
}

func (s *Strength0Context) KWEAK0() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKWEAK0, 0)
}

func (s *Strength0Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Strength0Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Strength0Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterStrength0(s)
	}
}

func (s *Strength0Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitStrength0(s)
	}
}

func (p *SystemVerilogParser) Strength0() (localctx IStrength0Context) {
	this := p
	_ = this

	localctx = NewStrength0Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, SystemVerilogParserRULE_strength0)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3182)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SystemVerilogParserKPULL0 || _la == SystemVerilogParserKSTRONG0 || _la == SystemVerilogParserKSUPPLY0 || _la == SystemVerilogParserKWEAK0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IStrength1Context is an interface to support dynamic dispatch.
type IStrength1Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStrength1Context differentiates from other interfaces.
	IsStrength1Context()
}

type Strength1Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStrength1Context() *Strength1Context {
	var p = new(Strength1Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_strength1
	return p
}

func (*Strength1Context) IsStrength1Context() {}

func NewStrength1Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Strength1Context {
	var p = new(Strength1Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_strength1

	return p
}

func (s *Strength1Context) GetParser() antlr.Parser { return s.parser }

func (s *Strength1Context) KSUPPLY1() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKSUPPLY1, 0)
}

func (s *Strength1Context) KSTRONG1() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKSTRONG1, 0)
}

func (s *Strength1Context) KPULL1() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKPULL1, 0)
}

func (s *Strength1Context) KWEAK1() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKWEAK1, 0)
}

func (s *Strength1Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Strength1Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Strength1Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterStrength1(s)
	}
}

func (s *Strength1Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitStrength1(s)
	}
}

func (p *SystemVerilogParser) Strength1() (localctx IStrength1Context) {
	this := p
	_ = this

	localctx = NewStrength1Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, SystemVerilogParserRULE_strength1)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3184)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SystemVerilogParserKPULL1 || _la == SystemVerilogParserKSTRONG1 || _la == SystemVerilogParserKSUPPLY1 || _la == SystemVerilogParserKWEAK1) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ICharge_strengthContext is an interface to support dynamic dispatch.
type ICharge_strengthContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCharge_strengthContext differentiates from other interfaces.
	IsCharge_strengthContext()
}

type Charge_strengthContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharge_strengthContext() *Charge_strengthContext {
	var p = new(Charge_strengthContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_charge_strength
	return p
}

func (*Charge_strengthContext) IsCharge_strengthContext() {}

func NewCharge_strengthContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Charge_strengthContext {
	var p = new(Charge_strengthContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_charge_strength

	return p
}

func (s *Charge_strengthContext) GetParser() antlr.Parser { return s.parser }

func (s *Charge_strengthContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Charge_strengthContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Charge_strengthContext) KSMALL() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKSMALL, 0)
}

func (s *Charge_strengthContext) KMEDIUM() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKMEDIUM, 0)
}

func (s *Charge_strengthContext) KLARGE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKLARGE, 0)
}

func (s *Charge_strengthContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Charge_strengthContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Charge_strengthContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterCharge_strength(s)
	}
}

func (s *Charge_strengthContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitCharge_strength(s)
	}
}

func (p *SystemVerilogParser) Charge_strength() (localctx ICharge_strengthContext) {
	this := p
	_ = this

	localctx = NewCharge_strengthContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 286, SystemVerilogParserRULE_charge_strength)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3186)
		p.Match(SystemVerilogParserLP)
	}
	{
		p.SetState(3187)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SystemVerilogParserKLARGE || _la == SystemVerilogParserKMEDIUM || _la == SystemVerilogParserKSMALL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(3188)
		p.Match(SystemVerilogParserRP)
	}

	return localctx
}

// IDelay3Context is an interface to support dynamic dispatch.
type IDelay3Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDelay3Context differentiates from other interfaces.
	IsDelay3Context()
}

type Delay3Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDelay3Context() *Delay3Context {
	var p = new(Delay3Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_delay3
	return p
}

func (*Delay3Context) IsDelay3Context() {}

func NewDelay3Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Delay3Context {
	var p = new(Delay3Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_delay3

	return p
}

func (s *Delay3Context) GetParser() antlr.Parser { return s.parser }

func (s *Delay3Context) P() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserP, 0)
}

func (s *Delay3Context) Delay_value() IDelay_valueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelay_valueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelay_valueContext)
}

func (s *Delay3Context) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Delay3Context) AllMintypmax_expression() []IMintypmax_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMintypmax_expressionContext)(nil)).Elem())
	var tst = make([]IMintypmax_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMintypmax_expressionContext)
		}
	}

	return tst
}

func (s *Delay3Context) Mintypmax_expression(i int) IMintypmax_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMintypmax_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMintypmax_expressionContext)
}

func (s *Delay3Context) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Delay3Context) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *Delay3Context) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *Delay3Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Delay3Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Delay3Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterDelay3(s)
	}
}

func (s *Delay3Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitDelay3(s)
	}
}

func (p *SystemVerilogParser) Delay3() (localctx IDelay3Context) {
	this := p
	_ = this

	localctx = NewDelay3Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 288, SystemVerilogParserRULE_delay3)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3190)
		p.Match(SystemVerilogParserP)
	}
	p.SetState(3204)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserDUNIT, SystemVerilogParserKONESTEP, SystemVerilogParserTIME_LITERAL, SystemVerilogParserREAL_NUMBER, SystemVerilogParserUNSIGNED_NUMBER, SystemVerilogParserSIMPLE_IDENTIFIER:
		{
			p.SetState(3191)
			p.Delay_value()
		}

	case SystemVerilogParserLP:
		{
			p.SetState(3192)
			p.Match(SystemVerilogParserLP)
		}
		{
			p.SetState(3193)
			p.Mintypmax_expression()
		}
		p.SetState(3200)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserCOMMA {
			{
				p.SetState(3194)
				p.Match(SystemVerilogParserCOMMA)
			}
			{
				p.SetState(3195)
				p.Mintypmax_expression()
			}
			p.SetState(3198)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == SystemVerilogParserCOMMA {
				{
					p.SetState(3196)
					p.Match(SystemVerilogParserCOMMA)
				}
				{
					p.SetState(3197)
					p.Mintypmax_expression()
				}

			}

		}
		{
			p.SetState(3202)
			p.Match(SystemVerilogParserRP)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDelay2Context is an interface to support dynamic dispatch.
type IDelay2Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDelay2Context differentiates from other interfaces.
	IsDelay2Context()
}

type Delay2Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDelay2Context() *Delay2Context {
	var p = new(Delay2Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_delay2
	return p
}

func (*Delay2Context) IsDelay2Context() {}

func NewDelay2Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Delay2Context {
	var p = new(Delay2Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_delay2

	return p
}

func (s *Delay2Context) GetParser() antlr.Parser { return s.parser }

func (s *Delay2Context) P() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserP, 0)
}

func (s *Delay2Context) Delay_value() IDelay_valueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelay_valueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelay_valueContext)
}

func (s *Delay2Context) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Delay2Context) AllMintypmax_expression() []IMintypmax_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMintypmax_expressionContext)(nil)).Elem())
	var tst = make([]IMintypmax_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMintypmax_expressionContext)
		}
	}

	return tst
}

func (s *Delay2Context) Mintypmax_expression(i int) IMintypmax_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMintypmax_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMintypmax_expressionContext)
}

func (s *Delay2Context) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Delay2Context) COMMA() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, 0)
}

func (s *Delay2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Delay2Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Delay2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterDelay2(s)
	}
}

func (s *Delay2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitDelay2(s)
	}
}

func (p *SystemVerilogParser) Delay2() (localctx IDelay2Context) {
	this := p
	_ = this

	localctx = NewDelay2Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 290, SystemVerilogParserRULE_delay2)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3206)
		p.Match(SystemVerilogParserP)
	}
	p.SetState(3216)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserDUNIT, SystemVerilogParserKONESTEP, SystemVerilogParserTIME_LITERAL, SystemVerilogParserREAL_NUMBER, SystemVerilogParserUNSIGNED_NUMBER, SystemVerilogParserSIMPLE_IDENTIFIER:
		{
			p.SetState(3207)
			p.Delay_value()
		}

	case SystemVerilogParserLP:
		{
			p.SetState(3208)
			p.Match(SystemVerilogParserLP)
		}
		{
			p.SetState(3209)
			p.Mintypmax_expression()
		}
		p.SetState(3212)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserCOMMA {
			{
				p.SetState(3210)
				p.Match(SystemVerilogParserCOMMA)
			}
			{
				p.SetState(3211)
				p.Mintypmax_expression()
			}

		}
		{
			p.SetState(3214)
			p.Match(SystemVerilogParserRP)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDelay_valueContext is an interface to support dynamic dispatch.
type IDelay_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDelay_valueContext differentiates from other interfaces.
	IsDelay_valueContext()
}

type Delay_valueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDelay_valueContext() *Delay_valueContext {
	var p = new(Delay_valueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_delay_value
	return p
}

func (*Delay_valueContext) IsDelay_valueContext() {}

func NewDelay_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Delay_valueContext {
	var p = new(Delay_valueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_delay_value

	return p
}

func (s *Delay_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *Delay_valueContext) UNSIGNED_NUMBER() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserUNSIGNED_NUMBER, 0)
}

func (s *Delay_valueContext) REAL_NUMBER() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserREAL_NUMBER, 0)
}

func (s *Delay_valueContext) Ps_identifier() IPs_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPs_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPs_identifierContext)
}

func (s *Delay_valueContext) TIME_LITERAL() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserTIME_LITERAL, 0)
}

func (s *Delay_valueContext) KONESTEP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKONESTEP, 0)
}

func (s *Delay_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Delay_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Delay_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterDelay_value(s)
	}
}

func (s *Delay_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitDelay_value(s)
	}
}

func (p *SystemVerilogParser) Delay_value() (localctx IDelay_valueContext) {
	this := p
	_ = this

	localctx = NewDelay_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 292, SystemVerilogParserRULE_delay_value)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3223)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserUNSIGNED_NUMBER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3218)
			p.Match(SystemVerilogParserUNSIGNED_NUMBER)
		}

	case SystemVerilogParserREAL_NUMBER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3219)
			p.Match(SystemVerilogParserREAL_NUMBER)
		}

	case SystemVerilogParserDUNIT, SystemVerilogParserSIMPLE_IDENTIFIER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3220)
			p.Ps_identifier()
		}

	case SystemVerilogParserTIME_LITERAL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3221)
			p.Match(SystemVerilogParserTIME_LITERAL)
		}

	case SystemVerilogParserKONESTEP:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3222)
			p.Match(SystemVerilogParserKONESTEP)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IList_of_defparam_assignmentsContext is an interface to support dynamic dispatch.
type IList_of_defparam_assignmentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_defparam_assignmentsContext differentiates from other interfaces.
	IsList_of_defparam_assignmentsContext()
}

type List_of_defparam_assignmentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_defparam_assignmentsContext() *List_of_defparam_assignmentsContext {
	var p = new(List_of_defparam_assignmentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_list_of_defparam_assignments
	return p
}

func (*List_of_defparam_assignmentsContext) IsList_of_defparam_assignmentsContext() {}

func NewList_of_defparam_assignmentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_defparam_assignmentsContext {
	var p = new(List_of_defparam_assignmentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_list_of_defparam_assignments

	return p
}

func (s *List_of_defparam_assignmentsContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_defparam_assignmentsContext) AllDefparam_assignment() []IDefparam_assignmentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDefparam_assignmentContext)(nil)).Elem())
	var tst = make([]IDefparam_assignmentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDefparam_assignmentContext)
		}
	}

	return tst
}

func (s *List_of_defparam_assignmentsContext) Defparam_assignment(i int) IDefparam_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefparam_assignmentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDefparam_assignmentContext)
}

func (s *List_of_defparam_assignmentsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *List_of_defparam_assignmentsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *List_of_defparam_assignmentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_defparam_assignmentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_defparam_assignmentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterList_of_defparam_assignments(s)
	}
}

func (s *List_of_defparam_assignmentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitList_of_defparam_assignments(s)
	}
}

func (p *SystemVerilogParser) List_of_defparam_assignments() (localctx IList_of_defparam_assignmentsContext) {
	this := p
	_ = this

	localctx = NewList_of_defparam_assignmentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 294, SystemVerilogParserRULE_list_of_defparam_assignments)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3225)
		p.Defparam_assignment()
	}
	p.SetState(3230)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserCOMMA {
		{
			p.SetState(3226)
			p.Match(SystemVerilogParserCOMMA)
		}
		{
			p.SetState(3227)
			p.Defparam_assignment()
		}

		p.SetState(3232)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IList_of_genvar_identifiersContext is an interface to support dynamic dispatch.
type IList_of_genvar_identifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_genvar_identifiersContext differentiates from other interfaces.
	IsList_of_genvar_identifiersContext()
}

type List_of_genvar_identifiersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_genvar_identifiersContext() *List_of_genvar_identifiersContext {
	var p = new(List_of_genvar_identifiersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_list_of_genvar_identifiers
	return p
}

func (*List_of_genvar_identifiersContext) IsList_of_genvar_identifiersContext() {}

func NewList_of_genvar_identifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_genvar_identifiersContext {
	var p = new(List_of_genvar_identifiersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_list_of_genvar_identifiers

	return p
}

func (s *List_of_genvar_identifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_genvar_identifiersContext) AllGenvar_identifier() []IGenvar_identifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IGenvar_identifierContext)(nil)).Elem())
	var tst = make([]IGenvar_identifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IGenvar_identifierContext)
		}
	}

	return tst
}

func (s *List_of_genvar_identifiersContext) Genvar_identifier(i int) IGenvar_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenvar_identifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IGenvar_identifierContext)
}

func (s *List_of_genvar_identifiersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *List_of_genvar_identifiersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *List_of_genvar_identifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_genvar_identifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_genvar_identifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterList_of_genvar_identifiers(s)
	}
}

func (s *List_of_genvar_identifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitList_of_genvar_identifiers(s)
	}
}

func (p *SystemVerilogParser) List_of_genvar_identifiers() (localctx IList_of_genvar_identifiersContext) {
	this := p
	_ = this

	localctx = NewList_of_genvar_identifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 296, SystemVerilogParserRULE_list_of_genvar_identifiers)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3233)
		p.Genvar_identifier()
	}
	p.SetState(3238)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserCOMMA {
		{
			p.SetState(3234)
			p.Match(SystemVerilogParserCOMMA)
		}
		{
			p.SetState(3235)
			p.Genvar_identifier()
		}

		p.SetState(3240)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IList_of_interface_identifiersContext is an interface to support dynamic dispatch.
type IList_of_interface_identifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_interface_identifiersContext differentiates from other interfaces.
	IsList_of_interface_identifiersContext()
}

type List_of_interface_identifiersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_interface_identifiersContext() *List_of_interface_identifiersContext {
	var p = new(List_of_interface_identifiersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_list_of_interface_identifiers
	return p
}

func (*List_of_interface_identifiersContext) IsList_of_interface_identifiersContext() {}

func NewList_of_interface_identifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_interface_identifiersContext {
	var p = new(List_of_interface_identifiersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_list_of_interface_identifiers

	return p
}

func (s *List_of_interface_identifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_interface_identifiersContext) AllInterface_identifier() []IInterface_identifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInterface_identifierContext)(nil)).Elem())
	var tst = make([]IInterface_identifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInterface_identifierContext)
		}
	}

	return tst
}

func (s *List_of_interface_identifiersContext) Interface_identifier(i int) IInterface_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_identifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInterface_identifierContext)
}

func (s *List_of_interface_identifiersContext) AllUnpacked_dimension() []IUnpacked_dimensionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IUnpacked_dimensionContext)(nil)).Elem())
	var tst = make([]IUnpacked_dimensionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IUnpacked_dimensionContext)
		}
	}

	return tst
}

func (s *List_of_interface_identifiersContext) Unpacked_dimension(i int) IUnpacked_dimensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnpacked_dimensionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IUnpacked_dimensionContext)
}

func (s *List_of_interface_identifiersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *List_of_interface_identifiersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *List_of_interface_identifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_interface_identifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_interface_identifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterList_of_interface_identifiers(s)
	}
}

func (s *List_of_interface_identifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitList_of_interface_identifiers(s)
	}
}

func (p *SystemVerilogParser) List_of_interface_identifiers() (localctx IList_of_interface_identifiersContext) {
	this := p
	_ = this

	localctx = NewList_of_interface_identifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 298, SystemVerilogParserRULE_list_of_interface_identifiers)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3241)
		p.Interface_identifier()
	}
	p.SetState(3245)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserLB {
		{
			p.SetState(3242)
			p.Unpacked_dimension()
		}

		p.SetState(3247)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(3258)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserCOMMA {
		{
			p.SetState(3248)
			p.Match(SystemVerilogParserCOMMA)
		}
		{
			p.SetState(3249)
			p.Interface_identifier()
		}
		p.SetState(3253)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserLB {
			{
				p.SetState(3250)
				p.Unpacked_dimension()
			}

			p.SetState(3255)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

		p.SetState(3260)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IList_of_net_decl_assignmentsContext is an interface to support dynamic dispatch.
type IList_of_net_decl_assignmentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_net_decl_assignmentsContext differentiates from other interfaces.
	IsList_of_net_decl_assignmentsContext()
}

type List_of_net_decl_assignmentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_net_decl_assignmentsContext() *List_of_net_decl_assignmentsContext {
	var p = new(List_of_net_decl_assignmentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_list_of_net_decl_assignments
	return p
}

func (*List_of_net_decl_assignmentsContext) IsList_of_net_decl_assignmentsContext() {}

func NewList_of_net_decl_assignmentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_net_decl_assignmentsContext {
	var p = new(List_of_net_decl_assignmentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_list_of_net_decl_assignments

	return p
}

func (s *List_of_net_decl_assignmentsContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_net_decl_assignmentsContext) AllNet_decl_assignment() []INet_decl_assignmentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INet_decl_assignmentContext)(nil)).Elem())
	var tst = make([]INet_decl_assignmentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INet_decl_assignmentContext)
		}
	}

	return tst
}

func (s *List_of_net_decl_assignmentsContext) Net_decl_assignment(i int) INet_decl_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_decl_assignmentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INet_decl_assignmentContext)
}

func (s *List_of_net_decl_assignmentsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *List_of_net_decl_assignmentsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *List_of_net_decl_assignmentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_net_decl_assignmentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_net_decl_assignmentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterList_of_net_decl_assignments(s)
	}
}

func (s *List_of_net_decl_assignmentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitList_of_net_decl_assignments(s)
	}
}

func (p *SystemVerilogParser) List_of_net_decl_assignments() (localctx IList_of_net_decl_assignmentsContext) {
	this := p
	_ = this

	localctx = NewList_of_net_decl_assignmentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 300, SystemVerilogParserRULE_list_of_net_decl_assignments)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3261)
		p.Net_decl_assignment()
	}
	p.SetState(3266)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserCOMMA {
		{
			p.SetState(3262)
			p.Match(SystemVerilogParserCOMMA)
		}
		{
			p.SetState(3263)
			p.Net_decl_assignment()
		}

		p.SetState(3268)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IList_of_param_assignmentsContext is an interface to support dynamic dispatch.
type IList_of_param_assignmentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_param_assignmentsContext differentiates from other interfaces.
	IsList_of_param_assignmentsContext()
}

type List_of_param_assignmentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_param_assignmentsContext() *List_of_param_assignmentsContext {
	var p = new(List_of_param_assignmentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_list_of_param_assignments
	return p
}

func (*List_of_param_assignmentsContext) IsList_of_param_assignmentsContext() {}

func NewList_of_param_assignmentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_param_assignmentsContext {
	var p = new(List_of_param_assignmentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_list_of_param_assignments

	return p
}

func (s *List_of_param_assignmentsContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_param_assignmentsContext) AllParam_assignment() []IParam_assignmentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IParam_assignmentContext)(nil)).Elem())
	var tst = make([]IParam_assignmentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IParam_assignmentContext)
		}
	}

	return tst
}

func (s *List_of_param_assignmentsContext) Param_assignment(i int) IParam_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParam_assignmentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IParam_assignmentContext)
}

func (s *List_of_param_assignmentsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *List_of_param_assignmentsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *List_of_param_assignmentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_param_assignmentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_param_assignmentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterList_of_param_assignments(s)
	}
}

func (s *List_of_param_assignmentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitList_of_param_assignments(s)
	}
}

func (p *SystemVerilogParser) List_of_param_assignments() (localctx IList_of_param_assignmentsContext) {
	this := p
	_ = this

	localctx = NewList_of_param_assignmentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 302, SystemVerilogParserRULE_list_of_param_assignments)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3269)
		p.Param_assignment()
	}
	p.SetState(3274)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 332, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3270)
				p.Match(SystemVerilogParserCOMMA)
			}
			{
				p.SetState(3271)
				p.Param_assignment()
			}

		}
		p.SetState(3276)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 332, p.GetParserRuleContext())
	}

	return localctx
}

// IList_of_port_identifiersContext is an interface to support dynamic dispatch.
type IList_of_port_identifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_port_identifiersContext differentiates from other interfaces.
	IsList_of_port_identifiersContext()
}

type List_of_port_identifiersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_port_identifiersContext() *List_of_port_identifiersContext {
	var p = new(List_of_port_identifiersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_list_of_port_identifiers
	return p
}

func (*List_of_port_identifiersContext) IsList_of_port_identifiersContext() {}

func NewList_of_port_identifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_port_identifiersContext {
	var p = new(List_of_port_identifiersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_list_of_port_identifiers

	return p
}

func (s *List_of_port_identifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_port_identifiersContext) AllPort_identifier() []IPort_identifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPort_identifierContext)(nil)).Elem())
	var tst = make([]IPort_identifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPort_identifierContext)
		}
	}

	return tst
}

func (s *List_of_port_identifiersContext) Port_identifier(i int) IPort_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPort_identifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPort_identifierContext)
}

func (s *List_of_port_identifiersContext) AllUnpacked_dimension() []IUnpacked_dimensionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IUnpacked_dimensionContext)(nil)).Elem())
	var tst = make([]IUnpacked_dimensionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IUnpacked_dimensionContext)
		}
	}

	return tst
}

func (s *List_of_port_identifiersContext) Unpacked_dimension(i int) IUnpacked_dimensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnpacked_dimensionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IUnpacked_dimensionContext)
}

func (s *List_of_port_identifiersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *List_of_port_identifiersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *List_of_port_identifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_port_identifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_port_identifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterList_of_port_identifiers(s)
	}
}

func (s *List_of_port_identifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitList_of_port_identifiers(s)
	}
}

func (p *SystemVerilogParser) List_of_port_identifiers() (localctx IList_of_port_identifiersContext) {
	this := p
	_ = this

	localctx = NewList_of_port_identifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 304, SystemVerilogParserRULE_list_of_port_identifiers)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3277)
		p.Port_identifier()
	}
	p.SetState(3281)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserLB {
		{
			p.SetState(3278)
			p.Unpacked_dimension()
		}

		p.SetState(3283)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(3294)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserCOMMA {
		{
			p.SetState(3284)
			p.Match(SystemVerilogParserCOMMA)
		}
		{
			p.SetState(3285)
			p.Port_identifier()
		}
		p.SetState(3289)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserLB {
			{
				p.SetState(3286)
				p.Unpacked_dimension()
			}

			p.SetState(3291)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

		p.SetState(3296)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IList_of_udp_port_identifiersContext is an interface to support dynamic dispatch.
type IList_of_udp_port_identifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_udp_port_identifiersContext differentiates from other interfaces.
	IsList_of_udp_port_identifiersContext()
}

type List_of_udp_port_identifiersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_udp_port_identifiersContext() *List_of_udp_port_identifiersContext {
	var p = new(List_of_udp_port_identifiersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_list_of_udp_port_identifiers
	return p
}

func (*List_of_udp_port_identifiersContext) IsList_of_udp_port_identifiersContext() {}

func NewList_of_udp_port_identifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_udp_port_identifiersContext {
	var p = new(List_of_udp_port_identifiersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_list_of_udp_port_identifiers

	return p
}

func (s *List_of_udp_port_identifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_udp_port_identifiersContext) AllPort_identifier() []IPort_identifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPort_identifierContext)(nil)).Elem())
	var tst = make([]IPort_identifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPort_identifierContext)
		}
	}

	return tst
}

func (s *List_of_udp_port_identifiersContext) Port_identifier(i int) IPort_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPort_identifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPort_identifierContext)
}

func (s *List_of_udp_port_identifiersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *List_of_udp_port_identifiersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *List_of_udp_port_identifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_udp_port_identifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_udp_port_identifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterList_of_udp_port_identifiers(s)
	}
}

func (s *List_of_udp_port_identifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitList_of_udp_port_identifiers(s)
	}
}

func (p *SystemVerilogParser) List_of_udp_port_identifiers() (localctx IList_of_udp_port_identifiersContext) {
	this := p
	_ = this

	localctx = NewList_of_udp_port_identifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 306, SystemVerilogParserRULE_list_of_udp_port_identifiers)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3297)
		p.Port_identifier()
	}
	p.SetState(3302)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserCOMMA {
		{
			p.SetState(3298)
			p.Match(SystemVerilogParserCOMMA)
		}
		{
			p.SetState(3299)
			p.Port_identifier()
		}

		p.SetState(3304)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IList_of_specparam_assignmentsContext is an interface to support dynamic dispatch.
type IList_of_specparam_assignmentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_specparam_assignmentsContext differentiates from other interfaces.
	IsList_of_specparam_assignmentsContext()
}

type List_of_specparam_assignmentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_specparam_assignmentsContext() *List_of_specparam_assignmentsContext {
	var p = new(List_of_specparam_assignmentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_list_of_specparam_assignments
	return p
}

func (*List_of_specparam_assignmentsContext) IsList_of_specparam_assignmentsContext() {}

func NewList_of_specparam_assignmentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_specparam_assignmentsContext {
	var p = new(List_of_specparam_assignmentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_list_of_specparam_assignments

	return p
}

func (s *List_of_specparam_assignmentsContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_specparam_assignmentsContext) AllSpecparam_assignment() []ISpecparam_assignmentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISpecparam_assignmentContext)(nil)).Elem())
	var tst = make([]ISpecparam_assignmentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISpecparam_assignmentContext)
		}
	}

	return tst
}

func (s *List_of_specparam_assignmentsContext) Specparam_assignment(i int) ISpecparam_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecparam_assignmentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISpecparam_assignmentContext)
}

func (s *List_of_specparam_assignmentsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *List_of_specparam_assignmentsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *List_of_specparam_assignmentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_specparam_assignmentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_specparam_assignmentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterList_of_specparam_assignments(s)
	}
}

func (s *List_of_specparam_assignmentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitList_of_specparam_assignments(s)
	}
}

func (p *SystemVerilogParser) List_of_specparam_assignments() (localctx IList_of_specparam_assignmentsContext) {
	this := p
	_ = this

	localctx = NewList_of_specparam_assignmentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 308, SystemVerilogParserRULE_list_of_specparam_assignments)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3305)
		p.Specparam_assignment()
	}
	p.SetState(3310)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserCOMMA {
		{
			p.SetState(3306)
			p.Match(SystemVerilogParserCOMMA)
		}
		{
			p.SetState(3307)
			p.Specparam_assignment()
		}

		p.SetState(3312)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IList_of_tf_variable_identifiersContext is an interface to support dynamic dispatch.
type IList_of_tf_variable_identifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_tf_variable_identifiersContext differentiates from other interfaces.
	IsList_of_tf_variable_identifiersContext()
}

type List_of_tf_variable_identifiersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_tf_variable_identifiersContext() *List_of_tf_variable_identifiersContext {
	var p = new(List_of_tf_variable_identifiersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_list_of_tf_variable_identifiers
	return p
}

func (*List_of_tf_variable_identifiersContext) IsList_of_tf_variable_identifiersContext() {}

func NewList_of_tf_variable_identifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_tf_variable_identifiersContext {
	var p = new(List_of_tf_variable_identifiersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_list_of_tf_variable_identifiers

	return p
}

func (s *List_of_tf_variable_identifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_tf_variable_identifiersContext) AllPort_identifier() []IPort_identifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPort_identifierContext)(nil)).Elem())
	var tst = make([]IPort_identifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPort_identifierContext)
		}
	}

	return tst
}

func (s *List_of_tf_variable_identifiersContext) Port_identifier(i int) IPort_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPort_identifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPort_identifierContext)
}

func (s *List_of_tf_variable_identifiersContext) AllVariable_dimension() []IVariable_dimensionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariable_dimensionContext)(nil)).Elem())
	var tst = make([]IVariable_dimensionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariable_dimensionContext)
		}
	}

	return tst
}

func (s *List_of_tf_variable_identifiersContext) Variable_dimension(i int) IVariable_dimensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_dimensionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariable_dimensionContext)
}

func (s *List_of_tf_variable_identifiersContext) AllEQ() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserEQ)
}

func (s *List_of_tf_variable_identifiersContext) EQ(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserEQ, i)
}

func (s *List_of_tf_variable_identifiersContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *List_of_tf_variable_identifiersContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *List_of_tf_variable_identifiersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *List_of_tf_variable_identifiersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *List_of_tf_variable_identifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_tf_variable_identifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_tf_variable_identifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterList_of_tf_variable_identifiers(s)
	}
}

func (s *List_of_tf_variable_identifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitList_of_tf_variable_identifiers(s)
	}
}

func (p *SystemVerilogParser) List_of_tf_variable_identifiers() (localctx IList_of_tf_variable_identifiersContext) {
	this := p
	_ = this

	localctx = NewList_of_tf_variable_identifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 310, SystemVerilogParserRULE_list_of_tf_variable_identifiers)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3313)
		p.Port_identifier()
	}
	p.SetState(3317)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserLB {
		{
			p.SetState(3314)
			p.Variable_dimension()
		}

		p.SetState(3319)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(3322)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserEQ {
		{
			p.SetState(3320)
			p.Match(SystemVerilogParserEQ)
		}
		{
			p.SetState(3321)
			p.expression(0)
		}

	}
	p.SetState(3338)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserCOMMA {
		{
			p.SetState(3324)
			p.Match(SystemVerilogParserCOMMA)
		}
		{
			p.SetState(3325)
			p.Port_identifier()
		}
		p.SetState(3329)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserLB {
			{
				p.SetState(3326)
				p.Variable_dimension()
			}

			p.SetState(3331)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(3334)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserEQ {
			{
				p.SetState(3332)
				p.Match(SystemVerilogParserEQ)
			}
			{
				p.SetState(3333)
				p.expression(0)
			}

		}

		p.SetState(3340)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IList_of_type_assignmentsContext is an interface to support dynamic dispatch.
type IList_of_type_assignmentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_type_assignmentsContext differentiates from other interfaces.
	IsList_of_type_assignmentsContext()
}

type List_of_type_assignmentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_type_assignmentsContext() *List_of_type_assignmentsContext {
	var p = new(List_of_type_assignmentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_list_of_type_assignments
	return p
}

func (*List_of_type_assignmentsContext) IsList_of_type_assignmentsContext() {}

func NewList_of_type_assignmentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_type_assignmentsContext {
	var p = new(List_of_type_assignmentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_list_of_type_assignments

	return p
}

func (s *List_of_type_assignmentsContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_type_assignmentsContext) AllType_assignment() []IType_assignmentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IType_assignmentContext)(nil)).Elem())
	var tst = make([]IType_assignmentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IType_assignmentContext)
		}
	}

	return tst
}

func (s *List_of_type_assignmentsContext) Type_assignment(i int) IType_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_assignmentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IType_assignmentContext)
}

func (s *List_of_type_assignmentsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *List_of_type_assignmentsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *List_of_type_assignmentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_type_assignmentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_type_assignmentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterList_of_type_assignments(s)
	}
}

func (s *List_of_type_assignmentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitList_of_type_assignments(s)
	}
}

func (p *SystemVerilogParser) List_of_type_assignments() (localctx IList_of_type_assignmentsContext) {
	this := p
	_ = this

	localctx = NewList_of_type_assignmentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 312, SystemVerilogParserRULE_list_of_type_assignments)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3341)
		p.Type_assignment()
	}
	p.SetState(3346)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 343, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3342)
				p.Match(SystemVerilogParserCOMMA)
			}
			{
				p.SetState(3343)
				p.Type_assignment()
			}

		}
		p.SetState(3348)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 343, p.GetParserRuleContext())
	}

	return localctx
}

// IList_of_variable_decl_assignmentsContext is an interface to support dynamic dispatch.
type IList_of_variable_decl_assignmentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_variable_decl_assignmentsContext differentiates from other interfaces.
	IsList_of_variable_decl_assignmentsContext()
}

type List_of_variable_decl_assignmentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_variable_decl_assignmentsContext() *List_of_variable_decl_assignmentsContext {
	var p = new(List_of_variable_decl_assignmentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_list_of_variable_decl_assignments
	return p
}

func (*List_of_variable_decl_assignmentsContext) IsList_of_variable_decl_assignmentsContext() {}

func NewList_of_variable_decl_assignmentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_variable_decl_assignmentsContext {
	var p = new(List_of_variable_decl_assignmentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_list_of_variable_decl_assignments

	return p
}

func (s *List_of_variable_decl_assignmentsContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_variable_decl_assignmentsContext) AllVariable_decl_assignment() []IVariable_decl_assignmentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariable_decl_assignmentContext)(nil)).Elem())
	var tst = make([]IVariable_decl_assignmentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariable_decl_assignmentContext)
		}
	}

	return tst
}

func (s *List_of_variable_decl_assignmentsContext) Variable_decl_assignment(i int) IVariable_decl_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_decl_assignmentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariable_decl_assignmentContext)
}

func (s *List_of_variable_decl_assignmentsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *List_of_variable_decl_assignmentsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *List_of_variable_decl_assignmentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_variable_decl_assignmentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_variable_decl_assignmentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterList_of_variable_decl_assignments(s)
	}
}

func (s *List_of_variable_decl_assignmentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitList_of_variable_decl_assignments(s)
	}
}

func (p *SystemVerilogParser) List_of_variable_decl_assignments() (localctx IList_of_variable_decl_assignmentsContext) {
	this := p
	_ = this

	localctx = NewList_of_variable_decl_assignmentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 314, SystemVerilogParserRULE_list_of_variable_decl_assignments)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3349)
		p.Variable_decl_assignment()
	}
	p.SetState(3354)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserCOMMA {
		{
			p.SetState(3350)
			p.Match(SystemVerilogParserCOMMA)
		}
		{
			p.SetState(3351)
			p.Variable_decl_assignment()
		}

		p.SetState(3356)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IList_of_variable_identifiersContext is an interface to support dynamic dispatch.
type IList_of_variable_identifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_variable_identifiersContext differentiates from other interfaces.
	IsList_of_variable_identifiersContext()
}

type List_of_variable_identifiersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_variable_identifiersContext() *List_of_variable_identifiersContext {
	var p = new(List_of_variable_identifiersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_list_of_variable_identifiers
	return p
}

func (*List_of_variable_identifiersContext) IsList_of_variable_identifiersContext() {}

func NewList_of_variable_identifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_variable_identifiersContext {
	var p = new(List_of_variable_identifiersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_list_of_variable_identifiers

	return p
}

func (s *List_of_variable_identifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_variable_identifiersContext) AllVariable_identifier() []IVariable_identifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariable_identifierContext)(nil)).Elem())
	var tst = make([]IVariable_identifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariable_identifierContext)
		}
	}

	return tst
}

func (s *List_of_variable_identifiersContext) Variable_identifier(i int) IVariable_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_identifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariable_identifierContext)
}

func (s *List_of_variable_identifiersContext) AllVariable_dimension() []IVariable_dimensionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariable_dimensionContext)(nil)).Elem())
	var tst = make([]IVariable_dimensionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariable_dimensionContext)
		}
	}

	return tst
}

func (s *List_of_variable_identifiersContext) Variable_dimension(i int) IVariable_dimensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_dimensionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariable_dimensionContext)
}

func (s *List_of_variable_identifiersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *List_of_variable_identifiersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *List_of_variable_identifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_variable_identifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_variable_identifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterList_of_variable_identifiers(s)
	}
}

func (s *List_of_variable_identifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitList_of_variable_identifiers(s)
	}
}

func (p *SystemVerilogParser) List_of_variable_identifiers() (localctx IList_of_variable_identifiersContext) {
	this := p
	_ = this

	localctx = NewList_of_variable_identifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 316, SystemVerilogParserRULE_list_of_variable_identifiers)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3357)
		p.Variable_identifier()
	}
	p.SetState(3361)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserLB {
		{
			p.SetState(3358)
			p.Variable_dimension()
		}

		p.SetState(3363)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(3374)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserCOMMA {
		{
			p.SetState(3364)
			p.Match(SystemVerilogParserCOMMA)
		}
		{
			p.SetState(3365)
			p.Variable_identifier()
		}
		p.SetState(3369)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserLB {
			{
				p.SetState(3366)
				p.Variable_dimension()
			}

			p.SetState(3371)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

		p.SetState(3376)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IList_of_variable_port_identifiersContext is an interface to support dynamic dispatch.
type IList_of_variable_port_identifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_variable_port_identifiersContext differentiates from other interfaces.
	IsList_of_variable_port_identifiersContext()
}

type List_of_variable_port_identifiersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_variable_port_identifiersContext() *List_of_variable_port_identifiersContext {
	var p = new(List_of_variable_port_identifiersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_list_of_variable_port_identifiers
	return p
}

func (*List_of_variable_port_identifiersContext) IsList_of_variable_port_identifiersContext() {}

func NewList_of_variable_port_identifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_variable_port_identifiersContext {
	var p = new(List_of_variable_port_identifiersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_list_of_variable_port_identifiers

	return p
}

func (s *List_of_variable_port_identifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_variable_port_identifiersContext) AllPort_identifier() []IPort_identifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPort_identifierContext)(nil)).Elem())
	var tst = make([]IPort_identifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPort_identifierContext)
		}
	}

	return tst
}

func (s *List_of_variable_port_identifiersContext) Port_identifier(i int) IPort_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPort_identifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPort_identifierContext)
}

func (s *List_of_variable_port_identifiersContext) AllVariable_dimension() []IVariable_dimensionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariable_dimensionContext)(nil)).Elem())
	var tst = make([]IVariable_dimensionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariable_dimensionContext)
		}
	}

	return tst
}

func (s *List_of_variable_port_identifiersContext) Variable_dimension(i int) IVariable_dimensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_dimensionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariable_dimensionContext)
}

func (s *List_of_variable_port_identifiersContext) AllEQ() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserEQ)
}

func (s *List_of_variable_port_identifiersContext) EQ(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserEQ, i)
}

func (s *List_of_variable_port_identifiersContext) AllConstant_expression() []IConstant_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem())
	var tst = make([]IConstant_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConstant_expressionContext)
		}
	}

	return tst
}

func (s *List_of_variable_port_identifiersContext) Constant_expression(i int) IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *List_of_variable_port_identifiersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *List_of_variable_port_identifiersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *List_of_variable_port_identifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_variable_port_identifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_variable_port_identifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterList_of_variable_port_identifiers(s)
	}
}

func (s *List_of_variable_port_identifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitList_of_variable_port_identifiers(s)
	}
}

func (p *SystemVerilogParser) List_of_variable_port_identifiers() (localctx IList_of_variable_port_identifiersContext) {
	this := p
	_ = this

	localctx = NewList_of_variable_port_identifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 318, SystemVerilogParserRULE_list_of_variable_port_identifiers)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3377)
		p.Port_identifier()
	}
	p.SetState(3381)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserLB {
		{
			p.SetState(3378)
			p.Variable_dimension()
		}

		p.SetState(3383)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(3386)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserEQ {
		{
			p.SetState(3384)
			p.Match(SystemVerilogParserEQ)
		}
		{
			p.SetState(3385)
			p.constant_expression(0)
		}

	}
	p.SetState(3402)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserCOMMA {
		{
			p.SetState(3388)
			p.Match(SystemVerilogParserCOMMA)
		}
		{
			p.SetState(3389)
			p.Port_identifier()
		}
		p.SetState(3393)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserLB {
			{
				p.SetState(3390)
				p.Variable_dimension()
			}

			p.SetState(3395)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(3398)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserEQ {
			{
				p.SetState(3396)
				p.Match(SystemVerilogParserEQ)
			}
			{
				p.SetState(3397)
				p.constant_expression(0)
			}

		}

		p.SetState(3404)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IDefparam_assignmentContext is an interface to support dynamic dispatch.
type IDefparam_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDefparam_assignmentContext differentiates from other interfaces.
	IsDefparam_assignmentContext()
}

type Defparam_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefparam_assignmentContext() *Defparam_assignmentContext {
	var p = new(Defparam_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_defparam_assignment
	return p
}

func (*Defparam_assignmentContext) IsDefparam_assignmentContext() {}

func NewDefparam_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Defparam_assignmentContext {
	var p = new(Defparam_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_defparam_assignment

	return p
}

func (s *Defparam_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Defparam_assignmentContext) Hierarchical_parameter_identifier() IHierarchical_parameter_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_parameter_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_parameter_identifierContext)
}

func (s *Defparam_assignmentContext) EQ() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserEQ, 0)
}

func (s *Defparam_assignmentContext) Constant_mintypmax_expression() IConstant_mintypmax_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_mintypmax_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_mintypmax_expressionContext)
}

func (s *Defparam_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Defparam_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Defparam_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterDefparam_assignment(s)
	}
}

func (s *Defparam_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitDefparam_assignment(s)
	}
}

func (p *SystemVerilogParser) Defparam_assignment() (localctx IDefparam_assignmentContext) {
	this := p
	_ = this

	localctx = NewDefparam_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 320, SystemVerilogParserRULE_defparam_assignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3405)
		p.Hierarchical_parameter_identifier()
	}
	{
		p.SetState(3406)
		p.Match(SystemVerilogParserEQ)
	}
	{
		p.SetState(3407)
		p.Constant_mintypmax_expression()
	}

	return localctx
}

// INet_decl_assignmentContext is an interface to support dynamic dispatch.
type INet_decl_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNet_decl_assignmentContext differentiates from other interfaces.
	IsNet_decl_assignmentContext()
}

type Net_decl_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNet_decl_assignmentContext() *Net_decl_assignmentContext {
	var p = new(Net_decl_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_net_decl_assignment
	return p
}

func (*Net_decl_assignmentContext) IsNet_decl_assignmentContext() {}

func NewNet_decl_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Net_decl_assignmentContext {
	var p = new(Net_decl_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_net_decl_assignment

	return p
}

func (s *Net_decl_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Net_decl_assignmentContext) Net_identifier() INet_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INet_identifierContext)
}

func (s *Net_decl_assignmentContext) AllUnpacked_dimension() []IUnpacked_dimensionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IUnpacked_dimensionContext)(nil)).Elem())
	var tst = make([]IUnpacked_dimensionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IUnpacked_dimensionContext)
		}
	}

	return tst
}

func (s *Net_decl_assignmentContext) Unpacked_dimension(i int) IUnpacked_dimensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnpacked_dimensionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IUnpacked_dimensionContext)
}

func (s *Net_decl_assignmentContext) EQ() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserEQ, 0)
}

func (s *Net_decl_assignmentContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Net_decl_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Net_decl_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Net_decl_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterNet_decl_assignment(s)
	}
}

func (s *Net_decl_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitNet_decl_assignment(s)
	}
}

func (p *SystemVerilogParser) Net_decl_assignment() (localctx INet_decl_assignmentContext) {
	this := p
	_ = this

	localctx = NewNet_decl_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 322, SystemVerilogParserRULE_net_decl_assignment)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3409)
		p.Net_identifier()
	}
	p.SetState(3413)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserLB {
		{
			p.SetState(3410)
			p.Unpacked_dimension()
		}

		p.SetState(3415)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(3418)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserEQ {
		{
			p.SetState(3416)
			p.Match(SystemVerilogParserEQ)
		}
		{
			p.SetState(3417)
			p.expression(0)
		}

	}

	return localctx
}

// IParam_assignmentContext is an interface to support dynamic dispatch.
type IParam_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParam_assignmentContext differentiates from other interfaces.
	IsParam_assignmentContext()
}

type Param_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParam_assignmentContext() *Param_assignmentContext {
	var p = new(Param_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_param_assignment
	return p
}

func (*Param_assignmentContext) IsParam_assignmentContext() {}

func NewParam_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Param_assignmentContext {
	var p = new(Param_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_param_assignment

	return p
}

func (s *Param_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Param_assignmentContext) Parameter_identifier() IParameter_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_identifierContext)
}

func (s *Param_assignmentContext) AllUnpacked_dimension() []IUnpacked_dimensionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IUnpacked_dimensionContext)(nil)).Elem())
	var tst = make([]IUnpacked_dimensionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IUnpacked_dimensionContext)
		}
	}

	return tst
}

func (s *Param_assignmentContext) Unpacked_dimension(i int) IUnpacked_dimensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnpacked_dimensionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IUnpacked_dimensionContext)
}

func (s *Param_assignmentContext) EQ() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserEQ, 0)
}

func (s *Param_assignmentContext) Constant_param_expression() IConstant_param_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_param_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_param_expressionContext)
}

func (s *Param_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Param_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Param_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterParam_assignment(s)
	}
}

func (s *Param_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitParam_assignment(s)
	}
}

func (p *SystemVerilogParser) Param_assignment() (localctx IParam_assignmentContext) {
	this := p
	_ = this

	localctx = NewParam_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 324, SystemVerilogParserRULE_param_assignment)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3420)
		p.Parameter_identifier()
	}
	p.SetState(3424)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserLB {
		{
			p.SetState(3421)
			p.Unpacked_dimension()
		}

		p.SetState(3426)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(3429)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserEQ {
		{
			p.SetState(3427)
			p.Match(SystemVerilogParserEQ)
		}
		{
			p.SetState(3428)
			p.Constant_param_expression()
		}

	}

	return localctx
}

// ISpecparam_assignmentContext is an interface to support dynamic dispatch.
type ISpecparam_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSpecparam_assignmentContext differentiates from other interfaces.
	IsSpecparam_assignmentContext()
}

type Specparam_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpecparam_assignmentContext() *Specparam_assignmentContext {
	var p = new(Specparam_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_specparam_assignment
	return p
}

func (*Specparam_assignmentContext) IsSpecparam_assignmentContext() {}

func NewSpecparam_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Specparam_assignmentContext {
	var p = new(Specparam_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_specparam_assignment

	return p
}

func (s *Specparam_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Specparam_assignmentContext) Specparam_identifier() ISpecparam_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecparam_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpecparam_identifierContext)
}

func (s *Specparam_assignmentContext) EQ() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserEQ, 0)
}

func (s *Specparam_assignmentContext) Constant_mintypmax_expression() IConstant_mintypmax_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_mintypmax_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_mintypmax_expressionContext)
}

func (s *Specparam_assignmentContext) Pulse_control_specparam() IPulse_control_specparamContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPulse_control_specparamContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPulse_control_specparamContext)
}

func (s *Specparam_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Specparam_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Specparam_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterSpecparam_assignment(s)
	}
}

func (s *Specparam_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitSpecparam_assignment(s)
	}
}

func (p *SystemVerilogParser) Specparam_assignment() (localctx ISpecparam_assignmentContext) {
	this := p
	_ = this

	localctx = NewSpecparam_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 326, SystemVerilogParserRULE_specparam_assignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3436)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserSIMPLE_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3431)
			p.Specparam_identifier()
		}
		{
			p.SetState(3432)
			p.Match(SystemVerilogParserEQ)
		}
		{
			p.SetState(3433)
			p.Constant_mintypmax_expression()
		}

	case SystemVerilogParserKPATHPULSE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3435)
			p.Pulse_control_specparam()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IType_assignmentContext is an interface to support dynamic dispatch.
type IType_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsType_assignmentContext differentiates from other interfaces.
	IsType_assignmentContext()
}

type Type_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_assignmentContext() *Type_assignmentContext {
	var p = new(Type_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_type_assignment
	return p
}

func (*Type_assignmentContext) IsType_assignmentContext() {}

func NewType_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_assignmentContext {
	var p = new(Type_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_type_assignment

	return p
}

func (s *Type_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_assignmentContext) Type_identifier() IType_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_identifierContext)
}

func (s *Type_assignmentContext) EQ() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserEQ, 0)
}

func (s *Type_assignmentContext) Data_type() IData_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IData_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IData_typeContext)
}

func (s *Type_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterType_assignment(s)
	}
}

func (s *Type_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitType_assignment(s)
	}
}

func (p *SystemVerilogParser) Type_assignment() (localctx IType_assignmentContext) {
	this := p
	_ = this

	localctx = NewType_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 328, SystemVerilogParserRULE_type_assignment)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3438)
		p.Type_identifier()
	}
	p.SetState(3441)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserEQ {
		{
			p.SetState(3439)
			p.Match(SystemVerilogParserEQ)
		}
		{
			p.SetState(3440)
			p.Data_type()
		}

	}

	return localctx
}

// IPulse_control_specparamContext is an interface to support dynamic dispatch.
type IPulse_control_specparamContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPulse_control_specparamContext differentiates from other interfaces.
	IsPulse_control_specparamContext()
}

type Pulse_control_specparamContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPulse_control_specparamContext() *Pulse_control_specparamContext {
	var p = new(Pulse_control_specparamContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_pulse_control_specparam
	return p
}

func (*Pulse_control_specparamContext) IsPulse_control_specparamContext() {}

func NewPulse_control_specparamContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pulse_control_specparamContext {
	var p = new(Pulse_control_specparamContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_pulse_control_specparam

	return p
}

func (s *Pulse_control_specparamContext) GetParser() antlr.Parser { return s.parser }

func (s *Pulse_control_specparamContext) KPATHPULSE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKPATHPULSE, 0)
}

func (s *Pulse_control_specparamContext) EQ() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserEQ, 0)
}

func (s *Pulse_control_specparamContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Pulse_control_specparamContext) Reject_limit_value() IReject_limit_valueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReject_limit_valueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReject_limit_valueContext)
}

func (s *Pulse_control_specparamContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Pulse_control_specparamContext) Specify_input_terminal_descriptor() ISpecify_input_terminal_descriptorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecify_input_terminal_descriptorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpecify_input_terminal_descriptorContext)
}

func (s *Pulse_control_specparamContext) DOLLAR() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserDOLLAR, 0)
}

func (s *Pulse_control_specparamContext) Specify_output_terminal_descriptor() ISpecify_output_terminal_descriptorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecify_output_terminal_descriptorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpecify_output_terminal_descriptorContext)
}

func (s *Pulse_control_specparamContext) COMMA() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, 0)
}

func (s *Pulse_control_specparamContext) Error_limit_value() IError_limit_valueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IError_limit_valueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IError_limit_valueContext)
}

func (s *Pulse_control_specparamContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pulse_control_specparamContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pulse_control_specparamContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterPulse_control_specparam(s)
	}
}

func (s *Pulse_control_specparamContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitPulse_control_specparam(s)
	}
}

func (p *SystemVerilogParser) Pulse_control_specparam() (localctx IPulse_control_specparamContext) {
	this := p
	_ = this

	localctx = NewPulse_control_specparamContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 330, SystemVerilogParserRULE_pulse_control_specparam)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3443)
		p.Match(SystemVerilogParserKPATHPULSE)
	}
	p.SetState(3448)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserSIMPLE_IDENTIFIER {
		{
			p.SetState(3444)
			p.Specify_input_terminal_descriptor()
		}
		{
			p.SetState(3445)
			p.Match(SystemVerilogParserDOLLAR)
		}
		{
			p.SetState(3446)
			p.Specify_output_terminal_descriptor()
		}

	}
	{
		p.SetState(3450)
		p.Match(SystemVerilogParserEQ)
	}
	{
		p.SetState(3451)
		p.Match(SystemVerilogParserLP)
	}
	{
		p.SetState(3452)
		p.Reject_limit_value()
	}
	p.SetState(3455)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserCOMMA {
		{
			p.SetState(3453)
			p.Match(SystemVerilogParserCOMMA)
		}
		{
			p.SetState(3454)
			p.Error_limit_value()
		}

	}
	{
		p.SetState(3457)
		p.Match(SystemVerilogParserRP)
	}

	return localctx
}

// IError_limit_valueContext is an interface to support dynamic dispatch.
type IError_limit_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsError_limit_valueContext differentiates from other interfaces.
	IsError_limit_valueContext()
}

type Error_limit_valueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyError_limit_valueContext() *Error_limit_valueContext {
	var p = new(Error_limit_valueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_error_limit_value
	return p
}

func (*Error_limit_valueContext) IsError_limit_valueContext() {}

func NewError_limit_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Error_limit_valueContext {
	var p = new(Error_limit_valueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_error_limit_value

	return p
}

func (s *Error_limit_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *Error_limit_valueContext) Limit_value() ILimit_valueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILimit_valueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILimit_valueContext)
}

func (s *Error_limit_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Error_limit_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Error_limit_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterError_limit_value(s)
	}
}

func (s *Error_limit_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitError_limit_value(s)
	}
}

func (p *SystemVerilogParser) Error_limit_value() (localctx IError_limit_valueContext) {
	this := p
	_ = this

	localctx = NewError_limit_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 332, SystemVerilogParserRULE_error_limit_value)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3459)
		p.Limit_value()
	}

	return localctx
}

// IReject_limit_valueContext is an interface to support dynamic dispatch.
type IReject_limit_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReject_limit_valueContext differentiates from other interfaces.
	IsReject_limit_valueContext()
}

type Reject_limit_valueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReject_limit_valueContext() *Reject_limit_valueContext {
	var p = new(Reject_limit_valueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_reject_limit_value
	return p
}

func (*Reject_limit_valueContext) IsReject_limit_valueContext() {}

func NewReject_limit_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Reject_limit_valueContext {
	var p = new(Reject_limit_valueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_reject_limit_value

	return p
}

func (s *Reject_limit_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *Reject_limit_valueContext) Limit_value() ILimit_valueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILimit_valueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILimit_valueContext)
}

func (s *Reject_limit_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Reject_limit_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Reject_limit_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterReject_limit_value(s)
	}
}

func (s *Reject_limit_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitReject_limit_value(s)
	}
}

func (p *SystemVerilogParser) Reject_limit_value() (localctx IReject_limit_valueContext) {
	this := p
	_ = this

	localctx = NewReject_limit_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 334, SystemVerilogParserRULE_reject_limit_value)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3461)
		p.Limit_value()
	}

	return localctx
}

// ILimit_valueContext is an interface to support dynamic dispatch.
type ILimit_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLimit_valueContext differentiates from other interfaces.
	IsLimit_valueContext()
}

type Limit_valueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLimit_valueContext() *Limit_valueContext {
	var p = new(Limit_valueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_limit_value
	return p
}

func (*Limit_valueContext) IsLimit_valueContext() {}

func NewLimit_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Limit_valueContext {
	var p = new(Limit_valueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_limit_value

	return p
}

func (s *Limit_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *Limit_valueContext) Constant_mintypmax_expression() IConstant_mintypmax_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_mintypmax_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_mintypmax_expressionContext)
}

func (s *Limit_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Limit_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Limit_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterLimit_value(s)
	}
}

func (s *Limit_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitLimit_value(s)
	}
}

func (p *SystemVerilogParser) Limit_value() (localctx ILimit_valueContext) {
	this := p
	_ = this

	localctx = NewLimit_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 336, SystemVerilogParserRULE_limit_value)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3463)
		p.Constant_mintypmax_expression()
	}

	return localctx
}

// IVariable_decl_assignmentContext is an interface to support dynamic dispatch.
type IVariable_decl_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariable_decl_assignmentContext differentiates from other interfaces.
	IsVariable_decl_assignmentContext()
}

type Variable_decl_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariable_decl_assignmentContext() *Variable_decl_assignmentContext {
	var p = new(Variable_decl_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_variable_decl_assignment
	return p
}

func (*Variable_decl_assignmentContext) IsVariable_decl_assignmentContext() {}

func NewVariable_decl_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Variable_decl_assignmentContext {
	var p = new(Variable_decl_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_variable_decl_assignment

	return p
}

func (s *Variable_decl_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Variable_decl_assignmentContext) Variable_identifier() IVariable_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_identifierContext)
}

func (s *Variable_decl_assignmentContext) AllVariable_dimension() []IVariable_dimensionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariable_dimensionContext)(nil)).Elem())
	var tst = make([]IVariable_dimensionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariable_dimensionContext)
		}
	}

	return tst
}

func (s *Variable_decl_assignmentContext) Variable_dimension(i int) IVariable_dimensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_dimensionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariable_dimensionContext)
}

func (s *Variable_decl_assignmentContext) EQ() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserEQ, 0)
}

func (s *Variable_decl_assignmentContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Variable_decl_assignmentContext) Dynamic_array_variable_identifier() IDynamic_array_variable_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDynamic_array_variable_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDynamic_array_variable_identifierContext)
}

func (s *Variable_decl_assignmentContext) Unsized_dimension() IUnsized_dimensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnsized_dimensionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnsized_dimensionContext)
}

func (s *Variable_decl_assignmentContext) Dynamic_array_new() IDynamic_array_newContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDynamic_array_newContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDynamic_array_newContext)
}

func (s *Variable_decl_assignmentContext) Class_variable_identifier() IClass_variable_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_variable_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClass_variable_identifierContext)
}

func (s *Variable_decl_assignmentContext) Class_new() IClass_newContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_newContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClass_newContext)
}

func (s *Variable_decl_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Variable_decl_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Variable_decl_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterVariable_decl_assignment(s)
	}
}

func (s *Variable_decl_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitVariable_decl_assignment(s)
	}
}

func (p *SystemVerilogParser) Variable_decl_assignment() (localctx IVariable_decl_assignmentContext) {
	this := p
	_ = this

	localctx = NewVariable_decl_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 338, SystemVerilogParserRULE_variable_decl_assignment)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3493)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 366, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3465)
			p.Variable_identifier()
		}
		p.SetState(3469)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserLB {
			{
				p.SetState(3466)
				p.Variable_dimension()
			}

			p.SetState(3471)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(3474)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserEQ {
			{
				p.SetState(3472)
				p.Match(SystemVerilogParserEQ)
			}
			{
				p.SetState(3473)
				p.expression(0)
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3476)
			p.Dynamic_array_variable_identifier()
		}
		{
			p.SetState(3477)
			p.Unsized_dimension()
		}
		p.SetState(3481)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserLB {
			{
				p.SetState(3478)
				p.Variable_dimension()
			}

			p.SetState(3483)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(3486)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserEQ {
			{
				p.SetState(3484)
				p.Match(SystemVerilogParserEQ)
			}
			{
				p.SetState(3485)
				p.Dynamic_array_new()
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3488)
			p.Class_variable_identifier()
		}
		p.SetState(3491)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserEQ {
			{
				p.SetState(3489)
				p.Match(SystemVerilogParserEQ)
			}
			{
				p.SetState(3490)
				p.Class_new()
			}

		}

	}

	return localctx
}

// IClass_newContext is an interface to support dynamic dispatch.
type IClass_newContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClass_newContext differentiates from other interfaces.
	IsClass_newContext()
}

type Class_newContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClass_newContext() *Class_newContext {
	var p = new(Class_newContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_class_new
	return p
}

func (*Class_newContext) IsClass_newContext() {}

func NewClass_newContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Class_newContext {
	var p = new(Class_newContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_class_new

	return p
}

func (s *Class_newContext) GetParser() antlr.Parser { return s.parser }

func (s *Class_newContext) KNEW() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKNEW, 0)
}

func (s *Class_newContext) Class_scope() IClass_scopeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_scopeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClass_scopeContext)
}

func (s *Class_newContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Class_newContext) List_of_arguments() IList_of_argumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_argumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_argumentsContext)
}

func (s *Class_newContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Class_newContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Class_newContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Class_newContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Class_newContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterClass_new(s)
	}
}

func (s *Class_newContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitClass_new(s)
	}
}

func (p *SystemVerilogParser) Class_new() (localctx IClass_newContext) {
	this := p
	_ = this

	localctx = NewClass_newContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 340, SystemVerilogParserRULE_class_new)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3507)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 369, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(3496)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserDUNIT || _la == SystemVerilogParserSIMPLE_IDENTIFIER {
			{
				p.SetState(3495)
				p.Class_scope()
			}

		}
		{
			p.SetState(3498)
			p.Match(SystemVerilogParserKNEW)
		}
		p.SetState(3503)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserLP {
			{
				p.SetState(3499)
				p.Match(SystemVerilogParserLP)
			}
			{
				p.SetState(3500)
				p.List_of_arguments()
			}
			{
				p.SetState(3501)
				p.Match(SystemVerilogParserRP)
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3505)
			p.Match(SystemVerilogParserKNEW)
		}
		{
			p.SetState(3506)
			p.expression(0)
		}

	}

	return localctx
}

// IDynamic_array_newContext is an interface to support dynamic dispatch.
type IDynamic_array_newContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDynamic_array_newContext differentiates from other interfaces.
	IsDynamic_array_newContext()
}

type Dynamic_array_newContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDynamic_array_newContext() *Dynamic_array_newContext {
	var p = new(Dynamic_array_newContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_dynamic_array_new
	return p
}

func (*Dynamic_array_newContext) IsDynamic_array_newContext() {}

func NewDynamic_array_newContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dynamic_array_newContext {
	var p = new(Dynamic_array_newContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_dynamic_array_new

	return p
}

func (s *Dynamic_array_newContext) GetParser() antlr.Parser { return s.parser }

func (s *Dynamic_array_newContext) KNEW() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKNEW, 0)
}

func (s *Dynamic_array_newContext) LB() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLB, 0)
}

func (s *Dynamic_array_newContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *Dynamic_array_newContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Dynamic_array_newContext) RB() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRB, 0)
}

func (s *Dynamic_array_newContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Dynamic_array_newContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Dynamic_array_newContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dynamic_array_newContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dynamic_array_newContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterDynamic_array_new(s)
	}
}

func (s *Dynamic_array_newContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitDynamic_array_new(s)
	}
}

func (p *SystemVerilogParser) Dynamic_array_new() (localctx IDynamic_array_newContext) {
	this := p
	_ = this

	localctx = NewDynamic_array_newContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 342, SystemVerilogParserRULE_dynamic_array_new)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3509)
		p.Match(SystemVerilogParserKNEW)
	}
	{
		p.SetState(3510)
		p.Match(SystemVerilogParserLB)
	}
	{
		p.SetState(3511)
		p.expression(0)
	}
	{
		p.SetState(3512)
		p.Match(SystemVerilogParserRB)
	}
	p.SetState(3517)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserLP {
		{
			p.SetState(3513)
			p.Match(SystemVerilogParserLP)
		}
		{
			p.SetState(3514)
			p.expression(0)
		}
		{
			p.SetState(3515)
			p.Match(SystemVerilogParserRP)
		}

	}

	return localctx
}

// IUnpacked_dimensionContext is an interface to support dynamic dispatch.
type IUnpacked_dimensionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnpacked_dimensionContext differentiates from other interfaces.
	IsUnpacked_dimensionContext()
}

type Unpacked_dimensionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnpacked_dimensionContext() *Unpacked_dimensionContext {
	var p = new(Unpacked_dimensionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_unpacked_dimension
	return p
}

func (*Unpacked_dimensionContext) IsUnpacked_dimensionContext() {}

func NewUnpacked_dimensionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unpacked_dimensionContext {
	var p = new(Unpacked_dimensionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_unpacked_dimension

	return p
}

func (s *Unpacked_dimensionContext) GetParser() antlr.Parser { return s.parser }

func (s *Unpacked_dimensionContext) LB() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLB, 0)
}

func (s *Unpacked_dimensionContext) RB() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRB, 0)
}

func (s *Unpacked_dimensionContext) Constant_range() IConstant_rangeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_rangeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_rangeContext)
}

func (s *Unpacked_dimensionContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Unpacked_dimensionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unpacked_dimensionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Unpacked_dimensionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterUnpacked_dimension(s)
	}
}

func (s *Unpacked_dimensionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitUnpacked_dimension(s)
	}
}

func (p *SystemVerilogParser) Unpacked_dimension() (localctx IUnpacked_dimensionContext) {
	this := p
	_ = this

	localctx = NewUnpacked_dimensionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 344, SystemVerilogParserRULE_unpacked_dimension)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3519)
		p.Match(SystemVerilogParserLB)
	}
	p.SetState(3522)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 371, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(3520)
			p.Constant_range()
		}

	case 2:
		{
			p.SetState(3521)
			p.constant_expression(0)
		}

	}
	{
		p.SetState(3524)
		p.Match(SystemVerilogParserRB)
	}

	return localctx
}

// IPacked_dimensionContext is an interface to support dynamic dispatch.
type IPacked_dimensionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPacked_dimensionContext differentiates from other interfaces.
	IsPacked_dimensionContext()
}

type Packed_dimensionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPacked_dimensionContext() *Packed_dimensionContext {
	var p = new(Packed_dimensionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_packed_dimension
	return p
}

func (*Packed_dimensionContext) IsPacked_dimensionContext() {}

func NewPacked_dimensionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Packed_dimensionContext {
	var p = new(Packed_dimensionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_packed_dimension

	return p
}

func (s *Packed_dimensionContext) GetParser() antlr.Parser { return s.parser }

func (s *Packed_dimensionContext) LB() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLB, 0)
}

func (s *Packed_dimensionContext) Constant_range() IConstant_rangeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_rangeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_rangeContext)
}

func (s *Packed_dimensionContext) RB() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRB, 0)
}

func (s *Packed_dimensionContext) Unsized_dimension() IUnsized_dimensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnsized_dimensionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnsized_dimensionContext)
}

func (s *Packed_dimensionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Packed_dimensionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Packed_dimensionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterPacked_dimension(s)
	}
}

func (s *Packed_dimensionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitPacked_dimension(s)
	}
}

func (p *SystemVerilogParser) Packed_dimension() (localctx IPacked_dimensionContext) {
	this := p
	_ = this

	localctx = NewPacked_dimensionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 346, SystemVerilogParserRULE_packed_dimension)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3531)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 372, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3526)
			p.Match(SystemVerilogParserLB)
		}
		{
			p.SetState(3527)
			p.Constant_range()
		}
		{
			p.SetState(3528)
			p.Match(SystemVerilogParserRB)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3530)
			p.Unsized_dimension()
		}

	}

	return localctx
}

// IAssociative_dimensionContext is an interface to support dynamic dispatch.
type IAssociative_dimensionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssociative_dimensionContext differentiates from other interfaces.
	IsAssociative_dimensionContext()
}

type Associative_dimensionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssociative_dimensionContext() *Associative_dimensionContext {
	var p = new(Associative_dimensionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_associative_dimension
	return p
}

func (*Associative_dimensionContext) IsAssociative_dimensionContext() {}

func NewAssociative_dimensionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Associative_dimensionContext {
	var p = new(Associative_dimensionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_associative_dimension

	return p
}

func (s *Associative_dimensionContext) GetParser() antlr.Parser { return s.parser }

func (s *Associative_dimensionContext) LB() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLB, 0)
}

func (s *Associative_dimensionContext) RB() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRB, 0)
}

func (s *Associative_dimensionContext) Data_type() IData_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IData_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IData_typeContext)
}

func (s *Associative_dimensionContext) STAR() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSTAR, 0)
}

func (s *Associative_dimensionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Associative_dimensionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Associative_dimensionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterAssociative_dimension(s)
	}
}

func (s *Associative_dimensionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitAssociative_dimension(s)
	}
}

func (p *SystemVerilogParser) Associative_dimension() (localctx IAssociative_dimensionContext) {
	this := p
	_ = this

	localctx = NewAssociative_dimensionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 348, SystemVerilogParserRULE_associative_dimension)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3533)
		p.Match(SystemVerilogParserLB)
	}
	p.SetState(3536)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserDUNIT, SystemVerilogParserKBIT, SystemVerilogParserKBYTE, SystemVerilogParserKCHANDLE, SystemVerilogParserKENUM, SystemVerilogParserKEVENT, SystemVerilogParserKINT, SystemVerilogParserKINTEGER, SystemVerilogParserKLOGIC, SystemVerilogParserKLONGINT, SystemVerilogParserKREAL, SystemVerilogParserKREALTIME, SystemVerilogParserKREG, SystemVerilogParserKSHORTINT, SystemVerilogParserKSHORTREAL, SystemVerilogParserKSTRING, SystemVerilogParserKSTRUCT, SystemVerilogParserKTIME, SystemVerilogParserKTYPE, SystemVerilogParserKUNION, SystemVerilogParserKVIRTUAL, SystemVerilogParserSIMPLE_IDENTIFIER:
		{
			p.SetState(3534)
			p.Data_type()
		}

	case SystemVerilogParserSTAR:
		{
			p.SetState(3535)
			p.Match(SystemVerilogParserSTAR)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(3538)
		p.Match(SystemVerilogParserRB)
	}

	return localctx
}

// IVariable_dimensionContext is an interface to support dynamic dispatch.
type IVariable_dimensionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariable_dimensionContext differentiates from other interfaces.
	IsVariable_dimensionContext()
}

type Variable_dimensionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariable_dimensionContext() *Variable_dimensionContext {
	var p = new(Variable_dimensionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_variable_dimension
	return p
}

func (*Variable_dimensionContext) IsVariable_dimensionContext() {}

func NewVariable_dimensionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Variable_dimensionContext {
	var p = new(Variable_dimensionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_variable_dimension

	return p
}

func (s *Variable_dimensionContext) GetParser() antlr.Parser { return s.parser }

func (s *Variable_dimensionContext) Unsized_dimension() IUnsized_dimensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnsized_dimensionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnsized_dimensionContext)
}

func (s *Variable_dimensionContext) Unpacked_dimension() IUnpacked_dimensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnpacked_dimensionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnpacked_dimensionContext)
}

func (s *Variable_dimensionContext) Associative_dimension() IAssociative_dimensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssociative_dimensionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssociative_dimensionContext)
}

func (s *Variable_dimensionContext) Queue_dimension() IQueue_dimensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueue_dimensionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueue_dimensionContext)
}

func (s *Variable_dimensionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Variable_dimensionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Variable_dimensionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterVariable_dimension(s)
	}
}

func (s *Variable_dimensionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitVariable_dimension(s)
	}
}

func (p *SystemVerilogParser) Variable_dimension() (localctx IVariable_dimensionContext) {
	this := p
	_ = this

	localctx = NewVariable_dimensionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 350, SystemVerilogParserRULE_variable_dimension)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3544)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 374, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3540)
			p.Unsized_dimension()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3541)
			p.Unpacked_dimension()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3542)
			p.Associative_dimension()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3543)
			p.Queue_dimension()
		}

	}

	return localctx
}

// IQueue_dimensionContext is an interface to support dynamic dispatch.
type IQueue_dimensionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQueue_dimensionContext differentiates from other interfaces.
	IsQueue_dimensionContext()
}

type Queue_dimensionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueue_dimensionContext() *Queue_dimensionContext {
	var p = new(Queue_dimensionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_queue_dimension
	return p
}

func (*Queue_dimensionContext) IsQueue_dimensionContext() {}

func NewQueue_dimensionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Queue_dimensionContext {
	var p = new(Queue_dimensionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_queue_dimension

	return p
}

func (s *Queue_dimensionContext) GetParser() antlr.Parser { return s.parser }

func (s *Queue_dimensionContext) LB() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLB, 0)
}

func (s *Queue_dimensionContext) DOLLAR() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserDOLLAR, 0)
}

func (s *Queue_dimensionContext) RB() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRB, 0)
}

func (s *Queue_dimensionContext) COLON() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOLON, 0)
}

func (s *Queue_dimensionContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Queue_dimensionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Queue_dimensionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Queue_dimensionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterQueue_dimension(s)
	}
}

func (s *Queue_dimensionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitQueue_dimension(s)
	}
}

func (p *SystemVerilogParser) Queue_dimension() (localctx IQueue_dimensionContext) {
	this := p
	_ = this

	localctx = NewQueue_dimensionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 352, SystemVerilogParserRULE_queue_dimension)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3546)
		p.Match(SystemVerilogParserLB)
	}
	{
		p.SetState(3547)
		p.Match(SystemVerilogParserDOLLAR)
	}
	p.SetState(3550)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserCOLON {
		{
			p.SetState(3548)
			p.Match(SystemVerilogParserCOLON)
		}
		{
			p.SetState(3549)
			p.constant_expression(0)
		}

	}
	{
		p.SetState(3552)
		p.Match(SystemVerilogParserRB)
	}

	return localctx
}

// IUnsized_dimensionContext is an interface to support dynamic dispatch.
type IUnsized_dimensionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnsized_dimensionContext differentiates from other interfaces.
	IsUnsized_dimensionContext()
}

type Unsized_dimensionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsized_dimensionContext() *Unsized_dimensionContext {
	var p = new(Unsized_dimensionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_unsized_dimension
	return p
}

func (*Unsized_dimensionContext) IsUnsized_dimensionContext() {}

func NewUnsized_dimensionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unsized_dimensionContext {
	var p = new(Unsized_dimensionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_unsized_dimension

	return p
}

func (s *Unsized_dimensionContext) GetParser() antlr.Parser { return s.parser }

func (s *Unsized_dimensionContext) LB() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLB, 0)
}

func (s *Unsized_dimensionContext) RB() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRB, 0)
}

func (s *Unsized_dimensionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unsized_dimensionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Unsized_dimensionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterUnsized_dimension(s)
	}
}

func (s *Unsized_dimensionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitUnsized_dimension(s)
	}
}

func (p *SystemVerilogParser) Unsized_dimension() (localctx IUnsized_dimensionContext) {
	this := p
	_ = this

	localctx = NewUnsized_dimensionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 354, SystemVerilogParserRULE_unsized_dimension)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3554)
		p.Match(SystemVerilogParserLB)
	}
	{
		p.SetState(3555)
		p.Match(SystemVerilogParserRB)
	}

	return localctx
}

// IFunction_data_type_or_implicitContext is an interface to support dynamic dispatch.
type IFunction_data_type_or_implicitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_data_type_or_implicitContext differentiates from other interfaces.
	IsFunction_data_type_or_implicitContext()
}

type Function_data_type_or_implicitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_data_type_or_implicitContext() *Function_data_type_or_implicitContext {
	var p = new(Function_data_type_or_implicitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_function_data_type_or_implicit
	return p
}

func (*Function_data_type_or_implicitContext) IsFunction_data_type_or_implicitContext() {}

func NewFunction_data_type_or_implicitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_data_type_or_implicitContext {
	var p = new(Function_data_type_or_implicitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_function_data_type_or_implicit

	return p
}

func (s *Function_data_type_or_implicitContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_data_type_or_implicitContext) Data_type_or_void() IData_type_or_voidContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IData_type_or_voidContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IData_type_or_voidContext)
}

func (s *Function_data_type_or_implicitContext) Implicit_data_type() IImplicit_data_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImplicit_data_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImplicit_data_typeContext)
}

func (s *Function_data_type_or_implicitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_data_type_or_implicitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_data_type_or_implicitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterFunction_data_type_or_implicit(s)
	}
}

func (s *Function_data_type_or_implicitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitFunction_data_type_or_implicit(s)
	}
}

func (p *SystemVerilogParser) Function_data_type_or_implicit() (localctx IFunction_data_type_or_implicitContext) {
	this := p
	_ = this

	localctx = NewFunction_data_type_or_implicitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 356, SystemVerilogParserRULE_function_data_type_or_implicit)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3559)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 376, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3557)
			p.Data_type_or_void()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3558)
			p.Implicit_data_type()
		}

	}

	return localctx
}

// IFunction_declarationContext is an interface to support dynamic dispatch.
type IFunction_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_declarationContext differentiates from other interfaces.
	IsFunction_declarationContext()
}

type Function_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_declarationContext() *Function_declarationContext {
	var p = new(Function_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_function_declaration
	return p
}

func (*Function_declarationContext) IsFunction_declarationContext() {}

func NewFunction_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_declarationContext {
	var p = new(Function_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_function_declaration

	return p
}

func (s *Function_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_declarationContext) KFUNCTION() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKFUNCTION, 0)
}

func (s *Function_declarationContext) Function_body_declaration() IFunction_body_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_body_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_body_declarationContext)
}

func (s *Function_declarationContext) Lifetime() ILifetimeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILifetimeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILifetimeContext)
}

func (s *Function_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterFunction_declaration(s)
	}
}

func (s *Function_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitFunction_declaration(s)
	}
}

func (p *SystemVerilogParser) Function_declaration() (localctx IFunction_declarationContext) {
	this := p
	_ = this

	localctx = NewFunction_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 358, SystemVerilogParserRULE_function_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3561)
		p.Match(SystemVerilogParserKFUNCTION)
	}
	p.SetState(3563)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserKAUTOMATIC || _la == SystemVerilogParserKSTATIC {
		{
			p.SetState(3562)
			p.Lifetime()
		}

	}
	{
		p.SetState(3565)
		p.Function_body_declaration()
	}

	return localctx
}

// IFunction_body_declarationContext is an interface to support dynamic dispatch.
type IFunction_body_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_body_declarationContext differentiates from other interfaces.
	IsFunction_body_declarationContext()
}

type Function_body_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_body_declarationContext() *Function_body_declarationContext {
	var p = new(Function_body_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_function_body_declaration
	return p
}

func (*Function_body_declarationContext) IsFunction_body_declarationContext() {}

func NewFunction_body_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_body_declarationContext {
	var p = new(Function_body_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_function_body_declaration

	return p
}

func (s *Function_body_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_body_declarationContext) Function_data_type_or_implicit() IFunction_data_type_or_implicitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_data_type_or_implicitContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_data_type_or_implicitContext)
}

func (s *Function_body_declarationContext) AllFunction_identifier() []IFunction_identifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFunction_identifierContext)(nil)).Elem())
	var tst = make([]IFunction_identifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFunction_identifierContext)
		}
	}

	return tst
}

func (s *Function_body_declarationContext) Function_identifier(i int) IFunction_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_identifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFunction_identifierContext)
}

func (s *Function_body_declarationContext) KENDFUNCTION() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKENDFUNCTION, 0)
}

func (s *Function_body_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Function_body_declarationContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Function_body_declarationContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Function_body_declarationContext) Interface_identifier() IInterface_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterface_identifierContext)
}

func (s *Function_body_declarationContext) DOT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserDOT, 0)
}

func (s *Function_body_declarationContext) Class_scope() IClass_scopeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_scopeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClass_scopeContext)
}

func (s *Function_body_declarationContext) AllFunction_statement_or_null() []IFunction_statement_or_nullContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFunction_statement_or_nullContext)(nil)).Elem())
	var tst = make([]IFunction_statement_or_nullContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFunction_statement_or_nullContext)
		}
	}

	return tst
}

func (s *Function_body_declarationContext) Function_statement_or_null(i int) IFunction_statement_or_nullContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_statement_or_nullContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFunction_statement_or_nullContext)
}

func (s *Function_body_declarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOLON, 0)
}

func (s *Function_body_declarationContext) AllTf_item_declaration() []ITf_item_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITf_item_declarationContext)(nil)).Elem())
	var tst = make([]ITf_item_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITf_item_declarationContext)
		}
	}

	return tst
}

func (s *Function_body_declarationContext) Tf_item_declaration(i int) ITf_item_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITf_item_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITf_item_declarationContext)
}

func (s *Function_body_declarationContext) Tf_port_list() ITf_port_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITf_port_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITf_port_listContext)
}

func (s *Function_body_declarationContext) AllBlock_item_declaration() []IBlock_item_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBlock_item_declarationContext)(nil)).Elem())
	var tst = make([]IBlock_item_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBlock_item_declarationContext)
		}
	}

	return tst
}

func (s *Function_body_declarationContext) Block_item_declaration(i int) IBlock_item_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_item_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBlock_item_declarationContext)
}

func (s *Function_body_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_body_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_body_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterFunction_body_declaration(s)
	}
}

func (s *Function_body_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitFunction_body_declaration(s)
	}
}

func (p *SystemVerilogParser) Function_body_declaration() (localctx IFunction_body_declarationContext) {
	this := p
	_ = this

	localctx = NewFunction_body_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 360, SystemVerilogParserRULE_function_body_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3567)
		p.Function_data_type_or_implicit()
	}
	p.SetState(3572)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 378, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3568)
			p.Interface_identifier()
		}
		{
			p.SetState(3569)
			p.Match(SystemVerilogParserDOT)
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 378, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(3571)
			p.Class_scope()
		}

	}
	{
		p.SetState(3574)
		p.Function_identifier()
	}
	p.SetState(3594)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserSEMI:
		{
			p.SetState(3575)
			p.Match(SystemVerilogParserSEMI)
		}
		p.SetState(3579)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 379, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(3576)
					p.Tf_item_declaration()
				}

			}
			p.SetState(3581)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 379, p.GetParserRuleContext())
		}

	case SystemVerilogParserLP:
		{
			p.SetState(3582)
			p.Match(SystemVerilogParserLP)
		}
		p.SetState(3584)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 380, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3583)
				p.Tf_port_list()
			}

		}
		{
			p.SetState(3586)
			p.Match(SystemVerilogParserRP)
		}
		{
			p.SetState(3587)
			p.Match(SystemVerilogParserSEMI)
		}
		p.SetState(3591)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 381, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(3588)
					p.Block_item_declaration()
				}

			}
			p.SetState(3593)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 381, p.GetParserRuleContext())
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(3599)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SystemVerilogParserMINUSMINS)|(1<<SystemVerilogParserP)|(1<<SystemVerilogParserPP)|(1<<SystemVerilogParserDOLLAR)|(1<<SystemVerilogParserDERROR)|(1<<SystemVerilogParserDFATAL)|(1<<SystemVerilogParserDINFO)|(1<<SystemVerilogParserDROOT)|(1<<SystemVerilogParserDUNIT)|(1<<SystemVerilogParserDWARNING)|(1<<SystemVerilogParserLP)|(1<<SystemVerilogParserLPS))) != 0) || (((_la-46)&-(0x1f+1)) == 0 && ((1<<uint((_la-46)))&((1<<(SystemVerilogParserSEMI-46))|(1<<(SystemVerilogParserAT-46))|(1<<(SystemVerilogParserQUOTE-46))|(1<<(SystemVerilogParserLC-46))|(1<<(SystemVerilogParserPLUSPLUS-46)))) != 0) || (((_la-85)&-(0x1f+1)) == 0 && ((1<<uint((_la-85)))&((1<<(SystemVerilogParserARROW-85))|(1<<(SystemVerilogParserMINUSGTGT-85))|(1<<(SystemVerilogParserKASSERT-85))|(1<<(SystemVerilogParserKASSIGN-85))|(1<<(SystemVerilogParserKASSUME-85))|(1<<(SystemVerilogParserKBEGIN-85))|(1<<(SystemVerilogParserKBREAK-85))|(1<<(SystemVerilogParserKBYTE-85))|(1<<(SystemVerilogParserKCASE-85))|(1<<(SystemVerilogParserKCASEX-85)))) != 0) || (((_la-117)&-(0x1f+1)) == 0 && ((1<<uint((_la-117)))&((1<<(SystemVerilogParserKCASEZ-117))|(1<<(SystemVerilogParserKCONTINUE-117))|(1<<(SystemVerilogParserKCOVER-117))|(1<<(SystemVerilogParserKDEASSIGN-117))|(1<<(SystemVerilogParserKDISABLE-117))|(1<<(SystemVerilogParserKDO-117)))) != 0) || (((_la-162)&-(0x1f+1)) == 0 && ((1<<uint((_la-162)))&((1<<(SystemVerilogParserKEXPECT-162))|(1<<(SystemVerilogParserKFOR-162))|(1<<(SystemVerilogParserKFORCE-162))|(1<<(SystemVerilogParserKFOREACH-162))|(1<<(SystemVerilogParserKFOREVER-162))|(1<<(SystemVerilogParserKFORK-162))|(1<<(SystemVerilogParserKIF-162)))) != 0) || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SystemVerilogParserKINT-195))|(1<<(SystemVerilogParserKINTEGER-195))|(1<<(SystemVerilogParserKLOCAL-195))|(1<<(SystemVerilogParserKLONGINT-195)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(SystemVerilogParserKNULL-228))|(1<<(SystemVerilogParserKPRIORITY-228))|(1<<(SystemVerilogParserKRANDCASE-228))|(1<<(SystemVerilogParserKRANDOMIZE-228))|(1<<(SystemVerilogParserKRANDSEQUENCE-228)))) != 0) || (((_la-260)&-(0x1f+1)) == 0 && ((1<<uint((_la-260)))&((1<<(SystemVerilogParserKRELEASE-260))|(1<<(SystemVerilogParserKREPEAT-260))|(1<<(SystemVerilogParserKRESTRICT-260))|(1<<(SystemVerilogParserKRETURN-260))|(1<<(SystemVerilogParserKSHORTINT-260))|(1<<(SystemVerilogParserKSTD-260)))) != 0) || (((_la-292)&-(0x1f+1)) == 0 && ((1<<uint((_la-292)))&((1<<(SystemVerilogParserKSUPER-292))|(1<<(SystemVerilogParserKTHIS-292))|(1<<(SystemVerilogParserKTIME-292))|(1<<(SystemVerilogParserKTYPE-292))|(1<<(SystemVerilogParserKUNIQUE-292))|(1<<(SystemVerilogParserKUNIQUE0-292)))) != 0) || (((_la-328)&-(0x1f+1)) == 0 && ((1<<uint((_la-328)))&((1<<(SystemVerilogParserKVOID-328))|(1<<(SystemVerilogParserKWAIT-328))|(1<<(SystemVerilogParserKWAIT_ORDER-328))|(1<<(SystemVerilogParserKWHILE-328))|(1<<(SystemVerilogParserTIME_LITERAL-328))|(1<<(SystemVerilogParserDECIMAL_NUMBER-328))|(1<<(SystemVerilogParserBINARY_NUMBER-328))|(1<<(SystemVerilogParserOCTAL_NUMBER-328))|(1<<(SystemVerilogParserHEX_NUMBER-328))|(1<<(SystemVerilogParserREAL_NUMBER-328))|(1<<(SystemVerilogParserUNSIGNED_NUMBER-328))|(1<<(SystemVerilogParserSTRING_LITERAL-328))|(1<<(SystemVerilogParserSIMPLE_IDENTIFIER-328))|(1<<(SystemVerilogParserSYSTEM_TF_IDENTIFIER-328)))) != 0) {
		{
			p.SetState(3596)
			p.Function_statement_or_null()
		}

		p.SetState(3601)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3602)
		p.Match(SystemVerilogParserKENDFUNCTION)
	}
	p.SetState(3605)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserCOLON {
		{
			p.SetState(3603)
			p.Match(SystemVerilogParserCOLON)
		}
		{
			p.SetState(3604)
			p.Function_identifier()
		}

	}

	return localctx
}

// IFunction_prototypeContext is an interface to support dynamic dispatch.
type IFunction_prototypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_prototypeContext differentiates from other interfaces.
	IsFunction_prototypeContext()
}

type Function_prototypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_prototypeContext() *Function_prototypeContext {
	var p = new(Function_prototypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_function_prototype
	return p
}

func (*Function_prototypeContext) IsFunction_prototypeContext() {}

func NewFunction_prototypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_prototypeContext {
	var p = new(Function_prototypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_function_prototype

	return p
}

func (s *Function_prototypeContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_prototypeContext) KFUNCTION() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKFUNCTION, 0)
}

func (s *Function_prototypeContext) Data_type_or_void() IData_type_or_voidContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IData_type_or_voidContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IData_type_or_voidContext)
}

func (s *Function_prototypeContext) Function_identifier() IFunction_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_identifierContext)
}

func (s *Function_prototypeContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Function_prototypeContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Function_prototypeContext) Tf_port_list() ITf_port_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITf_port_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITf_port_listContext)
}

func (s *Function_prototypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_prototypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_prototypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterFunction_prototype(s)
	}
}

func (s *Function_prototypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitFunction_prototype(s)
	}
}

func (p *SystemVerilogParser) Function_prototype() (localctx IFunction_prototypeContext) {
	this := p
	_ = this

	localctx = NewFunction_prototypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 362, SystemVerilogParserRULE_function_prototype)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3607)
		p.Match(SystemVerilogParserKFUNCTION)
	}
	{
		p.SetState(3608)
		p.Data_type_or_void()
	}
	{
		p.SetState(3609)
		p.Function_identifier()
	}
	p.SetState(3615)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserLP {
		{
			p.SetState(3610)
			p.Match(SystemVerilogParserLP)
		}
		p.SetState(3612)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 385, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3611)
				p.Tf_port_list()
			}

		}
		{
			p.SetState(3614)
			p.Match(SystemVerilogParserRP)
		}

	}

	return localctx
}

// IDpi_import_exportContext is an interface to support dynamic dispatch.
type IDpi_import_exportContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDpi_import_exportContext differentiates from other interfaces.
	IsDpi_import_exportContext()
}

type Dpi_import_exportContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDpi_import_exportContext() *Dpi_import_exportContext {
	var p = new(Dpi_import_exportContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_dpi_import_export
	return p
}

func (*Dpi_import_exportContext) IsDpi_import_exportContext() {}

func NewDpi_import_exportContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dpi_import_exportContext {
	var p = new(Dpi_import_exportContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_dpi_import_export

	return p
}

func (s *Dpi_import_exportContext) GetParser() antlr.Parser { return s.parser }

func (s *Dpi_import_exportContext) KIMPORT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKIMPORT, 0)
}

func (s *Dpi_import_exportContext) Dpi_spec_string() IDpi_spec_stringContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDpi_spec_stringContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDpi_spec_stringContext)
}

func (s *Dpi_import_exportContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Dpi_import_exportContext) Dpi_function_proto() IDpi_function_protoContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDpi_function_protoContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDpi_function_protoContext)
}

func (s *Dpi_import_exportContext) Dpi_task_proto() IDpi_task_protoContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDpi_task_protoContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDpi_task_protoContext)
}

func (s *Dpi_import_exportContext) Dpi_function_import_property() IDpi_function_import_propertyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDpi_function_import_propertyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDpi_function_import_propertyContext)
}

func (s *Dpi_import_exportContext) C_identifier() IC_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IC_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IC_identifierContext)
}

func (s *Dpi_import_exportContext) EQ() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserEQ, 0)
}

func (s *Dpi_import_exportContext) Dpi_task_import_property() IDpi_task_import_propertyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDpi_task_import_propertyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDpi_task_import_propertyContext)
}

func (s *Dpi_import_exportContext) KEXPORT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKEXPORT, 0)
}

func (s *Dpi_import_exportContext) KFUNCTION() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKFUNCTION, 0)
}

func (s *Dpi_import_exportContext) Function_identifier() IFunction_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_identifierContext)
}

func (s *Dpi_import_exportContext) KTASK() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKTASK, 0)
}

func (s *Dpi_import_exportContext) Task_identifier() ITask_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITask_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITask_identifierContext)
}

func (s *Dpi_import_exportContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dpi_import_exportContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dpi_import_exportContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterDpi_import_export(s)
	}
}

func (s *Dpi_import_exportContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitDpi_import_export(s)
	}
}

func (p *SystemVerilogParser) Dpi_import_export() (localctx IDpi_import_exportContext) {
	this := p
	_ = this

	localctx = NewDpi_import_exportContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 364, SystemVerilogParserRULE_dpi_import_export)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3656)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserKIMPORT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3617)
			p.Match(SystemVerilogParserKIMPORT)
		}
		{
			p.SetState(3618)
			p.Dpi_spec_string()
		}
		p.SetState(3637)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 391, p.GetParserRuleContext()) {
		case 1:
			p.SetState(3620)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == SystemVerilogParserKCONTEXT || _la == SystemVerilogParserKPURE {
				{
					p.SetState(3619)
					p.Dpi_function_import_property()
				}

			}
			p.SetState(3625)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == SystemVerilogParserSIMPLE_IDENTIFIER {
				{
					p.SetState(3622)
					p.C_identifier()
				}
				{
					p.SetState(3623)
					p.Match(SystemVerilogParserEQ)
				}

			}
			{
				p.SetState(3627)
				p.Dpi_function_proto()
			}

		case 2:
			p.SetState(3629)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == SystemVerilogParserKCONTEXT {
				{
					p.SetState(3628)
					p.Dpi_task_import_property()
				}

			}
			p.SetState(3634)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == SystemVerilogParserSIMPLE_IDENTIFIER {
				{
					p.SetState(3631)
					p.C_identifier()
				}
				{
					p.SetState(3632)
					p.Match(SystemVerilogParserEQ)
				}

			}
			{
				p.SetState(3636)
				p.Dpi_task_proto()
			}

		}
		{
			p.SetState(3639)
			p.Match(SystemVerilogParserSEMI)
		}

	case SystemVerilogParserKEXPORT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3641)
			p.Match(SystemVerilogParserKEXPORT)
		}
		{
			p.SetState(3642)
			p.Dpi_spec_string()
		}
		p.SetState(3646)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserSIMPLE_IDENTIFIER {
			{
				p.SetState(3643)
				p.C_identifier()
			}
			{
				p.SetState(3644)
				p.Match(SystemVerilogParserEQ)
			}

		}
		p.SetState(3652)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SystemVerilogParserKFUNCTION:
			{
				p.SetState(3648)
				p.Match(SystemVerilogParserKFUNCTION)
			}
			{
				p.SetState(3649)
				p.Function_identifier()
			}

		case SystemVerilogParserKTASK:
			{
				p.SetState(3650)
				p.Match(SystemVerilogParserKTASK)
			}
			{
				p.SetState(3651)
				p.Task_identifier()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(3654)
			p.Match(SystemVerilogParserSEMI)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDpi_spec_stringContext is an interface to support dynamic dispatch.
type IDpi_spec_stringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDpi_spec_stringContext differentiates from other interfaces.
	IsDpi_spec_stringContext()
}

type Dpi_spec_stringContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDpi_spec_stringContext() *Dpi_spec_stringContext {
	var p = new(Dpi_spec_stringContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_dpi_spec_string
	return p
}

func (*Dpi_spec_stringContext) IsDpi_spec_stringContext() {}

func NewDpi_spec_stringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dpi_spec_stringContext {
	var p = new(Dpi_spec_stringContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_dpi_spec_string

	return p
}

func (s *Dpi_spec_stringContext) GetParser() antlr.Parser { return s.parser }

func (s *Dpi_spec_stringContext) DPIC() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserDPIC, 0)
}

func (s *Dpi_spec_stringContext) DPI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserDPI, 0)
}

func (s *Dpi_spec_stringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dpi_spec_stringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dpi_spec_stringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterDpi_spec_string(s)
	}
}

func (s *Dpi_spec_stringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitDpi_spec_string(s)
	}
}

func (p *SystemVerilogParser) Dpi_spec_string() (localctx IDpi_spec_stringContext) {
	this := p
	_ = this

	localctx = NewDpi_spec_stringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 366, SystemVerilogParserRULE_dpi_spec_string)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3658)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SystemVerilogParserDPI || _la == SystemVerilogParserDPIC) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IDpi_function_import_propertyContext is an interface to support dynamic dispatch.
type IDpi_function_import_propertyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDpi_function_import_propertyContext differentiates from other interfaces.
	IsDpi_function_import_propertyContext()
}

type Dpi_function_import_propertyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDpi_function_import_propertyContext() *Dpi_function_import_propertyContext {
	var p = new(Dpi_function_import_propertyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_dpi_function_import_property
	return p
}

func (*Dpi_function_import_propertyContext) IsDpi_function_import_propertyContext() {}

func NewDpi_function_import_propertyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dpi_function_import_propertyContext {
	var p = new(Dpi_function_import_propertyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_dpi_function_import_property

	return p
}

func (s *Dpi_function_import_propertyContext) GetParser() antlr.Parser { return s.parser }

func (s *Dpi_function_import_propertyContext) KCONTEXT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKCONTEXT, 0)
}

func (s *Dpi_function_import_propertyContext) KPURE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKPURE, 0)
}

func (s *Dpi_function_import_propertyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dpi_function_import_propertyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dpi_function_import_propertyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterDpi_function_import_property(s)
	}
}

func (s *Dpi_function_import_propertyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitDpi_function_import_property(s)
	}
}

func (p *SystemVerilogParser) Dpi_function_import_property() (localctx IDpi_function_import_propertyContext) {
	this := p
	_ = this

	localctx = NewDpi_function_import_propertyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 368, SystemVerilogParserRULE_dpi_function_import_property)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3660)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SystemVerilogParserKCONTEXT || _la == SystemVerilogParserKPURE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IDpi_task_import_propertyContext is an interface to support dynamic dispatch.
type IDpi_task_import_propertyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDpi_task_import_propertyContext differentiates from other interfaces.
	IsDpi_task_import_propertyContext()
}

type Dpi_task_import_propertyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDpi_task_import_propertyContext() *Dpi_task_import_propertyContext {
	var p = new(Dpi_task_import_propertyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_dpi_task_import_property
	return p
}

func (*Dpi_task_import_propertyContext) IsDpi_task_import_propertyContext() {}

func NewDpi_task_import_propertyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dpi_task_import_propertyContext {
	var p = new(Dpi_task_import_propertyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_dpi_task_import_property

	return p
}

func (s *Dpi_task_import_propertyContext) GetParser() antlr.Parser { return s.parser }

func (s *Dpi_task_import_propertyContext) KCONTEXT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKCONTEXT, 0)
}

func (s *Dpi_task_import_propertyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dpi_task_import_propertyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dpi_task_import_propertyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterDpi_task_import_property(s)
	}
}

func (s *Dpi_task_import_propertyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitDpi_task_import_property(s)
	}
}

func (p *SystemVerilogParser) Dpi_task_import_property() (localctx IDpi_task_import_propertyContext) {
	this := p
	_ = this

	localctx = NewDpi_task_import_propertyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 370, SystemVerilogParserRULE_dpi_task_import_property)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3662)
		p.Match(SystemVerilogParserKCONTEXT)
	}

	return localctx
}

// IDpi_function_protoContext is an interface to support dynamic dispatch.
type IDpi_function_protoContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDpi_function_protoContext differentiates from other interfaces.
	IsDpi_function_protoContext()
}

type Dpi_function_protoContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDpi_function_protoContext() *Dpi_function_protoContext {
	var p = new(Dpi_function_protoContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_dpi_function_proto
	return p
}

func (*Dpi_function_protoContext) IsDpi_function_protoContext() {}

func NewDpi_function_protoContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dpi_function_protoContext {
	var p = new(Dpi_function_protoContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_dpi_function_proto

	return p
}

func (s *Dpi_function_protoContext) GetParser() antlr.Parser { return s.parser }

func (s *Dpi_function_protoContext) Function_prototype() IFunction_prototypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_prototypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_prototypeContext)
}

func (s *Dpi_function_protoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dpi_function_protoContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dpi_function_protoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterDpi_function_proto(s)
	}
}

func (s *Dpi_function_protoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitDpi_function_proto(s)
	}
}

func (p *SystemVerilogParser) Dpi_function_proto() (localctx IDpi_function_protoContext) {
	this := p
	_ = this

	localctx = NewDpi_function_protoContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 372, SystemVerilogParserRULE_dpi_function_proto)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3664)
		p.Function_prototype()
	}

	return localctx
}

// IDpi_task_protoContext is an interface to support dynamic dispatch.
type IDpi_task_protoContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDpi_task_protoContext differentiates from other interfaces.
	IsDpi_task_protoContext()
}

type Dpi_task_protoContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDpi_task_protoContext() *Dpi_task_protoContext {
	var p = new(Dpi_task_protoContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_dpi_task_proto
	return p
}

func (*Dpi_task_protoContext) IsDpi_task_protoContext() {}

func NewDpi_task_protoContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dpi_task_protoContext {
	var p = new(Dpi_task_protoContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_dpi_task_proto

	return p
}

func (s *Dpi_task_protoContext) GetParser() antlr.Parser { return s.parser }

func (s *Dpi_task_protoContext) Task_prototype() ITask_prototypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITask_prototypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITask_prototypeContext)
}

func (s *Dpi_task_protoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dpi_task_protoContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dpi_task_protoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterDpi_task_proto(s)
	}
}

func (s *Dpi_task_protoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitDpi_task_proto(s)
	}
}

func (p *SystemVerilogParser) Dpi_task_proto() (localctx IDpi_task_protoContext) {
	this := p
	_ = this

	localctx = NewDpi_task_protoContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 374, SystemVerilogParserRULE_dpi_task_proto)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3666)
		p.Task_prototype()
	}

	return localctx
}

// ITask_declarationContext is an interface to support dynamic dispatch.
type ITask_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTask_declarationContext differentiates from other interfaces.
	IsTask_declarationContext()
}

type Task_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTask_declarationContext() *Task_declarationContext {
	var p = new(Task_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_task_declaration
	return p
}

func (*Task_declarationContext) IsTask_declarationContext() {}

func NewTask_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Task_declarationContext {
	var p = new(Task_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_task_declaration

	return p
}

func (s *Task_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Task_declarationContext) KTASK() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKTASK, 0)
}

func (s *Task_declarationContext) Task_body_declaration() ITask_body_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITask_body_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITask_body_declarationContext)
}

func (s *Task_declarationContext) Lifetime() ILifetimeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILifetimeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILifetimeContext)
}

func (s *Task_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Task_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Task_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterTask_declaration(s)
	}
}

func (s *Task_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitTask_declaration(s)
	}
}

func (p *SystemVerilogParser) Task_declaration() (localctx ITask_declarationContext) {
	this := p
	_ = this

	localctx = NewTask_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 376, SystemVerilogParserRULE_task_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3668)
		p.Match(SystemVerilogParserKTASK)
	}
	p.SetState(3670)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserKAUTOMATIC || _la == SystemVerilogParserKSTATIC {
		{
			p.SetState(3669)
			p.Lifetime()
		}

	}
	{
		p.SetState(3672)
		p.Task_body_declaration()
	}

	return localctx
}

// ITask_body_declarationContext is an interface to support dynamic dispatch.
type ITask_body_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTask_body_declarationContext differentiates from other interfaces.
	IsTask_body_declarationContext()
}

type Task_body_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTask_body_declarationContext() *Task_body_declarationContext {
	var p = new(Task_body_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_task_body_declaration
	return p
}

func (*Task_body_declarationContext) IsTask_body_declarationContext() {}

func NewTask_body_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Task_body_declarationContext {
	var p = new(Task_body_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_task_body_declaration

	return p
}

func (s *Task_body_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Task_body_declarationContext) AllTask_identifier() []ITask_identifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITask_identifierContext)(nil)).Elem())
	var tst = make([]ITask_identifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITask_identifierContext)
		}
	}

	return tst
}

func (s *Task_body_declarationContext) Task_identifier(i int) ITask_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITask_identifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITask_identifierContext)
}

func (s *Task_body_declarationContext) KENDTASK() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKENDTASK, 0)
}

func (s *Task_body_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Task_body_declarationContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Task_body_declarationContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Task_body_declarationContext) Interface_identifier() IInterface_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterface_identifierContext)
}

func (s *Task_body_declarationContext) DOT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserDOT, 0)
}

func (s *Task_body_declarationContext) Class_scope() IClass_scopeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_scopeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClass_scopeContext)
}

func (s *Task_body_declarationContext) AllStatement_or_null() []IStatement_or_nullContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatement_or_nullContext)(nil)).Elem())
	var tst = make([]IStatement_or_nullContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatement_or_nullContext)
		}
	}

	return tst
}

func (s *Task_body_declarationContext) Statement_or_null(i int) IStatement_or_nullContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatement_or_nullContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatement_or_nullContext)
}

func (s *Task_body_declarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOLON, 0)
}

func (s *Task_body_declarationContext) AllTf_item_declaration() []ITf_item_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITf_item_declarationContext)(nil)).Elem())
	var tst = make([]ITf_item_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITf_item_declarationContext)
		}
	}

	return tst
}

func (s *Task_body_declarationContext) Tf_item_declaration(i int) ITf_item_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITf_item_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITf_item_declarationContext)
}

func (s *Task_body_declarationContext) Tf_port_list() ITf_port_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITf_port_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITf_port_listContext)
}

func (s *Task_body_declarationContext) AllBlock_item_declaration() []IBlock_item_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBlock_item_declarationContext)(nil)).Elem())
	var tst = make([]IBlock_item_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBlock_item_declarationContext)
		}
	}

	return tst
}

func (s *Task_body_declarationContext) Block_item_declaration(i int) IBlock_item_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_item_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBlock_item_declarationContext)
}

func (s *Task_body_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Task_body_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Task_body_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterTask_body_declaration(s)
	}
}

func (s *Task_body_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitTask_body_declaration(s)
	}
}

func (p *SystemVerilogParser) Task_body_declaration() (localctx ITask_body_declarationContext) {
	this := p
	_ = this

	localctx = NewTask_body_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 378, SystemVerilogParserRULE_task_body_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3678)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 396, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3674)
			p.Interface_identifier()
		}
		{
			p.SetState(3675)
			p.Match(SystemVerilogParserDOT)
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 396, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(3677)
			p.Class_scope()
		}

	}
	{
		p.SetState(3680)
		p.Task_identifier()
	}
	p.SetState(3700)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserSEMI:
		{
			p.SetState(3681)
			p.Match(SystemVerilogParserSEMI)
		}
		p.SetState(3685)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 397, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(3682)
					p.Tf_item_declaration()
				}

			}
			p.SetState(3687)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 397, p.GetParserRuleContext())
		}

	case SystemVerilogParserLP:
		{
			p.SetState(3688)
			p.Match(SystemVerilogParserLP)
		}
		p.SetState(3690)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 398, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3689)
				p.Tf_port_list()
			}

		}
		{
			p.SetState(3692)
			p.Match(SystemVerilogParserRP)
		}
		{
			p.SetState(3693)
			p.Match(SystemVerilogParserSEMI)
		}
		p.SetState(3697)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 399, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(3694)
					p.Block_item_declaration()
				}

			}
			p.SetState(3699)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 399, p.GetParserRuleContext())
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(3705)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SystemVerilogParserMINUSMINS)|(1<<SystemVerilogParserP)|(1<<SystemVerilogParserPP)|(1<<SystemVerilogParserDOLLAR)|(1<<SystemVerilogParserDERROR)|(1<<SystemVerilogParserDFATAL)|(1<<SystemVerilogParserDINFO)|(1<<SystemVerilogParserDROOT)|(1<<SystemVerilogParserDUNIT)|(1<<SystemVerilogParserDWARNING)|(1<<SystemVerilogParserLP)|(1<<SystemVerilogParserLPS))) != 0) || (((_la-46)&-(0x1f+1)) == 0 && ((1<<uint((_la-46)))&((1<<(SystemVerilogParserSEMI-46))|(1<<(SystemVerilogParserAT-46))|(1<<(SystemVerilogParserQUOTE-46))|(1<<(SystemVerilogParserLC-46))|(1<<(SystemVerilogParserPLUSPLUS-46)))) != 0) || (((_la-85)&-(0x1f+1)) == 0 && ((1<<uint((_la-85)))&((1<<(SystemVerilogParserARROW-85))|(1<<(SystemVerilogParserMINUSGTGT-85))|(1<<(SystemVerilogParserKASSERT-85))|(1<<(SystemVerilogParserKASSIGN-85))|(1<<(SystemVerilogParserKASSUME-85))|(1<<(SystemVerilogParserKBEGIN-85))|(1<<(SystemVerilogParserKBREAK-85))|(1<<(SystemVerilogParserKBYTE-85))|(1<<(SystemVerilogParserKCASE-85))|(1<<(SystemVerilogParserKCASEX-85)))) != 0) || (((_la-117)&-(0x1f+1)) == 0 && ((1<<uint((_la-117)))&((1<<(SystemVerilogParserKCASEZ-117))|(1<<(SystemVerilogParserKCONTINUE-117))|(1<<(SystemVerilogParserKCOVER-117))|(1<<(SystemVerilogParserKDEASSIGN-117))|(1<<(SystemVerilogParserKDISABLE-117))|(1<<(SystemVerilogParserKDO-117)))) != 0) || (((_la-162)&-(0x1f+1)) == 0 && ((1<<uint((_la-162)))&((1<<(SystemVerilogParserKEXPECT-162))|(1<<(SystemVerilogParserKFOR-162))|(1<<(SystemVerilogParserKFORCE-162))|(1<<(SystemVerilogParserKFOREACH-162))|(1<<(SystemVerilogParserKFOREVER-162))|(1<<(SystemVerilogParserKFORK-162))|(1<<(SystemVerilogParserKIF-162)))) != 0) || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SystemVerilogParserKINT-195))|(1<<(SystemVerilogParserKINTEGER-195))|(1<<(SystemVerilogParserKLOCAL-195))|(1<<(SystemVerilogParserKLONGINT-195)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(SystemVerilogParserKNULL-228))|(1<<(SystemVerilogParserKPRIORITY-228))|(1<<(SystemVerilogParserKRANDCASE-228))|(1<<(SystemVerilogParserKRANDOMIZE-228))|(1<<(SystemVerilogParserKRANDSEQUENCE-228)))) != 0) || (((_la-260)&-(0x1f+1)) == 0 && ((1<<uint((_la-260)))&((1<<(SystemVerilogParserKRELEASE-260))|(1<<(SystemVerilogParserKREPEAT-260))|(1<<(SystemVerilogParserKRESTRICT-260))|(1<<(SystemVerilogParserKRETURN-260))|(1<<(SystemVerilogParserKSHORTINT-260))|(1<<(SystemVerilogParserKSTD-260)))) != 0) || (((_la-292)&-(0x1f+1)) == 0 && ((1<<uint((_la-292)))&((1<<(SystemVerilogParserKSUPER-292))|(1<<(SystemVerilogParserKTHIS-292))|(1<<(SystemVerilogParserKTIME-292))|(1<<(SystemVerilogParserKTYPE-292))|(1<<(SystemVerilogParserKUNIQUE-292))|(1<<(SystemVerilogParserKUNIQUE0-292)))) != 0) || (((_la-328)&-(0x1f+1)) == 0 && ((1<<uint((_la-328)))&((1<<(SystemVerilogParserKVOID-328))|(1<<(SystemVerilogParserKWAIT-328))|(1<<(SystemVerilogParserKWAIT_ORDER-328))|(1<<(SystemVerilogParserKWHILE-328))|(1<<(SystemVerilogParserTIME_LITERAL-328))|(1<<(SystemVerilogParserDECIMAL_NUMBER-328))|(1<<(SystemVerilogParserBINARY_NUMBER-328))|(1<<(SystemVerilogParserOCTAL_NUMBER-328))|(1<<(SystemVerilogParserHEX_NUMBER-328))|(1<<(SystemVerilogParserREAL_NUMBER-328))|(1<<(SystemVerilogParserUNSIGNED_NUMBER-328))|(1<<(SystemVerilogParserSTRING_LITERAL-328))|(1<<(SystemVerilogParserSIMPLE_IDENTIFIER-328))|(1<<(SystemVerilogParserSYSTEM_TF_IDENTIFIER-328)))) != 0) {
		{
			p.SetState(3702)
			p.Statement_or_null()
		}

		p.SetState(3707)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3708)
		p.Match(SystemVerilogParserKENDTASK)
	}
	p.SetState(3711)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserCOLON {
		{
			p.SetState(3709)
			p.Match(SystemVerilogParserCOLON)
		}
		{
			p.SetState(3710)
			p.Task_identifier()
		}

	}

	return localctx
}

// ITf_item_declarationContext is an interface to support dynamic dispatch.
type ITf_item_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTf_item_declarationContext differentiates from other interfaces.
	IsTf_item_declarationContext()
}

type Tf_item_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTf_item_declarationContext() *Tf_item_declarationContext {
	var p = new(Tf_item_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_tf_item_declaration
	return p
}

func (*Tf_item_declarationContext) IsTf_item_declarationContext() {}

func NewTf_item_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tf_item_declarationContext {
	var p = new(Tf_item_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_tf_item_declaration

	return p
}

func (s *Tf_item_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Tf_item_declarationContext) Block_item_declaration() IBlock_item_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_item_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlock_item_declarationContext)
}

func (s *Tf_item_declarationContext) Tf_port_declaration() ITf_port_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITf_port_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITf_port_declarationContext)
}

func (s *Tf_item_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tf_item_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tf_item_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterTf_item_declaration(s)
	}
}

func (s *Tf_item_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitTf_item_declaration(s)
	}
}

func (p *SystemVerilogParser) Tf_item_declaration() (localctx ITf_item_declarationContext) {
	this := p
	_ = this

	localctx = NewTf_item_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 380, SystemVerilogParserRULE_tf_item_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3715)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 403, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3713)
			p.Block_item_declaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3714)
			p.Tf_port_declaration()
		}

	}

	return localctx
}

// ITf_port_listContext is an interface to support dynamic dispatch.
type ITf_port_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTf_port_listContext differentiates from other interfaces.
	IsTf_port_listContext()
}

type Tf_port_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTf_port_listContext() *Tf_port_listContext {
	var p = new(Tf_port_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_tf_port_list
	return p
}

func (*Tf_port_listContext) IsTf_port_listContext() {}

func NewTf_port_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tf_port_listContext {
	var p = new(Tf_port_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_tf_port_list

	return p
}

func (s *Tf_port_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Tf_port_listContext) AllTf_port_item() []ITf_port_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITf_port_itemContext)(nil)).Elem())
	var tst = make([]ITf_port_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITf_port_itemContext)
		}
	}

	return tst
}

func (s *Tf_port_listContext) Tf_port_item(i int) ITf_port_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITf_port_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITf_port_itemContext)
}

func (s *Tf_port_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *Tf_port_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *Tf_port_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tf_port_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tf_port_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterTf_port_list(s)
	}
}

func (s *Tf_port_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitTf_port_list(s)
	}
}

func (p *SystemVerilogParser) Tf_port_list() (localctx ITf_port_listContext) {
	this := p
	_ = this

	localctx = NewTf_port_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 382, SystemVerilogParserRULE_tf_port_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3717)
		p.Tf_port_item()
	}
	p.SetState(3722)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserCOMMA {
		{
			p.SetState(3718)
			p.Match(SystemVerilogParserCOMMA)
		}
		{
			p.SetState(3719)
			p.Tf_port_item()
		}

		p.SetState(3724)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ITf_port_itemContext is an interface to support dynamic dispatch.
type ITf_port_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTf_port_itemContext differentiates from other interfaces.
	IsTf_port_itemContext()
}

type Tf_port_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTf_port_itemContext() *Tf_port_itemContext {
	var p = new(Tf_port_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_tf_port_item
	return p
}

func (*Tf_port_itemContext) IsTf_port_itemContext() {}

func NewTf_port_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tf_port_itemContext {
	var p = new(Tf_port_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_tf_port_item

	return p
}

func (s *Tf_port_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Tf_port_itemContext) Data_type_or_implicit() IData_type_or_implicitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IData_type_or_implicitContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IData_type_or_implicitContext)
}

func (s *Tf_port_itemContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Tf_port_itemContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Tf_port_itemContext) Tf_port_direction() ITf_port_directionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITf_port_directionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITf_port_directionContext)
}

func (s *Tf_port_itemContext) KVAR() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKVAR, 0)
}

func (s *Tf_port_itemContext) Port_identifier() IPort_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPort_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPort_identifierContext)
}

func (s *Tf_port_itemContext) AllVariable_dimension() []IVariable_dimensionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariable_dimensionContext)(nil)).Elem())
	var tst = make([]IVariable_dimensionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariable_dimensionContext)
		}
	}

	return tst
}

func (s *Tf_port_itemContext) Variable_dimension(i int) IVariable_dimensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_dimensionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariable_dimensionContext)
}

func (s *Tf_port_itemContext) EQ() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserEQ, 0)
}

func (s *Tf_port_itemContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Tf_port_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tf_port_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tf_port_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterTf_port_item(s)
	}
}

func (s *Tf_port_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitTf_port_item(s)
	}
}

func (p *SystemVerilogParser) Tf_port_item() (localctx ITf_port_itemContext) {
	this := p
	_ = this

	localctx = NewTf_port_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 384, SystemVerilogParserRULE_tf_port_item)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3728)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserLPS {
		{
			p.SetState(3725)
			p.Attribute_instance()
		}

		p.SetState(3730)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(3732)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserKCONST || _la == SystemVerilogParserKINOUT || _la == SystemVerilogParserKINPUT || _la == SystemVerilogParserKOUTPUT || _la == SystemVerilogParserKREF {
		{
			p.SetState(3731)
			p.Tf_port_direction()
		}

	}
	p.SetState(3735)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserKVAR {
		{
			p.SetState(3734)
			p.Match(SystemVerilogParserKVAR)
		}

	}
	{
		p.SetState(3737)
		p.Data_type_or_implicit()
	}
	p.SetState(3749)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserSIMPLE_IDENTIFIER {
		{
			p.SetState(3738)
			p.Port_identifier()
		}
		p.SetState(3742)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserLB {
			{
				p.SetState(3739)
				p.Variable_dimension()
			}

			p.SetState(3744)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(3747)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserEQ {
			{
				p.SetState(3745)
				p.Match(SystemVerilogParserEQ)
			}
			{
				p.SetState(3746)
				p.expression(0)
			}

		}

	}

	return localctx
}

// ITf_port_directionContext is an interface to support dynamic dispatch.
type ITf_port_directionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTf_port_directionContext differentiates from other interfaces.
	IsTf_port_directionContext()
}

type Tf_port_directionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTf_port_directionContext() *Tf_port_directionContext {
	var p = new(Tf_port_directionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_tf_port_direction
	return p
}

func (*Tf_port_directionContext) IsTf_port_directionContext() {}

func NewTf_port_directionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tf_port_directionContext {
	var p = new(Tf_port_directionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_tf_port_direction

	return p
}

func (s *Tf_port_directionContext) GetParser() antlr.Parser { return s.parser }

func (s *Tf_port_directionContext) Port_direction() IPort_directionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPort_directionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPort_directionContext)
}

func (s *Tf_port_directionContext) KCONST() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKCONST, 0)
}

func (s *Tf_port_directionContext) KREF() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKREF, 0)
}

func (s *Tf_port_directionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tf_port_directionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tf_port_directionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterTf_port_direction(s)
	}
}

func (s *Tf_port_directionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitTf_port_direction(s)
	}
}

func (p *SystemVerilogParser) Tf_port_direction() (localctx ITf_port_directionContext) {
	this := p
	_ = this

	localctx = NewTf_port_directionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 386, SystemVerilogParserRULE_tf_port_direction)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3754)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserKINOUT, SystemVerilogParserKINPUT, SystemVerilogParserKOUTPUT, SystemVerilogParserKREF:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3751)
			p.Port_direction()
		}

	case SystemVerilogParserKCONST:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3752)
			p.Match(SystemVerilogParserKCONST)
		}
		{
			p.SetState(3753)
			p.Match(SystemVerilogParserKREF)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITf_port_declarationContext is an interface to support dynamic dispatch.
type ITf_port_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTf_port_declarationContext differentiates from other interfaces.
	IsTf_port_declarationContext()
}

type Tf_port_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTf_port_declarationContext() *Tf_port_declarationContext {
	var p = new(Tf_port_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_tf_port_declaration
	return p
}

func (*Tf_port_declarationContext) IsTf_port_declarationContext() {}

func NewTf_port_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tf_port_declarationContext {
	var p = new(Tf_port_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_tf_port_declaration

	return p
}

func (s *Tf_port_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Tf_port_declarationContext) Tf_port_direction() ITf_port_directionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITf_port_directionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITf_port_directionContext)
}

func (s *Tf_port_declarationContext) Data_type_or_implicit() IData_type_or_implicitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IData_type_or_implicitContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IData_type_or_implicitContext)
}

func (s *Tf_port_declarationContext) List_of_tf_variable_identifiers() IList_of_tf_variable_identifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_tf_variable_identifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_tf_variable_identifiersContext)
}

func (s *Tf_port_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Tf_port_declarationContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Tf_port_declarationContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Tf_port_declarationContext) KVAR() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKVAR, 0)
}

func (s *Tf_port_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tf_port_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tf_port_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterTf_port_declaration(s)
	}
}

func (s *Tf_port_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitTf_port_declaration(s)
	}
}

func (p *SystemVerilogParser) Tf_port_declaration() (localctx ITf_port_declarationContext) {
	this := p
	_ = this

	localctx = NewTf_port_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 388, SystemVerilogParserRULE_tf_port_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3759)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserLPS {
		{
			p.SetState(3756)
			p.Attribute_instance()
		}

		p.SetState(3761)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3762)
		p.Tf_port_direction()
	}
	p.SetState(3764)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserKVAR {
		{
			p.SetState(3763)
			p.Match(SystemVerilogParserKVAR)
		}

	}
	{
		p.SetState(3766)
		p.Data_type_or_implicit()
	}
	{
		p.SetState(3767)
		p.List_of_tf_variable_identifiers()
	}
	{
		p.SetState(3768)
		p.Match(SystemVerilogParserSEMI)
	}

	return localctx
}

// ITask_prototypeContext is an interface to support dynamic dispatch.
type ITask_prototypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTask_prototypeContext differentiates from other interfaces.
	IsTask_prototypeContext()
}

type Task_prototypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTask_prototypeContext() *Task_prototypeContext {
	var p = new(Task_prototypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_task_prototype
	return p
}

func (*Task_prototypeContext) IsTask_prototypeContext() {}

func NewTask_prototypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Task_prototypeContext {
	var p = new(Task_prototypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_task_prototype

	return p
}

func (s *Task_prototypeContext) GetParser() antlr.Parser { return s.parser }

func (s *Task_prototypeContext) KTASK() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKTASK, 0)
}

func (s *Task_prototypeContext) Task_identifier() ITask_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITask_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITask_identifierContext)
}

func (s *Task_prototypeContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Task_prototypeContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Task_prototypeContext) Tf_port_list() ITf_port_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITf_port_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITf_port_listContext)
}

func (s *Task_prototypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Task_prototypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Task_prototypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterTask_prototype(s)
	}
}

func (s *Task_prototypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitTask_prototype(s)
	}
}

func (p *SystemVerilogParser) Task_prototype() (localctx ITask_prototypeContext) {
	this := p
	_ = this

	localctx = NewTask_prototypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 390, SystemVerilogParserRULE_task_prototype)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3770)
		p.Match(SystemVerilogParserKTASK)
	}
	{
		p.SetState(3771)
		p.Task_identifier()
	}
	p.SetState(3777)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserLP {
		{
			p.SetState(3772)
			p.Match(SystemVerilogParserLP)
		}
		p.SetState(3774)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 414, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3773)
				p.Tf_port_list()
			}

		}
		{
			p.SetState(3776)
			p.Match(SystemVerilogParserRP)
		}

	}

	return localctx
}

// IBlock_item_declarationContext is an interface to support dynamic dispatch.
type IBlock_item_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlock_item_declarationContext differentiates from other interfaces.
	IsBlock_item_declarationContext()
}

type Block_item_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlock_item_declarationContext() *Block_item_declarationContext {
	var p = new(Block_item_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_block_item_declaration
	return p
}

func (*Block_item_declarationContext) IsBlock_item_declarationContext() {}

func NewBlock_item_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Block_item_declarationContext {
	var p = new(Block_item_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_block_item_declaration

	return p
}

func (s *Block_item_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Block_item_declarationContext) Data_declaration() IData_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IData_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IData_declarationContext)
}

func (s *Block_item_declarationContext) Let_declaration() ILet_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILet_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILet_declarationContext)
}

func (s *Block_item_declarationContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Block_item_declarationContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Block_item_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Block_item_declarationContext) Local_parameter_declaration() ILocal_parameter_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILocal_parameter_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILocal_parameter_declarationContext)
}

func (s *Block_item_declarationContext) Parameter_declaration() IParameter_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_declarationContext)
}

func (s *Block_item_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Block_item_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Block_item_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterBlock_item_declaration(s)
	}
}

func (s *Block_item_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitBlock_item_declaration(s)
	}
}

func (p *SystemVerilogParser) Block_item_declaration() (localctx IBlock_item_declarationContext) {
	this := p
	_ = this

	localctx = NewBlock_item_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 392, SystemVerilogParserRULE_block_item_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3801)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 420, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(3782)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserLPS {
			{
				p.SetState(3779)
				p.Attribute_instance()
			}

			p.SetState(3784)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(3787)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SystemVerilogParserDUNIT, SystemVerilogParserLB, SystemVerilogParserKAUTOMATIC, SystemVerilogParserKBIT, SystemVerilogParserKBYTE, SystemVerilogParserKCHANDLE, SystemVerilogParserKCONST, SystemVerilogParserKENUM, SystemVerilogParserKEVENT, SystemVerilogParserKIMPORT, SystemVerilogParserKINT, SystemVerilogParserKINTEGER, SystemVerilogParserKLOGIC, SystemVerilogParserKLONGINT, SystemVerilogParserKNETTYPE, SystemVerilogParserKREAL, SystemVerilogParserKREALTIME, SystemVerilogParserKREG, SystemVerilogParserKSHORTINT, SystemVerilogParserKSHORTREAL, SystemVerilogParserKSIGNED, SystemVerilogParserKSTATIC, SystemVerilogParserKSTRING, SystemVerilogParserKSTRUCT, SystemVerilogParserKTIME, SystemVerilogParserKTYPE, SystemVerilogParserKTYPEDEF, SystemVerilogParserKUNION, SystemVerilogParserKUNSIGNED, SystemVerilogParserKVAR, SystemVerilogParserKVIRTUAL, SystemVerilogParserSIMPLE_IDENTIFIER:
			{
				p.SetState(3785)
				p.Data_declaration()
			}

		case SystemVerilogParserKLET:
			{
				p.SetState(3786)
				p.Let_declaration()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(3792)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserLPS {
			{
				p.SetState(3789)
				p.Attribute_instance()
			}

			p.SetState(3794)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(3797)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SystemVerilogParserKLOCALPARAM:
			{
				p.SetState(3795)
				p.Local_parameter_declaration()
			}

		case SystemVerilogParserKPARAMETER:
			{
				p.SetState(3796)
				p.Parameter_declaration()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(3799)
			p.Match(SystemVerilogParserSEMI)
		}

	}

	return localctx
}

// IModport_declarationContext is an interface to support dynamic dispatch.
type IModport_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModport_declarationContext differentiates from other interfaces.
	IsModport_declarationContext()
}

type Modport_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModport_declarationContext() *Modport_declarationContext {
	var p = new(Modport_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_modport_declaration
	return p
}

func (*Modport_declarationContext) IsModport_declarationContext() {}

func NewModport_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Modport_declarationContext {
	var p = new(Modport_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_modport_declaration

	return p
}

func (s *Modport_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Modport_declarationContext) KMODPORT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKMODPORT, 0)
}

func (s *Modport_declarationContext) AllModport_item() []IModport_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IModport_itemContext)(nil)).Elem())
	var tst = make([]IModport_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IModport_itemContext)
		}
	}

	return tst
}

func (s *Modport_declarationContext) Modport_item(i int) IModport_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModport_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IModport_itemContext)
}

func (s *Modport_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Modport_declarationContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *Modport_declarationContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *Modport_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Modport_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Modport_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterModport_declaration(s)
	}
}

func (s *Modport_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitModport_declaration(s)
	}
}

func (p *SystemVerilogParser) Modport_declaration() (localctx IModport_declarationContext) {
	this := p
	_ = this

	localctx = NewModport_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 394, SystemVerilogParserRULE_modport_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3803)
		p.Match(SystemVerilogParserKMODPORT)
	}
	{
		p.SetState(3804)
		p.Modport_item()
	}
	p.SetState(3809)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserCOMMA {
		{
			p.SetState(3805)
			p.Match(SystemVerilogParserCOMMA)
		}
		{
			p.SetState(3806)
			p.Modport_item()
		}

		p.SetState(3811)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3812)
		p.Match(SystemVerilogParserSEMI)
	}

	return localctx
}

// IModport_itemContext is an interface to support dynamic dispatch.
type IModport_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModport_itemContext differentiates from other interfaces.
	IsModport_itemContext()
}

type Modport_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModport_itemContext() *Modport_itemContext {
	var p = new(Modport_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_modport_item
	return p
}

func (*Modport_itemContext) IsModport_itemContext() {}

func NewModport_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Modport_itemContext {
	var p = new(Modport_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_modport_item

	return p
}

func (s *Modport_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Modport_itemContext) Modport_identifier() IModport_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModport_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModport_identifierContext)
}

func (s *Modport_itemContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Modport_itemContext) AllModport_ports_declaration() []IModport_ports_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IModport_ports_declarationContext)(nil)).Elem())
	var tst = make([]IModport_ports_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IModport_ports_declarationContext)
		}
	}

	return tst
}

func (s *Modport_itemContext) Modport_ports_declaration(i int) IModport_ports_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModport_ports_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IModport_ports_declarationContext)
}

func (s *Modport_itemContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Modport_itemContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *Modport_itemContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *Modport_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Modport_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Modport_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterModport_item(s)
	}
}

func (s *Modport_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitModport_item(s)
	}
}

func (p *SystemVerilogParser) Modport_item() (localctx IModport_itemContext) {
	this := p
	_ = this

	localctx = NewModport_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 396, SystemVerilogParserRULE_modport_item)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3814)
		p.Modport_identifier()
	}
	{
		p.SetState(3815)
		p.Match(SystemVerilogParserLP)
	}
	{
		p.SetState(3816)
		p.Modport_ports_declaration()
	}
	p.SetState(3821)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserCOMMA {
		{
			p.SetState(3817)
			p.Match(SystemVerilogParserCOMMA)
		}
		{
			p.SetState(3818)
			p.Modport_ports_declaration()
		}

		p.SetState(3823)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3824)
		p.Match(SystemVerilogParserRP)
	}

	return localctx
}

// IModport_ports_declarationContext is an interface to support dynamic dispatch.
type IModport_ports_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModport_ports_declarationContext differentiates from other interfaces.
	IsModport_ports_declarationContext()
}

type Modport_ports_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModport_ports_declarationContext() *Modport_ports_declarationContext {
	var p = new(Modport_ports_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_modport_ports_declaration
	return p
}

func (*Modport_ports_declarationContext) IsModport_ports_declarationContext() {}

func NewModport_ports_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Modport_ports_declarationContext {
	var p = new(Modport_ports_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_modport_ports_declaration

	return p
}

func (s *Modport_ports_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Modport_ports_declarationContext) Modport_simple_ports_declaration() IModport_simple_ports_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModport_simple_ports_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModport_simple_ports_declarationContext)
}

func (s *Modport_ports_declarationContext) Modport_tf_ports_declaration() IModport_tf_ports_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModport_tf_ports_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModport_tf_ports_declarationContext)
}

func (s *Modport_ports_declarationContext) Modport_clocking_declaration() IModport_clocking_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModport_clocking_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModport_clocking_declarationContext)
}

func (s *Modport_ports_declarationContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Modport_ports_declarationContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Modport_ports_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Modport_ports_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Modport_ports_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterModport_ports_declaration(s)
	}
}

func (s *Modport_ports_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitModport_ports_declaration(s)
	}
}

func (p *SystemVerilogParser) Modport_ports_declaration() (localctx IModport_ports_declarationContext) {
	this := p
	_ = this

	localctx = NewModport_ports_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 398, SystemVerilogParserRULE_modport_ports_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3829)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserLPS {
		{
			p.SetState(3826)
			p.Attribute_instance()
		}

		p.SetState(3831)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(3835)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserKINOUT, SystemVerilogParserKINPUT, SystemVerilogParserKOUTPUT, SystemVerilogParserKREF:
		{
			p.SetState(3832)
			p.Modport_simple_ports_declaration()
		}

	case SystemVerilogParserKEXPORT, SystemVerilogParserKIMPORT:
		{
			p.SetState(3833)
			p.Modport_tf_ports_declaration()
		}

	case SystemVerilogParserKCLOCKING:
		{
			p.SetState(3834)
			p.Modport_clocking_declaration()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IModport_clocking_declarationContext is an interface to support dynamic dispatch.
type IModport_clocking_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModport_clocking_declarationContext differentiates from other interfaces.
	IsModport_clocking_declarationContext()
}

type Modport_clocking_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModport_clocking_declarationContext() *Modport_clocking_declarationContext {
	var p = new(Modport_clocking_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_modport_clocking_declaration
	return p
}

func (*Modport_clocking_declarationContext) IsModport_clocking_declarationContext() {}

func NewModport_clocking_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Modport_clocking_declarationContext {
	var p = new(Modport_clocking_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_modport_clocking_declaration

	return p
}

func (s *Modport_clocking_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Modport_clocking_declarationContext) KCLOCKING() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKCLOCKING, 0)
}

func (s *Modport_clocking_declarationContext) Clocking_identifier() IClocking_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClocking_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClocking_identifierContext)
}

func (s *Modport_clocking_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Modport_clocking_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Modport_clocking_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterModport_clocking_declaration(s)
	}
}

func (s *Modport_clocking_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitModport_clocking_declaration(s)
	}
}

func (p *SystemVerilogParser) Modport_clocking_declaration() (localctx IModport_clocking_declarationContext) {
	this := p
	_ = this

	localctx = NewModport_clocking_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 400, SystemVerilogParserRULE_modport_clocking_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3837)
		p.Match(SystemVerilogParserKCLOCKING)
	}
	{
		p.SetState(3838)
		p.Clocking_identifier()
	}

	return localctx
}

// IModport_simple_ports_declarationContext is an interface to support dynamic dispatch.
type IModport_simple_ports_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModport_simple_ports_declarationContext differentiates from other interfaces.
	IsModport_simple_ports_declarationContext()
}

type Modport_simple_ports_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModport_simple_ports_declarationContext() *Modport_simple_ports_declarationContext {
	var p = new(Modport_simple_ports_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_modport_simple_ports_declaration
	return p
}

func (*Modport_simple_ports_declarationContext) IsModport_simple_ports_declarationContext() {}

func NewModport_simple_ports_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Modport_simple_ports_declarationContext {
	var p = new(Modport_simple_ports_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_modport_simple_ports_declaration

	return p
}

func (s *Modport_simple_ports_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Modport_simple_ports_declarationContext) Port_direction() IPort_directionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPort_directionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPort_directionContext)
}

func (s *Modport_simple_ports_declarationContext) AllModport_simple_port() []IModport_simple_portContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IModport_simple_portContext)(nil)).Elem())
	var tst = make([]IModport_simple_portContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IModport_simple_portContext)
		}
	}

	return tst
}

func (s *Modport_simple_ports_declarationContext) Modport_simple_port(i int) IModport_simple_portContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModport_simple_portContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IModport_simple_portContext)
}

func (s *Modport_simple_ports_declarationContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *Modport_simple_ports_declarationContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *Modport_simple_ports_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Modport_simple_ports_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Modport_simple_ports_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterModport_simple_ports_declaration(s)
	}
}

func (s *Modport_simple_ports_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitModport_simple_ports_declaration(s)
	}
}

func (p *SystemVerilogParser) Modport_simple_ports_declaration() (localctx IModport_simple_ports_declarationContext) {
	this := p
	_ = this

	localctx = NewModport_simple_ports_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 402, SystemVerilogParserRULE_modport_simple_ports_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3840)
		p.Port_direction()
	}
	{
		p.SetState(3841)
		p.Modport_simple_port()
	}
	p.SetState(3846)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 425, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3842)
				p.Match(SystemVerilogParserCOMMA)
			}
			{
				p.SetState(3843)
				p.Modport_simple_port()
			}

		}
		p.SetState(3848)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 425, p.GetParserRuleContext())
	}

	return localctx
}

// IModport_simple_portContext is an interface to support dynamic dispatch.
type IModport_simple_portContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModport_simple_portContext differentiates from other interfaces.
	IsModport_simple_portContext()
}

type Modport_simple_portContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModport_simple_portContext() *Modport_simple_portContext {
	var p = new(Modport_simple_portContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_modport_simple_port
	return p
}

func (*Modport_simple_portContext) IsModport_simple_portContext() {}

func NewModport_simple_portContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Modport_simple_portContext {
	var p = new(Modport_simple_portContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_modport_simple_port

	return p
}

func (s *Modport_simple_portContext) GetParser() antlr.Parser { return s.parser }

func (s *Modport_simple_portContext) Port_identifier() IPort_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPort_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPort_identifierContext)
}

func (s *Modport_simple_portContext) DOT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserDOT, 0)
}

func (s *Modport_simple_portContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Modport_simple_portContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Modport_simple_portContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Modport_simple_portContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Modport_simple_portContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Modport_simple_portContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterModport_simple_port(s)
	}
}

func (s *Modport_simple_portContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitModport_simple_port(s)
	}
}

func (p *SystemVerilogParser) Modport_simple_port() (localctx IModport_simple_portContext) {
	this := p
	_ = this

	localctx = NewModport_simple_portContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 404, SystemVerilogParserRULE_modport_simple_port)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3858)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserSIMPLE_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3849)
			p.Port_identifier()
		}

	case SystemVerilogParserDOT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3850)
			p.Match(SystemVerilogParserDOT)
		}
		{
			p.SetState(3851)
			p.Port_identifier()
		}
		{
			p.SetState(3852)
			p.Match(SystemVerilogParserLP)
		}
		p.SetState(3854)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SystemVerilogParserMINUS)|(1<<SystemVerilogParserMINUSMINS)|(1<<SystemVerilogParserNOT)|(1<<SystemVerilogParserDOLLAR)|(1<<SystemVerilogParserDROOT)|(1<<SystemVerilogParserDUNIT)|(1<<SystemVerilogParserAND)|(1<<SystemVerilogParserLP))) != 0) || (((_la-51)&-(0x1f+1)) == 0 && ((1<<uint((_la-51)))&((1<<(SystemVerilogParserQUOTE-51))|(1<<(SystemVerilogParserCARET-51))|(1<<(SystemVerilogParserCARETSQUIG-51))|(1<<(SystemVerilogParserLC-51))|(1<<(SystemVerilogParserBAR-51))|(1<<(SystemVerilogParserSQUIG-51))|(1<<(SystemVerilogParserSQUIGAND-51))|(1<<(SystemVerilogParserSQUIGCARET-51))|(1<<(SystemVerilogParserSQUIGBAR-51))|(1<<(SystemVerilogParserPLUS-51))|(1<<(SystemVerilogParserPLUSPLUS-51)))) != 0) || (((_la-109)&-(0x1f+1)) == 0 && ((1<<uint((_la-109)))&((1<<(SystemVerilogParserKBIT-109))|(1<<(SystemVerilogParserKBYTE-109))|(1<<(SystemVerilogParserKCONST-109)))) != 0) || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SystemVerilogParserKINT-195))|(1<<(SystemVerilogParserKINTEGER-195))|(1<<(SystemVerilogParserKLOCAL-195))|(1<<(SystemVerilogParserKLOGIC-195))|(1<<(SystemVerilogParserKLONGINT-195)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(SystemVerilogParserKNULL-228))|(1<<(SystemVerilogParserKRANDOMIZE-228))|(1<<(SystemVerilogParserKREAL-228))|(1<<(SystemVerilogParserKREALTIME-228))|(1<<(SystemVerilogParserKREG-228)))) != 0) || (((_la-276)&-(0x1f+1)) == 0 && ((1<<uint((_la-276)))&((1<<(SystemVerilogParserKSHORTINT-276))|(1<<(SystemVerilogParserKSHORTREAL-276))|(1<<(SystemVerilogParserKSIGNED-276))|(1<<(SystemVerilogParserKSTD-276))|(1<<(SystemVerilogParserKSTRING-276))|(1<<(SystemVerilogParserKSUPER-276))|(1<<(SystemVerilogParserKTAGGED-276))|(1<<(SystemVerilogParserKTHIS-276))|(1<<(SystemVerilogParserKTIME-276)))) != 0) || _la == SystemVerilogParserKTYPE || _la == SystemVerilogParserKUNSIGNED || (((_la-345)&-(0x1f+1)) == 0 && ((1<<uint((_la-345)))&((1<<(SystemVerilogParserTIME_LITERAL-345))|(1<<(SystemVerilogParserDECIMAL_NUMBER-345))|(1<<(SystemVerilogParserBINARY_NUMBER-345))|(1<<(SystemVerilogParserOCTAL_NUMBER-345))|(1<<(SystemVerilogParserHEX_NUMBER-345))|(1<<(SystemVerilogParserREAL_NUMBER-345))|(1<<(SystemVerilogParserUNSIGNED_NUMBER-345))|(1<<(SystemVerilogParserSTRING_LITERAL-345))|(1<<(SystemVerilogParserSIMPLE_IDENTIFIER-345))|(1<<(SystemVerilogParserSYSTEM_TF_IDENTIFIER-345)))) != 0) {
			{
				p.SetState(3853)
				p.expression(0)
			}

		}
		{
			p.SetState(3856)
			p.Match(SystemVerilogParserRP)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IModport_tf_ports_declarationContext is an interface to support dynamic dispatch.
type IModport_tf_ports_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModport_tf_ports_declarationContext differentiates from other interfaces.
	IsModport_tf_ports_declarationContext()
}

type Modport_tf_ports_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModport_tf_ports_declarationContext() *Modport_tf_ports_declarationContext {
	var p = new(Modport_tf_ports_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_modport_tf_ports_declaration
	return p
}

func (*Modport_tf_ports_declarationContext) IsModport_tf_ports_declarationContext() {}

func NewModport_tf_ports_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Modport_tf_ports_declarationContext {
	var p = new(Modport_tf_ports_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_modport_tf_ports_declaration

	return p
}

func (s *Modport_tf_ports_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Modport_tf_ports_declarationContext) Import_export() IImport_exportContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImport_exportContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImport_exportContext)
}

func (s *Modport_tf_ports_declarationContext) AllModport_tf_port() []IModport_tf_portContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IModport_tf_portContext)(nil)).Elem())
	var tst = make([]IModport_tf_portContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IModport_tf_portContext)
		}
	}

	return tst
}

func (s *Modport_tf_ports_declarationContext) Modport_tf_port(i int) IModport_tf_portContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModport_tf_portContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IModport_tf_portContext)
}

func (s *Modport_tf_ports_declarationContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *Modport_tf_ports_declarationContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *Modport_tf_ports_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Modport_tf_ports_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Modport_tf_ports_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterModport_tf_ports_declaration(s)
	}
}

func (s *Modport_tf_ports_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitModport_tf_ports_declaration(s)
	}
}

func (p *SystemVerilogParser) Modport_tf_ports_declaration() (localctx IModport_tf_ports_declarationContext) {
	this := p
	_ = this

	localctx = NewModport_tf_ports_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 406, SystemVerilogParserRULE_modport_tf_ports_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3860)
		p.Import_export()
	}
	{
		p.SetState(3861)
		p.Modport_tf_port()
	}
	p.SetState(3866)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 428, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3862)
				p.Match(SystemVerilogParserCOMMA)
			}
			{
				p.SetState(3863)
				p.Modport_tf_port()
			}

		}
		p.SetState(3868)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 428, p.GetParserRuleContext())
	}

	return localctx
}

// IModport_tf_portContext is an interface to support dynamic dispatch.
type IModport_tf_portContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModport_tf_portContext differentiates from other interfaces.
	IsModport_tf_portContext()
}

type Modport_tf_portContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModport_tf_portContext() *Modport_tf_portContext {
	var p = new(Modport_tf_portContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_modport_tf_port
	return p
}

func (*Modport_tf_portContext) IsModport_tf_portContext() {}

func NewModport_tf_portContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Modport_tf_portContext {
	var p = new(Modport_tf_portContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_modport_tf_port

	return p
}

func (s *Modport_tf_portContext) GetParser() antlr.Parser { return s.parser }

func (s *Modport_tf_portContext) Method_prototype() IMethod_prototypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMethod_prototypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMethod_prototypeContext)
}

func (s *Modport_tf_portContext) Tf_identifier() ITf_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITf_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITf_identifierContext)
}

func (s *Modport_tf_portContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Modport_tf_portContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Modport_tf_portContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterModport_tf_port(s)
	}
}

func (s *Modport_tf_portContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitModport_tf_port(s)
	}
}

func (p *SystemVerilogParser) Modport_tf_port() (localctx IModport_tf_portContext) {
	this := p
	_ = this

	localctx = NewModport_tf_portContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 408, SystemVerilogParserRULE_modport_tf_port)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3871)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserKFUNCTION, SystemVerilogParserKTASK:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3869)
			p.Method_prototype()
		}

	case SystemVerilogParserSIMPLE_IDENTIFIER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3870)
			p.Tf_identifier()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IImport_exportContext is an interface to support dynamic dispatch.
type IImport_exportContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImport_exportContext differentiates from other interfaces.
	IsImport_exportContext()
}

type Import_exportContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImport_exportContext() *Import_exportContext {
	var p = new(Import_exportContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_import_export
	return p
}

func (*Import_exportContext) IsImport_exportContext() {}

func NewImport_exportContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Import_exportContext {
	var p = new(Import_exportContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_import_export

	return p
}

func (s *Import_exportContext) GetParser() antlr.Parser { return s.parser }

func (s *Import_exportContext) KIMPORT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKIMPORT, 0)
}

func (s *Import_exportContext) KEXPORT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKEXPORT, 0)
}

func (s *Import_exportContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Import_exportContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Import_exportContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterImport_export(s)
	}
}

func (s *Import_exportContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitImport_export(s)
	}
}

func (p *SystemVerilogParser) Import_export() (localctx IImport_exportContext) {
	this := p
	_ = this

	localctx = NewImport_exportContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 410, SystemVerilogParserRULE_import_export)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3873)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SystemVerilogParserKEXPORT || _la == SystemVerilogParserKIMPORT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IConcurrent_assertion_itemContext is an interface to support dynamic dispatch.
type IConcurrent_assertion_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConcurrent_assertion_itemContext differentiates from other interfaces.
	IsConcurrent_assertion_itemContext()
}

type Concurrent_assertion_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConcurrent_assertion_itemContext() *Concurrent_assertion_itemContext {
	var p = new(Concurrent_assertion_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_concurrent_assertion_item
	return p
}

func (*Concurrent_assertion_itemContext) IsConcurrent_assertion_itemContext() {}

func NewConcurrent_assertion_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Concurrent_assertion_itemContext {
	var p = new(Concurrent_assertion_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_concurrent_assertion_item

	return p
}

func (s *Concurrent_assertion_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Concurrent_assertion_itemContext) Concurrent_assertion_statement() IConcurrent_assertion_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConcurrent_assertion_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConcurrent_assertion_statementContext)
}

func (s *Concurrent_assertion_itemContext) Block_identifier() IBlock_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlock_identifierContext)
}

func (s *Concurrent_assertion_itemContext) COLON() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOLON, 0)
}

func (s *Concurrent_assertion_itemContext) Checker_instantiation() IChecker_instantiationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IChecker_instantiationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IChecker_instantiationContext)
}

func (s *Concurrent_assertion_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Concurrent_assertion_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Concurrent_assertion_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterConcurrent_assertion_item(s)
	}
}

func (s *Concurrent_assertion_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitConcurrent_assertion_item(s)
	}
}

func (p *SystemVerilogParser) Concurrent_assertion_item() (localctx IConcurrent_assertion_itemContext) {
	this := p
	_ = this

	localctx = NewConcurrent_assertion_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 412, SystemVerilogParserRULE_concurrent_assertion_item)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3882)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 431, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(3878)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserSIMPLE_IDENTIFIER {
			{
				p.SetState(3875)
				p.Block_identifier()
			}
			{
				p.SetState(3876)
				p.Match(SystemVerilogParserCOLON)
			}

		}
		{
			p.SetState(3880)
			p.Concurrent_assertion_statement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3881)
			p.Checker_instantiation()
		}

	}

	return localctx
}

// IConcurrent_assertion_statementContext is an interface to support dynamic dispatch.
type IConcurrent_assertion_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConcurrent_assertion_statementContext differentiates from other interfaces.
	IsConcurrent_assertion_statementContext()
}

type Concurrent_assertion_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConcurrent_assertion_statementContext() *Concurrent_assertion_statementContext {
	var p = new(Concurrent_assertion_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_concurrent_assertion_statement
	return p
}

func (*Concurrent_assertion_statementContext) IsConcurrent_assertion_statementContext() {}

func NewConcurrent_assertion_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Concurrent_assertion_statementContext {
	var p = new(Concurrent_assertion_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_concurrent_assertion_statement

	return p
}

func (s *Concurrent_assertion_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Concurrent_assertion_statementContext) Assert_property_statement() IAssert_property_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssert_property_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssert_property_statementContext)
}

func (s *Concurrent_assertion_statementContext) Assume_property_statement() IAssume_property_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssume_property_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssume_property_statementContext)
}

func (s *Concurrent_assertion_statementContext) Cover_property_statement() ICover_property_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICover_property_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICover_property_statementContext)
}

func (s *Concurrent_assertion_statementContext) Cover_sequence_statement() ICover_sequence_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICover_sequence_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICover_sequence_statementContext)
}

func (s *Concurrent_assertion_statementContext) Restrict_property_statement() IRestrict_property_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRestrict_property_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRestrict_property_statementContext)
}

func (s *Concurrent_assertion_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Concurrent_assertion_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Concurrent_assertion_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterConcurrent_assertion_statement(s)
	}
}

func (s *Concurrent_assertion_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitConcurrent_assertion_statement(s)
	}
}

func (p *SystemVerilogParser) Concurrent_assertion_statement() (localctx IConcurrent_assertion_statementContext) {
	this := p
	_ = this

	localctx = NewConcurrent_assertion_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 414, SystemVerilogParserRULE_concurrent_assertion_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3889)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 432, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3884)
			p.Assert_property_statement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3885)
			p.Assume_property_statement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3886)
			p.Cover_property_statement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3887)
			p.Cover_sequence_statement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3888)
			p.Restrict_property_statement()
		}

	}

	return localctx
}

// IAssert_property_statementContext is an interface to support dynamic dispatch.
type IAssert_property_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssert_property_statementContext differentiates from other interfaces.
	IsAssert_property_statementContext()
}

type Assert_property_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssert_property_statementContext() *Assert_property_statementContext {
	var p = new(Assert_property_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_assert_property_statement
	return p
}

func (*Assert_property_statementContext) IsAssert_property_statementContext() {}

func NewAssert_property_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Assert_property_statementContext {
	var p = new(Assert_property_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_assert_property_statement

	return p
}

func (s *Assert_property_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Assert_property_statementContext) KASSERT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKASSERT, 0)
}

func (s *Assert_property_statementContext) KPROPERTY() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKPROPERTY, 0)
}

func (s *Assert_property_statementContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Assert_property_statementContext) Property_spec() IProperty_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProperty_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProperty_specContext)
}

func (s *Assert_property_statementContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Assert_property_statementContext) Action_block() IAction_blockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAction_blockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAction_blockContext)
}

func (s *Assert_property_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Assert_property_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Assert_property_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterAssert_property_statement(s)
	}
}

func (s *Assert_property_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitAssert_property_statement(s)
	}
}

func (p *SystemVerilogParser) Assert_property_statement() (localctx IAssert_property_statementContext) {
	this := p
	_ = this

	localctx = NewAssert_property_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 416, SystemVerilogParserRULE_assert_property_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3891)
		p.Match(SystemVerilogParserKASSERT)
	}
	{
		p.SetState(3892)
		p.Match(SystemVerilogParserKPROPERTY)
	}
	{
		p.SetState(3893)
		p.Match(SystemVerilogParserLP)
	}
	{
		p.SetState(3894)
		p.Property_spec()
	}
	{
		p.SetState(3895)
		p.Match(SystemVerilogParserRP)
	}
	{
		p.SetState(3896)
		p.Action_block()
	}

	return localctx
}

// IAssume_property_statementContext is an interface to support dynamic dispatch.
type IAssume_property_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssume_property_statementContext differentiates from other interfaces.
	IsAssume_property_statementContext()
}

type Assume_property_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssume_property_statementContext() *Assume_property_statementContext {
	var p = new(Assume_property_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_assume_property_statement
	return p
}

func (*Assume_property_statementContext) IsAssume_property_statementContext() {}

func NewAssume_property_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Assume_property_statementContext {
	var p = new(Assume_property_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_assume_property_statement

	return p
}

func (s *Assume_property_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Assume_property_statementContext) KASSUME() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKASSUME, 0)
}

func (s *Assume_property_statementContext) KPROPERTY() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKPROPERTY, 0)
}

func (s *Assume_property_statementContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Assume_property_statementContext) Property_spec() IProperty_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProperty_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProperty_specContext)
}

func (s *Assume_property_statementContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Assume_property_statementContext) Action_block() IAction_blockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAction_blockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAction_blockContext)
}

func (s *Assume_property_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Assume_property_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Assume_property_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterAssume_property_statement(s)
	}
}

func (s *Assume_property_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitAssume_property_statement(s)
	}
}

func (p *SystemVerilogParser) Assume_property_statement() (localctx IAssume_property_statementContext) {
	this := p
	_ = this

	localctx = NewAssume_property_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 418, SystemVerilogParserRULE_assume_property_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3898)
		p.Match(SystemVerilogParserKASSUME)
	}
	{
		p.SetState(3899)
		p.Match(SystemVerilogParserKPROPERTY)
	}
	{
		p.SetState(3900)
		p.Match(SystemVerilogParserLP)
	}
	{
		p.SetState(3901)
		p.Property_spec()
	}
	{
		p.SetState(3902)
		p.Match(SystemVerilogParserRP)
	}
	{
		p.SetState(3903)
		p.Action_block()
	}

	return localctx
}

// ICover_property_statementContext is an interface to support dynamic dispatch.
type ICover_property_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCover_property_statementContext differentiates from other interfaces.
	IsCover_property_statementContext()
}

type Cover_property_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCover_property_statementContext() *Cover_property_statementContext {
	var p = new(Cover_property_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_cover_property_statement
	return p
}

func (*Cover_property_statementContext) IsCover_property_statementContext() {}

func NewCover_property_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cover_property_statementContext {
	var p = new(Cover_property_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_cover_property_statement

	return p
}

func (s *Cover_property_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Cover_property_statementContext) KCOVER() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKCOVER, 0)
}

func (s *Cover_property_statementContext) KPROPERTY() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKPROPERTY, 0)
}

func (s *Cover_property_statementContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Cover_property_statementContext) Property_spec() IProperty_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProperty_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProperty_specContext)
}

func (s *Cover_property_statementContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Cover_property_statementContext) Statement_or_null() IStatement_or_nullContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatement_or_nullContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatement_or_nullContext)
}

func (s *Cover_property_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cover_property_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cover_property_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterCover_property_statement(s)
	}
}

func (s *Cover_property_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitCover_property_statement(s)
	}
}

func (p *SystemVerilogParser) Cover_property_statement() (localctx ICover_property_statementContext) {
	this := p
	_ = this

	localctx = NewCover_property_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 420, SystemVerilogParserRULE_cover_property_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3905)
		p.Match(SystemVerilogParserKCOVER)
	}
	{
		p.SetState(3906)
		p.Match(SystemVerilogParserKPROPERTY)
	}
	{
		p.SetState(3907)
		p.Match(SystemVerilogParserLP)
	}
	{
		p.SetState(3908)
		p.Property_spec()
	}
	{
		p.SetState(3909)
		p.Match(SystemVerilogParserRP)
	}
	{
		p.SetState(3910)
		p.Statement_or_null()
	}

	return localctx
}

// IExpect_property_statementContext is an interface to support dynamic dispatch.
type IExpect_property_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpect_property_statementContext differentiates from other interfaces.
	IsExpect_property_statementContext()
}

type Expect_property_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpect_property_statementContext() *Expect_property_statementContext {
	var p = new(Expect_property_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_expect_property_statement
	return p
}

func (*Expect_property_statementContext) IsExpect_property_statementContext() {}

func NewExpect_property_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expect_property_statementContext {
	var p = new(Expect_property_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_expect_property_statement

	return p
}

func (s *Expect_property_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Expect_property_statementContext) KEXPECT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKEXPECT, 0)
}

func (s *Expect_property_statementContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Expect_property_statementContext) Property_spec() IProperty_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProperty_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProperty_specContext)
}

func (s *Expect_property_statementContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Expect_property_statementContext) Action_block() IAction_blockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAction_blockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAction_blockContext)
}

func (s *Expect_property_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expect_property_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expect_property_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterExpect_property_statement(s)
	}
}

func (s *Expect_property_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitExpect_property_statement(s)
	}
}

func (p *SystemVerilogParser) Expect_property_statement() (localctx IExpect_property_statementContext) {
	this := p
	_ = this

	localctx = NewExpect_property_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 422, SystemVerilogParserRULE_expect_property_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3912)
		p.Match(SystemVerilogParserKEXPECT)
	}
	{
		p.SetState(3913)
		p.Match(SystemVerilogParserLP)
	}
	{
		p.SetState(3914)
		p.Property_spec()
	}
	{
		p.SetState(3915)
		p.Match(SystemVerilogParserRP)
	}
	{
		p.SetState(3916)
		p.Action_block()
	}

	return localctx
}

// ICover_sequence_statementContext is an interface to support dynamic dispatch.
type ICover_sequence_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCover_sequence_statementContext differentiates from other interfaces.
	IsCover_sequence_statementContext()
}

type Cover_sequence_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCover_sequence_statementContext() *Cover_sequence_statementContext {
	var p = new(Cover_sequence_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_cover_sequence_statement
	return p
}

func (*Cover_sequence_statementContext) IsCover_sequence_statementContext() {}

func NewCover_sequence_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cover_sequence_statementContext {
	var p = new(Cover_sequence_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_cover_sequence_statement

	return p
}

func (s *Cover_sequence_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Cover_sequence_statementContext) KCOVER() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKCOVER, 0)
}

func (s *Cover_sequence_statementContext) KSEQUENCE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKSEQUENCE, 0)
}

func (s *Cover_sequence_statementContext) AllLP() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserLP)
}

func (s *Cover_sequence_statementContext) LP(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, i)
}

func (s *Cover_sequence_statementContext) Sequence_expr() ISequence_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequence_exprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISequence_exprContext)
}

func (s *Cover_sequence_statementContext) AllRP() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserRP)
}

func (s *Cover_sequence_statementContext) RP(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, i)
}

func (s *Cover_sequence_statementContext) Statement_or_null() IStatement_or_nullContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatement_or_nullContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatement_or_nullContext)
}

func (s *Cover_sequence_statementContext) Clocking_event() IClocking_eventContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClocking_eventContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClocking_eventContext)
}

func (s *Cover_sequence_statementContext) KDISABLE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKDISABLE, 0)
}

func (s *Cover_sequence_statementContext) KIFF() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKIFF, 0)
}

func (s *Cover_sequence_statementContext) Expression_or_dist() IExpression_or_distContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpression_or_distContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpression_or_distContext)
}

func (s *Cover_sequence_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cover_sequence_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cover_sequence_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterCover_sequence_statement(s)
	}
}

func (s *Cover_sequence_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitCover_sequence_statement(s)
	}
}

func (p *SystemVerilogParser) Cover_sequence_statement() (localctx ICover_sequence_statementContext) {
	this := p
	_ = this

	localctx = NewCover_sequence_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 424, SystemVerilogParserRULE_cover_sequence_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3918)
		p.Match(SystemVerilogParserKCOVER)
	}
	{
		p.SetState(3919)
		p.Match(SystemVerilogParserKSEQUENCE)
	}
	{
		p.SetState(3920)
		p.Match(SystemVerilogParserLP)
	}
	p.SetState(3922)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 433, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3921)
			p.Clocking_event()
		}

	}
	p.SetState(3930)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserKDISABLE {
		{
			p.SetState(3924)
			p.Match(SystemVerilogParserKDISABLE)
		}
		{
			p.SetState(3925)
			p.Match(SystemVerilogParserKIFF)
		}
		{
			p.SetState(3926)
			p.Match(SystemVerilogParserLP)
		}
		{
			p.SetState(3927)
			p.Expression_or_dist()
		}
		{
			p.SetState(3928)
			p.Match(SystemVerilogParserRP)
		}

	}
	{
		p.SetState(3932)
		p.sequence_expr(0)
	}
	{
		p.SetState(3933)
		p.Match(SystemVerilogParserRP)
	}
	{
		p.SetState(3934)
		p.Statement_or_null()
	}

	return localctx
}

// IRestrict_property_statementContext is an interface to support dynamic dispatch.
type IRestrict_property_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRestrict_property_statementContext differentiates from other interfaces.
	IsRestrict_property_statementContext()
}

type Restrict_property_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRestrict_property_statementContext() *Restrict_property_statementContext {
	var p = new(Restrict_property_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_restrict_property_statement
	return p
}

func (*Restrict_property_statementContext) IsRestrict_property_statementContext() {}

func NewRestrict_property_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Restrict_property_statementContext {
	var p = new(Restrict_property_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_restrict_property_statement

	return p
}

func (s *Restrict_property_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Restrict_property_statementContext) KRESTRICT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKRESTRICT, 0)
}

func (s *Restrict_property_statementContext) KPROPERTY() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKPROPERTY, 0)
}

func (s *Restrict_property_statementContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Restrict_property_statementContext) Property_spec() IProperty_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProperty_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProperty_specContext)
}

func (s *Restrict_property_statementContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Restrict_property_statementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Restrict_property_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Restrict_property_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Restrict_property_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterRestrict_property_statement(s)
	}
}

func (s *Restrict_property_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitRestrict_property_statement(s)
	}
}

func (p *SystemVerilogParser) Restrict_property_statement() (localctx IRestrict_property_statementContext) {
	this := p
	_ = this

	localctx = NewRestrict_property_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 426, SystemVerilogParserRULE_restrict_property_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3936)
		p.Match(SystemVerilogParserKRESTRICT)
	}
	{
		p.SetState(3937)
		p.Match(SystemVerilogParserKPROPERTY)
	}
	{
		p.SetState(3938)
		p.Match(SystemVerilogParserLP)
	}
	{
		p.SetState(3939)
		p.Property_spec()
	}
	{
		p.SetState(3940)
		p.Match(SystemVerilogParserRP)
	}
	{
		p.SetState(3941)
		p.Match(SystemVerilogParserSEMI)
	}

	return localctx
}

// IProperty_instanceContext is an interface to support dynamic dispatch.
type IProperty_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProperty_instanceContext differentiates from other interfaces.
	IsProperty_instanceContext()
}

type Property_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProperty_instanceContext() *Property_instanceContext {
	var p = new(Property_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_property_instance
	return p
}

func (*Property_instanceContext) IsProperty_instanceContext() {}

func NewProperty_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Property_instanceContext {
	var p = new(Property_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_property_instance

	return p
}

func (s *Property_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *Property_instanceContext) Ps_or_hierarchical_property_identifier() IPs_or_hierarchical_property_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPs_or_hierarchical_property_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPs_or_hierarchical_property_identifierContext)
}

func (s *Property_instanceContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Property_instanceContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Property_instanceContext) Property_list_of_arguments() IProperty_list_of_argumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProperty_list_of_argumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProperty_list_of_argumentsContext)
}

func (s *Property_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Property_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Property_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterProperty_instance(s)
	}
}

func (s *Property_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitProperty_instance(s)
	}
}

func (p *SystemVerilogParser) Property_instance() (localctx IProperty_instanceContext) {
	this := p
	_ = this

	localctx = NewProperty_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 428, SystemVerilogParserRULE_property_instance)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3943)
		p.Ps_or_hierarchical_property_identifier()
	}
	p.SetState(3949)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 436, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3944)
			p.Match(SystemVerilogParserLP)
		}
		p.SetState(3946)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 435, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3945)
				p.Property_list_of_arguments()
			}

		}
		{
			p.SetState(3948)
			p.Match(SystemVerilogParserRP)
		}

	}

	return localctx
}

// IProperty_list_of_argumentsContext is an interface to support dynamic dispatch.
type IProperty_list_of_argumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProperty_list_of_argumentsContext differentiates from other interfaces.
	IsProperty_list_of_argumentsContext()
}

type Property_list_of_argumentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProperty_list_of_argumentsContext() *Property_list_of_argumentsContext {
	var p = new(Property_list_of_argumentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_property_list_of_arguments
	return p
}

func (*Property_list_of_argumentsContext) IsProperty_list_of_argumentsContext() {}

func NewProperty_list_of_argumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Property_list_of_argumentsContext {
	var p = new(Property_list_of_argumentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_property_list_of_arguments

	return p
}

func (s *Property_list_of_argumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *Property_list_of_argumentsContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserDOT)
}

func (s *Property_list_of_argumentsContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserDOT, i)
}

func (s *Property_list_of_argumentsContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *Property_list_of_argumentsContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Property_list_of_argumentsContext) AllLP() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserLP)
}

func (s *Property_list_of_argumentsContext) LP(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, i)
}

func (s *Property_list_of_argumentsContext) AllRP() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserRP)
}

func (s *Property_list_of_argumentsContext) RP(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, i)
}

func (s *Property_list_of_argumentsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *Property_list_of_argumentsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *Property_list_of_argumentsContext) AllProperty_actual_arg() []IProperty_actual_argContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IProperty_actual_argContext)(nil)).Elem())
	var tst = make([]IProperty_actual_argContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IProperty_actual_argContext)
		}
	}

	return tst
}

func (s *Property_list_of_argumentsContext) Property_actual_arg(i int) IProperty_actual_argContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProperty_actual_argContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IProperty_actual_argContext)
}

func (s *Property_list_of_argumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Property_list_of_argumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Property_list_of_argumentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterProperty_list_of_arguments(s)
	}
}

func (s *Property_list_of_argumentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitProperty_list_of_arguments(s)
	}
}

func (p *SystemVerilogParser) Property_list_of_arguments() (localctx IProperty_list_of_argumentsContext) {
	this := p
	_ = this

	localctx = NewProperty_list_of_argumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 430, SystemVerilogParserRULE_property_list_of_arguments)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3971)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserMINUS, SystemVerilogParserMINUSMINS, SystemVerilogParserNOT, SystemVerilogParserPP, SystemVerilogParserDOLLAR, SystemVerilogParserDROOT, SystemVerilogParserDUNIT, SystemVerilogParserAND, SystemVerilogParserLP, SystemVerilogParserRP, SystemVerilogParserCOMMA, SystemVerilogParserAT, SystemVerilogParserQUOTE, SystemVerilogParserCARET, SystemVerilogParserCARETSQUIG, SystemVerilogParserLC, SystemVerilogParserBAR, SystemVerilogParserSQUIG, SystemVerilogParserSQUIGAND, SystemVerilogParserSQUIGCARET, SystemVerilogParserSQUIGBAR, SystemVerilogParserPLUS, SystemVerilogParserPLUSPLUS, SystemVerilogParserKACCEPT_ON, SystemVerilogParserKALWAYS, SystemVerilogParserKBIT, SystemVerilogParserKBYTE, SystemVerilogParserKCASE, SystemVerilogParserKCONST, SystemVerilogParserKEDGE, SystemVerilogParserKEVENTUALLY, SystemVerilogParserKFIRST_MATCH, SystemVerilogParserKIF, SystemVerilogParserKINT, SystemVerilogParserKINTEGER, SystemVerilogParserKLOCAL, SystemVerilogParserKLOGIC, SystemVerilogParserKLONGINT, SystemVerilogParserKNEGEDGE, SystemVerilogParserKNEXTTIME, SystemVerilogParserKNOT, SystemVerilogParserKNULL, SystemVerilogParserKPOSEDGE, SystemVerilogParserKRANDOMIZE, SystemVerilogParserKREAL, SystemVerilogParserKREALTIME, SystemVerilogParserKREG, SystemVerilogParserKREJECT_ON, SystemVerilogParserKS_ALWAYS, SystemVerilogParserKS_EVENTUALLY, SystemVerilogParserKS_NEXTTIME, SystemVerilogParserKSHORTINT, SystemVerilogParserKSHORTREAL, SystemVerilogParserKSIGNED, SystemVerilogParserKSTD, SystemVerilogParserKSTRING, SystemVerilogParserKSTRONG, SystemVerilogParserKSUPER, SystemVerilogParserKSYNC_ACCEPT_ON, SystemVerilogParserKSYNC_REJECT_ON, SystemVerilogParserKTAGGED, SystemVerilogParserKTHIS, SystemVerilogParserKTIME, SystemVerilogParserKTYPE, SystemVerilogParserKUNSIGNED, SystemVerilogParserKWEAK, SystemVerilogParserTIME_LITERAL, SystemVerilogParserDECIMAL_NUMBER, SystemVerilogParserBINARY_NUMBER, SystemVerilogParserOCTAL_NUMBER, SystemVerilogParserHEX_NUMBER, SystemVerilogParserREAL_NUMBER, SystemVerilogParserUNSIGNED_NUMBER, SystemVerilogParserSTRING_LITERAL, SystemVerilogParserSIMPLE_IDENTIFIER, SystemVerilogParserSYSTEM_TF_IDENTIFIER:
		p.SetState(3952)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SystemVerilogParserMINUS)|(1<<SystemVerilogParserMINUSMINS)|(1<<SystemVerilogParserNOT)|(1<<SystemVerilogParserPP)|(1<<SystemVerilogParserDOLLAR)|(1<<SystemVerilogParserDROOT)|(1<<SystemVerilogParserDUNIT)|(1<<SystemVerilogParserAND)|(1<<SystemVerilogParserLP))) != 0) || (((_la-48)&-(0x1f+1)) == 0 && ((1<<uint((_la-48)))&((1<<(SystemVerilogParserAT-48))|(1<<(SystemVerilogParserQUOTE-48))|(1<<(SystemVerilogParserCARET-48))|(1<<(SystemVerilogParserCARETSQUIG-48))|(1<<(SystemVerilogParserLC-48))|(1<<(SystemVerilogParserBAR-48))|(1<<(SystemVerilogParserSQUIG-48))|(1<<(SystemVerilogParserSQUIGAND-48))|(1<<(SystemVerilogParserSQUIGCARET-48))|(1<<(SystemVerilogParserSQUIGBAR-48))|(1<<(SystemVerilogParserPLUS-48))|(1<<(SystemVerilogParserPLUSPLUS-48)))) != 0) || (((_la-93)&-(0x1f+1)) == 0 && ((1<<uint((_la-93)))&((1<<(SystemVerilogParserKACCEPT_ON-93))|(1<<(SystemVerilogParserKALWAYS-93))|(1<<(SystemVerilogParserKBIT-93))|(1<<(SystemVerilogParserKBYTE-93))|(1<<(SystemVerilogParserKCASE-93)))) != 0) || _la == SystemVerilogParserKCONST || _la == SystemVerilogParserKEDGE || (((_la-161)&-(0x1f+1)) == 0 && ((1<<uint((_la-161)))&((1<<(SystemVerilogParserKEVENTUALLY-161))|(1<<(SystemVerilogParserKFIRST_MATCH-161))|(1<<(SystemVerilogParserKIF-161)))) != 0) || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SystemVerilogParserKINT-195))|(1<<(SystemVerilogParserKINTEGER-195))|(1<<(SystemVerilogParserKLOCAL-195))|(1<<(SystemVerilogParserKLOGIC-195))|(1<<(SystemVerilogParserKLONGINT-195))|(1<<(SystemVerilogParserKNEGEDGE-195))|(1<<(SystemVerilogParserKNEXTTIME-195))|(1<<(SystemVerilogParserKNOT-195)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(SystemVerilogParserKNULL-228))|(1<<(SystemVerilogParserKPOSEDGE-228))|(1<<(SystemVerilogParserKRANDOMIZE-228))|(1<<(SystemVerilogParserKREAL-228))|(1<<(SystemVerilogParserKREALTIME-228))|(1<<(SystemVerilogParserKREG-228))|(1<<(SystemVerilogParserKREJECT_ON-228)))) != 0) || (((_la-269)&-(0x1f+1)) == 0 && ((1<<uint((_la-269)))&((1<<(SystemVerilogParserKS_ALWAYS-269))|(1<<(SystemVerilogParserKS_EVENTUALLY-269))|(1<<(SystemVerilogParserKS_NEXTTIME-269))|(1<<(SystemVerilogParserKSHORTINT-269))|(1<<(SystemVerilogParserKSHORTREAL-269))|(1<<(SystemVerilogParserKSIGNED-269))|(1<<(SystemVerilogParserKSTD-269))|(1<<(SystemVerilogParserKSTRING-269))|(1<<(SystemVerilogParserKSTRONG-269))|(1<<(SystemVerilogParserKSUPER-269))|(1<<(SystemVerilogParserKSYNC_ACCEPT_ON-269))|(1<<(SystemVerilogParserKSYNC_REJECT_ON-269))|(1<<(SystemVerilogParserKTAGGED-269))|(1<<(SystemVerilogParserKTHIS-269)))) != 0) || (((_la-301)&-(0x1f+1)) == 0 && ((1<<uint((_la-301)))&((1<<(SystemVerilogParserKTIME-301))|(1<<(SystemVerilogParserKTYPE-301))|(1<<(SystemVerilogParserKUNSIGNED-301))|(1<<(SystemVerilogParserKWEAK-301)))) != 0) || (((_la-345)&-(0x1f+1)) == 0 && ((1<<uint((_la-345)))&((1<<(SystemVerilogParserTIME_LITERAL-345))|(1<<(SystemVerilogParserDECIMAL_NUMBER-345))|(1<<(SystemVerilogParserBINARY_NUMBER-345))|(1<<(SystemVerilogParserOCTAL_NUMBER-345))|(1<<(SystemVerilogParserHEX_NUMBER-345))|(1<<(SystemVerilogParserREAL_NUMBER-345))|(1<<(SystemVerilogParserUNSIGNED_NUMBER-345))|(1<<(SystemVerilogParserSTRING_LITERAL-345))|(1<<(SystemVerilogParserSIMPLE_IDENTIFIER-345))|(1<<(SystemVerilogParserSYSTEM_TF_IDENTIFIER-345)))) != 0) {
			{
				p.SetState(3951)
				p.Property_actual_arg()
			}

		}
		p.SetState(3960)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 439, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(3954)
					p.Match(SystemVerilogParserCOMMA)
				}
				p.SetState(3956)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SystemVerilogParserMINUS)|(1<<SystemVerilogParserMINUSMINS)|(1<<SystemVerilogParserNOT)|(1<<SystemVerilogParserPP)|(1<<SystemVerilogParserDOLLAR)|(1<<SystemVerilogParserDROOT)|(1<<SystemVerilogParserDUNIT)|(1<<SystemVerilogParserAND)|(1<<SystemVerilogParserLP))) != 0) || (((_la-48)&-(0x1f+1)) == 0 && ((1<<uint((_la-48)))&((1<<(SystemVerilogParserAT-48))|(1<<(SystemVerilogParserQUOTE-48))|(1<<(SystemVerilogParserCARET-48))|(1<<(SystemVerilogParserCARETSQUIG-48))|(1<<(SystemVerilogParserLC-48))|(1<<(SystemVerilogParserBAR-48))|(1<<(SystemVerilogParserSQUIG-48))|(1<<(SystemVerilogParserSQUIGAND-48))|(1<<(SystemVerilogParserSQUIGCARET-48))|(1<<(SystemVerilogParserSQUIGBAR-48))|(1<<(SystemVerilogParserPLUS-48))|(1<<(SystemVerilogParserPLUSPLUS-48)))) != 0) || (((_la-93)&-(0x1f+1)) == 0 && ((1<<uint((_la-93)))&((1<<(SystemVerilogParserKACCEPT_ON-93))|(1<<(SystemVerilogParserKALWAYS-93))|(1<<(SystemVerilogParserKBIT-93))|(1<<(SystemVerilogParserKBYTE-93))|(1<<(SystemVerilogParserKCASE-93)))) != 0) || _la == SystemVerilogParserKCONST || _la == SystemVerilogParserKEDGE || (((_la-161)&-(0x1f+1)) == 0 && ((1<<uint((_la-161)))&((1<<(SystemVerilogParserKEVENTUALLY-161))|(1<<(SystemVerilogParserKFIRST_MATCH-161))|(1<<(SystemVerilogParserKIF-161)))) != 0) || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SystemVerilogParserKINT-195))|(1<<(SystemVerilogParserKINTEGER-195))|(1<<(SystemVerilogParserKLOCAL-195))|(1<<(SystemVerilogParserKLOGIC-195))|(1<<(SystemVerilogParserKLONGINT-195))|(1<<(SystemVerilogParserKNEGEDGE-195))|(1<<(SystemVerilogParserKNEXTTIME-195))|(1<<(SystemVerilogParserKNOT-195)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(SystemVerilogParserKNULL-228))|(1<<(SystemVerilogParserKPOSEDGE-228))|(1<<(SystemVerilogParserKRANDOMIZE-228))|(1<<(SystemVerilogParserKREAL-228))|(1<<(SystemVerilogParserKREALTIME-228))|(1<<(SystemVerilogParserKREG-228))|(1<<(SystemVerilogParserKREJECT_ON-228)))) != 0) || (((_la-269)&-(0x1f+1)) == 0 && ((1<<uint((_la-269)))&((1<<(SystemVerilogParserKS_ALWAYS-269))|(1<<(SystemVerilogParserKS_EVENTUALLY-269))|(1<<(SystemVerilogParserKS_NEXTTIME-269))|(1<<(SystemVerilogParserKSHORTINT-269))|(1<<(SystemVerilogParserKSHORTREAL-269))|(1<<(SystemVerilogParserKSIGNED-269))|(1<<(SystemVerilogParserKSTD-269))|(1<<(SystemVerilogParserKSTRING-269))|(1<<(SystemVerilogParserKSTRONG-269))|(1<<(SystemVerilogParserKSUPER-269))|(1<<(SystemVerilogParserKSYNC_ACCEPT_ON-269))|(1<<(SystemVerilogParserKSYNC_REJECT_ON-269))|(1<<(SystemVerilogParserKTAGGED-269))|(1<<(SystemVerilogParserKTHIS-269)))) != 0) || (((_la-301)&-(0x1f+1)) == 0 && ((1<<uint((_la-301)))&((1<<(SystemVerilogParserKTIME-301))|(1<<(SystemVerilogParserKTYPE-301))|(1<<(SystemVerilogParserKUNSIGNED-301))|(1<<(SystemVerilogParserKWEAK-301)))) != 0) || (((_la-345)&-(0x1f+1)) == 0 && ((1<<uint((_la-345)))&((1<<(SystemVerilogParserTIME_LITERAL-345))|(1<<(SystemVerilogParserDECIMAL_NUMBER-345))|(1<<(SystemVerilogParserBINARY_NUMBER-345))|(1<<(SystemVerilogParserOCTAL_NUMBER-345))|(1<<(SystemVerilogParserHEX_NUMBER-345))|(1<<(SystemVerilogParserREAL_NUMBER-345))|(1<<(SystemVerilogParserUNSIGNED_NUMBER-345))|(1<<(SystemVerilogParserSTRING_LITERAL-345))|(1<<(SystemVerilogParserSIMPLE_IDENTIFIER-345))|(1<<(SystemVerilogParserSYSTEM_TF_IDENTIFIER-345)))) != 0) {
					{
						p.SetState(3955)
						p.Property_actual_arg()
					}

				}

			}
			p.SetState(3962)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 439, p.GetParserRuleContext())
		}

	case SystemVerilogParserDOT:
		{
			p.SetState(3963)
			p.Match(SystemVerilogParserDOT)
		}
		{
			p.SetState(3964)
			p.Identifier()
		}
		{
			p.SetState(3965)
			p.Match(SystemVerilogParserLP)
		}
		p.SetState(3967)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SystemVerilogParserMINUS)|(1<<SystemVerilogParserMINUSMINS)|(1<<SystemVerilogParserNOT)|(1<<SystemVerilogParserPP)|(1<<SystemVerilogParserDOLLAR)|(1<<SystemVerilogParserDROOT)|(1<<SystemVerilogParserDUNIT)|(1<<SystemVerilogParserAND)|(1<<SystemVerilogParserLP))) != 0) || (((_la-48)&-(0x1f+1)) == 0 && ((1<<uint((_la-48)))&((1<<(SystemVerilogParserAT-48))|(1<<(SystemVerilogParserQUOTE-48))|(1<<(SystemVerilogParserCARET-48))|(1<<(SystemVerilogParserCARETSQUIG-48))|(1<<(SystemVerilogParserLC-48))|(1<<(SystemVerilogParserBAR-48))|(1<<(SystemVerilogParserSQUIG-48))|(1<<(SystemVerilogParserSQUIGAND-48))|(1<<(SystemVerilogParserSQUIGCARET-48))|(1<<(SystemVerilogParserSQUIGBAR-48))|(1<<(SystemVerilogParserPLUS-48))|(1<<(SystemVerilogParserPLUSPLUS-48)))) != 0) || (((_la-93)&-(0x1f+1)) == 0 && ((1<<uint((_la-93)))&((1<<(SystemVerilogParserKACCEPT_ON-93))|(1<<(SystemVerilogParserKALWAYS-93))|(1<<(SystemVerilogParserKBIT-93))|(1<<(SystemVerilogParserKBYTE-93))|(1<<(SystemVerilogParserKCASE-93)))) != 0) || _la == SystemVerilogParserKCONST || _la == SystemVerilogParserKEDGE || (((_la-161)&-(0x1f+1)) == 0 && ((1<<uint((_la-161)))&((1<<(SystemVerilogParserKEVENTUALLY-161))|(1<<(SystemVerilogParserKFIRST_MATCH-161))|(1<<(SystemVerilogParserKIF-161)))) != 0) || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SystemVerilogParserKINT-195))|(1<<(SystemVerilogParserKINTEGER-195))|(1<<(SystemVerilogParserKLOCAL-195))|(1<<(SystemVerilogParserKLOGIC-195))|(1<<(SystemVerilogParserKLONGINT-195))|(1<<(SystemVerilogParserKNEGEDGE-195))|(1<<(SystemVerilogParserKNEXTTIME-195))|(1<<(SystemVerilogParserKNOT-195)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(SystemVerilogParserKNULL-228))|(1<<(SystemVerilogParserKPOSEDGE-228))|(1<<(SystemVerilogParserKRANDOMIZE-228))|(1<<(SystemVerilogParserKREAL-228))|(1<<(SystemVerilogParserKREALTIME-228))|(1<<(SystemVerilogParserKREG-228))|(1<<(SystemVerilogParserKREJECT_ON-228)))) != 0) || (((_la-269)&-(0x1f+1)) == 0 && ((1<<uint((_la-269)))&((1<<(SystemVerilogParserKS_ALWAYS-269))|(1<<(SystemVerilogParserKS_EVENTUALLY-269))|(1<<(SystemVerilogParserKS_NEXTTIME-269))|(1<<(SystemVerilogParserKSHORTINT-269))|(1<<(SystemVerilogParserKSHORTREAL-269))|(1<<(SystemVerilogParserKSIGNED-269))|(1<<(SystemVerilogParserKSTD-269))|(1<<(SystemVerilogParserKSTRING-269))|(1<<(SystemVerilogParserKSTRONG-269))|(1<<(SystemVerilogParserKSUPER-269))|(1<<(SystemVerilogParserKSYNC_ACCEPT_ON-269))|(1<<(SystemVerilogParserKSYNC_REJECT_ON-269))|(1<<(SystemVerilogParserKTAGGED-269))|(1<<(SystemVerilogParserKTHIS-269)))) != 0) || (((_la-301)&-(0x1f+1)) == 0 && ((1<<uint((_la-301)))&((1<<(SystemVerilogParserKTIME-301))|(1<<(SystemVerilogParserKTYPE-301))|(1<<(SystemVerilogParserKUNSIGNED-301))|(1<<(SystemVerilogParserKWEAK-301)))) != 0) || (((_la-345)&-(0x1f+1)) == 0 && ((1<<uint((_la-345)))&((1<<(SystemVerilogParserTIME_LITERAL-345))|(1<<(SystemVerilogParserDECIMAL_NUMBER-345))|(1<<(SystemVerilogParserBINARY_NUMBER-345))|(1<<(SystemVerilogParserOCTAL_NUMBER-345))|(1<<(SystemVerilogParserHEX_NUMBER-345))|(1<<(SystemVerilogParserREAL_NUMBER-345))|(1<<(SystemVerilogParserUNSIGNED_NUMBER-345))|(1<<(SystemVerilogParserSTRING_LITERAL-345))|(1<<(SystemVerilogParserSIMPLE_IDENTIFIER-345))|(1<<(SystemVerilogParserSYSTEM_TF_IDENTIFIER-345)))) != 0) {
			{
				p.SetState(3966)
				p.Property_actual_arg()
			}

		}
		{
			p.SetState(3969)
			p.Match(SystemVerilogParserRP)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(3984)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserCOMMA {
		{
			p.SetState(3973)
			p.Match(SystemVerilogParserCOMMA)
		}
		{
			p.SetState(3974)
			p.Match(SystemVerilogParserDOT)
		}
		{
			p.SetState(3975)
			p.Identifier()
		}
		{
			p.SetState(3976)
			p.Match(SystemVerilogParserLP)
		}
		p.SetState(3978)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SystemVerilogParserMINUS)|(1<<SystemVerilogParserMINUSMINS)|(1<<SystemVerilogParserNOT)|(1<<SystemVerilogParserPP)|(1<<SystemVerilogParserDOLLAR)|(1<<SystemVerilogParserDROOT)|(1<<SystemVerilogParserDUNIT)|(1<<SystemVerilogParserAND)|(1<<SystemVerilogParserLP))) != 0) || (((_la-48)&-(0x1f+1)) == 0 && ((1<<uint((_la-48)))&((1<<(SystemVerilogParserAT-48))|(1<<(SystemVerilogParserQUOTE-48))|(1<<(SystemVerilogParserCARET-48))|(1<<(SystemVerilogParserCARETSQUIG-48))|(1<<(SystemVerilogParserLC-48))|(1<<(SystemVerilogParserBAR-48))|(1<<(SystemVerilogParserSQUIG-48))|(1<<(SystemVerilogParserSQUIGAND-48))|(1<<(SystemVerilogParserSQUIGCARET-48))|(1<<(SystemVerilogParserSQUIGBAR-48))|(1<<(SystemVerilogParserPLUS-48))|(1<<(SystemVerilogParserPLUSPLUS-48)))) != 0) || (((_la-93)&-(0x1f+1)) == 0 && ((1<<uint((_la-93)))&((1<<(SystemVerilogParserKACCEPT_ON-93))|(1<<(SystemVerilogParserKALWAYS-93))|(1<<(SystemVerilogParserKBIT-93))|(1<<(SystemVerilogParserKBYTE-93))|(1<<(SystemVerilogParserKCASE-93)))) != 0) || _la == SystemVerilogParserKCONST || _la == SystemVerilogParserKEDGE || (((_la-161)&-(0x1f+1)) == 0 && ((1<<uint((_la-161)))&((1<<(SystemVerilogParserKEVENTUALLY-161))|(1<<(SystemVerilogParserKFIRST_MATCH-161))|(1<<(SystemVerilogParserKIF-161)))) != 0) || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SystemVerilogParserKINT-195))|(1<<(SystemVerilogParserKINTEGER-195))|(1<<(SystemVerilogParserKLOCAL-195))|(1<<(SystemVerilogParserKLOGIC-195))|(1<<(SystemVerilogParserKLONGINT-195))|(1<<(SystemVerilogParserKNEGEDGE-195))|(1<<(SystemVerilogParserKNEXTTIME-195))|(1<<(SystemVerilogParserKNOT-195)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(SystemVerilogParserKNULL-228))|(1<<(SystemVerilogParserKPOSEDGE-228))|(1<<(SystemVerilogParserKRANDOMIZE-228))|(1<<(SystemVerilogParserKREAL-228))|(1<<(SystemVerilogParserKREALTIME-228))|(1<<(SystemVerilogParserKREG-228))|(1<<(SystemVerilogParserKREJECT_ON-228)))) != 0) || (((_la-269)&-(0x1f+1)) == 0 && ((1<<uint((_la-269)))&((1<<(SystemVerilogParserKS_ALWAYS-269))|(1<<(SystemVerilogParserKS_EVENTUALLY-269))|(1<<(SystemVerilogParserKS_NEXTTIME-269))|(1<<(SystemVerilogParserKSHORTINT-269))|(1<<(SystemVerilogParserKSHORTREAL-269))|(1<<(SystemVerilogParserKSIGNED-269))|(1<<(SystemVerilogParserKSTD-269))|(1<<(SystemVerilogParserKSTRING-269))|(1<<(SystemVerilogParserKSTRONG-269))|(1<<(SystemVerilogParserKSUPER-269))|(1<<(SystemVerilogParserKSYNC_ACCEPT_ON-269))|(1<<(SystemVerilogParserKSYNC_REJECT_ON-269))|(1<<(SystemVerilogParserKTAGGED-269))|(1<<(SystemVerilogParserKTHIS-269)))) != 0) || (((_la-301)&-(0x1f+1)) == 0 && ((1<<uint((_la-301)))&((1<<(SystemVerilogParserKTIME-301))|(1<<(SystemVerilogParserKTYPE-301))|(1<<(SystemVerilogParserKUNSIGNED-301))|(1<<(SystemVerilogParserKWEAK-301)))) != 0) || (((_la-345)&-(0x1f+1)) == 0 && ((1<<uint((_la-345)))&((1<<(SystemVerilogParserTIME_LITERAL-345))|(1<<(SystemVerilogParserDECIMAL_NUMBER-345))|(1<<(SystemVerilogParserBINARY_NUMBER-345))|(1<<(SystemVerilogParserOCTAL_NUMBER-345))|(1<<(SystemVerilogParserHEX_NUMBER-345))|(1<<(SystemVerilogParserREAL_NUMBER-345))|(1<<(SystemVerilogParserUNSIGNED_NUMBER-345))|(1<<(SystemVerilogParserSTRING_LITERAL-345))|(1<<(SystemVerilogParserSIMPLE_IDENTIFIER-345))|(1<<(SystemVerilogParserSYSTEM_TF_IDENTIFIER-345)))) != 0) {
			{
				p.SetState(3977)
				p.Property_actual_arg()
			}

		}
		{
			p.SetState(3980)
			p.Match(SystemVerilogParserRP)
		}

		p.SetState(3986)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IProperty_actual_argContext is an interface to support dynamic dispatch.
type IProperty_actual_argContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProperty_actual_argContext differentiates from other interfaces.
	IsProperty_actual_argContext()
}

type Property_actual_argContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProperty_actual_argContext() *Property_actual_argContext {
	var p = new(Property_actual_argContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_property_actual_arg
	return p
}

func (*Property_actual_argContext) IsProperty_actual_argContext() {}

func NewProperty_actual_argContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Property_actual_argContext {
	var p = new(Property_actual_argContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_property_actual_arg

	return p
}

func (s *Property_actual_argContext) GetParser() antlr.Parser { return s.parser }

func (s *Property_actual_argContext) Property_expr() IProperty_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProperty_exprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProperty_exprContext)
}

func (s *Property_actual_argContext) Sequence_actual_arg() ISequence_actual_argContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequence_actual_argContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISequence_actual_argContext)
}

func (s *Property_actual_argContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Property_actual_argContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Property_actual_argContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterProperty_actual_arg(s)
	}
}

func (s *Property_actual_argContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitProperty_actual_arg(s)
	}
}

func (p *SystemVerilogParser) Property_actual_arg() (localctx IProperty_actual_argContext) {
	this := p
	_ = this

	localctx = NewProperty_actual_argContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 432, SystemVerilogParserRULE_property_actual_arg)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3989)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 444, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3987)
			p.property_expr(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3988)
			p.Sequence_actual_arg()
		}

	}

	return localctx
}

// IAssertion_item_declarationContext is an interface to support dynamic dispatch.
type IAssertion_item_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssertion_item_declarationContext differentiates from other interfaces.
	IsAssertion_item_declarationContext()
}

type Assertion_item_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssertion_item_declarationContext() *Assertion_item_declarationContext {
	var p = new(Assertion_item_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_assertion_item_declaration
	return p
}

func (*Assertion_item_declarationContext) IsAssertion_item_declarationContext() {}

func NewAssertion_item_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Assertion_item_declarationContext {
	var p = new(Assertion_item_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_assertion_item_declaration

	return p
}

func (s *Assertion_item_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Assertion_item_declarationContext) Property_declaration() IProperty_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProperty_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProperty_declarationContext)
}

func (s *Assertion_item_declarationContext) Sequence_declaration() ISequence_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequence_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISequence_declarationContext)
}

func (s *Assertion_item_declarationContext) Let_declaration() ILet_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILet_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILet_declarationContext)
}

func (s *Assertion_item_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Assertion_item_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Assertion_item_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterAssertion_item_declaration(s)
	}
}

func (s *Assertion_item_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitAssertion_item_declaration(s)
	}
}

func (p *SystemVerilogParser) Assertion_item_declaration() (localctx IAssertion_item_declarationContext) {
	this := p
	_ = this

	localctx = NewAssertion_item_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 434, SystemVerilogParserRULE_assertion_item_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3994)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserKPROPERTY:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3991)
			p.Property_declaration()
		}

	case SystemVerilogParserKSEQUENCE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3992)
			p.Sequence_declaration()
		}

	case SystemVerilogParserKLET:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3993)
			p.Let_declaration()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IProperty_declarationContext is an interface to support dynamic dispatch.
type IProperty_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProperty_declarationContext differentiates from other interfaces.
	IsProperty_declarationContext()
}

type Property_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProperty_declarationContext() *Property_declarationContext {
	var p = new(Property_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_property_declaration
	return p
}

func (*Property_declarationContext) IsProperty_declarationContext() {}

func NewProperty_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Property_declarationContext {
	var p = new(Property_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_property_declaration

	return p
}

func (s *Property_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Property_declarationContext) KPROPERTY() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKPROPERTY, 0)
}

func (s *Property_declarationContext) AllProperty_identifier() []IProperty_identifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IProperty_identifierContext)(nil)).Elem())
	var tst = make([]IProperty_identifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IProperty_identifierContext)
		}
	}

	return tst
}

func (s *Property_declarationContext) Property_identifier(i int) IProperty_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProperty_identifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IProperty_identifierContext)
}

func (s *Property_declarationContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserSEMI)
}

func (s *Property_declarationContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, i)
}

func (s *Property_declarationContext) Property_spec() IProperty_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProperty_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProperty_specContext)
}

func (s *Property_declarationContext) KENDPROPERTY() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKENDPROPERTY, 0)
}

func (s *Property_declarationContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Property_declarationContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Property_declarationContext) AllAssertion_variable_declaration() []IAssertion_variable_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAssertion_variable_declarationContext)(nil)).Elem())
	var tst = make([]IAssertion_variable_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAssertion_variable_declarationContext)
		}
	}

	return tst
}

func (s *Property_declarationContext) Assertion_variable_declaration(i int) IAssertion_variable_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssertion_variable_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAssertion_variable_declarationContext)
}

func (s *Property_declarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOLON, 0)
}

func (s *Property_declarationContext) Property_port_list() IProperty_port_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProperty_port_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProperty_port_listContext)
}

func (s *Property_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Property_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Property_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterProperty_declaration(s)
	}
}

func (s *Property_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitProperty_declaration(s)
	}
}

func (p *SystemVerilogParser) Property_declaration() (localctx IProperty_declarationContext) {
	this := p
	_ = this

	localctx = NewProperty_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 436, SystemVerilogParserRULE_property_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3996)
		p.Match(SystemVerilogParserKPROPERTY)
	}
	{
		p.SetState(3997)
		p.Property_identifier()
	}
	p.SetState(4003)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserLP {
		{
			p.SetState(3998)
			p.Match(SystemVerilogParserLP)
		}
		p.SetState(4000)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la-19)&-(0x1f+1)) == 0 && ((1<<uint((_la-19)))&((1<<(SystemVerilogParserDUNIT-19))|(1<<(SystemVerilogParserLPS-19))|(1<<(SystemVerilogParserLB-19)))) != 0) || (((_la-109)&-(0x1f+1)) == 0 && ((1<<uint((_la-109)))&((1<<(SystemVerilogParserKBIT-109))|(1<<(SystemVerilogParserKBYTE-109))|(1<<(SystemVerilogParserKCHANDLE-109)))) != 0) || _la == SystemVerilogParserKENUM || _la == SystemVerilogParserKEVENT || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SystemVerilogParserKINT-195))|(1<<(SystemVerilogParserKINTEGER-195))|(1<<(SystemVerilogParserKLOCAL-195))|(1<<(SystemVerilogParserKLOGIC-195))|(1<<(SystemVerilogParserKLONGINT-195)))) != 0) || (((_la-240)&-(0x1f+1)) == 0 && ((1<<uint((_la-240)))&((1<<(SystemVerilogParserKPROPERTY-240))|(1<<(SystemVerilogParserKREAL-240))|(1<<(SystemVerilogParserKREALTIME-240))|(1<<(SystemVerilogParserKREG-240)))) != 0) || (((_la-275)&-(0x1f+1)) == 0 && ((1<<uint((_la-275)))&((1<<(SystemVerilogParserKSEQUENCE-275))|(1<<(SystemVerilogParserKSHORTINT-275))|(1<<(SystemVerilogParserKSHORTREAL-275))|(1<<(SystemVerilogParserKSIGNED-275))|(1<<(SystemVerilogParserKSTRING-275))|(1<<(SystemVerilogParserKSTRUCT-275))|(1<<(SystemVerilogParserKTIME-275)))) != 0) || (((_la-313)&-(0x1f+1)) == 0 && ((1<<uint((_la-313)))&((1<<(SystemVerilogParserKTYPE-313))|(1<<(SystemVerilogParserKUNION-313))|(1<<(SystemVerilogParserKUNSIGNED-313))|(1<<(SystemVerilogParserKUNTYPED-313))|(1<<(SystemVerilogParserKVIRTUAL-313)))) != 0) || _la == SystemVerilogParserSIMPLE_IDENTIFIER {
			{
				p.SetState(3999)
				p.Property_port_list()
			}

		}
		{
			p.SetState(4002)
			p.Match(SystemVerilogParserRP)
		}

	}
	{
		p.SetState(4005)
		p.Match(SystemVerilogParserSEMI)
	}
	p.SetState(4009)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 448, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4006)
				p.Assertion_variable_declaration()
			}

		}
		p.SetState(4011)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 448, p.GetParserRuleContext())
	}
	{
		p.SetState(4012)
		p.Property_spec()
	}
	p.SetState(4014)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserSEMI {
		{
			p.SetState(4013)
			p.Match(SystemVerilogParserSEMI)
		}

	}
	{
		p.SetState(4016)
		p.Match(SystemVerilogParserKENDPROPERTY)
	}
	p.SetState(4019)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserCOLON {
		{
			p.SetState(4017)
			p.Match(SystemVerilogParserCOLON)
		}
		{
			p.SetState(4018)
			p.Property_identifier()
		}

	}

	return localctx
}

// IProperty_port_listContext is an interface to support dynamic dispatch.
type IProperty_port_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProperty_port_listContext differentiates from other interfaces.
	IsProperty_port_listContext()
}

type Property_port_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProperty_port_listContext() *Property_port_listContext {
	var p = new(Property_port_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_property_port_list
	return p
}

func (*Property_port_listContext) IsProperty_port_listContext() {}

func NewProperty_port_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Property_port_listContext {
	var p = new(Property_port_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_property_port_list

	return p
}

func (s *Property_port_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Property_port_listContext) AllProperty_port_item() []IProperty_port_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IProperty_port_itemContext)(nil)).Elem())
	var tst = make([]IProperty_port_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IProperty_port_itemContext)
		}
	}

	return tst
}

func (s *Property_port_listContext) Property_port_item(i int) IProperty_port_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProperty_port_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IProperty_port_itemContext)
}

func (s *Property_port_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *Property_port_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *Property_port_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Property_port_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Property_port_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterProperty_port_list(s)
	}
}

func (s *Property_port_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitProperty_port_list(s)
	}
}

func (p *SystemVerilogParser) Property_port_list() (localctx IProperty_port_listContext) {
	this := p
	_ = this

	localctx = NewProperty_port_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 438, SystemVerilogParserRULE_property_port_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4021)
		p.Property_port_item()
	}
	p.SetState(4026)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserCOMMA {
		{
			p.SetState(4022)
			p.Match(SystemVerilogParserCOMMA)
		}
		{
			p.SetState(4023)
			p.Property_port_item()
		}

		p.SetState(4028)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IProperty_port_itemContext is an interface to support dynamic dispatch.
type IProperty_port_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProperty_port_itemContext differentiates from other interfaces.
	IsProperty_port_itemContext()
}

type Property_port_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProperty_port_itemContext() *Property_port_itemContext {
	var p = new(Property_port_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_property_port_item
	return p
}

func (*Property_port_itemContext) IsProperty_port_itemContext() {}

func NewProperty_port_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Property_port_itemContext {
	var p = new(Property_port_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_property_port_item

	return p
}

func (s *Property_port_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Property_port_itemContext) Property_formal_type() IProperty_formal_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProperty_formal_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProperty_formal_typeContext)
}

func (s *Property_port_itemContext) Formal_port_identifier() IFormal_port_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormal_port_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFormal_port_identifierContext)
}

func (s *Property_port_itemContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Property_port_itemContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Property_port_itemContext) KLOCAL() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKLOCAL, 0)
}

func (s *Property_port_itemContext) AllVariable_dimension() []IVariable_dimensionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariable_dimensionContext)(nil)).Elem())
	var tst = make([]IVariable_dimensionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariable_dimensionContext)
		}
	}

	return tst
}

func (s *Property_port_itemContext) Variable_dimension(i int) IVariable_dimensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_dimensionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariable_dimensionContext)
}

func (s *Property_port_itemContext) EQ() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserEQ, 0)
}

func (s *Property_port_itemContext) Property_actual_arg() IProperty_actual_argContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProperty_actual_argContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProperty_actual_argContext)
}

func (s *Property_port_itemContext) Property_lvar_port_direction() IProperty_lvar_port_directionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProperty_lvar_port_directionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProperty_lvar_port_directionContext)
}

func (s *Property_port_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Property_port_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Property_port_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterProperty_port_item(s)
	}
}

func (s *Property_port_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitProperty_port_item(s)
	}
}

func (p *SystemVerilogParser) Property_port_item() (localctx IProperty_port_itemContext) {
	this := p
	_ = this

	localctx = NewProperty_port_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 440, SystemVerilogParserRULE_property_port_item)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4032)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserLPS {
		{
			p.SetState(4029)
			p.Attribute_instance()
		}

		p.SetState(4034)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(4039)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserKLOCAL {
		{
			p.SetState(4035)
			p.Match(SystemVerilogParserKLOCAL)
		}
		p.SetState(4037)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserKINPUT {
			{
				p.SetState(4036)
				p.Property_lvar_port_direction()
			}

		}

	}
	{
		p.SetState(4041)
		p.Property_formal_type()
	}
	{
		p.SetState(4042)
		p.Formal_port_identifier()
	}
	p.SetState(4046)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserLB {
		{
			p.SetState(4043)
			p.Variable_dimension()
		}

		p.SetState(4048)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(4051)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserEQ {
		{
			p.SetState(4049)
			p.Match(SystemVerilogParserEQ)
		}
		{
			p.SetState(4050)
			p.Property_actual_arg()
		}

	}

	return localctx
}

// IProperty_lvar_port_directionContext is an interface to support dynamic dispatch.
type IProperty_lvar_port_directionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProperty_lvar_port_directionContext differentiates from other interfaces.
	IsProperty_lvar_port_directionContext()
}

type Property_lvar_port_directionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProperty_lvar_port_directionContext() *Property_lvar_port_directionContext {
	var p = new(Property_lvar_port_directionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_property_lvar_port_direction
	return p
}

func (*Property_lvar_port_directionContext) IsProperty_lvar_port_directionContext() {}

func NewProperty_lvar_port_directionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Property_lvar_port_directionContext {
	var p = new(Property_lvar_port_directionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_property_lvar_port_direction

	return p
}

func (s *Property_lvar_port_directionContext) GetParser() antlr.Parser { return s.parser }

func (s *Property_lvar_port_directionContext) KINPUT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKINPUT, 0)
}

func (s *Property_lvar_port_directionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Property_lvar_port_directionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Property_lvar_port_directionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterProperty_lvar_port_direction(s)
	}
}

func (s *Property_lvar_port_directionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitProperty_lvar_port_direction(s)
	}
}

func (p *SystemVerilogParser) Property_lvar_port_direction() (localctx IProperty_lvar_port_directionContext) {
	this := p
	_ = this

	localctx = NewProperty_lvar_port_directionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 442, SystemVerilogParserRULE_property_lvar_port_direction)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4053)
		p.Match(SystemVerilogParserKINPUT)
	}

	return localctx
}

// IProperty_formal_typeContext is an interface to support dynamic dispatch.
type IProperty_formal_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProperty_formal_typeContext differentiates from other interfaces.
	IsProperty_formal_typeContext()
}

type Property_formal_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProperty_formal_typeContext() *Property_formal_typeContext {
	var p = new(Property_formal_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_property_formal_type
	return p
}

func (*Property_formal_typeContext) IsProperty_formal_typeContext() {}

func NewProperty_formal_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Property_formal_typeContext {
	var p = new(Property_formal_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_property_formal_type

	return p
}

func (s *Property_formal_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Property_formal_typeContext) Sequence_formal_type() ISequence_formal_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequence_formal_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISequence_formal_typeContext)
}

func (s *Property_formal_typeContext) KPROPERTY() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKPROPERTY, 0)
}

func (s *Property_formal_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Property_formal_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Property_formal_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterProperty_formal_type(s)
	}
}

func (s *Property_formal_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitProperty_formal_type(s)
	}
}

func (p *SystemVerilogParser) Property_formal_type() (localctx IProperty_formal_typeContext) {
	this := p
	_ = this

	localctx = NewProperty_formal_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 444, SystemVerilogParserRULE_property_formal_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4057)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserDUNIT, SystemVerilogParserLB, SystemVerilogParserKBIT, SystemVerilogParserKBYTE, SystemVerilogParserKCHANDLE, SystemVerilogParserKENUM, SystemVerilogParserKEVENT, SystemVerilogParserKINT, SystemVerilogParserKINTEGER, SystemVerilogParserKLOGIC, SystemVerilogParserKLONGINT, SystemVerilogParserKREAL, SystemVerilogParserKREALTIME, SystemVerilogParserKREG, SystemVerilogParserKSEQUENCE, SystemVerilogParserKSHORTINT, SystemVerilogParserKSHORTREAL, SystemVerilogParserKSIGNED, SystemVerilogParserKSTRING, SystemVerilogParserKSTRUCT, SystemVerilogParserKTIME, SystemVerilogParserKTYPE, SystemVerilogParserKUNION, SystemVerilogParserKUNSIGNED, SystemVerilogParserKUNTYPED, SystemVerilogParserKVIRTUAL, SystemVerilogParserSIMPLE_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4055)
			p.Sequence_formal_type()
		}

	case SystemVerilogParserKPROPERTY:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4056)
			p.Match(SystemVerilogParserKPROPERTY)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IProperty_specContext is an interface to support dynamic dispatch.
type IProperty_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProperty_specContext differentiates from other interfaces.
	IsProperty_specContext()
}

type Property_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProperty_specContext() *Property_specContext {
	var p = new(Property_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_property_spec
	return p
}

func (*Property_specContext) IsProperty_specContext() {}

func NewProperty_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Property_specContext {
	var p = new(Property_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_property_spec

	return p
}

func (s *Property_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Property_specContext) Property_expr() IProperty_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProperty_exprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProperty_exprContext)
}

func (s *Property_specContext) Clocking_event() IClocking_eventContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClocking_eventContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClocking_eventContext)
}

func (s *Property_specContext) KDISABLE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKDISABLE, 0)
}

func (s *Property_specContext) KIFF() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKIFF, 0)
}

func (s *Property_specContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Property_specContext) Expression_or_dist() IExpression_or_distContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpression_or_distContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpression_or_distContext)
}

func (s *Property_specContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Property_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Property_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Property_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterProperty_spec(s)
	}
}

func (s *Property_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitProperty_spec(s)
	}
}

func (p *SystemVerilogParser) Property_spec() (localctx IProperty_specContext) {
	this := p
	_ = this

	localctx = NewProperty_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 446, SystemVerilogParserRULE_property_spec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4060)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 458, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4059)
			p.Clocking_event()
		}

	}
	p.SetState(4068)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserKDISABLE {
		{
			p.SetState(4062)
			p.Match(SystemVerilogParserKDISABLE)
		}
		{
			p.SetState(4063)
			p.Match(SystemVerilogParserKIFF)
		}
		{
			p.SetState(4064)
			p.Match(SystemVerilogParserLP)
		}
		{
			p.SetState(4065)
			p.Expression_or_dist()
		}
		{
			p.SetState(4066)
			p.Match(SystemVerilogParserRP)
		}

	}
	{
		p.SetState(4070)
		p.property_expr(0)
	}

	return localctx
}

// IProperty_exprContext is an interface to support dynamic dispatch.
type IProperty_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProperty_exprContext differentiates from other interfaces.
	IsProperty_exprContext()
}

type Property_exprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProperty_exprContext() *Property_exprContext {
	var p = new(Property_exprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_property_expr
	return p
}

func (*Property_exprContext) IsProperty_exprContext() {}

func NewProperty_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Property_exprContext {
	var p = new(Property_exprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_property_expr

	return p
}

func (s *Property_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Property_exprContext) Sequence_expr() ISequence_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequence_exprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISequence_exprContext)
}

func (s *Property_exprContext) AllProperty_expr() []IProperty_exprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IProperty_exprContext)(nil)).Elem())
	var tst = make([]IProperty_exprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IProperty_exprContext)
		}
	}

	return tst
}

func (s *Property_exprContext) Property_expr(i int) IProperty_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProperty_exprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IProperty_exprContext)
}

func (s *Property_exprContext) BARARROW() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserBARARROW, 0)
}

func (s *Property_exprContext) BAREQGT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserBAREQGT, 0)
}

func (s *Property_exprContext) PMP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserPMP, 0)
}

func (s *Property_exprContext) PEP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserPEP, 0)
}

func (s *Property_exprContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Property_exprContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Property_exprContext) KSTRONG() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKSTRONG, 0)
}

func (s *Property_exprContext) KWEAK() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKWEAK, 0)
}

func (s *Property_exprContext) KNOT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKNOT, 0)
}

func (s *Property_exprContext) KIF() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKIF, 0)
}

func (s *Property_exprContext) Expression_or_dist() IExpression_or_distContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpression_or_distContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpression_or_distContext)
}

func (s *Property_exprContext) KELSE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKELSE, 0)
}

func (s *Property_exprContext) KCASE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKCASE, 0)
}

func (s *Property_exprContext) AllProperty_case_item() []IProperty_case_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IProperty_case_itemContext)(nil)).Elem())
	var tst = make([]IProperty_case_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IProperty_case_itemContext)
		}
	}

	return tst
}

func (s *Property_exprContext) Property_case_item(i int) IProperty_case_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProperty_case_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IProperty_case_itemContext)
}

func (s *Property_exprContext) KENDCASE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKENDCASE, 0)
}

func (s *Property_exprContext) KNEXTTIME() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKNEXTTIME, 0)
}

func (s *Property_exprContext) KS_NEXTTIME() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKS_NEXTTIME, 0)
}

func (s *Property_exprContext) LB() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLB, 0)
}

func (s *Property_exprContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Property_exprContext) RB() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRB, 0)
}

func (s *Property_exprContext) KALWAYS() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKALWAYS, 0)
}

func (s *Property_exprContext) KS_EVENTUALLY() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKS_EVENTUALLY, 0)
}

func (s *Property_exprContext) Cycle_delay_const_range_expression() ICycle_delay_const_range_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICycle_delay_const_range_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICycle_delay_const_range_expressionContext)
}

func (s *Property_exprContext) Constant_range() IConstant_rangeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_rangeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_rangeContext)
}

func (s *Property_exprContext) KS_ALWAYS() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKS_ALWAYS, 0)
}

func (s *Property_exprContext) KEVENTUALLY() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKEVENTUALLY, 0)
}

func (s *Property_exprContext) KACCEPT_ON() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKACCEPT_ON, 0)
}

func (s *Property_exprContext) KREJECT_ON() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKREJECT_ON, 0)
}

func (s *Property_exprContext) KSYNC_ACCEPT_ON() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKSYNC_ACCEPT_ON, 0)
}

func (s *Property_exprContext) KSYNC_REJECT_ON() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKSYNC_REJECT_ON, 0)
}

func (s *Property_exprContext) Property_instance() IProperty_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProperty_instanceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProperty_instanceContext)
}

func (s *Property_exprContext) Clocking_event() IClocking_eventContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClocking_eventContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClocking_eventContext)
}

func (s *Property_exprContext) KOR() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKOR, 0)
}

func (s *Property_exprContext) KAND() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKAND, 0)
}

func (s *Property_exprContext) KUNTIL() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKUNTIL, 0)
}

func (s *Property_exprContext) KS_UNTIL() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKS_UNTIL, 0)
}

func (s *Property_exprContext) KUNTIL_WITH() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKUNTIL_WITH, 0)
}

func (s *Property_exprContext) KS_UNTIL_WITH() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKS_UNTIL_WITH, 0)
}

func (s *Property_exprContext) KIMPLIES() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKIMPLIES, 0)
}

func (s *Property_exprContext) KIFF() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKIFF, 0)
}

func (s *Property_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Property_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Property_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterProperty_expr(s)
	}
}

func (s *Property_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitProperty_expr(s)
	}
}

func (p *SystemVerilogParser) Property_expr() (localctx IProperty_exprContext) {
	return p.property_expr(0)
}

func (p *SystemVerilogParser) property_expr(_p int) (localctx IProperty_exprContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewProperty_exprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IProperty_exprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 448
	p.EnterRecursionRule(localctx, 448, SystemVerilogParserRULE_property_expr, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4143)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 465, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4073)
			p.sequence_expr(0)
		}
		p.SetState(4076)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 460, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4074)
				_la = p.GetTokenStream().LA(1)

				if !(_la == SystemVerilogParserPMP || _la == SystemVerilogParserPEP || _la == SystemVerilogParserBAREQGT || _la == SystemVerilogParserBARARROW) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(4075)
				p.property_expr(0)
			}

		}

	case 2:
		{
			p.SetState(4078)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SystemVerilogParserKSTRONG || _la == SystemVerilogParserKWEAK) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(4079)
			p.Match(SystemVerilogParserLP)
		}
		{
			p.SetState(4080)
			p.sequence_expr(0)
		}
		{
			p.SetState(4081)
			p.Match(SystemVerilogParserRP)
		}

	case 3:
		{
			p.SetState(4083)
			p.Match(SystemVerilogParserLP)
		}
		{
			p.SetState(4084)
			p.property_expr(0)
		}
		{
			p.SetState(4085)
			p.Match(SystemVerilogParserRP)
		}

	case 4:
		{
			p.SetState(4087)
			p.Match(SystemVerilogParserKNOT)
		}
		{
			p.SetState(4088)
			p.property_expr(10)
		}

	case 5:
		{
			p.SetState(4089)
			p.Match(SystemVerilogParserKIF)
		}
		{
			p.SetState(4090)
			p.Match(SystemVerilogParserLP)
		}
		{
			p.SetState(4091)
			p.Expression_or_dist()
		}
		{
			p.SetState(4092)
			p.Match(SystemVerilogParserRP)
		}
		{
			p.SetState(4093)
			p.property_expr(0)
		}
		p.SetState(4096)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 461, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4094)
				p.Match(SystemVerilogParserKELSE)
			}
			{
				p.SetState(4095)
				p.property_expr(0)
			}

		}

	case 6:
		{
			p.SetState(4098)
			p.Match(SystemVerilogParserKCASE)
		}
		{
			p.SetState(4099)
			p.Match(SystemVerilogParserLP)
		}
		{
			p.SetState(4100)
			p.Expression_or_dist()
		}
		{
			p.SetState(4101)
			p.Match(SystemVerilogParserRP)
		}
		{
			p.SetState(4102)
			p.Property_case_item()
		}
		p.SetState(4106)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SystemVerilogParserMINUS)|(1<<SystemVerilogParserMINUSMINS)|(1<<SystemVerilogParserNOT)|(1<<SystemVerilogParserDOLLAR)|(1<<SystemVerilogParserDROOT)|(1<<SystemVerilogParserDUNIT)|(1<<SystemVerilogParserAND)|(1<<SystemVerilogParserLP))) != 0) || (((_la-51)&-(0x1f+1)) == 0 && ((1<<uint((_la-51)))&((1<<(SystemVerilogParserQUOTE-51))|(1<<(SystemVerilogParserCARET-51))|(1<<(SystemVerilogParserCARETSQUIG-51))|(1<<(SystemVerilogParserLC-51))|(1<<(SystemVerilogParserBAR-51))|(1<<(SystemVerilogParserSQUIG-51))|(1<<(SystemVerilogParserSQUIGAND-51))|(1<<(SystemVerilogParserSQUIGCARET-51))|(1<<(SystemVerilogParserSQUIGBAR-51))|(1<<(SystemVerilogParserPLUS-51))|(1<<(SystemVerilogParserPLUSPLUS-51)))) != 0) || (((_la-109)&-(0x1f+1)) == 0 && ((1<<uint((_la-109)))&((1<<(SystemVerilogParserKBIT-109))|(1<<(SystemVerilogParserKBYTE-109))|(1<<(SystemVerilogParserKCONST-109))|(1<<(SystemVerilogParserKDEFAULT-109)))) != 0) || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SystemVerilogParserKINT-195))|(1<<(SystemVerilogParserKINTEGER-195))|(1<<(SystemVerilogParserKLOCAL-195))|(1<<(SystemVerilogParserKLOGIC-195))|(1<<(SystemVerilogParserKLONGINT-195)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(SystemVerilogParserKNULL-228))|(1<<(SystemVerilogParserKRANDOMIZE-228))|(1<<(SystemVerilogParserKREAL-228))|(1<<(SystemVerilogParserKREALTIME-228))|(1<<(SystemVerilogParserKREG-228)))) != 0) || (((_la-276)&-(0x1f+1)) == 0 && ((1<<uint((_la-276)))&((1<<(SystemVerilogParserKSHORTINT-276))|(1<<(SystemVerilogParserKSHORTREAL-276))|(1<<(SystemVerilogParserKSIGNED-276))|(1<<(SystemVerilogParserKSTD-276))|(1<<(SystemVerilogParserKSTRING-276))|(1<<(SystemVerilogParserKSUPER-276))|(1<<(SystemVerilogParserKTAGGED-276))|(1<<(SystemVerilogParserKTHIS-276))|(1<<(SystemVerilogParserKTIME-276)))) != 0) || _la == SystemVerilogParserKTYPE || _la == SystemVerilogParserKUNSIGNED || (((_la-345)&-(0x1f+1)) == 0 && ((1<<uint((_la-345)))&((1<<(SystemVerilogParserTIME_LITERAL-345))|(1<<(SystemVerilogParserDECIMAL_NUMBER-345))|(1<<(SystemVerilogParserBINARY_NUMBER-345))|(1<<(SystemVerilogParserOCTAL_NUMBER-345))|(1<<(SystemVerilogParserHEX_NUMBER-345))|(1<<(SystemVerilogParserREAL_NUMBER-345))|(1<<(SystemVerilogParserUNSIGNED_NUMBER-345))|(1<<(SystemVerilogParserSTRING_LITERAL-345))|(1<<(SystemVerilogParserSIMPLE_IDENTIFIER-345))|(1<<(SystemVerilogParserSYSTEM_TF_IDENTIFIER-345)))) != 0) {
			{
				p.SetState(4103)
				p.Property_case_item()
			}

			p.SetState(4108)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(4109)
			p.Match(SystemVerilogParserKENDCASE)
		}

	case 7:
		{
			p.SetState(4111)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SystemVerilogParserKNEXTTIME || _la == SystemVerilogParserKS_NEXTTIME) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(4116)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserLB {
			{
				p.SetState(4112)
				p.Match(SystemVerilogParserLB)
			}
			{
				p.SetState(4113)
				p.constant_expression(0)
			}
			{
				p.SetState(4114)
				p.Match(SystemVerilogParserRB)
			}

		}
		{
			p.SetState(4118)
			p.property_expr(6)
		}

	case 8:
		{
			p.SetState(4119)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SystemVerilogParserKALWAYS || _la == SystemVerilogParserKS_EVENTUALLY) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(4124)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserLB {
			{
				p.SetState(4120)
				p.Match(SystemVerilogParserLB)
			}
			{
				p.SetState(4121)
				p.Cycle_delay_const_range_expression()
			}
			{
				p.SetState(4122)
				p.Match(SystemVerilogParserRB)
			}

		}
		{
			p.SetState(4126)
			p.property_expr(5)
		}

	case 9:
		{
			p.SetState(4127)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SystemVerilogParserKEVENTUALLY || _la == SystemVerilogParserKS_ALWAYS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(4128)
			p.Match(SystemVerilogParserLB)
		}
		{
			p.SetState(4129)
			p.Constant_range()
		}
		{
			p.SetState(4130)
			p.Match(SystemVerilogParserRB)
		}
		{
			p.SetState(4131)
			p.property_expr(4)
		}

	case 10:
		{
			p.SetState(4133)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SystemVerilogParserKACCEPT_ON || _la == SystemVerilogParserKREJECT_ON || _la == SystemVerilogParserKSYNC_ACCEPT_ON || _la == SystemVerilogParserKSYNC_REJECT_ON) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(4134)
			p.Match(SystemVerilogParserLP)
		}
		{
			p.SetState(4135)
			p.Expression_or_dist()
		}
		{
			p.SetState(4136)
			p.Match(SystemVerilogParserRP)
		}
		{
			p.SetState(4137)
			p.property_expr(3)
		}

	case 11:
		{
			p.SetState(4139)
			p.Property_instance()
		}

	case 12:
		{
			p.SetState(4140)
			p.Clocking_event()
		}
		{
			p.SetState(4141)
			p.property_expr(1)
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(4150)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 466, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewProperty_exprContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, SystemVerilogParserRULE_property_expr)
			p.SetState(4145)

			if !(p.Precpred(p.GetParserRuleContext(), 9)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 9)", ""))
			}
			{
				p.SetState(4146)
				_la = p.GetTokenStream().LA(1)

				if !(_la == SystemVerilogParserBAREQGT || _la == SystemVerilogParserBARARROW || _la == SystemVerilogParserKAND || _la == SystemVerilogParserKIFF || _la == SystemVerilogParserKIMPLIES || _la == SystemVerilogParserKOR || _la == SystemVerilogParserKS_UNTIL || _la == SystemVerilogParserKS_UNTIL_WITH || _la == SystemVerilogParserKUNTIL || _la == SystemVerilogParserKUNTIL_WITH) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(4147)
				p.property_expr(10)
			}

		}
		p.SetState(4152)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 466, p.GetParserRuleContext())
	}

	return localctx
}

// IProperty_case_itemContext is an interface to support dynamic dispatch.
type IProperty_case_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProperty_case_itemContext differentiates from other interfaces.
	IsProperty_case_itemContext()
}

type Property_case_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProperty_case_itemContext() *Property_case_itemContext {
	var p = new(Property_case_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_property_case_item
	return p
}

func (*Property_case_itemContext) IsProperty_case_itemContext() {}

func NewProperty_case_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Property_case_itemContext {
	var p = new(Property_case_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_property_case_item

	return p
}

func (s *Property_case_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Property_case_itemContext) AllExpression_or_dist() []IExpression_or_distContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpression_or_distContext)(nil)).Elem())
	var tst = make([]IExpression_or_distContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpression_or_distContext)
		}
	}

	return tst
}

func (s *Property_case_itemContext) Expression_or_dist(i int) IExpression_or_distContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpression_or_distContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpression_or_distContext)
}

func (s *Property_case_itemContext) COLON() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOLON, 0)
}

func (s *Property_case_itemContext) Property_expr() IProperty_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProperty_exprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProperty_exprContext)
}

func (s *Property_case_itemContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Property_case_itemContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *Property_case_itemContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *Property_case_itemContext) KDEFAULT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKDEFAULT, 0)
}

func (s *Property_case_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Property_case_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Property_case_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterProperty_case_item(s)
	}
}

func (s *Property_case_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitProperty_case_item(s)
	}
}

func (p *SystemVerilogParser) Property_case_item() (localctx IProperty_case_itemContext) {
	this := p
	_ = this

	localctx = NewProperty_case_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 450, SystemVerilogParserRULE_property_case_item)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4172)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserMINUS, SystemVerilogParserMINUSMINS, SystemVerilogParserNOT, SystemVerilogParserDOLLAR, SystemVerilogParserDROOT, SystemVerilogParserDUNIT, SystemVerilogParserAND, SystemVerilogParserLP, SystemVerilogParserQUOTE, SystemVerilogParserCARET, SystemVerilogParserCARETSQUIG, SystemVerilogParserLC, SystemVerilogParserBAR, SystemVerilogParserSQUIG, SystemVerilogParserSQUIGAND, SystemVerilogParserSQUIGCARET, SystemVerilogParserSQUIGBAR, SystemVerilogParserPLUS, SystemVerilogParserPLUSPLUS, SystemVerilogParserKBIT, SystemVerilogParserKBYTE, SystemVerilogParserKCONST, SystemVerilogParserKINT, SystemVerilogParserKINTEGER, SystemVerilogParserKLOCAL, SystemVerilogParserKLOGIC, SystemVerilogParserKLONGINT, SystemVerilogParserKNULL, SystemVerilogParserKRANDOMIZE, SystemVerilogParserKREAL, SystemVerilogParserKREALTIME, SystemVerilogParserKREG, SystemVerilogParserKSHORTINT, SystemVerilogParserKSHORTREAL, SystemVerilogParserKSIGNED, SystemVerilogParserKSTD, SystemVerilogParserKSTRING, SystemVerilogParserKSUPER, SystemVerilogParserKTAGGED, SystemVerilogParserKTHIS, SystemVerilogParserKTIME, SystemVerilogParserKTYPE, SystemVerilogParserKUNSIGNED, SystemVerilogParserTIME_LITERAL, SystemVerilogParserDECIMAL_NUMBER, SystemVerilogParserBINARY_NUMBER, SystemVerilogParserOCTAL_NUMBER, SystemVerilogParserHEX_NUMBER, SystemVerilogParserREAL_NUMBER, SystemVerilogParserUNSIGNED_NUMBER, SystemVerilogParserSTRING_LITERAL, SystemVerilogParserSIMPLE_IDENTIFIER, SystemVerilogParserSYSTEM_TF_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4153)
			p.Expression_or_dist()
		}
		p.SetState(4158)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserCOMMA {
			{
				p.SetState(4154)
				p.Match(SystemVerilogParserCOMMA)
			}
			{
				p.SetState(4155)
				p.Expression_or_dist()
			}

			p.SetState(4160)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(4161)
			p.Match(SystemVerilogParserCOLON)
		}
		{
			p.SetState(4162)
			p.property_expr(0)
		}
		{
			p.SetState(4163)
			p.Match(SystemVerilogParserSEMI)
		}

	case SystemVerilogParserKDEFAULT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4165)
			p.Match(SystemVerilogParserKDEFAULT)
		}
		p.SetState(4167)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserCOLON {
			{
				p.SetState(4166)
				p.Match(SystemVerilogParserCOLON)
			}

		}
		{
			p.SetState(4169)
			p.property_expr(0)
		}
		{
			p.SetState(4170)
			p.Match(SystemVerilogParserSEMI)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISequence_declarationContext is an interface to support dynamic dispatch.
type ISequence_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSequence_declarationContext differentiates from other interfaces.
	IsSequence_declarationContext()
}

type Sequence_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySequence_declarationContext() *Sequence_declarationContext {
	var p = new(Sequence_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_sequence_declaration
	return p
}

func (*Sequence_declarationContext) IsSequence_declarationContext() {}

func NewSequence_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sequence_declarationContext {
	var p = new(Sequence_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_sequence_declaration

	return p
}

func (s *Sequence_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Sequence_declarationContext) KSEQUENCE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKSEQUENCE, 0)
}

func (s *Sequence_declarationContext) AllSequence_identifier() []ISequence_identifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISequence_identifierContext)(nil)).Elem())
	var tst = make([]ISequence_identifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISequence_identifierContext)
		}
	}

	return tst
}

func (s *Sequence_declarationContext) Sequence_identifier(i int) ISequence_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequence_identifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISequence_identifierContext)
}

func (s *Sequence_declarationContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserSEMI)
}

func (s *Sequence_declarationContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, i)
}

func (s *Sequence_declarationContext) Sequence_expr() ISequence_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequence_exprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISequence_exprContext)
}

func (s *Sequence_declarationContext) KENDSEQUENCE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKENDSEQUENCE, 0)
}

func (s *Sequence_declarationContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Sequence_declarationContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Sequence_declarationContext) AllAssertion_variable_declaration() []IAssertion_variable_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAssertion_variable_declarationContext)(nil)).Elem())
	var tst = make([]IAssertion_variable_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAssertion_variable_declarationContext)
		}
	}

	return tst
}

func (s *Sequence_declarationContext) Assertion_variable_declaration(i int) IAssertion_variable_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssertion_variable_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAssertion_variable_declarationContext)
}

func (s *Sequence_declarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOLON, 0)
}

func (s *Sequence_declarationContext) Sequence_port_list() ISequence_port_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequence_port_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISequence_port_listContext)
}

func (s *Sequence_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sequence_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sequence_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterSequence_declaration(s)
	}
}

func (s *Sequence_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitSequence_declaration(s)
	}
}

func (p *SystemVerilogParser) Sequence_declaration() (localctx ISequence_declarationContext) {
	this := p
	_ = this

	localctx = NewSequence_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 452, SystemVerilogParserRULE_sequence_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4174)
		p.Match(SystemVerilogParserKSEQUENCE)
	}
	{
		p.SetState(4175)
		p.Sequence_identifier()
	}
	p.SetState(4181)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserLP {
		{
			p.SetState(4176)
			p.Match(SystemVerilogParserLP)
		}
		p.SetState(4178)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la-19)&-(0x1f+1)) == 0 && ((1<<uint((_la-19)))&((1<<(SystemVerilogParserDUNIT-19))|(1<<(SystemVerilogParserLPS-19))|(1<<(SystemVerilogParserLB-19)))) != 0) || (((_la-109)&-(0x1f+1)) == 0 && ((1<<uint((_la-109)))&((1<<(SystemVerilogParserKBIT-109))|(1<<(SystemVerilogParserKBYTE-109))|(1<<(SystemVerilogParserKCHANDLE-109)))) != 0) || _la == SystemVerilogParserKENUM || _la == SystemVerilogParserKEVENT || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SystemVerilogParserKINT-195))|(1<<(SystemVerilogParserKINTEGER-195))|(1<<(SystemVerilogParserKLOCAL-195))|(1<<(SystemVerilogParserKLOGIC-195))|(1<<(SystemVerilogParserKLONGINT-195)))) != 0) || (((_la-255)&-(0x1f+1)) == 0 && ((1<<uint((_la-255)))&((1<<(SystemVerilogParserKREAL-255))|(1<<(SystemVerilogParserKREALTIME-255))|(1<<(SystemVerilogParserKREG-255))|(1<<(SystemVerilogParserKSEQUENCE-255))|(1<<(SystemVerilogParserKSHORTINT-255))|(1<<(SystemVerilogParserKSHORTREAL-255))|(1<<(SystemVerilogParserKSIGNED-255)))) != 0) || (((_la-287)&-(0x1f+1)) == 0 && ((1<<uint((_la-287)))&((1<<(SystemVerilogParserKSTRING-287))|(1<<(SystemVerilogParserKSTRUCT-287))|(1<<(SystemVerilogParserKTIME-287))|(1<<(SystemVerilogParserKTYPE-287))|(1<<(SystemVerilogParserKUNION-287)))) != 0) || (((_la-319)&-(0x1f+1)) == 0 && ((1<<uint((_la-319)))&((1<<(SystemVerilogParserKUNSIGNED-319))|(1<<(SystemVerilogParserKUNTYPED-319))|(1<<(SystemVerilogParserKVIRTUAL-319)))) != 0) || _la == SystemVerilogParserSIMPLE_IDENTIFIER {
			{
				p.SetState(4177)
				p.Sequence_port_list()
			}

		}
		{
			p.SetState(4180)
			p.Match(SystemVerilogParserRP)
		}

	}
	{
		p.SetState(4183)
		p.Match(SystemVerilogParserSEMI)
	}
	p.SetState(4187)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 472, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4184)
				p.Assertion_variable_declaration()
			}

		}
		p.SetState(4189)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 472, p.GetParserRuleContext())
	}
	{
		p.SetState(4190)
		p.sequence_expr(0)
	}
	p.SetState(4192)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserSEMI {
		{
			p.SetState(4191)
			p.Match(SystemVerilogParserSEMI)
		}

	}
	{
		p.SetState(4194)
		p.Match(SystemVerilogParserKENDSEQUENCE)
	}
	p.SetState(4197)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserCOLON {
		{
			p.SetState(4195)
			p.Match(SystemVerilogParserCOLON)
		}
		{
			p.SetState(4196)
			p.Sequence_identifier()
		}

	}

	return localctx
}

// ISequence_port_listContext is an interface to support dynamic dispatch.
type ISequence_port_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSequence_port_listContext differentiates from other interfaces.
	IsSequence_port_listContext()
}

type Sequence_port_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySequence_port_listContext() *Sequence_port_listContext {
	var p = new(Sequence_port_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_sequence_port_list
	return p
}

func (*Sequence_port_listContext) IsSequence_port_listContext() {}

func NewSequence_port_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sequence_port_listContext {
	var p = new(Sequence_port_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_sequence_port_list

	return p
}

func (s *Sequence_port_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Sequence_port_listContext) AllSequence_port_item() []ISequence_port_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISequence_port_itemContext)(nil)).Elem())
	var tst = make([]ISequence_port_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISequence_port_itemContext)
		}
	}

	return tst
}

func (s *Sequence_port_listContext) Sequence_port_item(i int) ISequence_port_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequence_port_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISequence_port_itemContext)
}

func (s *Sequence_port_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *Sequence_port_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *Sequence_port_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sequence_port_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sequence_port_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterSequence_port_list(s)
	}
}

func (s *Sequence_port_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitSequence_port_list(s)
	}
}

func (p *SystemVerilogParser) Sequence_port_list() (localctx ISequence_port_listContext) {
	this := p
	_ = this

	localctx = NewSequence_port_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 454, SystemVerilogParserRULE_sequence_port_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4199)
		p.Sequence_port_item()
	}
	p.SetState(4204)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserCOMMA {
		{
			p.SetState(4200)
			p.Match(SystemVerilogParserCOMMA)
		}
		{
			p.SetState(4201)
			p.Sequence_port_item()
		}

		p.SetState(4206)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISequence_port_itemContext is an interface to support dynamic dispatch.
type ISequence_port_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSequence_port_itemContext differentiates from other interfaces.
	IsSequence_port_itemContext()
}

type Sequence_port_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySequence_port_itemContext() *Sequence_port_itemContext {
	var p = new(Sequence_port_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_sequence_port_item
	return p
}

func (*Sequence_port_itemContext) IsSequence_port_itemContext() {}

func NewSequence_port_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sequence_port_itemContext {
	var p = new(Sequence_port_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_sequence_port_item

	return p
}

func (s *Sequence_port_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Sequence_port_itemContext) Sequence_formal_type() ISequence_formal_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequence_formal_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISequence_formal_typeContext)
}

func (s *Sequence_port_itemContext) Formal_port_identifier() IFormal_port_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormal_port_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFormal_port_identifierContext)
}

func (s *Sequence_port_itemContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Sequence_port_itemContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Sequence_port_itemContext) KLOCAL() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKLOCAL, 0)
}

func (s *Sequence_port_itemContext) AllVariable_dimension() []IVariable_dimensionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariable_dimensionContext)(nil)).Elem())
	var tst = make([]IVariable_dimensionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariable_dimensionContext)
		}
	}

	return tst
}

func (s *Sequence_port_itemContext) Variable_dimension(i int) IVariable_dimensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_dimensionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariable_dimensionContext)
}

func (s *Sequence_port_itemContext) EQ() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserEQ, 0)
}

func (s *Sequence_port_itemContext) Sequence_actual_arg() ISequence_actual_argContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequence_actual_argContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISequence_actual_argContext)
}

func (s *Sequence_port_itemContext) Sequence_lvar_port_direction() ISequence_lvar_port_directionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequence_lvar_port_directionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISequence_lvar_port_directionContext)
}

func (s *Sequence_port_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sequence_port_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sequence_port_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterSequence_port_item(s)
	}
}

func (s *Sequence_port_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitSequence_port_item(s)
	}
}

func (p *SystemVerilogParser) Sequence_port_item() (localctx ISequence_port_itemContext) {
	this := p
	_ = this

	localctx = NewSequence_port_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 456, SystemVerilogParserRULE_sequence_port_item)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4210)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserLPS {
		{
			p.SetState(4207)
			p.Attribute_instance()
		}

		p.SetState(4212)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(4217)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserKLOCAL {
		{
			p.SetState(4213)
			p.Match(SystemVerilogParserKLOCAL)
		}
		p.SetState(4215)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserKINOUT || _la == SystemVerilogParserKINPUT || _la == SystemVerilogParserKOUTPUT {
			{
				p.SetState(4214)
				p.Sequence_lvar_port_direction()
			}

		}

	}
	{
		p.SetState(4219)
		p.Sequence_formal_type()
	}
	{
		p.SetState(4220)
		p.Formal_port_identifier()
	}
	p.SetState(4224)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserLB {
		{
			p.SetState(4221)
			p.Variable_dimension()
		}

		p.SetState(4226)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(4229)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserEQ {
		{
			p.SetState(4227)
			p.Match(SystemVerilogParserEQ)
		}
		{
			p.SetState(4228)
			p.Sequence_actual_arg()
		}

	}

	return localctx
}

// ISequence_lvar_port_directionContext is an interface to support dynamic dispatch.
type ISequence_lvar_port_directionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSequence_lvar_port_directionContext differentiates from other interfaces.
	IsSequence_lvar_port_directionContext()
}

type Sequence_lvar_port_directionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySequence_lvar_port_directionContext() *Sequence_lvar_port_directionContext {
	var p = new(Sequence_lvar_port_directionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_sequence_lvar_port_direction
	return p
}

func (*Sequence_lvar_port_directionContext) IsSequence_lvar_port_directionContext() {}

func NewSequence_lvar_port_directionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sequence_lvar_port_directionContext {
	var p = new(Sequence_lvar_port_directionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_sequence_lvar_port_direction

	return p
}

func (s *Sequence_lvar_port_directionContext) GetParser() antlr.Parser { return s.parser }

func (s *Sequence_lvar_port_directionContext) KINPUT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKINPUT, 0)
}

func (s *Sequence_lvar_port_directionContext) KINOUT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKINOUT, 0)
}

func (s *Sequence_lvar_port_directionContext) KOUTPUT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKOUTPUT, 0)
}

func (s *Sequence_lvar_port_directionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sequence_lvar_port_directionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sequence_lvar_port_directionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterSequence_lvar_port_direction(s)
	}
}

func (s *Sequence_lvar_port_directionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitSequence_lvar_port_direction(s)
	}
}

func (p *SystemVerilogParser) Sequence_lvar_port_direction() (localctx ISequence_lvar_port_directionContext) {
	this := p
	_ = this

	localctx = NewSequence_lvar_port_directionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 458, SystemVerilogParserRULE_sequence_lvar_port_direction)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4231)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SystemVerilogParserKINOUT || _la == SystemVerilogParserKINPUT || _la == SystemVerilogParserKOUTPUT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ISequence_formal_typeContext is an interface to support dynamic dispatch.
type ISequence_formal_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSequence_formal_typeContext differentiates from other interfaces.
	IsSequence_formal_typeContext()
}

type Sequence_formal_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySequence_formal_typeContext() *Sequence_formal_typeContext {
	var p = new(Sequence_formal_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_sequence_formal_type
	return p
}

func (*Sequence_formal_typeContext) IsSequence_formal_typeContext() {}

func NewSequence_formal_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sequence_formal_typeContext {
	var p = new(Sequence_formal_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_sequence_formal_type

	return p
}

func (s *Sequence_formal_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Sequence_formal_typeContext) Data_type_or_implicit() IData_type_or_implicitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IData_type_or_implicitContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IData_type_or_implicitContext)
}

func (s *Sequence_formal_typeContext) KSEQUENCE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKSEQUENCE, 0)
}

func (s *Sequence_formal_typeContext) KUNTYPED() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKUNTYPED, 0)
}

func (s *Sequence_formal_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sequence_formal_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sequence_formal_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterSequence_formal_type(s)
	}
}

func (s *Sequence_formal_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitSequence_formal_type(s)
	}
}

func (p *SystemVerilogParser) Sequence_formal_type() (localctx ISequence_formal_typeContext) {
	this := p
	_ = this

	localctx = NewSequence_formal_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 460, SystemVerilogParserRULE_sequence_formal_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4236)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserDUNIT, SystemVerilogParserLB, SystemVerilogParserKBIT, SystemVerilogParserKBYTE, SystemVerilogParserKCHANDLE, SystemVerilogParserKENUM, SystemVerilogParserKEVENT, SystemVerilogParserKINT, SystemVerilogParserKINTEGER, SystemVerilogParserKLOGIC, SystemVerilogParserKLONGINT, SystemVerilogParserKREAL, SystemVerilogParserKREALTIME, SystemVerilogParserKREG, SystemVerilogParserKSHORTINT, SystemVerilogParserKSHORTREAL, SystemVerilogParserKSIGNED, SystemVerilogParserKSTRING, SystemVerilogParserKSTRUCT, SystemVerilogParserKTIME, SystemVerilogParserKTYPE, SystemVerilogParserKUNION, SystemVerilogParserKUNSIGNED, SystemVerilogParserKVIRTUAL, SystemVerilogParserSIMPLE_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4233)
			p.Data_type_or_implicit()
		}

	case SystemVerilogParserKSEQUENCE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4234)
			p.Match(SystemVerilogParserKSEQUENCE)
		}

	case SystemVerilogParserKUNTYPED:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4235)
			p.Match(SystemVerilogParserKUNTYPED)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISequence_exprContext is an interface to support dynamic dispatch.
type ISequence_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSequence_exprContext differentiates from other interfaces.
	IsSequence_exprContext()
}

type Sequence_exprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySequence_exprContext() *Sequence_exprContext {
	var p = new(Sequence_exprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_sequence_expr
	return p
}

func (*Sequence_exprContext) IsSequence_exprContext() {}

func NewSequence_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sequence_exprContext {
	var p = new(Sequence_exprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_sequence_expr

	return p
}

func (s *Sequence_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Sequence_exprContext) AllCycle_delay_range() []ICycle_delay_rangeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICycle_delay_rangeContext)(nil)).Elem())
	var tst = make([]ICycle_delay_rangeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICycle_delay_rangeContext)
		}
	}

	return tst
}

func (s *Sequence_exprContext) Cycle_delay_range(i int) ICycle_delay_rangeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICycle_delay_rangeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICycle_delay_rangeContext)
}

func (s *Sequence_exprContext) AllSequence_expr() []ISequence_exprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISequence_exprContext)(nil)).Elem())
	var tst = make([]ISequence_exprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISequence_exprContext)
		}
	}

	return tst
}

func (s *Sequence_exprContext) Sequence_expr(i int) ISequence_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequence_exprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISequence_exprContext)
}

func (s *Sequence_exprContext) Expression_or_dist() IExpression_or_distContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpression_or_distContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpression_or_distContext)
}

func (s *Sequence_exprContext) KTHROUGHOUT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKTHROUGHOUT, 0)
}

func (s *Sequence_exprContext) Boolean_abbrev() IBoolean_abbrevContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBoolean_abbrevContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBoolean_abbrevContext)
}

func (s *Sequence_exprContext) Sequence_instance() ISequence_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequence_instanceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISequence_instanceContext)
}

func (s *Sequence_exprContext) Sequence_abbrev() ISequence_abbrevContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequence_abbrevContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISequence_abbrevContext)
}

func (s *Sequence_exprContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Sequence_exprContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Sequence_exprContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *Sequence_exprContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *Sequence_exprContext) AllSequence_match_item() []ISequence_match_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISequence_match_itemContext)(nil)).Elem())
	var tst = make([]ISequence_match_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISequence_match_itemContext)
		}
	}

	return tst
}

func (s *Sequence_exprContext) Sequence_match_item(i int) ISequence_match_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequence_match_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISequence_match_itemContext)
}

func (s *Sequence_exprContext) KFIRST_MATCH() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKFIRST_MATCH, 0)
}

func (s *Sequence_exprContext) Clocking_event() IClocking_eventContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClocking_eventContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClocking_eventContext)
}

func (s *Sequence_exprContext) KAND() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKAND, 0)
}

func (s *Sequence_exprContext) KINTERSECT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKINTERSECT, 0)
}

func (s *Sequence_exprContext) KOR() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKOR, 0)
}

func (s *Sequence_exprContext) KWITHIN() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKWITHIN, 0)
}

func (s *Sequence_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sequence_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sequence_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterSequence_expr(s)
	}
}

func (s *Sequence_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitSequence_expr(s)
	}
}

func (p *SystemVerilogParser) Sequence_expr() (localctx ISequence_exprContext) {
	return p.sequence_expr(0)
}

func (p *SystemVerilogParser) sequence_expr(_p int) (localctx ISequence_exprContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewSequence_exprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ISequence_exprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 462
	p.EnterRecursionRule(localctx, 462, SystemVerilogParserRULE_sequence_expr, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4289)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 489, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4239)
			p.Cycle_delay_range()
		}
		{
			p.SetState(4240)
			p.sequence_expr(0)
		}
		p.SetState(4246)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 482, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(4241)
					p.Cycle_delay_range()
				}
				{
					p.SetState(4242)
					p.sequence_expr(0)
				}

			}
			p.SetState(4248)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 482, p.GetParserRuleContext())
		}

	case 2:
		{
			p.SetState(4249)
			p.Expression_or_dist()
		}
		p.SetState(4255)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 484, p.GetParserRuleContext()) {
		case 1:
			p.SetState(4251)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 483, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(4250)
					p.Boolean_abbrev()
				}

			}

		case 2:
			{
				p.SetState(4253)
				p.Match(SystemVerilogParserKTHROUGHOUT)
			}
			{
				p.SetState(4254)
				p.sequence_expr(0)
			}

		}

	case 3:
		{
			p.SetState(4257)
			p.Sequence_instance()
		}
		p.SetState(4259)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 485, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4258)
				p.Sequence_abbrev()
			}

		}

	case 4:
		{
			p.SetState(4261)
			p.Match(SystemVerilogParserLP)
		}
		{
			p.SetState(4262)
			p.sequence_expr(0)
		}
		p.SetState(4267)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserCOMMA {
			{
				p.SetState(4263)
				p.Match(SystemVerilogParserCOMMA)
			}
			{
				p.SetState(4264)
				p.Sequence_match_item()
			}

			p.SetState(4269)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(4270)
			p.Match(SystemVerilogParserRP)
		}
		p.SetState(4272)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 487, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4271)
				p.Sequence_abbrev()
			}

		}

	case 5:
		{
			p.SetState(4274)
			p.Match(SystemVerilogParserKFIRST_MATCH)
		}
		{
			p.SetState(4275)
			p.Match(SystemVerilogParserLP)
		}
		{
			p.SetState(4276)
			p.sequence_expr(0)
		}
		p.SetState(4281)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserCOMMA {
			{
				p.SetState(4277)
				p.Match(SystemVerilogParserCOMMA)
			}
			{
				p.SetState(4278)
				p.Sequence_match_item()
			}

			p.SetState(4283)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(4284)
			p.Match(SystemVerilogParserRP)
		}

	case 6:
		{
			p.SetState(4286)
			p.Clocking_event()
		}
		{
			p.SetState(4287)
			p.sequence_expr(1)
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(4307)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 492, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(4305)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 491, p.GetParserRuleContext()) {
			case 1:
				localctx = NewSequence_exprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SystemVerilogParserRULE_sequence_expr)
				p.SetState(4291)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				}
				{
					p.SetState(4292)
					_la = p.GetTokenStream().LA(1)

					if !(_la == SystemVerilogParserKAND || _la == SystemVerilogParserKINTERSECT || _la == SystemVerilogParserKOR || _la == SystemVerilogParserKWITHIN) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(4293)
					p.sequence_expr(4)
				}

			case 2:
				localctx = NewSequence_exprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SystemVerilogParserRULE_sequence_expr)
				p.SetState(4294)

				if !(p.Precpred(p.GetParserRuleContext(), 7)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 7)", ""))
				}
				{
					p.SetState(4295)
					p.Cycle_delay_range()
				}
				{
					p.SetState(4296)
					p.sequence_expr(0)
				}
				p.SetState(4302)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 490, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(4297)
							p.Cycle_delay_range()
						}
						{
							p.SetState(4298)
							p.sequence_expr(0)
						}

					}
					p.SetState(4304)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 490, p.GetParserRuleContext())
				}

			}

		}
		p.SetState(4309)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 492, p.GetParserRuleContext())
	}

	return localctx
}

// ICycle_delay_rangeContext is an interface to support dynamic dispatch.
type ICycle_delay_rangeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCycle_delay_rangeContext differentiates from other interfaces.
	IsCycle_delay_rangeContext()
}

type Cycle_delay_rangeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCycle_delay_rangeContext() *Cycle_delay_rangeContext {
	var p = new(Cycle_delay_rangeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_cycle_delay_range
	return p
}

func (*Cycle_delay_rangeContext) IsCycle_delay_rangeContext() {}

func NewCycle_delay_rangeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cycle_delay_rangeContext {
	var p = new(Cycle_delay_rangeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_cycle_delay_range

	return p
}

func (s *Cycle_delay_rangeContext) GetParser() antlr.Parser { return s.parser }

func (s *Cycle_delay_rangeContext) PP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserPP, 0)
}

func (s *Cycle_delay_rangeContext) Constant_primary() IConstant_primaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_primaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_primaryContext)
}

func (s *Cycle_delay_rangeContext) LB() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLB, 0)
}

func (s *Cycle_delay_rangeContext) RB() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRB, 0)
}

func (s *Cycle_delay_rangeContext) Cycle_delay_const_range_expression() ICycle_delay_const_range_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICycle_delay_const_range_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICycle_delay_const_range_expressionContext)
}

func (s *Cycle_delay_rangeContext) STAR() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSTAR, 0)
}

func (s *Cycle_delay_rangeContext) PLUS() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserPLUS, 0)
}

func (s *Cycle_delay_rangeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cycle_delay_rangeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cycle_delay_rangeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterCycle_delay_range(s)
	}
}

func (s *Cycle_delay_rangeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitCycle_delay_range(s)
	}
}

func (p *SystemVerilogParser) Cycle_delay_range() (localctx ICycle_delay_rangeContext) {
	this := p
	_ = this

	localctx = NewCycle_delay_rangeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 464, SystemVerilogParserRULE_cycle_delay_range)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4310)
		p.Match(SystemVerilogParserPP)
	}
	p.SetState(4319)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserDOLLAR, SystemVerilogParserDROOT, SystemVerilogParserDUNIT, SystemVerilogParserLP, SystemVerilogParserQUOTE, SystemVerilogParserLC, SystemVerilogParserKBYTE, SystemVerilogParserKINT, SystemVerilogParserKINTEGER, SystemVerilogParserKLOCAL, SystemVerilogParserKLONGINT, SystemVerilogParserKNULL, SystemVerilogParserKRANDOMIZE, SystemVerilogParserKSHORTINT, SystemVerilogParserKSTD, SystemVerilogParserKSUPER, SystemVerilogParserKTHIS, SystemVerilogParserKTIME, SystemVerilogParserKTYPE, SystemVerilogParserTIME_LITERAL, SystemVerilogParserDECIMAL_NUMBER, SystemVerilogParserBINARY_NUMBER, SystemVerilogParserOCTAL_NUMBER, SystemVerilogParserHEX_NUMBER, SystemVerilogParserREAL_NUMBER, SystemVerilogParserUNSIGNED_NUMBER, SystemVerilogParserSTRING_LITERAL, SystemVerilogParserSIMPLE_IDENTIFIER, SystemVerilogParserSYSTEM_TF_IDENTIFIER:
		{
			p.SetState(4311)
			p.Constant_primary()
		}

	case SystemVerilogParserLB:
		{
			p.SetState(4312)
			p.Match(SystemVerilogParserLB)
		}
		p.SetState(4316)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 493, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(4313)
				p.Cycle_delay_const_range_expression()
			}

		case 2:
			{
				p.SetState(4314)
				p.Match(SystemVerilogParserSTAR)
			}

		case 3:
			{
				p.SetState(4315)
				p.Match(SystemVerilogParserPLUS)
			}

		}
		{
			p.SetState(4318)
			p.Match(SystemVerilogParserRB)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISequence_method_callContext is an interface to support dynamic dispatch.
type ISequence_method_callContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSequence_method_callContext differentiates from other interfaces.
	IsSequence_method_callContext()
}

type Sequence_method_callContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySequence_method_callContext() *Sequence_method_callContext {
	var p = new(Sequence_method_callContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_sequence_method_call
	return p
}

func (*Sequence_method_callContext) IsSequence_method_callContext() {}

func NewSequence_method_callContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sequence_method_callContext {
	var p = new(Sequence_method_callContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_sequence_method_call

	return p
}

func (s *Sequence_method_callContext) GetParser() antlr.Parser { return s.parser }

func (s *Sequence_method_callContext) Sequence_instance() ISequence_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequence_instanceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISequence_instanceContext)
}

func (s *Sequence_method_callContext) DOT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserDOT, 0)
}

func (s *Sequence_method_callContext) Method_identifier() IMethod_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMethod_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMethod_identifierContext)
}

func (s *Sequence_method_callContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sequence_method_callContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sequence_method_callContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterSequence_method_call(s)
	}
}

func (s *Sequence_method_callContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitSequence_method_call(s)
	}
}

func (p *SystemVerilogParser) Sequence_method_call() (localctx ISequence_method_callContext) {
	this := p
	_ = this

	localctx = NewSequence_method_callContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 466, SystemVerilogParserRULE_sequence_method_call)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4321)
		p.Sequence_instance()
	}
	{
		p.SetState(4322)
		p.Match(SystemVerilogParserDOT)
	}
	{
		p.SetState(4323)
		p.Method_identifier()
	}

	return localctx
}

// ISequence_match_itemContext is an interface to support dynamic dispatch.
type ISequence_match_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSequence_match_itemContext differentiates from other interfaces.
	IsSequence_match_itemContext()
}

type Sequence_match_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySequence_match_itemContext() *Sequence_match_itemContext {
	var p = new(Sequence_match_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_sequence_match_item
	return p
}

func (*Sequence_match_itemContext) IsSequence_match_itemContext() {}

func NewSequence_match_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sequence_match_itemContext {
	var p = new(Sequence_match_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_sequence_match_item

	return p
}

func (s *Sequence_match_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Sequence_match_itemContext) Operator_assignment() IOperator_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOperator_assignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOperator_assignmentContext)
}

func (s *Sequence_match_itemContext) Inc_or_dec_expression() IInc_or_dec_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInc_or_dec_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInc_or_dec_expressionContext)
}

func (s *Sequence_match_itemContext) Subroutine_call() ISubroutine_callContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubroutine_callContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubroutine_callContext)
}

func (s *Sequence_match_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sequence_match_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sequence_match_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterSequence_match_item(s)
	}
}

func (s *Sequence_match_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitSequence_match_item(s)
	}
}

func (p *SystemVerilogParser) Sequence_match_item() (localctx ISequence_match_itemContext) {
	this := p
	_ = this

	localctx = NewSequence_match_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 468, SystemVerilogParserRULE_sequence_match_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4328)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 495, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4325)
			p.Operator_assignment()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4326)
			p.Inc_or_dec_expression()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4327)
			p.Subroutine_call()
		}

	}

	return localctx
}

// ISequence_instanceContext is an interface to support dynamic dispatch.
type ISequence_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSequence_instanceContext differentiates from other interfaces.
	IsSequence_instanceContext()
}

type Sequence_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySequence_instanceContext() *Sequence_instanceContext {
	var p = new(Sequence_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_sequence_instance
	return p
}

func (*Sequence_instanceContext) IsSequence_instanceContext() {}

func NewSequence_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sequence_instanceContext {
	var p = new(Sequence_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_sequence_instance

	return p
}

func (s *Sequence_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *Sequence_instanceContext) Ps_or_hierarchical_sequence_identifier() IPs_or_hierarchical_sequence_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPs_or_hierarchical_sequence_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPs_or_hierarchical_sequence_identifierContext)
}

func (s *Sequence_instanceContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Sequence_instanceContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Sequence_instanceContext) Sequence_list_of_arguments() ISequence_list_of_argumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequence_list_of_argumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISequence_list_of_argumentsContext)
}

func (s *Sequence_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sequence_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sequence_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterSequence_instance(s)
	}
}

func (s *Sequence_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitSequence_instance(s)
	}
}

func (p *SystemVerilogParser) Sequence_instance() (localctx ISequence_instanceContext) {
	this := p
	_ = this

	localctx = NewSequence_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 470, SystemVerilogParserRULE_sequence_instance)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4330)
		p.Ps_or_hierarchical_sequence_identifier()
	}
	p.SetState(4336)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 497, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4331)
			p.Match(SystemVerilogParserLP)
		}
		p.SetState(4333)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 496, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4332)
				p.Sequence_list_of_arguments()
			}

		}
		{
			p.SetState(4335)
			p.Match(SystemVerilogParserRP)
		}

	}

	return localctx
}

// ISequence_list_of_argumentsContext is an interface to support dynamic dispatch.
type ISequence_list_of_argumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSequence_list_of_argumentsContext differentiates from other interfaces.
	IsSequence_list_of_argumentsContext()
}

type Sequence_list_of_argumentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySequence_list_of_argumentsContext() *Sequence_list_of_argumentsContext {
	var p = new(Sequence_list_of_argumentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_sequence_list_of_arguments
	return p
}

func (*Sequence_list_of_argumentsContext) IsSequence_list_of_argumentsContext() {}

func NewSequence_list_of_argumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sequence_list_of_argumentsContext {
	var p = new(Sequence_list_of_argumentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_sequence_list_of_arguments

	return p
}

func (s *Sequence_list_of_argumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *Sequence_list_of_argumentsContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserDOT)
}

func (s *Sequence_list_of_argumentsContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserDOT, i)
}

func (s *Sequence_list_of_argumentsContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *Sequence_list_of_argumentsContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Sequence_list_of_argumentsContext) AllLP() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserLP)
}

func (s *Sequence_list_of_argumentsContext) LP(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, i)
}

func (s *Sequence_list_of_argumentsContext) AllRP() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserRP)
}

func (s *Sequence_list_of_argumentsContext) RP(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, i)
}

func (s *Sequence_list_of_argumentsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *Sequence_list_of_argumentsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *Sequence_list_of_argumentsContext) AllSequence_actual_arg() []ISequence_actual_argContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISequence_actual_argContext)(nil)).Elem())
	var tst = make([]ISequence_actual_argContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISequence_actual_argContext)
		}
	}

	return tst
}

func (s *Sequence_list_of_argumentsContext) Sequence_actual_arg(i int) ISequence_actual_argContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequence_actual_argContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISequence_actual_argContext)
}

func (s *Sequence_list_of_argumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sequence_list_of_argumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sequence_list_of_argumentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterSequence_list_of_arguments(s)
	}
}

func (s *Sequence_list_of_argumentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitSequence_list_of_arguments(s)
	}
}

func (p *SystemVerilogParser) Sequence_list_of_arguments() (localctx ISequence_list_of_argumentsContext) {
	this := p
	_ = this

	localctx = NewSequence_list_of_argumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 472, SystemVerilogParserRULE_sequence_list_of_arguments)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4358)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserMINUS, SystemVerilogParserMINUSMINS, SystemVerilogParserNOT, SystemVerilogParserPP, SystemVerilogParserDOLLAR, SystemVerilogParserDROOT, SystemVerilogParserDUNIT, SystemVerilogParserAND, SystemVerilogParserLP, SystemVerilogParserRP, SystemVerilogParserCOMMA, SystemVerilogParserAT, SystemVerilogParserQUOTE, SystemVerilogParserCARET, SystemVerilogParserCARETSQUIG, SystemVerilogParserLC, SystemVerilogParserBAR, SystemVerilogParserSQUIG, SystemVerilogParserSQUIGAND, SystemVerilogParserSQUIGCARET, SystemVerilogParserSQUIGBAR, SystemVerilogParserPLUS, SystemVerilogParserPLUSPLUS, SystemVerilogParserKBIT, SystemVerilogParserKBYTE, SystemVerilogParserKCONST, SystemVerilogParserKEDGE, SystemVerilogParserKFIRST_MATCH, SystemVerilogParserKINT, SystemVerilogParserKINTEGER, SystemVerilogParserKLOCAL, SystemVerilogParserKLOGIC, SystemVerilogParserKLONGINT, SystemVerilogParserKNEGEDGE, SystemVerilogParserKNULL, SystemVerilogParserKPOSEDGE, SystemVerilogParserKRANDOMIZE, SystemVerilogParserKREAL, SystemVerilogParserKREALTIME, SystemVerilogParserKREG, SystemVerilogParserKSHORTINT, SystemVerilogParserKSHORTREAL, SystemVerilogParserKSIGNED, SystemVerilogParserKSTD, SystemVerilogParserKSTRING, SystemVerilogParserKSUPER, SystemVerilogParserKTAGGED, SystemVerilogParserKTHIS, SystemVerilogParserKTIME, SystemVerilogParserKTYPE, SystemVerilogParserKUNSIGNED, SystemVerilogParserTIME_LITERAL, SystemVerilogParserDECIMAL_NUMBER, SystemVerilogParserBINARY_NUMBER, SystemVerilogParserOCTAL_NUMBER, SystemVerilogParserHEX_NUMBER, SystemVerilogParserREAL_NUMBER, SystemVerilogParserUNSIGNED_NUMBER, SystemVerilogParserSTRING_LITERAL, SystemVerilogParserSIMPLE_IDENTIFIER, SystemVerilogParserSYSTEM_TF_IDENTIFIER:
		p.SetState(4339)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SystemVerilogParserMINUS)|(1<<SystemVerilogParserMINUSMINS)|(1<<SystemVerilogParserNOT)|(1<<SystemVerilogParserPP)|(1<<SystemVerilogParserDOLLAR)|(1<<SystemVerilogParserDROOT)|(1<<SystemVerilogParserDUNIT)|(1<<SystemVerilogParserAND)|(1<<SystemVerilogParserLP))) != 0) || (((_la-48)&-(0x1f+1)) == 0 && ((1<<uint((_la-48)))&((1<<(SystemVerilogParserAT-48))|(1<<(SystemVerilogParserQUOTE-48))|(1<<(SystemVerilogParserCARET-48))|(1<<(SystemVerilogParserCARETSQUIG-48))|(1<<(SystemVerilogParserLC-48))|(1<<(SystemVerilogParserBAR-48))|(1<<(SystemVerilogParserSQUIG-48))|(1<<(SystemVerilogParserSQUIGAND-48))|(1<<(SystemVerilogParserSQUIGCARET-48))|(1<<(SystemVerilogParserSQUIGBAR-48))|(1<<(SystemVerilogParserPLUS-48))|(1<<(SystemVerilogParserPLUSPLUS-48)))) != 0) || (((_la-109)&-(0x1f+1)) == 0 && ((1<<uint((_la-109)))&((1<<(SystemVerilogParserKBIT-109))|(1<<(SystemVerilogParserKBYTE-109))|(1<<(SystemVerilogParserKCONST-109))|(1<<(SystemVerilogParserKEDGE-109)))) != 0) || (((_la-167)&-(0x1f+1)) == 0 && ((1<<uint((_la-167)))&((1<<(SystemVerilogParserKFIRST_MATCH-167))|(1<<(SystemVerilogParserKINT-167))|(1<<(SystemVerilogParserKINTEGER-167)))) != 0) || (((_la-207)&-(0x1f+1)) == 0 && ((1<<uint((_la-207)))&((1<<(SystemVerilogParserKLOCAL-207))|(1<<(SystemVerilogParserKLOGIC-207))|(1<<(SystemVerilogParserKLONGINT-207))|(1<<(SystemVerilogParserKNEGEDGE-207))|(1<<(SystemVerilogParserKNULL-207))|(1<<(SystemVerilogParserKPOSEDGE-207)))) != 0) || (((_la-252)&-(0x1f+1)) == 0 && ((1<<uint((_la-252)))&((1<<(SystemVerilogParserKRANDOMIZE-252))|(1<<(SystemVerilogParserKREAL-252))|(1<<(SystemVerilogParserKREALTIME-252))|(1<<(SystemVerilogParserKREG-252))|(1<<(SystemVerilogParserKSHORTINT-252))|(1<<(SystemVerilogParserKSHORTREAL-252))|(1<<(SystemVerilogParserKSIGNED-252)))) != 0) || (((_la-286)&-(0x1f+1)) == 0 && ((1<<uint((_la-286)))&((1<<(SystemVerilogParserKSTD-286))|(1<<(SystemVerilogParserKSTRING-286))|(1<<(SystemVerilogParserKSUPER-286))|(1<<(SystemVerilogParserKTAGGED-286))|(1<<(SystemVerilogParserKTHIS-286))|(1<<(SystemVerilogParserKTIME-286))|(1<<(SystemVerilogParserKTYPE-286)))) != 0) || (((_la-319)&-(0x1f+1)) == 0 && ((1<<uint((_la-319)))&((1<<(SystemVerilogParserKUNSIGNED-319))|(1<<(SystemVerilogParserTIME_LITERAL-319))|(1<<(SystemVerilogParserDECIMAL_NUMBER-319))|(1<<(SystemVerilogParserBINARY_NUMBER-319))|(1<<(SystemVerilogParserOCTAL_NUMBER-319))|(1<<(SystemVerilogParserHEX_NUMBER-319))|(1<<(SystemVerilogParserREAL_NUMBER-319)))) != 0) || (((_la-351)&-(0x1f+1)) == 0 && ((1<<uint((_la-351)))&((1<<(SystemVerilogParserUNSIGNED_NUMBER-351))|(1<<(SystemVerilogParserSTRING_LITERAL-351))|(1<<(SystemVerilogParserSIMPLE_IDENTIFIER-351))|(1<<(SystemVerilogParserSYSTEM_TF_IDENTIFIER-351)))) != 0) {
			{
				p.SetState(4338)
				p.Sequence_actual_arg()
			}

		}
		p.SetState(4347)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 500, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(4341)
					p.Match(SystemVerilogParserCOMMA)
				}
				p.SetState(4343)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SystemVerilogParserMINUS)|(1<<SystemVerilogParserMINUSMINS)|(1<<SystemVerilogParserNOT)|(1<<SystemVerilogParserPP)|(1<<SystemVerilogParserDOLLAR)|(1<<SystemVerilogParserDROOT)|(1<<SystemVerilogParserDUNIT)|(1<<SystemVerilogParserAND)|(1<<SystemVerilogParserLP))) != 0) || (((_la-48)&-(0x1f+1)) == 0 && ((1<<uint((_la-48)))&((1<<(SystemVerilogParserAT-48))|(1<<(SystemVerilogParserQUOTE-48))|(1<<(SystemVerilogParserCARET-48))|(1<<(SystemVerilogParserCARETSQUIG-48))|(1<<(SystemVerilogParserLC-48))|(1<<(SystemVerilogParserBAR-48))|(1<<(SystemVerilogParserSQUIG-48))|(1<<(SystemVerilogParserSQUIGAND-48))|(1<<(SystemVerilogParserSQUIGCARET-48))|(1<<(SystemVerilogParserSQUIGBAR-48))|(1<<(SystemVerilogParserPLUS-48))|(1<<(SystemVerilogParserPLUSPLUS-48)))) != 0) || (((_la-109)&-(0x1f+1)) == 0 && ((1<<uint((_la-109)))&((1<<(SystemVerilogParserKBIT-109))|(1<<(SystemVerilogParserKBYTE-109))|(1<<(SystemVerilogParserKCONST-109))|(1<<(SystemVerilogParserKEDGE-109)))) != 0) || (((_la-167)&-(0x1f+1)) == 0 && ((1<<uint((_la-167)))&((1<<(SystemVerilogParserKFIRST_MATCH-167))|(1<<(SystemVerilogParserKINT-167))|(1<<(SystemVerilogParserKINTEGER-167)))) != 0) || (((_la-207)&-(0x1f+1)) == 0 && ((1<<uint((_la-207)))&((1<<(SystemVerilogParserKLOCAL-207))|(1<<(SystemVerilogParserKLOGIC-207))|(1<<(SystemVerilogParserKLONGINT-207))|(1<<(SystemVerilogParserKNEGEDGE-207))|(1<<(SystemVerilogParserKNULL-207))|(1<<(SystemVerilogParserKPOSEDGE-207)))) != 0) || (((_la-252)&-(0x1f+1)) == 0 && ((1<<uint((_la-252)))&((1<<(SystemVerilogParserKRANDOMIZE-252))|(1<<(SystemVerilogParserKREAL-252))|(1<<(SystemVerilogParserKREALTIME-252))|(1<<(SystemVerilogParserKREG-252))|(1<<(SystemVerilogParserKSHORTINT-252))|(1<<(SystemVerilogParserKSHORTREAL-252))|(1<<(SystemVerilogParserKSIGNED-252)))) != 0) || (((_la-286)&-(0x1f+1)) == 0 && ((1<<uint((_la-286)))&((1<<(SystemVerilogParserKSTD-286))|(1<<(SystemVerilogParserKSTRING-286))|(1<<(SystemVerilogParserKSUPER-286))|(1<<(SystemVerilogParserKTAGGED-286))|(1<<(SystemVerilogParserKTHIS-286))|(1<<(SystemVerilogParserKTIME-286))|(1<<(SystemVerilogParserKTYPE-286)))) != 0) || (((_la-319)&-(0x1f+1)) == 0 && ((1<<uint((_la-319)))&((1<<(SystemVerilogParserKUNSIGNED-319))|(1<<(SystemVerilogParserTIME_LITERAL-319))|(1<<(SystemVerilogParserDECIMAL_NUMBER-319))|(1<<(SystemVerilogParserBINARY_NUMBER-319))|(1<<(SystemVerilogParserOCTAL_NUMBER-319))|(1<<(SystemVerilogParserHEX_NUMBER-319))|(1<<(SystemVerilogParserREAL_NUMBER-319)))) != 0) || (((_la-351)&-(0x1f+1)) == 0 && ((1<<uint((_la-351)))&((1<<(SystemVerilogParserUNSIGNED_NUMBER-351))|(1<<(SystemVerilogParserSTRING_LITERAL-351))|(1<<(SystemVerilogParserSIMPLE_IDENTIFIER-351))|(1<<(SystemVerilogParserSYSTEM_TF_IDENTIFIER-351)))) != 0) {
					{
						p.SetState(4342)
						p.Sequence_actual_arg()
					}

				}

			}
			p.SetState(4349)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 500, p.GetParserRuleContext())
		}

	case SystemVerilogParserDOT:
		{
			p.SetState(4350)
			p.Match(SystemVerilogParserDOT)
		}
		{
			p.SetState(4351)
			p.Identifier()
		}
		{
			p.SetState(4352)
			p.Match(SystemVerilogParserLP)
		}
		p.SetState(4354)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SystemVerilogParserMINUS)|(1<<SystemVerilogParserMINUSMINS)|(1<<SystemVerilogParserNOT)|(1<<SystemVerilogParserPP)|(1<<SystemVerilogParserDOLLAR)|(1<<SystemVerilogParserDROOT)|(1<<SystemVerilogParserDUNIT)|(1<<SystemVerilogParserAND)|(1<<SystemVerilogParserLP))) != 0) || (((_la-48)&-(0x1f+1)) == 0 && ((1<<uint((_la-48)))&((1<<(SystemVerilogParserAT-48))|(1<<(SystemVerilogParserQUOTE-48))|(1<<(SystemVerilogParserCARET-48))|(1<<(SystemVerilogParserCARETSQUIG-48))|(1<<(SystemVerilogParserLC-48))|(1<<(SystemVerilogParserBAR-48))|(1<<(SystemVerilogParserSQUIG-48))|(1<<(SystemVerilogParserSQUIGAND-48))|(1<<(SystemVerilogParserSQUIGCARET-48))|(1<<(SystemVerilogParserSQUIGBAR-48))|(1<<(SystemVerilogParserPLUS-48))|(1<<(SystemVerilogParserPLUSPLUS-48)))) != 0) || (((_la-109)&-(0x1f+1)) == 0 && ((1<<uint((_la-109)))&((1<<(SystemVerilogParserKBIT-109))|(1<<(SystemVerilogParserKBYTE-109))|(1<<(SystemVerilogParserKCONST-109))|(1<<(SystemVerilogParserKEDGE-109)))) != 0) || (((_la-167)&-(0x1f+1)) == 0 && ((1<<uint((_la-167)))&((1<<(SystemVerilogParserKFIRST_MATCH-167))|(1<<(SystemVerilogParserKINT-167))|(1<<(SystemVerilogParserKINTEGER-167)))) != 0) || (((_la-207)&-(0x1f+1)) == 0 && ((1<<uint((_la-207)))&((1<<(SystemVerilogParserKLOCAL-207))|(1<<(SystemVerilogParserKLOGIC-207))|(1<<(SystemVerilogParserKLONGINT-207))|(1<<(SystemVerilogParserKNEGEDGE-207))|(1<<(SystemVerilogParserKNULL-207))|(1<<(SystemVerilogParserKPOSEDGE-207)))) != 0) || (((_la-252)&-(0x1f+1)) == 0 && ((1<<uint((_la-252)))&((1<<(SystemVerilogParserKRANDOMIZE-252))|(1<<(SystemVerilogParserKREAL-252))|(1<<(SystemVerilogParserKREALTIME-252))|(1<<(SystemVerilogParserKREG-252))|(1<<(SystemVerilogParserKSHORTINT-252))|(1<<(SystemVerilogParserKSHORTREAL-252))|(1<<(SystemVerilogParserKSIGNED-252)))) != 0) || (((_la-286)&-(0x1f+1)) == 0 && ((1<<uint((_la-286)))&((1<<(SystemVerilogParserKSTD-286))|(1<<(SystemVerilogParserKSTRING-286))|(1<<(SystemVerilogParserKSUPER-286))|(1<<(SystemVerilogParserKTAGGED-286))|(1<<(SystemVerilogParserKTHIS-286))|(1<<(SystemVerilogParserKTIME-286))|(1<<(SystemVerilogParserKTYPE-286)))) != 0) || (((_la-319)&-(0x1f+1)) == 0 && ((1<<uint((_la-319)))&((1<<(SystemVerilogParserKUNSIGNED-319))|(1<<(SystemVerilogParserTIME_LITERAL-319))|(1<<(SystemVerilogParserDECIMAL_NUMBER-319))|(1<<(SystemVerilogParserBINARY_NUMBER-319))|(1<<(SystemVerilogParserOCTAL_NUMBER-319))|(1<<(SystemVerilogParserHEX_NUMBER-319))|(1<<(SystemVerilogParserREAL_NUMBER-319)))) != 0) || (((_la-351)&-(0x1f+1)) == 0 && ((1<<uint((_la-351)))&((1<<(SystemVerilogParserUNSIGNED_NUMBER-351))|(1<<(SystemVerilogParserSTRING_LITERAL-351))|(1<<(SystemVerilogParserSIMPLE_IDENTIFIER-351))|(1<<(SystemVerilogParserSYSTEM_TF_IDENTIFIER-351)))) != 0) {
			{
				p.SetState(4353)
				p.Sequence_actual_arg()
			}

		}
		{
			p.SetState(4356)
			p.Match(SystemVerilogParserRP)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(4371)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserCOMMA {
		{
			p.SetState(4360)
			p.Match(SystemVerilogParserCOMMA)
		}
		{
			p.SetState(4361)
			p.Match(SystemVerilogParserDOT)
		}
		{
			p.SetState(4362)
			p.Identifier()
		}
		{
			p.SetState(4363)
			p.Match(SystemVerilogParserLP)
		}
		p.SetState(4365)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SystemVerilogParserMINUS)|(1<<SystemVerilogParserMINUSMINS)|(1<<SystemVerilogParserNOT)|(1<<SystemVerilogParserPP)|(1<<SystemVerilogParserDOLLAR)|(1<<SystemVerilogParserDROOT)|(1<<SystemVerilogParserDUNIT)|(1<<SystemVerilogParserAND)|(1<<SystemVerilogParserLP))) != 0) || (((_la-48)&-(0x1f+1)) == 0 && ((1<<uint((_la-48)))&((1<<(SystemVerilogParserAT-48))|(1<<(SystemVerilogParserQUOTE-48))|(1<<(SystemVerilogParserCARET-48))|(1<<(SystemVerilogParserCARETSQUIG-48))|(1<<(SystemVerilogParserLC-48))|(1<<(SystemVerilogParserBAR-48))|(1<<(SystemVerilogParserSQUIG-48))|(1<<(SystemVerilogParserSQUIGAND-48))|(1<<(SystemVerilogParserSQUIGCARET-48))|(1<<(SystemVerilogParserSQUIGBAR-48))|(1<<(SystemVerilogParserPLUS-48))|(1<<(SystemVerilogParserPLUSPLUS-48)))) != 0) || (((_la-109)&-(0x1f+1)) == 0 && ((1<<uint((_la-109)))&((1<<(SystemVerilogParserKBIT-109))|(1<<(SystemVerilogParserKBYTE-109))|(1<<(SystemVerilogParserKCONST-109))|(1<<(SystemVerilogParserKEDGE-109)))) != 0) || (((_la-167)&-(0x1f+1)) == 0 && ((1<<uint((_la-167)))&((1<<(SystemVerilogParserKFIRST_MATCH-167))|(1<<(SystemVerilogParserKINT-167))|(1<<(SystemVerilogParserKINTEGER-167)))) != 0) || (((_la-207)&-(0x1f+1)) == 0 && ((1<<uint((_la-207)))&((1<<(SystemVerilogParserKLOCAL-207))|(1<<(SystemVerilogParserKLOGIC-207))|(1<<(SystemVerilogParserKLONGINT-207))|(1<<(SystemVerilogParserKNEGEDGE-207))|(1<<(SystemVerilogParserKNULL-207))|(1<<(SystemVerilogParserKPOSEDGE-207)))) != 0) || (((_la-252)&-(0x1f+1)) == 0 && ((1<<uint((_la-252)))&((1<<(SystemVerilogParserKRANDOMIZE-252))|(1<<(SystemVerilogParserKREAL-252))|(1<<(SystemVerilogParserKREALTIME-252))|(1<<(SystemVerilogParserKREG-252))|(1<<(SystemVerilogParserKSHORTINT-252))|(1<<(SystemVerilogParserKSHORTREAL-252))|(1<<(SystemVerilogParserKSIGNED-252)))) != 0) || (((_la-286)&-(0x1f+1)) == 0 && ((1<<uint((_la-286)))&((1<<(SystemVerilogParserKSTD-286))|(1<<(SystemVerilogParserKSTRING-286))|(1<<(SystemVerilogParserKSUPER-286))|(1<<(SystemVerilogParserKTAGGED-286))|(1<<(SystemVerilogParserKTHIS-286))|(1<<(SystemVerilogParserKTIME-286))|(1<<(SystemVerilogParserKTYPE-286)))) != 0) || (((_la-319)&-(0x1f+1)) == 0 && ((1<<uint((_la-319)))&((1<<(SystemVerilogParserKUNSIGNED-319))|(1<<(SystemVerilogParserTIME_LITERAL-319))|(1<<(SystemVerilogParserDECIMAL_NUMBER-319))|(1<<(SystemVerilogParserBINARY_NUMBER-319))|(1<<(SystemVerilogParserOCTAL_NUMBER-319))|(1<<(SystemVerilogParserHEX_NUMBER-319))|(1<<(SystemVerilogParserREAL_NUMBER-319)))) != 0) || (((_la-351)&-(0x1f+1)) == 0 && ((1<<uint((_la-351)))&((1<<(SystemVerilogParserUNSIGNED_NUMBER-351))|(1<<(SystemVerilogParserSTRING_LITERAL-351))|(1<<(SystemVerilogParserSIMPLE_IDENTIFIER-351))|(1<<(SystemVerilogParserSYSTEM_TF_IDENTIFIER-351)))) != 0) {
			{
				p.SetState(4364)
				p.Sequence_actual_arg()
			}

		}
		{
			p.SetState(4367)
			p.Match(SystemVerilogParserRP)
		}

		p.SetState(4373)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISequence_actual_argContext is an interface to support dynamic dispatch.
type ISequence_actual_argContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSequence_actual_argContext differentiates from other interfaces.
	IsSequence_actual_argContext()
}

type Sequence_actual_argContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySequence_actual_argContext() *Sequence_actual_argContext {
	var p = new(Sequence_actual_argContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_sequence_actual_arg
	return p
}

func (*Sequence_actual_argContext) IsSequence_actual_argContext() {}

func NewSequence_actual_argContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sequence_actual_argContext {
	var p = new(Sequence_actual_argContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_sequence_actual_arg

	return p
}

func (s *Sequence_actual_argContext) GetParser() antlr.Parser { return s.parser }

func (s *Sequence_actual_argContext) Event_expression() IEvent_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvent_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEvent_expressionContext)
}

func (s *Sequence_actual_argContext) Sequence_expr() ISequence_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequence_exprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISequence_exprContext)
}

func (s *Sequence_actual_argContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sequence_actual_argContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sequence_actual_argContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterSequence_actual_arg(s)
	}
}

func (s *Sequence_actual_argContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitSequence_actual_arg(s)
	}
}

func (p *SystemVerilogParser) Sequence_actual_arg() (localctx ISequence_actual_argContext) {
	this := p
	_ = this

	localctx = NewSequence_actual_argContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 474, SystemVerilogParserRULE_sequence_actual_arg)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4376)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 505, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4374)
			p.event_expression(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4375)
			p.sequence_expr(0)
		}

	}

	return localctx
}

// IBoolean_abbrevContext is an interface to support dynamic dispatch.
type IBoolean_abbrevContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBoolean_abbrevContext differentiates from other interfaces.
	IsBoolean_abbrevContext()
}

type Boolean_abbrevContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBoolean_abbrevContext() *Boolean_abbrevContext {
	var p = new(Boolean_abbrevContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_boolean_abbrev
	return p
}

func (*Boolean_abbrevContext) IsBoolean_abbrevContext() {}

func NewBoolean_abbrevContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Boolean_abbrevContext {
	var p = new(Boolean_abbrevContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_boolean_abbrev

	return p
}

func (s *Boolean_abbrevContext) GetParser() antlr.Parser { return s.parser }

func (s *Boolean_abbrevContext) Consecutive_repetition() IConsecutive_repetitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConsecutive_repetitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConsecutive_repetitionContext)
}

func (s *Boolean_abbrevContext) Non_consecutive_repetition() INon_consecutive_repetitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INon_consecutive_repetitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INon_consecutive_repetitionContext)
}

func (s *Boolean_abbrevContext) Goto_repetition() IGoto_repetitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGoto_repetitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGoto_repetitionContext)
}

func (s *Boolean_abbrevContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Boolean_abbrevContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Boolean_abbrevContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterBoolean_abbrev(s)
	}
}

func (s *Boolean_abbrevContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitBoolean_abbrev(s)
	}
}

func (p *SystemVerilogParser) Boolean_abbrev() (localctx IBoolean_abbrevContext) {
	this := p
	_ = this

	localctx = NewBoolean_abbrevContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 476, SystemVerilogParserRULE_boolean_abbrev)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4381)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 506, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4378)
			p.Consecutive_repetition()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4379)
			p.Non_consecutive_repetition()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4380)
			p.Goto_repetition()
		}

	}

	return localctx
}

// ISequence_abbrevContext is an interface to support dynamic dispatch.
type ISequence_abbrevContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSequence_abbrevContext differentiates from other interfaces.
	IsSequence_abbrevContext()
}

type Sequence_abbrevContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySequence_abbrevContext() *Sequence_abbrevContext {
	var p = new(Sequence_abbrevContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_sequence_abbrev
	return p
}

func (*Sequence_abbrevContext) IsSequence_abbrevContext() {}

func NewSequence_abbrevContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sequence_abbrevContext {
	var p = new(Sequence_abbrevContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_sequence_abbrev

	return p
}

func (s *Sequence_abbrevContext) GetParser() antlr.Parser { return s.parser }

func (s *Sequence_abbrevContext) Consecutive_repetition() IConsecutive_repetitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConsecutive_repetitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConsecutive_repetitionContext)
}

func (s *Sequence_abbrevContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sequence_abbrevContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sequence_abbrevContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterSequence_abbrev(s)
	}
}

func (s *Sequence_abbrevContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitSequence_abbrev(s)
	}
}

func (p *SystemVerilogParser) Sequence_abbrev() (localctx ISequence_abbrevContext) {
	this := p
	_ = this

	localctx = NewSequence_abbrevContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 478, SystemVerilogParserRULE_sequence_abbrev)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4383)
		p.Consecutive_repetition()
	}

	return localctx
}

// IConsecutive_repetitionContext is an interface to support dynamic dispatch.
type IConsecutive_repetitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConsecutive_repetitionContext differentiates from other interfaces.
	IsConsecutive_repetitionContext()
}

type Consecutive_repetitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConsecutive_repetitionContext() *Consecutive_repetitionContext {
	var p = new(Consecutive_repetitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_consecutive_repetition
	return p
}

func (*Consecutive_repetitionContext) IsConsecutive_repetitionContext() {}

func NewConsecutive_repetitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Consecutive_repetitionContext {
	var p = new(Consecutive_repetitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_consecutive_repetition

	return p
}

func (s *Consecutive_repetitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Consecutive_repetitionContext) LB() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLB, 0)
}

func (s *Consecutive_repetitionContext) RB() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRB, 0)
}

func (s *Consecutive_repetitionContext) STAR() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSTAR, 0)
}

func (s *Consecutive_repetitionContext) Const_or_range_expression() IConst_or_range_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConst_or_range_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConst_or_range_expressionContext)
}

func (s *Consecutive_repetitionContext) PLUS() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserPLUS, 0)
}

func (s *Consecutive_repetitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Consecutive_repetitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Consecutive_repetitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterConsecutive_repetition(s)
	}
}

func (s *Consecutive_repetitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitConsecutive_repetition(s)
	}
}

func (p *SystemVerilogParser) Consecutive_repetition() (localctx IConsecutive_repetitionContext) {
	this := p
	_ = this

	localctx = NewConsecutive_repetitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 480, SystemVerilogParserRULE_consecutive_repetition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4385)
		p.Match(SystemVerilogParserLB)
	}
	p.SetState(4390)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 507, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4386)
			p.Match(SystemVerilogParserSTAR)
		}
		{
			p.SetState(4387)
			p.Const_or_range_expression()
		}

	case 2:
		{
			p.SetState(4388)
			p.Match(SystemVerilogParserSTAR)
		}

	case 3:
		{
			p.SetState(4389)
			p.Match(SystemVerilogParserPLUS)
		}

	}
	{
		p.SetState(4392)
		p.Match(SystemVerilogParserRB)
	}

	return localctx
}

// INon_consecutive_repetitionContext is an interface to support dynamic dispatch.
type INon_consecutive_repetitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNon_consecutive_repetitionContext differentiates from other interfaces.
	IsNon_consecutive_repetitionContext()
}

type Non_consecutive_repetitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNon_consecutive_repetitionContext() *Non_consecutive_repetitionContext {
	var p = new(Non_consecutive_repetitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_non_consecutive_repetition
	return p
}

func (*Non_consecutive_repetitionContext) IsNon_consecutive_repetitionContext() {}

func NewNon_consecutive_repetitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Non_consecutive_repetitionContext {
	var p = new(Non_consecutive_repetitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_non_consecutive_repetition

	return p
}

func (s *Non_consecutive_repetitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Non_consecutive_repetitionContext) LB() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLB, 0)
}

func (s *Non_consecutive_repetitionContext) EQ() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserEQ, 0)
}

func (s *Non_consecutive_repetitionContext) Const_or_range_expression() IConst_or_range_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConst_or_range_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConst_or_range_expressionContext)
}

func (s *Non_consecutive_repetitionContext) RB() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRB, 0)
}

func (s *Non_consecutive_repetitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Non_consecutive_repetitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Non_consecutive_repetitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterNon_consecutive_repetition(s)
	}
}

func (s *Non_consecutive_repetitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitNon_consecutive_repetition(s)
	}
}

func (p *SystemVerilogParser) Non_consecutive_repetition() (localctx INon_consecutive_repetitionContext) {
	this := p
	_ = this

	localctx = NewNon_consecutive_repetitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 482, SystemVerilogParserRULE_non_consecutive_repetition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4394)
		p.Match(SystemVerilogParserLB)
	}
	{
		p.SetState(4395)
		p.Match(SystemVerilogParserEQ)
	}
	{
		p.SetState(4396)
		p.Const_or_range_expression()
	}
	{
		p.SetState(4397)
		p.Match(SystemVerilogParserRB)
	}

	return localctx
}

// IGoto_repetitionContext is an interface to support dynamic dispatch.
type IGoto_repetitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGoto_repetitionContext differentiates from other interfaces.
	IsGoto_repetitionContext()
}

type Goto_repetitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGoto_repetitionContext() *Goto_repetitionContext {
	var p = new(Goto_repetitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_goto_repetition
	return p
}

func (*Goto_repetitionContext) IsGoto_repetitionContext() {}

func NewGoto_repetitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Goto_repetitionContext {
	var p = new(Goto_repetitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_goto_repetition

	return p
}

func (s *Goto_repetitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Goto_repetitionContext) LB() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLB, 0)
}

func (s *Goto_repetitionContext) ARROW() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserARROW, 0)
}

func (s *Goto_repetitionContext) Const_or_range_expression() IConst_or_range_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConst_or_range_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConst_or_range_expressionContext)
}

func (s *Goto_repetitionContext) RB() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRB, 0)
}

func (s *Goto_repetitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Goto_repetitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Goto_repetitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterGoto_repetition(s)
	}
}

func (s *Goto_repetitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitGoto_repetition(s)
	}
}

func (p *SystemVerilogParser) Goto_repetition() (localctx IGoto_repetitionContext) {
	this := p
	_ = this

	localctx = NewGoto_repetitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 484, SystemVerilogParserRULE_goto_repetition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4399)
		p.Match(SystemVerilogParserLB)
	}
	{
		p.SetState(4400)
		p.Match(SystemVerilogParserARROW)
	}
	{
		p.SetState(4401)
		p.Const_or_range_expression()
	}
	{
		p.SetState(4402)
		p.Match(SystemVerilogParserRB)
	}

	return localctx
}

// IConst_or_range_expressionContext is an interface to support dynamic dispatch.
type IConst_or_range_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConst_or_range_expressionContext differentiates from other interfaces.
	IsConst_or_range_expressionContext()
}

type Const_or_range_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConst_or_range_expressionContext() *Const_or_range_expressionContext {
	var p = new(Const_or_range_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_const_or_range_expression
	return p
}

func (*Const_or_range_expressionContext) IsConst_or_range_expressionContext() {}

func NewConst_or_range_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Const_or_range_expressionContext {
	var p = new(Const_or_range_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_const_or_range_expression

	return p
}

func (s *Const_or_range_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Const_or_range_expressionContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Const_or_range_expressionContext) Cycle_delay_const_range_expression() ICycle_delay_const_range_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICycle_delay_const_range_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICycle_delay_const_range_expressionContext)
}

func (s *Const_or_range_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Const_or_range_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Const_or_range_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterConst_or_range_expression(s)
	}
}

func (s *Const_or_range_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitConst_or_range_expression(s)
	}
}

func (p *SystemVerilogParser) Const_or_range_expression() (localctx IConst_or_range_expressionContext) {
	this := p
	_ = this

	localctx = NewConst_or_range_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 486, SystemVerilogParserRULE_const_or_range_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4406)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 508, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4404)
			p.constant_expression(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4405)
			p.Cycle_delay_const_range_expression()
		}

	}

	return localctx
}

// ICycle_delay_const_range_expressionContext is an interface to support dynamic dispatch.
type ICycle_delay_const_range_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCycle_delay_const_range_expressionContext differentiates from other interfaces.
	IsCycle_delay_const_range_expressionContext()
}

type Cycle_delay_const_range_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCycle_delay_const_range_expressionContext() *Cycle_delay_const_range_expressionContext {
	var p = new(Cycle_delay_const_range_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_cycle_delay_const_range_expression
	return p
}

func (*Cycle_delay_const_range_expressionContext) IsCycle_delay_const_range_expressionContext() {}

func NewCycle_delay_const_range_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cycle_delay_const_range_expressionContext {
	var p = new(Cycle_delay_const_range_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_cycle_delay_const_range_expression

	return p
}

func (s *Cycle_delay_const_range_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Cycle_delay_const_range_expressionContext) AllConstant_expression() []IConstant_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem())
	var tst = make([]IConstant_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConstant_expressionContext)
		}
	}

	return tst
}

func (s *Cycle_delay_const_range_expressionContext) Constant_expression(i int) IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Cycle_delay_const_range_expressionContext) COLON() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOLON, 0)
}

func (s *Cycle_delay_const_range_expressionContext) DOLLAR() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserDOLLAR, 0)
}

func (s *Cycle_delay_const_range_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cycle_delay_const_range_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cycle_delay_const_range_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterCycle_delay_const_range_expression(s)
	}
}

func (s *Cycle_delay_const_range_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitCycle_delay_const_range_expression(s)
	}
}

func (p *SystemVerilogParser) Cycle_delay_const_range_expression() (localctx ICycle_delay_const_range_expressionContext) {
	this := p
	_ = this

	localctx = NewCycle_delay_const_range_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 488, SystemVerilogParserRULE_cycle_delay_const_range_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4408)
		p.constant_expression(0)
	}
	{
		p.SetState(4409)
		p.Match(SystemVerilogParserCOLON)
	}
	p.SetState(4412)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 509, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4410)
			p.constant_expression(0)
		}

	case 2:
		{
			p.SetState(4411)
			p.Match(SystemVerilogParserDOLLAR)
		}

	}

	return localctx
}

// IExpression_or_distContext is an interface to support dynamic dispatch.
type IExpression_or_distContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpression_or_distContext differentiates from other interfaces.
	IsExpression_or_distContext()
}

type Expression_or_distContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpression_or_distContext() *Expression_or_distContext {
	var p = new(Expression_or_distContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_expression_or_dist
	return p
}

func (*Expression_or_distContext) IsExpression_or_distContext() {}

func NewExpression_or_distContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expression_or_distContext {
	var p = new(Expression_or_distContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_expression_or_dist

	return p
}

func (s *Expression_or_distContext) GetParser() antlr.Parser { return s.parser }

func (s *Expression_or_distContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Expression_or_distContext) KDIST() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKDIST, 0)
}

func (s *Expression_or_distContext) LC() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLC, 0)
}

func (s *Expression_or_distContext) Dist_list() IDist_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDist_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDist_listContext)
}

func (s *Expression_or_distContext) RC() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRC, 0)
}

func (s *Expression_or_distContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expression_or_distContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expression_or_distContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterExpression_or_dist(s)
	}
}

func (s *Expression_or_distContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitExpression_or_dist(s)
	}
}

func (p *SystemVerilogParser) Expression_or_dist() (localctx IExpression_or_distContext) {
	this := p
	_ = this

	localctx = NewExpression_or_distContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 490, SystemVerilogParserRULE_expression_or_dist)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4414)
		p.expression(0)
	}
	p.SetState(4420)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 510, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4415)
			p.Match(SystemVerilogParserKDIST)
		}
		{
			p.SetState(4416)
			p.Match(SystemVerilogParserLC)
		}
		{
			p.SetState(4417)
			p.Dist_list()
		}
		{
			p.SetState(4418)
			p.Match(SystemVerilogParserRC)
		}

	}

	return localctx
}

// IAssertion_variable_declarationContext is an interface to support dynamic dispatch.
type IAssertion_variable_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssertion_variable_declarationContext differentiates from other interfaces.
	IsAssertion_variable_declarationContext()
}

type Assertion_variable_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssertion_variable_declarationContext() *Assertion_variable_declarationContext {
	var p = new(Assertion_variable_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_assertion_variable_declaration
	return p
}

func (*Assertion_variable_declarationContext) IsAssertion_variable_declarationContext() {}

func NewAssertion_variable_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Assertion_variable_declarationContext {
	var p = new(Assertion_variable_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_assertion_variable_declaration

	return p
}

func (s *Assertion_variable_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Assertion_variable_declarationContext) Var_data_type() IVar_data_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVar_data_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVar_data_typeContext)
}

func (s *Assertion_variable_declarationContext) List_of_variable_decl_assignments() IList_of_variable_decl_assignmentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_variable_decl_assignmentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_variable_decl_assignmentsContext)
}

func (s *Assertion_variable_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Assertion_variable_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Assertion_variable_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Assertion_variable_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterAssertion_variable_declaration(s)
	}
}

func (s *Assertion_variable_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitAssertion_variable_declaration(s)
	}
}

func (p *SystemVerilogParser) Assertion_variable_declaration() (localctx IAssertion_variable_declarationContext) {
	this := p
	_ = this

	localctx = NewAssertion_variable_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 492, SystemVerilogParserRULE_assertion_variable_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4422)
		p.Var_data_type()
	}
	{
		p.SetState(4423)
		p.List_of_variable_decl_assignments()
	}
	{
		p.SetState(4424)
		p.Match(SystemVerilogParserSEMI)
	}

	return localctx
}

// ICovergroup_declarationContext is an interface to support dynamic dispatch.
type ICovergroup_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCovergroup_declarationContext differentiates from other interfaces.
	IsCovergroup_declarationContext()
}

type Covergroup_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCovergroup_declarationContext() *Covergroup_declarationContext {
	var p = new(Covergroup_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_covergroup_declaration
	return p
}

func (*Covergroup_declarationContext) IsCovergroup_declarationContext() {}

func NewCovergroup_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Covergroup_declarationContext {
	var p = new(Covergroup_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_covergroup_declaration

	return p
}

func (s *Covergroup_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Covergroup_declarationContext) KCOVERGROUP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKCOVERGROUP, 0)
}

func (s *Covergroup_declarationContext) AllCovergroup_identifier() []ICovergroup_identifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICovergroup_identifierContext)(nil)).Elem())
	var tst = make([]ICovergroup_identifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICovergroup_identifierContext)
		}
	}

	return tst
}

func (s *Covergroup_declarationContext) Covergroup_identifier(i int) ICovergroup_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICovergroup_identifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICovergroup_identifierContext)
}

func (s *Covergroup_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Covergroup_declarationContext) KENDGROUP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKENDGROUP, 0)
}

func (s *Covergroup_declarationContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Covergroup_declarationContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Covergroup_declarationContext) Coverage_event() ICoverage_eventContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICoverage_eventContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICoverage_eventContext)
}

func (s *Covergroup_declarationContext) AllCoverage_spec_or_option() []ICoverage_spec_or_optionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICoverage_spec_or_optionContext)(nil)).Elem())
	var tst = make([]ICoverage_spec_or_optionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICoverage_spec_or_optionContext)
		}
	}

	return tst
}

func (s *Covergroup_declarationContext) Coverage_spec_or_option(i int) ICoverage_spec_or_optionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICoverage_spec_or_optionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICoverage_spec_or_optionContext)
}

func (s *Covergroup_declarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOLON, 0)
}

func (s *Covergroup_declarationContext) Tf_port_list() ITf_port_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITf_port_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITf_port_listContext)
}

func (s *Covergroup_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Covergroup_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Covergroup_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterCovergroup_declaration(s)
	}
}

func (s *Covergroup_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitCovergroup_declaration(s)
	}
}

func (p *SystemVerilogParser) Covergroup_declaration() (localctx ICovergroup_declarationContext) {
	this := p
	_ = this

	localctx = NewCovergroup_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 494, SystemVerilogParserRULE_covergroup_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4426)
		p.Match(SystemVerilogParserKCOVERGROUP)
	}
	{
		p.SetState(4427)
		p.Covergroup_identifier()
	}
	p.SetState(4433)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserLP {
		{
			p.SetState(4428)
			p.Match(SystemVerilogParserLP)
		}
		p.SetState(4430)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 511, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4429)
				p.Tf_port_list()
			}

		}
		{
			p.SetState(4432)
			p.Match(SystemVerilogParserRP)
		}

	}
	p.SetState(4436)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserAT || _la == SystemVerilogParserATAT {
		{
			p.SetState(4435)
			p.Coverage_event()
		}

	}
	{
		p.SetState(4438)
		p.Match(SystemVerilogParserSEMI)
	}
	p.SetState(4442)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la-19)&-(0x1f+1)) == 0 && ((1<<uint((_la-19)))&((1<<(SystemVerilogParserDUNIT-19))|(1<<(SystemVerilogParserLPS-19))|(1<<(SystemVerilogParserLB-19)))) != 0) || (((_la-109)&-(0x1f+1)) == 0 && ((1<<uint((_la-109)))&((1<<(SystemVerilogParserKBIT-109))|(1<<(SystemVerilogParserKBYTE-109))|(1<<(SystemVerilogParserKCHANDLE-109))|(1<<(SystemVerilogParserKCOVERPOINT-109))|(1<<(SystemVerilogParserKCROSS-109)))) != 0) || _la == SystemVerilogParserKENUM || _la == SystemVerilogParserKEVENT || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SystemVerilogParserKINT-195))|(1<<(SystemVerilogParserKINTEGER-195))|(1<<(SystemVerilogParserKLOGIC-195))|(1<<(SystemVerilogParserKLONGINT-195)))) != 0) || (((_la-229)&-(0x1f+1)) == 0 && ((1<<uint((_la-229)))&((1<<(SystemVerilogParserKOPTION-229))|(1<<(SystemVerilogParserKREAL-229))|(1<<(SystemVerilogParserKREALTIME-229))|(1<<(SystemVerilogParserKREG-229)))) != 0) || (((_la-276)&-(0x1f+1)) == 0 && ((1<<uint((_la-276)))&((1<<(SystemVerilogParserKSHORTINT-276))|(1<<(SystemVerilogParserKSHORTREAL-276))|(1<<(SystemVerilogParserKSIGNED-276))|(1<<(SystemVerilogParserKSTRING-276))|(1<<(SystemVerilogParserKSTRUCT-276))|(1<<(SystemVerilogParserKTIME-276)))) != 0) || (((_la-313)&-(0x1f+1)) == 0 && ((1<<uint((_la-313)))&((1<<(SystemVerilogParserKTYPE-313))|(1<<(SystemVerilogParserKTYPE_OPTION-313))|(1<<(SystemVerilogParserKUNION-313))|(1<<(SystemVerilogParserKUNSIGNED-313))|(1<<(SystemVerilogParserKVIRTUAL-313)))) != 0) || _la == SystemVerilogParserSIMPLE_IDENTIFIER {
		{
			p.SetState(4439)
			p.Coverage_spec_or_option()
		}

		p.SetState(4444)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(4445)
		p.Match(SystemVerilogParserKENDGROUP)
	}
	p.SetState(4448)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserCOLON {
		{
			p.SetState(4446)
			p.Match(SystemVerilogParserCOLON)
		}
		{
			p.SetState(4447)
			p.Covergroup_identifier()
		}

	}

	return localctx
}

// ICoverage_spec_or_optionContext is an interface to support dynamic dispatch.
type ICoverage_spec_or_optionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCoverage_spec_or_optionContext differentiates from other interfaces.
	IsCoverage_spec_or_optionContext()
}

type Coverage_spec_or_optionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCoverage_spec_or_optionContext() *Coverage_spec_or_optionContext {
	var p = new(Coverage_spec_or_optionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_coverage_spec_or_option
	return p
}

func (*Coverage_spec_or_optionContext) IsCoverage_spec_or_optionContext() {}

func NewCoverage_spec_or_optionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Coverage_spec_or_optionContext {
	var p = new(Coverage_spec_or_optionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_coverage_spec_or_option

	return p
}

func (s *Coverage_spec_or_optionContext) GetParser() antlr.Parser { return s.parser }

func (s *Coverage_spec_or_optionContext) Coverage_spec() ICoverage_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICoverage_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICoverage_specContext)
}

func (s *Coverage_spec_or_optionContext) Coverage_option() ICoverage_optionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICoverage_optionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICoverage_optionContext)
}

func (s *Coverage_spec_or_optionContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Coverage_spec_or_optionContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Coverage_spec_or_optionContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Coverage_spec_or_optionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Coverage_spec_or_optionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Coverage_spec_or_optionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterCoverage_spec_or_option(s)
	}
}

func (s *Coverage_spec_or_optionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitCoverage_spec_or_option(s)
	}
}

func (p *SystemVerilogParser) Coverage_spec_or_option() (localctx ICoverage_spec_or_optionContext) {
	this := p
	_ = this

	localctx = NewCoverage_spec_or_optionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 496, SystemVerilogParserRULE_coverage_spec_or_option)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4453)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserLPS {
		{
			p.SetState(4450)
			p.Attribute_instance()
		}

		p.SetState(4455)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(4460)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserDUNIT, SystemVerilogParserLB, SystemVerilogParserKBIT, SystemVerilogParserKBYTE, SystemVerilogParserKCHANDLE, SystemVerilogParserKCOVERPOINT, SystemVerilogParserKCROSS, SystemVerilogParserKENUM, SystemVerilogParserKEVENT, SystemVerilogParserKINT, SystemVerilogParserKINTEGER, SystemVerilogParserKLOGIC, SystemVerilogParserKLONGINT, SystemVerilogParserKREAL, SystemVerilogParserKREALTIME, SystemVerilogParserKREG, SystemVerilogParserKSHORTINT, SystemVerilogParserKSHORTREAL, SystemVerilogParserKSIGNED, SystemVerilogParserKSTRING, SystemVerilogParserKSTRUCT, SystemVerilogParserKTIME, SystemVerilogParserKTYPE, SystemVerilogParserKUNION, SystemVerilogParserKUNSIGNED, SystemVerilogParserKVIRTUAL, SystemVerilogParserSIMPLE_IDENTIFIER:
		{
			p.SetState(4456)
			p.Coverage_spec()
		}

	case SystemVerilogParserKOPTION, SystemVerilogParserKTYPE_OPTION:
		{
			p.SetState(4457)
			p.Coverage_option()
		}
		{
			p.SetState(4458)
			p.Match(SystemVerilogParserSEMI)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICoverage_optionContext is an interface to support dynamic dispatch.
type ICoverage_optionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCoverage_optionContext differentiates from other interfaces.
	IsCoverage_optionContext()
}

type Coverage_optionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCoverage_optionContext() *Coverage_optionContext {
	var p = new(Coverage_optionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_coverage_option
	return p
}

func (*Coverage_optionContext) IsCoverage_optionContext() {}

func NewCoverage_optionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Coverage_optionContext {
	var p = new(Coverage_optionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_coverage_option

	return p
}

func (s *Coverage_optionContext) GetParser() antlr.Parser { return s.parser }

func (s *Coverage_optionContext) KOPTION() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKOPTION, 0)
}

func (s *Coverage_optionContext) DOT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserDOT, 0)
}

func (s *Coverage_optionContext) KMEMBER_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKMEMBER_IDENTIFIER, 0)
}

func (s *Coverage_optionContext) EQ() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserEQ, 0)
}

func (s *Coverage_optionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Coverage_optionContext) KTYPE_OPTION() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKTYPE_OPTION, 0)
}

func (s *Coverage_optionContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Coverage_optionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Coverage_optionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Coverage_optionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterCoverage_option(s)
	}
}

func (s *Coverage_optionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitCoverage_option(s)
	}
}

func (p *SystemVerilogParser) Coverage_option() (localctx ICoverage_optionContext) {
	this := p
	_ = this

	localctx = NewCoverage_optionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 498, SystemVerilogParserRULE_coverage_option)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4472)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserKOPTION:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4462)
			p.Match(SystemVerilogParserKOPTION)
		}
		{
			p.SetState(4463)
			p.Match(SystemVerilogParserDOT)
		}
		{
			p.SetState(4464)
			p.Match(SystemVerilogParserKMEMBER_IDENTIFIER)
		}
		{
			p.SetState(4465)
			p.Match(SystemVerilogParserEQ)
		}
		{
			p.SetState(4466)
			p.expression(0)
		}

	case SystemVerilogParserKTYPE_OPTION:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4467)
			p.Match(SystemVerilogParserKTYPE_OPTION)
		}
		{
			p.SetState(4468)
			p.Match(SystemVerilogParserDOT)
		}
		{
			p.SetState(4469)
			p.Match(SystemVerilogParserKMEMBER_IDENTIFIER)
		}
		{
			p.SetState(4470)
			p.Match(SystemVerilogParserEQ)
		}
		{
			p.SetState(4471)
			p.constant_expression(0)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICoverage_specContext is an interface to support dynamic dispatch.
type ICoverage_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCoverage_specContext differentiates from other interfaces.
	IsCoverage_specContext()
}

type Coverage_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCoverage_specContext() *Coverage_specContext {
	var p = new(Coverage_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_coverage_spec
	return p
}

func (*Coverage_specContext) IsCoverage_specContext() {}

func NewCoverage_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Coverage_specContext {
	var p = new(Coverage_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_coverage_spec

	return p
}

func (s *Coverage_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Coverage_specContext) Cover_point() ICover_pointContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICover_pointContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICover_pointContext)
}

func (s *Coverage_specContext) Cover_cross() ICover_crossContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICover_crossContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICover_crossContext)
}

func (s *Coverage_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Coverage_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Coverage_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterCoverage_spec(s)
	}
}

func (s *Coverage_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitCoverage_spec(s)
	}
}

func (p *SystemVerilogParser) Coverage_spec() (localctx ICoverage_specContext) {
	this := p
	_ = this

	localctx = NewCoverage_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 500, SystemVerilogParserRULE_coverage_spec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4476)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 519, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4474)
			p.Cover_point()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4475)
			p.Cover_cross()
		}

	}

	return localctx
}

// ICoverage_eventContext is an interface to support dynamic dispatch.
type ICoverage_eventContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCoverage_eventContext differentiates from other interfaces.
	IsCoverage_eventContext()
}

type Coverage_eventContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCoverage_eventContext() *Coverage_eventContext {
	var p = new(Coverage_eventContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_coverage_event
	return p
}

func (*Coverage_eventContext) IsCoverage_eventContext() {}

func NewCoverage_eventContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Coverage_eventContext {
	var p = new(Coverage_eventContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_coverage_event

	return p
}

func (s *Coverage_eventContext) GetParser() antlr.Parser { return s.parser }

func (s *Coverage_eventContext) Clocking_event() IClocking_eventContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClocking_eventContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClocking_eventContext)
}

func (s *Coverage_eventContext) ATAT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserATAT, 0)
}

func (s *Coverage_eventContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Coverage_eventContext) Block_event_expression() IBlock_event_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_event_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlock_event_expressionContext)
}

func (s *Coverage_eventContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Coverage_eventContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Coverage_eventContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Coverage_eventContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterCoverage_event(s)
	}
}

func (s *Coverage_eventContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitCoverage_event(s)
	}
}

func (p *SystemVerilogParser) Coverage_event() (localctx ICoverage_eventContext) {
	this := p
	_ = this

	localctx = NewCoverage_eventContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 502, SystemVerilogParserRULE_coverage_event)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4484)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserAT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4478)
			p.Clocking_event()
		}

	case SystemVerilogParserATAT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4479)
			p.Match(SystemVerilogParserATAT)
		}
		{
			p.SetState(4480)
			p.Match(SystemVerilogParserLP)
		}
		{
			p.SetState(4481)
			p.block_event_expression(0)
		}
		{
			p.SetState(4482)
			p.Match(SystemVerilogParserRP)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IBlock_event_expressionContext is an interface to support dynamic dispatch.
type IBlock_event_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlock_event_expressionContext differentiates from other interfaces.
	IsBlock_event_expressionContext()
}

type Block_event_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlock_event_expressionContext() *Block_event_expressionContext {
	var p = new(Block_event_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_block_event_expression
	return p
}

func (*Block_event_expressionContext) IsBlock_event_expressionContext() {}

func NewBlock_event_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Block_event_expressionContext {
	var p = new(Block_event_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_block_event_expression

	return p
}

func (s *Block_event_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Block_event_expressionContext) Hierarchical_btf_identifier() IHierarchical_btf_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_btf_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_btf_identifierContext)
}

func (s *Block_event_expressionContext) KBEGIN() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKBEGIN, 0)
}

func (s *Block_event_expressionContext) KEND() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKEND, 0)
}

func (s *Block_event_expressionContext) AllBlock_event_expression() []IBlock_event_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBlock_event_expressionContext)(nil)).Elem())
	var tst = make([]IBlock_event_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBlock_event_expressionContext)
		}
	}

	return tst
}

func (s *Block_event_expressionContext) Block_event_expression(i int) IBlock_event_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_event_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBlock_event_expressionContext)
}

func (s *Block_event_expressionContext) KOR() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKOR, 0)
}

func (s *Block_event_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Block_event_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Block_event_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterBlock_event_expression(s)
	}
}

func (s *Block_event_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitBlock_event_expression(s)
	}
}

func (p *SystemVerilogParser) Block_event_expression() (localctx IBlock_event_expressionContext) {
	return p.block_event_expression(0)
}

func (p *SystemVerilogParser) block_event_expression(_p int) (localctx IBlock_event_expressionContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewBlock_event_expressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IBlock_event_expressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 504
	p.EnterRecursionRule(localctx, 504, SystemVerilogParserRULE_block_event_expression, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4487)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SystemVerilogParserKBEGIN || _la == SystemVerilogParserKEND) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(4488)
		p.Hierarchical_btf_identifier()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(4495)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 521, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewBlock_event_expressionContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, SystemVerilogParserRULE_block_event_expression)
			p.SetState(4490)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
			}
			{
				p.SetState(4491)
				p.Match(SystemVerilogParserKOR)
			}
			{
				p.SetState(4492)
				p.block_event_expression(3)
			}

		}
		p.SetState(4497)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 521, p.GetParserRuleContext())
	}

	return localctx
}

// IHierarchical_btf_identifierContext is an interface to support dynamic dispatch.
type IHierarchical_btf_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHierarchical_btf_identifierContext differentiates from other interfaces.
	IsHierarchical_btf_identifierContext()
}

type Hierarchical_btf_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHierarchical_btf_identifierContext() *Hierarchical_btf_identifierContext {
	var p = new(Hierarchical_btf_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_hierarchical_btf_identifier
	return p
}

func (*Hierarchical_btf_identifierContext) IsHierarchical_btf_identifierContext() {}

func NewHierarchical_btf_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Hierarchical_btf_identifierContext {
	var p = new(Hierarchical_btf_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_hierarchical_btf_identifier

	return p
}

func (s *Hierarchical_btf_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Hierarchical_btf_identifierContext) Hierarchical_tf_identifier() IHierarchical_tf_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_tf_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_tf_identifierContext)
}

func (s *Hierarchical_btf_identifierContext) Hierarchical_block_identifier() IHierarchical_block_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_block_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_block_identifierContext)
}

func (s *Hierarchical_btf_identifierContext) Method_identifier() IMethod_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMethod_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMethod_identifierContext)
}

func (s *Hierarchical_btf_identifierContext) Hierarchical_identifier() IHierarchical_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_identifierContext)
}

func (s *Hierarchical_btf_identifierContext) DOT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserDOT, 0)
}

func (s *Hierarchical_btf_identifierContext) Class_scope() IClass_scopeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_scopeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClass_scopeContext)
}

func (s *Hierarchical_btf_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Hierarchical_btf_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Hierarchical_btf_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterHierarchical_btf_identifier(s)
	}
}

func (s *Hierarchical_btf_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitHierarchical_btf_identifier(s)
	}
}

func (p *SystemVerilogParser) Hierarchical_btf_identifier() (localctx IHierarchical_btf_identifierContext) {
	this := p
	_ = this

	localctx = NewHierarchical_btf_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 506, SystemVerilogParserRULE_hierarchical_btf_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4507)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 523, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4498)
			p.Hierarchical_tf_identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4499)
			p.Hierarchical_block_identifier()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(4504)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 522, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4500)
				p.Hierarchical_identifier()
			}
			{
				p.SetState(4501)
				p.Match(SystemVerilogParserDOT)
			}

		} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 522, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(4503)
				p.Class_scope()
			}

		}
		{
			p.SetState(4506)
			p.Method_identifier()
		}

	}

	return localctx
}

// ICover_pointContext is an interface to support dynamic dispatch.
type ICover_pointContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCover_pointContext differentiates from other interfaces.
	IsCover_pointContext()
}

type Cover_pointContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCover_pointContext() *Cover_pointContext {
	var p = new(Cover_pointContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_cover_point
	return p
}

func (*Cover_pointContext) IsCover_pointContext() {}

func NewCover_pointContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cover_pointContext {
	var p = new(Cover_pointContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_cover_point

	return p
}

func (s *Cover_pointContext) GetParser() antlr.Parser { return s.parser }

func (s *Cover_pointContext) KCOVERPOINT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKCOVERPOINT, 0)
}

func (s *Cover_pointContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *Cover_pointContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Cover_pointContext) Bins_or_empty() IBins_or_emptyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBins_or_emptyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBins_or_emptyContext)
}

func (s *Cover_pointContext) Cover_point_identifier() ICover_point_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICover_point_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICover_point_identifierContext)
}

func (s *Cover_pointContext) COLON() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOLON, 0)
}

func (s *Cover_pointContext) KIFF() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKIFF, 0)
}

func (s *Cover_pointContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Cover_pointContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Cover_pointContext) Data_type_or_implicit() IData_type_or_implicitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IData_type_or_implicitContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IData_type_or_implicitContext)
}

func (s *Cover_pointContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cover_pointContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cover_pointContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterCover_point(s)
	}
}

func (s *Cover_pointContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitCover_point(s)
	}
}

func (p *SystemVerilogParser) Cover_point() (localctx ICover_pointContext) {
	this := p
	_ = this

	localctx = NewCover_pointContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 508, SystemVerilogParserRULE_cover_point)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4515)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserDUNIT || _la == SystemVerilogParserLB || (((_la-109)&-(0x1f+1)) == 0 && ((1<<uint((_la-109)))&((1<<(SystemVerilogParserKBIT-109))|(1<<(SystemVerilogParserKBYTE-109))|(1<<(SystemVerilogParserKCHANDLE-109)))) != 0) || _la == SystemVerilogParserKENUM || _la == SystemVerilogParserKEVENT || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SystemVerilogParserKINT-195))|(1<<(SystemVerilogParserKINTEGER-195))|(1<<(SystemVerilogParserKLOGIC-195))|(1<<(SystemVerilogParserKLONGINT-195)))) != 0) || (((_la-255)&-(0x1f+1)) == 0 && ((1<<uint((_la-255)))&((1<<(SystemVerilogParserKREAL-255))|(1<<(SystemVerilogParserKREALTIME-255))|(1<<(SystemVerilogParserKREG-255))|(1<<(SystemVerilogParserKSHORTINT-255))|(1<<(SystemVerilogParserKSHORTREAL-255))|(1<<(SystemVerilogParserKSIGNED-255)))) != 0) || (((_la-287)&-(0x1f+1)) == 0 && ((1<<uint((_la-287)))&((1<<(SystemVerilogParserKSTRING-287))|(1<<(SystemVerilogParserKSTRUCT-287))|(1<<(SystemVerilogParserKTIME-287))|(1<<(SystemVerilogParserKTYPE-287))|(1<<(SystemVerilogParserKUNION-287)))) != 0) || _la == SystemVerilogParserKUNSIGNED || _la == SystemVerilogParserKVIRTUAL || _la == SystemVerilogParserSIMPLE_IDENTIFIER {
		p.SetState(4510)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 524, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4509)
				p.Data_type_or_implicit()
			}

		}
		{
			p.SetState(4512)
			p.Cover_point_identifier()
		}
		{
			p.SetState(4513)
			p.Match(SystemVerilogParserCOLON)
		}

	}
	{
		p.SetState(4517)
		p.Match(SystemVerilogParserKCOVERPOINT)
	}
	{
		p.SetState(4518)
		p.expression(0)
	}
	p.SetState(4524)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserKIFF {
		{
			p.SetState(4519)
			p.Match(SystemVerilogParserKIFF)
		}
		{
			p.SetState(4520)
			p.Match(SystemVerilogParserLP)
		}
		{
			p.SetState(4521)
			p.expression(0)
		}
		{
			p.SetState(4522)
			p.Match(SystemVerilogParserRP)
		}

	}
	{
		p.SetState(4526)
		p.Bins_or_empty()
	}

	return localctx
}

// IBins_or_emptyContext is an interface to support dynamic dispatch.
type IBins_or_emptyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBins_or_emptyContext differentiates from other interfaces.
	IsBins_or_emptyContext()
}

type Bins_or_emptyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBins_or_emptyContext() *Bins_or_emptyContext {
	var p = new(Bins_or_emptyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_bins_or_empty
	return p
}

func (*Bins_or_emptyContext) IsBins_or_emptyContext() {}

func NewBins_or_emptyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bins_or_emptyContext {
	var p = new(Bins_or_emptyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_bins_or_empty

	return p
}

func (s *Bins_or_emptyContext) GetParser() antlr.Parser { return s.parser }

func (s *Bins_or_emptyContext) LC() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLC, 0)
}

func (s *Bins_or_emptyContext) RC() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRC, 0)
}

func (s *Bins_or_emptyContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Bins_or_emptyContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Bins_or_emptyContext) AllBins_or_options() []IBins_or_optionsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBins_or_optionsContext)(nil)).Elem())
	var tst = make([]IBins_or_optionsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBins_or_optionsContext)
		}
	}

	return tst
}

func (s *Bins_or_emptyContext) Bins_or_options(i int) IBins_or_optionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBins_or_optionsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBins_or_optionsContext)
}

func (s *Bins_or_emptyContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserSEMI)
}

func (s *Bins_or_emptyContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, i)
}

func (s *Bins_or_emptyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bins_or_emptyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Bins_or_emptyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterBins_or_empty(s)
	}
}

func (s *Bins_or_emptyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitBins_or_empty(s)
	}
}

func (p *SystemVerilogParser) Bins_or_empty() (localctx IBins_or_emptyContext) {
	this := p
	_ = this

	localctx = NewBins_or_emptyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 510, SystemVerilogParserRULE_bins_or_empty)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4545)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserLC:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4528)
			p.Match(SystemVerilogParserLC)
		}
		p.SetState(4532)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserLPS {
			{
				p.SetState(4529)
				p.Attribute_instance()
			}

			p.SetState(4534)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(4540)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserKBINS || _la == SystemVerilogParserKIGNORE_BINS || _la == SystemVerilogParserKILLEGAL_BINS || _la == SystemVerilogParserKOPTION || _la == SystemVerilogParserKTYPE_OPTION || _la == SystemVerilogParserKWILDCARD {
			{
				p.SetState(4535)
				p.Bins_or_options()
			}
			{
				p.SetState(4536)
				p.Match(SystemVerilogParserSEMI)
			}

			p.SetState(4542)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(4543)
			p.Match(SystemVerilogParserRC)
		}

	case SystemVerilogParserSEMI:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4544)
			p.Match(SystemVerilogParserSEMI)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IBins_or_optionsContext is an interface to support dynamic dispatch.
type IBins_or_optionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBins_or_optionsContext differentiates from other interfaces.
	IsBins_or_optionsContext()
}

type Bins_or_optionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBins_or_optionsContext() *Bins_or_optionsContext {
	var p = new(Bins_or_optionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_bins_or_options
	return p
}

func (*Bins_or_optionsContext) IsBins_or_optionsContext() {}

func NewBins_or_optionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bins_or_optionsContext {
	var p = new(Bins_or_optionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_bins_or_options

	return p
}

func (s *Bins_or_optionsContext) GetParser() antlr.Parser { return s.parser }

func (s *Bins_or_optionsContext) Coverage_option() ICoverage_optionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICoverage_optionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICoverage_optionContext)
}

func (s *Bins_or_optionsContext) Bins_keyword() IBins_keywordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBins_keywordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBins_keywordContext)
}

func (s *Bins_or_optionsContext) Bin_identifier() IBin_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBin_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBin_identifierContext)
}

func (s *Bins_or_optionsContext) EQ() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserEQ, 0)
}

func (s *Bins_or_optionsContext) Trans_list() ITrans_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITrans_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITrans_listContext)
}

func (s *Bins_or_optionsContext) KWILDCARD() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKWILDCARD, 0)
}

func (s *Bins_or_optionsContext) KIFF() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKIFF, 0)
}

func (s *Bins_or_optionsContext) AllLP() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserLP)
}

func (s *Bins_or_optionsContext) LP(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, i)
}

func (s *Bins_or_optionsContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Bins_or_optionsContext) AllRP() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserRP)
}

func (s *Bins_or_optionsContext) RP(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, i)
}

func (s *Bins_or_optionsContext) LC() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLC, 0)
}

func (s *Bins_or_optionsContext) Covergroup_range_list() ICovergroup_range_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICovergroup_range_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICovergroup_range_listContext)
}

func (s *Bins_or_optionsContext) RC() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRC, 0)
}

func (s *Bins_or_optionsContext) Cover_point_identifier() ICover_point_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICover_point_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICover_point_identifierContext)
}

func (s *Bins_or_optionsContext) KWITH() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKWITH, 0)
}

func (s *Bins_or_optionsContext) With_covergroup_expression() IWith_covergroup_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWith_covergroup_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWith_covergroup_expressionContext)
}

func (s *Bins_or_optionsContext) Set_covergroup_expression() ISet_covergroup_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISet_covergroup_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISet_covergroup_expressionContext)
}

func (s *Bins_or_optionsContext) LB() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLB, 0)
}

func (s *Bins_or_optionsContext) RB() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRB, 0)
}

func (s *Bins_or_optionsContext) Covergroup_expression() ICovergroup_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICovergroup_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICovergroup_expressionContext)
}

func (s *Bins_or_optionsContext) KDEFAULT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKDEFAULT, 0)
}

func (s *Bins_or_optionsContext) KSEQUENCE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKSEQUENCE, 0)
}

func (s *Bins_or_optionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bins_or_optionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Bins_or_optionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterBins_or_options(s)
	}
}

func (s *Bins_or_optionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitBins_or_options(s)
	}
}

func (p *SystemVerilogParser) Bins_or_options() (localctx IBins_or_optionsContext) {
	this := p
	_ = this

	localctx = NewBins_or_optionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 512, SystemVerilogParserRULE_bins_or_options)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4618)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 542, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4547)
			p.Coverage_option()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(4549)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserKWILDCARD {
			{
				p.SetState(4548)
				p.Match(SystemVerilogParserKWILDCARD)
			}

		}
		{
			p.SetState(4551)
			p.Bins_keyword()
		}
		{
			p.SetState(4552)
			p.Bin_identifier()
		}
		p.SetState(4586)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 536, p.GetParserRuleContext()) {
		case 1:
			p.SetState(4558)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == SystemVerilogParserLB {
				{
					p.SetState(4553)
					p.Match(SystemVerilogParserLB)
				}
				p.SetState(4555)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SystemVerilogParserMINUS)|(1<<SystemVerilogParserMINUSMINS)|(1<<SystemVerilogParserNOT)|(1<<SystemVerilogParserDOLLAR)|(1<<SystemVerilogParserDROOT)|(1<<SystemVerilogParserDUNIT)|(1<<SystemVerilogParserAND)|(1<<SystemVerilogParserLP))) != 0) || (((_la-51)&-(0x1f+1)) == 0 && ((1<<uint((_la-51)))&((1<<(SystemVerilogParserQUOTE-51))|(1<<(SystemVerilogParserCARET-51))|(1<<(SystemVerilogParserCARETSQUIG-51))|(1<<(SystemVerilogParserLC-51))|(1<<(SystemVerilogParserBAR-51))|(1<<(SystemVerilogParserSQUIG-51))|(1<<(SystemVerilogParserSQUIGAND-51))|(1<<(SystemVerilogParserSQUIGCARET-51))|(1<<(SystemVerilogParserSQUIGBAR-51))|(1<<(SystemVerilogParserPLUS-51))|(1<<(SystemVerilogParserPLUSPLUS-51)))) != 0) || (((_la-109)&-(0x1f+1)) == 0 && ((1<<uint((_la-109)))&((1<<(SystemVerilogParserKBIT-109))|(1<<(SystemVerilogParserKBYTE-109))|(1<<(SystemVerilogParserKCONST-109)))) != 0) || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SystemVerilogParserKINT-195))|(1<<(SystemVerilogParserKINTEGER-195))|(1<<(SystemVerilogParserKLOCAL-195))|(1<<(SystemVerilogParserKLOGIC-195))|(1<<(SystemVerilogParserKLONGINT-195)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(SystemVerilogParserKNULL-228))|(1<<(SystemVerilogParserKRANDOMIZE-228))|(1<<(SystemVerilogParserKREAL-228))|(1<<(SystemVerilogParserKREALTIME-228))|(1<<(SystemVerilogParserKREG-228)))) != 0) || (((_la-276)&-(0x1f+1)) == 0 && ((1<<uint((_la-276)))&((1<<(SystemVerilogParserKSHORTINT-276))|(1<<(SystemVerilogParserKSHORTREAL-276))|(1<<(SystemVerilogParserKSIGNED-276))|(1<<(SystemVerilogParserKSTD-276))|(1<<(SystemVerilogParserKSTRING-276))|(1<<(SystemVerilogParserKSUPER-276))|(1<<(SystemVerilogParserKTAGGED-276))|(1<<(SystemVerilogParserKTHIS-276))|(1<<(SystemVerilogParserKTIME-276)))) != 0) || _la == SystemVerilogParserKTYPE || _la == SystemVerilogParserKUNSIGNED || (((_la-345)&-(0x1f+1)) == 0 && ((1<<uint((_la-345)))&((1<<(SystemVerilogParserTIME_LITERAL-345))|(1<<(SystemVerilogParserDECIMAL_NUMBER-345))|(1<<(SystemVerilogParserBINARY_NUMBER-345))|(1<<(SystemVerilogParserOCTAL_NUMBER-345))|(1<<(SystemVerilogParserHEX_NUMBER-345))|(1<<(SystemVerilogParserREAL_NUMBER-345))|(1<<(SystemVerilogParserUNSIGNED_NUMBER-345))|(1<<(SystemVerilogParserSTRING_LITERAL-345))|(1<<(SystemVerilogParserSIMPLE_IDENTIFIER-345))|(1<<(SystemVerilogParserSYSTEM_TF_IDENTIFIER-345)))) != 0) {
					{
						p.SetState(4554)
						p.Covergroup_expression()
					}

				}
				{
					p.SetState(4557)
					p.Match(SystemVerilogParserRB)
				}

			}
			{
				p.SetState(4560)
				p.Match(SystemVerilogParserEQ)
			}
			p.SetState(4578)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 534, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(4561)
					p.Match(SystemVerilogParserLC)
				}
				{
					p.SetState(4562)
					p.Covergroup_range_list()
				}
				{
					p.SetState(4563)
					p.Match(SystemVerilogParserRC)
				}
				p.SetState(4569)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == SystemVerilogParserKWITH {
					{
						p.SetState(4564)
						p.Match(SystemVerilogParserKWITH)
					}
					{
						p.SetState(4565)
						p.Match(SystemVerilogParserLP)
					}
					{
						p.SetState(4566)
						p.With_covergroup_expression()
					}
					{
						p.SetState(4567)
						p.Match(SystemVerilogParserRP)
					}

				}

			case 2:
				{
					p.SetState(4571)
					p.Cover_point_identifier()
				}
				{
					p.SetState(4572)
					p.Match(SystemVerilogParserKWITH)
				}
				{
					p.SetState(4573)
					p.Match(SystemVerilogParserLP)
				}
				{
					p.SetState(4574)
					p.With_covergroup_expression()
				}
				{
					p.SetState(4575)
					p.Match(SystemVerilogParserRP)
				}

			case 3:
				{
					p.SetState(4577)
					p.Set_covergroup_expression()
				}

			}

		case 2:
			p.SetState(4582)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == SystemVerilogParserLB {
				{
					p.SetState(4580)
					p.Match(SystemVerilogParserLB)
				}
				{
					p.SetState(4581)
					p.Match(SystemVerilogParserRB)
				}

			}
			{
				p.SetState(4584)
				p.Match(SystemVerilogParserEQ)
			}
			{
				p.SetState(4585)
				p.Trans_list()
			}

		}
		p.SetState(4593)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserKIFF {
			{
				p.SetState(4588)
				p.Match(SystemVerilogParserKIFF)
			}
			{
				p.SetState(4589)
				p.Match(SystemVerilogParserLP)
			}
			{
				p.SetState(4590)
				p.expression(0)
			}
			{
				p.SetState(4591)
				p.Match(SystemVerilogParserRP)
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4595)
			p.Bins_keyword()
		}
		{
			p.SetState(4596)
			p.Bin_identifier()
		}
		p.SetState(4609)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 540, p.GetParserRuleContext()) {
		case 1:
			p.SetState(4602)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == SystemVerilogParserLB {
				{
					p.SetState(4597)
					p.Match(SystemVerilogParserLB)
				}
				p.SetState(4599)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SystemVerilogParserMINUS)|(1<<SystemVerilogParserMINUSMINS)|(1<<SystemVerilogParserNOT)|(1<<SystemVerilogParserDOLLAR)|(1<<SystemVerilogParserDROOT)|(1<<SystemVerilogParserDUNIT)|(1<<SystemVerilogParserAND)|(1<<SystemVerilogParserLP))) != 0) || (((_la-51)&-(0x1f+1)) == 0 && ((1<<uint((_la-51)))&((1<<(SystemVerilogParserQUOTE-51))|(1<<(SystemVerilogParserCARET-51))|(1<<(SystemVerilogParserCARETSQUIG-51))|(1<<(SystemVerilogParserLC-51))|(1<<(SystemVerilogParserBAR-51))|(1<<(SystemVerilogParserSQUIG-51))|(1<<(SystemVerilogParserSQUIGAND-51))|(1<<(SystemVerilogParserSQUIGCARET-51))|(1<<(SystemVerilogParserSQUIGBAR-51))|(1<<(SystemVerilogParserPLUS-51))|(1<<(SystemVerilogParserPLUSPLUS-51)))) != 0) || (((_la-109)&-(0x1f+1)) == 0 && ((1<<uint((_la-109)))&((1<<(SystemVerilogParserKBIT-109))|(1<<(SystemVerilogParserKBYTE-109))|(1<<(SystemVerilogParserKCONST-109)))) != 0) || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SystemVerilogParserKINT-195))|(1<<(SystemVerilogParserKINTEGER-195))|(1<<(SystemVerilogParserKLOCAL-195))|(1<<(SystemVerilogParserKLOGIC-195))|(1<<(SystemVerilogParserKLONGINT-195)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(SystemVerilogParserKNULL-228))|(1<<(SystemVerilogParserKRANDOMIZE-228))|(1<<(SystemVerilogParserKREAL-228))|(1<<(SystemVerilogParserKREALTIME-228))|(1<<(SystemVerilogParserKREG-228)))) != 0) || (((_la-276)&-(0x1f+1)) == 0 && ((1<<uint((_la-276)))&((1<<(SystemVerilogParserKSHORTINT-276))|(1<<(SystemVerilogParserKSHORTREAL-276))|(1<<(SystemVerilogParserKSIGNED-276))|(1<<(SystemVerilogParserKSTD-276))|(1<<(SystemVerilogParserKSTRING-276))|(1<<(SystemVerilogParserKSUPER-276))|(1<<(SystemVerilogParserKTAGGED-276))|(1<<(SystemVerilogParserKTHIS-276))|(1<<(SystemVerilogParserKTIME-276)))) != 0) || _la == SystemVerilogParserKTYPE || _la == SystemVerilogParserKUNSIGNED || (((_la-345)&-(0x1f+1)) == 0 && ((1<<uint((_la-345)))&((1<<(SystemVerilogParserTIME_LITERAL-345))|(1<<(SystemVerilogParserDECIMAL_NUMBER-345))|(1<<(SystemVerilogParserBINARY_NUMBER-345))|(1<<(SystemVerilogParserOCTAL_NUMBER-345))|(1<<(SystemVerilogParserHEX_NUMBER-345))|(1<<(SystemVerilogParserREAL_NUMBER-345))|(1<<(SystemVerilogParserUNSIGNED_NUMBER-345))|(1<<(SystemVerilogParserSTRING_LITERAL-345))|(1<<(SystemVerilogParserSIMPLE_IDENTIFIER-345))|(1<<(SystemVerilogParserSYSTEM_TF_IDENTIFIER-345)))) != 0) {
					{
						p.SetState(4598)
						p.Covergroup_expression()
					}

				}
				{
					p.SetState(4601)
					p.Match(SystemVerilogParserRB)
				}

			}
			{
				p.SetState(4604)
				p.Match(SystemVerilogParserEQ)
			}
			{
				p.SetState(4605)
				p.Match(SystemVerilogParserKDEFAULT)
			}

		case 2:
			{
				p.SetState(4606)
				p.Match(SystemVerilogParserEQ)
			}
			{
				p.SetState(4607)
				p.Match(SystemVerilogParserKDEFAULT)
			}
			{
				p.SetState(4608)
				p.Match(SystemVerilogParserKSEQUENCE)
			}

		}
		p.SetState(4616)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserKIFF {
			{
				p.SetState(4611)
				p.Match(SystemVerilogParserKIFF)
			}
			{
				p.SetState(4612)
				p.Match(SystemVerilogParserLP)
			}
			{
				p.SetState(4613)
				p.expression(0)
			}
			{
				p.SetState(4614)
				p.Match(SystemVerilogParserRP)
			}

		}

	}

	return localctx
}

// IBins_keywordContext is an interface to support dynamic dispatch.
type IBins_keywordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBins_keywordContext differentiates from other interfaces.
	IsBins_keywordContext()
}

type Bins_keywordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBins_keywordContext() *Bins_keywordContext {
	var p = new(Bins_keywordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_bins_keyword
	return p
}

func (*Bins_keywordContext) IsBins_keywordContext() {}

func NewBins_keywordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bins_keywordContext {
	var p = new(Bins_keywordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_bins_keyword

	return p
}

func (s *Bins_keywordContext) GetParser() antlr.Parser { return s.parser }

func (s *Bins_keywordContext) KBINS() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKBINS, 0)
}

func (s *Bins_keywordContext) KILLEGAL_BINS() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKILLEGAL_BINS, 0)
}

func (s *Bins_keywordContext) KIGNORE_BINS() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKIGNORE_BINS, 0)
}

func (s *Bins_keywordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bins_keywordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Bins_keywordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterBins_keyword(s)
	}
}

func (s *Bins_keywordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitBins_keyword(s)
	}
}

func (p *SystemVerilogParser) Bins_keyword() (localctx IBins_keywordContext) {
	this := p
	_ = this

	localctx = NewBins_keywordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 514, SystemVerilogParserRULE_bins_keyword)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4620)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SystemVerilogParserKBINS || _la == SystemVerilogParserKIGNORE_BINS || _la == SystemVerilogParserKILLEGAL_BINS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ITrans_listContext is an interface to support dynamic dispatch.
type ITrans_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTrans_listContext differentiates from other interfaces.
	IsTrans_listContext()
}

type Trans_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTrans_listContext() *Trans_listContext {
	var p = new(Trans_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_trans_list
	return p
}

func (*Trans_listContext) IsTrans_listContext() {}

func NewTrans_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Trans_listContext {
	var p = new(Trans_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_trans_list

	return p
}

func (s *Trans_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Trans_listContext) AllLP() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserLP)
}

func (s *Trans_listContext) LP(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, i)
}

func (s *Trans_listContext) AllTrans_set() []ITrans_setContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITrans_setContext)(nil)).Elem())
	var tst = make([]ITrans_setContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITrans_setContext)
		}
	}

	return tst
}

func (s *Trans_listContext) Trans_set(i int) ITrans_setContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITrans_setContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITrans_setContext)
}

func (s *Trans_listContext) AllRP() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserRP)
}

func (s *Trans_listContext) RP(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, i)
}

func (s *Trans_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *Trans_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *Trans_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Trans_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Trans_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterTrans_list(s)
	}
}

func (s *Trans_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitTrans_list(s)
	}
}

func (p *SystemVerilogParser) Trans_list() (localctx ITrans_listContext) {
	this := p
	_ = this

	localctx = NewTrans_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 516, SystemVerilogParserRULE_trans_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4622)
		p.Match(SystemVerilogParserLP)
	}
	{
		p.SetState(4623)
		p.Trans_set()
	}
	{
		p.SetState(4624)
		p.Match(SystemVerilogParserRP)
	}
	p.SetState(4632)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserCOMMA {
		{
			p.SetState(4625)
			p.Match(SystemVerilogParserCOMMA)
		}
		{
			p.SetState(4626)
			p.Match(SystemVerilogParserLP)
		}
		{
			p.SetState(4627)
			p.Trans_set()
		}
		{
			p.SetState(4628)
			p.Match(SystemVerilogParserRP)
		}

		p.SetState(4634)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ITrans_setContext is an interface to support dynamic dispatch.
type ITrans_setContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTrans_setContext differentiates from other interfaces.
	IsTrans_setContext()
}

type Trans_setContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTrans_setContext() *Trans_setContext {
	var p = new(Trans_setContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_trans_set
	return p
}

func (*Trans_setContext) IsTrans_setContext() {}

func NewTrans_setContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Trans_setContext {
	var p = new(Trans_setContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_trans_set

	return p
}

func (s *Trans_setContext) GetParser() antlr.Parser { return s.parser }

func (s *Trans_setContext) AllTrans_range_list() []ITrans_range_listContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITrans_range_listContext)(nil)).Elem())
	var tst = make([]ITrans_range_listContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITrans_range_listContext)
		}
	}

	return tst
}

func (s *Trans_setContext) Trans_range_list(i int) ITrans_range_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITrans_range_listContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITrans_range_listContext)
}

func (s *Trans_setContext) AllEQGT() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserEQGT)
}

func (s *Trans_setContext) EQGT(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserEQGT, i)
}

func (s *Trans_setContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Trans_setContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Trans_setContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterTrans_set(s)
	}
}

func (s *Trans_setContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitTrans_set(s)
	}
}

func (p *SystemVerilogParser) Trans_set() (localctx ITrans_setContext) {
	this := p
	_ = this

	localctx = NewTrans_setContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 518, SystemVerilogParserRULE_trans_set)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4635)
		p.Trans_range_list()
	}
	p.SetState(4640)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserEQGT {
		{
			p.SetState(4636)
			p.Match(SystemVerilogParserEQGT)
		}
		{
			p.SetState(4637)
			p.Trans_range_list()
		}

		p.SetState(4642)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ITrans_range_listContext is an interface to support dynamic dispatch.
type ITrans_range_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTrans_range_listContext differentiates from other interfaces.
	IsTrans_range_listContext()
}

type Trans_range_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTrans_range_listContext() *Trans_range_listContext {
	var p = new(Trans_range_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_trans_range_list
	return p
}

func (*Trans_range_listContext) IsTrans_range_listContext() {}

func NewTrans_range_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Trans_range_listContext {
	var p = new(Trans_range_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_trans_range_list

	return p
}

func (s *Trans_range_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Trans_range_listContext) Trans_item() ITrans_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITrans_itemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITrans_itemContext)
}

func (s *Trans_range_listContext) LB() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLB, 0)
}

func (s *Trans_range_listContext) Repeat_range() IRepeat_rangeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRepeat_rangeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRepeat_rangeContext)
}

func (s *Trans_range_listContext) RB() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRB, 0)
}

func (s *Trans_range_listContext) STAR() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSTAR, 0)
}

func (s *Trans_range_listContext) ARROW() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserARROW, 0)
}

func (s *Trans_range_listContext) EQ() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserEQ, 0)
}

func (s *Trans_range_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Trans_range_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Trans_range_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterTrans_range_list(s)
	}
}

func (s *Trans_range_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitTrans_range_list(s)
	}
}

func (p *SystemVerilogParser) Trans_range_list() (localctx ITrans_range_listContext) {
	this := p
	_ = this

	localctx = NewTrans_range_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 520, SystemVerilogParserRULE_trans_range_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4643)
		p.Trans_item()
	}
	p.SetState(4649)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserLB {
		{
			p.SetState(4644)
			p.Match(SystemVerilogParserLB)
		}
		{
			p.SetState(4645)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SystemVerilogParserSTAR || _la == SystemVerilogParserEQ || _la == SystemVerilogParserARROW) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(4646)
			p.Repeat_range()
		}
		{
			p.SetState(4647)
			p.Match(SystemVerilogParserRB)
		}

	}

	return localctx
}

// ITrans_itemContext is an interface to support dynamic dispatch.
type ITrans_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTrans_itemContext differentiates from other interfaces.
	IsTrans_itemContext()
}

type Trans_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTrans_itemContext() *Trans_itemContext {
	var p = new(Trans_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_trans_item
	return p
}

func (*Trans_itemContext) IsTrans_itemContext() {}

func NewTrans_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Trans_itemContext {
	var p = new(Trans_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_trans_item

	return p
}

func (s *Trans_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Trans_itemContext) Covergroup_range_list() ICovergroup_range_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICovergroup_range_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICovergroup_range_listContext)
}

func (s *Trans_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Trans_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Trans_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterTrans_item(s)
	}
}

func (s *Trans_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitTrans_item(s)
	}
}

func (p *SystemVerilogParser) Trans_item() (localctx ITrans_itemContext) {
	this := p
	_ = this

	localctx = NewTrans_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 522, SystemVerilogParserRULE_trans_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4651)
		p.Covergroup_range_list()
	}

	return localctx
}

// IRepeat_rangeContext is an interface to support dynamic dispatch.
type IRepeat_rangeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRepeat_rangeContext differentiates from other interfaces.
	IsRepeat_rangeContext()
}

type Repeat_rangeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRepeat_rangeContext() *Repeat_rangeContext {
	var p = new(Repeat_rangeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_repeat_range
	return p
}

func (*Repeat_rangeContext) IsRepeat_rangeContext() {}

func NewRepeat_rangeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Repeat_rangeContext {
	var p = new(Repeat_rangeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_repeat_range

	return p
}

func (s *Repeat_rangeContext) GetParser() antlr.Parser { return s.parser }

func (s *Repeat_rangeContext) AllCovergroup_expression() []ICovergroup_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICovergroup_expressionContext)(nil)).Elem())
	var tst = make([]ICovergroup_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICovergroup_expressionContext)
		}
	}

	return tst
}

func (s *Repeat_rangeContext) Covergroup_expression(i int) ICovergroup_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICovergroup_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICovergroup_expressionContext)
}

func (s *Repeat_rangeContext) COLON() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOLON, 0)
}

func (s *Repeat_rangeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Repeat_rangeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Repeat_rangeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterRepeat_range(s)
	}
}

func (s *Repeat_rangeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitRepeat_range(s)
	}
}

func (p *SystemVerilogParser) Repeat_range() (localctx IRepeat_rangeContext) {
	this := p
	_ = this

	localctx = NewRepeat_rangeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 524, SystemVerilogParserRULE_repeat_range)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4653)
		p.Covergroup_expression()
	}
	p.SetState(4656)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserCOLON {
		{
			p.SetState(4654)
			p.Match(SystemVerilogParserCOLON)
		}
		{
			p.SetState(4655)
			p.Covergroup_expression()
		}

	}

	return localctx
}

// ICover_crossContext is an interface to support dynamic dispatch.
type ICover_crossContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCover_crossContext differentiates from other interfaces.
	IsCover_crossContext()
}

type Cover_crossContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCover_crossContext() *Cover_crossContext {
	var p = new(Cover_crossContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_cover_cross
	return p
}

func (*Cover_crossContext) IsCover_crossContext() {}

func NewCover_crossContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cover_crossContext {
	var p = new(Cover_crossContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_cover_cross

	return p
}

func (s *Cover_crossContext) GetParser() antlr.Parser { return s.parser }

func (s *Cover_crossContext) KCROSS() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKCROSS, 0)
}

func (s *Cover_crossContext) List_of_cross_items() IList_of_cross_itemsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_cross_itemsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_cross_itemsContext)
}

func (s *Cover_crossContext) Cross_body() ICross_bodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICross_bodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICross_bodyContext)
}

func (s *Cover_crossContext) Cross_identifier() ICross_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICross_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICross_identifierContext)
}

func (s *Cover_crossContext) COLON() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOLON, 0)
}

func (s *Cover_crossContext) KIFF() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKIFF, 0)
}

func (s *Cover_crossContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Cover_crossContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Cover_crossContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Cover_crossContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cover_crossContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cover_crossContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterCover_cross(s)
	}
}

func (s *Cover_crossContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitCover_cross(s)
	}
}

func (p *SystemVerilogParser) Cover_cross() (localctx ICover_crossContext) {
	this := p
	_ = this

	localctx = NewCover_crossContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 526, SystemVerilogParserRULE_cover_cross)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4661)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserSIMPLE_IDENTIFIER {
		{
			p.SetState(4658)
			p.Cross_identifier()
		}
		{
			p.SetState(4659)
			p.Match(SystemVerilogParserCOLON)
		}

	}
	{
		p.SetState(4663)
		p.Match(SystemVerilogParserKCROSS)
	}
	{
		p.SetState(4664)
		p.List_of_cross_items()
	}
	p.SetState(4670)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserKIFF {
		{
			p.SetState(4665)
			p.Match(SystemVerilogParserKIFF)
		}
		{
			p.SetState(4666)
			p.Match(SystemVerilogParserLP)
		}
		{
			p.SetState(4667)
			p.expression(0)
		}
		{
			p.SetState(4668)
			p.Match(SystemVerilogParserRP)
		}

	}
	{
		p.SetState(4672)
		p.Cross_body()
	}

	return localctx
}

// IList_of_cross_itemsContext is an interface to support dynamic dispatch.
type IList_of_cross_itemsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_cross_itemsContext differentiates from other interfaces.
	IsList_of_cross_itemsContext()
}

type List_of_cross_itemsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_cross_itemsContext() *List_of_cross_itemsContext {
	var p = new(List_of_cross_itemsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_list_of_cross_items
	return p
}

func (*List_of_cross_itemsContext) IsList_of_cross_itemsContext() {}

func NewList_of_cross_itemsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_cross_itemsContext {
	var p = new(List_of_cross_itemsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_list_of_cross_items

	return p
}

func (s *List_of_cross_itemsContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_cross_itemsContext) AllCross_item() []ICross_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICross_itemContext)(nil)).Elem())
	var tst = make([]ICross_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICross_itemContext)
		}
	}

	return tst
}

func (s *List_of_cross_itemsContext) Cross_item(i int) ICross_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICross_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICross_itemContext)
}

func (s *List_of_cross_itemsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *List_of_cross_itemsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *List_of_cross_itemsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_cross_itemsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_cross_itemsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterList_of_cross_items(s)
	}
}

func (s *List_of_cross_itemsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitList_of_cross_items(s)
	}
}

func (p *SystemVerilogParser) List_of_cross_items() (localctx IList_of_cross_itemsContext) {
	this := p
	_ = this

	localctx = NewList_of_cross_itemsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 528, SystemVerilogParserRULE_list_of_cross_items)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4674)
		p.Cross_item()
	}
	{
		p.SetState(4675)
		p.Match(SystemVerilogParserCOMMA)
	}
	{
		p.SetState(4676)
		p.Cross_item()
	}
	p.SetState(4681)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserCOMMA {
		{
			p.SetState(4677)
			p.Match(SystemVerilogParserCOMMA)
		}
		{
			p.SetState(4678)
			p.Cross_item()
		}

		p.SetState(4683)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ICross_itemContext is an interface to support dynamic dispatch.
type ICross_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCross_itemContext differentiates from other interfaces.
	IsCross_itemContext()
}

type Cross_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCross_itemContext() *Cross_itemContext {
	var p = new(Cross_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_cross_item
	return p
}

func (*Cross_itemContext) IsCross_itemContext() {}

func NewCross_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cross_itemContext {
	var p = new(Cross_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_cross_item

	return p
}

func (s *Cross_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Cross_itemContext) Cover_point_identifier() ICover_point_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICover_point_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICover_point_identifierContext)
}

func (s *Cross_itemContext) Variable_identifier() IVariable_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_identifierContext)
}

func (s *Cross_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cross_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cross_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterCross_item(s)
	}
}

func (s *Cross_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitCross_item(s)
	}
}

func (p *SystemVerilogParser) Cross_item() (localctx ICross_itemContext) {
	this := p
	_ = this

	localctx = NewCross_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 530, SystemVerilogParserRULE_cross_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4686)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 550, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4684)
			p.Cover_point_identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4685)
			p.Variable_identifier()
		}

	}

	return localctx
}

// ICross_bodyContext is an interface to support dynamic dispatch.
type ICross_bodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCross_bodyContext differentiates from other interfaces.
	IsCross_bodyContext()
}

type Cross_bodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCross_bodyContext() *Cross_bodyContext {
	var p = new(Cross_bodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_cross_body
	return p
}

func (*Cross_bodyContext) IsCross_bodyContext() {}

func NewCross_bodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cross_bodyContext {
	var p = new(Cross_bodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_cross_body

	return p
}

func (s *Cross_bodyContext) GetParser() antlr.Parser { return s.parser }

func (s *Cross_bodyContext) LC() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLC, 0)
}

func (s *Cross_bodyContext) RC() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRC, 0)
}

func (s *Cross_bodyContext) AllCross_body_item() []ICross_body_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICross_body_itemContext)(nil)).Elem())
	var tst = make([]ICross_body_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICross_body_itemContext)
		}
	}

	return tst
}

func (s *Cross_bodyContext) Cross_body_item(i int) ICross_body_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICross_body_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICross_body_itemContext)
}

func (s *Cross_bodyContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserSEMI)
}

func (s *Cross_bodyContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, i)
}

func (s *Cross_bodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cross_bodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cross_bodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterCross_body(s)
	}
}

func (s *Cross_bodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitCross_body(s)
	}
}

func (p *SystemVerilogParser) Cross_body() (localctx ICross_bodyContext) {
	this := p
	_ = this

	localctx = NewCross_bodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 532, SystemVerilogParserRULE_cross_body)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4699)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserLC:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4688)
			p.Match(SystemVerilogParserLC)
		}
		p.SetState(4694)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserLPS || _la == SystemVerilogParserKBINS || (((_la-174)&-(0x1f+1)) == 0 && ((1<<uint((_la-174)))&((1<<(SystemVerilogParserKFUNCTION-174))|(1<<(SystemVerilogParserKIGNORE_BINS-174))|(1<<(SystemVerilogParserKILLEGAL_BINS-174)))) != 0) || _la == SystemVerilogParserKOPTION || _la == SystemVerilogParserKTYPE_OPTION {
			{
				p.SetState(4689)
				p.Cross_body_item()
			}
			{
				p.SetState(4690)
				p.Match(SystemVerilogParserSEMI)
			}

			p.SetState(4696)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(4697)
			p.Match(SystemVerilogParserRC)
		}

	case SystemVerilogParserSEMI:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4698)
			p.Match(SystemVerilogParserSEMI)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICross_body_itemContext is an interface to support dynamic dispatch.
type ICross_body_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCross_body_itemContext differentiates from other interfaces.
	IsCross_body_itemContext()
}

type Cross_body_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCross_body_itemContext() *Cross_body_itemContext {
	var p = new(Cross_body_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_cross_body_item
	return p
}

func (*Cross_body_itemContext) IsCross_body_itemContext() {}

func NewCross_body_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cross_body_itemContext {
	var p = new(Cross_body_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_cross_body_item

	return p
}

func (s *Cross_body_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Cross_body_itemContext) Function_declaration() IFunction_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_declarationContext)
}

func (s *Cross_body_itemContext) Bins_selection_or_option() IBins_selection_or_optionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBins_selection_or_optionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBins_selection_or_optionContext)
}

func (s *Cross_body_itemContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Cross_body_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cross_body_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cross_body_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterCross_body_item(s)
	}
}

func (s *Cross_body_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitCross_body_item(s)
	}
}

func (p *SystemVerilogParser) Cross_body_item() (localctx ICross_body_itemContext) {
	this := p
	_ = this

	localctx = NewCross_body_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 534, SystemVerilogParserRULE_cross_body_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4705)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserKFUNCTION:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4701)
			p.Function_declaration()
		}

	case SystemVerilogParserLPS, SystemVerilogParserKBINS, SystemVerilogParserKIGNORE_BINS, SystemVerilogParserKILLEGAL_BINS, SystemVerilogParserKOPTION, SystemVerilogParserKTYPE_OPTION:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4702)
			p.Bins_selection_or_option()
		}
		{
			p.SetState(4703)
			p.Match(SystemVerilogParserSEMI)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IBins_selection_or_optionContext is an interface to support dynamic dispatch.
type IBins_selection_or_optionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBins_selection_or_optionContext differentiates from other interfaces.
	IsBins_selection_or_optionContext()
}

type Bins_selection_or_optionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBins_selection_or_optionContext() *Bins_selection_or_optionContext {
	var p = new(Bins_selection_or_optionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_bins_selection_or_option
	return p
}

func (*Bins_selection_or_optionContext) IsBins_selection_or_optionContext() {}

func NewBins_selection_or_optionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bins_selection_or_optionContext {
	var p = new(Bins_selection_or_optionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_bins_selection_or_option

	return p
}

func (s *Bins_selection_or_optionContext) GetParser() antlr.Parser { return s.parser }

func (s *Bins_selection_or_optionContext) Coverage_option() ICoverage_optionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICoverage_optionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICoverage_optionContext)
}

func (s *Bins_selection_or_optionContext) Bins_selection() IBins_selectionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBins_selectionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBins_selectionContext)
}

func (s *Bins_selection_or_optionContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Bins_selection_or_optionContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Bins_selection_or_optionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bins_selection_or_optionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Bins_selection_or_optionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterBins_selection_or_option(s)
	}
}

func (s *Bins_selection_or_optionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitBins_selection_or_option(s)
	}
}

func (p *SystemVerilogParser) Bins_selection_or_option() (localctx IBins_selection_or_optionContext) {
	this := p
	_ = this

	localctx = NewBins_selection_or_optionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 536, SystemVerilogParserRULE_bins_selection_or_option)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4710)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserLPS {
		{
			p.SetState(4707)
			p.Attribute_instance()
		}

		p.SetState(4712)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(4715)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserKOPTION, SystemVerilogParserKTYPE_OPTION:
		{
			p.SetState(4713)
			p.Coverage_option()
		}

	case SystemVerilogParserKBINS, SystemVerilogParserKIGNORE_BINS, SystemVerilogParserKILLEGAL_BINS:
		{
			p.SetState(4714)
			p.Bins_selection()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IBins_selectionContext is an interface to support dynamic dispatch.
type IBins_selectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBins_selectionContext differentiates from other interfaces.
	IsBins_selectionContext()
}

type Bins_selectionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBins_selectionContext() *Bins_selectionContext {
	var p = new(Bins_selectionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_bins_selection
	return p
}

func (*Bins_selectionContext) IsBins_selectionContext() {}

func NewBins_selectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bins_selectionContext {
	var p = new(Bins_selectionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_bins_selection

	return p
}

func (s *Bins_selectionContext) GetParser() antlr.Parser { return s.parser }

func (s *Bins_selectionContext) Bins_keyword() IBins_keywordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBins_keywordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBins_keywordContext)
}

func (s *Bins_selectionContext) Bin_identifier() IBin_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBin_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBin_identifierContext)
}

func (s *Bins_selectionContext) EQ() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserEQ, 0)
}

func (s *Bins_selectionContext) Select_expression() ISelect_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelect_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelect_expressionContext)
}

func (s *Bins_selectionContext) KIFF() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKIFF, 0)
}

func (s *Bins_selectionContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Bins_selectionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Bins_selectionContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Bins_selectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bins_selectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Bins_selectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterBins_selection(s)
	}
}

func (s *Bins_selectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitBins_selection(s)
	}
}

func (p *SystemVerilogParser) Bins_selection() (localctx IBins_selectionContext) {
	this := p
	_ = this

	localctx = NewBins_selectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 538, SystemVerilogParserRULE_bins_selection)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4717)
		p.Bins_keyword()
	}
	{
		p.SetState(4718)
		p.Bin_identifier()
	}
	{
		p.SetState(4719)
		p.Match(SystemVerilogParserEQ)
	}
	{
		p.SetState(4720)
		p.select_expression(0)
	}
	p.SetState(4726)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserKIFF {
		{
			p.SetState(4721)
			p.Match(SystemVerilogParserKIFF)
		}
		{
			p.SetState(4722)
			p.Match(SystemVerilogParserLP)
		}
		{
			p.SetState(4723)
			p.expression(0)
		}
		{
			p.SetState(4724)
			p.Match(SystemVerilogParserRP)
		}

	}

	return localctx
}

// ISelect_expressionContext is an interface to support dynamic dispatch.
type ISelect_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelect_expressionContext differentiates from other interfaces.
	IsSelect_expressionContext()
}

type Select_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_expressionContext() *Select_expressionContext {
	var p = new(Select_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_select_expression
	return p
}

func (*Select_expressionContext) IsSelect_expressionContext() {}

func NewSelect_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_expressionContext {
	var p = new(Select_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_select_expression

	return p
}

func (s *Select_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_expressionContext) Select_condition() ISelect_conditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelect_conditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelect_conditionContext)
}

func (s *Select_expressionContext) NOT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserNOT, 0)
}

func (s *Select_expressionContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Select_expressionContext) AllSelect_expression() []ISelect_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISelect_expressionContext)(nil)).Elem())
	var tst = make([]ISelect_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISelect_expressionContext)
		}
	}

	return tst
}

func (s *Select_expressionContext) Select_expression(i int) ISelect_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelect_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISelect_expressionContext)
}

func (s *Select_expressionContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Select_expressionContext) Cross_identifier() ICross_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICross_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICross_identifierContext)
}

func (s *Select_expressionContext) Cross_set_expression() ICross_set_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICross_set_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICross_set_expressionContext)
}

func (s *Select_expressionContext) KMATCHES() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKMATCHES, 0)
}

func (s *Select_expressionContext) Integer_covergroup_expression() IInteger_covergroup_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInteger_covergroup_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInteger_covergroup_expressionContext)
}

func (s *Select_expressionContext) ANDAND() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserANDAND, 0)
}

func (s *Select_expressionContext) BARBAR() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserBARBAR, 0)
}

func (s *Select_expressionContext) KWITH() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKWITH, 0)
}

func (s *Select_expressionContext) With_covergroup_expression() IWith_covergroup_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWith_covergroup_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWith_covergroup_expressionContext)
}

func (s *Select_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Select_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterSelect_expression(s)
	}
}

func (s *Select_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitSelect_expression(s)
	}
}

func (p *SystemVerilogParser) Select_expression() (localctx ISelect_expressionContext) {
	return p.select_expression(0)
}

func (p *SystemVerilogParser) select_expression(_p int) (localctx ISelect_expressionContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewSelect_expressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ISelect_expressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 540
	p.EnterRecursionRule(localctx, 540, SystemVerilogParserRULE_select_expression, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4743)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 559, p.GetParserRuleContext()) {
	case 1:
		p.SetState(4730)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserNOT {
			{
				p.SetState(4729)
				p.Match(SystemVerilogParserNOT)
			}

		}
		{
			p.SetState(4732)
			p.Select_condition()
		}

	case 2:
		{
			p.SetState(4733)
			p.Match(SystemVerilogParserLP)
		}
		{
			p.SetState(4734)
			p.select_expression(0)
		}
		{
			p.SetState(4735)
			p.Match(SystemVerilogParserRP)
		}

	case 3:
		{
			p.SetState(4737)
			p.Cross_identifier()
		}

	case 4:
		{
			p.SetState(4738)
			p.Cross_set_expression()
		}
		p.SetState(4741)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 558, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4739)
				p.Match(SystemVerilogParserKMATCHES)
			}
			{
				p.SetState(4740)
				p.Integer_covergroup_expression()
			}

		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(4759)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 562, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(4757)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 561, p.GetParserRuleContext()) {
			case 1:
				localctx = NewSelect_expressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SystemVerilogParserRULE_select_expression)
				p.SetState(4745)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
				}
				{
					p.SetState(4746)
					_la = p.GetTokenStream().LA(1)

					if !(_la == SystemVerilogParserANDAND || _la == SystemVerilogParserBARBAR) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(4747)
					p.select_expression(6)
				}

			case 2:
				localctx = NewSelect_expressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SystemVerilogParserRULE_select_expression)
				p.SetState(4748)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				}
				{
					p.SetState(4749)
					p.Match(SystemVerilogParserKWITH)
				}
				{
					p.SetState(4750)
					p.Match(SystemVerilogParserLP)
				}
				{
					p.SetState(4751)
					p.With_covergroup_expression()
				}
				{
					p.SetState(4752)
					p.Match(SystemVerilogParserRP)
				}
				p.SetState(4755)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 560, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(4753)
						p.Match(SystemVerilogParserKMATCHES)
					}
					{
						p.SetState(4754)
						p.Integer_covergroup_expression()
					}

				}

			}

		}
		p.SetState(4761)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 562, p.GetParserRuleContext())
	}

	return localctx
}

// ISelect_conditionContext is an interface to support dynamic dispatch.
type ISelect_conditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelect_conditionContext differentiates from other interfaces.
	IsSelect_conditionContext()
}

type Select_conditionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_conditionContext() *Select_conditionContext {
	var p = new(Select_conditionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_select_condition
	return p
}

func (*Select_conditionContext) IsSelect_conditionContext() {}

func NewSelect_conditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_conditionContext {
	var p = new(Select_conditionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_select_condition

	return p
}

func (s *Select_conditionContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_conditionContext) KBINSOF() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKBINSOF, 0)
}

func (s *Select_conditionContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Select_conditionContext) Bins_expression() IBins_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBins_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBins_expressionContext)
}

func (s *Select_conditionContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Select_conditionContext) KINTERSECT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKINTERSECT, 0)
}

func (s *Select_conditionContext) LC() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLC, 0)
}

func (s *Select_conditionContext) Covergroup_range_list() ICovergroup_range_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICovergroup_range_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICovergroup_range_listContext)
}

func (s *Select_conditionContext) RC() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRC, 0)
}

func (s *Select_conditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_conditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Select_conditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterSelect_condition(s)
	}
}

func (s *Select_conditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitSelect_condition(s)
	}
}

func (p *SystemVerilogParser) Select_condition() (localctx ISelect_conditionContext) {
	this := p
	_ = this

	localctx = NewSelect_conditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 542, SystemVerilogParserRULE_select_condition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4762)
		p.Match(SystemVerilogParserKBINSOF)
	}
	{
		p.SetState(4763)
		p.Match(SystemVerilogParserLP)
	}
	{
		p.SetState(4764)
		p.Bins_expression()
	}
	{
		p.SetState(4765)
		p.Match(SystemVerilogParserRP)
	}
	p.SetState(4771)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 563, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4766)
			p.Match(SystemVerilogParserKINTERSECT)
		}
		{
			p.SetState(4767)
			p.Match(SystemVerilogParserLC)
		}
		{
			p.SetState(4768)
			p.Covergroup_range_list()
		}
		{
			p.SetState(4769)
			p.Match(SystemVerilogParserRC)
		}

	}

	return localctx
}

// IBins_expressionContext is an interface to support dynamic dispatch.
type IBins_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBins_expressionContext differentiates from other interfaces.
	IsBins_expressionContext()
}

type Bins_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBins_expressionContext() *Bins_expressionContext {
	var p = new(Bins_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_bins_expression
	return p
}

func (*Bins_expressionContext) IsBins_expressionContext() {}

func NewBins_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bins_expressionContext {
	var p = new(Bins_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_bins_expression

	return p
}

func (s *Bins_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Bins_expressionContext) Variable_identifier() IVariable_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_identifierContext)
}

func (s *Bins_expressionContext) Cover_point_identifier() ICover_point_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICover_point_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICover_point_identifierContext)
}

func (s *Bins_expressionContext) DOT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserDOT, 0)
}

func (s *Bins_expressionContext) Bin_identifier() IBin_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBin_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBin_identifierContext)
}

func (s *Bins_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bins_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Bins_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterBins_expression(s)
	}
}

func (s *Bins_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitBins_expression(s)
	}
}

func (p *SystemVerilogParser) Bins_expression() (localctx IBins_expressionContext) {
	this := p
	_ = this

	localctx = NewBins_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 544, SystemVerilogParserRULE_bins_expression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4779)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 565, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4773)
			p.Variable_identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4774)
			p.Cover_point_identifier()
		}
		p.SetState(4777)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserDOT {
			{
				p.SetState(4775)
				p.Match(SystemVerilogParserDOT)
			}
			{
				p.SetState(4776)
				p.Bin_identifier()
			}

		}

	}

	return localctx
}

// ICovergroup_range_listContext is an interface to support dynamic dispatch.
type ICovergroup_range_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCovergroup_range_listContext differentiates from other interfaces.
	IsCovergroup_range_listContext()
}

type Covergroup_range_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCovergroup_range_listContext() *Covergroup_range_listContext {
	var p = new(Covergroup_range_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_covergroup_range_list
	return p
}

func (*Covergroup_range_listContext) IsCovergroup_range_listContext() {}

func NewCovergroup_range_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Covergroup_range_listContext {
	var p = new(Covergroup_range_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_covergroup_range_list

	return p
}

func (s *Covergroup_range_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Covergroup_range_listContext) AllCovergroup_value_range() []ICovergroup_value_rangeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICovergroup_value_rangeContext)(nil)).Elem())
	var tst = make([]ICovergroup_value_rangeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICovergroup_value_rangeContext)
		}
	}

	return tst
}

func (s *Covergroup_range_listContext) Covergroup_value_range(i int) ICovergroup_value_rangeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICovergroup_value_rangeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICovergroup_value_rangeContext)
}

func (s *Covergroup_range_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *Covergroup_range_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *Covergroup_range_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Covergroup_range_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Covergroup_range_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterCovergroup_range_list(s)
	}
}

func (s *Covergroup_range_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitCovergroup_range_list(s)
	}
}

func (p *SystemVerilogParser) Covergroup_range_list() (localctx ICovergroup_range_listContext) {
	this := p
	_ = this

	localctx = NewCovergroup_range_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 546, SystemVerilogParserRULE_covergroup_range_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4781)
		p.Covergroup_value_range()
	}
	p.SetState(4786)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserCOMMA {
		{
			p.SetState(4782)
			p.Match(SystemVerilogParserCOMMA)
		}
		{
			p.SetState(4783)
			p.Covergroup_value_range()
		}

		p.SetState(4788)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ICovergroup_value_rangeContext is an interface to support dynamic dispatch.
type ICovergroup_value_rangeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCovergroup_value_rangeContext differentiates from other interfaces.
	IsCovergroup_value_rangeContext()
}

type Covergroup_value_rangeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCovergroup_value_rangeContext() *Covergroup_value_rangeContext {
	var p = new(Covergroup_value_rangeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_covergroup_value_range
	return p
}

func (*Covergroup_value_rangeContext) IsCovergroup_value_rangeContext() {}

func NewCovergroup_value_rangeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Covergroup_value_rangeContext {
	var p = new(Covergroup_value_rangeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_covergroup_value_range

	return p
}

func (s *Covergroup_value_rangeContext) GetParser() antlr.Parser { return s.parser }

func (s *Covergroup_value_rangeContext) AllCovergroup_expression() []ICovergroup_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICovergroup_expressionContext)(nil)).Elem())
	var tst = make([]ICovergroup_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICovergroup_expressionContext)
		}
	}

	return tst
}

func (s *Covergroup_value_rangeContext) Covergroup_expression(i int) ICovergroup_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICovergroup_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICovergroup_expressionContext)
}

func (s *Covergroup_value_rangeContext) LB() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLB, 0)
}

func (s *Covergroup_value_rangeContext) COLON() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOLON, 0)
}

func (s *Covergroup_value_rangeContext) RB() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRB, 0)
}

func (s *Covergroup_value_rangeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Covergroup_value_rangeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Covergroup_value_rangeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterCovergroup_value_range(s)
	}
}

func (s *Covergroup_value_rangeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitCovergroup_value_range(s)
	}
}

func (p *SystemVerilogParser) Covergroup_value_range() (localctx ICovergroup_value_rangeContext) {
	this := p
	_ = this

	localctx = NewCovergroup_value_rangeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 548, SystemVerilogParserRULE_covergroup_value_range)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4796)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserMINUS, SystemVerilogParserMINUSMINS, SystemVerilogParserNOT, SystemVerilogParserDOLLAR, SystemVerilogParserDROOT, SystemVerilogParserDUNIT, SystemVerilogParserAND, SystemVerilogParserLP, SystemVerilogParserQUOTE, SystemVerilogParserCARET, SystemVerilogParserCARETSQUIG, SystemVerilogParserLC, SystemVerilogParserBAR, SystemVerilogParserSQUIG, SystemVerilogParserSQUIGAND, SystemVerilogParserSQUIGCARET, SystemVerilogParserSQUIGBAR, SystemVerilogParserPLUS, SystemVerilogParserPLUSPLUS, SystemVerilogParserKBIT, SystemVerilogParserKBYTE, SystemVerilogParserKCONST, SystemVerilogParserKINT, SystemVerilogParserKINTEGER, SystemVerilogParserKLOCAL, SystemVerilogParserKLOGIC, SystemVerilogParserKLONGINT, SystemVerilogParserKNULL, SystemVerilogParserKRANDOMIZE, SystemVerilogParserKREAL, SystemVerilogParserKREALTIME, SystemVerilogParserKREG, SystemVerilogParserKSHORTINT, SystemVerilogParserKSHORTREAL, SystemVerilogParserKSIGNED, SystemVerilogParserKSTD, SystemVerilogParserKSTRING, SystemVerilogParserKSUPER, SystemVerilogParserKTAGGED, SystemVerilogParserKTHIS, SystemVerilogParserKTIME, SystemVerilogParserKTYPE, SystemVerilogParserKUNSIGNED, SystemVerilogParserTIME_LITERAL, SystemVerilogParserDECIMAL_NUMBER, SystemVerilogParserBINARY_NUMBER, SystemVerilogParserOCTAL_NUMBER, SystemVerilogParserHEX_NUMBER, SystemVerilogParserREAL_NUMBER, SystemVerilogParserUNSIGNED_NUMBER, SystemVerilogParserSTRING_LITERAL, SystemVerilogParserSIMPLE_IDENTIFIER, SystemVerilogParserSYSTEM_TF_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4789)
			p.Covergroup_expression()
		}

	case SystemVerilogParserLB:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4790)
			p.Match(SystemVerilogParserLB)
		}
		{
			p.SetState(4791)
			p.Covergroup_expression()
		}
		{
			p.SetState(4792)
			p.Match(SystemVerilogParserCOLON)
		}
		{
			p.SetState(4793)
			p.Covergroup_expression()
		}
		{
			p.SetState(4794)
			p.Match(SystemVerilogParserRB)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IWith_covergroup_expressionContext is an interface to support dynamic dispatch.
type IWith_covergroup_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWith_covergroup_expressionContext differentiates from other interfaces.
	IsWith_covergroup_expressionContext()
}

type With_covergroup_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWith_covergroup_expressionContext() *With_covergroup_expressionContext {
	var p = new(With_covergroup_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_with_covergroup_expression
	return p
}

func (*With_covergroup_expressionContext) IsWith_covergroup_expressionContext() {}

func NewWith_covergroup_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *With_covergroup_expressionContext {
	var p = new(With_covergroup_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_with_covergroup_expression

	return p
}

func (s *With_covergroup_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *With_covergroup_expressionContext) Covergroup_expression() ICovergroup_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICovergroup_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICovergroup_expressionContext)
}

func (s *With_covergroup_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *With_covergroup_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *With_covergroup_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterWith_covergroup_expression(s)
	}
}

func (s *With_covergroup_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitWith_covergroup_expression(s)
	}
}

func (p *SystemVerilogParser) With_covergroup_expression() (localctx IWith_covergroup_expressionContext) {
	this := p
	_ = this

	localctx = NewWith_covergroup_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 550, SystemVerilogParserRULE_with_covergroup_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4798)
		p.Covergroup_expression()
	}

	return localctx
}

// ISet_covergroup_expressionContext is an interface to support dynamic dispatch.
type ISet_covergroup_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSet_covergroup_expressionContext differentiates from other interfaces.
	IsSet_covergroup_expressionContext()
}

type Set_covergroup_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySet_covergroup_expressionContext() *Set_covergroup_expressionContext {
	var p = new(Set_covergroup_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_set_covergroup_expression
	return p
}

func (*Set_covergroup_expressionContext) IsSet_covergroup_expressionContext() {}

func NewSet_covergroup_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Set_covergroup_expressionContext {
	var p = new(Set_covergroup_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_set_covergroup_expression

	return p
}

func (s *Set_covergroup_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Set_covergroup_expressionContext) Covergroup_expression() ICovergroup_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICovergroup_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICovergroup_expressionContext)
}

func (s *Set_covergroup_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Set_covergroup_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Set_covergroup_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterSet_covergroup_expression(s)
	}
}

func (s *Set_covergroup_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitSet_covergroup_expression(s)
	}
}

func (p *SystemVerilogParser) Set_covergroup_expression() (localctx ISet_covergroup_expressionContext) {
	this := p
	_ = this

	localctx = NewSet_covergroup_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 552, SystemVerilogParserRULE_set_covergroup_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4800)
		p.Covergroup_expression()
	}

	return localctx
}

// IInteger_covergroup_expressionContext is an interface to support dynamic dispatch.
type IInteger_covergroup_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInteger_covergroup_expressionContext differentiates from other interfaces.
	IsInteger_covergroup_expressionContext()
}

type Integer_covergroup_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInteger_covergroup_expressionContext() *Integer_covergroup_expressionContext {
	var p = new(Integer_covergroup_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_integer_covergroup_expression
	return p
}

func (*Integer_covergroup_expressionContext) IsInteger_covergroup_expressionContext() {}

func NewInteger_covergroup_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Integer_covergroup_expressionContext {
	var p = new(Integer_covergroup_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_integer_covergroup_expression

	return p
}

func (s *Integer_covergroup_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Integer_covergroup_expressionContext) Covergroup_expression() ICovergroup_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICovergroup_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICovergroup_expressionContext)
}

func (s *Integer_covergroup_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Integer_covergroup_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Integer_covergroup_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterInteger_covergroup_expression(s)
	}
}

func (s *Integer_covergroup_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitInteger_covergroup_expression(s)
	}
}

func (p *SystemVerilogParser) Integer_covergroup_expression() (localctx IInteger_covergroup_expressionContext) {
	this := p
	_ = this

	localctx = NewInteger_covergroup_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 554, SystemVerilogParserRULE_integer_covergroup_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4802)
		p.Covergroup_expression()
	}

	return localctx
}

// ICross_set_expressionContext is an interface to support dynamic dispatch.
type ICross_set_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCross_set_expressionContext differentiates from other interfaces.
	IsCross_set_expressionContext()
}

type Cross_set_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCross_set_expressionContext() *Cross_set_expressionContext {
	var p = new(Cross_set_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_cross_set_expression
	return p
}

func (*Cross_set_expressionContext) IsCross_set_expressionContext() {}

func NewCross_set_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cross_set_expressionContext {
	var p = new(Cross_set_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_cross_set_expression

	return p
}

func (s *Cross_set_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Cross_set_expressionContext) Covergroup_expression() ICovergroup_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICovergroup_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICovergroup_expressionContext)
}

func (s *Cross_set_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cross_set_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cross_set_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterCross_set_expression(s)
	}
}

func (s *Cross_set_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitCross_set_expression(s)
	}
}

func (p *SystemVerilogParser) Cross_set_expression() (localctx ICross_set_expressionContext) {
	this := p
	_ = this

	localctx = NewCross_set_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 556, SystemVerilogParserRULE_cross_set_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4804)
		p.Covergroup_expression()
	}

	return localctx
}

// ICovergroup_expressionContext is an interface to support dynamic dispatch.
type ICovergroup_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCovergroup_expressionContext differentiates from other interfaces.
	IsCovergroup_expressionContext()
}

type Covergroup_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCovergroup_expressionContext() *Covergroup_expressionContext {
	var p = new(Covergroup_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_covergroup_expression
	return p
}

func (*Covergroup_expressionContext) IsCovergroup_expressionContext() {}

func NewCovergroup_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Covergroup_expressionContext {
	var p = new(Covergroup_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_covergroup_expression

	return p
}

func (s *Covergroup_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Covergroup_expressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Covergroup_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Covergroup_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Covergroup_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterCovergroup_expression(s)
	}
}

func (s *Covergroup_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitCovergroup_expression(s)
	}
}

func (p *SystemVerilogParser) Covergroup_expression() (localctx ICovergroup_expressionContext) {
	this := p
	_ = this

	localctx = NewCovergroup_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 558, SystemVerilogParserRULE_covergroup_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4806)
		p.expression(0)
	}

	return localctx
}

// ILet_declarationContext is an interface to support dynamic dispatch.
type ILet_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLet_declarationContext differentiates from other interfaces.
	IsLet_declarationContext()
}

type Let_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLet_declarationContext() *Let_declarationContext {
	var p = new(Let_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_let_declaration
	return p
}

func (*Let_declarationContext) IsLet_declarationContext() {}

func NewLet_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Let_declarationContext {
	var p = new(Let_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_let_declaration

	return p
}

func (s *Let_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Let_declarationContext) KLET() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKLET, 0)
}

func (s *Let_declarationContext) Let_identifier() ILet_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILet_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILet_identifierContext)
}

func (s *Let_declarationContext) EQ() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserEQ, 0)
}

func (s *Let_declarationContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Let_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Let_declarationContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Let_declarationContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Let_declarationContext) Let_port_list() ILet_port_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILet_port_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILet_port_listContext)
}

func (s *Let_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Let_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Let_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterLet_declaration(s)
	}
}

func (s *Let_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitLet_declaration(s)
	}
}

func (p *SystemVerilogParser) Let_declaration() (localctx ILet_declarationContext) {
	this := p
	_ = this

	localctx = NewLet_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 560, SystemVerilogParserRULE_let_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4808)
		p.Match(SystemVerilogParserKLET)
	}
	{
		p.SetState(4809)
		p.Let_identifier()
	}
	p.SetState(4815)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserLP {
		{
			p.SetState(4810)
			p.Match(SystemVerilogParserLP)
		}
		p.SetState(4812)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la-19)&-(0x1f+1)) == 0 && ((1<<uint((_la-19)))&((1<<(SystemVerilogParserDUNIT-19))|(1<<(SystemVerilogParserLPS-19))|(1<<(SystemVerilogParserLB-19)))) != 0) || (((_la-109)&-(0x1f+1)) == 0 && ((1<<uint((_la-109)))&((1<<(SystemVerilogParserKBIT-109))|(1<<(SystemVerilogParserKBYTE-109))|(1<<(SystemVerilogParserKCHANDLE-109)))) != 0) || _la == SystemVerilogParserKENUM || _la == SystemVerilogParserKEVENT || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SystemVerilogParserKINT-195))|(1<<(SystemVerilogParserKINTEGER-195))|(1<<(SystemVerilogParserKLOGIC-195))|(1<<(SystemVerilogParserKLONGINT-195)))) != 0) || (((_la-255)&-(0x1f+1)) == 0 && ((1<<uint((_la-255)))&((1<<(SystemVerilogParserKREAL-255))|(1<<(SystemVerilogParserKREALTIME-255))|(1<<(SystemVerilogParserKREG-255))|(1<<(SystemVerilogParserKSHORTINT-255))|(1<<(SystemVerilogParserKSHORTREAL-255))|(1<<(SystemVerilogParserKSIGNED-255)))) != 0) || (((_la-287)&-(0x1f+1)) == 0 && ((1<<uint((_la-287)))&((1<<(SystemVerilogParserKSTRING-287))|(1<<(SystemVerilogParserKSTRUCT-287))|(1<<(SystemVerilogParserKTIME-287))|(1<<(SystemVerilogParserKTYPE-287))|(1<<(SystemVerilogParserKUNION-287)))) != 0) || (((_la-319)&-(0x1f+1)) == 0 && ((1<<uint((_la-319)))&((1<<(SystemVerilogParserKUNSIGNED-319))|(1<<(SystemVerilogParserKUNTYPED-319))|(1<<(SystemVerilogParserKVIRTUAL-319)))) != 0) || _la == SystemVerilogParserSIMPLE_IDENTIFIER {
			{
				p.SetState(4811)
				p.Let_port_list()
			}

		}
		{
			p.SetState(4814)
			p.Match(SystemVerilogParserRP)
		}

	}
	{
		p.SetState(4817)
		p.Match(SystemVerilogParserEQ)
	}
	{
		p.SetState(4818)
		p.expression(0)
	}
	{
		p.SetState(4819)
		p.Match(SystemVerilogParserSEMI)
	}

	return localctx
}

// ILet_identifierContext is an interface to support dynamic dispatch.
type ILet_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLet_identifierContext differentiates from other interfaces.
	IsLet_identifierContext()
}

type Let_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLet_identifierContext() *Let_identifierContext {
	var p = new(Let_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_let_identifier
	return p
}

func (*Let_identifierContext) IsLet_identifierContext() {}

func NewLet_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Let_identifierContext {
	var p = new(Let_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_let_identifier

	return p
}

func (s *Let_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Let_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Let_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Let_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Let_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterLet_identifier(s)
	}
}

func (s *Let_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitLet_identifier(s)
	}
}

func (p *SystemVerilogParser) Let_identifier() (localctx ILet_identifierContext) {
	this := p
	_ = this

	localctx = NewLet_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 562, SystemVerilogParserRULE_let_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4821)
		p.Identifier()
	}

	return localctx
}

// ILet_port_listContext is an interface to support dynamic dispatch.
type ILet_port_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLet_port_listContext differentiates from other interfaces.
	IsLet_port_listContext()
}

type Let_port_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLet_port_listContext() *Let_port_listContext {
	var p = new(Let_port_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_let_port_list
	return p
}

func (*Let_port_listContext) IsLet_port_listContext() {}

func NewLet_port_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Let_port_listContext {
	var p = new(Let_port_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_let_port_list

	return p
}

func (s *Let_port_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Let_port_listContext) AllLet_port_item() []ILet_port_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILet_port_itemContext)(nil)).Elem())
	var tst = make([]ILet_port_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILet_port_itemContext)
		}
	}

	return tst
}

func (s *Let_port_listContext) Let_port_item(i int) ILet_port_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILet_port_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILet_port_itemContext)
}

func (s *Let_port_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *Let_port_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *Let_port_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Let_port_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Let_port_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterLet_port_list(s)
	}
}

func (s *Let_port_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitLet_port_list(s)
	}
}

func (p *SystemVerilogParser) Let_port_list() (localctx ILet_port_listContext) {
	this := p
	_ = this

	localctx = NewLet_port_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 564, SystemVerilogParserRULE_let_port_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4823)
		p.Let_port_item()
	}
	p.SetState(4828)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserCOMMA {
		{
			p.SetState(4824)
			p.Match(SystemVerilogParserCOMMA)
		}
		{
			p.SetState(4825)
			p.Let_port_item()
		}

		p.SetState(4830)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ILet_port_itemContext is an interface to support dynamic dispatch.
type ILet_port_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLet_port_itemContext differentiates from other interfaces.
	IsLet_port_itemContext()
}

type Let_port_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLet_port_itemContext() *Let_port_itemContext {
	var p = new(Let_port_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_let_port_item
	return p
}

func (*Let_port_itemContext) IsLet_port_itemContext() {}

func NewLet_port_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Let_port_itemContext {
	var p = new(Let_port_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_let_port_item

	return p
}

func (s *Let_port_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Let_port_itemContext) Let_formal_type() ILet_formal_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILet_formal_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILet_formal_typeContext)
}

func (s *Let_port_itemContext) Formal_port_identifier() IFormal_port_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormal_port_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFormal_port_identifierContext)
}

func (s *Let_port_itemContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Let_port_itemContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Let_port_itemContext) AllVariable_dimension() []IVariable_dimensionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariable_dimensionContext)(nil)).Elem())
	var tst = make([]IVariable_dimensionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariable_dimensionContext)
		}
	}

	return tst
}

func (s *Let_port_itemContext) Variable_dimension(i int) IVariable_dimensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_dimensionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariable_dimensionContext)
}

func (s *Let_port_itemContext) EQ() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserEQ, 0)
}

func (s *Let_port_itemContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Let_port_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Let_port_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Let_port_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterLet_port_item(s)
	}
}

func (s *Let_port_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitLet_port_item(s)
	}
}

func (p *SystemVerilogParser) Let_port_item() (localctx ILet_port_itemContext) {
	this := p
	_ = this

	localctx = NewLet_port_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 566, SystemVerilogParserRULE_let_port_item)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4834)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserLPS {
		{
			p.SetState(4831)
			p.Attribute_instance()
		}

		p.SetState(4836)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(4837)
		p.Let_formal_type()
	}
	{
		p.SetState(4838)
		p.Formal_port_identifier()
	}
	p.SetState(4842)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserLB {
		{
			p.SetState(4839)
			p.Variable_dimension()
		}

		p.SetState(4844)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(4847)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserEQ {
		{
			p.SetState(4845)
			p.Match(SystemVerilogParserEQ)
		}
		{
			p.SetState(4846)
			p.expression(0)
		}

	}

	return localctx
}

// ILet_formal_typeContext is an interface to support dynamic dispatch.
type ILet_formal_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLet_formal_typeContext differentiates from other interfaces.
	IsLet_formal_typeContext()
}

type Let_formal_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLet_formal_typeContext() *Let_formal_typeContext {
	var p = new(Let_formal_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_let_formal_type
	return p
}

func (*Let_formal_typeContext) IsLet_formal_typeContext() {}

func NewLet_formal_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Let_formal_typeContext {
	var p = new(Let_formal_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_let_formal_type

	return p
}

func (s *Let_formal_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Let_formal_typeContext) Data_type_or_implicit() IData_type_or_implicitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IData_type_or_implicitContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IData_type_or_implicitContext)
}

func (s *Let_formal_typeContext) KUNTYPED() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKUNTYPED, 0)
}

func (s *Let_formal_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Let_formal_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Let_formal_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterLet_formal_type(s)
	}
}

func (s *Let_formal_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitLet_formal_type(s)
	}
}

func (p *SystemVerilogParser) Let_formal_type() (localctx ILet_formal_typeContext) {
	this := p
	_ = this

	localctx = NewLet_formal_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 568, SystemVerilogParserRULE_let_formal_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4851)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserDUNIT, SystemVerilogParserLB, SystemVerilogParserKBIT, SystemVerilogParserKBYTE, SystemVerilogParserKCHANDLE, SystemVerilogParserKENUM, SystemVerilogParserKEVENT, SystemVerilogParserKINT, SystemVerilogParserKINTEGER, SystemVerilogParserKLOGIC, SystemVerilogParserKLONGINT, SystemVerilogParserKREAL, SystemVerilogParserKREALTIME, SystemVerilogParserKREG, SystemVerilogParserKSHORTINT, SystemVerilogParserKSHORTREAL, SystemVerilogParserKSIGNED, SystemVerilogParserKSTRING, SystemVerilogParserKSTRUCT, SystemVerilogParserKTIME, SystemVerilogParserKTYPE, SystemVerilogParserKUNION, SystemVerilogParserKUNSIGNED, SystemVerilogParserKVIRTUAL, SystemVerilogParserSIMPLE_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4849)
			p.Data_type_or_implicit()
		}

	case SystemVerilogParserKUNTYPED:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4850)
			p.Match(SystemVerilogParserKUNTYPED)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ILet_expressionContext is an interface to support dynamic dispatch.
type ILet_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLet_expressionContext differentiates from other interfaces.
	IsLet_expressionContext()
}

type Let_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLet_expressionContext() *Let_expressionContext {
	var p = new(Let_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_let_expression
	return p
}

func (*Let_expressionContext) IsLet_expressionContext() {}

func NewLet_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Let_expressionContext {
	var p = new(Let_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_let_expression

	return p
}

func (s *Let_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Let_expressionContext) Let_identifier() ILet_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILet_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILet_identifierContext)
}

func (s *Let_expressionContext) Package_scope() IPackage_scopeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackage_scopeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPackage_scopeContext)
}

func (s *Let_expressionContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Let_expressionContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Let_expressionContext) Let_list_of_arguments() ILet_list_of_argumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILet_list_of_argumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILet_list_of_argumentsContext)
}

func (s *Let_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Let_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Let_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterLet_expression(s)
	}
}

func (s *Let_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitLet_expression(s)
	}
}

func (p *SystemVerilogParser) Let_expression() (localctx ILet_expressionContext) {
	this := p
	_ = this

	localctx = NewLet_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 570, SystemVerilogParserRULE_let_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4854)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 575, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4853)
			p.Package_scope()
		}

	}
	{
		p.SetState(4856)
		p.Let_identifier()
	}
	p.SetState(4862)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 577, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4857)
			p.Match(SystemVerilogParserLP)
		}
		p.SetState(4859)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 576, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4858)
				p.Let_list_of_arguments()
			}

		}
		{
			p.SetState(4861)
			p.Match(SystemVerilogParserRP)
		}

	}

	return localctx
}

// ILet_list_of_argumentsContext is an interface to support dynamic dispatch.
type ILet_list_of_argumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLet_list_of_argumentsContext differentiates from other interfaces.
	IsLet_list_of_argumentsContext()
}

type Let_list_of_argumentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLet_list_of_argumentsContext() *Let_list_of_argumentsContext {
	var p = new(Let_list_of_argumentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_let_list_of_arguments
	return p
}

func (*Let_list_of_argumentsContext) IsLet_list_of_argumentsContext() {}

func NewLet_list_of_argumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Let_list_of_argumentsContext {
	var p = new(Let_list_of_argumentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_let_list_of_arguments

	return p
}

func (s *Let_list_of_argumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *Let_list_of_argumentsContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserDOT)
}

func (s *Let_list_of_argumentsContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserDOT, i)
}

func (s *Let_list_of_argumentsContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *Let_list_of_argumentsContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Let_list_of_argumentsContext) AllLP() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserLP)
}

func (s *Let_list_of_argumentsContext) LP(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, i)
}

func (s *Let_list_of_argumentsContext) AllRP() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserRP)
}

func (s *Let_list_of_argumentsContext) RP(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, i)
}

func (s *Let_list_of_argumentsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *Let_list_of_argumentsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *Let_list_of_argumentsContext) AllLet_actual_arg() []ILet_actual_argContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILet_actual_argContext)(nil)).Elem())
	var tst = make([]ILet_actual_argContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILet_actual_argContext)
		}
	}

	return tst
}

func (s *Let_list_of_argumentsContext) Let_actual_arg(i int) ILet_actual_argContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILet_actual_argContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILet_actual_argContext)
}

func (s *Let_list_of_argumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Let_list_of_argumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Let_list_of_argumentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterLet_list_of_arguments(s)
	}
}

func (s *Let_list_of_argumentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitLet_list_of_arguments(s)
	}
}

func (p *SystemVerilogParser) Let_list_of_arguments() (localctx ILet_list_of_argumentsContext) {
	this := p
	_ = this

	localctx = NewLet_list_of_argumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 572, SystemVerilogParserRULE_let_list_of_arguments)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4884)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserMINUS, SystemVerilogParserMINUSMINS, SystemVerilogParserNOT, SystemVerilogParserDOLLAR, SystemVerilogParserDROOT, SystemVerilogParserDUNIT, SystemVerilogParserAND, SystemVerilogParserLP, SystemVerilogParserRP, SystemVerilogParserCOMMA, SystemVerilogParserQUOTE, SystemVerilogParserCARET, SystemVerilogParserCARETSQUIG, SystemVerilogParserLC, SystemVerilogParserBAR, SystemVerilogParserSQUIG, SystemVerilogParserSQUIGAND, SystemVerilogParserSQUIGCARET, SystemVerilogParserSQUIGBAR, SystemVerilogParserPLUS, SystemVerilogParserPLUSPLUS, SystemVerilogParserKBIT, SystemVerilogParserKBYTE, SystemVerilogParserKCONST, SystemVerilogParserKINT, SystemVerilogParserKINTEGER, SystemVerilogParserKLOCAL, SystemVerilogParserKLOGIC, SystemVerilogParserKLONGINT, SystemVerilogParserKNULL, SystemVerilogParserKRANDOMIZE, SystemVerilogParserKREAL, SystemVerilogParserKREALTIME, SystemVerilogParserKREG, SystemVerilogParserKSHORTINT, SystemVerilogParserKSHORTREAL, SystemVerilogParserKSIGNED, SystemVerilogParserKSTD, SystemVerilogParserKSTRING, SystemVerilogParserKSUPER, SystemVerilogParserKTAGGED, SystemVerilogParserKTHIS, SystemVerilogParserKTIME, SystemVerilogParserKTYPE, SystemVerilogParserKUNSIGNED, SystemVerilogParserTIME_LITERAL, SystemVerilogParserDECIMAL_NUMBER, SystemVerilogParserBINARY_NUMBER, SystemVerilogParserOCTAL_NUMBER, SystemVerilogParserHEX_NUMBER, SystemVerilogParserREAL_NUMBER, SystemVerilogParserUNSIGNED_NUMBER, SystemVerilogParserSTRING_LITERAL, SystemVerilogParserSIMPLE_IDENTIFIER, SystemVerilogParserSYSTEM_TF_IDENTIFIER:
		p.SetState(4865)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SystemVerilogParserMINUS)|(1<<SystemVerilogParserMINUSMINS)|(1<<SystemVerilogParserNOT)|(1<<SystemVerilogParserDOLLAR)|(1<<SystemVerilogParserDROOT)|(1<<SystemVerilogParserDUNIT)|(1<<SystemVerilogParserAND)|(1<<SystemVerilogParserLP))) != 0) || (((_la-51)&-(0x1f+1)) == 0 && ((1<<uint((_la-51)))&((1<<(SystemVerilogParserQUOTE-51))|(1<<(SystemVerilogParserCARET-51))|(1<<(SystemVerilogParserCARETSQUIG-51))|(1<<(SystemVerilogParserLC-51))|(1<<(SystemVerilogParserBAR-51))|(1<<(SystemVerilogParserSQUIG-51))|(1<<(SystemVerilogParserSQUIGAND-51))|(1<<(SystemVerilogParserSQUIGCARET-51))|(1<<(SystemVerilogParserSQUIGBAR-51))|(1<<(SystemVerilogParserPLUS-51))|(1<<(SystemVerilogParserPLUSPLUS-51)))) != 0) || (((_la-109)&-(0x1f+1)) == 0 && ((1<<uint((_la-109)))&((1<<(SystemVerilogParserKBIT-109))|(1<<(SystemVerilogParserKBYTE-109))|(1<<(SystemVerilogParserKCONST-109)))) != 0) || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SystemVerilogParserKINT-195))|(1<<(SystemVerilogParserKINTEGER-195))|(1<<(SystemVerilogParserKLOCAL-195))|(1<<(SystemVerilogParserKLOGIC-195))|(1<<(SystemVerilogParserKLONGINT-195)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(SystemVerilogParserKNULL-228))|(1<<(SystemVerilogParserKRANDOMIZE-228))|(1<<(SystemVerilogParserKREAL-228))|(1<<(SystemVerilogParserKREALTIME-228))|(1<<(SystemVerilogParserKREG-228)))) != 0) || (((_la-276)&-(0x1f+1)) == 0 && ((1<<uint((_la-276)))&((1<<(SystemVerilogParserKSHORTINT-276))|(1<<(SystemVerilogParserKSHORTREAL-276))|(1<<(SystemVerilogParserKSIGNED-276))|(1<<(SystemVerilogParserKSTD-276))|(1<<(SystemVerilogParserKSTRING-276))|(1<<(SystemVerilogParserKSUPER-276))|(1<<(SystemVerilogParserKTAGGED-276))|(1<<(SystemVerilogParserKTHIS-276))|(1<<(SystemVerilogParserKTIME-276)))) != 0) || _la == SystemVerilogParserKTYPE || _la == SystemVerilogParserKUNSIGNED || (((_la-345)&-(0x1f+1)) == 0 && ((1<<uint((_la-345)))&((1<<(SystemVerilogParserTIME_LITERAL-345))|(1<<(SystemVerilogParserDECIMAL_NUMBER-345))|(1<<(SystemVerilogParserBINARY_NUMBER-345))|(1<<(SystemVerilogParserOCTAL_NUMBER-345))|(1<<(SystemVerilogParserHEX_NUMBER-345))|(1<<(SystemVerilogParserREAL_NUMBER-345))|(1<<(SystemVerilogParserUNSIGNED_NUMBER-345))|(1<<(SystemVerilogParserSTRING_LITERAL-345))|(1<<(SystemVerilogParserSIMPLE_IDENTIFIER-345))|(1<<(SystemVerilogParserSYSTEM_TF_IDENTIFIER-345)))) != 0) {
			{
				p.SetState(4864)
				p.Let_actual_arg()
			}

		}
		p.SetState(4873)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 580, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(4867)
					p.Match(SystemVerilogParserCOMMA)
				}
				p.SetState(4869)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SystemVerilogParserMINUS)|(1<<SystemVerilogParserMINUSMINS)|(1<<SystemVerilogParserNOT)|(1<<SystemVerilogParserDOLLAR)|(1<<SystemVerilogParserDROOT)|(1<<SystemVerilogParserDUNIT)|(1<<SystemVerilogParserAND)|(1<<SystemVerilogParserLP))) != 0) || (((_la-51)&-(0x1f+1)) == 0 && ((1<<uint((_la-51)))&((1<<(SystemVerilogParserQUOTE-51))|(1<<(SystemVerilogParserCARET-51))|(1<<(SystemVerilogParserCARETSQUIG-51))|(1<<(SystemVerilogParserLC-51))|(1<<(SystemVerilogParserBAR-51))|(1<<(SystemVerilogParserSQUIG-51))|(1<<(SystemVerilogParserSQUIGAND-51))|(1<<(SystemVerilogParserSQUIGCARET-51))|(1<<(SystemVerilogParserSQUIGBAR-51))|(1<<(SystemVerilogParserPLUS-51))|(1<<(SystemVerilogParserPLUSPLUS-51)))) != 0) || (((_la-109)&-(0x1f+1)) == 0 && ((1<<uint((_la-109)))&((1<<(SystemVerilogParserKBIT-109))|(1<<(SystemVerilogParserKBYTE-109))|(1<<(SystemVerilogParserKCONST-109)))) != 0) || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SystemVerilogParserKINT-195))|(1<<(SystemVerilogParserKINTEGER-195))|(1<<(SystemVerilogParserKLOCAL-195))|(1<<(SystemVerilogParserKLOGIC-195))|(1<<(SystemVerilogParserKLONGINT-195)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(SystemVerilogParserKNULL-228))|(1<<(SystemVerilogParserKRANDOMIZE-228))|(1<<(SystemVerilogParserKREAL-228))|(1<<(SystemVerilogParserKREALTIME-228))|(1<<(SystemVerilogParserKREG-228)))) != 0) || (((_la-276)&-(0x1f+1)) == 0 && ((1<<uint((_la-276)))&((1<<(SystemVerilogParserKSHORTINT-276))|(1<<(SystemVerilogParserKSHORTREAL-276))|(1<<(SystemVerilogParserKSIGNED-276))|(1<<(SystemVerilogParserKSTD-276))|(1<<(SystemVerilogParserKSTRING-276))|(1<<(SystemVerilogParserKSUPER-276))|(1<<(SystemVerilogParserKTAGGED-276))|(1<<(SystemVerilogParserKTHIS-276))|(1<<(SystemVerilogParserKTIME-276)))) != 0) || _la == SystemVerilogParserKTYPE || _la == SystemVerilogParserKUNSIGNED || (((_la-345)&-(0x1f+1)) == 0 && ((1<<uint((_la-345)))&((1<<(SystemVerilogParserTIME_LITERAL-345))|(1<<(SystemVerilogParserDECIMAL_NUMBER-345))|(1<<(SystemVerilogParserBINARY_NUMBER-345))|(1<<(SystemVerilogParserOCTAL_NUMBER-345))|(1<<(SystemVerilogParserHEX_NUMBER-345))|(1<<(SystemVerilogParserREAL_NUMBER-345))|(1<<(SystemVerilogParserUNSIGNED_NUMBER-345))|(1<<(SystemVerilogParserSTRING_LITERAL-345))|(1<<(SystemVerilogParserSIMPLE_IDENTIFIER-345))|(1<<(SystemVerilogParserSYSTEM_TF_IDENTIFIER-345)))) != 0) {
					{
						p.SetState(4868)
						p.Let_actual_arg()
					}

				}

			}
			p.SetState(4875)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 580, p.GetParserRuleContext())
		}

	case SystemVerilogParserDOT:
		{
			p.SetState(4876)
			p.Match(SystemVerilogParserDOT)
		}
		{
			p.SetState(4877)
			p.Identifier()
		}
		{
			p.SetState(4878)
			p.Match(SystemVerilogParserLP)
		}
		p.SetState(4880)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SystemVerilogParserMINUS)|(1<<SystemVerilogParserMINUSMINS)|(1<<SystemVerilogParserNOT)|(1<<SystemVerilogParserDOLLAR)|(1<<SystemVerilogParserDROOT)|(1<<SystemVerilogParserDUNIT)|(1<<SystemVerilogParserAND)|(1<<SystemVerilogParserLP))) != 0) || (((_la-51)&-(0x1f+1)) == 0 && ((1<<uint((_la-51)))&((1<<(SystemVerilogParserQUOTE-51))|(1<<(SystemVerilogParserCARET-51))|(1<<(SystemVerilogParserCARETSQUIG-51))|(1<<(SystemVerilogParserLC-51))|(1<<(SystemVerilogParserBAR-51))|(1<<(SystemVerilogParserSQUIG-51))|(1<<(SystemVerilogParserSQUIGAND-51))|(1<<(SystemVerilogParserSQUIGCARET-51))|(1<<(SystemVerilogParserSQUIGBAR-51))|(1<<(SystemVerilogParserPLUS-51))|(1<<(SystemVerilogParserPLUSPLUS-51)))) != 0) || (((_la-109)&-(0x1f+1)) == 0 && ((1<<uint((_la-109)))&((1<<(SystemVerilogParserKBIT-109))|(1<<(SystemVerilogParserKBYTE-109))|(1<<(SystemVerilogParserKCONST-109)))) != 0) || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SystemVerilogParserKINT-195))|(1<<(SystemVerilogParserKINTEGER-195))|(1<<(SystemVerilogParserKLOCAL-195))|(1<<(SystemVerilogParserKLOGIC-195))|(1<<(SystemVerilogParserKLONGINT-195)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(SystemVerilogParserKNULL-228))|(1<<(SystemVerilogParserKRANDOMIZE-228))|(1<<(SystemVerilogParserKREAL-228))|(1<<(SystemVerilogParserKREALTIME-228))|(1<<(SystemVerilogParserKREG-228)))) != 0) || (((_la-276)&-(0x1f+1)) == 0 && ((1<<uint((_la-276)))&((1<<(SystemVerilogParserKSHORTINT-276))|(1<<(SystemVerilogParserKSHORTREAL-276))|(1<<(SystemVerilogParserKSIGNED-276))|(1<<(SystemVerilogParserKSTD-276))|(1<<(SystemVerilogParserKSTRING-276))|(1<<(SystemVerilogParserKSUPER-276))|(1<<(SystemVerilogParserKTAGGED-276))|(1<<(SystemVerilogParserKTHIS-276))|(1<<(SystemVerilogParserKTIME-276)))) != 0) || _la == SystemVerilogParserKTYPE || _la == SystemVerilogParserKUNSIGNED || (((_la-345)&-(0x1f+1)) == 0 && ((1<<uint((_la-345)))&((1<<(SystemVerilogParserTIME_LITERAL-345))|(1<<(SystemVerilogParserDECIMAL_NUMBER-345))|(1<<(SystemVerilogParserBINARY_NUMBER-345))|(1<<(SystemVerilogParserOCTAL_NUMBER-345))|(1<<(SystemVerilogParserHEX_NUMBER-345))|(1<<(SystemVerilogParserREAL_NUMBER-345))|(1<<(SystemVerilogParserUNSIGNED_NUMBER-345))|(1<<(SystemVerilogParserSTRING_LITERAL-345))|(1<<(SystemVerilogParserSIMPLE_IDENTIFIER-345))|(1<<(SystemVerilogParserSYSTEM_TF_IDENTIFIER-345)))) != 0) {
			{
				p.SetState(4879)
				p.Let_actual_arg()
			}

		}
		{
			p.SetState(4882)
			p.Match(SystemVerilogParserRP)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(4897)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserCOMMA {
		{
			p.SetState(4886)
			p.Match(SystemVerilogParserCOMMA)
		}
		{
			p.SetState(4887)
			p.Match(SystemVerilogParserDOT)
		}
		{
			p.SetState(4888)
			p.Identifier()
		}
		{
			p.SetState(4889)
			p.Match(SystemVerilogParserLP)
		}
		p.SetState(4891)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SystemVerilogParserMINUS)|(1<<SystemVerilogParserMINUSMINS)|(1<<SystemVerilogParserNOT)|(1<<SystemVerilogParserDOLLAR)|(1<<SystemVerilogParserDROOT)|(1<<SystemVerilogParserDUNIT)|(1<<SystemVerilogParserAND)|(1<<SystemVerilogParserLP))) != 0) || (((_la-51)&-(0x1f+1)) == 0 && ((1<<uint((_la-51)))&((1<<(SystemVerilogParserQUOTE-51))|(1<<(SystemVerilogParserCARET-51))|(1<<(SystemVerilogParserCARETSQUIG-51))|(1<<(SystemVerilogParserLC-51))|(1<<(SystemVerilogParserBAR-51))|(1<<(SystemVerilogParserSQUIG-51))|(1<<(SystemVerilogParserSQUIGAND-51))|(1<<(SystemVerilogParserSQUIGCARET-51))|(1<<(SystemVerilogParserSQUIGBAR-51))|(1<<(SystemVerilogParserPLUS-51))|(1<<(SystemVerilogParserPLUSPLUS-51)))) != 0) || (((_la-109)&-(0x1f+1)) == 0 && ((1<<uint((_la-109)))&((1<<(SystemVerilogParserKBIT-109))|(1<<(SystemVerilogParserKBYTE-109))|(1<<(SystemVerilogParserKCONST-109)))) != 0) || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SystemVerilogParserKINT-195))|(1<<(SystemVerilogParserKINTEGER-195))|(1<<(SystemVerilogParserKLOCAL-195))|(1<<(SystemVerilogParserKLOGIC-195))|(1<<(SystemVerilogParserKLONGINT-195)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(SystemVerilogParserKNULL-228))|(1<<(SystemVerilogParserKRANDOMIZE-228))|(1<<(SystemVerilogParserKREAL-228))|(1<<(SystemVerilogParserKREALTIME-228))|(1<<(SystemVerilogParserKREG-228)))) != 0) || (((_la-276)&-(0x1f+1)) == 0 && ((1<<uint((_la-276)))&((1<<(SystemVerilogParserKSHORTINT-276))|(1<<(SystemVerilogParserKSHORTREAL-276))|(1<<(SystemVerilogParserKSIGNED-276))|(1<<(SystemVerilogParserKSTD-276))|(1<<(SystemVerilogParserKSTRING-276))|(1<<(SystemVerilogParserKSUPER-276))|(1<<(SystemVerilogParserKTAGGED-276))|(1<<(SystemVerilogParserKTHIS-276))|(1<<(SystemVerilogParserKTIME-276)))) != 0) || _la == SystemVerilogParserKTYPE || _la == SystemVerilogParserKUNSIGNED || (((_la-345)&-(0x1f+1)) == 0 && ((1<<uint((_la-345)))&((1<<(SystemVerilogParserTIME_LITERAL-345))|(1<<(SystemVerilogParserDECIMAL_NUMBER-345))|(1<<(SystemVerilogParserBINARY_NUMBER-345))|(1<<(SystemVerilogParserOCTAL_NUMBER-345))|(1<<(SystemVerilogParserHEX_NUMBER-345))|(1<<(SystemVerilogParserREAL_NUMBER-345))|(1<<(SystemVerilogParserUNSIGNED_NUMBER-345))|(1<<(SystemVerilogParserSTRING_LITERAL-345))|(1<<(SystemVerilogParserSIMPLE_IDENTIFIER-345))|(1<<(SystemVerilogParserSYSTEM_TF_IDENTIFIER-345)))) != 0) {
			{
				p.SetState(4890)
				p.Let_actual_arg()
			}

		}
		{
			p.SetState(4893)
			p.Match(SystemVerilogParserRP)
		}

		p.SetState(4899)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ILet_actual_argContext is an interface to support dynamic dispatch.
type ILet_actual_argContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLet_actual_argContext differentiates from other interfaces.
	IsLet_actual_argContext()
}

type Let_actual_argContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLet_actual_argContext() *Let_actual_argContext {
	var p = new(Let_actual_argContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_let_actual_arg
	return p
}

func (*Let_actual_argContext) IsLet_actual_argContext() {}

func NewLet_actual_argContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Let_actual_argContext {
	var p = new(Let_actual_argContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_let_actual_arg

	return p
}

func (s *Let_actual_argContext) GetParser() antlr.Parser { return s.parser }

func (s *Let_actual_argContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Let_actual_argContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Let_actual_argContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Let_actual_argContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterLet_actual_arg(s)
	}
}

func (s *Let_actual_argContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitLet_actual_arg(s)
	}
}

func (p *SystemVerilogParser) Let_actual_arg() (localctx ILet_actual_argContext) {
	this := p
	_ = this

	localctx = NewLet_actual_argContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 574, SystemVerilogParserRULE_let_actual_arg)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4900)
		p.expression(0)
	}

	return localctx
}

// IGate_instantiationContext is an interface to support dynamic dispatch.
type IGate_instantiationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGate_instantiationContext differentiates from other interfaces.
	IsGate_instantiationContext()
}

type Gate_instantiationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGate_instantiationContext() *Gate_instantiationContext {
	var p = new(Gate_instantiationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_gate_instantiation
	return p
}

func (*Gate_instantiationContext) IsGate_instantiationContext() {}

func NewGate_instantiationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Gate_instantiationContext {
	var p = new(Gate_instantiationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_gate_instantiation

	return p
}

func (s *Gate_instantiationContext) GetParser() antlr.Parser { return s.parser }

func (s *Gate_instantiationContext) Cmos_switchtype() ICmos_switchtypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmos_switchtypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICmos_switchtypeContext)
}

func (s *Gate_instantiationContext) AllCmos_switch_instance() []ICmos_switch_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICmos_switch_instanceContext)(nil)).Elem())
	var tst = make([]ICmos_switch_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICmos_switch_instanceContext)
		}
	}

	return tst
}

func (s *Gate_instantiationContext) Cmos_switch_instance(i int) ICmos_switch_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICmos_switch_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICmos_switch_instanceContext)
}

func (s *Gate_instantiationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Gate_instantiationContext) Delay3() IDelay3Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelay3Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelay3Context)
}

func (s *Gate_instantiationContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *Gate_instantiationContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *Gate_instantiationContext) Enable_gatetype() IEnable_gatetypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnable_gatetypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnable_gatetypeContext)
}

func (s *Gate_instantiationContext) AllEnable_gate_instance() []IEnable_gate_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEnable_gate_instanceContext)(nil)).Elem())
	var tst = make([]IEnable_gate_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEnable_gate_instanceContext)
		}
	}

	return tst
}

func (s *Gate_instantiationContext) Enable_gate_instance(i int) IEnable_gate_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnable_gate_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEnable_gate_instanceContext)
}

func (s *Gate_instantiationContext) Drive_strength() IDrive_strengthContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDrive_strengthContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDrive_strengthContext)
}

func (s *Gate_instantiationContext) Mos_switchtype() IMos_switchtypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMos_switchtypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMos_switchtypeContext)
}

func (s *Gate_instantiationContext) AllMos_switch_instance() []IMos_switch_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMos_switch_instanceContext)(nil)).Elem())
	var tst = make([]IMos_switch_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMos_switch_instanceContext)
		}
	}

	return tst
}

func (s *Gate_instantiationContext) Mos_switch_instance(i int) IMos_switch_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMos_switch_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMos_switch_instanceContext)
}

func (s *Gate_instantiationContext) N_input_gatetype() IN_input_gatetypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IN_input_gatetypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IN_input_gatetypeContext)
}

func (s *Gate_instantiationContext) AllN_input_gate_instance() []IN_input_gate_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IN_input_gate_instanceContext)(nil)).Elem())
	var tst = make([]IN_input_gate_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IN_input_gate_instanceContext)
		}
	}

	return tst
}

func (s *Gate_instantiationContext) N_input_gate_instance(i int) IN_input_gate_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IN_input_gate_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IN_input_gate_instanceContext)
}

func (s *Gate_instantiationContext) Delay2() IDelay2Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelay2Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelay2Context)
}

func (s *Gate_instantiationContext) N_output_gatetype() IN_output_gatetypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IN_output_gatetypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IN_output_gatetypeContext)
}

func (s *Gate_instantiationContext) AllN_output_gate_instance() []IN_output_gate_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IN_output_gate_instanceContext)(nil)).Elem())
	var tst = make([]IN_output_gate_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IN_output_gate_instanceContext)
		}
	}

	return tst
}

func (s *Gate_instantiationContext) N_output_gate_instance(i int) IN_output_gate_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IN_output_gate_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IN_output_gate_instanceContext)
}

func (s *Gate_instantiationContext) Pass_en_switchtype() IPass_en_switchtypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPass_en_switchtypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPass_en_switchtypeContext)
}

func (s *Gate_instantiationContext) AllPass_enable_switch_instance() []IPass_enable_switch_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPass_enable_switch_instanceContext)(nil)).Elem())
	var tst = make([]IPass_enable_switch_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPass_enable_switch_instanceContext)
		}
	}

	return tst
}

func (s *Gate_instantiationContext) Pass_enable_switch_instance(i int) IPass_enable_switch_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPass_enable_switch_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPass_enable_switch_instanceContext)
}

func (s *Gate_instantiationContext) Pass_switchtype() IPass_switchtypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPass_switchtypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPass_switchtypeContext)
}

func (s *Gate_instantiationContext) AllPass_switch_instance() []IPass_switch_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPass_switch_instanceContext)(nil)).Elem())
	var tst = make([]IPass_switch_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPass_switch_instanceContext)
		}
	}

	return tst
}

func (s *Gate_instantiationContext) Pass_switch_instance(i int) IPass_switch_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPass_switch_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPass_switch_instanceContext)
}

func (s *Gate_instantiationContext) KPULLDOWN() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKPULLDOWN, 0)
}

func (s *Gate_instantiationContext) AllPull_gate_instance() []IPull_gate_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPull_gate_instanceContext)(nil)).Elem())
	var tst = make([]IPull_gate_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPull_gate_instanceContext)
		}
	}

	return tst
}

func (s *Gate_instantiationContext) Pull_gate_instance(i int) IPull_gate_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPull_gate_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPull_gate_instanceContext)
}

func (s *Gate_instantiationContext) Pulldown_strength() IPulldown_strengthContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPulldown_strengthContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPulldown_strengthContext)
}

func (s *Gate_instantiationContext) KPULLUP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKPULLUP, 0)
}

func (s *Gate_instantiationContext) Pullup_strength() IPullup_strengthContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPullup_strengthContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPullup_strengthContext)
}

func (s *Gate_instantiationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Gate_instantiationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Gate_instantiationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterGate_instantiation(s)
	}
}

func (s *Gate_instantiationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitGate_instantiation(s)
	}
}

func (p *SystemVerilogParser) Gate_instantiation() (localctx IGate_instantiationContext) {
	this := p
	_ = this

	localctx = NewGate_instantiationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 576, SystemVerilogParserRULE_gate_instantiation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5034)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserKCMOS, SystemVerilogParserKRCMOS:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4902)
			p.Cmos_switchtype()
		}
		p.SetState(4904)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserP {
			{
				p.SetState(4903)
				p.Delay3()
			}

		}
		{
			p.SetState(4906)
			p.Cmos_switch_instance()
		}
		p.SetState(4911)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserCOMMA {
			{
				p.SetState(4907)
				p.Match(SystemVerilogParserCOMMA)
			}
			{
				p.SetState(4908)
				p.Cmos_switch_instance()
			}

			p.SetState(4913)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(4914)
			p.Match(SystemVerilogParserSEMI)
		}

	case SystemVerilogParserKBUFIF0, SystemVerilogParserKBUFIF1, SystemVerilogParserKNOTIF0, SystemVerilogParserKNOTIF1:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4916)
			p.Enable_gatetype()
		}
		p.SetState(4918)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 587, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4917)
				p.Drive_strength()
			}

		}
		p.SetState(4921)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserP {
			{
				p.SetState(4920)
				p.Delay3()
			}

		}
		{
			p.SetState(4923)
			p.Enable_gate_instance()
		}
		p.SetState(4928)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserCOMMA {
			{
				p.SetState(4924)
				p.Match(SystemVerilogParserCOMMA)
			}
			{
				p.SetState(4925)
				p.Enable_gate_instance()
			}

			p.SetState(4930)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(4931)
			p.Match(SystemVerilogParserSEMI)
		}

	case SystemVerilogParserKNMOS, SystemVerilogParserKPMOS, SystemVerilogParserKRNMOS, SystemVerilogParserKRPMOS:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4933)
			p.Mos_switchtype()
		}
		p.SetState(4935)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserP {
			{
				p.SetState(4934)
				p.Delay3()
			}

		}
		{
			p.SetState(4937)
			p.Mos_switch_instance()
		}
		p.SetState(4942)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserCOMMA {
			{
				p.SetState(4938)
				p.Match(SystemVerilogParserCOMMA)
			}
			{
				p.SetState(4939)
				p.Mos_switch_instance()
			}

			p.SetState(4944)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(4945)
			p.Match(SystemVerilogParserSEMI)
		}

	case SystemVerilogParserKAND, SystemVerilogParserKNAND, SystemVerilogParserKNOR, SystemVerilogParserKOR, SystemVerilogParserKXNOR, SystemVerilogParserKXOR:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4947)
			p.N_input_gatetype()
		}
		p.SetState(4949)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 592, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4948)
				p.Drive_strength()
			}

		}
		p.SetState(4952)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserP {
			{
				p.SetState(4951)
				p.Delay2()
			}

		}
		{
			p.SetState(4954)
			p.N_input_gate_instance()
		}
		p.SetState(4959)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserCOMMA {
			{
				p.SetState(4955)
				p.Match(SystemVerilogParserCOMMA)
			}
			{
				p.SetState(4956)
				p.N_input_gate_instance()
			}

			p.SetState(4961)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(4962)
			p.Match(SystemVerilogParserSEMI)
		}

	case SystemVerilogParserKBUF, SystemVerilogParserKNOT:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4964)
			p.N_output_gatetype()
		}
		p.SetState(4966)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 595, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4965)
				p.Drive_strength()
			}

		}
		p.SetState(4969)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserP {
			{
				p.SetState(4968)
				p.Delay2()
			}

		}
		{
			p.SetState(4971)
			p.N_output_gate_instance()
		}
		p.SetState(4976)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserCOMMA {
			{
				p.SetState(4972)
				p.Match(SystemVerilogParserCOMMA)
			}
			{
				p.SetState(4973)
				p.N_output_gate_instance()
			}

			p.SetState(4978)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(4979)
			p.Match(SystemVerilogParserSEMI)
		}

	case SystemVerilogParserKRTRANIF0, SystemVerilogParserKRTRANIF1, SystemVerilogParserKTRANIF0, SystemVerilogParserKTRANIF1:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4981)
			p.Pass_en_switchtype()
		}
		p.SetState(4983)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserP {
			{
				p.SetState(4982)
				p.Delay2()
			}

		}
		{
			p.SetState(4985)
			p.Pass_enable_switch_instance()
		}
		p.SetState(4990)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserCOMMA {
			{
				p.SetState(4986)
				p.Match(SystemVerilogParserCOMMA)
			}
			{
				p.SetState(4987)
				p.Pass_enable_switch_instance()
			}

			p.SetState(4992)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(4993)
			p.Match(SystemVerilogParserSEMI)
		}

	case SystemVerilogParserKRTRAN, SystemVerilogParserKTRAN:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(4995)
			p.Pass_switchtype()
		}
		{
			p.SetState(4996)
			p.Pass_switch_instance()
		}
		p.SetState(5001)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserCOMMA {
			{
				p.SetState(4997)
				p.Match(SystemVerilogParserCOMMA)
			}
			{
				p.SetState(4998)
				p.Pass_switch_instance()
			}

			p.SetState(5003)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(5004)
			p.Match(SystemVerilogParserSEMI)
		}

	case SystemVerilogParserKPULLDOWN:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(5006)
			p.Match(SystemVerilogParserKPULLDOWN)
		}
		p.SetState(5008)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 601, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5007)
				p.Pulldown_strength()
			}

		}
		{
			p.SetState(5010)
			p.Pull_gate_instance()
		}
		p.SetState(5015)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserCOMMA {
			{
				p.SetState(5011)
				p.Match(SystemVerilogParserCOMMA)
			}
			{
				p.SetState(5012)
				p.Pull_gate_instance()
			}

			p.SetState(5017)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(5018)
			p.Match(SystemVerilogParserSEMI)
		}

	case SystemVerilogParserKPULLUP:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(5020)
			p.Match(SystemVerilogParserKPULLUP)
		}
		p.SetState(5022)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 603, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5021)
				p.Pullup_strength()
			}

		}
		{
			p.SetState(5024)
			p.Pull_gate_instance()
		}
		p.SetState(5029)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserCOMMA {
			{
				p.SetState(5025)
				p.Match(SystemVerilogParserCOMMA)
			}
			{
				p.SetState(5026)
				p.Pull_gate_instance()
			}

			p.SetState(5031)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(5032)
			p.Match(SystemVerilogParserSEMI)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICmos_switch_instanceContext is an interface to support dynamic dispatch.
type ICmos_switch_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCmos_switch_instanceContext differentiates from other interfaces.
	IsCmos_switch_instanceContext()
}

type Cmos_switch_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmos_switch_instanceContext() *Cmos_switch_instanceContext {
	var p = new(Cmos_switch_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_cmos_switch_instance
	return p
}

func (*Cmos_switch_instanceContext) IsCmos_switch_instanceContext() {}

func NewCmos_switch_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmos_switch_instanceContext {
	var p = new(Cmos_switch_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_cmos_switch_instance

	return p
}

func (s *Cmos_switch_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmos_switch_instanceContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Cmos_switch_instanceContext) Output_terminal() IOutput_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOutput_terminalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOutput_terminalContext)
}

func (s *Cmos_switch_instanceContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *Cmos_switch_instanceContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *Cmos_switch_instanceContext) Input_terminal() IInput_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInput_terminalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInput_terminalContext)
}

func (s *Cmos_switch_instanceContext) Ncontrol_terminal() INcontrol_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INcontrol_terminalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INcontrol_terminalContext)
}

func (s *Cmos_switch_instanceContext) Pcontrol_terminal() IPcontrol_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPcontrol_terminalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPcontrol_terminalContext)
}

func (s *Cmos_switch_instanceContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Cmos_switch_instanceContext) Name_of_instance() IName_of_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_of_instanceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_of_instanceContext)
}

func (s *Cmos_switch_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmos_switch_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmos_switch_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterCmos_switch_instance(s)
	}
}

func (s *Cmos_switch_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitCmos_switch_instance(s)
	}
}

func (p *SystemVerilogParser) Cmos_switch_instance() (localctx ICmos_switch_instanceContext) {
	this := p
	_ = this

	localctx = NewCmos_switch_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 578, SystemVerilogParserRULE_cmos_switch_instance)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5037)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserSIMPLE_IDENTIFIER {
		{
			p.SetState(5036)
			p.Name_of_instance()
		}

	}
	{
		p.SetState(5039)
		p.Match(SystemVerilogParserLP)
	}
	{
		p.SetState(5040)
		p.Output_terminal()
	}
	{
		p.SetState(5041)
		p.Match(SystemVerilogParserCOMMA)
	}
	{
		p.SetState(5042)
		p.Input_terminal()
	}
	{
		p.SetState(5043)
		p.Match(SystemVerilogParserCOMMA)
	}
	{
		p.SetState(5044)
		p.Ncontrol_terminal()
	}
	{
		p.SetState(5045)
		p.Match(SystemVerilogParserCOMMA)
	}
	{
		p.SetState(5046)
		p.Pcontrol_terminal()
	}
	{
		p.SetState(5047)
		p.Match(SystemVerilogParserRP)
	}

	return localctx
}

// IEnable_gate_instanceContext is an interface to support dynamic dispatch.
type IEnable_gate_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnable_gate_instanceContext differentiates from other interfaces.
	IsEnable_gate_instanceContext()
}

type Enable_gate_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnable_gate_instanceContext() *Enable_gate_instanceContext {
	var p = new(Enable_gate_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_enable_gate_instance
	return p
}

func (*Enable_gate_instanceContext) IsEnable_gate_instanceContext() {}

func NewEnable_gate_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Enable_gate_instanceContext {
	var p = new(Enable_gate_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_enable_gate_instance

	return p
}

func (s *Enable_gate_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *Enable_gate_instanceContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Enable_gate_instanceContext) Output_terminal() IOutput_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOutput_terminalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOutput_terminalContext)
}

func (s *Enable_gate_instanceContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *Enable_gate_instanceContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *Enable_gate_instanceContext) Input_terminal() IInput_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInput_terminalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInput_terminalContext)
}

func (s *Enable_gate_instanceContext) Enable_terminal() IEnable_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnable_terminalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnable_terminalContext)
}

func (s *Enable_gate_instanceContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Enable_gate_instanceContext) Name_of_instance() IName_of_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_of_instanceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_of_instanceContext)
}

func (s *Enable_gate_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Enable_gate_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Enable_gate_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterEnable_gate_instance(s)
	}
}

func (s *Enable_gate_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitEnable_gate_instance(s)
	}
}

func (p *SystemVerilogParser) Enable_gate_instance() (localctx IEnable_gate_instanceContext) {
	this := p
	_ = this

	localctx = NewEnable_gate_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 580, SystemVerilogParserRULE_enable_gate_instance)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5050)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserSIMPLE_IDENTIFIER {
		{
			p.SetState(5049)
			p.Name_of_instance()
		}

	}
	{
		p.SetState(5052)
		p.Match(SystemVerilogParserLP)
	}
	{
		p.SetState(5053)
		p.Output_terminal()
	}
	{
		p.SetState(5054)
		p.Match(SystemVerilogParserCOMMA)
	}
	{
		p.SetState(5055)
		p.Input_terminal()
	}
	{
		p.SetState(5056)
		p.Match(SystemVerilogParserCOMMA)
	}
	{
		p.SetState(5057)
		p.Enable_terminal()
	}
	{
		p.SetState(5058)
		p.Match(SystemVerilogParserRP)
	}

	return localctx
}

// IMos_switch_instanceContext is an interface to support dynamic dispatch.
type IMos_switch_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMos_switch_instanceContext differentiates from other interfaces.
	IsMos_switch_instanceContext()
}

type Mos_switch_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMos_switch_instanceContext() *Mos_switch_instanceContext {
	var p = new(Mos_switch_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_mos_switch_instance
	return p
}

func (*Mos_switch_instanceContext) IsMos_switch_instanceContext() {}

func NewMos_switch_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Mos_switch_instanceContext {
	var p = new(Mos_switch_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_mos_switch_instance

	return p
}

func (s *Mos_switch_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *Mos_switch_instanceContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Mos_switch_instanceContext) Output_terminal() IOutput_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOutput_terminalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOutput_terminalContext)
}

func (s *Mos_switch_instanceContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *Mos_switch_instanceContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *Mos_switch_instanceContext) Input_terminal() IInput_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInput_terminalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInput_terminalContext)
}

func (s *Mos_switch_instanceContext) Enable_terminal() IEnable_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnable_terminalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnable_terminalContext)
}

func (s *Mos_switch_instanceContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Mos_switch_instanceContext) Name_of_instance() IName_of_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_of_instanceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_of_instanceContext)
}

func (s *Mos_switch_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Mos_switch_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Mos_switch_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterMos_switch_instance(s)
	}
}

func (s *Mos_switch_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitMos_switch_instance(s)
	}
}

func (p *SystemVerilogParser) Mos_switch_instance() (localctx IMos_switch_instanceContext) {
	this := p
	_ = this

	localctx = NewMos_switch_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 582, SystemVerilogParserRULE_mos_switch_instance)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5061)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserSIMPLE_IDENTIFIER {
		{
			p.SetState(5060)
			p.Name_of_instance()
		}

	}
	{
		p.SetState(5063)
		p.Match(SystemVerilogParserLP)
	}
	{
		p.SetState(5064)
		p.Output_terminal()
	}
	{
		p.SetState(5065)
		p.Match(SystemVerilogParserCOMMA)
	}
	{
		p.SetState(5066)
		p.Input_terminal()
	}
	{
		p.SetState(5067)
		p.Match(SystemVerilogParserCOMMA)
	}
	{
		p.SetState(5068)
		p.Enable_terminal()
	}
	{
		p.SetState(5069)
		p.Match(SystemVerilogParserRP)
	}

	return localctx
}

// IN_input_gate_instanceContext is an interface to support dynamic dispatch.
type IN_input_gate_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsN_input_gate_instanceContext differentiates from other interfaces.
	IsN_input_gate_instanceContext()
}

type N_input_gate_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyN_input_gate_instanceContext() *N_input_gate_instanceContext {
	var p = new(N_input_gate_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_n_input_gate_instance
	return p
}

func (*N_input_gate_instanceContext) IsN_input_gate_instanceContext() {}

func NewN_input_gate_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *N_input_gate_instanceContext {
	var p = new(N_input_gate_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_n_input_gate_instance

	return p
}

func (s *N_input_gate_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *N_input_gate_instanceContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *N_input_gate_instanceContext) Output_terminal() IOutput_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOutput_terminalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOutput_terminalContext)
}

func (s *N_input_gate_instanceContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *N_input_gate_instanceContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *N_input_gate_instanceContext) AllInput_terminal() []IInput_terminalContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInput_terminalContext)(nil)).Elem())
	var tst = make([]IInput_terminalContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInput_terminalContext)
		}
	}

	return tst
}

func (s *N_input_gate_instanceContext) Input_terminal(i int) IInput_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInput_terminalContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInput_terminalContext)
}

func (s *N_input_gate_instanceContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *N_input_gate_instanceContext) Name_of_instance() IName_of_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_of_instanceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_of_instanceContext)
}

func (s *N_input_gate_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *N_input_gate_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *N_input_gate_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterN_input_gate_instance(s)
	}
}

func (s *N_input_gate_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitN_input_gate_instance(s)
	}
}

func (p *SystemVerilogParser) N_input_gate_instance() (localctx IN_input_gate_instanceContext) {
	this := p
	_ = this

	localctx = NewN_input_gate_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 584, SystemVerilogParserRULE_n_input_gate_instance)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5072)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserSIMPLE_IDENTIFIER {
		{
			p.SetState(5071)
			p.Name_of_instance()
		}

	}
	{
		p.SetState(5074)
		p.Match(SystemVerilogParserLP)
	}
	{
		p.SetState(5075)
		p.Output_terminal()
	}
	{
		p.SetState(5076)
		p.Match(SystemVerilogParserCOMMA)
	}
	{
		p.SetState(5077)
		p.Input_terminal()
	}
	p.SetState(5082)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserCOMMA {
		{
			p.SetState(5078)
			p.Match(SystemVerilogParserCOMMA)
		}
		{
			p.SetState(5079)
			p.Input_terminal()
		}

		p.SetState(5084)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(5085)
		p.Match(SystemVerilogParserRP)
	}

	return localctx
}

// IN_output_gate_instanceContext is an interface to support dynamic dispatch.
type IN_output_gate_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsN_output_gate_instanceContext differentiates from other interfaces.
	IsN_output_gate_instanceContext()
}

type N_output_gate_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyN_output_gate_instanceContext() *N_output_gate_instanceContext {
	var p = new(N_output_gate_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_n_output_gate_instance
	return p
}

func (*N_output_gate_instanceContext) IsN_output_gate_instanceContext() {}

func NewN_output_gate_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *N_output_gate_instanceContext {
	var p = new(N_output_gate_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_n_output_gate_instance

	return p
}

func (s *N_output_gate_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *N_output_gate_instanceContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *N_output_gate_instanceContext) AllOutput_terminal() []IOutput_terminalContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOutput_terminalContext)(nil)).Elem())
	var tst = make([]IOutput_terminalContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOutput_terminalContext)
		}
	}

	return tst
}

func (s *N_output_gate_instanceContext) Output_terminal(i int) IOutput_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOutput_terminalContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOutput_terminalContext)
}

func (s *N_output_gate_instanceContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *N_output_gate_instanceContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *N_output_gate_instanceContext) Input_terminal() IInput_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInput_terminalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInput_terminalContext)
}

func (s *N_output_gate_instanceContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *N_output_gate_instanceContext) Name_of_instance() IName_of_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_of_instanceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_of_instanceContext)
}

func (s *N_output_gate_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *N_output_gate_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *N_output_gate_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterN_output_gate_instance(s)
	}
}

func (s *N_output_gate_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitN_output_gate_instance(s)
	}
}

func (p *SystemVerilogParser) N_output_gate_instance() (localctx IN_output_gate_instanceContext) {
	this := p
	_ = this

	localctx = NewN_output_gate_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 586, SystemVerilogParserRULE_n_output_gate_instance)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5088)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserSIMPLE_IDENTIFIER {
		{
			p.SetState(5087)
			p.Name_of_instance()
		}

	}
	{
		p.SetState(5090)
		p.Match(SystemVerilogParserLP)
	}
	{
		p.SetState(5091)
		p.Output_terminal()
	}
	p.SetState(5096)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 612, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(5092)
				p.Match(SystemVerilogParserCOMMA)
			}
			{
				p.SetState(5093)
				p.Output_terminal()
			}

		}
		p.SetState(5098)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 612, p.GetParserRuleContext())
	}
	{
		p.SetState(5099)
		p.Match(SystemVerilogParserCOMMA)
	}
	{
		p.SetState(5100)
		p.Input_terminal()
	}
	{
		p.SetState(5101)
		p.Match(SystemVerilogParserRP)
	}

	return localctx
}

// IPass_switch_instanceContext is an interface to support dynamic dispatch.
type IPass_switch_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPass_switch_instanceContext differentiates from other interfaces.
	IsPass_switch_instanceContext()
}

type Pass_switch_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPass_switch_instanceContext() *Pass_switch_instanceContext {
	var p = new(Pass_switch_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_pass_switch_instance
	return p
}

func (*Pass_switch_instanceContext) IsPass_switch_instanceContext() {}

func NewPass_switch_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pass_switch_instanceContext {
	var p = new(Pass_switch_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_pass_switch_instance

	return p
}

func (s *Pass_switch_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *Pass_switch_instanceContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Pass_switch_instanceContext) AllInout_terminal() []IInout_terminalContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInout_terminalContext)(nil)).Elem())
	var tst = make([]IInout_terminalContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInout_terminalContext)
		}
	}

	return tst
}

func (s *Pass_switch_instanceContext) Inout_terminal(i int) IInout_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInout_terminalContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInout_terminalContext)
}

func (s *Pass_switch_instanceContext) COMMA() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, 0)
}

func (s *Pass_switch_instanceContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Pass_switch_instanceContext) Name_of_instance() IName_of_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_of_instanceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_of_instanceContext)
}

func (s *Pass_switch_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pass_switch_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pass_switch_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterPass_switch_instance(s)
	}
}

func (s *Pass_switch_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitPass_switch_instance(s)
	}
}

func (p *SystemVerilogParser) Pass_switch_instance() (localctx IPass_switch_instanceContext) {
	this := p
	_ = this

	localctx = NewPass_switch_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 588, SystemVerilogParserRULE_pass_switch_instance)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5104)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserSIMPLE_IDENTIFIER {
		{
			p.SetState(5103)
			p.Name_of_instance()
		}

	}
	{
		p.SetState(5106)
		p.Match(SystemVerilogParserLP)
	}
	{
		p.SetState(5107)
		p.Inout_terminal()
	}
	{
		p.SetState(5108)
		p.Match(SystemVerilogParserCOMMA)
	}
	{
		p.SetState(5109)
		p.Inout_terminal()
	}
	{
		p.SetState(5110)
		p.Match(SystemVerilogParserRP)
	}

	return localctx
}

// IPass_enable_switch_instanceContext is an interface to support dynamic dispatch.
type IPass_enable_switch_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPass_enable_switch_instanceContext differentiates from other interfaces.
	IsPass_enable_switch_instanceContext()
}

type Pass_enable_switch_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPass_enable_switch_instanceContext() *Pass_enable_switch_instanceContext {
	var p = new(Pass_enable_switch_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_pass_enable_switch_instance
	return p
}

func (*Pass_enable_switch_instanceContext) IsPass_enable_switch_instanceContext() {}

func NewPass_enable_switch_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pass_enable_switch_instanceContext {
	var p = new(Pass_enable_switch_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_pass_enable_switch_instance

	return p
}

func (s *Pass_enable_switch_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *Pass_enable_switch_instanceContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Pass_enable_switch_instanceContext) AllInout_terminal() []IInout_terminalContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInout_terminalContext)(nil)).Elem())
	var tst = make([]IInout_terminalContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInout_terminalContext)
		}
	}

	return tst
}

func (s *Pass_enable_switch_instanceContext) Inout_terminal(i int) IInout_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInout_terminalContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInout_terminalContext)
}

func (s *Pass_enable_switch_instanceContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *Pass_enable_switch_instanceContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *Pass_enable_switch_instanceContext) Enable_terminal() IEnable_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnable_terminalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnable_terminalContext)
}

func (s *Pass_enable_switch_instanceContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Pass_enable_switch_instanceContext) Name_of_instance() IName_of_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_of_instanceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_of_instanceContext)
}

func (s *Pass_enable_switch_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pass_enable_switch_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pass_enable_switch_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterPass_enable_switch_instance(s)
	}
}

func (s *Pass_enable_switch_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitPass_enable_switch_instance(s)
	}
}

func (p *SystemVerilogParser) Pass_enable_switch_instance() (localctx IPass_enable_switch_instanceContext) {
	this := p
	_ = this

	localctx = NewPass_enable_switch_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 590, SystemVerilogParserRULE_pass_enable_switch_instance)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5113)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserSIMPLE_IDENTIFIER {
		{
			p.SetState(5112)
			p.Name_of_instance()
		}

	}
	{
		p.SetState(5115)
		p.Match(SystemVerilogParserLP)
	}
	{
		p.SetState(5116)
		p.Inout_terminal()
	}
	{
		p.SetState(5117)
		p.Match(SystemVerilogParserCOMMA)
	}
	{
		p.SetState(5118)
		p.Inout_terminal()
	}
	{
		p.SetState(5119)
		p.Match(SystemVerilogParserCOMMA)
	}
	{
		p.SetState(5120)
		p.Enable_terminal()
	}
	{
		p.SetState(5121)
		p.Match(SystemVerilogParserRP)
	}

	return localctx
}

// IPull_gate_instanceContext is an interface to support dynamic dispatch.
type IPull_gate_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPull_gate_instanceContext differentiates from other interfaces.
	IsPull_gate_instanceContext()
}

type Pull_gate_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPull_gate_instanceContext() *Pull_gate_instanceContext {
	var p = new(Pull_gate_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_pull_gate_instance
	return p
}

func (*Pull_gate_instanceContext) IsPull_gate_instanceContext() {}

func NewPull_gate_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pull_gate_instanceContext {
	var p = new(Pull_gate_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_pull_gate_instance

	return p
}

func (s *Pull_gate_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *Pull_gate_instanceContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Pull_gate_instanceContext) Output_terminal() IOutput_terminalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOutput_terminalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOutput_terminalContext)
}

func (s *Pull_gate_instanceContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Pull_gate_instanceContext) Name_of_instance() IName_of_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_of_instanceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_of_instanceContext)
}

func (s *Pull_gate_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pull_gate_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pull_gate_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterPull_gate_instance(s)
	}
}

func (s *Pull_gate_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitPull_gate_instance(s)
	}
}

func (p *SystemVerilogParser) Pull_gate_instance() (localctx IPull_gate_instanceContext) {
	this := p
	_ = this

	localctx = NewPull_gate_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 592, SystemVerilogParserRULE_pull_gate_instance)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5124)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserSIMPLE_IDENTIFIER {
		{
			p.SetState(5123)
			p.Name_of_instance()
		}

	}
	{
		p.SetState(5126)
		p.Match(SystemVerilogParserLP)
	}
	{
		p.SetState(5127)
		p.Output_terminal()
	}
	{
		p.SetState(5128)
		p.Match(SystemVerilogParserRP)
	}

	return localctx
}

// IPulldown_strengthContext is an interface to support dynamic dispatch.
type IPulldown_strengthContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPulldown_strengthContext differentiates from other interfaces.
	IsPulldown_strengthContext()
}

type Pulldown_strengthContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPulldown_strengthContext() *Pulldown_strengthContext {
	var p = new(Pulldown_strengthContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_pulldown_strength
	return p
}

func (*Pulldown_strengthContext) IsPulldown_strengthContext() {}

func NewPulldown_strengthContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pulldown_strengthContext {
	var p = new(Pulldown_strengthContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_pulldown_strength

	return p
}

func (s *Pulldown_strengthContext) GetParser() antlr.Parser { return s.parser }

func (s *Pulldown_strengthContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Pulldown_strengthContext) Strength0() IStrength0Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStrength0Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStrength0Context)
}

func (s *Pulldown_strengthContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Pulldown_strengthContext) COMMA() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, 0)
}

func (s *Pulldown_strengthContext) Strength1() IStrength1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStrength1Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStrength1Context)
}

func (s *Pulldown_strengthContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pulldown_strengthContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pulldown_strengthContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterPulldown_strength(s)
	}
}

func (s *Pulldown_strengthContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitPulldown_strength(s)
	}
}

func (p *SystemVerilogParser) Pulldown_strength() (localctx IPulldown_strengthContext) {
	this := p
	_ = this

	localctx = NewPulldown_strengthContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 594, SystemVerilogParserRULE_pulldown_strength)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5144)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 617, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5130)
			p.Match(SystemVerilogParserLP)
		}
		{
			p.SetState(5131)
			p.Strength0()
		}
		p.SetState(5134)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserCOMMA {
			{
				p.SetState(5132)
				p.Match(SystemVerilogParserCOMMA)
			}
			{
				p.SetState(5133)
				p.Strength1()
			}

		}
		{
			p.SetState(5136)
			p.Match(SystemVerilogParserRP)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5138)
			p.Match(SystemVerilogParserLP)
		}
		{
			p.SetState(5139)
			p.Strength1()
		}
		{
			p.SetState(5140)
			p.Match(SystemVerilogParserCOMMA)
		}
		{
			p.SetState(5141)
			p.Strength0()
		}
		{
			p.SetState(5142)
			p.Match(SystemVerilogParserRP)
		}

	}

	return localctx
}

// IPullup_strengthContext is an interface to support dynamic dispatch.
type IPullup_strengthContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPullup_strengthContext differentiates from other interfaces.
	IsPullup_strengthContext()
}

type Pullup_strengthContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPullup_strengthContext() *Pullup_strengthContext {
	var p = new(Pullup_strengthContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_pullup_strength
	return p
}

func (*Pullup_strengthContext) IsPullup_strengthContext() {}

func NewPullup_strengthContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pullup_strengthContext {
	var p = new(Pullup_strengthContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_pullup_strength

	return p
}

func (s *Pullup_strengthContext) GetParser() antlr.Parser { return s.parser }

func (s *Pullup_strengthContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Pullup_strengthContext) Strength0() IStrength0Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStrength0Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStrength0Context)
}

func (s *Pullup_strengthContext) COMMA() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, 0)
}

func (s *Pullup_strengthContext) Strength1() IStrength1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStrength1Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStrength1Context)
}

func (s *Pullup_strengthContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Pullup_strengthContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pullup_strengthContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pullup_strengthContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterPullup_strength(s)
	}
}

func (s *Pullup_strengthContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitPullup_strength(s)
	}
}

func (p *SystemVerilogParser) Pullup_strength() (localctx IPullup_strengthContext) {
	this := p
	_ = this

	localctx = NewPullup_strengthContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 596, SystemVerilogParserRULE_pullup_strength)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5160)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 619, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5146)
			p.Match(SystemVerilogParserLP)
		}
		{
			p.SetState(5147)
			p.Strength0()
		}
		{
			p.SetState(5148)
			p.Match(SystemVerilogParserCOMMA)
		}
		{
			p.SetState(5149)
			p.Strength1()
		}
		{
			p.SetState(5150)
			p.Match(SystemVerilogParserRP)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5152)
			p.Match(SystemVerilogParserLP)
		}
		{
			p.SetState(5153)
			p.Strength1()
		}
		p.SetState(5156)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserCOMMA {
			{
				p.SetState(5154)
				p.Match(SystemVerilogParserCOMMA)
			}
			{
				p.SetState(5155)
				p.Strength0()
			}

		}
		{
			p.SetState(5158)
			p.Match(SystemVerilogParserRP)
		}

	}

	return localctx
}

// IEnable_terminalContext is an interface to support dynamic dispatch.
type IEnable_terminalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnable_terminalContext differentiates from other interfaces.
	IsEnable_terminalContext()
}

type Enable_terminalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnable_terminalContext() *Enable_terminalContext {
	var p = new(Enable_terminalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_enable_terminal
	return p
}

func (*Enable_terminalContext) IsEnable_terminalContext() {}

func NewEnable_terminalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Enable_terminalContext {
	var p = new(Enable_terminalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_enable_terminal

	return p
}

func (s *Enable_terminalContext) GetParser() antlr.Parser { return s.parser }

func (s *Enable_terminalContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Enable_terminalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Enable_terminalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Enable_terminalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterEnable_terminal(s)
	}
}

func (s *Enable_terminalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitEnable_terminal(s)
	}
}

func (p *SystemVerilogParser) Enable_terminal() (localctx IEnable_terminalContext) {
	this := p
	_ = this

	localctx = NewEnable_terminalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 598, SystemVerilogParserRULE_enable_terminal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5162)
		p.expression(0)
	}

	return localctx
}

// IInout_terminalContext is an interface to support dynamic dispatch.
type IInout_terminalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInout_terminalContext differentiates from other interfaces.
	IsInout_terminalContext()
}

type Inout_terminalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInout_terminalContext() *Inout_terminalContext {
	var p = new(Inout_terminalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_inout_terminal
	return p
}

func (*Inout_terminalContext) IsInout_terminalContext() {}

func NewInout_terminalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Inout_terminalContext {
	var p = new(Inout_terminalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_inout_terminal

	return p
}

func (s *Inout_terminalContext) GetParser() antlr.Parser { return s.parser }

func (s *Inout_terminalContext) Net_lvalue() INet_lvalueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_lvalueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INet_lvalueContext)
}

func (s *Inout_terminalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Inout_terminalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Inout_terminalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterInout_terminal(s)
	}
}

func (s *Inout_terminalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitInout_terminal(s)
	}
}

func (p *SystemVerilogParser) Inout_terminal() (localctx IInout_terminalContext) {
	this := p
	_ = this

	localctx = NewInout_terminalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 600, SystemVerilogParserRULE_inout_terminal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5164)
		p.Net_lvalue()
	}

	return localctx
}

// IInput_terminalContext is an interface to support dynamic dispatch.
type IInput_terminalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInput_terminalContext differentiates from other interfaces.
	IsInput_terminalContext()
}

type Input_terminalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInput_terminalContext() *Input_terminalContext {
	var p = new(Input_terminalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_input_terminal
	return p
}

func (*Input_terminalContext) IsInput_terminalContext() {}

func NewInput_terminalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Input_terminalContext {
	var p = new(Input_terminalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_input_terminal

	return p
}

func (s *Input_terminalContext) GetParser() antlr.Parser { return s.parser }

func (s *Input_terminalContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Input_terminalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Input_terminalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Input_terminalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterInput_terminal(s)
	}
}

func (s *Input_terminalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitInput_terminal(s)
	}
}

func (p *SystemVerilogParser) Input_terminal() (localctx IInput_terminalContext) {
	this := p
	_ = this

	localctx = NewInput_terminalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 602, SystemVerilogParserRULE_input_terminal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5166)
		p.expression(0)
	}

	return localctx
}

// INcontrol_terminalContext is an interface to support dynamic dispatch.
type INcontrol_terminalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNcontrol_terminalContext differentiates from other interfaces.
	IsNcontrol_terminalContext()
}

type Ncontrol_terminalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNcontrol_terminalContext() *Ncontrol_terminalContext {
	var p = new(Ncontrol_terminalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_ncontrol_terminal
	return p
}

func (*Ncontrol_terminalContext) IsNcontrol_terminalContext() {}

func NewNcontrol_terminalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Ncontrol_terminalContext {
	var p = new(Ncontrol_terminalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_ncontrol_terminal

	return p
}

func (s *Ncontrol_terminalContext) GetParser() antlr.Parser { return s.parser }

func (s *Ncontrol_terminalContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Ncontrol_terminalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ncontrol_terminalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Ncontrol_terminalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterNcontrol_terminal(s)
	}
}

func (s *Ncontrol_terminalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitNcontrol_terminal(s)
	}
}

func (p *SystemVerilogParser) Ncontrol_terminal() (localctx INcontrol_terminalContext) {
	this := p
	_ = this

	localctx = NewNcontrol_terminalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 604, SystemVerilogParserRULE_ncontrol_terminal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5168)
		p.expression(0)
	}

	return localctx
}

// IOutput_terminalContext is an interface to support dynamic dispatch.
type IOutput_terminalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOutput_terminalContext differentiates from other interfaces.
	IsOutput_terminalContext()
}

type Output_terminalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOutput_terminalContext() *Output_terminalContext {
	var p = new(Output_terminalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_output_terminal
	return p
}

func (*Output_terminalContext) IsOutput_terminalContext() {}

func NewOutput_terminalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Output_terminalContext {
	var p = new(Output_terminalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_output_terminal

	return p
}

func (s *Output_terminalContext) GetParser() antlr.Parser { return s.parser }

func (s *Output_terminalContext) Net_lvalue() INet_lvalueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_lvalueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INet_lvalueContext)
}

func (s *Output_terminalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Output_terminalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Output_terminalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterOutput_terminal(s)
	}
}

func (s *Output_terminalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitOutput_terminal(s)
	}
}

func (p *SystemVerilogParser) Output_terminal() (localctx IOutput_terminalContext) {
	this := p
	_ = this

	localctx = NewOutput_terminalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 606, SystemVerilogParserRULE_output_terminal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5170)
		p.Net_lvalue()
	}

	return localctx
}

// IPcontrol_terminalContext is an interface to support dynamic dispatch.
type IPcontrol_terminalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPcontrol_terminalContext differentiates from other interfaces.
	IsPcontrol_terminalContext()
}

type Pcontrol_terminalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPcontrol_terminalContext() *Pcontrol_terminalContext {
	var p = new(Pcontrol_terminalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_pcontrol_terminal
	return p
}

func (*Pcontrol_terminalContext) IsPcontrol_terminalContext() {}

func NewPcontrol_terminalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pcontrol_terminalContext {
	var p = new(Pcontrol_terminalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_pcontrol_terminal

	return p
}

func (s *Pcontrol_terminalContext) GetParser() antlr.Parser { return s.parser }

func (s *Pcontrol_terminalContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Pcontrol_terminalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pcontrol_terminalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pcontrol_terminalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterPcontrol_terminal(s)
	}
}

func (s *Pcontrol_terminalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitPcontrol_terminal(s)
	}
}

func (p *SystemVerilogParser) Pcontrol_terminal() (localctx IPcontrol_terminalContext) {
	this := p
	_ = this

	localctx = NewPcontrol_terminalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 608, SystemVerilogParserRULE_pcontrol_terminal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5172)
		p.expression(0)
	}

	return localctx
}

// ICmos_switchtypeContext is an interface to support dynamic dispatch.
type ICmos_switchtypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCmos_switchtypeContext differentiates from other interfaces.
	IsCmos_switchtypeContext()
}

type Cmos_switchtypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmos_switchtypeContext() *Cmos_switchtypeContext {
	var p = new(Cmos_switchtypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_cmos_switchtype
	return p
}

func (*Cmos_switchtypeContext) IsCmos_switchtypeContext() {}

func NewCmos_switchtypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmos_switchtypeContext {
	var p = new(Cmos_switchtypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_cmos_switchtype

	return p
}

func (s *Cmos_switchtypeContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmos_switchtypeContext) KCMOS() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKCMOS, 0)
}

func (s *Cmos_switchtypeContext) KRCMOS() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKRCMOS, 0)
}

func (s *Cmos_switchtypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmos_switchtypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmos_switchtypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterCmos_switchtype(s)
	}
}

func (s *Cmos_switchtypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitCmos_switchtype(s)
	}
}

func (p *SystemVerilogParser) Cmos_switchtype() (localctx ICmos_switchtypeContext) {
	this := p
	_ = this

	localctx = NewCmos_switchtypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 610, SystemVerilogParserRULE_cmos_switchtype)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5174)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SystemVerilogParserKCMOS || _la == SystemVerilogParserKRCMOS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IEnable_gatetypeContext is an interface to support dynamic dispatch.
type IEnable_gatetypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnable_gatetypeContext differentiates from other interfaces.
	IsEnable_gatetypeContext()
}

type Enable_gatetypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnable_gatetypeContext() *Enable_gatetypeContext {
	var p = new(Enable_gatetypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_enable_gatetype
	return p
}

func (*Enable_gatetypeContext) IsEnable_gatetypeContext() {}

func NewEnable_gatetypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Enable_gatetypeContext {
	var p = new(Enable_gatetypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_enable_gatetype

	return p
}

func (s *Enable_gatetypeContext) GetParser() antlr.Parser { return s.parser }

func (s *Enable_gatetypeContext) KBUFIF0() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKBUFIF0, 0)
}

func (s *Enable_gatetypeContext) KBUFIF1() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKBUFIF1, 0)
}

func (s *Enable_gatetypeContext) KNOTIF0() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKNOTIF0, 0)
}

func (s *Enable_gatetypeContext) KNOTIF1() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKNOTIF1, 0)
}

func (s *Enable_gatetypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Enable_gatetypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Enable_gatetypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterEnable_gatetype(s)
	}
}

func (s *Enable_gatetypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitEnable_gatetype(s)
	}
}

func (p *SystemVerilogParser) Enable_gatetype() (localctx IEnable_gatetypeContext) {
	this := p
	_ = this

	localctx = NewEnable_gatetypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 612, SystemVerilogParserRULE_enable_gatetype)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5176)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SystemVerilogParserKBUFIF0 || _la == SystemVerilogParserKBUFIF1 || _la == SystemVerilogParserKNOTIF0 || _la == SystemVerilogParserKNOTIF1) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IMos_switchtypeContext is an interface to support dynamic dispatch.
type IMos_switchtypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMos_switchtypeContext differentiates from other interfaces.
	IsMos_switchtypeContext()
}

type Mos_switchtypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMos_switchtypeContext() *Mos_switchtypeContext {
	var p = new(Mos_switchtypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_mos_switchtype
	return p
}

func (*Mos_switchtypeContext) IsMos_switchtypeContext() {}

func NewMos_switchtypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Mos_switchtypeContext {
	var p = new(Mos_switchtypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_mos_switchtype

	return p
}

func (s *Mos_switchtypeContext) GetParser() antlr.Parser { return s.parser }

func (s *Mos_switchtypeContext) KNMOS() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKNMOS, 0)
}

func (s *Mos_switchtypeContext) KPMOS() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKPMOS, 0)
}

func (s *Mos_switchtypeContext) KRNMOS() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKRNMOS, 0)
}

func (s *Mos_switchtypeContext) KRPMOS() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKRPMOS, 0)
}

func (s *Mos_switchtypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Mos_switchtypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Mos_switchtypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterMos_switchtype(s)
	}
}

func (s *Mos_switchtypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitMos_switchtype(s)
	}
}

func (p *SystemVerilogParser) Mos_switchtype() (localctx IMos_switchtypeContext) {
	this := p
	_ = this

	localctx = NewMos_switchtypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 614, SystemVerilogParserRULE_mos_switchtype)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5178)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SystemVerilogParserKNMOS || _la == SystemVerilogParserKPMOS || _la == SystemVerilogParserKRNMOS || _la == SystemVerilogParserKRPMOS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IN_input_gatetypeContext is an interface to support dynamic dispatch.
type IN_input_gatetypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsN_input_gatetypeContext differentiates from other interfaces.
	IsN_input_gatetypeContext()
}

type N_input_gatetypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyN_input_gatetypeContext() *N_input_gatetypeContext {
	var p = new(N_input_gatetypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_n_input_gatetype
	return p
}

func (*N_input_gatetypeContext) IsN_input_gatetypeContext() {}

func NewN_input_gatetypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *N_input_gatetypeContext {
	var p = new(N_input_gatetypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_n_input_gatetype

	return p
}

func (s *N_input_gatetypeContext) GetParser() antlr.Parser { return s.parser }

func (s *N_input_gatetypeContext) KAND() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKAND, 0)
}

func (s *N_input_gatetypeContext) KNAND() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKNAND, 0)
}

func (s *N_input_gatetypeContext) KOR() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKOR, 0)
}

func (s *N_input_gatetypeContext) KNOR() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKNOR, 0)
}

func (s *N_input_gatetypeContext) KXOR() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKXOR, 0)
}

func (s *N_input_gatetypeContext) KXNOR() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKXNOR, 0)
}

func (s *N_input_gatetypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *N_input_gatetypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *N_input_gatetypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterN_input_gatetype(s)
	}
}

func (s *N_input_gatetypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitN_input_gatetype(s)
	}
}

func (p *SystemVerilogParser) N_input_gatetype() (localctx IN_input_gatetypeContext) {
	this := p
	_ = this

	localctx = NewN_input_gatetypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 616, SystemVerilogParserRULE_n_input_gatetype)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5180)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SystemVerilogParserKAND || (((_la-217)&-(0x1f+1)) == 0 && ((1<<uint((_la-217)))&((1<<(SystemVerilogParserKNAND-217))|(1<<(SystemVerilogParserKNOR-217))|(1<<(SystemVerilogParserKOR-217)))) != 0) || _la == SystemVerilogParserKXNOR || _la == SystemVerilogParserKXOR) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IN_output_gatetypeContext is an interface to support dynamic dispatch.
type IN_output_gatetypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsN_output_gatetypeContext differentiates from other interfaces.
	IsN_output_gatetypeContext()
}

type N_output_gatetypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyN_output_gatetypeContext() *N_output_gatetypeContext {
	var p = new(N_output_gatetypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_n_output_gatetype
	return p
}

func (*N_output_gatetypeContext) IsN_output_gatetypeContext() {}

func NewN_output_gatetypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *N_output_gatetypeContext {
	var p = new(N_output_gatetypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_n_output_gatetype

	return p
}

func (s *N_output_gatetypeContext) GetParser() antlr.Parser { return s.parser }

func (s *N_output_gatetypeContext) KBUF() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKBUF, 0)
}

func (s *N_output_gatetypeContext) KNOT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKNOT, 0)
}

func (s *N_output_gatetypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *N_output_gatetypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *N_output_gatetypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterN_output_gatetype(s)
	}
}

func (s *N_output_gatetypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitN_output_gatetype(s)
	}
}

func (p *SystemVerilogParser) N_output_gatetype() (localctx IN_output_gatetypeContext) {
	this := p
	_ = this

	localctx = NewN_output_gatetypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 618, SystemVerilogParserRULE_n_output_gatetype)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5182)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SystemVerilogParserKBUF || _la == SystemVerilogParserKNOT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IPass_en_switchtypeContext is an interface to support dynamic dispatch.
type IPass_en_switchtypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPass_en_switchtypeContext differentiates from other interfaces.
	IsPass_en_switchtypeContext()
}

type Pass_en_switchtypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPass_en_switchtypeContext() *Pass_en_switchtypeContext {
	var p = new(Pass_en_switchtypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_pass_en_switchtype
	return p
}

func (*Pass_en_switchtypeContext) IsPass_en_switchtypeContext() {}

func NewPass_en_switchtypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pass_en_switchtypeContext {
	var p = new(Pass_en_switchtypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_pass_en_switchtype

	return p
}

func (s *Pass_en_switchtypeContext) GetParser() antlr.Parser { return s.parser }

func (s *Pass_en_switchtypeContext) KTRANIF0() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKTRANIF0, 0)
}

func (s *Pass_en_switchtypeContext) KTRANIF1() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKTRANIF1, 0)
}

func (s *Pass_en_switchtypeContext) KRTRANIF1() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKRTRANIF1, 0)
}

func (s *Pass_en_switchtypeContext) KRTRANIF0() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKRTRANIF0, 0)
}

func (s *Pass_en_switchtypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pass_en_switchtypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pass_en_switchtypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterPass_en_switchtype(s)
	}
}

func (s *Pass_en_switchtypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitPass_en_switchtype(s)
	}
}

func (p *SystemVerilogParser) Pass_en_switchtype() (localctx IPass_en_switchtypeContext) {
	this := p
	_ = this

	localctx = NewPass_en_switchtypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 620, SystemVerilogParserRULE_pass_en_switchtype)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5184)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SystemVerilogParserKRTRANIF0 || _la == SystemVerilogParserKRTRANIF1 || _la == SystemVerilogParserKTRANIF0 || _la == SystemVerilogParserKTRANIF1) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IPass_switchtypeContext is an interface to support dynamic dispatch.
type IPass_switchtypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPass_switchtypeContext differentiates from other interfaces.
	IsPass_switchtypeContext()
}

type Pass_switchtypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPass_switchtypeContext() *Pass_switchtypeContext {
	var p = new(Pass_switchtypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_pass_switchtype
	return p
}

func (*Pass_switchtypeContext) IsPass_switchtypeContext() {}

func NewPass_switchtypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pass_switchtypeContext {
	var p = new(Pass_switchtypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_pass_switchtype

	return p
}

func (s *Pass_switchtypeContext) GetParser() antlr.Parser { return s.parser }

func (s *Pass_switchtypeContext) KTRAN() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKTRAN, 0)
}

func (s *Pass_switchtypeContext) KRTRAN() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKRTRAN, 0)
}

func (s *Pass_switchtypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pass_switchtypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pass_switchtypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterPass_switchtype(s)
	}
}

func (s *Pass_switchtypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitPass_switchtype(s)
	}
}

func (p *SystemVerilogParser) Pass_switchtype() (localctx IPass_switchtypeContext) {
	this := p
	_ = this

	localctx = NewPass_switchtypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 622, SystemVerilogParserRULE_pass_switchtype)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5186)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SystemVerilogParserKRTRAN || _la == SystemVerilogParserKTRAN) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IModule_instantiationContext is an interface to support dynamic dispatch.
type IModule_instantiationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModule_instantiationContext differentiates from other interfaces.
	IsModule_instantiationContext()
}

type Module_instantiationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModule_instantiationContext() *Module_instantiationContext {
	var p = new(Module_instantiationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_module_instantiation
	return p
}

func (*Module_instantiationContext) IsModule_instantiationContext() {}

func NewModule_instantiationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Module_instantiationContext {
	var p = new(Module_instantiationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_module_instantiation

	return p
}

func (s *Module_instantiationContext) GetParser() antlr.Parser { return s.parser }

func (s *Module_instantiationContext) Module_identifier() IModule_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_identifierContext)
}

func (s *Module_instantiationContext) AllHierarchical_instance() []IHierarchical_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IHierarchical_instanceContext)(nil)).Elem())
	var tst = make([]IHierarchical_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IHierarchical_instanceContext)
		}
	}

	return tst
}

func (s *Module_instantiationContext) Hierarchical_instance(i int) IHierarchical_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_instanceContext)
}

func (s *Module_instantiationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Module_instantiationContext) Parameter_value_assignment() IParameter_value_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_value_assignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_value_assignmentContext)
}

func (s *Module_instantiationContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *Module_instantiationContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *Module_instantiationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Module_instantiationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Module_instantiationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterModule_instantiation(s)
	}
}

func (s *Module_instantiationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitModule_instantiation(s)
	}
}

func (p *SystemVerilogParser) Module_instantiation() (localctx IModule_instantiationContext) {
	this := p
	_ = this

	localctx = NewModule_instantiationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 624, SystemVerilogParserRULE_module_instantiation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5188)
		p.Module_identifier()
	}
	p.SetState(5190)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserP {
		{
			p.SetState(5189)
			p.Parameter_value_assignment()
		}

	}
	{
		p.SetState(5192)
		p.Hierarchical_instance()
	}
	p.SetState(5197)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserCOMMA {
		{
			p.SetState(5193)
			p.Match(SystemVerilogParserCOMMA)
		}
		{
			p.SetState(5194)
			p.Hierarchical_instance()
		}

		p.SetState(5199)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(5200)
		p.Match(SystemVerilogParserSEMI)
	}

	return localctx
}

// IParameter_value_assignmentContext is an interface to support dynamic dispatch.
type IParameter_value_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameter_value_assignmentContext differentiates from other interfaces.
	IsParameter_value_assignmentContext()
}

type Parameter_value_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameter_value_assignmentContext() *Parameter_value_assignmentContext {
	var p = new(Parameter_value_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_parameter_value_assignment
	return p
}

func (*Parameter_value_assignmentContext) IsParameter_value_assignmentContext() {}

func NewParameter_value_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Parameter_value_assignmentContext {
	var p = new(Parameter_value_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_parameter_value_assignment

	return p
}

func (s *Parameter_value_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Parameter_value_assignmentContext) P() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserP, 0)
}

func (s *Parameter_value_assignmentContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Parameter_value_assignmentContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Parameter_value_assignmentContext) List_of_parameter_assignments() IList_of_parameter_assignmentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_parameter_assignmentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_parameter_assignmentsContext)
}

func (s *Parameter_value_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parameter_value_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Parameter_value_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterParameter_value_assignment(s)
	}
}

func (s *Parameter_value_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitParameter_value_assignment(s)
	}
}

func (p *SystemVerilogParser) Parameter_value_assignment() (localctx IParameter_value_assignmentContext) {
	this := p
	_ = this

	localctx = NewParameter_value_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 626, SystemVerilogParserRULE_parameter_value_assignment)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5202)
		p.Match(SystemVerilogParserP)
	}
	{
		p.SetState(5203)
		p.Match(SystemVerilogParserLP)
	}
	p.SetState(5205)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SystemVerilogParserMINUS)|(1<<SystemVerilogParserMINUSMINS)|(1<<SystemVerilogParserNOT)|(1<<SystemVerilogParserDOLLAR)|(1<<SystemVerilogParserDROOT)|(1<<SystemVerilogParserDUNIT)|(1<<SystemVerilogParserAND)|(1<<SystemVerilogParserLP))) != 0) || (((_la-37)&-(0x1f+1)) == 0 && ((1<<uint((_la-37)))&((1<<(SystemVerilogParserDOT-37))|(1<<(SystemVerilogParserQUOTE-37))|(1<<(SystemVerilogParserCARET-37))|(1<<(SystemVerilogParserCARETSQUIG-37))|(1<<(SystemVerilogParserLC-37))|(1<<(SystemVerilogParserBAR-37))|(1<<(SystemVerilogParserSQUIG-37))|(1<<(SystemVerilogParserSQUIGAND-37))|(1<<(SystemVerilogParserSQUIGCARET-37))|(1<<(SystemVerilogParserSQUIGBAR-37))|(1<<(SystemVerilogParserPLUS-37)))) != 0) || _la == SystemVerilogParserPLUSPLUS || (((_la-109)&-(0x1f+1)) == 0 && ((1<<uint((_la-109)))&((1<<(SystemVerilogParserKBIT-109))|(1<<(SystemVerilogParserKBYTE-109))|(1<<(SystemVerilogParserKCHANDLE-109))|(1<<(SystemVerilogParserKCONST-109)))) != 0) || _la == SystemVerilogParserKENUM || _la == SystemVerilogParserKEVENT || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SystemVerilogParserKINT-195))|(1<<(SystemVerilogParserKINTEGER-195))|(1<<(SystemVerilogParserKLOCAL-195))|(1<<(SystemVerilogParserKLOGIC-195))|(1<<(SystemVerilogParserKLONGINT-195)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(SystemVerilogParserKNULL-228))|(1<<(SystemVerilogParserKRANDOMIZE-228))|(1<<(SystemVerilogParserKREAL-228))|(1<<(SystemVerilogParserKREALTIME-228))|(1<<(SystemVerilogParserKREG-228)))) != 0) || (((_la-276)&-(0x1f+1)) == 0 && ((1<<uint((_la-276)))&((1<<(SystemVerilogParserKSHORTINT-276))|(1<<(SystemVerilogParserKSHORTREAL-276))|(1<<(SystemVerilogParserKSIGNED-276))|(1<<(SystemVerilogParserKSTD-276))|(1<<(SystemVerilogParserKSTRING-276))|(1<<(SystemVerilogParserKSTRUCT-276))|(1<<(SystemVerilogParserKSUPER-276))|(1<<(SystemVerilogParserKTAGGED-276))|(1<<(SystemVerilogParserKTHIS-276))|(1<<(SystemVerilogParserKTIME-276)))) != 0) || (((_la-313)&-(0x1f+1)) == 0 && ((1<<uint((_la-313)))&((1<<(SystemVerilogParserKTYPE-313))|(1<<(SystemVerilogParserKUNION-313))|(1<<(SystemVerilogParserKUNSIGNED-313))|(1<<(SystemVerilogParserKVIRTUAL-313)))) != 0) || (((_la-345)&-(0x1f+1)) == 0 && ((1<<uint((_la-345)))&((1<<(SystemVerilogParserTIME_LITERAL-345))|(1<<(SystemVerilogParserDECIMAL_NUMBER-345))|(1<<(SystemVerilogParserBINARY_NUMBER-345))|(1<<(SystemVerilogParserOCTAL_NUMBER-345))|(1<<(SystemVerilogParserHEX_NUMBER-345))|(1<<(SystemVerilogParserREAL_NUMBER-345))|(1<<(SystemVerilogParserUNSIGNED_NUMBER-345))|(1<<(SystemVerilogParserSTRING_LITERAL-345))|(1<<(SystemVerilogParserSIMPLE_IDENTIFIER-345))|(1<<(SystemVerilogParserSYSTEM_TF_IDENTIFIER-345)))) != 0) {
		{
			p.SetState(5204)
			p.List_of_parameter_assignments()
		}

	}
	{
		p.SetState(5207)
		p.Match(SystemVerilogParserRP)
	}

	return localctx
}

// IList_of_parameter_assignmentsContext is an interface to support dynamic dispatch.
type IList_of_parameter_assignmentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_parameter_assignmentsContext differentiates from other interfaces.
	IsList_of_parameter_assignmentsContext()
}

type List_of_parameter_assignmentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_parameter_assignmentsContext() *List_of_parameter_assignmentsContext {
	var p = new(List_of_parameter_assignmentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_list_of_parameter_assignments
	return p
}

func (*List_of_parameter_assignmentsContext) IsList_of_parameter_assignmentsContext() {}

func NewList_of_parameter_assignmentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_parameter_assignmentsContext {
	var p = new(List_of_parameter_assignmentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_list_of_parameter_assignments

	return p
}

func (s *List_of_parameter_assignmentsContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_parameter_assignmentsContext) AllOrdered_parameter_assignment() []IOrdered_parameter_assignmentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOrdered_parameter_assignmentContext)(nil)).Elem())
	var tst = make([]IOrdered_parameter_assignmentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOrdered_parameter_assignmentContext)
		}
	}

	return tst
}

func (s *List_of_parameter_assignmentsContext) Ordered_parameter_assignment(i int) IOrdered_parameter_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOrdered_parameter_assignmentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOrdered_parameter_assignmentContext)
}

func (s *List_of_parameter_assignmentsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *List_of_parameter_assignmentsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *List_of_parameter_assignmentsContext) AllNamed_parameter_assignment() []INamed_parameter_assignmentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INamed_parameter_assignmentContext)(nil)).Elem())
	var tst = make([]INamed_parameter_assignmentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INamed_parameter_assignmentContext)
		}
	}

	return tst
}

func (s *List_of_parameter_assignmentsContext) Named_parameter_assignment(i int) INamed_parameter_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamed_parameter_assignmentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INamed_parameter_assignmentContext)
}

func (s *List_of_parameter_assignmentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_parameter_assignmentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_parameter_assignmentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterList_of_parameter_assignments(s)
	}
}

func (s *List_of_parameter_assignmentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitList_of_parameter_assignments(s)
	}
}

func (p *SystemVerilogParser) List_of_parameter_assignments() (localctx IList_of_parameter_assignmentsContext) {
	this := p
	_ = this

	localctx = NewList_of_parameter_assignmentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 628, SystemVerilogParserRULE_list_of_parameter_assignments)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5225)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserMINUS, SystemVerilogParserMINUSMINS, SystemVerilogParserNOT, SystemVerilogParserDOLLAR, SystemVerilogParserDROOT, SystemVerilogParserDUNIT, SystemVerilogParserAND, SystemVerilogParserLP, SystemVerilogParserQUOTE, SystemVerilogParserCARET, SystemVerilogParserCARETSQUIG, SystemVerilogParserLC, SystemVerilogParserBAR, SystemVerilogParserSQUIG, SystemVerilogParserSQUIGAND, SystemVerilogParserSQUIGCARET, SystemVerilogParserSQUIGBAR, SystemVerilogParserPLUS, SystemVerilogParserPLUSPLUS, SystemVerilogParserKBIT, SystemVerilogParserKBYTE, SystemVerilogParserKCHANDLE, SystemVerilogParserKCONST, SystemVerilogParserKENUM, SystemVerilogParserKEVENT, SystemVerilogParserKINT, SystemVerilogParserKINTEGER, SystemVerilogParserKLOCAL, SystemVerilogParserKLOGIC, SystemVerilogParserKLONGINT, SystemVerilogParserKNULL, SystemVerilogParserKRANDOMIZE, SystemVerilogParserKREAL, SystemVerilogParserKREALTIME, SystemVerilogParserKREG, SystemVerilogParserKSHORTINT, SystemVerilogParserKSHORTREAL, SystemVerilogParserKSIGNED, SystemVerilogParserKSTD, SystemVerilogParserKSTRING, SystemVerilogParserKSTRUCT, SystemVerilogParserKSUPER, SystemVerilogParserKTAGGED, SystemVerilogParserKTHIS, SystemVerilogParserKTIME, SystemVerilogParserKTYPE, SystemVerilogParserKUNION, SystemVerilogParserKUNSIGNED, SystemVerilogParserKVIRTUAL, SystemVerilogParserTIME_LITERAL, SystemVerilogParserDECIMAL_NUMBER, SystemVerilogParserBINARY_NUMBER, SystemVerilogParserOCTAL_NUMBER, SystemVerilogParserHEX_NUMBER, SystemVerilogParserREAL_NUMBER, SystemVerilogParserUNSIGNED_NUMBER, SystemVerilogParserSTRING_LITERAL, SystemVerilogParserSIMPLE_IDENTIFIER, SystemVerilogParserSYSTEM_TF_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5209)
			p.Ordered_parameter_assignment()
		}
		p.SetState(5214)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserCOMMA {
			{
				p.SetState(5210)
				p.Match(SystemVerilogParserCOMMA)
			}
			{
				p.SetState(5211)
				p.Ordered_parameter_assignment()
			}

			p.SetState(5216)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case SystemVerilogParserDOT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5217)
			p.Named_parameter_assignment()
		}
		p.SetState(5222)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserCOMMA {
			{
				p.SetState(5218)
				p.Match(SystemVerilogParserCOMMA)
			}
			{
				p.SetState(5219)
				p.Named_parameter_assignment()
			}

			p.SetState(5224)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IOrdered_parameter_assignmentContext is an interface to support dynamic dispatch.
type IOrdered_parameter_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOrdered_parameter_assignmentContext differentiates from other interfaces.
	IsOrdered_parameter_assignmentContext()
}

type Ordered_parameter_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrdered_parameter_assignmentContext() *Ordered_parameter_assignmentContext {
	var p = new(Ordered_parameter_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_ordered_parameter_assignment
	return p
}

func (*Ordered_parameter_assignmentContext) IsOrdered_parameter_assignmentContext() {}

func NewOrdered_parameter_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Ordered_parameter_assignmentContext {
	var p = new(Ordered_parameter_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_ordered_parameter_assignment

	return p
}

func (s *Ordered_parameter_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Ordered_parameter_assignmentContext) Param_expression() IParam_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParam_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParam_expressionContext)
}

func (s *Ordered_parameter_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ordered_parameter_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Ordered_parameter_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterOrdered_parameter_assignment(s)
	}
}

func (s *Ordered_parameter_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitOrdered_parameter_assignment(s)
	}
}

func (p *SystemVerilogParser) Ordered_parameter_assignment() (localctx IOrdered_parameter_assignmentContext) {
	this := p
	_ = this

	localctx = NewOrdered_parameter_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 630, SystemVerilogParserRULE_ordered_parameter_assignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5227)
		p.Param_expression()
	}

	return localctx
}

// INamed_parameter_assignmentContext is an interface to support dynamic dispatch.
type INamed_parameter_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNamed_parameter_assignmentContext differentiates from other interfaces.
	IsNamed_parameter_assignmentContext()
}

type Named_parameter_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamed_parameter_assignmentContext() *Named_parameter_assignmentContext {
	var p = new(Named_parameter_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_named_parameter_assignment
	return p
}

func (*Named_parameter_assignmentContext) IsNamed_parameter_assignmentContext() {}

func NewNamed_parameter_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Named_parameter_assignmentContext {
	var p = new(Named_parameter_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_named_parameter_assignment

	return p
}

func (s *Named_parameter_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Named_parameter_assignmentContext) DOT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserDOT, 0)
}

func (s *Named_parameter_assignmentContext) Parameter_identifier() IParameter_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_identifierContext)
}

func (s *Named_parameter_assignmentContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Named_parameter_assignmentContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Named_parameter_assignmentContext) Param_expression() IParam_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParam_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParam_expressionContext)
}

func (s *Named_parameter_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Named_parameter_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Named_parameter_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterNamed_parameter_assignment(s)
	}
}

func (s *Named_parameter_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitNamed_parameter_assignment(s)
	}
}

func (p *SystemVerilogParser) Named_parameter_assignment() (localctx INamed_parameter_assignmentContext) {
	this := p
	_ = this

	localctx = NewNamed_parameter_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 632, SystemVerilogParserRULE_named_parameter_assignment)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5229)
		p.Match(SystemVerilogParserDOT)
	}
	{
		p.SetState(5230)
		p.Parameter_identifier()
	}
	{
		p.SetState(5231)
		p.Match(SystemVerilogParserLP)
	}
	p.SetState(5233)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SystemVerilogParserMINUS)|(1<<SystemVerilogParserMINUSMINS)|(1<<SystemVerilogParserNOT)|(1<<SystemVerilogParserDOLLAR)|(1<<SystemVerilogParserDROOT)|(1<<SystemVerilogParserDUNIT)|(1<<SystemVerilogParserAND)|(1<<SystemVerilogParserLP))) != 0) || (((_la-51)&-(0x1f+1)) == 0 && ((1<<uint((_la-51)))&((1<<(SystemVerilogParserQUOTE-51))|(1<<(SystemVerilogParserCARET-51))|(1<<(SystemVerilogParserCARETSQUIG-51))|(1<<(SystemVerilogParserLC-51))|(1<<(SystemVerilogParserBAR-51))|(1<<(SystemVerilogParserSQUIG-51))|(1<<(SystemVerilogParserSQUIGAND-51))|(1<<(SystemVerilogParserSQUIGCARET-51))|(1<<(SystemVerilogParserSQUIGBAR-51))|(1<<(SystemVerilogParserPLUS-51))|(1<<(SystemVerilogParserPLUSPLUS-51)))) != 0) || (((_la-109)&-(0x1f+1)) == 0 && ((1<<uint((_la-109)))&((1<<(SystemVerilogParserKBIT-109))|(1<<(SystemVerilogParserKBYTE-109))|(1<<(SystemVerilogParserKCHANDLE-109))|(1<<(SystemVerilogParserKCONST-109)))) != 0) || _la == SystemVerilogParserKENUM || _la == SystemVerilogParserKEVENT || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SystemVerilogParserKINT-195))|(1<<(SystemVerilogParserKINTEGER-195))|(1<<(SystemVerilogParserKLOCAL-195))|(1<<(SystemVerilogParserKLOGIC-195))|(1<<(SystemVerilogParserKLONGINT-195)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(SystemVerilogParserKNULL-228))|(1<<(SystemVerilogParserKRANDOMIZE-228))|(1<<(SystemVerilogParserKREAL-228))|(1<<(SystemVerilogParserKREALTIME-228))|(1<<(SystemVerilogParserKREG-228)))) != 0) || (((_la-276)&-(0x1f+1)) == 0 && ((1<<uint((_la-276)))&((1<<(SystemVerilogParserKSHORTINT-276))|(1<<(SystemVerilogParserKSHORTREAL-276))|(1<<(SystemVerilogParserKSIGNED-276))|(1<<(SystemVerilogParserKSTD-276))|(1<<(SystemVerilogParserKSTRING-276))|(1<<(SystemVerilogParserKSTRUCT-276))|(1<<(SystemVerilogParserKSUPER-276))|(1<<(SystemVerilogParserKTAGGED-276))|(1<<(SystemVerilogParserKTHIS-276))|(1<<(SystemVerilogParserKTIME-276)))) != 0) || (((_la-313)&-(0x1f+1)) == 0 && ((1<<uint((_la-313)))&((1<<(SystemVerilogParserKTYPE-313))|(1<<(SystemVerilogParserKUNION-313))|(1<<(SystemVerilogParserKUNSIGNED-313))|(1<<(SystemVerilogParserKVIRTUAL-313)))) != 0) || (((_la-345)&-(0x1f+1)) == 0 && ((1<<uint((_la-345)))&((1<<(SystemVerilogParserTIME_LITERAL-345))|(1<<(SystemVerilogParserDECIMAL_NUMBER-345))|(1<<(SystemVerilogParserBINARY_NUMBER-345))|(1<<(SystemVerilogParserOCTAL_NUMBER-345))|(1<<(SystemVerilogParserHEX_NUMBER-345))|(1<<(SystemVerilogParserREAL_NUMBER-345))|(1<<(SystemVerilogParserUNSIGNED_NUMBER-345))|(1<<(SystemVerilogParserSTRING_LITERAL-345))|(1<<(SystemVerilogParserSIMPLE_IDENTIFIER-345))|(1<<(SystemVerilogParserSYSTEM_TF_IDENTIFIER-345)))) != 0) {
		{
			p.SetState(5232)
			p.Param_expression()
		}

	}
	{
		p.SetState(5235)
		p.Match(SystemVerilogParserRP)
	}

	return localctx
}

// IHierarchical_instanceContext is an interface to support dynamic dispatch.
type IHierarchical_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHierarchical_instanceContext differentiates from other interfaces.
	IsHierarchical_instanceContext()
}

type Hierarchical_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHierarchical_instanceContext() *Hierarchical_instanceContext {
	var p = new(Hierarchical_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_hierarchical_instance
	return p
}

func (*Hierarchical_instanceContext) IsHierarchical_instanceContext() {}

func NewHierarchical_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Hierarchical_instanceContext {
	var p = new(Hierarchical_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_hierarchical_instance

	return p
}

func (s *Hierarchical_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *Hierarchical_instanceContext) Name_of_instance() IName_of_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_of_instanceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_of_instanceContext)
}

func (s *Hierarchical_instanceContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Hierarchical_instanceContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Hierarchical_instanceContext) List_of_port_connections() IList_of_port_connectionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_port_connectionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_port_connectionsContext)
}

func (s *Hierarchical_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Hierarchical_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Hierarchical_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterHierarchical_instance(s)
	}
}

func (s *Hierarchical_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitHierarchical_instance(s)
	}
}

func (p *SystemVerilogParser) Hierarchical_instance() (localctx IHierarchical_instanceContext) {
	this := p
	_ = this

	localctx = NewHierarchical_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 634, SystemVerilogParserRULE_hierarchical_instance)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5237)
		p.Name_of_instance()
	}
	{
		p.SetState(5238)
		p.Match(SystemVerilogParserLP)
	}
	p.SetState(5240)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 627, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5239)
			p.List_of_port_connections()
		}

	}
	{
		p.SetState(5242)
		p.Match(SystemVerilogParserRP)
	}

	return localctx
}

// IName_of_instanceContext is an interface to support dynamic dispatch.
type IName_of_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsName_of_instanceContext differentiates from other interfaces.
	IsName_of_instanceContext()
}

type Name_of_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyName_of_instanceContext() *Name_of_instanceContext {
	var p = new(Name_of_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_name_of_instance
	return p
}

func (*Name_of_instanceContext) IsName_of_instanceContext() {}

func NewName_of_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Name_of_instanceContext {
	var p = new(Name_of_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_name_of_instance

	return p
}

func (s *Name_of_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *Name_of_instanceContext) Instance_identifier() IInstance_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInstance_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInstance_identifierContext)
}

func (s *Name_of_instanceContext) AllUnpacked_dimension() []IUnpacked_dimensionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IUnpacked_dimensionContext)(nil)).Elem())
	var tst = make([]IUnpacked_dimensionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IUnpacked_dimensionContext)
		}
	}

	return tst
}

func (s *Name_of_instanceContext) Unpacked_dimension(i int) IUnpacked_dimensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnpacked_dimensionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IUnpacked_dimensionContext)
}

func (s *Name_of_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Name_of_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Name_of_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterName_of_instance(s)
	}
}

func (s *Name_of_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitName_of_instance(s)
	}
}

func (p *SystemVerilogParser) Name_of_instance() (localctx IName_of_instanceContext) {
	this := p
	_ = this

	localctx = NewName_of_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 636, SystemVerilogParserRULE_name_of_instance)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5244)
		p.Instance_identifier()
	}
	p.SetState(5248)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserLB {
		{
			p.SetState(5245)
			p.Unpacked_dimension()
		}

		p.SetState(5250)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IList_of_port_connectionsContext is an interface to support dynamic dispatch.
type IList_of_port_connectionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_port_connectionsContext differentiates from other interfaces.
	IsList_of_port_connectionsContext()
}

type List_of_port_connectionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_port_connectionsContext() *List_of_port_connectionsContext {
	var p = new(List_of_port_connectionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_list_of_port_connections
	return p
}

func (*List_of_port_connectionsContext) IsList_of_port_connectionsContext() {}

func NewList_of_port_connectionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_port_connectionsContext {
	var p = new(List_of_port_connectionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_list_of_port_connections

	return p
}

func (s *List_of_port_connectionsContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_port_connectionsContext) AllOrdered_port_connection() []IOrdered_port_connectionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOrdered_port_connectionContext)(nil)).Elem())
	var tst = make([]IOrdered_port_connectionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOrdered_port_connectionContext)
		}
	}

	return tst
}

func (s *List_of_port_connectionsContext) Ordered_port_connection(i int) IOrdered_port_connectionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOrdered_port_connectionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOrdered_port_connectionContext)
}

func (s *List_of_port_connectionsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *List_of_port_connectionsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *List_of_port_connectionsContext) AllNamed_port_connection() []INamed_port_connectionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INamed_port_connectionContext)(nil)).Elem())
	var tst = make([]INamed_port_connectionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INamed_port_connectionContext)
		}
	}

	return tst
}

func (s *List_of_port_connectionsContext) Named_port_connection(i int) INamed_port_connectionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamed_port_connectionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INamed_port_connectionContext)
}

func (s *List_of_port_connectionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_port_connectionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_port_connectionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterList_of_port_connections(s)
	}
}

func (s *List_of_port_connectionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitList_of_port_connections(s)
	}
}

func (p *SystemVerilogParser) List_of_port_connections() (localctx IList_of_port_connectionsContext) {
	this := p
	_ = this

	localctx = NewList_of_port_connectionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 638, SystemVerilogParserRULE_list_of_port_connections)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5267)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 631, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5251)
			p.Ordered_port_connection()
		}
		p.SetState(5256)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserCOMMA {
			{
				p.SetState(5252)
				p.Match(SystemVerilogParserCOMMA)
			}
			{
				p.SetState(5253)
				p.Ordered_port_connection()
			}

			p.SetState(5258)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5259)
			p.Named_port_connection()
		}
		p.SetState(5264)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserCOMMA {
			{
				p.SetState(5260)
				p.Match(SystemVerilogParserCOMMA)
			}
			{
				p.SetState(5261)
				p.Named_port_connection()
			}

			p.SetState(5266)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// IOrdered_port_connectionContext is an interface to support dynamic dispatch.
type IOrdered_port_connectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOrdered_port_connectionContext differentiates from other interfaces.
	IsOrdered_port_connectionContext()
}

type Ordered_port_connectionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrdered_port_connectionContext() *Ordered_port_connectionContext {
	var p = new(Ordered_port_connectionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_ordered_port_connection
	return p
}

func (*Ordered_port_connectionContext) IsOrdered_port_connectionContext() {}

func NewOrdered_port_connectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Ordered_port_connectionContext {
	var p = new(Ordered_port_connectionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_ordered_port_connection

	return p
}

func (s *Ordered_port_connectionContext) GetParser() antlr.Parser { return s.parser }

func (s *Ordered_port_connectionContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Ordered_port_connectionContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Ordered_port_connectionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Ordered_port_connectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ordered_port_connectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Ordered_port_connectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterOrdered_port_connection(s)
	}
}

func (s *Ordered_port_connectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitOrdered_port_connection(s)
	}
}

func (p *SystemVerilogParser) Ordered_port_connection() (localctx IOrdered_port_connectionContext) {
	this := p
	_ = this

	localctx = NewOrdered_port_connectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 640, SystemVerilogParserRULE_ordered_port_connection)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5272)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserLPS {
		{
			p.SetState(5269)
			p.Attribute_instance()
		}

		p.SetState(5274)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(5276)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SystemVerilogParserMINUS)|(1<<SystemVerilogParserMINUSMINS)|(1<<SystemVerilogParserNOT)|(1<<SystemVerilogParserDOLLAR)|(1<<SystemVerilogParserDROOT)|(1<<SystemVerilogParserDUNIT)|(1<<SystemVerilogParserAND)|(1<<SystemVerilogParserLP))) != 0) || (((_la-51)&-(0x1f+1)) == 0 && ((1<<uint((_la-51)))&((1<<(SystemVerilogParserQUOTE-51))|(1<<(SystemVerilogParserCARET-51))|(1<<(SystemVerilogParserCARETSQUIG-51))|(1<<(SystemVerilogParserLC-51))|(1<<(SystemVerilogParserBAR-51))|(1<<(SystemVerilogParserSQUIG-51))|(1<<(SystemVerilogParserSQUIGAND-51))|(1<<(SystemVerilogParserSQUIGCARET-51))|(1<<(SystemVerilogParserSQUIGBAR-51))|(1<<(SystemVerilogParserPLUS-51))|(1<<(SystemVerilogParserPLUSPLUS-51)))) != 0) || (((_la-109)&-(0x1f+1)) == 0 && ((1<<uint((_la-109)))&((1<<(SystemVerilogParserKBIT-109))|(1<<(SystemVerilogParserKBYTE-109))|(1<<(SystemVerilogParserKCONST-109)))) != 0) || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SystemVerilogParserKINT-195))|(1<<(SystemVerilogParserKINTEGER-195))|(1<<(SystemVerilogParserKLOCAL-195))|(1<<(SystemVerilogParserKLOGIC-195))|(1<<(SystemVerilogParserKLONGINT-195)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(SystemVerilogParserKNULL-228))|(1<<(SystemVerilogParserKRANDOMIZE-228))|(1<<(SystemVerilogParserKREAL-228))|(1<<(SystemVerilogParserKREALTIME-228))|(1<<(SystemVerilogParserKREG-228)))) != 0) || (((_la-276)&-(0x1f+1)) == 0 && ((1<<uint((_la-276)))&((1<<(SystemVerilogParserKSHORTINT-276))|(1<<(SystemVerilogParserKSHORTREAL-276))|(1<<(SystemVerilogParserKSIGNED-276))|(1<<(SystemVerilogParserKSTD-276))|(1<<(SystemVerilogParserKSTRING-276))|(1<<(SystemVerilogParserKSUPER-276))|(1<<(SystemVerilogParserKTAGGED-276))|(1<<(SystemVerilogParserKTHIS-276))|(1<<(SystemVerilogParserKTIME-276)))) != 0) || _la == SystemVerilogParserKTYPE || _la == SystemVerilogParserKUNSIGNED || (((_la-345)&-(0x1f+1)) == 0 && ((1<<uint((_la-345)))&((1<<(SystemVerilogParserTIME_LITERAL-345))|(1<<(SystemVerilogParserDECIMAL_NUMBER-345))|(1<<(SystemVerilogParserBINARY_NUMBER-345))|(1<<(SystemVerilogParserOCTAL_NUMBER-345))|(1<<(SystemVerilogParserHEX_NUMBER-345))|(1<<(SystemVerilogParserREAL_NUMBER-345))|(1<<(SystemVerilogParserUNSIGNED_NUMBER-345))|(1<<(SystemVerilogParserSTRING_LITERAL-345))|(1<<(SystemVerilogParserSIMPLE_IDENTIFIER-345))|(1<<(SystemVerilogParserSYSTEM_TF_IDENTIFIER-345)))) != 0) {
		{
			p.SetState(5275)
			p.expression(0)
		}

	}

	return localctx
}

// INamed_port_connectionContext is an interface to support dynamic dispatch.
type INamed_port_connectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNamed_port_connectionContext differentiates from other interfaces.
	IsNamed_port_connectionContext()
}

type Named_port_connectionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamed_port_connectionContext() *Named_port_connectionContext {
	var p = new(Named_port_connectionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_named_port_connection
	return p
}

func (*Named_port_connectionContext) IsNamed_port_connectionContext() {}

func NewNamed_port_connectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Named_port_connectionContext {
	var p = new(Named_port_connectionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_named_port_connection

	return p
}

func (s *Named_port_connectionContext) GetParser() antlr.Parser { return s.parser }

func (s *Named_port_connectionContext) DOT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserDOT, 0)
}

func (s *Named_port_connectionContext) Port_identifier() IPort_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPort_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPort_identifierContext)
}

func (s *Named_port_connectionContext) DOTSTAR() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserDOTSTAR, 0)
}

func (s *Named_port_connectionContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Named_port_connectionContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Named_port_connectionContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Named_port_connectionContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Named_port_connectionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Named_port_connectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Named_port_connectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Named_port_connectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterNamed_port_connection(s)
	}
}

func (s *Named_port_connectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitNamed_port_connection(s)
	}
}

func (p *SystemVerilogParser) Named_port_connection() (localctx INamed_port_connectionContext) {
	this := p
	_ = this

	localctx = NewNamed_port_connectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 642, SystemVerilogParserRULE_named_port_connection)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5281)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserLPS {
		{
			p.SetState(5278)
			p.Attribute_instance()
		}

		p.SetState(5283)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(5294)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserDOT:
		{
			p.SetState(5284)
			p.Match(SystemVerilogParserDOT)
		}
		{
			p.SetState(5285)
			p.Port_identifier()
		}
		p.SetState(5291)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserLP {
			{
				p.SetState(5286)
				p.Match(SystemVerilogParserLP)
			}
			p.SetState(5288)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SystemVerilogParserMINUS)|(1<<SystemVerilogParserMINUSMINS)|(1<<SystemVerilogParserNOT)|(1<<SystemVerilogParserDOLLAR)|(1<<SystemVerilogParserDROOT)|(1<<SystemVerilogParserDUNIT)|(1<<SystemVerilogParserAND)|(1<<SystemVerilogParserLP))) != 0) || (((_la-51)&-(0x1f+1)) == 0 && ((1<<uint((_la-51)))&((1<<(SystemVerilogParserQUOTE-51))|(1<<(SystemVerilogParserCARET-51))|(1<<(SystemVerilogParserCARETSQUIG-51))|(1<<(SystemVerilogParserLC-51))|(1<<(SystemVerilogParserBAR-51))|(1<<(SystemVerilogParserSQUIG-51))|(1<<(SystemVerilogParserSQUIGAND-51))|(1<<(SystemVerilogParserSQUIGCARET-51))|(1<<(SystemVerilogParserSQUIGBAR-51))|(1<<(SystemVerilogParserPLUS-51))|(1<<(SystemVerilogParserPLUSPLUS-51)))) != 0) || (((_la-109)&-(0x1f+1)) == 0 && ((1<<uint((_la-109)))&((1<<(SystemVerilogParserKBIT-109))|(1<<(SystemVerilogParserKBYTE-109))|(1<<(SystemVerilogParserKCONST-109)))) != 0) || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SystemVerilogParserKINT-195))|(1<<(SystemVerilogParserKINTEGER-195))|(1<<(SystemVerilogParserKLOCAL-195))|(1<<(SystemVerilogParserKLOGIC-195))|(1<<(SystemVerilogParserKLONGINT-195)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(SystemVerilogParserKNULL-228))|(1<<(SystemVerilogParserKRANDOMIZE-228))|(1<<(SystemVerilogParserKREAL-228))|(1<<(SystemVerilogParserKREALTIME-228))|(1<<(SystemVerilogParserKREG-228)))) != 0) || (((_la-276)&-(0x1f+1)) == 0 && ((1<<uint((_la-276)))&((1<<(SystemVerilogParserKSHORTINT-276))|(1<<(SystemVerilogParserKSHORTREAL-276))|(1<<(SystemVerilogParserKSIGNED-276))|(1<<(SystemVerilogParserKSTD-276))|(1<<(SystemVerilogParserKSTRING-276))|(1<<(SystemVerilogParserKSUPER-276))|(1<<(SystemVerilogParserKTAGGED-276))|(1<<(SystemVerilogParserKTHIS-276))|(1<<(SystemVerilogParserKTIME-276)))) != 0) || _la == SystemVerilogParserKTYPE || _la == SystemVerilogParserKUNSIGNED || (((_la-345)&-(0x1f+1)) == 0 && ((1<<uint((_la-345)))&((1<<(SystemVerilogParserTIME_LITERAL-345))|(1<<(SystemVerilogParserDECIMAL_NUMBER-345))|(1<<(SystemVerilogParserBINARY_NUMBER-345))|(1<<(SystemVerilogParserOCTAL_NUMBER-345))|(1<<(SystemVerilogParserHEX_NUMBER-345))|(1<<(SystemVerilogParserREAL_NUMBER-345))|(1<<(SystemVerilogParserUNSIGNED_NUMBER-345))|(1<<(SystemVerilogParserSTRING_LITERAL-345))|(1<<(SystemVerilogParserSIMPLE_IDENTIFIER-345))|(1<<(SystemVerilogParserSYSTEM_TF_IDENTIFIER-345)))) != 0) {
				{
					p.SetState(5287)
					p.expression(0)
				}

			}
			{
				p.SetState(5290)
				p.Match(SystemVerilogParserRP)
			}

		}

	case SystemVerilogParserDOTSTAR:
		{
			p.SetState(5293)
			p.Match(SystemVerilogParserDOTSTAR)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IInterface_instantiationContext is an interface to support dynamic dispatch.
type IInterface_instantiationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterface_instantiationContext differentiates from other interfaces.
	IsInterface_instantiationContext()
}

type Interface_instantiationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterface_instantiationContext() *Interface_instantiationContext {
	var p = new(Interface_instantiationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_interface_instantiation
	return p
}

func (*Interface_instantiationContext) IsInterface_instantiationContext() {}

func NewInterface_instantiationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Interface_instantiationContext {
	var p = new(Interface_instantiationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_interface_instantiation

	return p
}

func (s *Interface_instantiationContext) GetParser() antlr.Parser { return s.parser }

func (s *Interface_instantiationContext) Interface_identifier() IInterface_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterface_identifierContext)
}

func (s *Interface_instantiationContext) AllHierarchical_instance() []IHierarchical_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IHierarchical_instanceContext)(nil)).Elem())
	var tst = make([]IHierarchical_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IHierarchical_instanceContext)
		}
	}

	return tst
}

func (s *Interface_instantiationContext) Hierarchical_instance(i int) IHierarchical_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_instanceContext)
}

func (s *Interface_instantiationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Interface_instantiationContext) Parameter_value_assignment() IParameter_value_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_value_assignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_value_assignmentContext)
}

func (s *Interface_instantiationContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *Interface_instantiationContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *Interface_instantiationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Interface_instantiationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Interface_instantiationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterInterface_instantiation(s)
	}
}

func (s *Interface_instantiationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitInterface_instantiation(s)
	}
}

func (p *SystemVerilogParser) Interface_instantiation() (localctx IInterface_instantiationContext) {
	this := p
	_ = this

	localctx = NewInterface_instantiationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 644, SystemVerilogParserRULE_interface_instantiation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5296)
		p.Interface_identifier()
	}
	p.SetState(5298)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserP {
		{
			p.SetState(5297)
			p.Parameter_value_assignment()
		}

	}
	{
		p.SetState(5300)
		p.Hierarchical_instance()
	}
	p.SetState(5305)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserCOMMA {
		{
			p.SetState(5301)
			p.Match(SystemVerilogParserCOMMA)
		}
		{
			p.SetState(5302)
			p.Hierarchical_instance()
		}

		p.SetState(5307)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(5308)
		p.Match(SystemVerilogParserSEMI)
	}

	return localctx
}

// IProgram_instantiationContext is an interface to support dynamic dispatch.
type IProgram_instantiationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProgram_instantiationContext differentiates from other interfaces.
	IsProgram_instantiationContext()
}

type Program_instantiationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProgram_instantiationContext() *Program_instantiationContext {
	var p = new(Program_instantiationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_program_instantiation
	return p
}

func (*Program_instantiationContext) IsProgram_instantiationContext() {}

func NewProgram_instantiationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Program_instantiationContext {
	var p = new(Program_instantiationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_program_instantiation

	return p
}

func (s *Program_instantiationContext) GetParser() antlr.Parser { return s.parser }

func (s *Program_instantiationContext) Program_identifier() IProgram_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProgram_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProgram_identifierContext)
}

func (s *Program_instantiationContext) AllHierarchical_instance() []IHierarchical_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IHierarchical_instanceContext)(nil)).Elem())
	var tst = make([]IHierarchical_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IHierarchical_instanceContext)
		}
	}

	return tst
}

func (s *Program_instantiationContext) Hierarchical_instance(i int) IHierarchical_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_instanceContext)
}

func (s *Program_instantiationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Program_instantiationContext) Parameter_value_assignment() IParameter_value_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_value_assignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_value_assignmentContext)
}

func (s *Program_instantiationContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *Program_instantiationContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *Program_instantiationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Program_instantiationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Program_instantiationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterProgram_instantiation(s)
	}
}

func (s *Program_instantiationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitProgram_instantiation(s)
	}
}

func (p *SystemVerilogParser) Program_instantiation() (localctx IProgram_instantiationContext) {
	this := p
	_ = this

	localctx = NewProgram_instantiationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 646, SystemVerilogParserRULE_program_instantiation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5310)
		p.Program_identifier()
	}
	p.SetState(5312)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserP {
		{
			p.SetState(5311)
			p.Parameter_value_assignment()
		}

	}
	{
		p.SetState(5314)
		p.Hierarchical_instance()
	}
	p.SetState(5319)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserCOMMA {
		{
			p.SetState(5315)
			p.Match(SystemVerilogParserCOMMA)
		}
		{
			p.SetState(5316)
			p.Hierarchical_instance()
		}

		p.SetState(5321)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(5322)
		p.Match(SystemVerilogParserSEMI)
	}

	return localctx
}

// IChecker_instantiationContext is an interface to support dynamic dispatch.
type IChecker_instantiationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsChecker_instantiationContext differentiates from other interfaces.
	IsChecker_instantiationContext()
}

type Checker_instantiationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChecker_instantiationContext() *Checker_instantiationContext {
	var p = new(Checker_instantiationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_checker_instantiation
	return p
}

func (*Checker_instantiationContext) IsChecker_instantiationContext() {}

func NewChecker_instantiationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Checker_instantiationContext {
	var p = new(Checker_instantiationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_checker_instantiation

	return p
}

func (s *Checker_instantiationContext) GetParser() antlr.Parser { return s.parser }

func (s *Checker_instantiationContext) Ps_checker_identifier() IPs_checker_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPs_checker_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPs_checker_identifierContext)
}

func (s *Checker_instantiationContext) Name_of_instance() IName_of_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_of_instanceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_of_instanceContext)
}

func (s *Checker_instantiationContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Checker_instantiationContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Checker_instantiationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Checker_instantiationContext) List_of_checker_port_connections() IList_of_checker_port_connectionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_checker_port_connectionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_checker_port_connectionsContext)
}

func (s *Checker_instantiationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Checker_instantiationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Checker_instantiationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterChecker_instantiation(s)
	}
}

func (s *Checker_instantiationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitChecker_instantiation(s)
	}
}

func (p *SystemVerilogParser) Checker_instantiation() (localctx IChecker_instantiationContext) {
	this := p
	_ = this

	localctx = NewChecker_instantiationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 648, SystemVerilogParserRULE_checker_instantiation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5324)
		p.Ps_checker_identifier()
	}
	{
		p.SetState(5325)
		p.Name_of_instance()
	}
	{
		p.SetState(5326)
		p.Match(SystemVerilogParserLP)
	}
	p.SetState(5328)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 642, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5327)
			p.List_of_checker_port_connections()
		}

	}
	{
		p.SetState(5330)
		p.Match(SystemVerilogParserRP)
	}
	{
		p.SetState(5331)
		p.Match(SystemVerilogParserSEMI)
	}

	return localctx
}

// IList_of_checker_port_connectionsContext is an interface to support dynamic dispatch.
type IList_of_checker_port_connectionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_checker_port_connectionsContext differentiates from other interfaces.
	IsList_of_checker_port_connectionsContext()
}

type List_of_checker_port_connectionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_checker_port_connectionsContext() *List_of_checker_port_connectionsContext {
	var p = new(List_of_checker_port_connectionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_list_of_checker_port_connections
	return p
}

func (*List_of_checker_port_connectionsContext) IsList_of_checker_port_connectionsContext() {}

func NewList_of_checker_port_connectionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_checker_port_connectionsContext {
	var p = new(List_of_checker_port_connectionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_list_of_checker_port_connections

	return p
}

func (s *List_of_checker_port_connectionsContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_checker_port_connectionsContext) AllOrdered_checker_port_connection() []IOrdered_checker_port_connectionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOrdered_checker_port_connectionContext)(nil)).Elem())
	var tst = make([]IOrdered_checker_port_connectionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOrdered_checker_port_connectionContext)
		}
	}

	return tst
}

func (s *List_of_checker_port_connectionsContext) Ordered_checker_port_connection(i int) IOrdered_checker_port_connectionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOrdered_checker_port_connectionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOrdered_checker_port_connectionContext)
}

func (s *List_of_checker_port_connectionsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *List_of_checker_port_connectionsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *List_of_checker_port_connectionsContext) AllNamed_checker_port_connection() []INamed_checker_port_connectionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INamed_checker_port_connectionContext)(nil)).Elem())
	var tst = make([]INamed_checker_port_connectionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INamed_checker_port_connectionContext)
		}
	}

	return tst
}

func (s *List_of_checker_port_connectionsContext) Named_checker_port_connection(i int) INamed_checker_port_connectionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamed_checker_port_connectionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INamed_checker_port_connectionContext)
}

func (s *List_of_checker_port_connectionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_checker_port_connectionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_checker_port_connectionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterList_of_checker_port_connections(s)
	}
}

func (s *List_of_checker_port_connectionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitList_of_checker_port_connections(s)
	}
}

func (p *SystemVerilogParser) List_of_checker_port_connections() (localctx IList_of_checker_port_connectionsContext) {
	this := p
	_ = this

	localctx = NewList_of_checker_port_connectionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 650, SystemVerilogParserRULE_list_of_checker_port_connections)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5349)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 645, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5333)
			p.Ordered_checker_port_connection()
		}
		p.SetState(5338)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserCOMMA {
			{
				p.SetState(5334)
				p.Match(SystemVerilogParserCOMMA)
			}
			{
				p.SetState(5335)
				p.Ordered_checker_port_connection()
			}

			p.SetState(5340)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5341)
			p.Named_checker_port_connection()
		}
		p.SetState(5346)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserCOMMA {
			{
				p.SetState(5342)
				p.Match(SystemVerilogParserCOMMA)
			}
			{
				p.SetState(5343)
				p.Named_checker_port_connection()
			}

			p.SetState(5348)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// IOrdered_checker_port_connectionContext is an interface to support dynamic dispatch.
type IOrdered_checker_port_connectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOrdered_checker_port_connectionContext differentiates from other interfaces.
	IsOrdered_checker_port_connectionContext()
}

type Ordered_checker_port_connectionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrdered_checker_port_connectionContext() *Ordered_checker_port_connectionContext {
	var p = new(Ordered_checker_port_connectionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_ordered_checker_port_connection
	return p
}

func (*Ordered_checker_port_connectionContext) IsOrdered_checker_port_connectionContext() {}

func NewOrdered_checker_port_connectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Ordered_checker_port_connectionContext {
	var p = new(Ordered_checker_port_connectionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_ordered_checker_port_connection

	return p
}

func (s *Ordered_checker_port_connectionContext) GetParser() antlr.Parser { return s.parser }

func (s *Ordered_checker_port_connectionContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Ordered_checker_port_connectionContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Ordered_checker_port_connectionContext) Property_actual_arg() IProperty_actual_argContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProperty_actual_argContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProperty_actual_argContext)
}

func (s *Ordered_checker_port_connectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ordered_checker_port_connectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Ordered_checker_port_connectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterOrdered_checker_port_connection(s)
	}
}

func (s *Ordered_checker_port_connectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitOrdered_checker_port_connection(s)
	}
}

func (p *SystemVerilogParser) Ordered_checker_port_connection() (localctx IOrdered_checker_port_connectionContext) {
	this := p
	_ = this

	localctx = NewOrdered_checker_port_connectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 652, SystemVerilogParserRULE_ordered_checker_port_connection)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5354)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserLPS {
		{
			p.SetState(5351)
			p.Attribute_instance()
		}

		p.SetState(5356)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(5358)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SystemVerilogParserMINUS)|(1<<SystemVerilogParserMINUSMINS)|(1<<SystemVerilogParserNOT)|(1<<SystemVerilogParserPP)|(1<<SystemVerilogParserDOLLAR)|(1<<SystemVerilogParserDROOT)|(1<<SystemVerilogParserDUNIT)|(1<<SystemVerilogParserAND)|(1<<SystemVerilogParserLP))) != 0) || (((_la-48)&-(0x1f+1)) == 0 && ((1<<uint((_la-48)))&((1<<(SystemVerilogParserAT-48))|(1<<(SystemVerilogParserQUOTE-48))|(1<<(SystemVerilogParserCARET-48))|(1<<(SystemVerilogParserCARETSQUIG-48))|(1<<(SystemVerilogParserLC-48))|(1<<(SystemVerilogParserBAR-48))|(1<<(SystemVerilogParserSQUIG-48))|(1<<(SystemVerilogParserSQUIGAND-48))|(1<<(SystemVerilogParserSQUIGCARET-48))|(1<<(SystemVerilogParserSQUIGBAR-48))|(1<<(SystemVerilogParserPLUS-48))|(1<<(SystemVerilogParserPLUSPLUS-48)))) != 0) || (((_la-93)&-(0x1f+1)) == 0 && ((1<<uint((_la-93)))&((1<<(SystemVerilogParserKACCEPT_ON-93))|(1<<(SystemVerilogParserKALWAYS-93))|(1<<(SystemVerilogParserKBIT-93))|(1<<(SystemVerilogParserKBYTE-93))|(1<<(SystemVerilogParserKCASE-93)))) != 0) || _la == SystemVerilogParserKCONST || _la == SystemVerilogParserKEDGE || (((_la-161)&-(0x1f+1)) == 0 && ((1<<uint((_la-161)))&((1<<(SystemVerilogParserKEVENTUALLY-161))|(1<<(SystemVerilogParserKFIRST_MATCH-161))|(1<<(SystemVerilogParserKIF-161)))) != 0) || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SystemVerilogParserKINT-195))|(1<<(SystemVerilogParserKINTEGER-195))|(1<<(SystemVerilogParserKLOCAL-195))|(1<<(SystemVerilogParserKLOGIC-195))|(1<<(SystemVerilogParserKLONGINT-195))|(1<<(SystemVerilogParserKNEGEDGE-195))|(1<<(SystemVerilogParserKNEXTTIME-195))|(1<<(SystemVerilogParserKNOT-195)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(SystemVerilogParserKNULL-228))|(1<<(SystemVerilogParserKPOSEDGE-228))|(1<<(SystemVerilogParserKRANDOMIZE-228))|(1<<(SystemVerilogParserKREAL-228))|(1<<(SystemVerilogParserKREALTIME-228))|(1<<(SystemVerilogParserKREG-228))|(1<<(SystemVerilogParserKREJECT_ON-228)))) != 0) || (((_la-269)&-(0x1f+1)) == 0 && ((1<<uint((_la-269)))&((1<<(SystemVerilogParserKS_ALWAYS-269))|(1<<(SystemVerilogParserKS_EVENTUALLY-269))|(1<<(SystemVerilogParserKS_NEXTTIME-269))|(1<<(SystemVerilogParserKSHORTINT-269))|(1<<(SystemVerilogParserKSHORTREAL-269))|(1<<(SystemVerilogParserKSIGNED-269))|(1<<(SystemVerilogParserKSTD-269))|(1<<(SystemVerilogParserKSTRING-269))|(1<<(SystemVerilogParserKSTRONG-269))|(1<<(SystemVerilogParserKSUPER-269))|(1<<(SystemVerilogParserKSYNC_ACCEPT_ON-269))|(1<<(SystemVerilogParserKSYNC_REJECT_ON-269))|(1<<(SystemVerilogParserKTAGGED-269))|(1<<(SystemVerilogParserKTHIS-269)))) != 0) || (((_la-301)&-(0x1f+1)) == 0 && ((1<<uint((_la-301)))&((1<<(SystemVerilogParserKTIME-301))|(1<<(SystemVerilogParserKTYPE-301))|(1<<(SystemVerilogParserKUNSIGNED-301))|(1<<(SystemVerilogParserKWEAK-301)))) != 0) || (((_la-345)&-(0x1f+1)) == 0 && ((1<<uint((_la-345)))&((1<<(SystemVerilogParserTIME_LITERAL-345))|(1<<(SystemVerilogParserDECIMAL_NUMBER-345))|(1<<(SystemVerilogParserBINARY_NUMBER-345))|(1<<(SystemVerilogParserOCTAL_NUMBER-345))|(1<<(SystemVerilogParserHEX_NUMBER-345))|(1<<(SystemVerilogParserREAL_NUMBER-345))|(1<<(SystemVerilogParserUNSIGNED_NUMBER-345))|(1<<(SystemVerilogParserSTRING_LITERAL-345))|(1<<(SystemVerilogParserSIMPLE_IDENTIFIER-345))|(1<<(SystemVerilogParserSYSTEM_TF_IDENTIFIER-345)))) != 0) {
		{
			p.SetState(5357)
			p.Property_actual_arg()
		}

	}

	return localctx
}

// INamed_checker_port_connectionContext is an interface to support dynamic dispatch.
type INamed_checker_port_connectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNamed_checker_port_connectionContext differentiates from other interfaces.
	IsNamed_checker_port_connectionContext()
}

type Named_checker_port_connectionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamed_checker_port_connectionContext() *Named_checker_port_connectionContext {
	var p = new(Named_checker_port_connectionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_named_checker_port_connection
	return p
}

func (*Named_checker_port_connectionContext) IsNamed_checker_port_connectionContext() {}

func NewNamed_checker_port_connectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Named_checker_port_connectionContext {
	var p = new(Named_checker_port_connectionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_named_checker_port_connection

	return p
}

func (s *Named_checker_port_connectionContext) GetParser() antlr.Parser { return s.parser }

func (s *Named_checker_port_connectionContext) DOT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserDOT, 0)
}

func (s *Named_checker_port_connectionContext) Formal_port_identifier() IFormal_port_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormal_port_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFormal_port_identifierContext)
}

func (s *Named_checker_port_connectionContext) DOTSTAR() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserDOTSTAR, 0)
}

func (s *Named_checker_port_connectionContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Named_checker_port_connectionContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Named_checker_port_connectionContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Named_checker_port_connectionContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Named_checker_port_connectionContext) Property_actual_arg() IProperty_actual_argContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProperty_actual_argContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProperty_actual_argContext)
}

func (s *Named_checker_port_connectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Named_checker_port_connectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Named_checker_port_connectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterNamed_checker_port_connection(s)
	}
}

func (s *Named_checker_port_connectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitNamed_checker_port_connection(s)
	}
}

func (p *SystemVerilogParser) Named_checker_port_connection() (localctx INamed_checker_port_connectionContext) {
	this := p
	_ = this

	localctx = NewNamed_checker_port_connectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 654, SystemVerilogParserRULE_named_checker_port_connection)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5363)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserLPS {
		{
			p.SetState(5360)
			p.Attribute_instance()
		}

		p.SetState(5365)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(5376)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserDOT:
		{
			p.SetState(5366)
			p.Match(SystemVerilogParserDOT)
		}
		{
			p.SetState(5367)
			p.Formal_port_identifier()
		}
		p.SetState(5373)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserLP {
			{
				p.SetState(5368)
				p.Match(SystemVerilogParserLP)
			}
			p.SetState(5370)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SystemVerilogParserMINUS)|(1<<SystemVerilogParserMINUSMINS)|(1<<SystemVerilogParserNOT)|(1<<SystemVerilogParserPP)|(1<<SystemVerilogParserDOLLAR)|(1<<SystemVerilogParserDROOT)|(1<<SystemVerilogParserDUNIT)|(1<<SystemVerilogParserAND)|(1<<SystemVerilogParserLP))) != 0) || (((_la-48)&-(0x1f+1)) == 0 && ((1<<uint((_la-48)))&((1<<(SystemVerilogParserAT-48))|(1<<(SystemVerilogParserQUOTE-48))|(1<<(SystemVerilogParserCARET-48))|(1<<(SystemVerilogParserCARETSQUIG-48))|(1<<(SystemVerilogParserLC-48))|(1<<(SystemVerilogParserBAR-48))|(1<<(SystemVerilogParserSQUIG-48))|(1<<(SystemVerilogParserSQUIGAND-48))|(1<<(SystemVerilogParserSQUIGCARET-48))|(1<<(SystemVerilogParserSQUIGBAR-48))|(1<<(SystemVerilogParserPLUS-48))|(1<<(SystemVerilogParserPLUSPLUS-48)))) != 0) || (((_la-93)&-(0x1f+1)) == 0 && ((1<<uint((_la-93)))&((1<<(SystemVerilogParserKACCEPT_ON-93))|(1<<(SystemVerilogParserKALWAYS-93))|(1<<(SystemVerilogParserKBIT-93))|(1<<(SystemVerilogParserKBYTE-93))|(1<<(SystemVerilogParserKCASE-93)))) != 0) || _la == SystemVerilogParserKCONST || _la == SystemVerilogParserKEDGE || (((_la-161)&-(0x1f+1)) == 0 && ((1<<uint((_la-161)))&((1<<(SystemVerilogParserKEVENTUALLY-161))|(1<<(SystemVerilogParserKFIRST_MATCH-161))|(1<<(SystemVerilogParserKIF-161)))) != 0) || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SystemVerilogParserKINT-195))|(1<<(SystemVerilogParserKINTEGER-195))|(1<<(SystemVerilogParserKLOCAL-195))|(1<<(SystemVerilogParserKLOGIC-195))|(1<<(SystemVerilogParserKLONGINT-195))|(1<<(SystemVerilogParserKNEGEDGE-195))|(1<<(SystemVerilogParserKNEXTTIME-195))|(1<<(SystemVerilogParserKNOT-195)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(SystemVerilogParserKNULL-228))|(1<<(SystemVerilogParserKPOSEDGE-228))|(1<<(SystemVerilogParserKRANDOMIZE-228))|(1<<(SystemVerilogParserKREAL-228))|(1<<(SystemVerilogParserKREALTIME-228))|(1<<(SystemVerilogParserKREG-228))|(1<<(SystemVerilogParserKREJECT_ON-228)))) != 0) || (((_la-269)&-(0x1f+1)) == 0 && ((1<<uint((_la-269)))&((1<<(SystemVerilogParserKS_ALWAYS-269))|(1<<(SystemVerilogParserKS_EVENTUALLY-269))|(1<<(SystemVerilogParserKS_NEXTTIME-269))|(1<<(SystemVerilogParserKSHORTINT-269))|(1<<(SystemVerilogParserKSHORTREAL-269))|(1<<(SystemVerilogParserKSIGNED-269))|(1<<(SystemVerilogParserKSTD-269))|(1<<(SystemVerilogParserKSTRING-269))|(1<<(SystemVerilogParserKSTRONG-269))|(1<<(SystemVerilogParserKSUPER-269))|(1<<(SystemVerilogParserKSYNC_ACCEPT_ON-269))|(1<<(SystemVerilogParserKSYNC_REJECT_ON-269))|(1<<(SystemVerilogParserKTAGGED-269))|(1<<(SystemVerilogParserKTHIS-269)))) != 0) || (((_la-301)&-(0x1f+1)) == 0 && ((1<<uint((_la-301)))&((1<<(SystemVerilogParserKTIME-301))|(1<<(SystemVerilogParserKTYPE-301))|(1<<(SystemVerilogParserKUNSIGNED-301))|(1<<(SystemVerilogParserKWEAK-301)))) != 0) || (((_la-345)&-(0x1f+1)) == 0 && ((1<<uint((_la-345)))&((1<<(SystemVerilogParserTIME_LITERAL-345))|(1<<(SystemVerilogParserDECIMAL_NUMBER-345))|(1<<(SystemVerilogParserBINARY_NUMBER-345))|(1<<(SystemVerilogParserOCTAL_NUMBER-345))|(1<<(SystemVerilogParserHEX_NUMBER-345))|(1<<(SystemVerilogParserREAL_NUMBER-345))|(1<<(SystemVerilogParserUNSIGNED_NUMBER-345))|(1<<(SystemVerilogParserSTRING_LITERAL-345))|(1<<(SystemVerilogParserSIMPLE_IDENTIFIER-345))|(1<<(SystemVerilogParserSYSTEM_TF_IDENTIFIER-345)))) != 0) {
				{
					p.SetState(5369)
					p.Property_actual_arg()
				}

			}
			{
				p.SetState(5372)
				p.Match(SystemVerilogParserRP)
			}

		}

	case SystemVerilogParserDOTSTAR:
		{
			p.SetState(5375)
			p.Match(SystemVerilogParserDOTSTAR)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IGenerate_regionContext is an interface to support dynamic dispatch.
type IGenerate_regionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenerate_regionContext differentiates from other interfaces.
	IsGenerate_regionContext()
}

type Generate_regionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenerate_regionContext() *Generate_regionContext {
	var p = new(Generate_regionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_generate_region
	return p
}

func (*Generate_regionContext) IsGenerate_regionContext() {}

func NewGenerate_regionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Generate_regionContext {
	var p = new(Generate_regionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_generate_region

	return p
}

func (s *Generate_regionContext) GetParser() antlr.Parser { return s.parser }

func (s *Generate_regionContext) KGENERATE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKGENERATE, 0)
}

func (s *Generate_regionContext) KENDGENERATE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKENDGENERATE, 0)
}

func (s *Generate_regionContext) AllGenerate_item() []IGenerate_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IGenerate_itemContext)(nil)).Elem())
	var tst = make([]IGenerate_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IGenerate_itemContext)
		}
	}

	return tst
}

func (s *Generate_regionContext) Generate_item(i int) IGenerate_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenerate_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IGenerate_itemContext)
}

func (s *Generate_regionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Generate_regionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Generate_regionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterGenerate_region(s)
	}
}

func (s *Generate_regionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitGenerate_region(s)
	}
}

func (p *SystemVerilogParser) Generate_region() (localctx IGenerate_regionContext) {
	this := p
	_ = this

	localctx = NewGenerate_regionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 656, SystemVerilogParserRULE_generate_region)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5378)
		p.Match(SystemVerilogParserKGENERATE)
	}
	p.SetState(5382)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SystemVerilogParserDERROR)|(1<<SystemVerilogParserDFATAL)|(1<<SystemVerilogParserDINFO)|(1<<SystemVerilogParserDUNIT)|(1<<SystemVerilogParserDWARNING)|(1<<SystemVerilogParserLPS))) != 0) || _la == SystemVerilogParserSEMI || _la == SystemVerilogParserLB || (((_la-94)&-(0x1f+1)) == 0 && ((1<<uint((_la-94)))&((1<<(SystemVerilogParserKALIAS-94))|(1<<(SystemVerilogParserKALWAYS-94))|(1<<(SystemVerilogParserKALWAYS_COMB-94))|(1<<(SystemVerilogParserKALWAYS_FF-94))|(1<<(SystemVerilogParserKALWAYS_LATCH-94))|(1<<(SystemVerilogParserKAND-94))|(1<<(SystemVerilogParserKASSERT-94))|(1<<(SystemVerilogParserKASSIGN-94))|(1<<(SystemVerilogParserKASSUME-94))|(1<<(SystemVerilogParserKAUTOMATIC-94))|(1<<(SystemVerilogParserKBIND-94))|(1<<(SystemVerilogParserKBIT-94))|(1<<(SystemVerilogParserKBUF-94))|(1<<(SystemVerilogParserKBUFIF0-94))|(1<<(SystemVerilogParserKBUFIF1-94))|(1<<(SystemVerilogParserKBYTE-94))|(1<<(SystemVerilogParserKCASE-94))|(1<<(SystemVerilogParserKCHANDLE-94))|(1<<(SystemVerilogParserKCHECKER-94))|(1<<(SystemVerilogParserKCLASS-94))|(1<<(SystemVerilogParserKCLOCKING-94))|(1<<(SystemVerilogParserKCMOS-94))|(1<<(SystemVerilogParserKCONST-94)))) != 0) || (((_la-126)&-(0x1f+1)) == 0 && ((1<<uint((_la-126)))&((1<<(SystemVerilogParserKCONSTRAINT-126))|(1<<(SystemVerilogParserKCOVER-126))|(1<<(SystemVerilogParserKCOVERGROUP-126))|(1<<(SystemVerilogParserKDEFAULT-126))|(1<<(SystemVerilogParserKDEFPARAM-126)))) != 0) || (((_la-159)&-(0x1f+1)) == 0 && ((1<<uint((_la-159)))&((1<<(SystemVerilogParserKENUM-159))|(1<<(SystemVerilogParserKEVENT-159))|(1<<(SystemVerilogParserKEXPORT-159))|(1<<(SystemVerilogParserKEXTERN-159))|(1<<(SystemVerilogParserKFINAL-159))|(1<<(SystemVerilogParserKFOR-159))|(1<<(SystemVerilogParserKFUNCTION-159))|(1<<(SystemVerilogParserKGENERATE-159))|(1<<(SystemVerilogParserKGENVAR-159))|(1<<(SystemVerilogParserKGLOBAL-159))|(1<<(SystemVerilogParserKIF-159))|(1<<(SystemVerilogParserKIMPORT-159))|(1<<(SystemVerilogParserKINITIAL-159)))) != 0) || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SystemVerilogParserKINT-195))|(1<<(SystemVerilogParserKINTEGER-195))|(1<<(SystemVerilogParserKINTERCONNECT-195))|(1<<(SystemVerilogParserKLET-195))|(1<<(SystemVerilogParserKLOCALPARAM-195))|(1<<(SystemVerilogParserKLOGIC-195))|(1<<(SystemVerilogParserKLONGINT-195))|(1<<(SystemVerilogParserKNAND-195))|(1<<(SystemVerilogParserKNETTYPE-195))|(1<<(SystemVerilogParserKNMOS-195))|(1<<(SystemVerilogParserKNOR-195))|(1<<(SystemVerilogParserKNOT-195))|(1<<(SystemVerilogParserKNOTIF0-195)))) != 0) || (((_la-227)&-(0x1f+1)) == 0 && ((1<<uint((_la-227)))&((1<<(SystemVerilogParserKNOTIF1-227))|(1<<(SystemVerilogParserKOR-227))|(1<<(SystemVerilogParserKPARAMETER-227))|(1<<(SystemVerilogParserKPMOS-227))|(1<<(SystemVerilogParserKPROPERTY-227))|(1<<(SystemVerilogParserKPULLDOWN-227))|(1<<(SystemVerilogParserKPULLUP-227))|(1<<(SystemVerilogParserKRAND-227))|(1<<(SystemVerilogParserKRCMOS-227))|(1<<(SystemVerilogParserKREAL-227))|(1<<(SystemVerilogParserKREALTIME-227))|(1<<(SystemVerilogParserKREG-227)))) != 0) || (((_la-262)&-(0x1f+1)) == 0 && ((1<<uint((_la-262)))&((1<<(SystemVerilogParserKRESTRICT-262))|(1<<(SystemVerilogParserKRNMOS-262))|(1<<(SystemVerilogParserKRPMOS-262))|(1<<(SystemVerilogParserKRTRAN-262))|(1<<(SystemVerilogParserKRTRANIF0-262))|(1<<(SystemVerilogParserKRTRANIF1-262))|(1<<(SystemVerilogParserKSEQUENCE-262))|(1<<(SystemVerilogParserKSHORTINT-262))|(1<<(SystemVerilogParserKSHORTREAL-262))|(1<<(SystemVerilogParserKSIGNED-262))|(1<<(SystemVerilogParserKSTATIC-262))|(1<<(SystemVerilogParserKSTRING-262))|(1<<(SystemVerilogParserKSTRUCT-262))|(1<<(SystemVerilogParserKSUPPLY0-262)))) != 0) || (((_la-294)&-(0x1f+1)) == 0 && ((1<<uint((_la-294)))&((1<<(SystemVerilogParserKSUPPLY1-294))|(1<<(SystemVerilogParserKTASK-294))|(1<<(SystemVerilogParserKTIME-294))|(1<<(SystemVerilogParserKTRAN-294))|(1<<(SystemVerilogParserKTRANIF0-294))|(1<<(SystemVerilogParserKTRANIF1-294))|(1<<(SystemVerilogParserKTRI-294))|(1<<(SystemVerilogParserKTRI0-294))|(1<<(SystemVerilogParserKTRI1-294))|(1<<(SystemVerilogParserKTRIAND-294))|(1<<(SystemVerilogParserKTRIOR-294))|(1<<(SystemVerilogParserKTRIREG-294))|(1<<(SystemVerilogParserKTYPE-294))|(1<<(SystemVerilogParserKTYPEDEF-294))|(1<<(SystemVerilogParserKUNION-294))|(1<<(SystemVerilogParserKUNSIGNED-294))|(1<<(SystemVerilogParserKUWIRE-294))|(1<<(SystemVerilogParserKVAR-294)))) != 0) || (((_la-327)&-(0x1f+1)) == 0 && ((1<<uint((_la-327)))&((1<<(SystemVerilogParserKVIRTUAL-327))|(1<<(SystemVerilogParserKWAND-327))|(1<<(SystemVerilogParserKWIRE-327))|(1<<(SystemVerilogParserKWOR-327))|(1<<(SystemVerilogParserKXNOR-327))|(1<<(SystemVerilogParserKXOR-327))|(1<<(SystemVerilogParserSIMPLE_IDENTIFIER-327)))) != 0) {
		{
			p.SetState(5379)
			p.Generate_item()
		}

		p.SetState(5384)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(5385)
		p.Match(SystemVerilogParserKENDGENERATE)
	}

	return localctx
}

// ILoop_generate_constructContext is an interface to support dynamic dispatch.
type ILoop_generate_constructContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLoop_generate_constructContext differentiates from other interfaces.
	IsLoop_generate_constructContext()
}

type Loop_generate_constructContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLoop_generate_constructContext() *Loop_generate_constructContext {
	var p = new(Loop_generate_constructContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_loop_generate_construct
	return p
}

func (*Loop_generate_constructContext) IsLoop_generate_constructContext() {}

func NewLoop_generate_constructContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Loop_generate_constructContext {
	var p = new(Loop_generate_constructContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_loop_generate_construct

	return p
}

func (s *Loop_generate_constructContext) GetParser() antlr.Parser { return s.parser }

func (s *Loop_generate_constructContext) KFOR() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKFOR, 0)
}

func (s *Loop_generate_constructContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Loop_generate_constructContext) Genvar_initialization() IGenvar_initializationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenvar_initializationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenvar_initializationContext)
}

func (s *Loop_generate_constructContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserSEMI)
}

func (s *Loop_generate_constructContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, i)
}

func (s *Loop_generate_constructContext) Genvar_expression() IGenvar_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenvar_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenvar_expressionContext)
}

func (s *Loop_generate_constructContext) Genvar_iteration() IGenvar_iterationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenvar_iterationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenvar_iterationContext)
}

func (s *Loop_generate_constructContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Loop_generate_constructContext) Generate_block() IGenerate_blockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenerate_blockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenerate_blockContext)
}

func (s *Loop_generate_constructContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Loop_generate_constructContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Loop_generate_constructContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterLoop_generate_construct(s)
	}
}

func (s *Loop_generate_constructContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitLoop_generate_construct(s)
	}
}

func (p *SystemVerilogParser) Loop_generate_construct() (localctx ILoop_generate_constructContext) {
	this := p
	_ = this

	localctx = NewLoop_generate_constructContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 658, SystemVerilogParserRULE_loop_generate_construct)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5387)
		p.Match(SystemVerilogParserKFOR)
	}
	{
		p.SetState(5388)
		p.Match(SystemVerilogParserLP)
	}
	{
		p.SetState(5389)
		p.Genvar_initialization()
	}
	{
		p.SetState(5390)
		p.Match(SystemVerilogParserSEMI)
	}
	{
		p.SetState(5391)
		p.Genvar_expression()
	}
	{
		p.SetState(5392)
		p.Match(SystemVerilogParserSEMI)
	}
	{
		p.SetState(5393)
		p.Genvar_iteration()
	}
	{
		p.SetState(5394)
		p.Match(SystemVerilogParserRP)
	}
	{
		p.SetState(5395)
		p.Generate_block()
	}

	return localctx
}

// IGenvar_initializationContext is an interface to support dynamic dispatch.
type IGenvar_initializationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenvar_initializationContext differentiates from other interfaces.
	IsGenvar_initializationContext()
}

type Genvar_initializationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenvar_initializationContext() *Genvar_initializationContext {
	var p = new(Genvar_initializationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_genvar_initialization
	return p
}

func (*Genvar_initializationContext) IsGenvar_initializationContext() {}

func NewGenvar_initializationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Genvar_initializationContext {
	var p = new(Genvar_initializationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_genvar_initialization

	return p
}

func (s *Genvar_initializationContext) GetParser() antlr.Parser { return s.parser }

func (s *Genvar_initializationContext) Genvar_identifier() IGenvar_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenvar_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenvar_identifierContext)
}

func (s *Genvar_initializationContext) EQ() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserEQ, 0)
}

func (s *Genvar_initializationContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Genvar_initializationContext) KGENVAR() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKGENVAR, 0)
}

func (s *Genvar_initializationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Genvar_initializationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Genvar_initializationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterGenvar_initialization(s)
	}
}

func (s *Genvar_initializationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitGenvar_initialization(s)
	}
}

func (p *SystemVerilogParser) Genvar_initialization() (localctx IGenvar_initializationContext) {
	this := p
	_ = this

	localctx = NewGenvar_initializationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 660, SystemVerilogParserRULE_genvar_initialization)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5398)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserKGENVAR {
		{
			p.SetState(5397)
			p.Match(SystemVerilogParserKGENVAR)
		}

	}
	{
		p.SetState(5400)
		p.Genvar_identifier()
	}
	{
		p.SetState(5401)
		p.Match(SystemVerilogParserEQ)
	}
	{
		p.SetState(5402)
		p.constant_expression(0)
	}

	return localctx
}

// IGenvar_iterationContext is an interface to support dynamic dispatch.
type IGenvar_iterationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenvar_iterationContext differentiates from other interfaces.
	IsGenvar_iterationContext()
}

type Genvar_iterationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenvar_iterationContext() *Genvar_iterationContext {
	var p = new(Genvar_iterationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_genvar_iteration
	return p
}

func (*Genvar_iterationContext) IsGenvar_iterationContext() {}

func NewGenvar_iterationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Genvar_iterationContext {
	var p = new(Genvar_iterationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_genvar_iteration

	return p
}

func (s *Genvar_iterationContext) GetParser() antlr.Parser { return s.parser }

func (s *Genvar_iterationContext) Genvar_identifier() IGenvar_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenvar_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenvar_identifierContext)
}

func (s *Genvar_iterationContext) Assignment_operator() IAssignment_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignment_operatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignment_operatorContext)
}

func (s *Genvar_iterationContext) Genvar_expression() IGenvar_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenvar_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenvar_expressionContext)
}

func (s *Genvar_iterationContext) Inc_or_dec_operator() IInc_or_dec_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInc_or_dec_operatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInc_or_dec_operatorContext)
}

func (s *Genvar_iterationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Genvar_iterationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Genvar_iterationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterGenvar_iteration(s)
	}
}

func (s *Genvar_iterationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitGenvar_iteration(s)
	}
}

func (p *SystemVerilogParser) Genvar_iteration() (localctx IGenvar_iterationContext) {
	this := p
	_ = this

	localctx = NewGenvar_iterationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 662, SystemVerilogParserRULE_genvar_iteration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5414)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 654, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5404)
			p.Genvar_identifier()
		}
		{
			p.SetState(5405)
			p.Assignment_operator()
		}
		{
			p.SetState(5406)
			p.Genvar_expression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5408)
			p.Inc_or_dec_operator()
		}
		{
			p.SetState(5409)
			p.Genvar_identifier()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5411)
			p.Genvar_identifier()
		}
		{
			p.SetState(5412)
			p.Inc_or_dec_operator()
		}

	}

	return localctx
}

// IConditional_generate_constructContext is an interface to support dynamic dispatch.
type IConditional_generate_constructContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConditional_generate_constructContext differentiates from other interfaces.
	IsConditional_generate_constructContext()
}

type Conditional_generate_constructContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditional_generate_constructContext() *Conditional_generate_constructContext {
	var p = new(Conditional_generate_constructContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_conditional_generate_construct
	return p
}

func (*Conditional_generate_constructContext) IsConditional_generate_constructContext() {}

func NewConditional_generate_constructContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Conditional_generate_constructContext {
	var p = new(Conditional_generate_constructContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_conditional_generate_construct

	return p
}

func (s *Conditional_generate_constructContext) GetParser() antlr.Parser { return s.parser }

func (s *Conditional_generate_constructContext) If_generate_construct() IIf_generate_constructContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIf_generate_constructContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIf_generate_constructContext)
}

func (s *Conditional_generate_constructContext) Case_generate_construct() ICase_generate_constructContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICase_generate_constructContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICase_generate_constructContext)
}

func (s *Conditional_generate_constructContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Conditional_generate_constructContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Conditional_generate_constructContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterConditional_generate_construct(s)
	}
}

func (s *Conditional_generate_constructContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitConditional_generate_construct(s)
	}
}

func (p *SystemVerilogParser) Conditional_generate_construct() (localctx IConditional_generate_constructContext) {
	this := p
	_ = this

	localctx = NewConditional_generate_constructContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 664, SystemVerilogParserRULE_conditional_generate_construct)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5418)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserKIF:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5416)
			p.If_generate_construct()
		}

	case SystemVerilogParserKCASE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5417)
			p.Case_generate_construct()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IIf_generate_constructContext is an interface to support dynamic dispatch.
type IIf_generate_constructContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIf_generate_constructContext differentiates from other interfaces.
	IsIf_generate_constructContext()
}

type If_generate_constructContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIf_generate_constructContext() *If_generate_constructContext {
	var p = new(If_generate_constructContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_if_generate_construct
	return p
}

func (*If_generate_constructContext) IsIf_generate_constructContext() {}

func NewIf_generate_constructContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *If_generate_constructContext {
	var p = new(If_generate_constructContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_if_generate_construct

	return p
}

func (s *If_generate_constructContext) GetParser() antlr.Parser { return s.parser }

func (s *If_generate_constructContext) KIF() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKIF, 0)
}

func (s *If_generate_constructContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *If_generate_constructContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *If_generate_constructContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *If_generate_constructContext) AllGenerate_block() []IGenerate_blockContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IGenerate_blockContext)(nil)).Elem())
	var tst = make([]IGenerate_blockContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IGenerate_blockContext)
		}
	}

	return tst
}

func (s *If_generate_constructContext) Generate_block(i int) IGenerate_blockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenerate_blockContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IGenerate_blockContext)
}

func (s *If_generate_constructContext) KELSE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKELSE, 0)
}

func (s *If_generate_constructContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *If_generate_constructContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *If_generate_constructContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterIf_generate_construct(s)
	}
}

func (s *If_generate_constructContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitIf_generate_construct(s)
	}
}

func (p *SystemVerilogParser) If_generate_construct() (localctx IIf_generate_constructContext) {
	this := p
	_ = this

	localctx = NewIf_generate_constructContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 666, SystemVerilogParserRULE_if_generate_construct)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5420)
		p.Match(SystemVerilogParserKIF)
	}
	{
		p.SetState(5421)
		p.Match(SystemVerilogParserLP)
	}
	{
		p.SetState(5422)
		p.constant_expression(0)
	}
	{
		p.SetState(5423)
		p.Match(SystemVerilogParserRP)
	}
	{
		p.SetState(5424)
		p.Generate_block()
	}
	p.SetState(5427)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 656, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5425)
			p.Match(SystemVerilogParserKELSE)
		}
		{
			p.SetState(5426)
			p.Generate_block()
		}

	}

	return localctx
}

// ICase_generate_constructContext is an interface to support dynamic dispatch.
type ICase_generate_constructContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCase_generate_constructContext differentiates from other interfaces.
	IsCase_generate_constructContext()
}

type Case_generate_constructContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCase_generate_constructContext() *Case_generate_constructContext {
	var p = new(Case_generate_constructContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_case_generate_construct
	return p
}

func (*Case_generate_constructContext) IsCase_generate_constructContext() {}

func NewCase_generate_constructContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Case_generate_constructContext {
	var p = new(Case_generate_constructContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_case_generate_construct

	return p
}

func (s *Case_generate_constructContext) GetParser() antlr.Parser { return s.parser }

func (s *Case_generate_constructContext) KCASE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKCASE, 0)
}

func (s *Case_generate_constructContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Case_generate_constructContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Case_generate_constructContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Case_generate_constructContext) AllCase_generate_item() []ICase_generate_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICase_generate_itemContext)(nil)).Elem())
	var tst = make([]ICase_generate_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICase_generate_itemContext)
		}
	}

	return tst
}

func (s *Case_generate_constructContext) Case_generate_item(i int) ICase_generate_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICase_generate_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICase_generate_itemContext)
}

func (s *Case_generate_constructContext) KENDCASE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKENDCASE, 0)
}

func (s *Case_generate_constructContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Case_generate_constructContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Case_generate_constructContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterCase_generate_construct(s)
	}
}

func (s *Case_generate_constructContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitCase_generate_construct(s)
	}
}

func (p *SystemVerilogParser) Case_generate_construct() (localctx ICase_generate_constructContext) {
	this := p
	_ = this

	localctx = NewCase_generate_constructContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 668, SystemVerilogParserRULE_case_generate_construct)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5429)
		p.Match(SystemVerilogParserKCASE)
	}
	{
		p.SetState(5430)
		p.Match(SystemVerilogParserLP)
	}
	{
		p.SetState(5431)
		p.constant_expression(0)
	}
	{
		p.SetState(5432)
		p.Match(SystemVerilogParserRP)
	}
	{
		p.SetState(5433)
		p.Case_generate_item()
	}
	p.SetState(5437)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SystemVerilogParserMINUS)|(1<<SystemVerilogParserNOT)|(1<<SystemVerilogParserDOLLAR)|(1<<SystemVerilogParserDROOT)|(1<<SystemVerilogParserDUNIT)|(1<<SystemVerilogParserAND)|(1<<SystemVerilogParserLP))) != 0) || (((_la-51)&-(0x1f+1)) == 0 && ((1<<uint((_la-51)))&((1<<(SystemVerilogParserQUOTE-51))|(1<<(SystemVerilogParserCARET-51))|(1<<(SystemVerilogParserCARETSQUIG-51))|(1<<(SystemVerilogParserLC-51))|(1<<(SystemVerilogParserBAR-51))|(1<<(SystemVerilogParserSQUIG-51))|(1<<(SystemVerilogParserSQUIGAND-51))|(1<<(SystemVerilogParserSQUIGCARET-51))|(1<<(SystemVerilogParserSQUIGBAR-51))|(1<<(SystemVerilogParserPLUS-51)))) != 0) || _la == SystemVerilogParserKBYTE || _la == SystemVerilogParserKDEFAULT || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SystemVerilogParserKINT-195))|(1<<(SystemVerilogParserKINTEGER-195))|(1<<(SystemVerilogParserKLOCAL-195))|(1<<(SystemVerilogParserKLONGINT-195)))) != 0) || _la == SystemVerilogParserKNULL || _la == SystemVerilogParserKRANDOMIZE || (((_la-276)&-(0x1f+1)) == 0 && ((1<<uint((_la-276)))&((1<<(SystemVerilogParserKSHORTINT-276))|(1<<(SystemVerilogParserKSTD-276))|(1<<(SystemVerilogParserKSUPER-276))|(1<<(SystemVerilogParserKTHIS-276))|(1<<(SystemVerilogParserKTIME-276)))) != 0) || _la == SystemVerilogParserKTYPE || (((_la-345)&-(0x1f+1)) == 0 && ((1<<uint((_la-345)))&((1<<(SystemVerilogParserTIME_LITERAL-345))|(1<<(SystemVerilogParserDECIMAL_NUMBER-345))|(1<<(SystemVerilogParserBINARY_NUMBER-345))|(1<<(SystemVerilogParserOCTAL_NUMBER-345))|(1<<(SystemVerilogParserHEX_NUMBER-345))|(1<<(SystemVerilogParserREAL_NUMBER-345))|(1<<(SystemVerilogParserUNSIGNED_NUMBER-345))|(1<<(SystemVerilogParserSTRING_LITERAL-345))|(1<<(SystemVerilogParserSIMPLE_IDENTIFIER-345))|(1<<(SystemVerilogParserSYSTEM_TF_IDENTIFIER-345)))) != 0) {
		{
			p.SetState(5434)
			p.Case_generate_item()
		}

		p.SetState(5439)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(5440)
		p.Match(SystemVerilogParserKENDCASE)
	}

	return localctx
}

// ICase_generate_itemContext is an interface to support dynamic dispatch.
type ICase_generate_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCase_generate_itemContext differentiates from other interfaces.
	IsCase_generate_itemContext()
}

type Case_generate_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCase_generate_itemContext() *Case_generate_itemContext {
	var p = new(Case_generate_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_case_generate_item
	return p
}

func (*Case_generate_itemContext) IsCase_generate_itemContext() {}

func NewCase_generate_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Case_generate_itemContext {
	var p = new(Case_generate_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_case_generate_item

	return p
}

func (s *Case_generate_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Case_generate_itemContext) AllConstant_expression() []IConstant_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem())
	var tst = make([]IConstant_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConstant_expressionContext)
		}
	}

	return tst
}

func (s *Case_generate_itemContext) Constant_expression(i int) IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Case_generate_itemContext) COLON() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOLON, 0)
}

func (s *Case_generate_itemContext) Generate_block() IGenerate_blockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenerate_blockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenerate_blockContext)
}

func (s *Case_generate_itemContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *Case_generate_itemContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *Case_generate_itemContext) KDEFAULT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKDEFAULT, 0)
}

func (s *Case_generate_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Case_generate_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Case_generate_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterCase_generate_item(s)
	}
}

func (s *Case_generate_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitCase_generate_item(s)
	}
}

func (p *SystemVerilogParser) Case_generate_item() (localctx ICase_generate_itemContext) {
	this := p
	_ = this

	localctx = NewCase_generate_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 670, SystemVerilogParserRULE_case_generate_item)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5458)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserMINUS, SystemVerilogParserNOT, SystemVerilogParserDOLLAR, SystemVerilogParserDROOT, SystemVerilogParserDUNIT, SystemVerilogParserAND, SystemVerilogParserLP, SystemVerilogParserQUOTE, SystemVerilogParserCARET, SystemVerilogParserCARETSQUIG, SystemVerilogParserLC, SystemVerilogParserBAR, SystemVerilogParserSQUIG, SystemVerilogParserSQUIGAND, SystemVerilogParserSQUIGCARET, SystemVerilogParserSQUIGBAR, SystemVerilogParserPLUS, SystemVerilogParserKBYTE, SystemVerilogParserKINT, SystemVerilogParserKINTEGER, SystemVerilogParserKLOCAL, SystemVerilogParserKLONGINT, SystemVerilogParserKNULL, SystemVerilogParserKRANDOMIZE, SystemVerilogParserKSHORTINT, SystemVerilogParserKSTD, SystemVerilogParserKSUPER, SystemVerilogParserKTHIS, SystemVerilogParserKTIME, SystemVerilogParserKTYPE, SystemVerilogParserTIME_LITERAL, SystemVerilogParserDECIMAL_NUMBER, SystemVerilogParserBINARY_NUMBER, SystemVerilogParserOCTAL_NUMBER, SystemVerilogParserHEX_NUMBER, SystemVerilogParserREAL_NUMBER, SystemVerilogParserUNSIGNED_NUMBER, SystemVerilogParserSTRING_LITERAL, SystemVerilogParserSIMPLE_IDENTIFIER, SystemVerilogParserSYSTEM_TF_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5442)
			p.constant_expression(0)
		}
		p.SetState(5447)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserCOMMA {
			{
				p.SetState(5443)
				p.Match(SystemVerilogParserCOMMA)
			}
			{
				p.SetState(5444)
				p.constant_expression(0)
			}

			p.SetState(5449)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(5450)
			p.Match(SystemVerilogParserCOLON)
		}
		{
			p.SetState(5451)
			p.Generate_block()
		}

	case SystemVerilogParserKDEFAULT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5453)
			p.Match(SystemVerilogParserKDEFAULT)
		}
		p.SetState(5455)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserCOLON {
			{
				p.SetState(5454)
				p.Match(SystemVerilogParserCOLON)
			}

		}
		{
			p.SetState(5457)
			p.Generate_block()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IGenerate_blockContext is an interface to support dynamic dispatch.
type IGenerate_blockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenerate_blockContext differentiates from other interfaces.
	IsGenerate_blockContext()
}

type Generate_blockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenerate_blockContext() *Generate_blockContext {
	var p = new(Generate_blockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_generate_block
	return p
}

func (*Generate_blockContext) IsGenerate_blockContext() {}

func NewGenerate_blockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Generate_blockContext {
	var p = new(Generate_blockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_generate_block

	return p
}

func (s *Generate_blockContext) GetParser() antlr.Parser { return s.parser }

func (s *Generate_blockContext) AllGenerate_item() []IGenerate_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IGenerate_itemContext)(nil)).Elem())
	var tst = make([]IGenerate_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IGenerate_itemContext)
		}
	}

	return tst
}

func (s *Generate_blockContext) Generate_item(i int) IGenerate_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenerate_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IGenerate_itemContext)
}

func (s *Generate_blockContext) KBEGIN() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKBEGIN, 0)
}

func (s *Generate_blockContext) KEND() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKEND, 0)
}

func (s *Generate_blockContext) AllGenerate_block_identifier() []IGenerate_block_identifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IGenerate_block_identifierContext)(nil)).Elem())
	var tst = make([]IGenerate_block_identifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IGenerate_block_identifierContext)
		}
	}

	return tst
}

func (s *Generate_blockContext) Generate_block_identifier(i int) IGenerate_block_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenerate_block_identifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IGenerate_block_identifierContext)
}

func (s *Generate_blockContext) AllCOLON() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOLON)
}

func (s *Generate_blockContext) COLON(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOLON, i)
}

func (s *Generate_blockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Generate_blockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Generate_blockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterGenerate_block(s)
	}
}

func (s *Generate_blockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitGenerate_block(s)
	}
}

func (p *SystemVerilogParser) Generate_block() (localctx IGenerate_blockContext) {
	this := p
	_ = this

	localctx = NewGenerate_blockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 672, SystemVerilogParserRULE_generate_block)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5482)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 665, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5460)
			p.Generate_item()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(5464)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserSIMPLE_IDENTIFIER {
			{
				p.SetState(5461)
				p.Generate_block_identifier()
			}
			{
				p.SetState(5462)
				p.Match(SystemVerilogParserCOLON)
			}

		}
		{
			p.SetState(5466)
			p.Match(SystemVerilogParserKBEGIN)
		}
		p.SetState(5469)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserCOLON {
			{
				p.SetState(5467)
				p.Match(SystemVerilogParserCOLON)
			}
			{
				p.SetState(5468)
				p.Generate_block_identifier()
			}

		}
		p.SetState(5474)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SystemVerilogParserDERROR)|(1<<SystemVerilogParserDFATAL)|(1<<SystemVerilogParserDINFO)|(1<<SystemVerilogParserDUNIT)|(1<<SystemVerilogParserDWARNING)|(1<<SystemVerilogParserLPS))) != 0) || _la == SystemVerilogParserSEMI || _la == SystemVerilogParserLB || (((_la-94)&-(0x1f+1)) == 0 && ((1<<uint((_la-94)))&((1<<(SystemVerilogParserKALIAS-94))|(1<<(SystemVerilogParserKALWAYS-94))|(1<<(SystemVerilogParserKALWAYS_COMB-94))|(1<<(SystemVerilogParserKALWAYS_FF-94))|(1<<(SystemVerilogParserKALWAYS_LATCH-94))|(1<<(SystemVerilogParserKAND-94))|(1<<(SystemVerilogParserKASSERT-94))|(1<<(SystemVerilogParserKASSIGN-94))|(1<<(SystemVerilogParserKASSUME-94))|(1<<(SystemVerilogParserKAUTOMATIC-94))|(1<<(SystemVerilogParserKBIND-94))|(1<<(SystemVerilogParserKBIT-94))|(1<<(SystemVerilogParserKBUF-94))|(1<<(SystemVerilogParserKBUFIF0-94))|(1<<(SystemVerilogParserKBUFIF1-94))|(1<<(SystemVerilogParserKBYTE-94))|(1<<(SystemVerilogParserKCASE-94))|(1<<(SystemVerilogParserKCHANDLE-94))|(1<<(SystemVerilogParserKCHECKER-94))|(1<<(SystemVerilogParserKCLASS-94))|(1<<(SystemVerilogParserKCLOCKING-94))|(1<<(SystemVerilogParserKCMOS-94))|(1<<(SystemVerilogParserKCONST-94)))) != 0) || (((_la-126)&-(0x1f+1)) == 0 && ((1<<uint((_la-126)))&((1<<(SystemVerilogParserKCONSTRAINT-126))|(1<<(SystemVerilogParserKCOVER-126))|(1<<(SystemVerilogParserKCOVERGROUP-126))|(1<<(SystemVerilogParserKDEFAULT-126))|(1<<(SystemVerilogParserKDEFPARAM-126)))) != 0) || (((_la-159)&-(0x1f+1)) == 0 && ((1<<uint((_la-159)))&((1<<(SystemVerilogParserKENUM-159))|(1<<(SystemVerilogParserKEVENT-159))|(1<<(SystemVerilogParserKEXPORT-159))|(1<<(SystemVerilogParserKEXTERN-159))|(1<<(SystemVerilogParserKFINAL-159))|(1<<(SystemVerilogParserKFOR-159))|(1<<(SystemVerilogParserKFUNCTION-159))|(1<<(SystemVerilogParserKGENERATE-159))|(1<<(SystemVerilogParserKGENVAR-159))|(1<<(SystemVerilogParserKGLOBAL-159))|(1<<(SystemVerilogParserKIF-159))|(1<<(SystemVerilogParserKIMPORT-159))|(1<<(SystemVerilogParserKINITIAL-159)))) != 0) || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SystemVerilogParserKINT-195))|(1<<(SystemVerilogParserKINTEGER-195))|(1<<(SystemVerilogParserKINTERCONNECT-195))|(1<<(SystemVerilogParserKLET-195))|(1<<(SystemVerilogParserKLOCALPARAM-195))|(1<<(SystemVerilogParserKLOGIC-195))|(1<<(SystemVerilogParserKLONGINT-195))|(1<<(SystemVerilogParserKNAND-195))|(1<<(SystemVerilogParserKNETTYPE-195))|(1<<(SystemVerilogParserKNMOS-195))|(1<<(SystemVerilogParserKNOR-195))|(1<<(SystemVerilogParserKNOT-195))|(1<<(SystemVerilogParserKNOTIF0-195)))) != 0) || (((_la-227)&-(0x1f+1)) == 0 && ((1<<uint((_la-227)))&((1<<(SystemVerilogParserKNOTIF1-227))|(1<<(SystemVerilogParserKOR-227))|(1<<(SystemVerilogParserKPARAMETER-227))|(1<<(SystemVerilogParserKPMOS-227))|(1<<(SystemVerilogParserKPROPERTY-227))|(1<<(SystemVerilogParserKPULLDOWN-227))|(1<<(SystemVerilogParserKPULLUP-227))|(1<<(SystemVerilogParserKRAND-227))|(1<<(SystemVerilogParserKRCMOS-227))|(1<<(SystemVerilogParserKREAL-227))|(1<<(SystemVerilogParserKREALTIME-227))|(1<<(SystemVerilogParserKREG-227)))) != 0) || (((_la-262)&-(0x1f+1)) == 0 && ((1<<uint((_la-262)))&((1<<(SystemVerilogParserKRESTRICT-262))|(1<<(SystemVerilogParserKRNMOS-262))|(1<<(SystemVerilogParserKRPMOS-262))|(1<<(SystemVerilogParserKRTRAN-262))|(1<<(SystemVerilogParserKRTRANIF0-262))|(1<<(SystemVerilogParserKRTRANIF1-262))|(1<<(SystemVerilogParserKSEQUENCE-262))|(1<<(SystemVerilogParserKSHORTINT-262))|(1<<(SystemVerilogParserKSHORTREAL-262))|(1<<(SystemVerilogParserKSIGNED-262))|(1<<(SystemVerilogParserKSTATIC-262))|(1<<(SystemVerilogParserKSTRING-262))|(1<<(SystemVerilogParserKSTRUCT-262))|(1<<(SystemVerilogParserKSUPPLY0-262)))) != 0) || (((_la-294)&-(0x1f+1)) == 0 && ((1<<uint((_la-294)))&((1<<(SystemVerilogParserKSUPPLY1-294))|(1<<(SystemVerilogParserKTASK-294))|(1<<(SystemVerilogParserKTIME-294))|(1<<(SystemVerilogParserKTRAN-294))|(1<<(SystemVerilogParserKTRANIF0-294))|(1<<(SystemVerilogParserKTRANIF1-294))|(1<<(SystemVerilogParserKTRI-294))|(1<<(SystemVerilogParserKTRI0-294))|(1<<(SystemVerilogParserKTRI1-294))|(1<<(SystemVerilogParserKTRIAND-294))|(1<<(SystemVerilogParserKTRIOR-294))|(1<<(SystemVerilogParserKTRIREG-294))|(1<<(SystemVerilogParserKTYPE-294))|(1<<(SystemVerilogParserKTYPEDEF-294))|(1<<(SystemVerilogParserKUNION-294))|(1<<(SystemVerilogParserKUNSIGNED-294))|(1<<(SystemVerilogParserKUWIRE-294))|(1<<(SystemVerilogParserKVAR-294)))) != 0) || (((_la-327)&-(0x1f+1)) == 0 && ((1<<uint((_la-327)))&((1<<(SystemVerilogParserKVIRTUAL-327))|(1<<(SystemVerilogParserKWAND-327))|(1<<(SystemVerilogParserKWIRE-327))|(1<<(SystemVerilogParserKWOR-327))|(1<<(SystemVerilogParserKXNOR-327))|(1<<(SystemVerilogParserKXOR-327))|(1<<(SystemVerilogParserSIMPLE_IDENTIFIER-327)))) != 0) {
			{
				p.SetState(5471)
				p.Generate_item()
			}

			p.SetState(5476)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(5477)
			p.Match(SystemVerilogParserKEND)
		}
		p.SetState(5480)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserCOLON {
			{
				p.SetState(5478)
				p.Match(SystemVerilogParserCOLON)
			}
			{
				p.SetState(5479)
				p.Generate_block_identifier()
			}

		}

	}

	return localctx
}

// IGenerate_itemContext is an interface to support dynamic dispatch.
type IGenerate_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenerate_itemContext differentiates from other interfaces.
	IsGenerate_itemContext()
}

type Generate_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenerate_itemContext() *Generate_itemContext {
	var p = new(Generate_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_generate_item
	return p
}

func (*Generate_itemContext) IsGenerate_itemContext() {}

func NewGenerate_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Generate_itemContext {
	var p = new(Generate_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_generate_item

	return p
}

func (s *Generate_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Generate_itemContext) Module_or_generate_item() IModule_or_generate_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_or_generate_itemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_or_generate_itemContext)
}

func (s *Generate_itemContext) Interface_or_generate_item() IInterface_or_generate_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_or_generate_itemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterface_or_generate_itemContext)
}

func (s *Generate_itemContext) Checker_or_generate_item() IChecker_or_generate_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IChecker_or_generate_itemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IChecker_or_generate_itemContext)
}

func (s *Generate_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Generate_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Generate_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterGenerate_item(s)
	}
}

func (s *Generate_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitGenerate_item(s)
	}
}

func (p *SystemVerilogParser) Generate_item() (localctx IGenerate_itemContext) {
	this := p
	_ = this

	localctx = NewGenerate_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 674, SystemVerilogParserRULE_generate_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5487)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 666, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5484)
			p.Module_or_generate_item()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5485)
			p.Interface_or_generate_item()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5486)
			p.Checker_or_generate_item()
		}

	}

	return localctx
}

// IContinuous_assignContext is an interface to support dynamic dispatch.
type IContinuous_assignContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsContinuous_assignContext differentiates from other interfaces.
	IsContinuous_assignContext()
}

type Continuous_assignContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContinuous_assignContext() *Continuous_assignContext {
	var p = new(Continuous_assignContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_continuous_assign
	return p
}

func (*Continuous_assignContext) IsContinuous_assignContext() {}

func NewContinuous_assignContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Continuous_assignContext {
	var p = new(Continuous_assignContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_continuous_assign

	return p
}

func (s *Continuous_assignContext) GetParser() antlr.Parser { return s.parser }

func (s *Continuous_assignContext) KASSIGN() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKASSIGN, 0)
}

func (s *Continuous_assignContext) List_of_net_assignments() IList_of_net_assignmentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_net_assignmentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_net_assignmentsContext)
}

func (s *Continuous_assignContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Continuous_assignContext) List_of_variable_assignments() IList_of_variable_assignmentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_variable_assignmentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_variable_assignmentsContext)
}

func (s *Continuous_assignContext) Drive_strength() IDrive_strengthContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDrive_strengthContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDrive_strengthContext)
}

func (s *Continuous_assignContext) Delay3() IDelay3Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelay3Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelay3Context)
}

func (s *Continuous_assignContext) Delay_control() IDelay_controlContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelay_controlContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelay_controlContext)
}

func (s *Continuous_assignContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Continuous_assignContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Continuous_assignContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterContinuous_assign(s)
	}
}

func (s *Continuous_assignContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitContinuous_assign(s)
	}
}

func (p *SystemVerilogParser) Continuous_assign() (localctx IContinuous_assignContext) {
	this := p
	_ = this

	localctx = NewContinuous_assignContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 676, SystemVerilogParserRULE_continuous_assign)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5489)
		p.Match(SystemVerilogParserKASSIGN)
	}
	p.SetState(5505)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 670, p.GetParserRuleContext()) {
	case 1:
		p.SetState(5491)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserLP {
			{
				p.SetState(5490)
				p.Drive_strength()
			}

		}
		p.SetState(5494)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserP {
			{
				p.SetState(5493)
				p.Delay3()
			}

		}
		{
			p.SetState(5496)
			p.List_of_net_assignments()
		}
		{
			p.SetState(5497)
			p.Match(SystemVerilogParserSEMI)
		}

	case 2:
		p.SetState(5500)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserP {
			{
				p.SetState(5499)
				p.Delay_control()
			}

		}
		{
			p.SetState(5502)
			p.List_of_variable_assignments()
		}
		{
			p.SetState(5503)
			p.Match(SystemVerilogParserSEMI)
		}

	}

	return localctx
}

// IList_of_net_assignmentsContext is an interface to support dynamic dispatch.
type IList_of_net_assignmentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_net_assignmentsContext differentiates from other interfaces.
	IsList_of_net_assignmentsContext()
}

type List_of_net_assignmentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_net_assignmentsContext() *List_of_net_assignmentsContext {
	var p = new(List_of_net_assignmentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_list_of_net_assignments
	return p
}

func (*List_of_net_assignmentsContext) IsList_of_net_assignmentsContext() {}

func NewList_of_net_assignmentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_net_assignmentsContext {
	var p = new(List_of_net_assignmentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_list_of_net_assignments

	return p
}

func (s *List_of_net_assignmentsContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_net_assignmentsContext) AllNet_assignment() []INet_assignmentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INet_assignmentContext)(nil)).Elem())
	var tst = make([]INet_assignmentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INet_assignmentContext)
		}
	}

	return tst
}

func (s *List_of_net_assignmentsContext) Net_assignment(i int) INet_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_assignmentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INet_assignmentContext)
}

func (s *List_of_net_assignmentsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *List_of_net_assignmentsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *List_of_net_assignmentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_net_assignmentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_net_assignmentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterList_of_net_assignments(s)
	}
}

func (s *List_of_net_assignmentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitList_of_net_assignments(s)
	}
}

func (p *SystemVerilogParser) List_of_net_assignments() (localctx IList_of_net_assignmentsContext) {
	this := p
	_ = this

	localctx = NewList_of_net_assignmentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 678, SystemVerilogParserRULE_list_of_net_assignments)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5507)
		p.Net_assignment()
	}
	p.SetState(5512)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserCOMMA {
		{
			p.SetState(5508)
			p.Match(SystemVerilogParserCOMMA)
		}
		{
			p.SetState(5509)
			p.Net_assignment()
		}

		p.SetState(5514)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IList_of_variable_assignmentsContext is an interface to support dynamic dispatch.
type IList_of_variable_assignmentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_variable_assignmentsContext differentiates from other interfaces.
	IsList_of_variable_assignmentsContext()
}

type List_of_variable_assignmentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_variable_assignmentsContext() *List_of_variable_assignmentsContext {
	var p = new(List_of_variable_assignmentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_list_of_variable_assignments
	return p
}

func (*List_of_variable_assignmentsContext) IsList_of_variable_assignmentsContext() {}

func NewList_of_variable_assignmentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_variable_assignmentsContext {
	var p = new(List_of_variable_assignmentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_list_of_variable_assignments

	return p
}

func (s *List_of_variable_assignmentsContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_variable_assignmentsContext) AllVariable_assignment() []IVariable_assignmentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariable_assignmentContext)(nil)).Elem())
	var tst = make([]IVariable_assignmentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariable_assignmentContext)
		}
	}

	return tst
}

func (s *List_of_variable_assignmentsContext) Variable_assignment(i int) IVariable_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_assignmentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariable_assignmentContext)
}

func (s *List_of_variable_assignmentsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *List_of_variable_assignmentsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *List_of_variable_assignmentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_variable_assignmentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_variable_assignmentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterList_of_variable_assignments(s)
	}
}

func (s *List_of_variable_assignmentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitList_of_variable_assignments(s)
	}
}

func (p *SystemVerilogParser) List_of_variable_assignments() (localctx IList_of_variable_assignmentsContext) {
	this := p
	_ = this

	localctx = NewList_of_variable_assignmentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 680, SystemVerilogParserRULE_list_of_variable_assignments)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5515)
		p.Variable_assignment()
	}
	p.SetState(5520)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserCOMMA {
		{
			p.SetState(5516)
			p.Match(SystemVerilogParserCOMMA)
		}
		{
			p.SetState(5517)
			p.Variable_assignment()
		}

		p.SetState(5522)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// INet_aliasContext is an interface to support dynamic dispatch.
type INet_aliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNet_aliasContext differentiates from other interfaces.
	IsNet_aliasContext()
}

type Net_aliasContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNet_aliasContext() *Net_aliasContext {
	var p = new(Net_aliasContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_net_alias
	return p
}

func (*Net_aliasContext) IsNet_aliasContext() {}

func NewNet_aliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Net_aliasContext {
	var p = new(Net_aliasContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_net_alias

	return p
}

func (s *Net_aliasContext) GetParser() antlr.Parser { return s.parser }

func (s *Net_aliasContext) KALIAS() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKALIAS, 0)
}

func (s *Net_aliasContext) AllNet_lvalue() []INet_lvalueContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INet_lvalueContext)(nil)).Elem())
	var tst = make([]INet_lvalueContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INet_lvalueContext)
		}
	}

	return tst
}

func (s *Net_aliasContext) Net_lvalue(i int) INet_lvalueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_lvalueContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INet_lvalueContext)
}

func (s *Net_aliasContext) AllEQ() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserEQ)
}

func (s *Net_aliasContext) EQ(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserEQ, i)
}

func (s *Net_aliasContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Net_aliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Net_aliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Net_aliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterNet_alias(s)
	}
}

func (s *Net_aliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitNet_alias(s)
	}
}

func (p *SystemVerilogParser) Net_alias() (localctx INet_aliasContext) {
	this := p
	_ = this

	localctx = NewNet_aliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 682, SystemVerilogParserRULE_net_alias)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5523)
		p.Match(SystemVerilogParserKALIAS)
	}
	{
		p.SetState(5524)
		p.Net_lvalue()
	}
	{
		p.SetState(5525)
		p.Match(SystemVerilogParserEQ)
	}
	{
		p.SetState(5526)
		p.Net_lvalue()
	}
	p.SetState(5531)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserEQ {
		{
			p.SetState(5527)
			p.Match(SystemVerilogParserEQ)
		}
		{
			p.SetState(5528)
			p.Net_lvalue()
		}

		p.SetState(5533)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(5534)
		p.Match(SystemVerilogParserSEMI)
	}

	return localctx
}

// INet_assignmentContext is an interface to support dynamic dispatch.
type INet_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNet_assignmentContext differentiates from other interfaces.
	IsNet_assignmentContext()
}

type Net_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNet_assignmentContext() *Net_assignmentContext {
	var p = new(Net_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_net_assignment
	return p
}

func (*Net_assignmentContext) IsNet_assignmentContext() {}

func NewNet_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Net_assignmentContext {
	var p = new(Net_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_net_assignment

	return p
}

func (s *Net_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Net_assignmentContext) Net_lvalue() INet_lvalueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_lvalueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INet_lvalueContext)
}

func (s *Net_assignmentContext) EQ() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserEQ, 0)
}

func (s *Net_assignmentContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Net_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Net_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Net_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterNet_assignment(s)
	}
}

func (s *Net_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitNet_assignment(s)
	}
}

func (p *SystemVerilogParser) Net_assignment() (localctx INet_assignmentContext) {
	this := p
	_ = this

	localctx = NewNet_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 684, SystemVerilogParserRULE_net_assignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5536)
		p.Net_lvalue()
	}
	{
		p.SetState(5537)
		p.Match(SystemVerilogParserEQ)
	}
	{
		p.SetState(5538)
		p.expression(0)
	}

	return localctx
}

// IInitial_constructContext is an interface to support dynamic dispatch.
type IInitial_constructContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInitial_constructContext differentiates from other interfaces.
	IsInitial_constructContext()
}

type Initial_constructContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInitial_constructContext() *Initial_constructContext {
	var p = new(Initial_constructContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_initial_construct
	return p
}

func (*Initial_constructContext) IsInitial_constructContext() {}

func NewInitial_constructContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Initial_constructContext {
	var p = new(Initial_constructContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_initial_construct

	return p
}

func (s *Initial_constructContext) GetParser() antlr.Parser { return s.parser }

func (s *Initial_constructContext) KINITIAL() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKINITIAL, 0)
}

func (s *Initial_constructContext) Statement_or_null() IStatement_or_nullContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatement_or_nullContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatement_or_nullContext)
}

func (s *Initial_constructContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Initial_constructContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Initial_constructContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterInitial_construct(s)
	}
}

func (s *Initial_constructContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitInitial_construct(s)
	}
}

func (p *SystemVerilogParser) Initial_construct() (localctx IInitial_constructContext) {
	this := p
	_ = this

	localctx = NewInitial_constructContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 686, SystemVerilogParserRULE_initial_construct)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5540)
		p.Match(SystemVerilogParserKINITIAL)
	}
	{
		p.SetState(5541)
		p.Statement_or_null()
	}

	return localctx
}

// IAlways_constructContext is an interface to support dynamic dispatch.
type IAlways_constructContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlways_constructContext differentiates from other interfaces.
	IsAlways_constructContext()
}

type Always_constructContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlways_constructContext() *Always_constructContext {
	var p = new(Always_constructContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_always_construct
	return p
}

func (*Always_constructContext) IsAlways_constructContext() {}

func NewAlways_constructContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Always_constructContext {
	var p = new(Always_constructContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_always_construct

	return p
}

func (s *Always_constructContext) GetParser() antlr.Parser { return s.parser }

func (s *Always_constructContext) Always_keyword() IAlways_keywordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlways_keywordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlways_keywordContext)
}

func (s *Always_constructContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *Always_constructContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Always_constructContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Always_constructContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterAlways_construct(s)
	}
}

func (s *Always_constructContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitAlways_construct(s)
	}
}

func (p *SystemVerilogParser) Always_construct() (localctx IAlways_constructContext) {
	this := p
	_ = this

	localctx = NewAlways_constructContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 688, SystemVerilogParserRULE_always_construct)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5543)
		p.Always_keyword()
	}
	{
		p.SetState(5544)
		p.Statement()
	}

	return localctx
}

// IAlways_keywordContext is an interface to support dynamic dispatch.
type IAlways_keywordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlways_keywordContext differentiates from other interfaces.
	IsAlways_keywordContext()
}

type Always_keywordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlways_keywordContext() *Always_keywordContext {
	var p = new(Always_keywordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_always_keyword
	return p
}

func (*Always_keywordContext) IsAlways_keywordContext() {}

func NewAlways_keywordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Always_keywordContext {
	var p = new(Always_keywordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_always_keyword

	return p
}

func (s *Always_keywordContext) GetParser() antlr.Parser { return s.parser }

func (s *Always_keywordContext) KALWAYS() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKALWAYS, 0)
}

func (s *Always_keywordContext) KALWAYS_COMB() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKALWAYS_COMB, 0)
}

func (s *Always_keywordContext) KALWAYS_LATCH() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKALWAYS_LATCH, 0)
}

func (s *Always_keywordContext) KALWAYS_FF() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKALWAYS_FF, 0)
}

func (s *Always_keywordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Always_keywordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Always_keywordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterAlways_keyword(s)
	}
}

func (s *Always_keywordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitAlways_keyword(s)
	}
}

func (p *SystemVerilogParser) Always_keyword() (localctx IAlways_keywordContext) {
	this := p
	_ = this

	localctx = NewAlways_keywordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 690, SystemVerilogParserRULE_always_keyword)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5546)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-95)&-(0x1f+1)) == 0 && ((1<<uint((_la-95)))&((1<<(SystemVerilogParserKALWAYS-95))|(1<<(SystemVerilogParserKALWAYS_COMB-95))|(1<<(SystemVerilogParserKALWAYS_FF-95))|(1<<(SystemVerilogParserKALWAYS_LATCH-95)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IFinal_constructContext is an interface to support dynamic dispatch.
type IFinal_constructContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFinal_constructContext differentiates from other interfaces.
	IsFinal_constructContext()
}

type Final_constructContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFinal_constructContext() *Final_constructContext {
	var p = new(Final_constructContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_final_construct
	return p
}

func (*Final_constructContext) IsFinal_constructContext() {}

func NewFinal_constructContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Final_constructContext {
	var p = new(Final_constructContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_final_construct

	return p
}

func (s *Final_constructContext) GetParser() antlr.Parser { return s.parser }

func (s *Final_constructContext) KFINAL() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKFINAL, 0)
}

func (s *Final_constructContext) Function_statement() IFunction_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_statementContext)
}

func (s *Final_constructContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Final_constructContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Final_constructContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterFinal_construct(s)
	}
}

func (s *Final_constructContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitFinal_construct(s)
	}
}

func (p *SystemVerilogParser) Final_construct() (localctx IFinal_constructContext) {
	this := p
	_ = this

	localctx = NewFinal_constructContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 692, SystemVerilogParserRULE_final_construct)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5548)
		p.Match(SystemVerilogParserKFINAL)
	}
	{
		p.SetState(5549)
		p.Function_statement()
	}

	return localctx
}

// IBlocking_assignmentContext is an interface to support dynamic dispatch.
type IBlocking_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlocking_assignmentContext differentiates from other interfaces.
	IsBlocking_assignmentContext()
}

type Blocking_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlocking_assignmentContext() *Blocking_assignmentContext {
	var p = new(Blocking_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_blocking_assignment
	return p
}

func (*Blocking_assignmentContext) IsBlocking_assignmentContext() {}

func NewBlocking_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Blocking_assignmentContext {
	var p = new(Blocking_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_blocking_assignment

	return p
}

func (s *Blocking_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Blocking_assignmentContext) Variable_lvalue() IVariable_lvalueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_lvalueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_lvalueContext)
}

func (s *Blocking_assignmentContext) EQ() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserEQ, 0)
}

func (s *Blocking_assignmentContext) Delay_or_event_control() IDelay_or_event_controlContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelay_or_event_controlContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelay_or_event_controlContext)
}

func (s *Blocking_assignmentContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Blocking_assignmentContext) Nonrange_variable_lvalue() INonrange_variable_lvalueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INonrange_variable_lvalueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INonrange_variable_lvalueContext)
}

func (s *Blocking_assignmentContext) Dynamic_array_new() IDynamic_array_newContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDynamic_array_newContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDynamic_array_newContext)
}

func (s *Blocking_assignmentContext) Hierarchical_variable_identifier() IHierarchical_variable_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_variable_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_variable_identifierContext)
}

func (s *Blocking_assignmentContext) Select_() ISelect_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelect_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelect_Context)
}

func (s *Blocking_assignmentContext) Class_new() IClass_newContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_newContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClass_newContext)
}

func (s *Blocking_assignmentContext) Implicit_class_handle() IImplicit_class_handleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImplicit_class_handleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImplicit_class_handleContext)
}

func (s *Blocking_assignmentContext) DOT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserDOT, 0)
}

func (s *Blocking_assignmentContext) Class_scope() IClass_scopeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_scopeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClass_scopeContext)
}

func (s *Blocking_assignmentContext) Package_scope() IPackage_scopeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackage_scopeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPackage_scopeContext)
}

func (s *Blocking_assignmentContext) Operator_assignment() IOperator_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOperator_assignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOperator_assignmentContext)
}

func (s *Blocking_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Blocking_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Blocking_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterBlocking_assignment(s)
	}
}

func (s *Blocking_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitBlocking_assignment(s)
	}
}

func (p *SystemVerilogParser) Blocking_assignment() (localctx IBlocking_assignmentContext) {
	this := p
	_ = this

	localctx = NewBlocking_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 694, SystemVerilogParserRULE_blocking_assignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5573)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 675, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5551)
			p.Variable_lvalue()
		}
		{
			p.SetState(5552)
			p.Match(SystemVerilogParserEQ)
		}
		{
			p.SetState(5553)
			p.Delay_or_event_control()
		}
		{
			p.SetState(5554)
			p.expression(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5556)
			p.Nonrange_variable_lvalue()
		}
		{
			p.SetState(5557)
			p.Match(SystemVerilogParserEQ)
		}
		{
			p.SetState(5558)
			p.Dynamic_array_new()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(5565)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 674, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5560)
				p.Implicit_class_handle()
			}
			{
				p.SetState(5561)
				p.Match(SystemVerilogParserDOT)
			}

		} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 674, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(5563)
				p.Class_scope()
			}

		} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 674, p.GetParserRuleContext()) == 3 {
			{
				p.SetState(5564)
				p.Package_scope()
			}

		}
		{
			p.SetState(5567)
			p.Hierarchical_variable_identifier()
		}
		{
			p.SetState(5568)
			p.Select_()
		}
		{
			p.SetState(5569)
			p.Match(SystemVerilogParserEQ)
		}
		{
			p.SetState(5570)
			p.Class_new()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5572)
			p.Operator_assignment()
		}

	}

	return localctx
}

// IOperator_assignmentContext is an interface to support dynamic dispatch.
type IOperator_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOperator_assignmentContext differentiates from other interfaces.
	IsOperator_assignmentContext()
}

type Operator_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOperator_assignmentContext() *Operator_assignmentContext {
	var p = new(Operator_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_operator_assignment
	return p
}

func (*Operator_assignmentContext) IsOperator_assignmentContext() {}

func NewOperator_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Operator_assignmentContext {
	var p = new(Operator_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_operator_assignment

	return p
}

func (s *Operator_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Operator_assignmentContext) Variable_lvalue() IVariable_lvalueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_lvalueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_lvalueContext)
}

func (s *Operator_assignmentContext) Assignment_operator() IAssignment_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignment_operatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignment_operatorContext)
}

func (s *Operator_assignmentContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Operator_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Operator_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Operator_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterOperator_assignment(s)
	}
}

func (s *Operator_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitOperator_assignment(s)
	}
}

func (p *SystemVerilogParser) Operator_assignment() (localctx IOperator_assignmentContext) {
	this := p
	_ = this

	localctx = NewOperator_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 696, SystemVerilogParserRULE_operator_assignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5575)
		p.Variable_lvalue()
	}
	{
		p.SetState(5576)
		p.Assignment_operator()
	}
	{
		p.SetState(5577)
		p.expression(0)
	}

	return localctx
}

// IAssignment_operatorContext is an interface to support dynamic dispatch.
type IAssignment_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignment_operatorContext differentiates from other interfaces.
	IsAssignment_operatorContext()
}

type Assignment_operatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignment_operatorContext() *Assignment_operatorContext {
	var p = new(Assignment_operatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_assignment_operator
	return p
}

func (*Assignment_operatorContext) IsAssignment_operatorContext() {}

func NewAssignment_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Assignment_operatorContext {
	var p = new(Assignment_operatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_assignment_operator

	return p
}

func (s *Assignment_operatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Assignment_operatorContext) EQ() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserEQ, 0)
}

func (s *Assignment_operatorContext) PLUSEQ() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserPLUSEQ, 0)
}

func (s *Assignment_operatorContext) MINUSEQ() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserMINUSEQ, 0)
}

func (s *Assignment_operatorContext) SEQ() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEQ, 0)
}

func (s *Assignment_operatorContext) SLASHEQ() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSLASHEQ, 0)
}

func (s *Assignment_operatorContext) PE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserPE, 0)
}

func (s *Assignment_operatorContext) AE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserAE, 0)
}

func (s *Assignment_operatorContext) BAREQ() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserBAREQ, 0)
}

func (s *Assignment_operatorContext) CARETEQ() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCARETEQ, 0)
}

func (s *Assignment_operatorContext) LTLTEQ() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLTLTEQ, 0)
}

func (s *Assignment_operatorContext) GTGTEQ() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserGTGTEQ, 0)
}

func (s *Assignment_operatorContext) LTLTLTEQ() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLTLTLTEQ, 0)
}

func (s *Assignment_operatorContext) GTGTGTEQ() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserGTGTGTEQ, 0)
}

func (s *Assignment_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Assignment_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Assignment_operatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterAssignment_operator(s)
	}
}

func (s *Assignment_operatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitAssignment_operator(s)
	}
}

func (p *SystemVerilogParser) Assignment_operator() (localctx IAssignment_operatorContext) {
	this := p
	_ = this

	localctx = NewAssignment_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 698, SystemVerilogParserRULE_assignment_operator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5579)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SystemVerilogParserPE || _la == SystemVerilogParserAE || (((_la-34)&-(0x1f+1)) == 0 && ((1<<uint((_la-34)))&((1<<(SystemVerilogParserSEQ-34))|(1<<(SystemVerilogParserSLASHEQ-34))|(1<<(SystemVerilogParserCARETEQ-34))|(1<<(SystemVerilogParserBAREQ-34)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(SystemVerilogParserPLUSEQ-70))|(1<<(SystemVerilogParserLTLTLTEQ-70))|(1<<(SystemVerilogParserLTLTEQ-70))|(1<<(SystemVerilogParserEQ-70))|(1<<(SystemVerilogParserMINUSEQ-70))|(1<<(SystemVerilogParserGTGTEQ-70))|(1<<(SystemVerilogParserGTGTGTEQ-70)))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// INonblocking_assignmentContext is an interface to support dynamic dispatch.
type INonblocking_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNonblocking_assignmentContext differentiates from other interfaces.
	IsNonblocking_assignmentContext()
}

type Nonblocking_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNonblocking_assignmentContext() *Nonblocking_assignmentContext {
	var p = new(Nonblocking_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_nonblocking_assignment
	return p
}

func (*Nonblocking_assignmentContext) IsNonblocking_assignmentContext() {}

func NewNonblocking_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Nonblocking_assignmentContext {
	var p = new(Nonblocking_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_nonblocking_assignment

	return p
}

func (s *Nonblocking_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Nonblocking_assignmentContext) Variable_lvalue() IVariable_lvalueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_lvalueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_lvalueContext)
}

func (s *Nonblocking_assignmentContext) LTEQ() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLTEQ, 0)
}

func (s *Nonblocking_assignmentContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Nonblocking_assignmentContext) Delay_or_event_control() IDelay_or_event_controlContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelay_or_event_controlContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelay_or_event_controlContext)
}

func (s *Nonblocking_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Nonblocking_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Nonblocking_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterNonblocking_assignment(s)
	}
}

func (s *Nonblocking_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitNonblocking_assignment(s)
	}
}

func (p *SystemVerilogParser) Nonblocking_assignment() (localctx INonblocking_assignmentContext) {
	this := p
	_ = this

	localctx = NewNonblocking_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 700, SystemVerilogParserRULE_nonblocking_assignment)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5581)
		p.Variable_lvalue()
	}
	{
		p.SetState(5582)
		p.Match(SystemVerilogParserLTEQ)
	}
	p.SetState(5584)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserP || _la == SystemVerilogParserAT || _la == SystemVerilogParserKREPEAT {
		{
			p.SetState(5583)
			p.Delay_or_event_control()
		}

	}
	{
		p.SetState(5586)
		p.expression(0)
	}

	return localctx
}

// IProcedural_continuous_assignmentContext is an interface to support dynamic dispatch.
type IProcedural_continuous_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedural_continuous_assignmentContext differentiates from other interfaces.
	IsProcedural_continuous_assignmentContext()
}

type Procedural_continuous_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedural_continuous_assignmentContext() *Procedural_continuous_assignmentContext {
	var p = new(Procedural_continuous_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_procedural_continuous_assignment
	return p
}

func (*Procedural_continuous_assignmentContext) IsProcedural_continuous_assignmentContext() {}

func NewProcedural_continuous_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Procedural_continuous_assignmentContext {
	var p = new(Procedural_continuous_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_procedural_continuous_assignment

	return p
}

func (s *Procedural_continuous_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Procedural_continuous_assignmentContext) Variable_assignment() IVariable_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_assignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_assignmentContext)
}

func (s *Procedural_continuous_assignmentContext) KASSIGN() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKASSIGN, 0)
}

func (s *Procedural_continuous_assignmentContext) KFORCE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKFORCE, 0)
}

func (s *Procedural_continuous_assignmentContext) Variable_lvalue() IVariable_lvalueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_lvalueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_lvalueContext)
}

func (s *Procedural_continuous_assignmentContext) KDEASSIGN() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKDEASSIGN, 0)
}

func (s *Procedural_continuous_assignmentContext) KRELEASE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKRELEASE, 0)
}

func (s *Procedural_continuous_assignmentContext) Net_assignment() INet_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_assignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INet_assignmentContext)
}

func (s *Procedural_continuous_assignmentContext) Net_lvalue() INet_lvalueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_lvalueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INet_lvalueContext)
}

func (s *Procedural_continuous_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Procedural_continuous_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Procedural_continuous_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterProcedural_continuous_assignment(s)
	}
}

func (s *Procedural_continuous_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitProcedural_continuous_assignment(s)
	}
}

func (p *SystemVerilogParser) Procedural_continuous_assignment() (localctx IProcedural_continuous_assignmentContext) {
	this := p
	_ = this

	localctx = NewProcedural_continuous_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 702, SystemVerilogParserRULE_procedural_continuous_assignment)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5596)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 677, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5588)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SystemVerilogParserKASSIGN || _la == SystemVerilogParserKFORCE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5589)
			p.Variable_assignment()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5590)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SystemVerilogParserKDEASSIGN || _la == SystemVerilogParserKRELEASE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5591)
			p.Variable_lvalue()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5592)
			p.Match(SystemVerilogParserKFORCE)
		}
		{
			p.SetState(5593)
			p.Net_assignment()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5594)
			p.Match(SystemVerilogParserKRELEASE)
		}
		{
			p.SetState(5595)
			p.Net_lvalue()
		}

	}

	return localctx
}

// IVariable_assignmentContext is an interface to support dynamic dispatch.
type IVariable_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariable_assignmentContext differentiates from other interfaces.
	IsVariable_assignmentContext()
}

type Variable_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariable_assignmentContext() *Variable_assignmentContext {
	var p = new(Variable_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_variable_assignment
	return p
}

func (*Variable_assignmentContext) IsVariable_assignmentContext() {}

func NewVariable_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Variable_assignmentContext {
	var p = new(Variable_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_variable_assignment

	return p
}

func (s *Variable_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Variable_assignmentContext) Variable_lvalue() IVariable_lvalueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_lvalueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_lvalueContext)
}

func (s *Variable_assignmentContext) EQ() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserEQ, 0)
}

func (s *Variable_assignmentContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Variable_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Variable_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Variable_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterVariable_assignment(s)
	}
}

func (s *Variable_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitVariable_assignment(s)
	}
}

func (p *SystemVerilogParser) Variable_assignment() (localctx IVariable_assignmentContext) {
	this := p
	_ = this

	localctx = NewVariable_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 704, SystemVerilogParserRULE_variable_assignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5598)
		p.Variable_lvalue()
	}
	{
		p.SetState(5599)
		p.Match(SystemVerilogParserEQ)
	}
	{
		p.SetState(5600)
		p.expression(0)
	}

	return localctx
}

// IAction_blockContext is an interface to support dynamic dispatch.
type IAction_blockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAction_blockContext differentiates from other interfaces.
	IsAction_blockContext()
}

type Action_blockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAction_blockContext() *Action_blockContext {
	var p = new(Action_blockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_action_block
	return p
}

func (*Action_blockContext) IsAction_blockContext() {}

func NewAction_blockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Action_blockContext {
	var p = new(Action_blockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_action_block

	return p
}

func (s *Action_blockContext) GetParser() antlr.Parser { return s.parser }

func (s *Action_blockContext) Statement_or_null() IStatement_or_nullContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatement_or_nullContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatement_or_nullContext)
}

func (s *Action_blockContext) KELSE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKELSE, 0)
}

func (s *Action_blockContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *Action_blockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Action_blockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Action_blockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterAction_block(s)
	}
}

func (s *Action_blockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitAction_block(s)
	}
}

func (p *SystemVerilogParser) Action_block() (localctx IAction_blockContext) {
	this := p
	_ = this

	localctx = NewAction_blockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 706, SystemVerilogParserRULE_action_block)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5606)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 679, p.GetParserRuleContext()) == 1 {
		p.SetState(5603)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SystemVerilogParserMINUSMINS)|(1<<SystemVerilogParserP)|(1<<SystemVerilogParserPP)|(1<<SystemVerilogParserDOLLAR)|(1<<SystemVerilogParserDERROR)|(1<<SystemVerilogParserDFATAL)|(1<<SystemVerilogParserDINFO)|(1<<SystemVerilogParserDROOT)|(1<<SystemVerilogParserDUNIT)|(1<<SystemVerilogParserDWARNING)|(1<<SystemVerilogParserLP)|(1<<SystemVerilogParserLPS))) != 0) || (((_la-48)&-(0x1f+1)) == 0 && ((1<<uint((_la-48)))&((1<<(SystemVerilogParserAT-48))|(1<<(SystemVerilogParserQUOTE-48))|(1<<(SystemVerilogParserLC-48))|(1<<(SystemVerilogParserPLUSPLUS-48)))) != 0) || (((_la-85)&-(0x1f+1)) == 0 && ((1<<uint((_la-85)))&((1<<(SystemVerilogParserARROW-85))|(1<<(SystemVerilogParserMINUSGTGT-85))|(1<<(SystemVerilogParserKASSERT-85))|(1<<(SystemVerilogParserKASSIGN-85))|(1<<(SystemVerilogParserKASSUME-85))|(1<<(SystemVerilogParserKBEGIN-85))|(1<<(SystemVerilogParserKBREAK-85))|(1<<(SystemVerilogParserKBYTE-85))|(1<<(SystemVerilogParserKCASE-85))|(1<<(SystemVerilogParserKCASEX-85)))) != 0) || (((_la-117)&-(0x1f+1)) == 0 && ((1<<uint((_la-117)))&((1<<(SystemVerilogParserKCASEZ-117))|(1<<(SystemVerilogParserKCONTINUE-117))|(1<<(SystemVerilogParserKCOVER-117))|(1<<(SystemVerilogParserKDEASSIGN-117))|(1<<(SystemVerilogParserKDISABLE-117))|(1<<(SystemVerilogParserKDO-117)))) != 0) || (((_la-162)&-(0x1f+1)) == 0 && ((1<<uint((_la-162)))&((1<<(SystemVerilogParserKEXPECT-162))|(1<<(SystemVerilogParserKFOR-162))|(1<<(SystemVerilogParserKFORCE-162))|(1<<(SystemVerilogParserKFOREACH-162))|(1<<(SystemVerilogParserKFOREVER-162))|(1<<(SystemVerilogParserKFORK-162))|(1<<(SystemVerilogParserKIF-162)))) != 0) || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SystemVerilogParserKINT-195))|(1<<(SystemVerilogParserKINTEGER-195))|(1<<(SystemVerilogParserKLOCAL-195))|(1<<(SystemVerilogParserKLONGINT-195)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(SystemVerilogParserKNULL-228))|(1<<(SystemVerilogParserKPRIORITY-228))|(1<<(SystemVerilogParserKRANDCASE-228))|(1<<(SystemVerilogParserKRANDOMIZE-228))|(1<<(SystemVerilogParserKRANDSEQUENCE-228)))) != 0) || (((_la-260)&-(0x1f+1)) == 0 && ((1<<uint((_la-260)))&((1<<(SystemVerilogParserKRELEASE-260))|(1<<(SystemVerilogParserKREPEAT-260))|(1<<(SystemVerilogParserKRESTRICT-260))|(1<<(SystemVerilogParserKRETURN-260))|(1<<(SystemVerilogParserKSHORTINT-260))|(1<<(SystemVerilogParserKSTD-260)))) != 0) || (((_la-292)&-(0x1f+1)) == 0 && ((1<<uint((_la-292)))&((1<<(SystemVerilogParserKSUPER-292))|(1<<(SystemVerilogParserKTHIS-292))|(1<<(SystemVerilogParserKTIME-292))|(1<<(SystemVerilogParserKTYPE-292))|(1<<(SystemVerilogParserKUNIQUE-292))|(1<<(SystemVerilogParserKUNIQUE0-292)))) != 0) || (((_la-328)&-(0x1f+1)) == 0 && ((1<<uint((_la-328)))&((1<<(SystemVerilogParserKVOID-328))|(1<<(SystemVerilogParserKWAIT-328))|(1<<(SystemVerilogParserKWAIT_ORDER-328))|(1<<(SystemVerilogParserKWHILE-328))|(1<<(SystemVerilogParserTIME_LITERAL-328))|(1<<(SystemVerilogParserDECIMAL_NUMBER-328))|(1<<(SystemVerilogParserBINARY_NUMBER-328))|(1<<(SystemVerilogParserOCTAL_NUMBER-328))|(1<<(SystemVerilogParserHEX_NUMBER-328))|(1<<(SystemVerilogParserREAL_NUMBER-328))|(1<<(SystemVerilogParserUNSIGNED_NUMBER-328))|(1<<(SystemVerilogParserSTRING_LITERAL-328))|(1<<(SystemVerilogParserSIMPLE_IDENTIFIER-328))|(1<<(SystemVerilogParserSYSTEM_TF_IDENTIFIER-328)))) != 0) {
			{
				p.SetState(5602)
				p.Statement()
			}

		}
		{
			p.SetState(5605)
			p.Match(SystemVerilogParserKELSE)
		}

	}
	{
		p.SetState(5608)
		p.Statement_or_null()
	}

	return localctx
}

// ISeq_blockContext is an interface to support dynamic dispatch.
type ISeq_blockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSeq_blockContext differentiates from other interfaces.
	IsSeq_blockContext()
}

type Seq_blockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySeq_blockContext() *Seq_blockContext {
	var p = new(Seq_blockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_seq_block
	return p
}

func (*Seq_blockContext) IsSeq_blockContext() {}

func NewSeq_blockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Seq_blockContext {
	var p = new(Seq_blockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_seq_block

	return p
}

func (s *Seq_blockContext) GetParser() antlr.Parser { return s.parser }

func (s *Seq_blockContext) KBEGIN() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKBEGIN, 0)
}

func (s *Seq_blockContext) KEND() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKEND, 0)
}

func (s *Seq_blockContext) AllCOLON() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOLON)
}

func (s *Seq_blockContext) COLON(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOLON, i)
}

func (s *Seq_blockContext) AllBlock_identifier() []IBlock_identifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBlock_identifierContext)(nil)).Elem())
	var tst = make([]IBlock_identifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBlock_identifierContext)
		}
	}

	return tst
}

func (s *Seq_blockContext) Block_identifier(i int) IBlock_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_identifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBlock_identifierContext)
}

func (s *Seq_blockContext) AllBlock_item_declaration() []IBlock_item_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBlock_item_declarationContext)(nil)).Elem())
	var tst = make([]IBlock_item_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBlock_item_declarationContext)
		}
	}

	return tst
}

func (s *Seq_blockContext) Block_item_declaration(i int) IBlock_item_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_item_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBlock_item_declarationContext)
}

func (s *Seq_blockContext) AllStatement_or_null() []IStatement_or_nullContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatement_or_nullContext)(nil)).Elem())
	var tst = make([]IStatement_or_nullContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatement_or_nullContext)
		}
	}

	return tst
}

func (s *Seq_blockContext) Statement_or_null(i int) IStatement_or_nullContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatement_or_nullContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatement_or_nullContext)
}

func (s *Seq_blockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Seq_blockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Seq_blockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterSeq_block(s)
	}
}

func (s *Seq_blockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitSeq_block(s)
	}
}

func (p *SystemVerilogParser) Seq_block() (localctx ISeq_blockContext) {
	this := p
	_ = this

	localctx = NewSeq_blockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 708, SystemVerilogParserRULE_seq_block)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5610)
		p.Match(SystemVerilogParserKBEGIN)
	}
	p.SetState(5613)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserCOLON {
		{
			p.SetState(5611)
			p.Match(SystemVerilogParserCOLON)
		}
		{
			p.SetState(5612)
			p.Block_identifier()
		}

	}
	p.SetState(5618)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 681, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(5615)
				p.Block_item_declaration()
			}

		}
		p.SetState(5620)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 681, p.GetParserRuleContext())
	}
	p.SetState(5624)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SystemVerilogParserMINUSMINS)|(1<<SystemVerilogParserP)|(1<<SystemVerilogParserPP)|(1<<SystemVerilogParserDOLLAR)|(1<<SystemVerilogParserDERROR)|(1<<SystemVerilogParserDFATAL)|(1<<SystemVerilogParserDINFO)|(1<<SystemVerilogParserDROOT)|(1<<SystemVerilogParserDUNIT)|(1<<SystemVerilogParserDWARNING)|(1<<SystemVerilogParserLP)|(1<<SystemVerilogParserLPS))) != 0) || (((_la-46)&-(0x1f+1)) == 0 && ((1<<uint((_la-46)))&((1<<(SystemVerilogParserSEMI-46))|(1<<(SystemVerilogParserAT-46))|(1<<(SystemVerilogParserQUOTE-46))|(1<<(SystemVerilogParserLC-46))|(1<<(SystemVerilogParserPLUSPLUS-46)))) != 0) || (((_la-85)&-(0x1f+1)) == 0 && ((1<<uint((_la-85)))&((1<<(SystemVerilogParserARROW-85))|(1<<(SystemVerilogParserMINUSGTGT-85))|(1<<(SystemVerilogParserKASSERT-85))|(1<<(SystemVerilogParserKASSIGN-85))|(1<<(SystemVerilogParserKASSUME-85))|(1<<(SystemVerilogParserKBEGIN-85))|(1<<(SystemVerilogParserKBREAK-85))|(1<<(SystemVerilogParserKBYTE-85))|(1<<(SystemVerilogParserKCASE-85))|(1<<(SystemVerilogParserKCASEX-85)))) != 0) || (((_la-117)&-(0x1f+1)) == 0 && ((1<<uint((_la-117)))&((1<<(SystemVerilogParserKCASEZ-117))|(1<<(SystemVerilogParserKCONTINUE-117))|(1<<(SystemVerilogParserKCOVER-117))|(1<<(SystemVerilogParserKDEASSIGN-117))|(1<<(SystemVerilogParserKDISABLE-117))|(1<<(SystemVerilogParserKDO-117)))) != 0) || (((_la-162)&-(0x1f+1)) == 0 && ((1<<uint((_la-162)))&((1<<(SystemVerilogParserKEXPECT-162))|(1<<(SystemVerilogParserKFOR-162))|(1<<(SystemVerilogParserKFORCE-162))|(1<<(SystemVerilogParserKFOREACH-162))|(1<<(SystemVerilogParserKFOREVER-162))|(1<<(SystemVerilogParserKFORK-162))|(1<<(SystemVerilogParserKIF-162)))) != 0) || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SystemVerilogParserKINT-195))|(1<<(SystemVerilogParserKINTEGER-195))|(1<<(SystemVerilogParserKLOCAL-195))|(1<<(SystemVerilogParserKLONGINT-195)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(SystemVerilogParserKNULL-228))|(1<<(SystemVerilogParserKPRIORITY-228))|(1<<(SystemVerilogParserKRANDCASE-228))|(1<<(SystemVerilogParserKRANDOMIZE-228))|(1<<(SystemVerilogParserKRANDSEQUENCE-228)))) != 0) || (((_la-260)&-(0x1f+1)) == 0 && ((1<<uint((_la-260)))&((1<<(SystemVerilogParserKRELEASE-260))|(1<<(SystemVerilogParserKREPEAT-260))|(1<<(SystemVerilogParserKRESTRICT-260))|(1<<(SystemVerilogParserKRETURN-260))|(1<<(SystemVerilogParserKSHORTINT-260))|(1<<(SystemVerilogParserKSTD-260)))) != 0) || (((_la-292)&-(0x1f+1)) == 0 && ((1<<uint((_la-292)))&((1<<(SystemVerilogParserKSUPER-292))|(1<<(SystemVerilogParserKTHIS-292))|(1<<(SystemVerilogParserKTIME-292))|(1<<(SystemVerilogParserKTYPE-292))|(1<<(SystemVerilogParserKUNIQUE-292))|(1<<(SystemVerilogParserKUNIQUE0-292)))) != 0) || (((_la-328)&-(0x1f+1)) == 0 && ((1<<uint((_la-328)))&((1<<(SystemVerilogParserKVOID-328))|(1<<(SystemVerilogParserKWAIT-328))|(1<<(SystemVerilogParserKWAIT_ORDER-328))|(1<<(SystemVerilogParserKWHILE-328))|(1<<(SystemVerilogParserTIME_LITERAL-328))|(1<<(SystemVerilogParserDECIMAL_NUMBER-328))|(1<<(SystemVerilogParserBINARY_NUMBER-328))|(1<<(SystemVerilogParserOCTAL_NUMBER-328))|(1<<(SystemVerilogParserHEX_NUMBER-328))|(1<<(SystemVerilogParserREAL_NUMBER-328))|(1<<(SystemVerilogParserUNSIGNED_NUMBER-328))|(1<<(SystemVerilogParserSTRING_LITERAL-328))|(1<<(SystemVerilogParserSIMPLE_IDENTIFIER-328))|(1<<(SystemVerilogParserSYSTEM_TF_IDENTIFIER-328)))) != 0) {
		{
			p.SetState(5621)
			p.Statement_or_null()
		}

		p.SetState(5626)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(5627)
		p.Match(SystemVerilogParserKEND)
	}
	p.SetState(5630)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserCOLON {
		{
			p.SetState(5628)
			p.Match(SystemVerilogParserCOLON)
		}
		{
			p.SetState(5629)
			p.Block_identifier()
		}

	}

	return localctx
}

// IPar_blockContext is an interface to support dynamic dispatch.
type IPar_blockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPar_blockContext differentiates from other interfaces.
	IsPar_blockContext()
}

type Par_blockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPar_blockContext() *Par_blockContext {
	var p = new(Par_blockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_par_block
	return p
}

func (*Par_blockContext) IsPar_blockContext() {}

func NewPar_blockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Par_blockContext {
	var p = new(Par_blockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_par_block

	return p
}

func (s *Par_blockContext) GetParser() antlr.Parser { return s.parser }

func (s *Par_blockContext) KFORK() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKFORK, 0)
}

func (s *Par_blockContext) Join_keyword() IJoin_keywordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJoin_keywordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IJoin_keywordContext)
}

func (s *Par_blockContext) AllCOLON() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOLON)
}

func (s *Par_blockContext) COLON(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOLON, i)
}

func (s *Par_blockContext) AllBlock_identifier() []IBlock_identifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBlock_identifierContext)(nil)).Elem())
	var tst = make([]IBlock_identifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBlock_identifierContext)
		}
	}

	return tst
}

func (s *Par_blockContext) Block_identifier(i int) IBlock_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_identifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBlock_identifierContext)
}

func (s *Par_blockContext) AllBlock_item_declaration() []IBlock_item_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBlock_item_declarationContext)(nil)).Elem())
	var tst = make([]IBlock_item_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBlock_item_declarationContext)
		}
	}

	return tst
}

func (s *Par_blockContext) Block_item_declaration(i int) IBlock_item_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_item_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBlock_item_declarationContext)
}

func (s *Par_blockContext) AllStatement_or_null() []IStatement_or_nullContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatement_or_nullContext)(nil)).Elem())
	var tst = make([]IStatement_or_nullContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatement_or_nullContext)
		}
	}

	return tst
}

func (s *Par_blockContext) Statement_or_null(i int) IStatement_or_nullContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatement_or_nullContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatement_or_nullContext)
}

func (s *Par_blockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Par_blockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Par_blockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterPar_block(s)
	}
}

func (s *Par_blockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitPar_block(s)
	}
}

func (p *SystemVerilogParser) Par_block() (localctx IPar_blockContext) {
	this := p
	_ = this

	localctx = NewPar_blockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 710, SystemVerilogParserRULE_par_block)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5632)
		p.Match(SystemVerilogParserKFORK)
	}
	p.SetState(5635)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserCOLON {
		{
			p.SetState(5633)
			p.Match(SystemVerilogParserCOLON)
		}
		{
			p.SetState(5634)
			p.Block_identifier()
		}

	}
	p.SetState(5640)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 685, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(5637)
				p.Block_item_declaration()
			}

		}
		p.SetState(5642)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 685, p.GetParserRuleContext())
	}
	p.SetState(5646)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SystemVerilogParserMINUSMINS)|(1<<SystemVerilogParserP)|(1<<SystemVerilogParserPP)|(1<<SystemVerilogParserDOLLAR)|(1<<SystemVerilogParserDERROR)|(1<<SystemVerilogParserDFATAL)|(1<<SystemVerilogParserDINFO)|(1<<SystemVerilogParserDROOT)|(1<<SystemVerilogParserDUNIT)|(1<<SystemVerilogParserDWARNING)|(1<<SystemVerilogParserLP)|(1<<SystemVerilogParserLPS))) != 0) || (((_la-46)&-(0x1f+1)) == 0 && ((1<<uint((_la-46)))&((1<<(SystemVerilogParserSEMI-46))|(1<<(SystemVerilogParserAT-46))|(1<<(SystemVerilogParserQUOTE-46))|(1<<(SystemVerilogParserLC-46))|(1<<(SystemVerilogParserPLUSPLUS-46)))) != 0) || (((_la-85)&-(0x1f+1)) == 0 && ((1<<uint((_la-85)))&((1<<(SystemVerilogParserARROW-85))|(1<<(SystemVerilogParserMINUSGTGT-85))|(1<<(SystemVerilogParserKASSERT-85))|(1<<(SystemVerilogParserKASSIGN-85))|(1<<(SystemVerilogParserKASSUME-85))|(1<<(SystemVerilogParserKBEGIN-85))|(1<<(SystemVerilogParserKBREAK-85))|(1<<(SystemVerilogParserKBYTE-85))|(1<<(SystemVerilogParserKCASE-85))|(1<<(SystemVerilogParserKCASEX-85)))) != 0) || (((_la-117)&-(0x1f+1)) == 0 && ((1<<uint((_la-117)))&((1<<(SystemVerilogParserKCASEZ-117))|(1<<(SystemVerilogParserKCONTINUE-117))|(1<<(SystemVerilogParserKCOVER-117))|(1<<(SystemVerilogParserKDEASSIGN-117))|(1<<(SystemVerilogParserKDISABLE-117))|(1<<(SystemVerilogParserKDO-117)))) != 0) || (((_la-162)&-(0x1f+1)) == 0 && ((1<<uint((_la-162)))&((1<<(SystemVerilogParserKEXPECT-162))|(1<<(SystemVerilogParserKFOR-162))|(1<<(SystemVerilogParserKFORCE-162))|(1<<(SystemVerilogParserKFOREACH-162))|(1<<(SystemVerilogParserKFOREVER-162))|(1<<(SystemVerilogParserKFORK-162))|(1<<(SystemVerilogParserKIF-162)))) != 0) || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SystemVerilogParserKINT-195))|(1<<(SystemVerilogParserKINTEGER-195))|(1<<(SystemVerilogParserKLOCAL-195))|(1<<(SystemVerilogParserKLONGINT-195)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(SystemVerilogParserKNULL-228))|(1<<(SystemVerilogParserKPRIORITY-228))|(1<<(SystemVerilogParserKRANDCASE-228))|(1<<(SystemVerilogParserKRANDOMIZE-228))|(1<<(SystemVerilogParserKRANDSEQUENCE-228)))) != 0) || (((_la-260)&-(0x1f+1)) == 0 && ((1<<uint((_la-260)))&((1<<(SystemVerilogParserKRELEASE-260))|(1<<(SystemVerilogParserKREPEAT-260))|(1<<(SystemVerilogParserKRESTRICT-260))|(1<<(SystemVerilogParserKRETURN-260))|(1<<(SystemVerilogParserKSHORTINT-260))|(1<<(SystemVerilogParserKSTD-260)))) != 0) || (((_la-292)&-(0x1f+1)) == 0 && ((1<<uint((_la-292)))&((1<<(SystemVerilogParserKSUPER-292))|(1<<(SystemVerilogParserKTHIS-292))|(1<<(SystemVerilogParserKTIME-292))|(1<<(SystemVerilogParserKTYPE-292))|(1<<(SystemVerilogParserKUNIQUE-292))|(1<<(SystemVerilogParserKUNIQUE0-292)))) != 0) || (((_la-328)&-(0x1f+1)) == 0 && ((1<<uint((_la-328)))&((1<<(SystemVerilogParserKVOID-328))|(1<<(SystemVerilogParserKWAIT-328))|(1<<(SystemVerilogParserKWAIT_ORDER-328))|(1<<(SystemVerilogParserKWHILE-328))|(1<<(SystemVerilogParserTIME_LITERAL-328))|(1<<(SystemVerilogParserDECIMAL_NUMBER-328))|(1<<(SystemVerilogParserBINARY_NUMBER-328))|(1<<(SystemVerilogParserOCTAL_NUMBER-328))|(1<<(SystemVerilogParserHEX_NUMBER-328))|(1<<(SystemVerilogParserREAL_NUMBER-328))|(1<<(SystemVerilogParserUNSIGNED_NUMBER-328))|(1<<(SystemVerilogParserSTRING_LITERAL-328))|(1<<(SystemVerilogParserSIMPLE_IDENTIFIER-328))|(1<<(SystemVerilogParserSYSTEM_TF_IDENTIFIER-328)))) != 0) {
		{
			p.SetState(5643)
			p.Statement_or_null()
		}

		p.SetState(5648)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(5649)
		p.Join_keyword()
	}
	p.SetState(5652)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserCOLON {
		{
			p.SetState(5650)
			p.Match(SystemVerilogParserCOLON)
		}
		{
			p.SetState(5651)
			p.Block_identifier()
		}

	}

	return localctx
}

// IJoin_keywordContext is an interface to support dynamic dispatch.
type IJoin_keywordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsJoin_keywordContext differentiates from other interfaces.
	IsJoin_keywordContext()
}

type Join_keywordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoin_keywordContext() *Join_keywordContext {
	var p = new(Join_keywordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_join_keyword
	return p
}

func (*Join_keywordContext) IsJoin_keywordContext() {}

func NewJoin_keywordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Join_keywordContext {
	var p = new(Join_keywordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_join_keyword

	return p
}

func (s *Join_keywordContext) GetParser() antlr.Parser { return s.parser }

func (s *Join_keywordContext) KJOIN() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKJOIN, 0)
}

func (s *Join_keywordContext) KJOIN_ANY() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKJOIN_ANY, 0)
}

func (s *Join_keywordContext) KJOIN_NONE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKJOIN_NONE, 0)
}

func (s *Join_keywordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Join_keywordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Join_keywordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterJoin_keyword(s)
	}
}

func (s *Join_keywordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitJoin_keyword(s)
	}
}

func (p *SystemVerilogParser) Join_keyword() (localctx IJoin_keywordContext) {
	this := p
	_ = this

	localctx = NewJoin_keywordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 712, SystemVerilogParserRULE_join_keyword)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5654)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-200)&-(0x1f+1)) == 0 && ((1<<uint((_la-200)))&((1<<(SystemVerilogParserKJOIN-200))|(1<<(SystemVerilogParserKJOIN_ANY-200))|(1<<(SystemVerilogParserKJOIN_NONE-200)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IStatement_or_nullContext is an interface to support dynamic dispatch.
type IStatement_or_nullContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatement_or_nullContext differentiates from other interfaces.
	IsStatement_or_nullContext()
}

type Statement_or_nullContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatement_or_nullContext() *Statement_or_nullContext {
	var p = new(Statement_or_nullContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_statement_or_null
	return p
}

func (*Statement_or_nullContext) IsStatement_or_nullContext() {}

func NewStatement_or_nullContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Statement_or_nullContext {
	var p = new(Statement_or_nullContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_statement_or_null

	return p
}

func (s *Statement_or_nullContext) GetParser() antlr.Parser { return s.parser }

func (s *Statement_or_nullContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *Statement_or_nullContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Statement_or_nullContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Statement_or_nullContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Statement_or_nullContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Statement_or_nullContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Statement_or_nullContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterStatement_or_null(s)
	}
}

func (s *Statement_or_nullContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitStatement_or_null(s)
	}
}

func (p *SystemVerilogParser) Statement_or_null() (localctx IStatement_or_nullContext) {
	this := p
	_ = this

	localctx = NewStatement_or_nullContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 714, SystemVerilogParserRULE_statement_or_null)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5664)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 689, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5656)
			p.Statement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(5660)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserLPS {
			{
				p.SetState(5657)
				p.Attribute_instance()
			}

			p.SetState(5662)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(5663)
			p.Match(SystemVerilogParserSEMI)
		}

	}

	return localctx
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_statement
	return p
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) Statement_item() IStatement_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatement_itemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatement_itemContext)
}

func (s *StatementContext) Block_identifier() IBlock_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlock_identifierContext)
}

func (s *StatementContext) COLON() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOLON, 0)
}

func (s *StatementContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *StatementContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterStatement(s)
	}
}

func (s *StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitStatement(s)
	}
}

func (p *SystemVerilogParser) Statement() (localctx IStatementContext) {
	this := p
	_ = this

	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 716, SystemVerilogParserRULE_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5669)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 690, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5666)
			p.Block_identifier()
		}
		{
			p.SetState(5667)
			p.Match(SystemVerilogParserCOLON)
		}

	}
	p.SetState(5674)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserLPS {
		{
			p.SetState(5671)
			p.Attribute_instance()
		}

		p.SetState(5676)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(5677)
		p.Statement_item()
	}

	return localctx
}

// IStatement_itemContext is an interface to support dynamic dispatch.
type IStatement_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatement_itemContext differentiates from other interfaces.
	IsStatement_itemContext()
}

type Statement_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatement_itemContext() *Statement_itemContext {
	var p = new(Statement_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_statement_item
	return p
}

func (*Statement_itemContext) IsStatement_itemContext() {}

func NewStatement_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Statement_itemContext {
	var p = new(Statement_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_statement_item

	return p
}

func (s *Statement_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Statement_itemContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Statement_itemContext) Blocking_assignment() IBlocking_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlocking_assignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlocking_assignmentContext)
}

func (s *Statement_itemContext) Nonblocking_assignment() INonblocking_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INonblocking_assignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INonblocking_assignmentContext)
}

func (s *Statement_itemContext) Procedural_continuous_assignment() IProcedural_continuous_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedural_continuous_assignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedural_continuous_assignmentContext)
}

func (s *Statement_itemContext) Inc_or_dec_expression() IInc_or_dec_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInc_or_dec_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInc_or_dec_expressionContext)
}

func (s *Statement_itemContext) Clocking_drive() IClocking_driveContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClocking_driveContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClocking_driveContext)
}

func (s *Statement_itemContext) Case_statement() ICase_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICase_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICase_statementContext)
}

func (s *Statement_itemContext) Conditional_statement() IConditional_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditional_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditional_statementContext)
}

func (s *Statement_itemContext) Subroutine_call_statement() ISubroutine_call_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubroutine_call_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubroutine_call_statementContext)
}

func (s *Statement_itemContext) Disable_statement() IDisable_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDisable_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDisable_statementContext)
}

func (s *Statement_itemContext) Event_trigger() IEvent_triggerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvent_triggerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEvent_triggerContext)
}

func (s *Statement_itemContext) Loop_statement() ILoop_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILoop_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILoop_statementContext)
}

func (s *Statement_itemContext) Jump_statement() IJump_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJump_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IJump_statementContext)
}

func (s *Statement_itemContext) Par_block() IPar_blockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPar_blockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPar_blockContext)
}

func (s *Statement_itemContext) Procedural_timing_control_statement() IProcedural_timing_control_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedural_timing_control_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedural_timing_control_statementContext)
}

func (s *Statement_itemContext) Seq_block() ISeq_blockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISeq_blockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISeq_blockContext)
}

func (s *Statement_itemContext) Wait_statement() IWait_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWait_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWait_statementContext)
}

func (s *Statement_itemContext) Procedural_assertion_statement() IProcedural_assertion_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedural_assertion_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedural_assertion_statementContext)
}

func (s *Statement_itemContext) Randsequence_statement() IRandsequence_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRandsequence_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRandsequence_statementContext)
}

func (s *Statement_itemContext) Randcase_statement() IRandcase_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRandcase_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRandcase_statementContext)
}

func (s *Statement_itemContext) Expect_property_statement() IExpect_property_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpect_property_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpect_property_statementContext)
}

func (s *Statement_itemContext) Elaboration_system_task() IElaboration_system_taskContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElaboration_system_taskContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElaboration_system_taskContext)
}

func (s *Statement_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Statement_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Statement_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterStatement_item(s)
	}
}

func (s *Statement_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitStatement_item(s)
	}
}

func (p *SystemVerilogParser) Statement_item() (localctx IStatement_itemContext) {
	this := p
	_ = this

	localctx = NewStatement_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 718, SystemVerilogParserRULE_statement_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5704)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 693, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(5684)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 692, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(5679)
				p.Blocking_assignment()
			}

		case 2:
			{
				p.SetState(5680)
				p.Nonblocking_assignment()
			}

		case 3:
			{
				p.SetState(5681)
				p.Procedural_continuous_assignment()
			}

		case 4:
			{
				p.SetState(5682)
				p.Inc_or_dec_expression()
			}

		case 5:
			{
				p.SetState(5683)
				p.Clocking_drive()
			}

		}
		{
			p.SetState(5686)
			p.Match(SystemVerilogParserSEMI)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5688)
			p.Case_statement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5689)
			p.Conditional_statement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5690)
			p.Subroutine_call_statement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5691)
			p.Disable_statement()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(5692)
			p.Event_trigger()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(5693)
			p.Loop_statement()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(5694)
			p.Jump_statement()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(5695)
			p.Par_block()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(5696)
			p.Procedural_timing_control_statement()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(5697)
			p.Seq_block()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(5698)
			p.Wait_statement()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(5699)
			p.Procedural_assertion_statement()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(5700)
			p.Randsequence_statement()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(5701)
			p.Randcase_statement()
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(5702)
			p.Expect_property_statement()
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(5703)
			p.Elaboration_system_task()
		}

	}

	return localctx
}

// IFunction_statementContext is an interface to support dynamic dispatch.
type IFunction_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_statementContext differentiates from other interfaces.
	IsFunction_statementContext()
}

type Function_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_statementContext() *Function_statementContext {
	var p = new(Function_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_function_statement
	return p
}

func (*Function_statementContext) IsFunction_statementContext() {}

func NewFunction_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_statementContext {
	var p = new(Function_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_function_statement

	return p
}

func (s *Function_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_statementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *Function_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterFunction_statement(s)
	}
}

func (s *Function_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitFunction_statement(s)
	}
}

func (p *SystemVerilogParser) Function_statement() (localctx IFunction_statementContext) {
	this := p
	_ = this

	localctx = NewFunction_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 720, SystemVerilogParserRULE_function_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5706)
		p.Statement()
	}

	return localctx
}

// IFunction_statement_or_nullContext is an interface to support dynamic dispatch.
type IFunction_statement_or_nullContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_statement_or_nullContext differentiates from other interfaces.
	IsFunction_statement_or_nullContext()
}

type Function_statement_or_nullContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_statement_or_nullContext() *Function_statement_or_nullContext {
	var p = new(Function_statement_or_nullContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_function_statement_or_null
	return p
}

func (*Function_statement_or_nullContext) IsFunction_statement_or_nullContext() {}

func NewFunction_statement_or_nullContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_statement_or_nullContext {
	var p = new(Function_statement_or_nullContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_function_statement_or_null

	return p
}

func (s *Function_statement_or_nullContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_statement_or_nullContext) Function_statement() IFunction_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_statementContext)
}

func (s *Function_statement_or_nullContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Function_statement_or_nullContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Function_statement_or_nullContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Function_statement_or_nullContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_statement_or_nullContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_statement_or_nullContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterFunction_statement_or_null(s)
	}
}

func (s *Function_statement_or_nullContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitFunction_statement_or_null(s)
	}
}

func (p *SystemVerilogParser) Function_statement_or_null() (localctx IFunction_statement_or_nullContext) {
	this := p
	_ = this

	localctx = NewFunction_statement_or_nullContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 722, SystemVerilogParserRULE_function_statement_or_null)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5716)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 695, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5708)
			p.Function_statement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(5712)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserLPS {
			{
				p.SetState(5709)
				p.Attribute_instance()
			}

			p.SetState(5714)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(5715)
			p.Match(SystemVerilogParserSEMI)
		}

	}

	return localctx
}

// IVariable_identifier_listContext is an interface to support dynamic dispatch.
type IVariable_identifier_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariable_identifier_listContext differentiates from other interfaces.
	IsVariable_identifier_listContext()
}

type Variable_identifier_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariable_identifier_listContext() *Variable_identifier_listContext {
	var p = new(Variable_identifier_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_variable_identifier_list
	return p
}

func (*Variable_identifier_listContext) IsVariable_identifier_listContext() {}

func NewVariable_identifier_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Variable_identifier_listContext {
	var p = new(Variable_identifier_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_variable_identifier_list

	return p
}

func (s *Variable_identifier_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Variable_identifier_listContext) AllVariable_identifier() []IVariable_identifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariable_identifierContext)(nil)).Elem())
	var tst = make([]IVariable_identifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariable_identifierContext)
		}
	}

	return tst
}

func (s *Variable_identifier_listContext) Variable_identifier(i int) IVariable_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_identifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariable_identifierContext)
}

func (s *Variable_identifier_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *Variable_identifier_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *Variable_identifier_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Variable_identifier_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Variable_identifier_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterVariable_identifier_list(s)
	}
}

func (s *Variable_identifier_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitVariable_identifier_list(s)
	}
}

func (p *SystemVerilogParser) Variable_identifier_list() (localctx IVariable_identifier_listContext) {
	this := p
	_ = this

	localctx = NewVariable_identifier_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 724, SystemVerilogParserRULE_variable_identifier_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5718)
		p.Variable_identifier()
	}
	p.SetState(5723)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserCOMMA {
		{
			p.SetState(5719)
			p.Match(SystemVerilogParserCOMMA)
		}
		{
			p.SetState(5720)
			p.Variable_identifier()
		}

		p.SetState(5725)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IProcedural_timing_control_statementContext is an interface to support dynamic dispatch.
type IProcedural_timing_control_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedural_timing_control_statementContext differentiates from other interfaces.
	IsProcedural_timing_control_statementContext()
}

type Procedural_timing_control_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedural_timing_control_statementContext() *Procedural_timing_control_statementContext {
	var p = new(Procedural_timing_control_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_procedural_timing_control_statement
	return p
}

func (*Procedural_timing_control_statementContext) IsProcedural_timing_control_statementContext() {}

func NewProcedural_timing_control_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Procedural_timing_control_statementContext {
	var p = new(Procedural_timing_control_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_procedural_timing_control_statement

	return p
}

func (s *Procedural_timing_control_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Procedural_timing_control_statementContext) Procedural_timing_control() IProcedural_timing_controlContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedural_timing_controlContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedural_timing_controlContext)
}

func (s *Procedural_timing_control_statementContext) Statement_or_null() IStatement_or_nullContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatement_or_nullContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatement_or_nullContext)
}

func (s *Procedural_timing_control_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Procedural_timing_control_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Procedural_timing_control_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterProcedural_timing_control_statement(s)
	}
}

func (s *Procedural_timing_control_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitProcedural_timing_control_statement(s)
	}
}

func (p *SystemVerilogParser) Procedural_timing_control_statement() (localctx IProcedural_timing_control_statementContext) {
	this := p
	_ = this

	localctx = NewProcedural_timing_control_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 726, SystemVerilogParserRULE_procedural_timing_control_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5726)
		p.Procedural_timing_control()
	}
	{
		p.SetState(5727)
		p.Statement_or_null()
	}

	return localctx
}

// IDelay_or_event_controlContext is an interface to support dynamic dispatch.
type IDelay_or_event_controlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDelay_or_event_controlContext differentiates from other interfaces.
	IsDelay_or_event_controlContext()
}

type Delay_or_event_controlContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDelay_or_event_controlContext() *Delay_or_event_controlContext {
	var p = new(Delay_or_event_controlContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_delay_or_event_control
	return p
}

func (*Delay_or_event_controlContext) IsDelay_or_event_controlContext() {}

func NewDelay_or_event_controlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Delay_or_event_controlContext {
	var p = new(Delay_or_event_controlContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_delay_or_event_control

	return p
}

func (s *Delay_or_event_controlContext) GetParser() antlr.Parser { return s.parser }

func (s *Delay_or_event_controlContext) Delay_control() IDelay_controlContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelay_controlContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelay_controlContext)
}

func (s *Delay_or_event_controlContext) Event_control() IEvent_controlContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvent_controlContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEvent_controlContext)
}

func (s *Delay_or_event_controlContext) KREPEAT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKREPEAT, 0)
}

func (s *Delay_or_event_controlContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Delay_or_event_controlContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Delay_or_event_controlContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Delay_or_event_controlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Delay_or_event_controlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Delay_or_event_controlContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterDelay_or_event_control(s)
	}
}

func (s *Delay_or_event_controlContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitDelay_or_event_control(s)
	}
}

func (p *SystemVerilogParser) Delay_or_event_control() (localctx IDelay_or_event_controlContext) {
	this := p
	_ = this

	localctx = NewDelay_or_event_controlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 728, SystemVerilogParserRULE_delay_or_event_control)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5738)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserP:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5729)
			p.Delay_control()
		}

	case SystemVerilogParserAT, SystemVerilogParserKREPEAT:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(5735)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserKREPEAT {
			{
				p.SetState(5730)
				p.Match(SystemVerilogParserKREPEAT)
			}
			{
				p.SetState(5731)
				p.Match(SystemVerilogParserLP)
			}
			{
				p.SetState(5732)
				p.expression(0)
			}
			{
				p.SetState(5733)
				p.Match(SystemVerilogParserRP)
			}

		}
		{
			p.SetState(5737)
			p.Event_control()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDelay_controlContext is an interface to support dynamic dispatch.
type IDelay_controlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDelay_controlContext differentiates from other interfaces.
	IsDelay_controlContext()
}

type Delay_controlContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDelay_controlContext() *Delay_controlContext {
	var p = new(Delay_controlContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_delay_control
	return p
}

func (*Delay_controlContext) IsDelay_controlContext() {}

func NewDelay_controlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Delay_controlContext {
	var p = new(Delay_controlContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_delay_control

	return p
}

func (s *Delay_controlContext) GetParser() antlr.Parser { return s.parser }

func (s *Delay_controlContext) P() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserP, 0)
}

func (s *Delay_controlContext) Delay_value() IDelay_valueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelay_valueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelay_valueContext)
}

func (s *Delay_controlContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Delay_controlContext) Mintypmax_expression() IMintypmax_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMintypmax_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMintypmax_expressionContext)
}

func (s *Delay_controlContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Delay_controlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Delay_controlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Delay_controlContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterDelay_control(s)
	}
}

func (s *Delay_controlContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitDelay_control(s)
	}
}

func (p *SystemVerilogParser) Delay_control() (localctx IDelay_controlContext) {
	this := p
	_ = this

	localctx = NewDelay_controlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 730, SystemVerilogParserRULE_delay_control)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5740)
		p.Match(SystemVerilogParserP)
	}
	p.SetState(5746)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserDUNIT, SystemVerilogParserKONESTEP, SystemVerilogParserTIME_LITERAL, SystemVerilogParserREAL_NUMBER, SystemVerilogParserUNSIGNED_NUMBER, SystemVerilogParserSIMPLE_IDENTIFIER:
		{
			p.SetState(5741)
			p.Delay_value()
		}

	case SystemVerilogParserLP:
		{
			p.SetState(5742)
			p.Match(SystemVerilogParserLP)
		}
		{
			p.SetState(5743)
			p.Mintypmax_expression()
		}
		{
			p.SetState(5744)
			p.Match(SystemVerilogParserRP)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IEvent_controlContext is an interface to support dynamic dispatch.
type IEvent_controlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvent_controlContext differentiates from other interfaces.
	IsEvent_controlContext()
}

type Event_controlContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvent_controlContext() *Event_controlContext {
	var p = new(Event_controlContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_event_control
	return p
}

func (*Event_controlContext) IsEvent_controlContext() {}

func NewEvent_controlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Event_controlContext {
	var p = new(Event_controlContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_event_control

	return p
}

func (s *Event_controlContext) GetParser() antlr.Parser { return s.parser }

func (s *Event_controlContext) AT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserAT, 0)
}

func (s *Event_controlContext) Hierarchical_event_identifier() IHierarchical_event_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_event_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_event_identifierContext)
}

func (s *Event_controlContext) Ps_or_hierarchical_sequence_identifier() IPs_or_hierarchical_sequence_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPs_or_hierarchical_sequence_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPs_or_hierarchical_sequence_identifierContext)
}

func (s *Event_controlContext) STAR() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSTAR, 0)
}

func (s *Event_controlContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Event_controlContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Event_controlContext) Event_expression() IEvent_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvent_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEvent_expressionContext)
}

func (s *Event_controlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Event_controlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Event_controlContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterEvent_control(s)
	}
}

func (s *Event_controlContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitEvent_control(s)
	}
}

func (p *SystemVerilogParser) Event_control() (localctx IEvent_controlContext) {
	this := p
	_ = this

	localctx = NewEvent_controlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 732, SystemVerilogParserRULE_event_control)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5748)
		p.Match(SystemVerilogParserAT)
	}
	p.SetState(5758)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 701, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(5749)
			p.Hierarchical_event_identifier()
		}

	case 2:
		{
			p.SetState(5750)
			p.Ps_or_hierarchical_sequence_identifier()
		}

	case 3:
		{
			p.SetState(5751)
			p.Match(SystemVerilogParserSTAR)
		}

	case 4:
		{
			p.SetState(5752)
			p.Match(SystemVerilogParserLP)
		}
		p.SetState(5755)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SystemVerilogParserMINUS, SystemVerilogParserMINUSMINS, SystemVerilogParserNOT, SystemVerilogParserDOLLAR, SystemVerilogParserDROOT, SystemVerilogParserDUNIT, SystemVerilogParserAND, SystemVerilogParserLP, SystemVerilogParserQUOTE, SystemVerilogParserCARET, SystemVerilogParserCARETSQUIG, SystemVerilogParserLC, SystemVerilogParserBAR, SystemVerilogParserSQUIG, SystemVerilogParserSQUIGAND, SystemVerilogParserSQUIGCARET, SystemVerilogParserSQUIGBAR, SystemVerilogParserPLUS, SystemVerilogParserPLUSPLUS, SystemVerilogParserKBIT, SystemVerilogParserKBYTE, SystemVerilogParserKCONST, SystemVerilogParserKEDGE, SystemVerilogParserKINT, SystemVerilogParserKINTEGER, SystemVerilogParserKLOCAL, SystemVerilogParserKLOGIC, SystemVerilogParserKLONGINT, SystemVerilogParserKNEGEDGE, SystemVerilogParserKNULL, SystemVerilogParserKPOSEDGE, SystemVerilogParserKRANDOMIZE, SystemVerilogParserKREAL, SystemVerilogParserKREALTIME, SystemVerilogParserKREG, SystemVerilogParserKSHORTINT, SystemVerilogParserKSHORTREAL, SystemVerilogParserKSIGNED, SystemVerilogParserKSTD, SystemVerilogParserKSTRING, SystemVerilogParserKSUPER, SystemVerilogParserKTAGGED, SystemVerilogParserKTHIS, SystemVerilogParserKTIME, SystemVerilogParserKTYPE, SystemVerilogParserKUNSIGNED, SystemVerilogParserTIME_LITERAL, SystemVerilogParserDECIMAL_NUMBER, SystemVerilogParserBINARY_NUMBER, SystemVerilogParserOCTAL_NUMBER, SystemVerilogParserHEX_NUMBER, SystemVerilogParserREAL_NUMBER, SystemVerilogParserUNSIGNED_NUMBER, SystemVerilogParserSTRING_LITERAL, SystemVerilogParserSIMPLE_IDENTIFIER, SystemVerilogParserSYSTEM_TF_IDENTIFIER:
			{
				p.SetState(5753)
				p.event_expression(0)
			}

		case SystemVerilogParserSTAR:
			{
				p.SetState(5754)
				p.Match(SystemVerilogParserSTAR)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(5757)
			p.Match(SystemVerilogParserRP)
		}

	}

	return localctx
}

// IEvent_expressionContext is an interface to support dynamic dispatch.
type IEvent_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvent_expressionContext differentiates from other interfaces.
	IsEvent_expressionContext()
}

type Event_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvent_expressionContext() *Event_expressionContext {
	var p = new(Event_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_event_expression
	return p
}

func (*Event_expressionContext) IsEvent_expressionContext() {}

func NewEvent_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Event_expressionContext {
	var p = new(Event_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_event_expression

	return p
}

func (s *Event_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Event_expressionContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *Event_expressionContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Event_expressionContext) Sequence_instance() ISequence_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequence_instanceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISequence_instanceContext)
}

func (s *Event_expressionContext) KIFF() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKIFF, 0)
}

func (s *Event_expressionContext) Edge_identifier() IEdge_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEdge_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEdge_identifierContext)
}

func (s *Event_expressionContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Event_expressionContext) AllEvent_expression() []IEvent_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEvent_expressionContext)(nil)).Elem())
	var tst = make([]IEvent_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEvent_expressionContext)
		}
	}

	return tst
}

func (s *Event_expressionContext) Event_expression(i int) IEvent_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvent_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEvent_expressionContext)
}

func (s *Event_expressionContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Event_expressionContext) KOR() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKOR, 0)
}

func (s *Event_expressionContext) COMMA() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, 0)
}

func (s *Event_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Event_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Event_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterEvent_expression(s)
	}
}

func (s *Event_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitEvent_expression(s)
	}
}

func (p *SystemVerilogParser) Event_expression() (localctx IEvent_expressionContext) {
	return p.event_expression(0)
}

func (p *SystemVerilogParser) event_expression(_p int) (localctx IEvent_expressionContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewEvent_expressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IEvent_expressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 734
	p.EnterRecursionRule(localctx, 734, SystemVerilogParserRULE_event_expression, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5776)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 705, p.GetParserRuleContext()) {
	case 1:
		p.SetState(5766)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 703, p.GetParserRuleContext()) {
		case 1:
			p.SetState(5762)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == SystemVerilogParserKEDGE || _la == SystemVerilogParserKNEGEDGE || _la == SystemVerilogParserKPOSEDGE {
				{
					p.SetState(5761)
					p.Edge_identifier()
				}

			}
			{
				p.SetState(5764)
				p.expression(0)
			}

		case 2:
			{
				p.SetState(5765)
				p.Sequence_instance()
			}

		}
		p.SetState(5770)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 704, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5768)
				p.Match(SystemVerilogParserKIFF)
			}
			{
				p.SetState(5769)
				p.expression(0)
			}

		}

	case 2:
		{
			p.SetState(5772)
			p.Match(SystemVerilogParserLP)
		}
		{
			p.SetState(5773)
			p.event_expression(0)
		}
		{
			p.SetState(5774)
			p.Match(SystemVerilogParserRP)
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(5783)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 706, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewEvent_expressionContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, SystemVerilogParserRULE_event_expression)
			p.SetState(5778)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
			}
			{
				p.SetState(5779)
				_la = p.GetTokenStream().LA(1)

				if !(_la == SystemVerilogParserCOMMA || _la == SystemVerilogParserKOR) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(5780)
				p.event_expression(3)
			}

		}
		p.SetState(5785)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 706, p.GetParserRuleContext())
	}

	return localctx
}

// IProcedural_timing_controlContext is an interface to support dynamic dispatch.
type IProcedural_timing_controlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedural_timing_controlContext differentiates from other interfaces.
	IsProcedural_timing_controlContext()
}

type Procedural_timing_controlContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedural_timing_controlContext() *Procedural_timing_controlContext {
	var p = new(Procedural_timing_controlContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_procedural_timing_control
	return p
}

func (*Procedural_timing_controlContext) IsProcedural_timing_controlContext() {}

func NewProcedural_timing_controlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Procedural_timing_controlContext {
	var p = new(Procedural_timing_controlContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_procedural_timing_control

	return p
}

func (s *Procedural_timing_controlContext) GetParser() antlr.Parser { return s.parser }

func (s *Procedural_timing_controlContext) Delay_control() IDelay_controlContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelay_controlContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelay_controlContext)
}

func (s *Procedural_timing_controlContext) Event_control() IEvent_controlContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvent_controlContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEvent_controlContext)
}

func (s *Procedural_timing_controlContext) Cycle_delay() ICycle_delayContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICycle_delayContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICycle_delayContext)
}

func (s *Procedural_timing_controlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Procedural_timing_controlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Procedural_timing_controlContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterProcedural_timing_control(s)
	}
}

func (s *Procedural_timing_controlContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitProcedural_timing_control(s)
	}
}

func (p *SystemVerilogParser) Procedural_timing_control() (localctx IProcedural_timing_controlContext) {
	this := p
	_ = this

	localctx = NewProcedural_timing_controlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 736, SystemVerilogParserRULE_procedural_timing_control)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5789)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserP:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5786)
			p.Delay_control()
		}

	case SystemVerilogParserAT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5787)
			p.Event_control()
		}

	case SystemVerilogParserPP:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5788)
			p.Cycle_delay()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IJump_statementContext is an interface to support dynamic dispatch.
type IJump_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsJump_statementContext differentiates from other interfaces.
	IsJump_statementContext()
}

type Jump_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJump_statementContext() *Jump_statementContext {
	var p = new(Jump_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_jump_statement
	return p
}

func (*Jump_statementContext) IsJump_statementContext() {}

func NewJump_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Jump_statementContext {
	var p = new(Jump_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_jump_statement

	return p
}

func (s *Jump_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Jump_statementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Jump_statementContext) KRETURN() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKRETURN, 0)
}

func (s *Jump_statementContext) KBREAK() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKBREAK, 0)
}

func (s *Jump_statementContext) KCONTINUE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKCONTINUE, 0)
}

func (s *Jump_statementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Jump_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Jump_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Jump_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterJump_statement(s)
	}
}

func (s *Jump_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitJump_statement(s)
	}
}

func (p *SystemVerilogParser) Jump_statement() (localctx IJump_statementContext) {
	this := p
	_ = this

	localctx = NewJump_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 738, SystemVerilogParserRULE_jump_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5797)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserKRETURN:
		{
			p.SetState(5791)
			p.Match(SystemVerilogParserKRETURN)
		}
		p.SetState(5793)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SystemVerilogParserMINUS)|(1<<SystemVerilogParserMINUSMINS)|(1<<SystemVerilogParserNOT)|(1<<SystemVerilogParserDOLLAR)|(1<<SystemVerilogParserDROOT)|(1<<SystemVerilogParserDUNIT)|(1<<SystemVerilogParserAND)|(1<<SystemVerilogParserLP))) != 0) || (((_la-51)&-(0x1f+1)) == 0 && ((1<<uint((_la-51)))&((1<<(SystemVerilogParserQUOTE-51))|(1<<(SystemVerilogParserCARET-51))|(1<<(SystemVerilogParserCARETSQUIG-51))|(1<<(SystemVerilogParserLC-51))|(1<<(SystemVerilogParserBAR-51))|(1<<(SystemVerilogParserSQUIG-51))|(1<<(SystemVerilogParserSQUIGAND-51))|(1<<(SystemVerilogParserSQUIGCARET-51))|(1<<(SystemVerilogParserSQUIGBAR-51))|(1<<(SystemVerilogParserPLUS-51))|(1<<(SystemVerilogParserPLUSPLUS-51)))) != 0) || (((_la-109)&-(0x1f+1)) == 0 && ((1<<uint((_la-109)))&((1<<(SystemVerilogParserKBIT-109))|(1<<(SystemVerilogParserKBYTE-109))|(1<<(SystemVerilogParserKCONST-109)))) != 0) || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SystemVerilogParserKINT-195))|(1<<(SystemVerilogParserKINTEGER-195))|(1<<(SystemVerilogParserKLOCAL-195))|(1<<(SystemVerilogParserKLOGIC-195))|(1<<(SystemVerilogParserKLONGINT-195)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(SystemVerilogParserKNULL-228))|(1<<(SystemVerilogParserKRANDOMIZE-228))|(1<<(SystemVerilogParserKREAL-228))|(1<<(SystemVerilogParserKREALTIME-228))|(1<<(SystemVerilogParserKREG-228)))) != 0) || (((_la-276)&-(0x1f+1)) == 0 && ((1<<uint((_la-276)))&((1<<(SystemVerilogParserKSHORTINT-276))|(1<<(SystemVerilogParserKSHORTREAL-276))|(1<<(SystemVerilogParserKSIGNED-276))|(1<<(SystemVerilogParserKSTD-276))|(1<<(SystemVerilogParserKSTRING-276))|(1<<(SystemVerilogParserKSUPER-276))|(1<<(SystemVerilogParserKTAGGED-276))|(1<<(SystemVerilogParserKTHIS-276))|(1<<(SystemVerilogParserKTIME-276)))) != 0) || _la == SystemVerilogParserKTYPE || _la == SystemVerilogParserKUNSIGNED || (((_la-345)&-(0x1f+1)) == 0 && ((1<<uint((_la-345)))&((1<<(SystemVerilogParserTIME_LITERAL-345))|(1<<(SystemVerilogParserDECIMAL_NUMBER-345))|(1<<(SystemVerilogParserBINARY_NUMBER-345))|(1<<(SystemVerilogParserOCTAL_NUMBER-345))|(1<<(SystemVerilogParserHEX_NUMBER-345))|(1<<(SystemVerilogParserREAL_NUMBER-345))|(1<<(SystemVerilogParserUNSIGNED_NUMBER-345))|(1<<(SystemVerilogParserSTRING_LITERAL-345))|(1<<(SystemVerilogParserSIMPLE_IDENTIFIER-345))|(1<<(SystemVerilogParserSYSTEM_TF_IDENTIFIER-345)))) != 0) {
			{
				p.SetState(5792)
				p.expression(0)
			}

		}

	case SystemVerilogParserKBREAK:
		{
			p.SetState(5795)
			p.Match(SystemVerilogParserKBREAK)
		}

	case SystemVerilogParserKCONTINUE:
		{
			p.SetState(5796)
			p.Match(SystemVerilogParserKCONTINUE)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(5799)
		p.Match(SystemVerilogParserSEMI)
	}

	return localctx
}

// IWait_statementContext is an interface to support dynamic dispatch.
type IWait_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWait_statementContext differentiates from other interfaces.
	IsWait_statementContext()
}

type Wait_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWait_statementContext() *Wait_statementContext {
	var p = new(Wait_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_wait_statement
	return p
}

func (*Wait_statementContext) IsWait_statementContext() {}

func NewWait_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Wait_statementContext {
	var p = new(Wait_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_wait_statement

	return p
}

func (s *Wait_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Wait_statementContext) KWAIT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKWAIT, 0)
}

func (s *Wait_statementContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Wait_statementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Wait_statementContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Wait_statementContext) Statement_or_null() IStatement_or_nullContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatement_or_nullContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatement_or_nullContext)
}

func (s *Wait_statementContext) KFORK() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKFORK, 0)
}

func (s *Wait_statementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Wait_statementContext) KWAIT_ORDER() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKWAIT_ORDER, 0)
}

func (s *Wait_statementContext) AllHierarchical_identifier() []IHierarchical_identifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IHierarchical_identifierContext)(nil)).Elem())
	var tst = make([]IHierarchical_identifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IHierarchical_identifierContext)
		}
	}

	return tst
}

func (s *Wait_statementContext) Hierarchical_identifier(i int) IHierarchical_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_identifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_identifierContext)
}

func (s *Wait_statementContext) Action_block() IAction_blockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAction_blockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAction_blockContext)
}

func (s *Wait_statementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *Wait_statementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *Wait_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Wait_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Wait_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterWait_statement(s)
	}
}

func (s *Wait_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitWait_statement(s)
	}
}

func (p *SystemVerilogParser) Wait_statement() (localctx IWait_statementContext) {
	this := p
	_ = this

	localctx = NewWait_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 740, SystemVerilogParserRULE_wait_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5824)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserKWAIT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5801)
			p.Match(SystemVerilogParserKWAIT)
		}
		p.SetState(5809)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SystemVerilogParserLP:
			{
				p.SetState(5802)
				p.Match(SystemVerilogParserLP)
			}
			{
				p.SetState(5803)
				p.expression(0)
			}
			{
				p.SetState(5804)
				p.Match(SystemVerilogParserRP)
			}
			{
				p.SetState(5805)
				p.Statement_or_null()
			}

		case SystemVerilogParserKFORK:
			{
				p.SetState(5807)
				p.Match(SystemVerilogParserKFORK)
			}
			{
				p.SetState(5808)
				p.Match(SystemVerilogParserSEMI)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case SystemVerilogParserKWAIT_ORDER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5811)
			p.Match(SystemVerilogParserKWAIT_ORDER)
		}
		{
			p.SetState(5812)
			p.Match(SystemVerilogParserLP)
		}
		{
			p.SetState(5813)
			p.Hierarchical_identifier()
		}
		p.SetState(5818)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserCOMMA {
			{
				p.SetState(5814)
				p.Match(SystemVerilogParserCOMMA)
			}
			{
				p.SetState(5815)
				p.Hierarchical_identifier()
			}

			p.SetState(5820)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(5821)
			p.Match(SystemVerilogParserRP)
		}
		{
			p.SetState(5822)
			p.Action_block()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IEvent_triggerContext is an interface to support dynamic dispatch.
type IEvent_triggerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvent_triggerContext differentiates from other interfaces.
	IsEvent_triggerContext()
}

type Event_triggerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvent_triggerContext() *Event_triggerContext {
	var p = new(Event_triggerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_event_trigger
	return p
}

func (*Event_triggerContext) IsEvent_triggerContext() {}

func NewEvent_triggerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Event_triggerContext {
	var p = new(Event_triggerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_event_trigger

	return p
}

func (s *Event_triggerContext) GetParser() antlr.Parser { return s.parser }

func (s *Event_triggerContext) Hierarchical_event_identifier() IHierarchical_event_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_event_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_event_identifierContext)
}

func (s *Event_triggerContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Event_triggerContext) ARROW() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserARROW, 0)
}

func (s *Event_triggerContext) MINUSGTGT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserMINUSGTGT, 0)
}

func (s *Event_triggerContext) Delay_or_event_control() IDelay_or_event_controlContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelay_or_event_controlContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelay_or_event_controlContext)
}

func (s *Event_triggerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Event_triggerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Event_triggerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterEvent_trigger(s)
	}
}

func (s *Event_triggerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitEvent_trigger(s)
	}
}

func (p *SystemVerilogParser) Event_trigger() (localctx IEvent_triggerContext) {
	this := p
	_ = this

	localctx = NewEvent_triggerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 742, SystemVerilogParserRULE_event_trigger)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5831)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserARROW:
		{
			p.SetState(5826)
			p.Match(SystemVerilogParserARROW)
		}

	case SystemVerilogParserMINUSGTGT:
		{
			p.SetState(5827)
			p.Match(SystemVerilogParserMINUSGTGT)
		}
		p.SetState(5829)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserP || _la == SystemVerilogParserAT || _la == SystemVerilogParserKREPEAT {
			{
				p.SetState(5828)
				p.Delay_or_event_control()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(5833)
		p.Hierarchical_event_identifier()
	}
	{
		p.SetState(5834)
		p.Match(SystemVerilogParserSEMI)
	}

	return localctx
}

// IDisable_statementContext is an interface to support dynamic dispatch.
type IDisable_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDisable_statementContext differentiates from other interfaces.
	IsDisable_statementContext()
}

type Disable_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDisable_statementContext() *Disable_statementContext {
	var p = new(Disable_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_disable_statement
	return p
}

func (*Disable_statementContext) IsDisable_statementContext() {}

func NewDisable_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Disable_statementContext {
	var p = new(Disable_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_disable_statement

	return p
}

func (s *Disable_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Disable_statementContext) KDISABLE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKDISABLE, 0)
}

func (s *Disable_statementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Disable_statementContext) Hierarchical_task_identifier() IHierarchical_task_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_task_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_task_identifierContext)
}

func (s *Disable_statementContext) Hierarchical_block_identifier() IHierarchical_block_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_block_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_block_identifierContext)
}

func (s *Disable_statementContext) KFORK() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKFORK, 0)
}

func (s *Disable_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Disable_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Disable_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterDisable_statement(s)
	}
}

func (s *Disable_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitDisable_statement(s)
	}
}

func (p *SystemVerilogParser) Disable_statement() (localctx IDisable_statementContext) {
	this := p
	_ = this

	localctx = NewDisable_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 744, SystemVerilogParserRULE_disable_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5836)
		p.Match(SystemVerilogParserKDISABLE)
	}
	p.SetState(5840)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 715, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(5837)
			p.Hierarchical_task_identifier()
		}

	case 2:
		{
			p.SetState(5838)
			p.Hierarchical_block_identifier()
		}

	case 3:
		{
			p.SetState(5839)
			p.Match(SystemVerilogParserKFORK)
		}

	}
	{
		p.SetState(5842)
		p.Match(SystemVerilogParserSEMI)
	}

	return localctx
}

// IConditional_statementContext is an interface to support dynamic dispatch.
type IConditional_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConditional_statementContext differentiates from other interfaces.
	IsConditional_statementContext()
}

type Conditional_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditional_statementContext() *Conditional_statementContext {
	var p = new(Conditional_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_conditional_statement
	return p
}

func (*Conditional_statementContext) IsConditional_statementContext() {}

func NewConditional_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Conditional_statementContext {
	var p = new(Conditional_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_conditional_statement

	return p
}

func (s *Conditional_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Conditional_statementContext) AllKIF() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserKIF)
}

func (s *Conditional_statementContext) KIF(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKIF, i)
}

func (s *Conditional_statementContext) AllLP() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserLP)
}

func (s *Conditional_statementContext) LP(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, i)
}

func (s *Conditional_statementContext) AllCond_predicate() []ICond_predicateContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICond_predicateContext)(nil)).Elem())
	var tst = make([]ICond_predicateContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICond_predicateContext)
		}
	}

	return tst
}

func (s *Conditional_statementContext) Cond_predicate(i int) ICond_predicateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICond_predicateContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICond_predicateContext)
}

func (s *Conditional_statementContext) AllRP() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserRP)
}

func (s *Conditional_statementContext) RP(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, i)
}

func (s *Conditional_statementContext) AllStatement_or_null() []IStatement_or_nullContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatement_or_nullContext)(nil)).Elem())
	var tst = make([]IStatement_or_nullContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatement_or_nullContext)
		}
	}

	return tst
}

func (s *Conditional_statementContext) Statement_or_null(i int) IStatement_or_nullContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatement_or_nullContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatement_or_nullContext)
}

func (s *Conditional_statementContext) Unique_priority() IUnique_priorityContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnique_priorityContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnique_priorityContext)
}

func (s *Conditional_statementContext) AllKELSE() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserKELSE)
}

func (s *Conditional_statementContext) KELSE(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKELSE, i)
}

func (s *Conditional_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Conditional_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Conditional_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterConditional_statement(s)
	}
}

func (s *Conditional_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitConditional_statement(s)
	}
}

func (p *SystemVerilogParser) Conditional_statement() (localctx IConditional_statementContext) {
	this := p
	_ = this

	localctx = NewConditional_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 746, SystemVerilogParserRULE_conditional_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5845)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserKPRIORITY || _la == SystemVerilogParserKUNIQUE || _la == SystemVerilogParserKUNIQUE0 {
		{
			p.SetState(5844)
			p.Unique_priority()
		}

	}
	{
		p.SetState(5847)
		p.Match(SystemVerilogParserKIF)
	}
	{
		p.SetState(5848)
		p.Match(SystemVerilogParserLP)
	}
	{
		p.SetState(5849)
		p.Cond_predicate()
	}
	{
		p.SetState(5850)
		p.Match(SystemVerilogParserRP)
	}
	{
		p.SetState(5851)
		p.Statement_or_null()
	}
	p.SetState(5861)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 717, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(5852)
				p.Match(SystemVerilogParserKELSE)
			}
			{
				p.SetState(5853)
				p.Match(SystemVerilogParserKIF)
			}
			{
				p.SetState(5854)
				p.Match(SystemVerilogParserLP)
			}
			{
				p.SetState(5855)
				p.Cond_predicate()
			}
			{
				p.SetState(5856)
				p.Match(SystemVerilogParserRP)
			}
			{
				p.SetState(5857)
				p.Statement_or_null()
			}

		}
		p.SetState(5863)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 717, p.GetParserRuleContext())
	}
	p.SetState(5866)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 718, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5864)
			p.Match(SystemVerilogParserKELSE)
		}
		{
			p.SetState(5865)
			p.Statement_or_null()
		}

	}

	return localctx
}

// IUnique_priorityContext is an interface to support dynamic dispatch.
type IUnique_priorityContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnique_priorityContext differentiates from other interfaces.
	IsUnique_priorityContext()
}

type Unique_priorityContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnique_priorityContext() *Unique_priorityContext {
	var p = new(Unique_priorityContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_unique_priority
	return p
}

func (*Unique_priorityContext) IsUnique_priorityContext() {}

func NewUnique_priorityContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unique_priorityContext {
	var p = new(Unique_priorityContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_unique_priority

	return p
}

func (s *Unique_priorityContext) GetParser() antlr.Parser { return s.parser }

func (s *Unique_priorityContext) KUNIQUE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKUNIQUE, 0)
}

func (s *Unique_priorityContext) KUNIQUE0() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKUNIQUE0, 0)
}

func (s *Unique_priorityContext) KPRIORITY() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKPRIORITY, 0)
}

func (s *Unique_priorityContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unique_priorityContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Unique_priorityContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterUnique_priority(s)
	}
}

func (s *Unique_priorityContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitUnique_priority(s)
	}
}

func (p *SystemVerilogParser) Unique_priority() (localctx IUnique_priorityContext) {
	this := p
	_ = this

	localctx = NewUnique_priorityContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 748, SystemVerilogParserRULE_unique_priority)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5868)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SystemVerilogParserKPRIORITY || _la == SystemVerilogParserKUNIQUE || _la == SystemVerilogParserKUNIQUE0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ICond_predicateContext is an interface to support dynamic dispatch.
type ICond_predicateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCond_predicateContext differentiates from other interfaces.
	IsCond_predicateContext()
}

type Cond_predicateContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCond_predicateContext() *Cond_predicateContext {
	var p = new(Cond_predicateContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_cond_predicate
	return p
}

func (*Cond_predicateContext) IsCond_predicateContext() {}

func NewCond_predicateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cond_predicateContext {
	var p = new(Cond_predicateContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_cond_predicate

	return p
}

func (s *Cond_predicateContext) GetParser() antlr.Parser { return s.parser }

func (s *Cond_predicateContext) AllExpression_or_cond_pattern() []IExpression_or_cond_patternContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpression_or_cond_patternContext)(nil)).Elem())
	var tst = make([]IExpression_or_cond_patternContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpression_or_cond_patternContext)
		}
	}

	return tst
}

func (s *Cond_predicateContext) Expression_or_cond_pattern(i int) IExpression_or_cond_patternContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpression_or_cond_patternContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpression_or_cond_patternContext)
}

func (s *Cond_predicateContext) AllANDANDAND() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserANDANDAND)
}

func (s *Cond_predicateContext) ANDANDAND(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserANDANDAND, i)
}

func (s *Cond_predicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cond_predicateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cond_predicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterCond_predicate(s)
	}
}

func (s *Cond_predicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitCond_predicate(s)
	}
}

func (p *SystemVerilogParser) Cond_predicate() (localctx ICond_predicateContext) {
	this := p
	_ = this

	localctx = NewCond_predicateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 750, SystemVerilogParserRULE_cond_predicate)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5870)
		p.Expression_or_cond_pattern()
	}
	p.SetState(5875)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserANDANDAND {
		{
			p.SetState(5871)
			p.Match(SystemVerilogParserANDANDAND)
		}
		{
			p.SetState(5872)
			p.Expression_or_cond_pattern()
		}

		p.SetState(5877)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IExpression_or_cond_patternContext is an interface to support dynamic dispatch.
type IExpression_or_cond_patternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpression_or_cond_patternContext differentiates from other interfaces.
	IsExpression_or_cond_patternContext()
}

type Expression_or_cond_patternContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpression_or_cond_patternContext() *Expression_or_cond_patternContext {
	var p = new(Expression_or_cond_patternContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_expression_or_cond_pattern
	return p
}

func (*Expression_or_cond_patternContext) IsExpression_or_cond_patternContext() {}

func NewExpression_or_cond_patternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expression_or_cond_patternContext {
	var p = new(Expression_or_cond_patternContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_expression_or_cond_pattern

	return p
}

func (s *Expression_or_cond_patternContext) GetParser() antlr.Parser { return s.parser }

func (s *Expression_or_cond_patternContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Expression_or_cond_patternContext) Cond_pattern() ICond_patternContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICond_patternContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICond_patternContext)
}

func (s *Expression_or_cond_patternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expression_or_cond_patternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expression_or_cond_patternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterExpression_or_cond_pattern(s)
	}
}

func (s *Expression_or_cond_patternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitExpression_or_cond_pattern(s)
	}
}

func (p *SystemVerilogParser) Expression_or_cond_pattern() (localctx IExpression_or_cond_patternContext) {
	this := p
	_ = this

	localctx = NewExpression_or_cond_patternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 752, SystemVerilogParserRULE_expression_or_cond_pattern)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5880)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 720, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5878)
			p.expression(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5879)
			p.Cond_pattern()
		}

	}

	return localctx
}

// ICond_patternContext is an interface to support dynamic dispatch.
type ICond_patternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCond_patternContext differentiates from other interfaces.
	IsCond_patternContext()
}

type Cond_patternContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCond_patternContext() *Cond_patternContext {
	var p = new(Cond_patternContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_cond_pattern
	return p
}

func (*Cond_patternContext) IsCond_patternContext() {}

func NewCond_patternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cond_patternContext {
	var p = new(Cond_patternContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_cond_pattern

	return p
}

func (s *Cond_patternContext) GetParser() antlr.Parser { return s.parser }

func (s *Cond_patternContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Cond_patternContext) KMATCHES() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKMATCHES, 0)
}

func (s *Cond_patternContext) Pattern() IPatternContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPatternContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPatternContext)
}

func (s *Cond_patternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cond_patternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cond_patternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterCond_pattern(s)
	}
}

func (s *Cond_patternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitCond_pattern(s)
	}
}

func (p *SystemVerilogParser) Cond_pattern() (localctx ICond_patternContext) {
	this := p
	_ = this

	localctx = NewCond_patternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 754, SystemVerilogParserRULE_cond_pattern)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5882)
		p.expression(0)
	}
	{
		p.SetState(5883)
		p.Match(SystemVerilogParserKMATCHES)
	}
	{
		p.SetState(5884)
		p.Pattern()
	}

	return localctx
}

// ICase_statementContext is an interface to support dynamic dispatch.
type ICase_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCase_statementContext differentiates from other interfaces.
	IsCase_statementContext()
}

type Case_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCase_statementContext() *Case_statementContext {
	var p = new(Case_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_case_statement
	return p
}

func (*Case_statementContext) IsCase_statementContext() {}

func NewCase_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Case_statementContext {
	var p = new(Case_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_case_statement

	return p
}

func (s *Case_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Case_statementContext) Case_keyword() ICase_keywordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICase_keywordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICase_keywordContext)
}

func (s *Case_statementContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Case_statementContext) Case_expression() ICase_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICase_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICase_expressionContext)
}

func (s *Case_statementContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Case_statementContext) KENDCASE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKENDCASE, 0)
}

func (s *Case_statementContext) AllCase_item() []ICase_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICase_itemContext)(nil)).Elem())
	var tst = make([]ICase_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICase_itemContext)
		}
	}

	return tst
}

func (s *Case_statementContext) Case_item(i int) ICase_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICase_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICase_itemContext)
}

func (s *Case_statementContext) KMATCHES() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKMATCHES, 0)
}

func (s *Case_statementContext) AllCase_pattern_item() []ICase_pattern_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICase_pattern_itemContext)(nil)).Elem())
	var tst = make([]ICase_pattern_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICase_pattern_itemContext)
		}
	}

	return tst
}

func (s *Case_statementContext) Case_pattern_item(i int) ICase_pattern_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICase_pattern_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICase_pattern_itemContext)
}

func (s *Case_statementContext) Unique_priority() IUnique_priorityContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnique_priorityContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnique_priorityContext)
}

func (s *Case_statementContext) KCASE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKCASE, 0)
}

func (s *Case_statementContext) KINSIDE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKINSIDE, 0)
}

func (s *Case_statementContext) AllCase_inside_item() []ICase_inside_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICase_inside_itemContext)(nil)).Elem())
	var tst = make([]ICase_inside_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICase_inside_itemContext)
		}
	}

	return tst
}

func (s *Case_statementContext) Case_inside_item(i int) ICase_inside_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICase_inside_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICase_inside_itemContext)
}

func (s *Case_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Case_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Case_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterCase_statement(s)
	}
}

func (s *Case_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitCase_statement(s)
	}
}

func (p *SystemVerilogParser) Case_statement() (localctx ICase_statementContext) {
	this := p
	_ = this

	localctx = NewCase_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 756, SystemVerilogParserRULE_case_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5929)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 727, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(5887)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserKPRIORITY || _la == SystemVerilogParserKUNIQUE || _la == SystemVerilogParserKUNIQUE0 {
			{
				p.SetState(5886)
				p.Unique_priority()
			}

		}
		{
			p.SetState(5889)
			p.Case_keyword()
		}
		{
			p.SetState(5890)
			p.Match(SystemVerilogParserLP)
		}
		{
			p.SetState(5891)
			p.Case_expression()
		}
		{
			p.SetState(5892)
			p.Match(SystemVerilogParserRP)
		}
		p.SetState(5908)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SystemVerilogParserMINUS, SystemVerilogParserMINUSMINS, SystemVerilogParserNOT, SystemVerilogParserDOLLAR, SystemVerilogParserDROOT, SystemVerilogParserDUNIT, SystemVerilogParserAND, SystemVerilogParserLP, SystemVerilogParserQUOTE, SystemVerilogParserCARET, SystemVerilogParserCARETSQUIG, SystemVerilogParserLC, SystemVerilogParserBAR, SystemVerilogParserSQUIG, SystemVerilogParserSQUIGAND, SystemVerilogParserSQUIGCARET, SystemVerilogParserSQUIGBAR, SystemVerilogParserPLUS, SystemVerilogParserPLUSPLUS, SystemVerilogParserKBIT, SystemVerilogParserKBYTE, SystemVerilogParserKCONST, SystemVerilogParserKDEFAULT, SystemVerilogParserKINT, SystemVerilogParserKINTEGER, SystemVerilogParserKLOCAL, SystemVerilogParserKLOGIC, SystemVerilogParserKLONGINT, SystemVerilogParserKNULL, SystemVerilogParserKRANDOMIZE, SystemVerilogParserKREAL, SystemVerilogParserKREALTIME, SystemVerilogParserKREG, SystemVerilogParserKSHORTINT, SystemVerilogParserKSHORTREAL, SystemVerilogParserKSIGNED, SystemVerilogParserKSTD, SystemVerilogParserKSTRING, SystemVerilogParserKSUPER, SystemVerilogParserKTAGGED, SystemVerilogParserKTHIS, SystemVerilogParserKTIME, SystemVerilogParserKTYPE, SystemVerilogParserKUNSIGNED, SystemVerilogParserTIME_LITERAL, SystemVerilogParserDECIMAL_NUMBER, SystemVerilogParserBINARY_NUMBER, SystemVerilogParserOCTAL_NUMBER, SystemVerilogParserHEX_NUMBER, SystemVerilogParserREAL_NUMBER, SystemVerilogParserUNSIGNED_NUMBER, SystemVerilogParserSTRING_LITERAL, SystemVerilogParserSIMPLE_IDENTIFIER, SystemVerilogParserSYSTEM_TF_IDENTIFIER:
			{
				p.SetState(5893)
				p.Case_item()
			}
			p.SetState(5897)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SystemVerilogParserMINUS)|(1<<SystemVerilogParserMINUSMINS)|(1<<SystemVerilogParserNOT)|(1<<SystemVerilogParserDOLLAR)|(1<<SystemVerilogParserDROOT)|(1<<SystemVerilogParserDUNIT)|(1<<SystemVerilogParserAND)|(1<<SystemVerilogParserLP))) != 0) || (((_la-51)&-(0x1f+1)) == 0 && ((1<<uint((_la-51)))&((1<<(SystemVerilogParserQUOTE-51))|(1<<(SystemVerilogParserCARET-51))|(1<<(SystemVerilogParserCARETSQUIG-51))|(1<<(SystemVerilogParserLC-51))|(1<<(SystemVerilogParserBAR-51))|(1<<(SystemVerilogParserSQUIG-51))|(1<<(SystemVerilogParserSQUIGAND-51))|(1<<(SystemVerilogParserSQUIGCARET-51))|(1<<(SystemVerilogParserSQUIGBAR-51))|(1<<(SystemVerilogParserPLUS-51))|(1<<(SystemVerilogParserPLUSPLUS-51)))) != 0) || (((_la-109)&-(0x1f+1)) == 0 && ((1<<uint((_la-109)))&((1<<(SystemVerilogParserKBIT-109))|(1<<(SystemVerilogParserKBYTE-109))|(1<<(SystemVerilogParserKCONST-109))|(1<<(SystemVerilogParserKDEFAULT-109)))) != 0) || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SystemVerilogParserKINT-195))|(1<<(SystemVerilogParserKINTEGER-195))|(1<<(SystemVerilogParserKLOCAL-195))|(1<<(SystemVerilogParserKLOGIC-195))|(1<<(SystemVerilogParserKLONGINT-195)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(SystemVerilogParserKNULL-228))|(1<<(SystemVerilogParserKRANDOMIZE-228))|(1<<(SystemVerilogParserKREAL-228))|(1<<(SystemVerilogParserKREALTIME-228))|(1<<(SystemVerilogParserKREG-228)))) != 0) || (((_la-276)&-(0x1f+1)) == 0 && ((1<<uint((_la-276)))&((1<<(SystemVerilogParserKSHORTINT-276))|(1<<(SystemVerilogParserKSHORTREAL-276))|(1<<(SystemVerilogParserKSIGNED-276))|(1<<(SystemVerilogParserKSTD-276))|(1<<(SystemVerilogParserKSTRING-276))|(1<<(SystemVerilogParserKSUPER-276))|(1<<(SystemVerilogParserKTAGGED-276))|(1<<(SystemVerilogParserKTHIS-276))|(1<<(SystemVerilogParserKTIME-276)))) != 0) || _la == SystemVerilogParserKTYPE || _la == SystemVerilogParserKUNSIGNED || (((_la-345)&-(0x1f+1)) == 0 && ((1<<uint((_la-345)))&((1<<(SystemVerilogParserTIME_LITERAL-345))|(1<<(SystemVerilogParserDECIMAL_NUMBER-345))|(1<<(SystemVerilogParserBINARY_NUMBER-345))|(1<<(SystemVerilogParserOCTAL_NUMBER-345))|(1<<(SystemVerilogParserHEX_NUMBER-345))|(1<<(SystemVerilogParserREAL_NUMBER-345))|(1<<(SystemVerilogParserUNSIGNED_NUMBER-345))|(1<<(SystemVerilogParserSTRING_LITERAL-345))|(1<<(SystemVerilogParserSIMPLE_IDENTIFIER-345))|(1<<(SystemVerilogParserSYSTEM_TF_IDENTIFIER-345)))) != 0) {
				{
					p.SetState(5894)
					p.Case_item()
				}

				p.SetState(5899)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		case SystemVerilogParserKMATCHES:
			{
				p.SetState(5900)
				p.Match(SystemVerilogParserKMATCHES)
			}
			{
				p.SetState(5901)
				p.Case_pattern_item()
			}
			p.SetState(5905)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SystemVerilogParserMINUS)|(1<<SystemVerilogParserNOT)|(1<<SystemVerilogParserDOLLAR)|(1<<SystemVerilogParserDROOT)|(1<<SystemVerilogParserDUNIT)|(1<<SystemVerilogParserAND)|(1<<SystemVerilogParserLP))) != 0) || (((_la-37)&-(0x1f+1)) == 0 && ((1<<uint((_la-37)))&((1<<(SystemVerilogParserDOT-37))|(1<<(SystemVerilogParserDOTSTAR-37))|(1<<(SystemVerilogParserQUOTE-37))|(1<<(SystemVerilogParserCARET-37))|(1<<(SystemVerilogParserCARETSQUIG-37))|(1<<(SystemVerilogParserLC-37))|(1<<(SystemVerilogParserBAR-37))|(1<<(SystemVerilogParserSQUIG-37))|(1<<(SystemVerilogParserSQUIGAND-37))|(1<<(SystemVerilogParserSQUIGCARET-37))|(1<<(SystemVerilogParserSQUIGBAR-37))|(1<<(SystemVerilogParserPLUS-37)))) != 0) || _la == SystemVerilogParserKBYTE || _la == SystemVerilogParserKDEFAULT || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SystemVerilogParserKINT-195))|(1<<(SystemVerilogParserKINTEGER-195))|(1<<(SystemVerilogParserKLOCAL-195))|(1<<(SystemVerilogParserKLONGINT-195)))) != 0) || _la == SystemVerilogParserKNULL || _la == SystemVerilogParserKRANDOMIZE || (((_la-276)&-(0x1f+1)) == 0 && ((1<<uint((_la-276)))&((1<<(SystemVerilogParserKSHORTINT-276))|(1<<(SystemVerilogParserKSTD-276))|(1<<(SystemVerilogParserKSUPER-276))|(1<<(SystemVerilogParserKTAGGED-276))|(1<<(SystemVerilogParserKTHIS-276))|(1<<(SystemVerilogParserKTIME-276)))) != 0) || _la == SystemVerilogParserKTYPE || (((_la-345)&-(0x1f+1)) == 0 && ((1<<uint((_la-345)))&((1<<(SystemVerilogParserTIME_LITERAL-345))|(1<<(SystemVerilogParserDECIMAL_NUMBER-345))|(1<<(SystemVerilogParserBINARY_NUMBER-345))|(1<<(SystemVerilogParserOCTAL_NUMBER-345))|(1<<(SystemVerilogParserHEX_NUMBER-345))|(1<<(SystemVerilogParserREAL_NUMBER-345))|(1<<(SystemVerilogParserUNSIGNED_NUMBER-345))|(1<<(SystemVerilogParserSTRING_LITERAL-345))|(1<<(SystemVerilogParserSIMPLE_IDENTIFIER-345))|(1<<(SystemVerilogParserSYSTEM_TF_IDENTIFIER-345)))) != 0) {
				{
					p.SetState(5902)
					p.Case_pattern_item()
				}

				p.SetState(5907)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(5910)
			p.Match(SystemVerilogParserKENDCASE)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(5913)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserKPRIORITY || _la == SystemVerilogParserKUNIQUE || _la == SystemVerilogParserKUNIQUE0 {
			{
				p.SetState(5912)
				p.Unique_priority()
			}

		}
		{
			p.SetState(5915)
			p.Match(SystemVerilogParserKCASE)
		}
		{
			p.SetState(5916)
			p.Match(SystemVerilogParserLP)
		}
		{
			p.SetState(5917)
			p.Case_expression()
		}
		{
			p.SetState(5918)
			p.Match(SystemVerilogParserRP)
		}
		{
			p.SetState(5919)
			p.Match(SystemVerilogParserKINSIDE)
		}
		{
			p.SetState(5920)
			p.Case_inside_item()
		}
		p.SetState(5924)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SystemVerilogParserMINUS)|(1<<SystemVerilogParserMINUSMINS)|(1<<SystemVerilogParserNOT)|(1<<SystemVerilogParserDOLLAR)|(1<<SystemVerilogParserDROOT)|(1<<SystemVerilogParserDUNIT)|(1<<SystemVerilogParserAND)|(1<<SystemVerilogParserLP))) != 0) || (((_la-50)&-(0x1f+1)) == 0 && ((1<<uint((_la-50)))&((1<<(SystemVerilogParserLB-50))|(1<<(SystemVerilogParserQUOTE-50))|(1<<(SystemVerilogParserCARET-50))|(1<<(SystemVerilogParserCARETSQUIG-50))|(1<<(SystemVerilogParserLC-50))|(1<<(SystemVerilogParserBAR-50))|(1<<(SystemVerilogParserSQUIG-50))|(1<<(SystemVerilogParserSQUIGAND-50))|(1<<(SystemVerilogParserSQUIGCARET-50))|(1<<(SystemVerilogParserSQUIGBAR-50))|(1<<(SystemVerilogParserPLUS-50))|(1<<(SystemVerilogParserPLUSPLUS-50)))) != 0) || (((_la-109)&-(0x1f+1)) == 0 && ((1<<uint((_la-109)))&((1<<(SystemVerilogParserKBIT-109))|(1<<(SystemVerilogParserKBYTE-109))|(1<<(SystemVerilogParserKCONST-109))|(1<<(SystemVerilogParserKDEFAULT-109)))) != 0) || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SystemVerilogParserKINT-195))|(1<<(SystemVerilogParserKINTEGER-195))|(1<<(SystemVerilogParserKLOCAL-195))|(1<<(SystemVerilogParserKLOGIC-195))|(1<<(SystemVerilogParserKLONGINT-195)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(SystemVerilogParserKNULL-228))|(1<<(SystemVerilogParserKRANDOMIZE-228))|(1<<(SystemVerilogParserKREAL-228))|(1<<(SystemVerilogParserKREALTIME-228))|(1<<(SystemVerilogParserKREG-228)))) != 0) || (((_la-276)&-(0x1f+1)) == 0 && ((1<<uint((_la-276)))&((1<<(SystemVerilogParserKSHORTINT-276))|(1<<(SystemVerilogParserKSHORTREAL-276))|(1<<(SystemVerilogParserKSIGNED-276))|(1<<(SystemVerilogParserKSTD-276))|(1<<(SystemVerilogParserKSTRING-276))|(1<<(SystemVerilogParserKSUPER-276))|(1<<(SystemVerilogParserKTAGGED-276))|(1<<(SystemVerilogParserKTHIS-276))|(1<<(SystemVerilogParserKTIME-276)))) != 0) || _la == SystemVerilogParserKTYPE || _la == SystemVerilogParserKUNSIGNED || (((_la-345)&-(0x1f+1)) == 0 && ((1<<uint((_la-345)))&((1<<(SystemVerilogParserTIME_LITERAL-345))|(1<<(SystemVerilogParserDECIMAL_NUMBER-345))|(1<<(SystemVerilogParserBINARY_NUMBER-345))|(1<<(SystemVerilogParserOCTAL_NUMBER-345))|(1<<(SystemVerilogParserHEX_NUMBER-345))|(1<<(SystemVerilogParserREAL_NUMBER-345))|(1<<(SystemVerilogParserUNSIGNED_NUMBER-345))|(1<<(SystemVerilogParserSTRING_LITERAL-345))|(1<<(SystemVerilogParserSIMPLE_IDENTIFIER-345))|(1<<(SystemVerilogParserSYSTEM_TF_IDENTIFIER-345)))) != 0) {
			{
				p.SetState(5921)
				p.Case_inside_item()
			}

			p.SetState(5926)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(5927)
			p.Match(SystemVerilogParserKENDCASE)
		}

	}

	return localctx
}

// ICase_keywordContext is an interface to support dynamic dispatch.
type ICase_keywordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCase_keywordContext differentiates from other interfaces.
	IsCase_keywordContext()
}

type Case_keywordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCase_keywordContext() *Case_keywordContext {
	var p = new(Case_keywordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_case_keyword
	return p
}

func (*Case_keywordContext) IsCase_keywordContext() {}

func NewCase_keywordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Case_keywordContext {
	var p = new(Case_keywordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_case_keyword

	return p
}

func (s *Case_keywordContext) GetParser() antlr.Parser { return s.parser }

func (s *Case_keywordContext) KCASE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKCASE, 0)
}

func (s *Case_keywordContext) KCASEZ() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKCASEZ, 0)
}

func (s *Case_keywordContext) KCASEX() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKCASEX, 0)
}

func (s *Case_keywordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Case_keywordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Case_keywordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterCase_keyword(s)
	}
}

func (s *Case_keywordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitCase_keyword(s)
	}
}

func (p *SystemVerilogParser) Case_keyword() (localctx ICase_keywordContext) {
	this := p
	_ = this

	localctx = NewCase_keywordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 758, SystemVerilogParserRULE_case_keyword)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5931)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-115)&-(0x1f+1)) == 0 && ((1<<uint((_la-115)))&((1<<(SystemVerilogParserKCASE-115))|(1<<(SystemVerilogParserKCASEX-115))|(1<<(SystemVerilogParserKCASEZ-115)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ICase_expressionContext is an interface to support dynamic dispatch.
type ICase_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCase_expressionContext differentiates from other interfaces.
	IsCase_expressionContext()
}

type Case_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCase_expressionContext() *Case_expressionContext {
	var p = new(Case_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_case_expression
	return p
}

func (*Case_expressionContext) IsCase_expressionContext() {}

func NewCase_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Case_expressionContext {
	var p = new(Case_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_case_expression

	return p
}

func (s *Case_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Case_expressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Case_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Case_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Case_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterCase_expression(s)
	}
}

func (s *Case_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitCase_expression(s)
	}
}

func (p *SystemVerilogParser) Case_expression() (localctx ICase_expressionContext) {
	this := p
	_ = this

	localctx = NewCase_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 760, SystemVerilogParserRULE_case_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5933)
		p.expression(0)
	}

	return localctx
}

// ICase_itemContext is an interface to support dynamic dispatch.
type ICase_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCase_itemContext differentiates from other interfaces.
	IsCase_itemContext()
}

type Case_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCase_itemContext() *Case_itemContext {
	var p = new(Case_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_case_item
	return p
}

func (*Case_itemContext) IsCase_itemContext() {}

func NewCase_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Case_itemContext {
	var p = new(Case_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_case_item

	return p
}

func (s *Case_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Case_itemContext) AllCase_item_expression() []ICase_item_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICase_item_expressionContext)(nil)).Elem())
	var tst = make([]ICase_item_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICase_item_expressionContext)
		}
	}

	return tst
}

func (s *Case_itemContext) Case_item_expression(i int) ICase_item_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICase_item_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICase_item_expressionContext)
}

func (s *Case_itemContext) COLON() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOLON, 0)
}

func (s *Case_itemContext) Statement_or_null() IStatement_or_nullContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatement_or_nullContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatement_or_nullContext)
}

func (s *Case_itemContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *Case_itemContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *Case_itemContext) KDEFAULT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKDEFAULT, 0)
}

func (s *Case_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Case_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Case_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterCase_item(s)
	}
}

func (s *Case_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitCase_item(s)
	}
}

func (p *SystemVerilogParser) Case_item() (localctx ICase_itemContext) {
	this := p
	_ = this

	localctx = NewCase_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 762, SystemVerilogParserRULE_case_item)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5951)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserMINUS, SystemVerilogParserMINUSMINS, SystemVerilogParserNOT, SystemVerilogParserDOLLAR, SystemVerilogParserDROOT, SystemVerilogParserDUNIT, SystemVerilogParserAND, SystemVerilogParserLP, SystemVerilogParserQUOTE, SystemVerilogParserCARET, SystemVerilogParserCARETSQUIG, SystemVerilogParserLC, SystemVerilogParserBAR, SystemVerilogParserSQUIG, SystemVerilogParserSQUIGAND, SystemVerilogParserSQUIGCARET, SystemVerilogParserSQUIGBAR, SystemVerilogParserPLUS, SystemVerilogParserPLUSPLUS, SystemVerilogParserKBIT, SystemVerilogParserKBYTE, SystemVerilogParserKCONST, SystemVerilogParserKINT, SystemVerilogParserKINTEGER, SystemVerilogParserKLOCAL, SystemVerilogParserKLOGIC, SystemVerilogParserKLONGINT, SystemVerilogParserKNULL, SystemVerilogParserKRANDOMIZE, SystemVerilogParserKREAL, SystemVerilogParserKREALTIME, SystemVerilogParserKREG, SystemVerilogParserKSHORTINT, SystemVerilogParserKSHORTREAL, SystemVerilogParserKSIGNED, SystemVerilogParserKSTD, SystemVerilogParserKSTRING, SystemVerilogParserKSUPER, SystemVerilogParserKTAGGED, SystemVerilogParserKTHIS, SystemVerilogParserKTIME, SystemVerilogParserKTYPE, SystemVerilogParserKUNSIGNED, SystemVerilogParserTIME_LITERAL, SystemVerilogParserDECIMAL_NUMBER, SystemVerilogParserBINARY_NUMBER, SystemVerilogParserOCTAL_NUMBER, SystemVerilogParserHEX_NUMBER, SystemVerilogParserREAL_NUMBER, SystemVerilogParserUNSIGNED_NUMBER, SystemVerilogParserSTRING_LITERAL, SystemVerilogParserSIMPLE_IDENTIFIER, SystemVerilogParserSYSTEM_TF_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5935)
			p.Case_item_expression()
		}
		p.SetState(5940)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserCOMMA {
			{
				p.SetState(5936)
				p.Match(SystemVerilogParserCOMMA)
			}
			{
				p.SetState(5937)
				p.Case_item_expression()
			}

			p.SetState(5942)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(5943)
			p.Match(SystemVerilogParserCOLON)
		}
		{
			p.SetState(5944)
			p.Statement_or_null()
		}

	case SystemVerilogParserKDEFAULT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5946)
			p.Match(SystemVerilogParserKDEFAULT)
		}
		p.SetState(5948)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserCOLON {
			{
				p.SetState(5947)
				p.Match(SystemVerilogParserCOLON)
			}

		}
		{
			p.SetState(5950)
			p.Statement_or_null()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICase_pattern_itemContext is an interface to support dynamic dispatch.
type ICase_pattern_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCase_pattern_itemContext differentiates from other interfaces.
	IsCase_pattern_itemContext()
}

type Case_pattern_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCase_pattern_itemContext() *Case_pattern_itemContext {
	var p = new(Case_pattern_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_case_pattern_item
	return p
}

func (*Case_pattern_itemContext) IsCase_pattern_itemContext() {}

func NewCase_pattern_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Case_pattern_itemContext {
	var p = new(Case_pattern_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_case_pattern_item

	return p
}

func (s *Case_pattern_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Case_pattern_itemContext) Pattern() IPatternContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPatternContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPatternContext)
}

func (s *Case_pattern_itemContext) COLON() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOLON, 0)
}

func (s *Case_pattern_itemContext) Statement_or_null() IStatement_or_nullContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatement_or_nullContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatement_or_nullContext)
}

func (s *Case_pattern_itemContext) ANDANDAND() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserANDANDAND, 0)
}

func (s *Case_pattern_itemContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Case_pattern_itemContext) KDEFAULT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKDEFAULT, 0)
}

func (s *Case_pattern_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Case_pattern_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Case_pattern_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterCase_pattern_item(s)
	}
}

func (s *Case_pattern_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitCase_pattern_item(s)
	}
}

func (p *SystemVerilogParser) Case_pattern_item() (localctx ICase_pattern_itemContext) {
	this := p
	_ = this

	localctx = NewCase_pattern_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 764, SystemVerilogParserRULE_case_pattern_item)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5966)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserMINUS, SystemVerilogParserNOT, SystemVerilogParserDOLLAR, SystemVerilogParserDROOT, SystemVerilogParserDUNIT, SystemVerilogParserAND, SystemVerilogParserLP, SystemVerilogParserDOT, SystemVerilogParserDOTSTAR, SystemVerilogParserQUOTE, SystemVerilogParserCARET, SystemVerilogParserCARETSQUIG, SystemVerilogParserLC, SystemVerilogParserBAR, SystemVerilogParserSQUIG, SystemVerilogParserSQUIGAND, SystemVerilogParserSQUIGCARET, SystemVerilogParserSQUIGBAR, SystemVerilogParserPLUS, SystemVerilogParserKBYTE, SystemVerilogParserKINT, SystemVerilogParserKINTEGER, SystemVerilogParserKLOCAL, SystemVerilogParserKLONGINT, SystemVerilogParserKNULL, SystemVerilogParserKRANDOMIZE, SystemVerilogParserKSHORTINT, SystemVerilogParserKSTD, SystemVerilogParserKSUPER, SystemVerilogParserKTAGGED, SystemVerilogParserKTHIS, SystemVerilogParserKTIME, SystemVerilogParserKTYPE, SystemVerilogParserTIME_LITERAL, SystemVerilogParserDECIMAL_NUMBER, SystemVerilogParserBINARY_NUMBER, SystemVerilogParserOCTAL_NUMBER, SystemVerilogParserHEX_NUMBER, SystemVerilogParserREAL_NUMBER, SystemVerilogParserUNSIGNED_NUMBER, SystemVerilogParserSTRING_LITERAL, SystemVerilogParserSIMPLE_IDENTIFIER, SystemVerilogParserSYSTEM_TF_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5953)
			p.Pattern()
		}
		p.SetState(5956)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserANDANDAND {
			{
				p.SetState(5954)
				p.Match(SystemVerilogParserANDANDAND)
			}
			{
				p.SetState(5955)
				p.expression(0)
			}

		}
		{
			p.SetState(5958)
			p.Match(SystemVerilogParserCOLON)
		}
		{
			p.SetState(5959)
			p.Statement_or_null()
		}

	case SystemVerilogParserKDEFAULT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5961)
			p.Match(SystemVerilogParserKDEFAULT)
		}
		p.SetState(5963)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserCOLON {
			{
				p.SetState(5962)
				p.Match(SystemVerilogParserCOLON)
			}

		}
		{
			p.SetState(5965)
			p.Statement_or_null()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICase_inside_itemContext is an interface to support dynamic dispatch.
type ICase_inside_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCase_inside_itemContext differentiates from other interfaces.
	IsCase_inside_itemContext()
}

type Case_inside_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCase_inside_itemContext() *Case_inside_itemContext {
	var p = new(Case_inside_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_case_inside_item
	return p
}

func (*Case_inside_itemContext) IsCase_inside_itemContext() {}

func NewCase_inside_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Case_inside_itemContext {
	var p = new(Case_inside_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_case_inside_item

	return p
}

func (s *Case_inside_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Case_inside_itemContext) Open_range_list() IOpen_range_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOpen_range_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOpen_range_listContext)
}

func (s *Case_inside_itemContext) COLON() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOLON, 0)
}

func (s *Case_inside_itemContext) Statement_or_null() IStatement_or_nullContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatement_or_nullContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatement_or_nullContext)
}

func (s *Case_inside_itemContext) KDEFAULT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKDEFAULT, 0)
}

func (s *Case_inside_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Case_inside_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Case_inside_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterCase_inside_item(s)
	}
}

func (s *Case_inside_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitCase_inside_item(s)
	}
}

func (p *SystemVerilogParser) Case_inside_item() (localctx ICase_inside_itemContext) {
	this := p
	_ = this

	localctx = NewCase_inside_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 766, SystemVerilogParserRULE_case_inside_item)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5977)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserMINUS, SystemVerilogParserMINUSMINS, SystemVerilogParserNOT, SystemVerilogParserDOLLAR, SystemVerilogParserDROOT, SystemVerilogParserDUNIT, SystemVerilogParserAND, SystemVerilogParserLP, SystemVerilogParserLB, SystemVerilogParserQUOTE, SystemVerilogParserCARET, SystemVerilogParserCARETSQUIG, SystemVerilogParserLC, SystemVerilogParserBAR, SystemVerilogParserSQUIG, SystemVerilogParserSQUIGAND, SystemVerilogParserSQUIGCARET, SystemVerilogParserSQUIGBAR, SystemVerilogParserPLUS, SystemVerilogParserPLUSPLUS, SystemVerilogParserKBIT, SystemVerilogParserKBYTE, SystemVerilogParserKCONST, SystemVerilogParserKINT, SystemVerilogParserKINTEGER, SystemVerilogParserKLOCAL, SystemVerilogParserKLOGIC, SystemVerilogParserKLONGINT, SystemVerilogParserKNULL, SystemVerilogParserKRANDOMIZE, SystemVerilogParserKREAL, SystemVerilogParserKREALTIME, SystemVerilogParserKREG, SystemVerilogParserKSHORTINT, SystemVerilogParserKSHORTREAL, SystemVerilogParserKSIGNED, SystemVerilogParserKSTD, SystemVerilogParserKSTRING, SystemVerilogParserKSUPER, SystemVerilogParserKTAGGED, SystemVerilogParserKTHIS, SystemVerilogParserKTIME, SystemVerilogParserKTYPE, SystemVerilogParserKUNSIGNED, SystemVerilogParserTIME_LITERAL, SystemVerilogParserDECIMAL_NUMBER, SystemVerilogParserBINARY_NUMBER, SystemVerilogParserOCTAL_NUMBER, SystemVerilogParserHEX_NUMBER, SystemVerilogParserREAL_NUMBER, SystemVerilogParserUNSIGNED_NUMBER, SystemVerilogParserSTRING_LITERAL, SystemVerilogParserSIMPLE_IDENTIFIER, SystemVerilogParserSYSTEM_TF_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5968)
			p.Open_range_list()
		}
		{
			p.SetState(5969)
			p.Match(SystemVerilogParserCOLON)
		}
		{
			p.SetState(5970)
			p.Statement_or_null()
		}

	case SystemVerilogParserKDEFAULT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5972)
			p.Match(SystemVerilogParserKDEFAULT)
		}
		p.SetState(5974)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserCOLON {
			{
				p.SetState(5973)
				p.Match(SystemVerilogParserCOLON)
			}

		}
		{
			p.SetState(5976)
			p.Statement_or_null()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICase_item_expressionContext is an interface to support dynamic dispatch.
type ICase_item_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCase_item_expressionContext differentiates from other interfaces.
	IsCase_item_expressionContext()
}

type Case_item_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCase_item_expressionContext() *Case_item_expressionContext {
	var p = new(Case_item_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_case_item_expression
	return p
}

func (*Case_item_expressionContext) IsCase_item_expressionContext() {}

func NewCase_item_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Case_item_expressionContext {
	var p = new(Case_item_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_case_item_expression

	return p
}

func (s *Case_item_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Case_item_expressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Case_item_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Case_item_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Case_item_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterCase_item_expression(s)
	}
}

func (s *Case_item_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitCase_item_expression(s)
	}
}

func (p *SystemVerilogParser) Case_item_expression() (localctx ICase_item_expressionContext) {
	this := p
	_ = this

	localctx = NewCase_item_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 768, SystemVerilogParserRULE_case_item_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5979)
		p.expression(0)
	}

	return localctx
}

// IRandcase_statementContext is an interface to support dynamic dispatch.
type IRandcase_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRandcase_statementContext differentiates from other interfaces.
	IsRandcase_statementContext()
}

type Randcase_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRandcase_statementContext() *Randcase_statementContext {
	var p = new(Randcase_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_randcase_statement
	return p
}

func (*Randcase_statementContext) IsRandcase_statementContext() {}

func NewRandcase_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Randcase_statementContext {
	var p = new(Randcase_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_randcase_statement

	return p
}

func (s *Randcase_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Randcase_statementContext) KRANDCASE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKRANDCASE, 0)
}

func (s *Randcase_statementContext) AllRandcase_item() []IRandcase_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRandcase_itemContext)(nil)).Elem())
	var tst = make([]IRandcase_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRandcase_itemContext)
		}
	}

	return tst
}

func (s *Randcase_statementContext) Randcase_item(i int) IRandcase_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRandcase_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRandcase_itemContext)
}

func (s *Randcase_statementContext) KENDCASE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKENDCASE, 0)
}

func (s *Randcase_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Randcase_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Randcase_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterRandcase_statement(s)
	}
}

func (s *Randcase_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitRandcase_statement(s)
	}
}

func (p *SystemVerilogParser) Randcase_statement() (localctx IRandcase_statementContext) {
	this := p
	_ = this

	localctx = NewRandcase_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 770, SystemVerilogParserRULE_randcase_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5981)
		p.Match(SystemVerilogParserKRANDCASE)
	}
	{
		p.SetState(5982)
		p.Randcase_item()
	}
	p.SetState(5986)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SystemVerilogParserMINUS)|(1<<SystemVerilogParserMINUSMINS)|(1<<SystemVerilogParserNOT)|(1<<SystemVerilogParserDOLLAR)|(1<<SystemVerilogParserDROOT)|(1<<SystemVerilogParserDUNIT)|(1<<SystemVerilogParserAND)|(1<<SystemVerilogParserLP))) != 0) || (((_la-51)&-(0x1f+1)) == 0 && ((1<<uint((_la-51)))&((1<<(SystemVerilogParserQUOTE-51))|(1<<(SystemVerilogParserCARET-51))|(1<<(SystemVerilogParserCARETSQUIG-51))|(1<<(SystemVerilogParserLC-51))|(1<<(SystemVerilogParserBAR-51))|(1<<(SystemVerilogParserSQUIG-51))|(1<<(SystemVerilogParserSQUIGAND-51))|(1<<(SystemVerilogParserSQUIGCARET-51))|(1<<(SystemVerilogParserSQUIGBAR-51))|(1<<(SystemVerilogParserPLUS-51))|(1<<(SystemVerilogParserPLUSPLUS-51)))) != 0) || (((_la-109)&-(0x1f+1)) == 0 && ((1<<uint((_la-109)))&((1<<(SystemVerilogParserKBIT-109))|(1<<(SystemVerilogParserKBYTE-109))|(1<<(SystemVerilogParserKCONST-109)))) != 0) || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SystemVerilogParserKINT-195))|(1<<(SystemVerilogParserKINTEGER-195))|(1<<(SystemVerilogParserKLOCAL-195))|(1<<(SystemVerilogParserKLOGIC-195))|(1<<(SystemVerilogParserKLONGINT-195)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(SystemVerilogParserKNULL-228))|(1<<(SystemVerilogParserKRANDOMIZE-228))|(1<<(SystemVerilogParserKREAL-228))|(1<<(SystemVerilogParserKREALTIME-228))|(1<<(SystemVerilogParserKREG-228)))) != 0) || (((_la-276)&-(0x1f+1)) == 0 && ((1<<uint((_la-276)))&((1<<(SystemVerilogParserKSHORTINT-276))|(1<<(SystemVerilogParserKSHORTREAL-276))|(1<<(SystemVerilogParserKSIGNED-276))|(1<<(SystemVerilogParserKSTD-276))|(1<<(SystemVerilogParserKSTRING-276))|(1<<(SystemVerilogParserKSUPER-276))|(1<<(SystemVerilogParserKTAGGED-276))|(1<<(SystemVerilogParserKTHIS-276))|(1<<(SystemVerilogParserKTIME-276)))) != 0) || _la == SystemVerilogParserKTYPE || _la == SystemVerilogParserKUNSIGNED || (((_la-345)&-(0x1f+1)) == 0 && ((1<<uint((_la-345)))&((1<<(SystemVerilogParserTIME_LITERAL-345))|(1<<(SystemVerilogParserDECIMAL_NUMBER-345))|(1<<(SystemVerilogParserBINARY_NUMBER-345))|(1<<(SystemVerilogParserOCTAL_NUMBER-345))|(1<<(SystemVerilogParserHEX_NUMBER-345))|(1<<(SystemVerilogParserREAL_NUMBER-345))|(1<<(SystemVerilogParserUNSIGNED_NUMBER-345))|(1<<(SystemVerilogParserSTRING_LITERAL-345))|(1<<(SystemVerilogParserSIMPLE_IDENTIFIER-345))|(1<<(SystemVerilogParserSYSTEM_TF_IDENTIFIER-345)))) != 0) {
		{
			p.SetState(5983)
			p.Randcase_item()
		}

		p.SetState(5988)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(5989)
		p.Match(SystemVerilogParserKENDCASE)
	}

	return localctx
}

// IRandcase_itemContext is an interface to support dynamic dispatch.
type IRandcase_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRandcase_itemContext differentiates from other interfaces.
	IsRandcase_itemContext()
}

type Randcase_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRandcase_itemContext() *Randcase_itemContext {
	var p = new(Randcase_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_randcase_item
	return p
}

func (*Randcase_itemContext) IsRandcase_itemContext() {}

func NewRandcase_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Randcase_itemContext {
	var p = new(Randcase_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_randcase_item

	return p
}

func (s *Randcase_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Randcase_itemContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Randcase_itemContext) COLON() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOLON, 0)
}

func (s *Randcase_itemContext) Statement_or_null() IStatement_or_nullContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatement_or_nullContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatement_or_nullContext)
}

func (s *Randcase_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Randcase_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Randcase_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterRandcase_item(s)
	}
}

func (s *Randcase_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitRandcase_item(s)
	}
}

func (p *SystemVerilogParser) Randcase_item() (localctx IRandcase_itemContext) {
	this := p
	_ = this

	localctx = NewRandcase_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 772, SystemVerilogParserRULE_randcase_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5991)
		p.expression(0)
	}
	{
		p.SetState(5992)
		p.Match(SystemVerilogParserCOLON)
	}
	{
		p.SetState(5993)
		p.Statement_or_null()
	}

	return localctx
}

// IOpen_range_listContext is an interface to support dynamic dispatch.
type IOpen_range_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOpen_range_listContext differentiates from other interfaces.
	IsOpen_range_listContext()
}

type Open_range_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpen_range_listContext() *Open_range_listContext {
	var p = new(Open_range_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_open_range_list
	return p
}

func (*Open_range_listContext) IsOpen_range_listContext() {}

func NewOpen_range_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Open_range_listContext {
	var p = new(Open_range_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_open_range_list

	return p
}

func (s *Open_range_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Open_range_listContext) AllOpen_value_range() []IOpen_value_rangeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOpen_value_rangeContext)(nil)).Elem())
	var tst = make([]IOpen_value_rangeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOpen_value_rangeContext)
		}
	}

	return tst
}

func (s *Open_range_listContext) Open_value_range(i int) IOpen_value_rangeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOpen_value_rangeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOpen_value_rangeContext)
}

func (s *Open_range_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *Open_range_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *Open_range_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Open_range_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Open_range_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterOpen_range_list(s)
	}
}

func (s *Open_range_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitOpen_range_list(s)
	}
}

func (p *SystemVerilogParser) Open_range_list() (localctx IOpen_range_listContext) {
	this := p
	_ = this

	localctx = NewOpen_range_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 774, SystemVerilogParserRULE_open_range_list)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5995)
		p.Open_value_range()
	}
	p.SetState(6000)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 737, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(5996)
				p.Match(SystemVerilogParserCOMMA)
			}
			{
				p.SetState(5997)
				p.Open_value_range()
			}

		}
		p.SetState(6002)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 737, p.GetParserRuleContext())
	}

	return localctx
}

// IOpen_value_rangeContext is an interface to support dynamic dispatch.
type IOpen_value_rangeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOpen_value_rangeContext differentiates from other interfaces.
	IsOpen_value_rangeContext()
}

type Open_value_rangeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpen_value_rangeContext() *Open_value_rangeContext {
	var p = new(Open_value_rangeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_open_value_range
	return p
}

func (*Open_value_rangeContext) IsOpen_value_rangeContext() {}

func NewOpen_value_rangeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Open_value_rangeContext {
	var p = new(Open_value_rangeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_open_value_range

	return p
}

func (s *Open_value_rangeContext) GetParser() antlr.Parser { return s.parser }

func (s *Open_value_rangeContext) Value_range() IValue_rangeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValue_rangeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValue_rangeContext)
}

func (s *Open_value_rangeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Open_value_rangeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Open_value_rangeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterOpen_value_range(s)
	}
}

func (s *Open_value_rangeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitOpen_value_range(s)
	}
}

func (p *SystemVerilogParser) Open_value_range() (localctx IOpen_value_rangeContext) {
	this := p
	_ = this

	localctx = NewOpen_value_rangeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 776, SystemVerilogParserRULE_open_value_range)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6003)
		p.Value_range()
	}

	return localctx
}

// IPatternContext is an interface to support dynamic dispatch.
type IPatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPatternContext differentiates from other interfaces.
	IsPatternContext()
}

type PatternContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPatternContext() *PatternContext {
	var p = new(PatternContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_pattern
	return p
}

func (*PatternContext) IsPatternContext() {}

func NewPatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PatternContext {
	var p = new(PatternContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_pattern

	return p
}

func (s *PatternContext) GetParser() antlr.Parser { return s.parser }

func (s *PatternContext) DOT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserDOT, 0)
}

func (s *PatternContext) Variable_identifier() IVariable_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_identifierContext)
}

func (s *PatternContext) DOTSTAR() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserDOTSTAR, 0)
}

func (s *PatternContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *PatternContext) KTAGGED() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKTAGGED, 0)
}

func (s *PatternContext) AllMember_identifier() []IMember_identifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMember_identifierContext)(nil)).Elem())
	var tst = make([]IMember_identifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMember_identifierContext)
		}
	}

	return tst
}

func (s *PatternContext) Member_identifier(i int) IMember_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMember_identifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMember_identifierContext)
}

func (s *PatternContext) AllPattern() []IPatternContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPatternContext)(nil)).Elem())
	var tst = make([]IPatternContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPatternContext)
		}
	}

	return tst
}

func (s *PatternContext) Pattern(i int) IPatternContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPatternContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPatternContext)
}

func (s *PatternContext) QUOTE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserQUOTE, 0)
}

func (s *PatternContext) LC() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLC, 0)
}

func (s *PatternContext) RC() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRC, 0)
}

func (s *PatternContext) AllCOLON() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOLON)
}

func (s *PatternContext) COLON(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOLON, i)
}

func (s *PatternContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *PatternContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *PatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PatternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterPattern(s)
	}
}

func (s *PatternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitPattern(s)
	}
}

func (p *SystemVerilogParser) Pattern() (localctx IPatternContext) {
	this := p
	_ = this

	localctx = NewPatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 778, SystemVerilogParserRULE_pattern)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6041)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 742, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6005)
			p.Match(SystemVerilogParserDOT)
		}
		{
			p.SetState(6006)
			p.Variable_identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6007)
			p.Match(SystemVerilogParserDOTSTAR)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6008)
			p.constant_expression(0)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6009)
			p.Match(SystemVerilogParserKTAGGED)
		}
		{
			p.SetState(6010)
			p.Member_identifier()
		}
		p.SetState(6012)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SystemVerilogParserMINUS)|(1<<SystemVerilogParserNOT)|(1<<SystemVerilogParserDOLLAR)|(1<<SystemVerilogParserDROOT)|(1<<SystemVerilogParserDUNIT)|(1<<SystemVerilogParserAND)|(1<<SystemVerilogParserLP))) != 0) || (((_la-37)&-(0x1f+1)) == 0 && ((1<<uint((_la-37)))&((1<<(SystemVerilogParserDOT-37))|(1<<(SystemVerilogParserDOTSTAR-37))|(1<<(SystemVerilogParserQUOTE-37))|(1<<(SystemVerilogParserCARET-37))|(1<<(SystemVerilogParserCARETSQUIG-37))|(1<<(SystemVerilogParserLC-37))|(1<<(SystemVerilogParserBAR-37))|(1<<(SystemVerilogParserSQUIG-37))|(1<<(SystemVerilogParserSQUIGAND-37))|(1<<(SystemVerilogParserSQUIGCARET-37))|(1<<(SystemVerilogParserSQUIGBAR-37))|(1<<(SystemVerilogParserPLUS-37)))) != 0) || _la == SystemVerilogParserKBYTE || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SystemVerilogParserKINT-195))|(1<<(SystemVerilogParserKINTEGER-195))|(1<<(SystemVerilogParserKLOCAL-195))|(1<<(SystemVerilogParserKLONGINT-195)))) != 0) || _la == SystemVerilogParserKNULL || _la == SystemVerilogParserKRANDOMIZE || (((_la-276)&-(0x1f+1)) == 0 && ((1<<uint((_la-276)))&((1<<(SystemVerilogParserKSHORTINT-276))|(1<<(SystemVerilogParserKSTD-276))|(1<<(SystemVerilogParserKSUPER-276))|(1<<(SystemVerilogParserKTAGGED-276))|(1<<(SystemVerilogParserKTHIS-276))|(1<<(SystemVerilogParserKTIME-276)))) != 0) || _la == SystemVerilogParserKTYPE || (((_la-345)&-(0x1f+1)) == 0 && ((1<<uint((_la-345)))&((1<<(SystemVerilogParserTIME_LITERAL-345))|(1<<(SystemVerilogParserDECIMAL_NUMBER-345))|(1<<(SystemVerilogParserBINARY_NUMBER-345))|(1<<(SystemVerilogParserOCTAL_NUMBER-345))|(1<<(SystemVerilogParserHEX_NUMBER-345))|(1<<(SystemVerilogParserREAL_NUMBER-345))|(1<<(SystemVerilogParserUNSIGNED_NUMBER-345))|(1<<(SystemVerilogParserSTRING_LITERAL-345))|(1<<(SystemVerilogParserSIMPLE_IDENTIFIER-345))|(1<<(SystemVerilogParserSYSTEM_TF_IDENTIFIER-345)))) != 0) {
			{
				p.SetState(6011)
				p.Pattern()
			}

		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6014)
			p.Match(SystemVerilogParserQUOTE)
		}
		{
			p.SetState(6015)
			p.Match(SystemVerilogParserLC)
		}
		p.SetState(6037)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 741, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(6016)
				p.Pattern()
			}
			p.SetState(6021)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SystemVerilogParserCOMMA {
				{
					p.SetState(6017)
					p.Match(SystemVerilogParserCOMMA)
				}
				{
					p.SetState(6018)
					p.Pattern()
				}

				p.SetState(6023)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		case 2:
			{
				p.SetState(6024)
				p.Member_identifier()
			}
			{
				p.SetState(6025)
				p.Match(SystemVerilogParserCOLON)
			}
			{
				p.SetState(6026)
				p.Pattern()
			}
			p.SetState(6034)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SystemVerilogParserCOMMA {
				{
					p.SetState(6027)
					p.Match(SystemVerilogParserCOMMA)
				}
				{
					p.SetState(6028)
					p.Member_identifier()
				}
				{
					p.SetState(6029)
					p.Match(SystemVerilogParserCOLON)
				}
				{
					p.SetState(6030)
					p.Pattern()
				}

				p.SetState(6036)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(6039)
			p.Match(SystemVerilogParserRC)
		}

	}

	return localctx
}

// IAssignment_patternContext is an interface to support dynamic dispatch.
type IAssignment_patternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignment_patternContext differentiates from other interfaces.
	IsAssignment_patternContext()
}

type Assignment_patternContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignment_patternContext() *Assignment_patternContext {
	var p = new(Assignment_patternContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_assignment_pattern
	return p
}

func (*Assignment_patternContext) IsAssignment_patternContext() {}

func NewAssignment_patternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Assignment_patternContext {
	var p = new(Assignment_patternContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_assignment_pattern

	return p
}

func (s *Assignment_patternContext) GetParser() antlr.Parser { return s.parser }

func (s *Assignment_patternContext) QUOTE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserQUOTE, 0)
}

func (s *Assignment_patternContext) AllLC() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserLC)
}

func (s *Assignment_patternContext) LC(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLC, i)
}

func (s *Assignment_patternContext) AllRC() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserRC)
}

func (s *Assignment_patternContext) RC(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRC, i)
}

func (s *Assignment_patternContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *Assignment_patternContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Assignment_patternContext) AllStructure_pattern_key() []IStructure_pattern_keyContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStructure_pattern_keyContext)(nil)).Elem())
	var tst = make([]IStructure_pattern_keyContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStructure_pattern_keyContext)
		}
	}

	return tst
}

func (s *Assignment_patternContext) Structure_pattern_key(i int) IStructure_pattern_keyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStructure_pattern_keyContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStructure_pattern_keyContext)
}

func (s *Assignment_patternContext) AllCOLON() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOLON)
}

func (s *Assignment_patternContext) COLON(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOLON, i)
}

func (s *Assignment_patternContext) AllArray_pattern_key() []IArray_pattern_keyContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IArray_pattern_keyContext)(nil)).Elem())
	var tst = make([]IArray_pattern_keyContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IArray_pattern_keyContext)
		}
	}

	return tst
}

func (s *Assignment_patternContext) Array_pattern_key(i int) IArray_pattern_keyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArray_pattern_keyContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IArray_pattern_keyContext)
}

func (s *Assignment_patternContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Assignment_patternContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *Assignment_patternContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *Assignment_patternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Assignment_patternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Assignment_patternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterAssignment_pattern(s)
	}
}

func (s *Assignment_patternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitAssignment_pattern(s)
	}
}

func (p *SystemVerilogParser) Assignment_pattern() (localctx IAssignment_patternContext) {
	this := p
	_ = this

	localctx = NewAssignment_patternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 780, SystemVerilogParserRULE_assignment_pattern)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6043)
		p.Match(SystemVerilogParserQUOTE)
	}
	{
		p.SetState(6044)
		p.Match(SystemVerilogParserLC)
	}
	p.SetState(6091)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 747, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(6045)
			p.expression(0)
		}
		p.SetState(6050)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserCOMMA {
			{
				p.SetState(6046)
				p.Match(SystemVerilogParserCOMMA)
			}
			{
				p.SetState(6047)
				p.expression(0)
			}

			p.SetState(6052)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		{
			p.SetState(6053)
			p.Structure_pattern_key()
		}
		{
			p.SetState(6054)
			p.Match(SystemVerilogParserCOLON)
		}
		{
			p.SetState(6055)
			p.expression(0)
		}
		p.SetState(6063)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserCOMMA {
			{
				p.SetState(6056)
				p.Match(SystemVerilogParserCOMMA)
			}
			{
				p.SetState(6057)
				p.Structure_pattern_key()
			}
			{
				p.SetState(6058)
				p.Match(SystemVerilogParserCOLON)
			}
			{
				p.SetState(6059)
				p.expression(0)
			}

			p.SetState(6065)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 3:
		{
			p.SetState(6066)
			p.Array_pattern_key()
		}
		{
			p.SetState(6067)
			p.Match(SystemVerilogParserCOLON)
		}
		{
			p.SetState(6068)
			p.expression(0)
		}
		p.SetState(6076)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserCOMMA {
			{
				p.SetState(6069)
				p.Match(SystemVerilogParserCOMMA)
			}
			{
				p.SetState(6070)
				p.Array_pattern_key()
			}
			{
				p.SetState(6071)
				p.Match(SystemVerilogParserCOLON)
			}
			{
				p.SetState(6072)
				p.expression(0)
			}

			p.SetState(6078)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 4:
		{
			p.SetState(6079)
			p.constant_expression(0)
		}
		{
			p.SetState(6080)
			p.Match(SystemVerilogParserLC)
		}
		{
			p.SetState(6081)
			p.expression(0)
		}
		p.SetState(6086)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserCOMMA {
			{
				p.SetState(6082)
				p.Match(SystemVerilogParserCOMMA)
			}
			{
				p.SetState(6083)
				p.expression(0)
			}

			p.SetState(6088)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(6089)
			p.Match(SystemVerilogParserRC)
		}

	}
	{
		p.SetState(6093)
		p.Match(SystemVerilogParserRC)
	}

	return localctx
}

// IStructure_pattern_keyContext is an interface to support dynamic dispatch.
type IStructure_pattern_keyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStructure_pattern_keyContext differentiates from other interfaces.
	IsStructure_pattern_keyContext()
}

type Structure_pattern_keyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStructure_pattern_keyContext() *Structure_pattern_keyContext {
	var p = new(Structure_pattern_keyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_structure_pattern_key
	return p
}

func (*Structure_pattern_keyContext) IsStructure_pattern_keyContext() {}

func NewStructure_pattern_keyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Structure_pattern_keyContext {
	var p = new(Structure_pattern_keyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_structure_pattern_key

	return p
}

func (s *Structure_pattern_keyContext) GetParser() antlr.Parser { return s.parser }

func (s *Structure_pattern_keyContext) Member_identifier() IMember_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMember_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMember_identifierContext)
}

func (s *Structure_pattern_keyContext) Assignment_pattern_key() IAssignment_pattern_keyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignment_pattern_keyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignment_pattern_keyContext)
}

func (s *Structure_pattern_keyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Structure_pattern_keyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Structure_pattern_keyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterStructure_pattern_key(s)
	}
}

func (s *Structure_pattern_keyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitStructure_pattern_key(s)
	}
}

func (p *SystemVerilogParser) Structure_pattern_key() (localctx IStructure_pattern_keyContext) {
	this := p
	_ = this

	localctx = NewStructure_pattern_keyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 782, SystemVerilogParserRULE_structure_pattern_key)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6097)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 748, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6095)
			p.Member_identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6096)
			p.Assignment_pattern_key()
		}

	}

	return localctx
}

// IArray_pattern_keyContext is an interface to support dynamic dispatch.
type IArray_pattern_keyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArray_pattern_keyContext differentiates from other interfaces.
	IsArray_pattern_keyContext()
}

type Array_pattern_keyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArray_pattern_keyContext() *Array_pattern_keyContext {
	var p = new(Array_pattern_keyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_array_pattern_key
	return p
}

func (*Array_pattern_keyContext) IsArray_pattern_keyContext() {}

func NewArray_pattern_keyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Array_pattern_keyContext {
	var p = new(Array_pattern_keyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_array_pattern_key

	return p
}

func (s *Array_pattern_keyContext) GetParser() antlr.Parser { return s.parser }

func (s *Array_pattern_keyContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Array_pattern_keyContext) Assignment_pattern_key() IAssignment_pattern_keyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignment_pattern_keyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignment_pattern_keyContext)
}

func (s *Array_pattern_keyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Array_pattern_keyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Array_pattern_keyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterArray_pattern_key(s)
	}
}

func (s *Array_pattern_keyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitArray_pattern_key(s)
	}
}

func (p *SystemVerilogParser) Array_pattern_key() (localctx IArray_pattern_keyContext) {
	this := p
	_ = this

	localctx = NewArray_pattern_keyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 784, SystemVerilogParserRULE_array_pattern_key)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6101)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 749, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6099)
			p.constant_expression(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6100)
			p.Assignment_pattern_key()
		}

	}

	return localctx
}

// IAssignment_pattern_keyContext is an interface to support dynamic dispatch.
type IAssignment_pattern_keyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignment_pattern_keyContext differentiates from other interfaces.
	IsAssignment_pattern_keyContext()
}

type Assignment_pattern_keyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignment_pattern_keyContext() *Assignment_pattern_keyContext {
	var p = new(Assignment_pattern_keyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_assignment_pattern_key
	return p
}

func (*Assignment_pattern_keyContext) IsAssignment_pattern_keyContext() {}

func NewAssignment_pattern_keyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Assignment_pattern_keyContext {
	var p = new(Assignment_pattern_keyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_assignment_pattern_key

	return p
}

func (s *Assignment_pattern_keyContext) GetParser() antlr.Parser { return s.parser }

func (s *Assignment_pattern_keyContext) Simple_type() ISimple_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimple_typeContext)
}

func (s *Assignment_pattern_keyContext) KDEFAULT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKDEFAULT, 0)
}

func (s *Assignment_pattern_keyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Assignment_pattern_keyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Assignment_pattern_keyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterAssignment_pattern_key(s)
	}
}

func (s *Assignment_pattern_keyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitAssignment_pattern_key(s)
	}
}

func (p *SystemVerilogParser) Assignment_pattern_key() (localctx IAssignment_pattern_keyContext) {
	this := p
	_ = this

	localctx = NewAssignment_pattern_keyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 786, SystemVerilogParserRULE_assignment_pattern_key)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6105)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserDUNIT, SystemVerilogParserKBIT, SystemVerilogParserKBYTE, SystemVerilogParserKINT, SystemVerilogParserKINTEGER, SystemVerilogParserKLOCAL, SystemVerilogParserKLOGIC, SystemVerilogParserKLONGINT, SystemVerilogParserKREAL, SystemVerilogParserKREALTIME, SystemVerilogParserKREG, SystemVerilogParserKSHORTINT, SystemVerilogParserKSHORTREAL, SystemVerilogParserKTIME, SystemVerilogParserSIMPLE_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6103)
			p.Simple_type()
		}

	case SystemVerilogParserKDEFAULT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6104)
			p.Match(SystemVerilogParserKDEFAULT)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAssignment_pattern_expressionContext is an interface to support dynamic dispatch.
type IAssignment_pattern_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignment_pattern_expressionContext differentiates from other interfaces.
	IsAssignment_pattern_expressionContext()
}

type Assignment_pattern_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignment_pattern_expressionContext() *Assignment_pattern_expressionContext {
	var p = new(Assignment_pattern_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_assignment_pattern_expression
	return p
}

func (*Assignment_pattern_expressionContext) IsAssignment_pattern_expressionContext() {}

func NewAssignment_pattern_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Assignment_pattern_expressionContext {
	var p = new(Assignment_pattern_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_assignment_pattern_expression

	return p
}

func (s *Assignment_pattern_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Assignment_pattern_expressionContext) Assignment_pattern() IAssignment_patternContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignment_patternContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignment_patternContext)
}

func (s *Assignment_pattern_expressionContext) Assignment_pattern_expression_type() IAssignment_pattern_expression_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignment_pattern_expression_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignment_pattern_expression_typeContext)
}

func (s *Assignment_pattern_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Assignment_pattern_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Assignment_pattern_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterAssignment_pattern_expression(s)
	}
}

func (s *Assignment_pattern_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitAssignment_pattern_expression(s)
	}
}

func (p *SystemVerilogParser) Assignment_pattern_expression() (localctx IAssignment_pattern_expressionContext) {
	this := p
	_ = this

	localctx = NewAssignment_pattern_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 788, SystemVerilogParserRULE_assignment_pattern_expression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(6108)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserDUNIT || _la == SystemVerilogParserKBYTE || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SystemVerilogParserKINT-195))|(1<<(SystemVerilogParserKINTEGER-195))|(1<<(SystemVerilogParserKLOCAL-195))|(1<<(SystemVerilogParserKLONGINT-195)))) != 0) || _la == SystemVerilogParserKSHORTINT || _la == SystemVerilogParserKTIME || _la == SystemVerilogParserKTYPE || _la == SystemVerilogParserSIMPLE_IDENTIFIER {
		{
			p.SetState(6107)
			p.Assignment_pattern_expression_type()
		}

	}
	{
		p.SetState(6110)
		p.Assignment_pattern()
	}

	return localctx
}

// IAssignment_pattern_expression_typeContext is an interface to support dynamic dispatch.
type IAssignment_pattern_expression_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignment_pattern_expression_typeContext differentiates from other interfaces.
	IsAssignment_pattern_expression_typeContext()
}

type Assignment_pattern_expression_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignment_pattern_expression_typeContext() *Assignment_pattern_expression_typeContext {
	var p = new(Assignment_pattern_expression_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_assignment_pattern_expression_type
	return p
}

func (*Assignment_pattern_expression_typeContext) IsAssignment_pattern_expression_typeContext() {}

func NewAssignment_pattern_expression_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Assignment_pattern_expression_typeContext {
	var p = new(Assignment_pattern_expression_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_assignment_pattern_expression_type

	return p
}

func (s *Assignment_pattern_expression_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Assignment_pattern_expression_typeContext) Ps_type_identifier() IPs_type_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPs_type_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPs_type_identifierContext)
}

func (s *Assignment_pattern_expression_typeContext) Ps_parameter_identifier() IPs_parameter_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPs_parameter_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPs_parameter_identifierContext)
}

func (s *Assignment_pattern_expression_typeContext) Integer_atom_type() IInteger_atom_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInteger_atom_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInteger_atom_typeContext)
}

func (s *Assignment_pattern_expression_typeContext) Type_reference() IType_referenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_referenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_referenceContext)
}

func (s *Assignment_pattern_expression_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Assignment_pattern_expression_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Assignment_pattern_expression_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterAssignment_pattern_expression_type(s)
	}
}

func (s *Assignment_pattern_expression_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitAssignment_pattern_expression_type(s)
	}
}

func (p *SystemVerilogParser) Assignment_pattern_expression_type() (localctx IAssignment_pattern_expression_typeContext) {
	this := p
	_ = this

	localctx = NewAssignment_pattern_expression_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 790, SystemVerilogParserRULE_assignment_pattern_expression_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6116)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 752, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6112)
			p.Ps_type_identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6113)
			p.Ps_parameter_identifier()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6114)
			p.Integer_atom_type()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6115)
			p.Type_reference()
		}

	}

	return localctx
}

// IConstant_assignment_pattern_expressionContext is an interface to support dynamic dispatch.
type IConstant_assignment_pattern_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstant_assignment_pattern_expressionContext differentiates from other interfaces.
	IsConstant_assignment_pattern_expressionContext()
}

type Constant_assignment_pattern_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstant_assignment_pattern_expressionContext() *Constant_assignment_pattern_expressionContext {
	var p = new(Constant_assignment_pattern_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_constant_assignment_pattern_expression
	return p
}

func (*Constant_assignment_pattern_expressionContext) IsConstant_assignment_pattern_expressionContext() {
}

func NewConstant_assignment_pattern_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constant_assignment_pattern_expressionContext {
	var p = new(Constant_assignment_pattern_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_constant_assignment_pattern_expression

	return p
}

func (s *Constant_assignment_pattern_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Constant_assignment_pattern_expressionContext) Assignment_pattern_expression() IAssignment_pattern_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignment_pattern_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignment_pattern_expressionContext)
}

func (s *Constant_assignment_pattern_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constant_assignment_pattern_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constant_assignment_pattern_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterConstant_assignment_pattern_expression(s)
	}
}

func (s *Constant_assignment_pattern_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitConstant_assignment_pattern_expression(s)
	}
}

func (p *SystemVerilogParser) Constant_assignment_pattern_expression() (localctx IConstant_assignment_pattern_expressionContext) {
	this := p
	_ = this

	localctx = NewConstant_assignment_pattern_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 792, SystemVerilogParserRULE_constant_assignment_pattern_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6118)
		p.Assignment_pattern_expression()
	}

	return localctx
}

// IAssignment_pattern_net_lvalueContext is an interface to support dynamic dispatch.
type IAssignment_pattern_net_lvalueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignment_pattern_net_lvalueContext differentiates from other interfaces.
	IsAssignment_pattern_net_lvalueContext()
}

type Assignment_pattern_net_lvalueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignment_pattern_net_lvalueContext() *Assignment_pattern_net_lvalueContext {
	var p = new(Assignment_pattern_net_lvalueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_assignment_pattern_net_lvalue
	return p
}

func (*Assignment_pattern_net_lvalueContext) IsAssignment_pattern_net_lvalueContext() {}

func NewAssignment_pattern_net_lvalueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Assignment_pattern_net_lvalueContext {
	var p = new(Assignment_pattern_net_lvalueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_assignment_pattern_net_lvalue

	return p
}

func (s *Assignment_pattern_net_lvalueContext) GetParser() antlr.Parser { return s.parser }

func (s *Assignment_pattern_net_lvalueContext) QUOTE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserQUOTE, 0)
}

func (s *Assignment_pattern_net_lvalueContext) LC() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLC, 0)
}

func (s *Assignment_pattern_net_lvalueContext) AllNet_lvalue() []INet_lvalueContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INet_lvalueContext)(nil)).Elem())
	var tst = make([]INet_lvalueContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INet_lvalueContext)
		}
	}

	return tst
}

func (s *Assignment_pattern_net_lvalueContext) Net_lvalue(i int) INet_lvalueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_lvalueContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INet_lvalueContext)
}

func (s *Assignment_pattern_net_lvalueContext) RC() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRC, 0)
}

func (s *Assignment_pattern_net_lvalueContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *Assignment_pattern_net_lvalueContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *Assignment_pattern_net_lvalueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Assignment_pattern_net_lvalueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Assignment_pattern_net_lvalueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterAssignment_pattern_net_lvalue(s)
	}
}

func (s *Assignment_pattern_net_lvalueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitAssignment_pattern_net_lvalue(s)
	}
}

func (p *SystemVerilogParser) Assignment_pattern_net_lvalue() (localctx IAssignment_pattern_net_lvalueContext) {
	this := p
	_ = this

	localctx = NewAssignment_pattern_net_lvalueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 794, SystemVerilogParserRULE_assignment_pattern_net_lvalue)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6120)
		p.Match(SystemVerilogParserQUOTE)
	}
	{
		p.SetState(6121)
		p.Match(SystemVerilogParserLC)
	}
	{
		p.SetState(6122)
		p.Net_lvalue()
	}
	p.SetState(6127)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserCOMMA {
		{
			p.SetState(6123)
			p.Match(SystemVerilogParserCOMMA)
		}
		{
			p.SetState(6124)
			p.Net_lvalue()
		}

		p.SetState(6129)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(6130)
		p.Match(SystemVerilogParserRC)
	}

	return localctx
}

// IAssignment_pattern_variable_lvalueContext is an interface to support dynamic dispatch.
type IAssignment_pattern_variable_lvalueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignment_pattern_variable_lvalueContext differentiates from other interfaces.
	IsAssignment_pattern_variable_lvalueContext()
}

type Assignment_pattern_variable_lvalueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignment_pattern_variable_lvalueContext() *Assignment_pattern_variable_lvalueContext {
	var p = new(Assignment_pattern_variable_lvalueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_assignment_pattern_variable_lvalue
	return p
}

func (*Assignment_pattern_variable_lvalueContext) IsAssignment_pattern_variable_lvalueContext() {}

func NewAssignment_pattern_variable_lvalueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Assignment_pattern_variable_lvalueContext {
	var p = new(Assignment_pattern_variable_lvalueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_assignment_pattern_variable_lvalue

	return p
}

func (s *Assignment_pattern_variable_lvalueContext) GetParser() antlr.Parser { return s.parser }

func (s *Assignment_pattern_variable_lvalueContext) QUOTE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserQUOTE, 0)
}

func (s *Assignment_pattern_variable_lvalueContext) LC() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLC, 0)
}

func (s *Assignment_pattern_variable_lvalueContext) AllVariable_lvalue() []IVariable_lvalueContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariable_lvalueContext)(nil)).Elem())
	var tst = make([]IVariable_lvalueContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariable_lvalueContext)
		}
	}

	return tst
}

func (s *Assignment_pattern_variable_lvalueContext) Variable_lvalue(i int) IVariable_lvalueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_lvalueContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariable_lvalueContext)
}

func (s *Assignment_pattern_variable_lvalueContext) RC() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRC, 0)
}

func (s *Assignment_pattern_variable_lvalueContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *Assignment_pattern_variable_lvalueContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *Assignment_pattern_variable_lvalueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Assignment_pattern_variable_lvalueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Assignment_pattern_variable_lvalueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterAssignment_pattern_variable_lvalue(s)
	}
}

func (s *Assignment_pattern_variable_lvalueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitAssignment_pattern_variable_lvalue(s)
	}
}

func (p *SystemVerilogParser) Assignment_pattern_variable_lvalue() (localctx IAssignment_pattern_variable_lvalueContext) {
	this := p
	_ = this

	localctx = NewAssignment_pattern_variable_lvalueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 796, SystemVerilogParserRULE_assignment_pattern_variable_lvalue)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6132)
		p.Match(SystemVerilogParserQUOTE)
	}
	{
		p.SetState(6133)
		p.Match(SystemVerilogParserLC)
	}
	{
		p.SetState(6134)
		p.Variable_lvalue()
	}
	p.SetState(6139)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserCOMMA {
		{
			p.SetState(6135)
			p.Match(SystemVerilogParserCOMMA)
		}
		{
			p.SetState(6136)
			p.Variable_lvalue()
		}

		p.SetState(6141)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(6142)
		p.Match(SystemVerilogParserRC)
	}

	return localctx
}

// ILoop_statementContext is an interface to support dynamic dispatch.
type ILoop_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLoop_statementContext differentiates from other interfaces.
	IsLoop_statementContext()
}

type Loop_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLoop_statementContext() *Loop_statementContext {
	var p = new(Loop_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_loop_statement
	return p
}

func (*Loop_statementContext) IsLoop_statementContext() {}

func NewLoop_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Loop_statementContext {
	var p = new(Loop_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_loop_statement

	return p
}

func (s *Loop_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Loop_statementContext) KFOREVER() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKFOREVER, 0)
}

func (s *Loop_statementContext) Statement_or_null() IStatement_or_nullContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatement_or_nullContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatement_or_nullContext)
}

func (s *Loop_statementContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Loop_statementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Loop_statementContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Loop_statementContext) KREPEAT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKREPEAT, 0)
}

func (s *Loop_statementContext) KWHILE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKWHILE, 0)
}

func (s *Loop_statementContext) KFOR() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKFOR, 0)
}

func (s *Loop_statementContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserSEMI)
}

func (s *Loop_statementContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, i)
}

func (s *Loop_statementContext) For_initialization() IFor_initializationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFor_initializationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFor_initializationContext)
}

func (s *Loop_statementContext) For_step() IFor_stepContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFor_stepContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFor_stepContext)
}

func (s *Loop_statementContext) KDO() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKDO, 0)
}

func (s *Loop_statementContext) KFOREACH() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKFOREACH, 0)
}

func (s *Loop_statementContext) Ps_or_hierarchical_array_identifier() IPs_or_hierarchical_array_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPs_or_hierarchical_array_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPs_or_hierarchical_array_identifierContext)
}

func (s *Loop_statementContext) LB() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLB, 0)
}

func (s *Loop_statementContext) Loop_variables() ILoop_variablesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILoop_variablesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILoop_variablesContext)
}

func (s *Loop_statementContext) RB() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRB, 0)
}

func (s *Loop_statementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *Loop_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Loop_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Loop_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterLoop_statement(s)
	}
}

func (s *Loop_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitLoop_statement(s)
	}
}

func (p *SystemVerilogParser) Loop_statement() (localctx ILoop_statementContext) {
	this := p
	_ = this

	localctx = NewLoop_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 798, SystemVerilogParserRULE_loop_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6184)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserKFOREVER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6144)
			p.Match(SystemVerilogParserKFOREVER)
		}
		{
			p.SetState(6145)
			p.Statement_or_null()
		}

	case SystemVerilogParserKREPEAT, SystemVerilogParserKWHILE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6146)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SystemVerilogParserKREPEAT || _la == SystemVerilogParserKWHILE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(6147)
			p.Match(SystemVerilogParserLP)
		}
		{
			p.SetState(6148)
			p.expression(0)
		}
		{
			p.SetState(6149)
			p.Match(SystemVerilogParserRP)
		}
		{
			p.SetState(6150)
			p.Statement_or_null()
		}

	case SystemVerilogParserKFOR:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6152)
			p.Match(SystemVerilogParserKFOR)
		}
		{
			p.SetState(6153)
			p.Match(SystemVerilogParserLP)
		}
		p.SetState(6155)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserDROOT || _la == SystemVerilogParserDUNIT || _la == SystemVerilogParserQUOTE || _la == SystemVerilogParserLC || (((_la-109)&-(0x1f+1)) == 0 && ((1<<uint((_la-109)))&((1<<(SystemVerilogParserKBIT-109))|(1<<(SystemVerilogParserKBYTE-109))|(1<<(SystemVerilogParserKCHANDLE-109)))) != 0) || _la == SystemVerilogParserKENUM || _la == SystemVerilogParserKEVENT || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SystemVerilogParserKINT-195))|(1<<(SystemVerilogParserKINTEGER-195))|(1<<(SystemVerilogParserKLOCAL-195))|(1<<(SystemVerilogParserKLOGIC-195))|(1<<(SystemVerilogParserKLONGINT-195)))) != 0) || (((_la-255)&-(0x1f+1)) == 0 && ((1<<uint((_la-255)))&((1<<(SystemVerilogParserKREAL-255))|(1<<(SystemVerilogParserKREALTIME-255))|(1<<(SystemVerilogParserKREG-255))|(1<<(SystemVerilogParserKSHORTINT-255))|(1<<(SystemVerilogParserKSHORTREAL-255)))) != 0) || (((_la-287)&-(0x1f+1)) == 0 && ((1<<uint((_la-287)))&((1<<(SystemVerilogParserKSTRING-287))|(1<<(SystemVerilogParserKSTRUCT-287))|(1<<(SystemVerilogParserKSUPER-287))|(1<<(SystemVerilogParserKTHIS-287))|(1<<(SystemVerilogParserKTIME-287))|(1<<(SystemVerilogParserKTYPE-287))|(1<<(SystemVerilogParserKUNION-287)))) != 0) || (((_la-325)&-(0x1f+1)) == 0 && ((1<<uint((_la-325)))&((1<<(SystemVerilogParserKVAR-325))|(1<<(SystemVerilogParserKVIRTUAL-325))|(1<<(SystemVerilogParserSIMPLE_IDENTIFIER-325)))) != 0) {
			{
				p.SetState(6154)
				p.For_initialization()
			}

		}
		{
			p.SetState(6157)
			p.Match(SystemVerilogParserSEMI)
		}
		p.SetState(6159)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SystemVerilogParserMINUS)|(1<<SystemVerilogParserMINUSMINS)|(1<<SystemVerilogParserNOT)|(1<<SystemVerilogParserDOLLAR)|(1<<SystemVerilogParserDROOT)|(1<<SystemVerilogParserDUNIT)|(1<<SystemVerilogParserAND)|(1<<SystemVerilogParserLP))) != 0) || (((_la-51)&-(0x1f+1)) == 0 && ((1<<uint((_la-51)))&((1<<(SystemVerilogParserQUOTE-51))|(1<<(SystemVerilogParserCARET-51))|(1<<(SystemVerilogParserCARETSQUIG-51))|(1<<(SystemVerilogParserLC-51))|(1<<(SystemVerilogParserBAR-51))|(1<<(SystemVerilogParserSQUIG-51))|(1<<(SystemVerilogParserSQUIGAND-51))|(1<<(SystemVerilogParserSQUIGCARET-51))|(1<<(SystemVerilogParserSQUIGBAR-51))|(1<<(SystemVerilogParserPLUS-51))|(1<<(SystemVerilogParserPLUSPLUS-51)))) != 0) || (((_la-109)&-(0x1f+1)) == 0 && ((1<<uint((_la-109)))&((1<<(SystemVerilogParserKBIT-109))|(1<<(SystemVerilogParserKBYTE-109))|(1<<(SystemVerilogParserKCONST-109)))) != 0) || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SystemVerilogParserKINT-195))|(1<<(SystemVerilogParserKINTEGER-195))|(1<<(SystemVerilogParserKLOCAL-195))|(1<<(SystemVerilogParserKLOGIC-195))|(1<<(SystemVerilogParserKLONGINT-195)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(SystemVerilogParserKNULL-228))|(1<<(SystemVerilogParserKRANDOMIZE-228))|(1<<(SystemVerilogParserKREAL-228))|(1<<(SystemVerilogParserKREALTIME-228))|(1<<(SystemVerilogParserKREG-228)))) != 0) || (((_la-276)&-(0x1f+1)) == 0 && ((1<<uint((_la-276)))&((1<<(SystemVerilogParserKSHORTINT-276))|(1<<(SystemVerilogParserKSHORTREAL-276))|(1<<(SystemVerilogParserKSIGNED-276))|(1<<(SystemVerilogParserKSTD-276))|(1<<(SystemVerilogParserKSTRING-276))|(1<<(SystemVerilogParserKSUPER-276))|(1<<(SystemVerilogParserKTAGGED-276))|(1<<(SystemVerilogParserKTHIS-276))|(1<<(SystemVerilogParserKTIME-276)))) != 0) || _la == SystemVerilogParserKTYPE || _la == SystemVerilogParserKUNSIGNED || (((_la-345)&-(0x1f+1)) == 0 && ((1<<uint((_la-345)))&((1<<(SystemVerilogParserTIME_LITERAL-345))|(1<<(SystemVerilogParserDECIMAL_NUMBER-345))|(1<<(SystemVerilogParserBINARY_NUMBER-345))|(1<<(SystemVerilogParserOCTAL_NUMBER-345))|(1<<(SystemVerilogParserHEX_NUMBER-345))|(1<<(SystemVerilogParserREAL_NUMBER-345))|(1<<(SystemVerilogParserUNSIGNED_NUMBER-345))|(1<<(SystemVerilogParserSTRING_LITERAL-345))|(1<<(SystemVerilogParserSIMPLE_IDENTIFIER-345))|(1<<(SystemVerilogParserSYSTEM_TF_IDENTIFIER-345)))) != 0) {
			{
				p.SetState(6158)
				p.expression(0)
			}

		}
		{
			p.SetState(6161)
			p.Match(SystemVerilogParserSEMI)
		}
		p.SetState(6163)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SystemVerilogParserMINUSMINS)|(1<<SystemVerilogParserDOLLAR)|(1<<SystemVerilogParserDROOT)|(1<<SystemVerilogParserDUNIT)|(1<<SystemVerilogParserLP))) != 0) || (((_la-51)&-(0x1f+1)) == 0 && ((1<<uint((_la-51)))&((1<<(SystemVerilogParserQUOTE-51))|(1<<(SystemVerilogParserLC-51))|(1<<(SystemVerilogParserPLUSPLUS-51)))) != 0) || _la == SystemVerilogParserKBYTE || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SystemVerilogParserKINT-195))|(1<<(SystemVerilogParserKINTEGER-195))|(1<<(SystemVerilogParserKLOCAL-195))|(1<<(SystemVerilogParserKLONGINT-195)))) != 0) || _la == SystemVerilogParserKNULL || _la == SystemVerilogParserKRANDOMIZE || (((_la-276)&-(0x1f+1)) == 0 && ((1<<uint((_la-276)))&((1<<(SystemVerilogParserKSHORTINT-276))|(1<<(SystemVerilogParserKSTD-276))|(1<<(SystemVerilogParserKSUPER-276))|(1<<(SystemVerilogParserKTHIS-276))|(1<<(SystemVerilogParserKTIME-276)))) != 0) || _la == SystemVerilogParserKTYPE || (((_la-345)&-(0x1f+1)) == 0 && ((1<<uint((_la-345)))&((1<<(SystemVerilogParserTIME_LITERAL-345))|(1<<(SystemVerilogParserDECIMAL_NUMBER-345))|(1<<(SystemVerilogParserBINARY_NUMBER-345))|(1<<(SystemVerilogParserOCTAL_NUMBER-345))|(1<<(SystemVerilogParserHEX_NUMBER-345))|(1<<(SystemVerilogParserREAL_NUMBER-345))|(1<<(SystemVerilogParserUNSIGNED_NUMBER-345))|(1<<(SystemVerilogParserSTRING_LITERAL-345))|(1<<(SystemVerilogParserSIMPLE_IDENTIFIER-345))|(1<<(SystemVerilogParserSYSTEM_TF_IDENTIFIER-345)))) != 0) {
			{
				p.SetState(6162)
				p.For_step()
			}

		}
		{
			p.SetState(6165)
			p.Match(SystemVerilogParserRP)
		}
		{
			p.SetState(6166)
			p.Statement_or_null()
		}

	case SystemVerilogParserKDO:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6167)
			p.Match(SystemVerilogParserKDO)
		}
		{
			p.SetState(6168)
			p.Statement_or_null()
		}
		{
			p.SetState(6169)
			p.Match(SystemVerilogParserKWHILE)
		}
		{
			p.SetState(6170)
			p.Match(SystemVerilogParserLP)
		}
		{
			p.SetState(6171)
			p.expression(0)
		}
		{
			p.SetState(6172)
			p.Match(SystemVerilogParserRP)
		}
		{
			p.SetState(6173)
			p.Match(SystemVerilogParserSEMI)
		}

	case SystemVerilogParserKFOREACH:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6175)
			p.Match(SystemVerilogParserKFOREACH)
		}
		{
			p.SetState(6176)
			p.Match(SystemVerilogParserLP)
		}
		{
			p.SetState(6177)
			p.Ps_or_hierarchical_array_identifier()
		}
		{
			p.SetState(6178)
			p.Match(SystemVerilogParserLB)
		}
		{
			p.SetState(6179)
			p.Loop_variables()
		}
		{
			p.SetState(6180)
			p.Match(SystemVerilogParserRB)
		}
		{
			p.SetState(6181)
			p.Match(SystemVerilogParserRP)
		}
		{
			p.SetState(6182)
			p.Statement()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFor_initializationContext is an interface to support dynamic dispatch.
type IFor_initializationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFor_initializationContext differentiates from other interfaces.
	IsFor_initializationContext()
}

type For_initializationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFor_initializationContext() *For_initializationContext {
	var p = new(For_initializationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_for_initialization
	return p
}

func (*For_initializationContext) IsFor_initializationContext() {}

func NewFor_initializationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *For_initializationContext {
	var p = new(For_initializationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_for_initialization

	return p
}

func (s *For_initializationContext) GetParser() antlr.Parser { return s.parser }

func (s *For_initializationContext) List_of_variable_assignments() IList_of_variable_assignmentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_variable_assignmentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_variable_assignmentsContext)
}

func (s *For_initializationContext) AllFor_variable_declaration() []IFor_variable_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFor_variable_declarationContext)(nil)).Elem())
	var tst = make([]IFor_variable_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFor_variable_declarationContext)
		}
	}

	return tst
}

func (s *For_initializationContext) For_variable_declaration(i int) IFor_variable_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFor_variable_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFor_variable_declarationContext)
}

func (s *For_initializationContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *For_initializationContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *For_initializationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *For_initializationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *For_initializationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterFor_initialization(s)
	}
}

func (s *For_initializationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitFor_initialization(s)
	}
}

func (p *SystemVerilogParser) For_initialization() (localctx IFor_initializationContext) {
	this := p
	_ = this

	localctx = NewFor_initializationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 800, SystemVerilogParserRULE_for_initialization)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6195)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 760, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6186)
			p.List_of_variable_assignments()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6187)
			p.For_variable_declaration()
		}
		p.SetState(6192)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserCOMMA {
			{
				p.SetState(6188)
				p.Match(SystemVerilogParserCOMMA)
			}
			{
				p.SetState(6189)
				p.For_variable_declaration()
			}

			p.SetState(6194)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// IFor_variable_declarationContext is an interface to support dynamic dispatch.
type IFor_variable_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFor_variable_declarationContext differentiates from other interfaces.
	IsFor_variable_declarationContext()
}

type For_variable_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFor_variable_declarationContext() *For_variable_declarationContext {
	var p = new(For_variable_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_for_variable_declaration
	return p
}

func (*For_variable_declarationContext) IsFor_variable_declarationContext() {}

func NewFor_variable_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *For_variable_declarationContext {
	var p = new(For_variable_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_for_variable_declaration

	return p
}

func (s *For_variable_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *For_variable_declarationContext) Data_type() IData_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IData_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IData_typeContext)
}

func (s *For_variable_declarationContext) AllVariable_identifier() []IVariable_identifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariable_identifierContext)(nil)).Elem())
	var tst = make([]IVariable_identifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariable_identifierContext)
		}
	}

	return tst
}

func (s *For_variable_declarationContext) Variable_identifier(i int) IVariable_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_identifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariable_identifierContext)
}

func (s *For_variable_declarationContext) AllEQ() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserEQ)
}

func (s *For_variable_declarationContext) EQ(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserEQ, i)
}

func (s *For_variable_declarationContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *For_variable_declarationContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *For_variable_declarationContext) KVAR() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKVAR, 0)
}

func (s *For_variable_declarationContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *For_variable_declarationContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *For_variable_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *For_variable_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *For_variable_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterFor_variable_declaration(s)
	}
}

func (s *For_variable_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitFor_variable_declaration(s)
	}
}

func (p *SystemVerilogParser) For_variable_declaration() (localctx IFor_variable_declarationContext) {
	this := p
	_ = this

	localctx = NewFor_variable_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 802, SystemVerilogParserRULE_for_variable_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(6198)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserKVAR {
		{
			p.SetState(6197)
			p.Match(SystemVerilogParserKVAR)
		}

	}
	{
		p.SetState(6200)
		p.Data_type()
	}
	{
		p.SetState(6201)
		p.Variable_identifier()
	}
	{
		p.SetState(6202)
		p.Match(SystemVerilogParserEQ)
	}
	{
		p.SetState(6203)
		p.expression(0)
	}
	p.SetState(6211)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 762, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(6204)
				p.Match(SystemVerilogParserCOMMA)
			}
			{
				p.SetState(6205)
				p.Variable_identifier()
			}
			{
				p.SetState(6206)
				p.Match(SystemVerilogParserEQ)
			}
			{
				p.SetState(6207)
				p.expression(0)
			}

		}
		p.SetState(6213)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 762, p.GetParserRuleContext())
	}

	return localctx
}

// IFor_stepContext is an interface to support dynamic dispatch.
type IFor_stepContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFor_stepContext differentiates from other interfaces.
	IsFor_stepContext()
}

type For_stepContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFor_stepContext() *For_stepContext {
	var p = new(For_stepContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_for_step
	return p
}

func (*For_stepContext) IsFor_stepContext() {}

func NewFor_stepContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *For_stepContext {
	var p = new(For_stepContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_for_step

	return p
}

func (s *For_stepContext) GetParser() antlr.Parser { return s.parser }

func (s *For_stepContext) AllFor_step_assignment() []IFor_step_assignmentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFor_step_assignmentContext)(nil)).Elem())
	var tst = make([]IFor_step_assignmentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFor_step_assignmentContext)
		}
	}

	return tst
}

func (s *For_stepContext) For_step_assignment(i int) IFor_step_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFor_step_assignmentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFor_step_assignmentContext)
}

func (s *For_stepContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *For_stepContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *For_stepContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *For_stepContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *For_stepContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterFor_step(s)
	}
}

func (s *For_stepContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitFor_step(s)
	}
}

func (p *SystemVerilogParser) For_step() (localctx IFor_stepContext) {
	this := p
	_ = this

	localctx = NewFor_stepContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 804, SystemVerilogParserRULE_for_step)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6214)
		p.For_step_assignment()
	}
	p.SetState(6219)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserCOMMA {
		{
			p.SetState(6215)
			p.Match(SystemVerilogParserCOMMA)
		}
		{
			p.SetState(6216)
			p.For_step_assignment()
		}

		p.SetState(6221)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IFor_step_assignmentContext is an interface to support dynamic dispatch.
type IFor_step_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFor_step_assignmentContext differentiates from other interfaces.
	IsFor_step_assignmentContext()
}

type For_step_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFor_step_assignmentContext() *For_step_assignmentContext {
	var p = new(For_step_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_for_step_assignment
	return p
}

func (*For_step_assignmentContext) IsFor_step_assignmentContext() {}

func NewFor_step_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *For_step_assignmentContext {
	var p = new(For_step_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_for_step_assignment

	return p
}

func (s *For_step_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *For_step_assignmentContext) Operator_assignment() IOperator_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOperator_assignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOperator_assignmentContext)
}

func (s *For_step_assignmentContext) Inc_or_dec_expression() IInc_or_dec_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInc_or_dec_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInc_or_dec_expressionContext)
}

func (s *For_step_assignmentContext) Function_subroutine_call() IFunction_subroutine_callContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_subroutine_callContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_subroutine_callContext)
}

func (s *For_step_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *For_step_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *For_step_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterFor_step_assignment(s)
	}
}

func (s *For_step_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitFor_step_assignment(s)
	}
}

func (p *SystemVerilogParser) For_step_assignment() (localctx IFor_step_assignmentContext) {
	this := p
	_ = this

	localctx = NewFor_step_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 806, SystemVerilogParserRULE_for_step_assignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6225)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 764, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6222)
			p.Operator_assignment()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6223)
			p.Inc_or_dec_expression()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6224)
			p.Function_subroutine_call()
		}

	}

	return localctx
}

// ILoop_variablesContext is an interface to support dynamic dispatch.
type ILoop_variablesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLoop_variablesContext differentiates from other interfaces.
	IsLoop_variablesContext()
}

type Loop_variablesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLoop_variablesContext() *Loop_variablesContext {
	var p = new(Loop_variablesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_loop_variables
	return p
}

func (*Loop_variablesContext) IsLoop_variablesContext() {}

func NewLoop_variablesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Loop_variablesContext {
	var p = new(Loop_variablesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_loop_variables

	return p
}

func (s *Loop_variablesContext) GetParser() antlr.Parser { return s.parser }

func (s *Loop_variablesContext) AllIndex_variable_identifier() []IIndex_variable_identifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIndex_variable_identifierContext)(nil)).Elem())
	var tst = make([]IIndex_variable_identifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIndex_variable_identifierContext)
		}
	}

	return tst
}

func (s *Loop_variablesContext) Index_variable_identifier(i int) IIndex_variable_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIndex_variable_identifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIndex_variable_identifierContext)
}

func (s *Loop_variablesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *Loop_variablesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *Loop_variablesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Loop_variablesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Loop_variablesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterLoop_variables(s)
	}
}

func (s *Loop_variablesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitLoop_variables(s)
	}
}

func (p *SystemVerilogParser) Loop_variables() (localctx ILoop_variablesContext) {
	this := p
	_ = this

	localctx = NewLoop_variablesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 808, SystemVerilogParserRULE_loop_variables)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(6228)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserSIMPLE_IDENTIFIER {
		{
			p.SetState(6227)
			p.Index_variable_identifier()
		}

	}
	p.SetState(6236)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserCOMMA {
		{
			p.SetState(6230)
			p.Match(SystemVerilogParserCOMMA)
		}
		p.SetState(6232)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserSIMPLE_IDENTIFIER {
			{
				p.SetState(6231)
				p.Index_variable_identifier()
			}

		}

		p.SetState(6238)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISubroutine_call_statementContext is an interface to support dynamic dispatch.
type ISubroutine_call_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubroutine_call_statementContext differentiates from other interfaces.
	IsSubroutine_call_statementContext()
}

type Subroutine_call_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubroutine_call_statementContext() *Subroutine_call_statementContext {
	var p = new(Subroutine_call_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_subroutine_call_statement
	return p
}

func (*Subroutine_call_statementContext) IsSubroutine_call_statementContext() {}

func NewSubroutine_call_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Subroutine_call_statementContext {
	var p = new(Subroutine_call_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_subroutine_call_statement

	return p
}

func (s *Subroutine_call_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Subroutine_call_statementContext) Subroutine_call() ISubroutine_callContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubroutine_callContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubroutine_callContext)
}

func (s *Subroutine_call_statementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Subroutine_call_statementContext) KVOID() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKVOID, 0)
}

func (s *Subroutine_call_statementContext) QUOTE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserQUOTE, 0)
}

func (s *Subroutine_call_statementContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Subroutine_call_statementContext) Function_subroutine_call() IFunction_subroutine_callContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_subroutine_callContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_subroutine_callContext)
}

func (s *Subroutine_call_statementContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Subroutine_call_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Subroutine_call_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Subroutine_call_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterSubroutine_call_statement(s)
	}
}

func (s *Subroutine_call_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitSubroutine_call_statement(s)
	}
}

func (p *SystemVerilogParser) Subroutine_call_statement() (localctx ISubroutine_call_statementContext) {
	this := p
	_ = this

	localctx = NewSubroutine_call_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 810, SystemVerilogParserRULE_subroutine_call_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6249)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserDOLLAR, SystemVerilogParserDROOT, SystemVerilogParserDUNIT, SystemVerilogParserLP, SystemVerilogParserQUOTE, SystemVerilogParserLC, SystemVerilogParserKBYTE, SystemVerilogParserKINT, SystemVerilogParserKINTEGER, SystemVerilogParserKLOCAL, SystemVerilogParserKLONGINT, SystemVerilogParserKNULL, SystemVerilogParserKRANDOMIZE, SystemVerilogParserKSHORTINT, SystemVerilogParserKSTD, SystemVerilogParserKSUPER, SystemVerilogParserKTHIS, SystemVerilogParserKTIME, SystemVerilogParserKTYPE, SystemVerilogParserTIME_LITERAL, SystemVerilogParserDECIMAL_NUMBER, SystemVerilogParserBINARY_NUMBER, SystemVerilogParserOCTAL_NUMBER, SystemVerilogParserHEX_NUMBER, SystemVerilogParserREAL_NUMBER, SystemVerilogParserUNSIGNED_NUMBER, SystemVerilogParserSTRING_LITERAL, SystemVerilogParserSIMPLE_IDENTIFIER, SystemVerilogParserSYSTEM_TF_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6239)
			p.Subroutine_call()
		}
		{
			p.SetState(6240)
			p.Match(SystemVerilogParserSEMI)
		}

	case SystemVerilogParserKVOID:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6242)
			p.Match(SystemVerilogParserKVOID)
		}
		{
			p.SetState(6243)
			p.Match(SystemVerilogParserQUOTE)
		}
		{
			p.SetState(6244)
			p.Match(SystemVerilogParserLP)
		}
		{
			p.SetState(6245)
			p.Function_subroutine_call()
		}
		{
			p.SetState(6246)
			p.Match(SystemVerilogParserRP)
		}
		{
			p.SetState(6247)
			p.Match(SystemVerilogParserSEMI)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAssertion_itemContext is an interface to support dynamic dispatch.
type IAssertion_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssertion_itemContext differentiates from other interfaces.
	IsAssertion_itemContext()
}

type Assertion_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssertion_itemContext() *Assertion_itemContext {
	var p = new(Assertion_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_assertion_item
	return p
}

func (*Assertion_itemContext) IsAssertion_itemContext() {}

func NewAssertion_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Assertion_itemContext {
	var p = new(Assertion_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_assertion_item

	return p
}

func (s *Assertion_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Assertion_itemContext) Concurrent_assertion_item() IConcurrent_assertion_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConcurrent_assertion_itemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConcurrent_assertion_itemContext)
}

func (s *Assertion_itemContext) Deferred_immediate_assertion_item() IDeferred_immediate_assertion_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeferred_immediate_assertion_itemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeferred_immediate_assertion_itemContext)
}

func (s *Assertion_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Assertion_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Assertion_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterAssertion_item(s)
	}
}

func (s *Assertion_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitAssertion_item(s)
	}
}

func (p *SystemVerilogParser) Assertion_item() (localctx IAssertion_itemContext) {
	this := p
	_ = this

	localctx = NewAssertion_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 812, SystemVerilogParserRULE_assertion_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6253)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 769, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6251)
			p.Concurrent_assertion_item()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6252)
			p.Deferred_immediate_assertion_item()
		}

	}

	return localctx
}

// IDeferred_immediate_assertion_itemContext is an interface to support dynamic dispatch.
type IDeferred_immediate_assertion_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeferred_immediate_assertion_itemContext differentiates from other interfaces.
	IsDeferred_immediate_assertion_itemContext()
}

type Deferred_immediate_assertion_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeferred_immediate_assertion_itemContext() *Deferred_immediate_assertion_itemContext {
	var p = new(Deferred_immediate_assertion_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_deferred_immediate_assertion_item
	return p
}

func (*Deferred_immediate_assertion_itemContext) IsDeferred_immediate_assertion_itemContext() {}

func NewDeferred_immediate_assertion_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Deferred_immediate_assertion_itemContext {
	var p = new(Deferred_immediate_assertion_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_deferred_immediate_assertion_item

	return p
}

func (s *Deferred_immediate_assertion_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Deferred_immediate_assertion_itemContext) Deferred_immediate_assertion_statement() IDeferred_immediate_assertion_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeferred_immediate_assertion_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeferred_immediate_assertion_statementContext)
}

func (s *Deferred_immediate_assertion_itemContext) Block_identifier() IBlock_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlock_identifierContext)
}

func (s *Deferred_immediate_assertion_itemContext) COLON() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOLON, 0)
}

func (s *Deferred_immediate_assertion_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Deferred_immediate_assertion_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Deferred_immediate_assertion_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterDeferred_immediate_assertion_item(s)
	}
}

func (s *Deferred_immediate_assertion_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitDeferred_immediate_assertion_item(s)
	}
}

func (p *SystemVerilogParser) Deferred_immediate_assertion_item() (localctx IDeferred_immediate_assertion_itemContext) {
	this := p
	_ = this

	localctx = NewDeferred_immediate_assertion_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 814, SystemVerilogParserRULE_deferred_immediate_assertion_item)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(6258)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserSIMPLE_IDENTIFIER {
		{
			p.SetState(6255)
			p.Block_identifier()
		}
		{
			p.SetState(6256)
			p.Match(SystemVerilogParserCOLON)
		}

	}
	{
		p.SetState(6260)
		p.Deferred_immediate_assertion_statement()
	}

	return localctx
}

// IProcedural_assertion_statementContext is an interface to support dynamic dispatch.
type IProcedural_assertion_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedural_assertion_statementContext differentiates from other interfaces.
	IsProcedural_assertion_statementContext()
}

type Procedural_assertion_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedural_assertion_statementContext() *Procedural_assertion_statementContext {
	var p = new(Procedural_assertion_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_procedural_assertion_statement
	return p
}

func (*Procedural_assertion_statementContext) IsProcedural_assertion_statementContext() {}

func NewProcedural_assertion_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Procedural_assertion_statementContext {
	var p = new(Procedural_assertion_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_procedural_assertion_statement

	return p
}

func (s *Procedural_assertion_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Procedural_assertion_statementContext) Concurrent_assertion_statement() IConcurrent_assertion_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConcurrent_assertion_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConcurrent_assertion_statementContext)
}

func (s *Procedural_assertion_statementContext) Immediate_assertion_statement() IImmediate_assertion_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImmediate_assertion_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImmediate_assertion_statementContext)
}

func (s *Procedural_assertion_statementContext) Checker_instantiation() IChecker_instantiationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IChecker_instantiationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IChecker_instantiationContext)
}

func (s *Procedural_assertion_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Procedural_assertion_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Procedural_assertion_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterProcedural_assertion_statement(s)
	}
}

func (s *Procedural_assertion_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitProcedural_assertion_statement(s)
	}
}

func (p *SystemVerilogParser) Procedural_assertion_statement() (localctx IProcedural_assertion_statementContext) {
	this := p
	_ = this

	localctx = NewProcedural_assertion_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 816, SystemVerilogParserRULE_procedural_assertion_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6265)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 771, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6262)
			p.Concurrent_assertion_statement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6263)
			p.Immediate_assertion_statement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6264)
			p.Checker_instantiation()
		}

	}

	return localctx
}

// IImmediate_assertion_statementContext is an interface to support dynamic dispatch.
type IImmediate_assertion_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImmediate_assertion_statementContext differentiates from other interfaces.
	IsImmediate_assertion_statementContext()
}

type Immediate_assertion_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImmediate_assertion_statementContext() *Immediate_assertion_statementContext {
	var p = new(Immediate_assertion_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_immediate_assertion_statement
	return p
}

func (*Immediate_assertion_statementContext) IsImmediate_assertion_statementContext() {}

func NewImmediate_assertion_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Immediate_assertion_statementContext {
	var p = new(Immediate_assertion_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_immediate_assertion_statement

	return p
}

func (s *Immediate_assertion_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Immediate_assertion_statementContext) Simple_immediate_assertion_statement() ISimple_immediate_assertion_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_immediate_assertion_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimple_immediate_assertion_statementContext)
}

func (s *Immediate_assertion_statementContext) Deferred_immediate_assertion_statement() IDeferred_immediate_assertion_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeferred_immediate_assertion_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeferred_immediate_assertion_statementContext)
}

func (s *Immediate_assertion_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Immediate_assertion_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Immediate_assertion_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterImmediate_assertion_statement(s)
	}
}

func (s *Immediate_assertion_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitImmediate_assertion_statement(s)
	}
}

func (p *SystemVerilogParser) Immediate_assertion_statement() (localctx IImmediate_assertion_statementContext) {
	this := p
	_ = this

	localctx = NewImmediate_assertion_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 818, SystemVerilogParserRULE_immediate_assertion_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6269)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 772, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6267)
			p.Simple_immediate_assertion_statement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6268)
			p.Deferred_immediate_assertion_statement()
		}

	}

	return localctx
}

// ISimple_immediate_assertion_statementContext is an interface to support dynamic dispatch.
type ISimple_immediate_assertion_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimple_immediate_assertion_statementContext differentiates from other interfaces.
	IsSimple_immediate_assertion_statementContext()
}

type Simple_immediate_assertion_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimple_immediate_assertion_statementContext() *Simple_immediate_assertion_statementContext {
	var p = new(Simple_immediate_assertion_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_simple_immediate_assertion_statement
	return p
}

func (*Simple_immediate_assertion_statementContext) IsSimple_immediate_assertion_statementContext() {}

func NewSimple_immediate_assertion_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Simple_immediate_assertion_statementContext {
	var p = new(Simple_immediate_assertion_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_simple_immediate_assertion_statement

	return p
}

func (s *Simple_immediate_assertion_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Simple_immediate_assertion_statementContext) Simple_immediate_assert_statement() ISimple_immediate_assert_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_immediate_assert_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimple_immediate_assert_statementContext)
}

func (s *Simple_immediate_assertion_statementContext) Simple_immediate_assume_statement() ISimple_immediate_assume_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_immediate_assume_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimple_immediate_assume_statementContext)
}

func (s *Simple_immediate_assertion_statementContext) Simple_immediate_cover_statement() ISimple_immediate_cover_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_immediate_cover_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimple_immediate_cover_statementContext)
}

func (s *Simple_immediate_assertion_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Simple_immediate_assertion_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Simple_immediate_assertion_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterSimple_immediate_assertion_statement(s)
	}
}

func (s *Simple_immediate_assertion_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitSimple_immediate_assertion_statement(s)
	}
}

func (p *SystemVerilogParser) Simple_immediate_assertion_statement() (localctx ISimple_immediate_assertion_statementContext) {
	this := p
	_ = this

	localctx = NewSimple_immediate_assertion_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 820, SystemVerilogParserRULE_simple_immediate_assertion_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6274)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserKASSERT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6271)
			p.Simple_immediate_assert_statement()
		}

	case SystemVerilogParserKASSUME:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6272)
			p.Simple_immediate_assume_statement()
		}

	case SystemVerilogParserKCOVER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6273)
			p.Simple_immediate_cover_statement()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISimple_immediate_assert_statementContext is an interface to support dynamic dispatch.
type ISimple_immediate_assert_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimple_immediate_assert_statementContext differentiates from other interfaces.
	IsSimple_immediate_assert_statementContext()
}

type Simple_immediate_assert_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimple_immediate_assert_statementContext() *Simple_immediate_assert_statementContext {
	var p = new(Simple_immediate_assert_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_simple_immediate_assert_statement
	return p
}

func (*Simple_immediate_assert_statementContext) IsSimple_immediate_assert_statementContext() {}

func NewSimple_immediate_assert_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Simple_immediate_assert_statementContext {
	var p = new(Simple_immediate_assert_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_simple_immediate_assert_statement

	return p
}

func (s *Simple_immediate_assert_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Simple_immediate_assert_statementContext) KASSERT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKASSERT, 0)
}

func (s *Simple_immediate_assert_statementContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Simple_immediate_assert_statementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Simple_immediate_assert_statementContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Simple_immediate_assert_statementContext) Action_block() IAction_blockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAction_blockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAction_blockContext)
}

func (s *Simple_immediate_assert_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Simple_immediate_assert_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Simple_immediate_assert_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterSimple_immediate_assert_statement(s)
	}
}

func (s *Simple_immediate_assert_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitSimple_immediate_assert_statement(s)
	}
}

func (p *SystemVerilogParser) Simple_immediate_assert_statement() (localctx ISimple_immediate_assert_statementContext) {
	this := p
	_ = this

	localctx = NewSimple_immediate_assert_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 822, SystemVerilogParserRULE_simple_immediate_assert_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6276)
		p.Match(SystemVerilogParserKASSERT)
	}
	{
		p.SetState(6277)
		p.Match(SystemVerilogParserLP)
	}
	{
		p.SetState(6278)
		p.expression(0)
	}
	{
		p.SetState(6279)
		p.Match(SystemVerilogParserRP)
	}
	{
		p.SetState(6280)
		p.Action_block()
	}

	return localctx
}

// ISimple_immediate_assume_statementContext is an interface to support dynamic dispatch.
type ISimple_immediate_assume_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimple_immediate_assume_statementContext differentiates from other interfaces.
	IsSimple_immediate_assume_statementContext()
}

type Simple_immediate_assume_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimple_immediate_assume_statementContext() *Simple_immediate_assume_statementContext {
	var p = new(Simple_immediate_assume_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_simple_immediate_assume_statement
	return p
}

func (*Simple_immediate_assume_statementContext) IsSimple_immediate_assume_statementContext() {}

func NewSimple_immediate_assume_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Simple_immediate_assume_statementContext {
	var p = new(Simple_immediate_assume_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_simple_immediate_assume_statement

	return p
}

func (s *Simple_immediate_assume_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Simple_immediate_assume_statementContext) KASSUME() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKASSUME, 0)
}

func (s *Simple_immediate_assume_statementContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Simple_immediate_assume_statementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Simple_immediate_assume_statementContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Simple_immediate_assume_statementContext) Action_block() IAction_blockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAction_blockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAction_blockContext)
}

func (s *Simple_immediate_assume_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Simple_immediate_assume_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Simple_immediate_assume_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterSimple_immediate_assume_statement(s)
	}
}

func (s *Simple_immediate_assume_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitSimple_immediate_assume_statement(s)
	}
}

func (p *SystemVerilogParser) Simple_immediate_assume_statement() (localctx ISimple_immediate_assume_statementContext) {
	this := p
	_ = this

	localctx = NewSimple_immediate_assume_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 824, SystemVerilogParserRULE_simple_immediate_assume_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6282)
		p.Match(SystemVerilogParserKASSUME)
	}
	{
		p.SetState(6283)
		p.Match(SystemVerilogParserLP)
	}
	{
		p.SetState(6284)
		p.expression(0)
	}
	{
		p.SetState(6285)
		p.Match(SystemVerilogParserRP)
	}
	{
		p.SetState(6286)
		p.Action_block()
	}

	return localctx
}

// ISimple_immediate_cover_statementContext is an interface to support dynamic dispatch.
type ISimple_immediate_cover_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimple_immediate_cover_statementContext differentiates from other interfaces.
	IsSimple_immediate_cover_statementContext()
}

type Simple_immediate_cover_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimple_immediate_cover_statementContext() *Simple_immediate_cover_statementContext {
	var p = new(Simple_immediate_cover_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_simple_immediate_cover_statement
	return p
}

func (*Simple_immediate_cover_statementContext) IsSimple_immediate_cover_statementContext() {}

func NewSimple_immediate_cover_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Simple_immediate_cover_statementContext {
	var p = new(Simple_immediate_cover_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_simple_immediate_cover_statement

	return p
}

func (s *Simple_immediate_cover_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Simple_immediate_cover_statementContext) KCOVER() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKCOVER, 0)
}

func (s *Simple_immediate_cover_statementContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Simple_immediate_cover_statementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Simple_immediate_cover_statementContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Simple_immediate_cover_statementContext) Statement_or_null() IStatement_or_nullContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatement_or_nullContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatement_or_nullContext)
}

func (s *Simple_immediate_cover_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Simple_immediate_cover_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Simple_immediate_cover_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterSimple_immediate_cover_statement(s)
	}
}

func (s *Simple_immediate_cover_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitSimple_immediate_cover_statement(s)
	}
}

func (p *SystemVerilogParser) Simple_immediate_cover_statement() (localctx ISimple_immediate_cover_statementContext) {
	this := p
	_ = this

	localctx = NewSimple_immediate_cover_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 826, SystemVerilogParserRULE_simple_immediate_cover_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6288)
		p.Match(SystemVerilogParserKCOVER)
	}
	{
		p.SetState(6289)
		p.Match(SystemVerilogParserLP)
	}
	{
		p.SetState(6290)
		p.expression(0)
	}
	{
		p.SetState(6291)
		p.Match(SystemVerilogParserRP)
	}
	{
		p.SetState(6292)
		p.Statement_or_null()
	}

	return localctx
}

// IDeferred_immediate_assertion_statementContext is an interface to support dynamic dispatch.
type IDeferred_immediate_assertion_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeferred_immediate_assertion_statementContext differentiates from other interfaces.
	IsDeferred_immediate_assertion_statementContext()
}

type Deferred_immediate_assertion_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeferred_immediate_assertion_statementContext() *Deferred_immediate_assertion_statementContext {
	var p = new(Deferred_immediate_assertion_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_deferred_immediate_assertion_statement
	return p
}

func (*Deferred_immediate_assertion_statementContext) IsDeferred_immediate_assertion_statementContext() {
}

func NewDeferred_immediate_assertion_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Deferred_immediate_assertion_statementContext {
	var p = new(Deferred_immediate_assertion_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_deferred_immediate_assertion_statement

	return p
}

func (s *Deferred_immediate_assertion_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Deferred_immediate_assertion_statementContext) Deferred_immediate_assert_statement() IDeferred_immediate_assert_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeferred_immediate_assert_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeferred_immediate_assert_statementContext)
}

func (s *Deferred_immediate_assertion_statementContext) Deferred_immediate_assume_statement() IDeferred_immediate_assume_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeferred_immediate_assume_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeferred_immediate_assume_statementContext)
}

func (s *Deferred_immediate_assertion_statementContext) Deferred_immediate_cover_statement() IDeferred_immediate_cover_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeferred_immediate_cover_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeferred_immediate_cover_statementContext)
}

func (s *Deferred_immediate_assertion_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Deferred_immediate_assertion_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Deferred_immediate_assertion_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterDeferred_immediate_assertion_statement(s)
	}
}

func (s *Deferred_immediate_assertion_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitDeferred_immediate_assertion_statement(s)
	}
}

func (p *SystemVerilogParser) Deferred_immediate_assertion_statement() (localctx IDeferred_immediate_assertion_statementContext) {
	this := p
	_ = this

	localctx = NewDeferred_immediate_assertion_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 828, SystemVerilogParserRULE_deferred_immediate_assertion_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6297)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserKASSERT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6294)
			p.Deferred_immediate_assert_statement()
		}

	case SystemVerilogParserKASSUME:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6295)
			p.Deferred_immediate_assume_statement()
		}

	case SystemVerilogParserKCOVER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6296)
			p.Deferred_immediate_cover_statement()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDeferred_immediate_assert_statementContext is an interface to support dynamic dispatch.
type IDeferred_immediate_assert_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeferred_immediate_assert_statementContext differentiates from other interfaces.
	IsDeferred_immediate_assert_statementContext()
}

type Deferred_immediate_assert_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeferred_immediate_assert_statementContext() *Deferred_immediate_assert_statementContext {
	var p = new(Deferred_immediate_assert_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_deferred_immediate_assert_statement
	return p
}

func (*Deferred_immediate_assert_statementContext) IsDeferred_immediate_assert_statementContext() {}

func NewDeferred_immediate_assert_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Deferred_immediate_assert_statementContext {
	var p = new(Deferred_immediate_assert_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_deferred_immediate_assert_statement

	return p
}

func (s *Deferred_immediate_assert_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Deferred_immediate_assert_statementContext) KASSERT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKASSERT, 0)
}

func (s *Deferred_immediate_assert_statementContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Deferred_immediate_assert_statementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Deferred_immediate_assert_statementContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Deferred_immediate_assert_statementContext) Action_block() IAction_blockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAction_blockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAction_blockContext)
}

func (s *Deferred_immediate_assert_statementContext) PZ() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserPZ, 0)
}

func (s *Deferred_immediate_assert_statementContext) KFINAL() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKFINAL, 0)
}

func (s *Deferred_immediate_assert_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Deferred_immediate_assert_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Deferred_immediate_assert_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterDeferred_immediate_assert_statement(s)
	}
}

func (s *Deferred_immediate_assert_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitDeferred_immediate_assert_statement(s)
	}
}

func (p *SystemVerilogParser) Deferred_immediate_assert_statement() (localctx IDeferred_immediate_assert_statementContext) {
	this := p
	_ = this

	localctx = NewDeferred_immediate_assert_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 830, SystemVerilogParserRULE_deferred_immediate_assert_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6299)
		p.Match(SystemVerilogParserKASSERT)
	}
	{
		p.SetState(6300)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SystemVerilogParserPZ || _la == SystemVerilogParserKFINAL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(6301)
		p.Match(SystemVerilogParserLP)
	}
	{
		p.SetState(6302)
		p.expression(0)
	}
	{
		p.SetState(6303)
		p.Match(SystemVerilogParserRP)
	}
	{
		p.SetState(6304)
		p.Action_block()
	}

	return localctx
}

// IDeferred_immediate_assume_statementContext is an interface to support dynamic dispatch.
type IDeferred_immediate_assume_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeferred_immediate_assume_statementContext differentiates from other interfaces.
	IsDeferred_immediate_assume_statementContext()
}

type Deferred_immediate_assume_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeferred_immediate_assume_statementContext() *Deferred_immediate_assume_statementContext {
	var p = new(Deferred_immediate_assume_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_deferred_immediate_assume_statement
	return p
}

func (*Deferred_immediate_assume_statementContext) IsDeferred_immediate_assume_statementContext() {}

func NewDeferred_immediate_assume_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Deferred_immediate_assume_statementContext {
	var p = new(Deferred_immediate_assume_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_deferred_immediate_assume_statement

	return p
}

func (s *Deferred_immediate_assume_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Deferred_immediate_assume_statementContext) KASSUME() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKASSUME, 0)
}

func (s *Deferred_immediate_assume_statementContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Deferred_immediate_assume_statementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Deferred_immediate_assume_statementContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Deferred_immediate_assume_statementContext) Action_block() IAction_blockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAction_blockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAction_blockContext)
}

func (s *Deferred_immediate_assume_statementContext) PZ() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserPZ, 0)
}

func (s *Deferred_immediate_assume_statementContext) KFINAL() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKFINAL, 0)
}

func (s *Deferred_immediate_assume_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Deferred_immediate_assume_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Deferred_immediate_assume_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterDeferred_immediate_assume_statement(s)
	}
}

func (s *Deferred_immediate_assume_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitDeferred_immediate_assume_statement(s)
	}
}

func (p *SystemVerilogParser) Deferred_immediate_assume_statement() (localctx IDeferred_immediate_assume_statementContext) {
	this := p
	_ = this

	localctx = NewDeferred_immediate_assume_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 832, SystemVerilogParserRULE_deferred_immediate_assume_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6306)
		p.Match(SystemVerilogParserKASSUME)
	}
	{
		p.SetState(6307)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SystemVerilogParserPZ || _la == SystemVerilogParserKFINAL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(6308)
		p.Match(SystemVerilogParserLP)
	}
	{
		p.SetState(6309)
		p.expression(0)
	}
	{
		p.SetState(6310)
		p.Match(SystemVerilogParserRP)
	}
	{
		p.SetState(6311)
		p.Action_block()
	}

	return localctx
}

// IDeferred_immediate_cover_statementContext is an interface to support dynamic dispatch.
type IDeferred_immediate_cover_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeferred_immediate_cover_statementContext differentiates from other interfaces.
	IsDeferred_immediate_cover_statementContext()
}

type Deferred_immediate_cover_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeferred_immediate_cover_statementContext() *Deferred_immediate_cover_statementContext {
	var p = new(Deferred_immediate_cover_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_deferred_immediate_cover_statement
	return p
}

func (*Deferred_immediate_cover_statementContext) IsDeferred_immediate_cover_statementContext() {}

func NewDeferred_immediate_cover_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Deferred_immediate_cover_statementContext {
	var p = new(Deferred_immediate_cover_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_deferred_immediate_cover_statement

	return p
}

func (s *Deferred_immediate_cover_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Deferred_immediate_cover_statementContext) KCOVER() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKCOVER, 0)
}

func (s *Deferred_immediate_cover_statementContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Deferred_immediate_cover_statementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Deferred_immediate_cover_statementContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Deferred_immediate_cover_statementContext) Statement_or_null() IStatement_or_nullContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatement_or_nullContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatement_or_nullContext)
}

func (s *Deferred_immediate_cover_statementContext) PZ() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserPZ, 0)
}

func (s *Deferred_immediate_cover_statementContext) KFINAL() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKFINAL, 0)
}

func (s *Deferred_immediate_cover_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Deferred_immediate_cover_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Deferred_immediate_cover_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterDeferred_immediate_cover_statement(s)
	}
}

func (s *Deferred_immediate_cover_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitDeferred_immediate_cover_statement(s)
	}
}

func (p *SystemVerilogParser) Deferred_immediate_cover_statement() (localctx IDeferred_immediate_cover_statementContext) {
	this := p
	_ = this

	localctx = NewDeferred_immediate_cover_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 834, SystemVerilogParserRULE_deferred_immediate_cover_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6313)
		p.Match(SystemVerilogParserKCOVER)
	}
	{
		p.SetState(6314)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SystemVerilogParserPZ || _la == SystemVerilogParserKFINAL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(6315)
		p.Match(SystemVerilogParserLP)
	}
	{
		p.SetState(6316)
		p.expression(0)
	}
	{
		p.SetState(6317)
		p.Match(SystemVerilogParserRP)
	}
	{
		p.SetState(6318)
		p.Statement_or_null()
	}

	return localctx
}

// IClocking_declarationContext is an interface to support dynamic dispatch.
type IClocking_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClocking_declarationContext differentiates from other interfaces.
	IsClocking_declarationContext()
}

type Clocking_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClocking_declarationContext() *Clocking_declarationContext {
	var p = new(Clocking_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_clocking_declaration
	return p
}

func (*Clocking_declarationContext) IsClocking_declarationContext() {}

func NewClocking_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Clocking_declarationContext {
	var p = new(Clocking_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_clocking_declaration

	return p
}

func (s *Clocking_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Clocking_declarationContext) KCLOCKING() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKCLOCKING, 0)
}

func (s *Clocking_declarationContext) Clocking_event() IClocking_eventContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClocking_eventContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClocking_eventContext)
}

func (s *Clocking_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Clocking_declarationContext) KENDCLOCKING() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKENDCLOCKING, 0)
}

func (s *Clocking_declarationContext) KDEFAULT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKDEFAULT, 0)
}

func (s *Clocking_declarationContext) AllClocking_identifier() []IClocking_identifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IClocking_identifierContext)(nil)).Elem())
	var tst = make([]IClocking_identifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IClocking_identifierContext)
		}
	}

	return tst
}

func (s *Clocking_declarationContext) Clocking_identifier(i int) IClocking_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClocking_identifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IClocking_identifierContext)
}

func (s *Clocking_declarationContext) AllClocking_item() []IClocking_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IClocking_itemContext)(nil)).Elem())
	var tst = make([]IClocking_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IClocking_itemContext)
		}
	}

	return tst
}

func (s *Clocking_declarationContext) Clocking_item(i int) IClocking_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClocking_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IClocking_itemContext)
}

func (s *Clocking_declarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOLON, 0)
}

func (s *Clocking_declarationContext) KGLOBAL() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKGLOBAL, 0)
}

func (s *Clocking_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Clocking_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Clocking_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterClocking_declaration(s)
	}
}

func (s *Clocking_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitClocking_declaration(s)
	}
}

func (p *SystemVerilogParser) Clocking_declaration() (localctx IClocking_declarationContext) {
	this := p
	_ = this

	localctx = NewClocking_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 836, SystemVerilogParserRULE_clocking_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6352)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserKCLOCKING, SystemVerilogParserKDEFAULT:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(6321)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserKDEFAULT {
			{
				p.SetState(6320)
				p.Match(SystemVerilogParserKDEFAULT)
			}

		}
		{
			p.SetState(6323)
			p.Match(SystemVerilogParserKCLOCKING)
		}
		p.SetState(6325)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserSIMPLE_IDENTIFIER {
			{
				p.SetState(6324)
				p.Clocking_identifier()
			}

		}
		{
			p.SetState(6327)
			p.Clocking_event()
		}
		{
			p.SetState(6328)
			p.Match(SystemVerilogParserSEMI)
		}
		p.SetState(6332)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserLPS || _la == SystemVerilogParserKDEFAULT || (((_la-191)&-(0x1f+1)) == 0 && ((1<<uint((_la-191)))&((1<<(SystemVerilogParserKINOUT-191))|(1<<(SystemVerilogParserKINPUT-191))|(1<<(SystemVerilogParserKLET-191)))) != 0) || _la == SystemVerilogParserKOUTPUT || _la == SystemVerilogParserKPROPERTY || _la == SystemVerilogParserKSEQUENCE {
			{
				p.SetState(6329)
				p.Clocking_item()
			}

			p.SetState(6334)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(6335)
			p.Match(SystemVerilogParserKENDCLOCKING)
		}
		p.SetState(6338)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserCOLON {
			{
				p.SetState(6336)
				p.Match(SystemVerilogParserCOLON)
			}
			{
				p.SetState(6337)
				p.Clocking_identifier()
			}

		}

	case SystemVerilogParserKGLOBAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6340)
			p.Match(SystemVerilogParserKGLOBAL)
		}
		{
			p.SetState(6341)
			p.Match(SystemVerilogParserKCLOCKING)
		}
		p.SetState(6343)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserSIMPLE_IDENTIFIER {
			{
				p.SetState(6342)
				p.Clocking_identifier()
			}

		}
		{
			p.SetState(6345)
			p.Clocking_event()
		}
		{
			p.SetState(6346)
			p.Match(SystemVerilogParserSEMI)
		}
		{
			p.SetState(6347)
			p.Match(SystemVerilogParserKENDCLOCKING)
		}
		p.SetState(6350)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserCOLON {
			{
				p.SetState(6348)
				p.Match(SystemVerilogParserCOLON)
			}
			{
				p.SetState(6349)
				p.Clocking_identifier()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IClocking_eventContext is an interface to support dynamic dispatch.
type IClocking_eventContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClocking_eventContext differentiates from other interfaces.
	IsClocking_eventContext()
}

type Clocking_eventContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClocking_eventContext() *Clocking_eventContext {
	var p = new(Clocking_eventContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_clocking_event
	return p
}

func (*Clocking_eventContext) IsClocking_eventContext() {}

func NewClocking_eventContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Clocking_eventContext {
	var p = new(Clocking_eventContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_clocking_event

	return p
}

func (s *Clocking_eventContext) GetParser() antlr.Parser { return s.parser }

func (s *Clocking_eventContext) AT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserAT, 0)
}

func (s *Clocking_eventContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Clocking_eventContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Clocking_eventContext) Event_expression() IEvent_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvent_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEvent_expressionContext)
}

func (s *Clocking_eventContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Clocking_eventContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Clocking_eventContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Clocking_eventContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterClocking_event(s)
	}
}

func (s *Clocking_eventContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitClocking_event(s)
	}
}

func (p *SystemVerilogParser) Clocking_event() (localctx IClocking_eventContext) {
	this := p
	_ = this

	localctx = NewClocking_eventContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 838, SystemVerilogParserRULE_clocking_event)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6354)
		p.Match(SystemVerilogParserAT)
	}
	p.SetState(6360)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserSIMPLE_IDENTIFIER:
		{
			p.SetState(6355)
			p.Identifier()
		}

	case SystemVerilogParserLP:
		{
			p.SetState(6356)
			p.Match(SystemVerilogParserLP)
		}
		{
			p.SetState(6357)
			p.event_expression(0)
		}
		{
			p.SetState(6358)
			p.Match(SystemVerilogParserRP)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IClocking_itemContext is an interface to support dynamic dispatch.
type IClocking_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClocking_itemContext differentiates from other interfaces.
	IsClocking_itemContext()
}

type Clocking_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClocking_itemContext() *Clocking_itemContext {
	var p = new(Clocking_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_clocking_item
	return p
}

func (*Clocking_itemContext) IsClocking_itemContext() {}

func NewClocking_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Clocking_itemContext {
	var p = new(Clocking_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_clocking_item

	return p
}

func (s *Clocking_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Clocking_itemContext) KDEFAULT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKDEFAULT, 0)
}

func (s *Clocking_itemContext) Default_skew() IDefault_skewContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefault_skewContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefault_skewContext)
}

func (s *Clocking_itemContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Clocking_itemContext) Clocking_direction() IClocking_directionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClocking_directionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClocking_directionContext)
}

func (s *Clocking_itemContext) List_of_clocking_decl_assign() IList_of_clocking_decl_assignContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_clocking_decl_assignContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_clocking_decl_assignContext)
}

func (s *Clocking_itemContext) Assertion_item_declaration() IAssertion_item_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssertion_item_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssertion_item_declarationContext)
}

func (s *Clocking_itemContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Clocking_itemContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Clocking_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Clocking_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Clocking_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterClocking_item(s)
	}
}

func (s *Clocking_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitClocking_item(s)
	}
}

func (p *SystemVerilogParser) Clocking_item() (localctx IClocking_itemContext) {
	this := p
	_ = this

	localctx = NewClocking_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 840, SystemVerilogParserRULE_clocking_item)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6377)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserKDEFAULT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6362)
			p.Match(SystemVerilogParserKDEFAULT)
		}
		{
			p.SetState(6363)
			p.Default_skew()
		}
		{
			p.SetState(6364)
			p.Match(SystemVerilogParserSEMI)
		}

	case SystemVerilogParserKINOUT, SystemVerilogParserKINPUT, SystemVerilogParserKOUTPUT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6366)
			p.Clocking_direction()
		}
		{
			p.SetState(6367)
			p.List_of_clocking_decl_assign()
		}
		{
			p.SetState(6368)
			p.Match(SystemVerilogParserSEMI)
		}

	case SystemVerilogParserLPS, SystemVerilogParserKLET, SystemVerilogParserKPROPERTY, SystemVerilogParserKSEQUENCE:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(6373)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserLPS {
			{
				p.SetState(6370)
				p.Attribute_instance()
			}

			p.SetState(6375)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(6376)
			p.Assertion_item_declaration()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDefault_skewContext is an interface to support dynamic dispatch.
type IDefault_skewContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDefault_skewContext differentiates from other interfaces.
	IsDefault_skewContext()
}

type Default_skewContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefault_skewContext() *Default_skewContext {
	var p = new(Default_skewContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_default_skew
	return p
}

func (*Default_skewContext) IsDefault_skewContext() {}

func NewDefault_skewContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Default_skewContext {
	var p = new(Default_skewContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_default_skew

	return p
}

func (s *Default_skewContext) GetParser() antlr.Parser { return s.parser }

func (s *Default_skewContext) KINPUT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKINPUT, 0)
}

func (s *Default_skewContext) AllClocking_skew() []IClocking_skewContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IClocking_skewContext)(nil)).Elem())
	var tst = make([]IClocking_skewContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IClocking_skewContext)
		}
	}

	return tst
}

func (s *Default_skewContext) Clocking_skew(i int) IClocking_skewContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClocking_skewContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IClocking_skewContext)
}

func (s *Default_skewContext) KOUTPUT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKOUTPUT, 0)
}

func (s *Default_skewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Default_skewContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Default_skewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterDefault_skew(s)
	}
}

func (s *Default_skewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitDefault_skew(s)
	}
}

func (p *SystemVerilogParser) Default_skew() (localctx IDefault_skewContext) {
	this := p
	_ = this

	localctx = NewDefault_skewContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 842, SystemVerilogParserRULE_default_skew)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6387)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserKINPUT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6379)
			p.Match(SystemVerilogParserKINPUT)
		}
		{
			p.SetState(6380)
			p.Clocking_skew()
		}
		p.SetState(6383)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserKOUTPUT {
			{
				p.SetState(6381)
				p.Match(SystemVerilogParserKOUTPUT)
			}
			{
				p.SetState(6382)
				p.Clocking_skew()
			}

		}

	case SystemVerilogParserKOUTPUT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6385)
			p.Match(SystemVerilogParserKOUTPUT)
		}
		{
			p.SetState(6386)
			p.Clocking_skew()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IClocking_directionContext is an interface to support dynamic dispatch.
type IClocking_directionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClocking_directionContext differentiates from other interfaces.
	IsClocking_directionContext()
}

type Clocking_directionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClocking_directionContext() *Clocking_directionContext {
	var p = new(Clocking_directionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_clocking_direction
	return p
}

func (*Clocking_directionContext) IsClocking_directionContext() {}

func NewClocking_directionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Clocking_directionContext {
	var p = new(Clocking_directionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_clocking_direction

	return p
}

func (s *Clocking_directionContext) GetParser() antlr.Parser { return s.parser }

func (s *Clocking_directionContext) KINPUT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKINPUT, 0)
}

func (s *Clocking_directionContext) AllClocking_skew() []IClocking_skewContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IClocking_skewContext)(nil)).Elem())
	var tst = make([]IClocking_skewContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IClocking_skewContext)
		}
	}

	return tst
}

func (s *Clocking_directionContext) Clocking_skew(i int) IClocking_skewContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClocking_skewContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IClocking_skewContext)
}

func (s *Clocking_directionContext) KOUTPUT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKOUTPUT, 0)
}

func (s *Clocking_directionContext) KINOUT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKINOUT, 0)
}

func (s *Clocking_directionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Clocking_directionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Clocking_directionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterClocking_direction(s)
	}
}

func (s *Clocking_directionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitClocking_direction(s)
	}
}

func (p *SystemVerilogParser) Clocking_direction() (localctx IClocking_directionContext) {
	this := p
	_ = this

	localctx = NewClocking_directionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 844, SystemVerilogParserRULE_clocking_direction)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6404)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserKINPUT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6389)
			p.Match(SystemVerilogParserKINPUT)
		}
		p.SetState(6391)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserP || _la == SystemVerilogParserKEDGE || _la == SystemVerilogParserKNEGEDGE || _la == SystemVerilogParserKPOSEDGE {
			{
				p.SetState(6390)
				p.Clocking_skew()
			}

		}
		p.SetState(6397)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserKOUTPUT {
			{
				p.SetState(6393)
				p.Match(SystemVerilogParserKOUTPUT)
			}
			p.SetState(6395)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == SystemVerilogParserP || _la == SystemVerilogParserKEDGE || _la == SystemVerilogParserKNEGEDGE || _la == SystemVerilogParserKPOSEDGE {
				{
					p.SetState(6394)
					p.Clocking_skew()
				}

			}

		}

	case SystemVerilogParserKOUTPUT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6399)
			p.Match(SystemVerilogParserKOUTPUT)
		}
		p.SetState(6401)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserP || _la == SystemVerilogParserKEDGE || _la == SystemVerilogParserKNEGEDGE || _la == SystemVerilogParserKPOSEDGE {
			{
				p.SetState(6400)
				p.Clocking_skew()
			}

		}

	case SystemVerilogParserKINOUT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6403)
			p.Match(SystemVerilogParserKINOUT)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IList_of_clocking_decl_assignContext is an interface to support dynamic dispatch.
type IList_of_clocking_decl_assignContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_clocking_decl_assignContext differentiates from other interfaces.
	IsList_of_clocking_decl_assignContext()
}

type List_of_clocking_decl_assignContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_clocking_decl_assignContext() *List_of_clocking_decl_assignContext {
	var p = new(List_of_clocking_decl_assignContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_list_of_clocking_decl_assign
	return p
}

func (*List_of_clocking_decl_assignContext) IsList_of_clocking_decl_assignContext() {}

func NewList_of_clocking_decl_assignContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_clocking_decl_assignContext {
	var p = new(List_of_clocking_decl_assignContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_list_of_clocking_decl_assign

	return p
}

func (s *List_of_clocking_decl_assignContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_clocking_decl_assignContext) AllClocking_decl_assign() []IClocking_decl_assignContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IClocking_decl_assignContext)(nil)).Elem())
	var tst = make([]IClocking_decl_assignContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IClocking_decl_assignContext)
		}
	}

	return tst
}

func (s *List_of_clocking_decl_assignContext) Clocking_decl_assign(i int) IClocking_decl_assignContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClocking_decl_assignContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IClocking_decl_assignContext)
}

func (s *List_of_clocking_decl_assignContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *List_of_clocking_decl_assignContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *List_of_clocking_decl_assignContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_clocking_decl_assignContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_clocking_decl_assignContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterList_of_clocking_decl_assign(s)
	}
}

func (s *List_of_clocking_decl_assignContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitList_of_clocking_decl_assign(s)
	}
}

func (p *SystemVerilogParser) List_of_clocking_decl_assign() (localctx IList_of_clocking_decl_assignContext) {
	this := p
	_ = this

	localctx = NewList_of_clocking_decl_assignContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 846, SystemVerilogParserRULE_list_of_clocking_decl_assign)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6406)
		p.Clocking_decl_assign()
	}
	p.SetState(6411)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserCOMMA {
		{
			p.SetState(6407)
			p.Match(SystemVerilogParserCOMMA)
		}
		{
			p.SetState(6408)
			p.Clocking_decl_assign()
		}

		p.SetState(6413)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IClocking_decl_assignContext is an interface to support dynamic dispatch.
type IClocking_decl_assignContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClocking_decl_assignContext differentiates from other interfaces.
	IsClocking_decl_assignContext()
}

type Clocking_decl_assignContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClocking_decl_assignContext() *Clocking_decl_assignContext {
	var p = new(Clocking_decl_assignContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_clocking_decl_assign
	return p
}

func (*Clocking_decl_assignContext) IsClocking_decl_assignContext() {}

func NewClocking_decl_assignContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Clocking_decl_assignContext {
	var p = new(Clocking_decl_assignContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_clocking_decl_assign

	return p
}

func (s *Clocking_decl_assignContext) GetParser() antlr.Parser { return s.parser }

func (s *Clocking_decl_assignContext) Signal_identifier() ISignal_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISignal_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISignal_identifierContext)
}

func (s *Clocking_decl_assignContext) EQ() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserEQ, 0)
}

func (s *Clocking_decl_assignContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Clocking_decl_assignContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Clocking_decl_assignContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Clocking_decl_assignContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterClocking_decl_assign(s)
	}
}

func (s *Clocking_decl_assignContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitClocking_decl_assign(s)
	}
}

func (p *SystemVerilogParser) Clocking_decl_assign() (localctx IClocking_decl_assignContext) {
	this := p
	_ = this

	localctx = NewClocking_decl_assignContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 848, SystemVerilogParserRULE_clocking_decl_assign)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6414)
		p.Signal_identifier()
	}
	p.SetState(6417)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserEQ {
		{
			p.SetState(6415)
			p.Match(SystemVerilogParserEQ)
		}
		{
			p.SetState(6416)
			p.expression(0)
		}

	}

	return localctx
}

// IClocking_skewContext is an interface to support dynamic dispatch.
type IClocking_skewContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClocking_skewContext differentiates from other interfaces.
	IsClocking_skewContext()
}

type Clocking_skewContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClocking_skewContext() *Clocking_skewContext {
	var p = new(Clocking_skewContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_clocking_skew
	return p
}

func (*Clocking_skewContext) IsClocking_skewContext() {}

func NewClocking_skewContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Clocking_skewContext {
	var p = new(Clocking_skewContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_clocking_skew

	return p
}

func (s *Clocking_skewContext) GetParser() antlr.Parser { return s.parser }

func (s *Clocking_skewContext) Edge_identifier() IEdge_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEdge_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEdge_identifierContext)
}

func (s *Clocking_skewContext) Delay_control() IDelay_controlContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelay_controlContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelay_controlContext)
}

func (s *Clocking_skewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Clocking_skewContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Clocking_skewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterClocking_skew(s)
	}
}

func (s *Clocking_skewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitClocking_skew(s)
	}
}

func (p *SystemVerilogParser) Clocking_skew() (localctx IClocking_skewContext) {
	this := p
	_ = this

	localctx = NewClocking_skewContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 850, SystemVerilogParserRULE_clocking_skew)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6424)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserKEDGE, SystemVerilogParserKNEGEDGE, SystemVerilogParserKPOSEDGE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6419)
			p.Edge_identifier()
		}
		p.SetState(6421)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserP {
			{
				p.SetState(6420)
				p.Delay_control()
			}

		}

	case SystemVerilogParserP:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6423)
			p.Delay_control()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IClocking_driveContext is an interface to support dynamic dispatch.
type IClocking_driveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClocking_driveContext differentiates from other interfaces.
	IsClocking_driveContext()
}

type Clocking_driveContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClocking_driveContext() *Clocking_driveContext {
	var p = new(Clocking_driveContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_clocking_drive
	return p
}

func (*Clocking_driveContext) IsClocking_driveContext() {}

func NewClocking_driveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Clocking_driveContext {
	var p = new(Clocking_driveContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_clocking_drive

	return p
}

func (s *Clocking_driveContext) GetParser() antlr.Parser { return s.parser }

func (s *Clocking_driveContext) Clockvar_expression() IClockvar_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClockvar_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClockvar_expressionContext)
}

func (s *Clocking_driveContext) LTEQ() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLTEQ, 0)
}

func (s *Clocking_driveContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Clocking_driveContext) Cycle_delay() ICycle_delayContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICycle_delayContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICycle_delayContext)
}

func (s *Clocking_driveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Clocking_driveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Clocking_driveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterClocking_drive(s)
	}
}

func (s *Clocking_driveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitClocking_drive(s)
	}
}

func (p *SystemVerilogParser) Clocking_drive() (localctx IClocking_driveContext) {
	this := p
	_ = this

	localctx = NewClocking_driveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 852, SystemVerilogParserRULE_clocking_drive)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6426)
		p.Clockvar_expression()
	}
	{
		p.SetState(6427)
		p.Match(SystemVerilogParserLTEQ)
	}
	p.SetState(6429)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserPP {
		{
			p.SetState(6428)
			p.Cycle_delay()
		}

	}
	{
		p.SetState(6431)
		p.expression(0)
	}

	return localctx
}

// ICycle_delayContext is an interface to support dynamic dispatch.
type ICycle_delayContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCycle_delayContext differentiates from other interfaces.
	IsCycle_delayContext()
}

type Cycle_delayContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCycle_delayContext() *Cycle_delayContext {
	var p = new(Cycle_delayContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_cycle_delay
	return p
}

func (*Cycle_delayContext) IsCycle_delayContext() {}

func NewCycle_delayContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cycle_delayContext {
	var p = new(Cycle_delayContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_cycle_delay

	return p
}

func (s *Cycle_delayContext) GetParser() antlr.Parser { return s.parser }

func (s *Cycle_delayContext) PP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserPP, 0)
}

func (s *Cycle_delayContext) DECIMAL_NUMBER() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserDECIMAL_NUMBER, 0)
}

func (s *Cycle_delayContext) UNSIGNED_NUMBER() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserUNSIGNED_NUMBER, 0)
}

func (s *Cycle_delayContext) OCTAL_NUMBER() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserOCTAL_NUMBER, 0)
}

func (s *Cycle_delayContext) BINARY_NUMBER() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserBINARY_NUMBER, 0)
}

func (s *Cycle_delayContext) HEX_NUMBER() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserHEX_NUMBER, 0)
}

func (s *Cycle_delayContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Cycle_delayContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Cycle_delayContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Cycle_delayContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Cycle_delayContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cycle_delayContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cycle_delayContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterCycle_delay(s)
	}
}

func (s *Cycle_delayContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitCycle_delay(s)
	}
}

func (p *SystemVerilogParser) Cycle_delay() (localctx ICycle_delayContext) {
	this := p
	_ = this

	localctx = NewCycle_delayContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 854, SystemVerilogParserRULE_cycle_delay)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6433)
		p.Match(SystemVerilogParserPP)
	}
	p.SetState(6444)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserDECIMAL_NUMBER:
		{
			p.SetState(6434)
			p.Match(SystemVerilogParserDECIMAL_NUMBER)
		}

	case SystemVerilogParserUNSIGNED_NUMBER:
		{
			p.SetState(6435)
			p.Match(SystemVerilogParserUNSIGNED_NUMBER)
		}

	case SystemVerilogParserOCTAL_NUMBER:
		{
			p.SetState(6436)
			p.Match(SystemVerilogParserOCTAL_NUMBER)
		}

	case SystemVerilogParserBINARY_NUMBER:
		{
			p.SetState(6437)
			p.Match(SystemVerilogParserBINARY_NUMBER)
		}

	case SystemVerilogParserHEX_NUMBER:
		{
			p.SetState(6438)
			p.Match(SystemVerilogParserHEX_NUMBER)
		}

	case SystemVerilogParserSIMPLE_IDENTIFIER:
		{
			p.SetState(6439)
			p.Identifier()
		}

	case SystemVerilogParserLP:
		{
			p.SetState(6440)
			p.Match(SystemVerilogParserLP)
		}
		{
			p.SetState(6441)
			p.expression(0)
		}
		{
			p.SetState(6442)
			p.Match(SystemVerilogParserRP)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IClockvarContext is an interface to support dynamic dispatch.
type IClockvarContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClockvarContext differentiates from other interfaces.
	IsClockvarContext()
}

type ClockvarContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClockvarContext() *ClockvarContext {
	var p = new(ClockvarContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_clockvar
	return p
}

func (*ClockvarContext) IsClockvarContext() {}

func NewClockvarContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClockvarContext {
	var p = new(ClockvarContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_clockvar

	return p
}

func (s *ClockvarContext) GetParser() antlr.Parser { return s.parser }

func (s *ClockvarContext) Hierarchical_identifier() IHierarchical_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_identifierContext)
}

func (s *ClockvarContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClockvarContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClockvarContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterClockvar(s)
	}
}

func (s *ClockvarContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitClockvar(s)
	}
}

func (p *SystemVerilogParser) Clockvar() (localctx IClockvarContext) {
	this := p
	_ = this

	localctx = NewClockvarContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 856, SystemVerilogParserRULE_clockvar)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6446)
		p.Hierarchical_identifier()
	}

	return localctx
}

// IClockvar_expressionContext is an interface to support dynamic dispatch.
type IClockvar_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClockvar_expressionContext differentiates from other interfaces.
	IsClockvar_expressionContext()
}

type Clockvar_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClockvar_expressionContext() *Clockvar_expressionContext {
	var p = new(Clockvar_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_clockvar_expression
	return p
}

func (*Clockvar_expressionContext) IsClockvar_expressionContext() {}

func NewClockvar_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Clockvar_expressionContext {
	var p = new(Clockvar_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_clockvar_expression

	return p
}

func (s *Clockvar_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Clockvar_expressionContext) Clockvar() IClockvarContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClockvarContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClockvarContext)
}

func (s *Clockvar_expressionContext) Select_() ISelect_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelect_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelect_Context)
}

func (s *Clockvar_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Clockvar_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Clockvar_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterClockvar_expression(s)
	}
}

func (s *Clockvar_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitClockvar_expression(s)
	}
}

func (p *SystemVerilogParser) Clockvar_expression() (localctx IClockvar_expressionContext) {
	this := p
	_ = this

	localctx = NewClockvar_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 858, SystemVerilogParserRULE_clockvar_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6448)
		p.Clockvar()
	}
	{
		p.SetState(6449)
		p.Select_()
	}

	return localctx
}

// IRandsequence_statementContext is an interface to support dynamic dispatch.
type IRandsequence_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRandsequence_statementContext differentiates from other interfaces.
	IsRandsequence_statementContext()
}

type Randsequence_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRandsequence_statementContext() *Randsequence_statementContext {
	var p = new(Randsequence_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_randsequence_statement
	return p
}

func (*Randsequence_statementContext) IsRandsequence_statementContext() {}

func NewRandsequence_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Randsequence_statementContext {
	var p = new(Randsequence_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_randsequence_statement

	return p
}

func (s *Randsequence_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Randsequence_statementContext) KRANDSEQUENCE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKRANDSEQUENCE, 0)
}

func (s *Randsequence_statementContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Randsequence_statementContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Randsequence_statementContext) AllProduction() []IProductionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IProductionContext)(nil)).Elem())
	var tst = make([]IProductionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IProductionContext)
		}
	}

	return tst
}

func (s *Randsequence_statementContext) Production(i int) IProductionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProductionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IProductionContext)
}

func (s *Randsequence_statementContext) KENDSEQUENCE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKENDSEQUENCE, 0)
}

func (s *Randsequence_statementContext) Production_identifier() IProduction_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProduction_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProduction_identifierContext)
}

func (s *Randsequence_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Randsequence_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Randsequence_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterRandsequence_statement(s)
	}
}

func (s *Randsequence_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitRandsequence_statement(s)
	}
}

func (p *SystemVerilogParser) Randsequence_statement() (localctx IRandsequence_statementContext) {
	this := p
	_ = this

	localctx = NewRandsequence_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 860, SystemVerilogParserRULE_randsequence_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6451)
		p.Match(SystemVerilogParserKRANDSEQUENCE)
	}
	{
		p.SetState(6452)
		p.Match(SystemVerilogParserLP)
	}
	p.SetState(6454)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserSIMPLE_IDENTIFIER {
		{
			p.SetState(6453)
			p.Production_identifier()
		}

	}
	{
		p.SetState(6456)
		p.Match(SystemVerilogParserRP)
	}
	{
		p.SetState(6457)
		p.Production()
	}
	p.SetState(6461)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserDUNIT || (((_la-109)&-(0x1f+1)) == 0 && ((1<<uint((_la-109)))&((1<<(SystemVerilogParserKBIT-109))|(1<<(SystemVerilogParserKBYTE-109))|(1<<(SystemVerilogParserKCHANDLE-109)))) != 0) || _la == SystemVerilogParserKENUM || _la == SystemVerilogParserKEVENT || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SystemVerilogParserKINT-195))|(1<<(SystemVerilogParserKINTEGER-195))|(1<<(SystemVerilogParserKLOGIC-195))|(1<<(SystemVerilogParserKLONGINT-195)))) != 0) || (((_la-255)&-(0x1f+1)) == 0 && ((1<<uint((_la-255)))&((1<<(SystemVerilogParserKREAL-255))|(1<<(SystemVerilogParserKREALTIME-255))|(1<<(SystemVerilogParserKREG-255))|(1<<(SystemVerilogParserKSHORTINT-255))|(1<<(SystemVerilogParserKSHORTREAL-255)))) != 0) || (((_la-287)&-(0x1f+1)) == 0 && ((1<<uint((_la-287)))&((1<<(SystemVerilogParserKSTRING-287))|(1<<(SystemVerilogParserKSTRUCT-287))|(1<<(SystemVerilogParserKTIME-287))|(1<<(SystemVerilogParserKTYPE-287))|(1<<(SystemVerilogParserKUNION-287)))) != 0) || (((_la-327)&-(0x1f+1)) == 0 && ((1<<uint((_la-327)))&((1<<(SystemVerilogParserKVIRTUAL-327))|(1<<(SystemVerilogParserKVOID-327))|(1<<(SystemVerilogParserSIMPLE_IDENTIFIER-327)))) != 0) {
		{
			p.SetState(6458)
			p.Production()
		}

		p.SetState(6463)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(6464)
		p.Match(SystemVerilogParserKENDSEQUENCE)
	}

	return localctx
}

// IProductionContext is an interface to support dynamic dispatch.
type IProductionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProductionContext differentiates from other interfaces.
	IsProductionContext()
}

type ProductionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProductionContext() *ProductionContext {
	var p = new(ProductionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_production
	return p
}

func (*ProductionContext) IsProductionContext() {}

func NewProductionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProductionContext {
	var p = new(ProductionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_production

	return p
}

func (s *ProductionContext) GetParser() antlr.Parser { return s.parser }

func (s *ProductionContext) Production_identifier() IProduction_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProduction_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProduction_identifierContext)
}

func (s *ProductionContext) COLON() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOLON, 0)
}

func (s *ProductionContext) AllRs_rule() []IRs_ruleContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRs_ruleContext)(nil)).Elem())
	var tst = make([]IRs_ruleContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRs_ruleContext)
		}
	}

	return tst
}

func (s *ProductionContext) Rs_rule(i int) IRs_ruleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRs_ruleContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRs_ruleContext)
}

func (s *ProductionContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *ProductionContext) Data_type_or_void() IData_type_or_voidContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IData_type_or_voidContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IData_type_or_voidContext)
}

func (s *ProductionContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *ProductionContext) Tf_port_list() ITf_port_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITf_port_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITf_port_listContext)
}

func (s *ProductionContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *ProductionContext) AllBAR() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserBAR)
}

func (s *ProductionContext) BAR(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserBAR, i)
}

func (s *ProductionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProductionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProductionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterProduction(s)
	}
}

func (s *ProductionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitProduction(s)
	}
}

func (p *SystemVerilogParser) Production() (localctx IProductionContext) {
	this := p
	_ = this

	localctx = NewProductionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 862, SystemVerilogParserRULE_production)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(6467)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 800, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(6466)
			p.Data_type_or_void()
		}

	}
	{
		p.SetState(6469)
		p.Production_identifier()
	}
	p.SetState(6474)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserLP {
		{
			p.SetState(6470)
			p.Match(SystemVerilogParserLP)
		}
		{
			p.SetState(6471)
			p.Tf_port_list()
		}
		{
			p.SetState(6472)
			p.Match(SystemVerilogParserRP)
		}

	}
	{
		p.SetState(6476)
		p.Match(SystemVerilogParserCOLON)
	}
	{
		p.SetState(6477)
		p.Rs_rule()
	}
	p.SetState(6482)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserBAR {
		{
			p.SetState(6478)
			p.Match(SystemVerilogParserBAR)
		}
		{
			p.SetState(6479)
			p.Rs_rule()
		}

		p.SetState(6484)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(6485)
		p.Match(SystemVerilogParserSEMI)
	}

	return localctx
}

// IRs_ruleContext is an interface to support dynamic dispatch.
type IRs_ruleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRs_ruleContext differentiates from other interfaces.
	IsRs_ruleContext()
}

type Rs_ruleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRs_ruleContext() *Rs_ruleContext {
	var p = new(Rs_ruleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_rs_rule
	return p
}

func (*Rs_ruleContext) IsRs_ruleContext() {}

func NewRs_ruleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Rs_ruleContext {
	var p = new(Rs_ruleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_rs_rule

	return p
}

func (s *Rs_ruleContext) GetParser() antlr.Parser { return s.parser }

func (s *Rs_ruleContext) Rs_production_list() IRs_production_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRs_production_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRs_production_listContext)
}

func (s *Rs_ruleContext) COLONEQ() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOLONEQ, 0)
}

func (s *Rs_ruleContext) Weight_specification() IWeight_specificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWeight_specificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWeight_specificationContext)
}

func (s *Rs_ruleContext) Rs_code_block() IRs_code_blockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRs_code_blockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRs_code_blockContext)
}

func (s *Rs_ruleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Rs_ruleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Rs_ruleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterRs_rule(s)
	}
}

func (s *Rs_ruleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitRs_rule(s)
	}
}

func (p *SystemVerilogParser) Rs_rule() (localctx IRs_ruleContext) {
	this := p
	_ = this

	localctx = NewRs_ruleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 864, SystemVerilogParserRULE_rs_rule)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6487)
		p.Rs_production_list()
	}
	p.SetState(6493)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserCOLONEQ {
		{
			p.SetState(6488)
			p.Match(SystemVerilogParserCOLONEQ)
		}
		{
			p.SetState(6489)
			p.Weight_specification()
		}
		p.SetState(6491)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserLC {
			{
				p.SetState(6490)
				p.Rs_code_block()
			}

		}

	}

	return localctx
}

// IRs_production_listContext is an interface to support dynamic dispatch.
type IRs_production_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRs_production_listContext differentiates from other interfaces.
	IsRs_production_listContext()
}

type Rs_production_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRs_production_listContext() *Rs_production_listContext {
	var p = new(Rs_production_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_rs_production_list
	return p
}

func (*Rs_production_listContext) IsRs_production_listContext() {}

func NewRs_production_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Rs_production_listContext {
	var p = new(Rs_production_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_rs_production_list

	return p
}

func (s *Rs_production_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Rs_production_listContext) AllRs_prod() []IRs_prodContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRs_prodContext)(nil)).Elem())
	var tst = make([]IRs_prodContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRs_prodContext)
		}
	}

	return tst
}

func (s *Rs_production_listContext) Rs_prod(i int) IRs_prodContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRs_prodContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRs_prodContext)
}

func (s *Rs_production_listContext) KRAND() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKRAND, 0)
}

func (s *Rs_production_listContext) KJOIN() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKJOIN, 0)
}

func (s *Rs_production_listContext) AllProduction_item() []IProduction_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IProduction_itemContext)(nil)).Elem())
	var tst = make([]IProduction_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IProduction_itemContext)
		}
	}

	return tst
}

func (s *Rs_production_listContext) Production_item(i int) IProduction_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProduction_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IProduction_itemContext)
}

func (s *Rs_production_listContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Rs_production_listContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Rs_production_listContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Rs_production_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Rs_production_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Rs_production_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterRs_production_list(s)
	}
}

func (s *Rs_production_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitRs_production_list(s)
	}
}

func (p *SystemVerilogParser) Rs_production_list() (localctx IRs_production_listContext) {
	this := p
	_ = this

	localctx = NewRs_production_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 866, SystemVerilogParserRULE_rs_production_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6518)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserLC, SystemVerilogParserKCASE, SystemVerilogParserKIF, SystemVerilogParserKREPEAT, SystemVerilogParserSIMPLE_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6495)
			p.Rs_prod()
		}
		p.SetState(6499)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserLC || _la == SystemVerilogParserKCASE || _la == SystemVerilogParserKIF || _la == SystemVerilogParserKREPEAT || _la == SystemVerilogParserSIMPLE_IDENTIFIER {
			{
				p.SetState(6496)
				p.Rs_prod()
			}

			p.SetState(6501)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case SystemVerilogParserKRAND:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6502)
			p.Match(SystemVerilogParserKRAND)
		}
		{
			p.SetState(6503)
			p.Match(SystemVerilogParserKJOIN)
		}
		p.SetState(6508)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserLP {
			{
				p.SetState(6504)
				p.Match(SystemVerilogParserLP)
			}
			{
				p.SetState(6505)
				p.expression(0)
			}
			{
				p.SetState(6506)
				p.Match(SystemVerilogParserRP)
			}

		}
		{
			p.SetState(6510)
			p.Production_item()
		}
		{
			p.SetState(6511)
			p.Production_item()
		}
		p.SetState(6515)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserSIMPLE_IDENTIFIER {
			{
				p.SetState(6512)
				p.Production_item()
			}

			p.SetState(6517)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IWeight_specificationContext is an interface to support dynamic dispatch.
type IWeight_specificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWeight_specificationContext differentiates from other interfaces.
	IsWeight_specificationContext()
}

type Weight_specificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWeight_specificationContext() *Weight_specificationContext {
	var p = new(Weight_specificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_weight_specification
	return p
}

func (*Weight_specificationContext) IsWeight_specificationContext() {}

func NewWeight_specificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Weight_specificationContext {
	var p = new(Weight_specificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_weight_specification

	return p
}

func (s *Weight_specificationContext) GetParser() antlr.Parser { return s.parser }

func (s *Weight_specificationContext) DECIMAL_NUMBER() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserDECIMAL_NUMBER, 0)
}

func (s *Weight_specificationContext) UNSIGNED_NUMBER() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserUNSIGNED_NUMBER, 0)
}

func (s *Weight_specificationContext) OCTAL_NUMBER() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserOCTAL_NUMBER, 0)
}

func (s *Weight_specificationContext) BINARY_NUMBER() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserBINARY_NUMBER, 0)
}

func (s *Weight_specificationContext) HEX_NUMBER() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserHEX_NUMBER, 0)
}

func (s *Weight_specificationContext) Ps_identifier() IPs_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPs_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPs_identifierContext)
}

func (s *Weight_specificationContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Weight_specificationContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Weight_specificationContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Weight_specificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Weight_specificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Weight_specificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterWeight_specification(s)
	}
}

func (s *Weight_specificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitWeight_specification(s)
	}
}

func (p *SystemVerilogParser) Weight_specification() (localctx IWeight_specificationContext) {
	this := p
	_ = this

	localctx = NewWeight_specificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 868, SystemVerilogParserRULE_weight_specification)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6530)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserDECIMAL_NUMBER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6520)
			p.Match(SystemVerilogParserDECIMAL_NUMBER)
		}

	case SystemVerilogParserUNSIGNED_NUMBER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6521)
			p.Match(SystemVerilogParserUNSIGNED_NUMBER)
		}

	case SystemVerilogParserOCTAL_NUMBER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6522)
			p.Match(SystemVerilogParserOCTAL_NUMBER)
		}

	case SystemVerilogParserBINARY_NUMBER:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6523)
			p.Match(SystemVerilogParserBINARY_NUMBER)
		}

	case SystemVerilogParserHEX_NUMBER:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6524)
			p.Match(SystemVerilogParserHEX_NUMBER)
		}

	case SystemVerilogParserDUNIT, SystemVerilogParserSIMPLE_IDENTIFIER:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(6525)
			p.Ps_identifier()
		}

	case SystemVerilogParserLP:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(6526)
			p.Match(SystemVerilogParserLP)
		}
		{
			p.SetState(6527)
			p.expression(0)
		}
		{
			p.SetState(6528)
			p.Match(SystemVerilogParserRP)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IRs_code_blockContext is an interface to support dynamic dispatch.
type IRs_code_blockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRs_code_blockContext differentiates from other interfaces.
	IsRs_code_blockContext()
}

type Rs_code_blockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRs_code_blockContext() *Rs_code_blockContext {
	var p = new(Rs_code_blockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_rs_code_block
	return p
}

func (*Rs_code_blockContext) IsRs_code_blockContext() {}

func NewRs_code_blockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Rs_code_blockContext {
	var p = new(Rs_code_blockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_rs_code_block

	return p
}

func (s *Rs_code_blockContext) GetParser() antlr.Parser { return s.parser }

func (s *Rs_code_blockContext) LC() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLC, 0)
}

func (s *Rs_code_blockContext) RC() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRC, 0)
}

func (s *Rs_code_blockContext) AllData_declaration() []IData_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IData_declarationContext)(nil)).Elem())
	var tst = make([]IData_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IData_declarationContext)
		}
	}

	return tst
}

func (s *Rs_code_blockContext) Data_declaration(i int) IData_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IData_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IData_declarationContext)
}

func (s *Rs_code_blockContext) AllStatement_or_null() []IStatement_or_nullContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatement_or_nullContext)(nil)).Elem())
	var tst = make([]IStatement_or_nullContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatement_or_nullContext)
		}
	}

	return tst
}

func (s *Rs_code_blockContext) Statement_or_null(i int) IStatement_or_nullContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatement_or_nullContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatement_or_nullContext)
}

func (s *Rs_code_blockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Rs_code_blockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Rs_code_blockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterRs_code_block(s)
	}
}

func (s *Rs_code_blockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitRs_code_block(s)
	}
}

func (p *SystemVerilogParser) Rs_code_block() (localctx IRs_code_blockContext) {
	this := p
	_ = this

	localctx = NewRs_code_blockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 870, SystemVerilogParserRULE_rs_code_block)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6532)
		p.Match(SystemVerilogParserLC)
	}
	p.SetState(6536)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 810, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(6533)
				p.Data_declaration()
			}

		}
		p.SetState(6538)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 810, p.GetParserRuleContext())
	}
	p.SetState(6542)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SystemVerilogParserMINUSMINS)|(1<<SystemVerilogParserP)|(1<<SystemVerilogParserPP)|(1<<SystemVerilogParserDOLLAR)|(1<<SystemVerilogParserDERROR)|(1<<SystemVerilogParserDFATAL)|(1<<SystemVerilogParserDINFO)|(1<<SystemVerilogParserDROOT)|(1<<SystemVerilogParserDUNIT)|(1<<SystemVerilogParserDWARNING)|(1<<SystemVerilogParserLP)|(1<<SystemVerilogParserLPS))) != 0) || (((_la-46)&-(0x1f+1)) == 0 && ((1<<uint((_la-46)))&((1<<(SystemVerilogParserSEMI-46))|(1<<(SystemVerilogParserAT-46))|(1<<(SystemVerilogParserQUOTE-46))|(1<<(SystemVerilogParserLC-46))|(1<<(SystemVerilogParserPLUSPLUS-46)))) != 0) || (((_la-85)&-(0x1f+1)) == 0 && ((1<<uint((_la-85)))&((1<<(SystemVerilogParserARROW-85))|(1<<(SystemVerilogParserMINUSGTGT-85))|(1<<(SystemVerilogParserKASSERT-85))|(1<<(SystemVerilogParserKASSIGN-85))|(1<<(SystemVerilogParserKASSUME-85))|(1<<(SystemVerilogParserKBEGIN-85))|(1<<(SystemVerilogParserKBREAK-85))|(1<<(SystemVerilogParserKBYTE-85))|(1<<(SystemVerilogParserKCASE-85))|(1<<(SystemVerilogParserKCASEX-85)))) != 0) || (((_la-117)&-(0x1f+1)) == 0 && ((1<<uint((_la-117)))&((1<<(SystemVerilogParserKCASEZ-117))|(1<<(SystemVerilogParserKCONTINUE-117))|(1<<(SystemVerilogParserKCOVER-117))|(1<<(SystemVerilogParserKDEASSIGN-117))|(1<<(SystemVerilogParserKDISABLE-117))|(1<<(SystemVerilogParserKDO-117)))) != 0) || (((_la-162)&-(0x1f+1)) == 0 && ((1<<uint((_la-162)))&((1<<(SystemVerilogParserKEXPECT-162))|(1<<(SystemVerilogParserKFOR-162))|(1<<(SystemVerilogParserKFORCE-162))|(1<<(SystemVerilogParserKFOREACH-162))|(1<<(SystemVerilogParserKFOREVER-162))|(1<<(SystemVerilogParserKFORK-162))|(1<<(SystemVerilogParserKIF-162)))) != 0) || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SystemVerilogParserKINT-195))|(1<<(SystemVerilogParserKINTEGER-195))|(1<<(SystemVerilogParserKLOCAL-195))|(1<<(SystemVerilogParserKLONGINT-195)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(SystemVerilogParserKNULL-228))|(1<<(SystemVerilogParserKPRIORITY-228))|(1<<(SystemVerilogParserKRANDCASE-228))|(1<<(SystemVerilogParserKRANDOMIZE-228))|(1<<(SystemVerilogParserKRANDSEQUENCE-228)))) != 0) || (((_la-260)&-(0x1f+1)) == 0 && ((1<<uint((_la-260)))&((1<<(SystemVerilogParserKRELEASE-260))|(1<<(SystemVerilogParserKREPEAT-260))|(1<<(SystemVerilogParserKRESTRICT-260))|(1<<(SystemVerilogParserKRETURN-260))|(1<<(SystemVerilogParserKSHORTINT-260))|(1<<(SystemVerilogParserKSTD-260)))) != 0) || (((_la-292)&-(0x1f+1)) == 0 && ((1<<uint((_la-292)))&((1<<(SystemVerilogParserKSUPER-292))|(1<<(SystemVerilogParserKTHIS-292))|(1<<(SystemVerilogParserKTIME-292))|(1<<(SystemVerilogParserKTYPE-292))|(1<<(SystemVerilogParserKUNIQUE-292))|(1<<(SystemVerilogParserKUNIQUE0-292)))) != 0) || (((_la-328)&-(0x1f+1)) == 0 && ((1<<uint((_la-328)))&((1<<(SystemVerilogParserKVOID-328))|(1<<(SystemVerilogParserKWAIT-328))|(1<<(SystemVerilogParserKWAIT_ORDER-328))|(1<<(SystemVerilogParserKWHILE-328))|(1<<(SystemVerilogParserTIME_LITERAL-328))|(1<<(SystemVerilogParserDECIMAL_NUMBER-328))|(1<<(SystemVerilogParserBINARY_NUMBER-328))|(1<<(SystemVerilogParserOCTAL_NUMBER-328))|(1<<(SystemVerilogParserHEX_NUMBER-328))|(1<<(SystemVerilogParserREAL_NUMBER-328))|(1<<(SystemVerilogParserUNSIGNED_NUMBER-328))|(1<<(SystemVerilogParserSTRING_LITERAL-328))|(1<<(SystemVerilogParserSIMPLE_IDENTIFIER-328))|(1<<(SystemVerilogParserSYSTEM_TF_IDENTIFIER-328)))) != 0) {
		{
			p.SetState(6539)
			p.Statement_or_null()
		}

		p.SetState(6544)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(6545)
		p.Match(SystemVerilogParserRC)
	}

	return localctx
}

// IRs_prodContext is an interface to support dynamic dispatch.
type IRs_prodContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRs_prodContext differentiates from other interfaces.
	IsRs_prodContext()
}

type Rs_prodContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRs_prodContext() *Rs_prodContext {
	var p = new(Rs_prodContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_rs_prod
	return p
}

func (*Rs_prodContext) IsRs_prodContext() {}

func NewRs_prodContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Rs_prodContext {
	var p = new(Rs_prodContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_rs_prod

	return p
}

func (s *Rs_prodContext) GetParser() antlr.Parser { return s.parser }

func (s *Rs_prodContext) Production_item() IProduction_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProduction_itemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProduction_itemContext)
}

func (s *Rs_prodContext) Rs_code_block() IRs_code_blockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRs_code_blockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRs_code_blockContext)
}

func (s *Rs_prodContext) Rs_if_else() IRs_if_elseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRs_if_elseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRs_if_elseContext)
}

func (s *Rs_prodContext) Rs_repeat() IRs_repeatContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRs_repeatContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRs_repeatContext)
}

func (s *Rs_prodContext) Rs_case() IRs_caseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRs_caseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRs_caseContext)
}

func (s *Rs_prodContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Rs_prodContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Rs_prodContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterRs_prod(s)
	}
}

func (s *Rs_prodContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitRs_prod(s)
	}
}

func (p *SystemVerilogParser) Rs_prod() (localctx IRs_prodContext) {
	this := p
	_ = this

	localctx = NewRs_prodContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 872, SystemVerilogParserRULE_rs_prod)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6552)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserSIMPLE_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6547)
			p.Production_item()
		}

	case SystemVerilogParserLC:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6548)
			p.Rs_code_block()
		}

	case SystemVerilogParserKIF:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6549)
			p.Rs_if_else()
		}

	case SystemVerilogParserKREPEAT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6550)
			p.Rs_repeat()
		}

	case SystemVerilogParserKCASE:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6551)
			p.Rs_case()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IProduction_itemContext is an interface to support dynamic dispatch.
type IProduction_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProduction_itemContext differentiates from other interfaces.
	IsProduction_itemContext()
}

type Production_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProduction_itemContext() *Production_itemContext {
	var p = new(Production_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_production_item
	return p
}

func (*Production_itemContext) IsProduction_itemContext() {}

func NewProduction_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Production_itemContext {
	var p = new(Production_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_production_item

	return p
}

func (s *Production_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Production_itemContext) Production_identifier() IProduction_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProduction_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProduction_identifierContext)
}

func (s *Production_itemContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Production_itemContext) List_of_arguments() IList_of_argumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_argumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_argumentsContext)
}

func (s *Production_itemContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Production_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Production_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Production_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterProduction_item(s)
	}
}

func (s *Production_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitProduction_item(s)
	}
}

func (p *SystemVerilogParser) Production_item() (localctx IProduction_itemContext) {
	this := p
	_ = this

	localctx = NewProduction_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 874, SystemVerilogParserRULE_production_item)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6554)
		p.Production_identifier()
	}
	p.SetState(6559)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserLP {
		{
			p.SetState(6555)
			p.Match(SystemVerilogParserLP)
		}
		{
			p.SetState(6556)
			p.List_of_arguments()
		}
		{
			p.SetState(6557)
			p.Match(SystemVerilogParserRP)
		}

	}

	return localctx
}

// IRs_if_elseContext is an interface to support dynamic dispatch.
type IRs_if_elseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRs_if_elseContext differentiates from other interfaces.
	IsRs_if_elseContext()
}

type Rs_if_elseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRs_if_elseContext() *Rs_if_elseContext {
	var p = new(Rs_if_elseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_rs_if_else
	return p
}

func (*Rs_if_elseContext) IsRs_if_elseContext() {}

func NewRs_if_elseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Rs_if_elseContext {
	var p = new(Rs_if_elseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_rs_if_else

	return p
}

func (s *Rs_if_elseContext) GetParser() antlr.Parser { return s.parser }

func (s *Rs_if_elseContext) KIF() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKIF, 0)
}

func (s *Rs_if_elseContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Rs_if_elseContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Rs_if_elseContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Rs_if_elseContext) AllProduction_item() []IProduction_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IProduction_itemContext)(nil)).Elem())
	var tst = make([]IProduction_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IProduction_itemContext)
		}
	}

	return tst
}

func (s *Rs_if_elseContext) Production_item(i int) IProduction_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProduction_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IProduction_itemContext)
}

func (s *Rs_if_elseContext) KELSE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKELSE, 0)
}

func (s *Rs_if_elseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Rs_if_elseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Rs_if_elseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterRs_if_else(s)
	}
}

func (s *Rs_if_elseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitRs_if_else(s)
	}
}

func (p *SystemVerilogParser) Rs_if_else() (localctx IRs_if_elseContext) {
	this := p
	_ = this

	localctx = NewRs_if_elseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 876, SystemVerilogParserRULE_rs_if_else)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6561)
		p.Match(SystemVerilogParserKIF)
	}
	{
		p.SetState(6562)
		p.Match(SystemVerilogParserLP)
	}
	{
		p.SetState(6563)
		p.expression(0)
	}
	{
		p.SetState(6564)
		p.Match(SystemVerilogParserRP)
	}
	{
		p.SetState(6565)
		p.Production_item()
	}
	p.SetState(6568)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserKELSE {
		{
			p.SetState(6566)
			p.Match(SystemVerilogParserKELSE)
		}
		{
			p.SetState(6567)
			p.Production_item()
		}

	}

	return localctx
}

// IRs_repeatContext is an interface to support dynamic dispatch.
type IRs_repeatContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRs_repeatContext differentiates from other interfaces.
	IsRs_repeatContext()
}

type Rs_repeatContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRs_repeatContext() *Rs_repeatContext {
	var p = new(Rs_repeatContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_rs_repeat
	return p
}

func (*Rs_repeatContext) IsRs_repeatContext() {}

func NewRs_repeatContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Rs_repeatContext {
	var p = new(Rs_repeatContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_rs_repeat

	return p
}

func (s *Rs_repeatContext) GetParser() antlr.Parser { return s.parser }

func (s *Rs_repeatContext) KREPEAT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKREPEAT, 0)
}

func (s *Rs_repeatContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Rs_repeatContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Rs_repeatContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Rs_repeatContext) Production_item() IProduction_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProduction_itemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProduction_itemContext)
}

func (s *Rs_repeatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Rs_repeatContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Rs_repeatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterRs_repeat(s)
	}
}

func (s *Rs_repeatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitRs_repeat(s)
	}
}

func (p *SystemVerilogParser) Rs_repeat() (localctx IRs_repeatContext) {
	this := p
	_ = this

	localctx = NewRs_repeatContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 878, SystemVerilogParserRULE_rs_repeat)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6570)
		p.Match(SystemVerilogParserKREPEAT)
	}
	{
		p.SetState(6571)
		p.Match(SystemVerilogParserLP)
	}
	{
		p.SetState(6572)
		p.expression(0)
	}
	{
		p.SetState(6573)
		p.Match(SystemVerilogParserRP)
	}
	{
		p.SetState(6574)
		p.Production_item()
	}

	return localctx
}

// IRs_caseContext is an interface to support dynamic dispatch.
type IRs_caseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRs_caseContext differentiates from other interfaces.
	IsRs_caseContext()
}

type Rs_caseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRs_caseContext() *Rs_caseContext {
	var p = new(Rs_caseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_rs_case
	return p
}

func (*Rs_caseContext) IsRs_caseContext() {}

func NewRs_caseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Rs_caseContext {
	var p = new(Rs_caseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_rs_case

	return p
}

func (s *Rs_caseContext) GetParser() antlr.Parser { return s.parser }

func (s *Rs_caseContext) KCASE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKCASE, 0)
}

func (s *Rs_caseContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Rs_caseContext) Case_expression() ICase_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICase_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICase_expressionContext)
}

func (s *Rs_caseContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Rs_caseContext) AllRs_case_item() []IRs_case_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRs_case_itemContext)(nil)).Elem())
	var tst = make([]IRs_case_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRs_case_itemContext)
		}
	}

	return tst
}

func (s *Rs_caseContext) Rs_case_item(i int) IRs_case_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRs_case_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRs_case_itemContext)
}

func (s *Rs_caseContext) KENDCASE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKENDCASE, 0)
}

func (s *Rs_caseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Rs_caseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Rs_caseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterRs_case(s)
	}
}

func (s *Rs_caseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitRs_case(s)
	}
}

func (p *SystemVerilogParser) Rs_case() (localctx IRs_caseContext) {
	this := p
	_ = this

	localctx = NewRs_caseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 880, SystemVerilogParserRULE_rs_case)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6576)
		p.Match(SystemVerilogParserKCASE)
	}
	{
		p.SetState(6577)
		p.Match(SystemVerilogParserLP)
	}
	{
		p.SetState(6578)
		p.Case_expression()
	}
	{
		p.SetState(6579)
		p.Match(SystemVerilogParserRP)
	}
	{
		p.SetState(6580)
		p.Rs_case_item()
	}
	p.SetState(6584)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SystemVerilogParserMINUS)|(1<<SystemVerilogParserMINUSMINS)|(1<<SystemVerilogParserNOT)|(1<<SystemVerilogParserDOLLAR)|(1<<SystemVerilogParserDROOT)|(1<<SystemVerilogParserDUNIT)|(1<<SystemVerilogParserAND)|(1<<SystemVerilogParserLP))) != 0) || (((_la-51)&-(0x1f+1)) == 0 && ((1<<uint((_la-51)))&((1<<(SystemVerilogParserQUOTE-51))|(1<<(SystemVerilogParserCARET-51))|(1<<(SystemVerilogParserCARETSQUIG-51))|(1<<(SystemVerilogParserLC-51))|(1<<(SystemVerilogParserBAR-51))|(1<<(SystemVerilogParserSQUIG-51))|(1<<(SystemVerilogParserSQUIGAND-51))|(1<<(SystemVerilogParserSQUIGCARET-51))|(1<<(SystemVerilogParserSQUIGBAR-51))|(1<<(SystemVerilogParserPLUS-51))|(1<<(SystemVerilogParserPLUSPLUS-51)))) != 0) || (((_la-109)&-(0x1f+1)) == 0 && ((1<<uint((_la-109)))&((1<<(SystemVerilogParserKBIT-109))|(1<<(SystemVerilogParserKBYTE-109))|(1<<(SystemVerilogParserKCONST-109))|(1<<(SystemVerilogParserKDEFAULT-109)))) != 0) || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SystemVerilogParserKINT-195))|(1<<(SystemVerilogParserKINTEGER-195))|(1<<(SystemVerilogParserKLOCAL-195))|(1<<(SystemVerilogParserKLOGIC-195))|(1<<(SystemVerilogParserKLONGINT-195)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(SystemVerilogParserKNULL-228))|(1<<(SystemVerilogParserKRANDOMIZE-228))|(1<<(SystemVerilogParserKREAL-228))|(1<<(SystemVerilogParserKREALTIME-228))|(1<<(SystemVerilogParserKREG-228)))) != 0) || (((_la-276)&-(0x1f+1)) == 0 && ((1<<uint((_la-276)))&((1<<(SystemVerilogParserKSHORTINT-276))|(1<<(SystemVerilogParserKSHORTREAL-276))|(1<<(SystemVerilogParserKSIGNED-276))|(1<<(SystemVerilogParserKSTD-276))|(1<<(SystemVerilogParserKSTRING-276))|(1<<(SystemVerilogParserKSUPER-276))|(1<<(SystemVerilogParserKTAGGED-276))|(1<<(SystemVerilogParserKTHIS-276))|(1<<(SystemVerilogParserKTIME-276)))) != 0) || _la == SystemVerilogParserKTYPE || _la == SystemVerilogParserKUNSIGNED || (((_la-345)&-(0x1f+1)) == 0 && ((1<<uint((_la-345)))&((1<<(SystemVerilogParserTIME_LITERAL-345))|(1<<(SystemVerilogParserDECIMAL_NUMBER-345))|(1<<(SystemVerilogParserBINARY_NUMBER-345))|(1<<(SystemVerilogParserOCTAL_NUMBER-345))|(1<<(SystemVerilogParserHEX_NUMBER-345))|(1<<(SystemVerilogParserREAL_NUMBER-345))|(1<<(SystemVerilogParserUNSIGNED_NUMBER-345))|(1<<(SystemVerilogParserSTRING_LITERAL-345))|(1<<(SystemVerilogParserSIMPLE_IDENTIFIER-345))|(1<<(SystemVerilogParserSYSTEM_TF_IDENTIFIER-345)))) != 0) {
		{
			p.SetState(6581)
			p.Rs_case_item()
		}

		p.SetState(6586)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(6587)
		p.Match(SystemVerilogParserKENDCASE)
	}

	return localctx
}

// IRs_case_itemContext is an interface to support dynamic dispatch.
type IRs_case_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRs_case_itemContext differentiates from other interfaces.
	IsRs_case_itemContext()
}

type Rs_case_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRs_case_itemContext() *Rs_case_itemContext {
	var p = new(Rs_case_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_rs_case_item
	return p
}

func (*Rs_case_itemContext) IsRs_case_itemContext() {}

func NewRs_case_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Rs_case_itemContext {
	var p = new(Rs_case_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_rs_case_item

	return p
}

func (s *Rs_case_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Rs_case_itemContext) AllCase_item_expression() []ICase_item_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICase_item_expressionContext)(nil)).Elem())
	var tst = make([]ICase_item_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICase_item_expressionContext)
		}
	}

	return tst
}

func (s *Rs_case_itemContext) Case_item_expression(i int) ICase_item_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICase_item_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICase_item_expressionContext)
}

func (s *Rs_case_itemContext) COLON() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOLON, 0)
}

func (s *Rs_case_itemContext) Production_item() IProduction_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProduction_itemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProduction_itemContext)
}

func (s *Rs_case_itemContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Rs_case_itemContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *Rs_case_itemContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *Rs_case_itemContext) KDEFAULT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKDEFAULT, 0)
}

func (s *Rs_case_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Rs_case_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Rs_case_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterRs_case_item(s)
	}
}

func (s *Rs_case_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitRs_case_item(s)
	}
}

func (p *SystemVerilogParser) Rs_case_item() (localctx IRs_case_itemContext) {
	this := p
	_ = this

	localctx = NewRs_case_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 882, SystemVerilogParserRULE_rs_case_item)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6608)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserMINUS, SystemVerilogParserMINUSMINS, SystemVerilogParserNOT, SystemVerilogParserDOLLAR, SystemVerilogParserDROOT, SystemVerilogParserDUNIT, SystemVerilogParserAND, SystemVerilogParserLP, SystemVerilogParserQUOTE, SystemVerilogParserCARET, SystemVerilogParserCARETSQUIG, SystemVerilogParserLC, SystemVerilogParserBAR, SystemVerilogParserSQUIG, SystemVerilogParserSQUIGAND, SystemVerilogParserSQUIGCARET, SystemVerilogParserSQUIGBAR, SystemVerilogParserPLUS, SystemVerilogParserPLUSPLUS, SystemVerilogParserKBIT, SystemVerilogParserKBYTE, SystemVerilogParserKCONST, SystemVerilogParserKINT, SystemVerilogParserKINTEGER, SystemVerilogParserKLOCAL, SystemVerilogParserKLOGIC, SystemVerilogParserKLONGINT, SystemVerilogParserKNULL, SystemVerilogParserKRANDOMIZE, SystemVerilogParserKREAL, SystemVerilogParserKREALTIME, SystemVerilogParserKREG, SystemVerilogParserKSHORTINT, SystemVerilogParserKSHORTREAL, SystemVerilogParserKSIGNED, SystemVerilogParserKSTD, SystemVerilogParserKSTRING, SystemVerilogParserKSUPER, SystemVerilogParserKTAGGED, SystemVerilogParserKTHIS, SystemVerilogParserKTIME, SystemVerilogParserKTYPE, SystemVerilogParserKUNSIGNED, SystemVerilogParserTIME_LITERAL, SystemVerilogParserDECIMAL_NUMBER, SystemVerilogParserBINARY_NUMBER, SystemVerilogParserOCTAL_NUMBER, SystemVerilogParserHEX_NUMBER, SystemVerilogParserREAL_NUMBER, SystemVerilogParserUNSIGNED_NUMBER, SystemVerilogParserSTRING_LITERAL, SystemVerilogParserSIMPLE_IDENTIFIER, SystemVerilogParserSYSTEM_TF_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6589)
			p.Case_item_expression()
		}
		p.SetState(6594)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserCOMMA {
			{
				p.SetState(6590)
				p.Match(SystemVerilogParserCOMMA)
			}
			{
				p.SetState(6591)
				p.Case_item_expression()
			}

			p.SetState(6596)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(6597)
			p.Match(SystemVerilogParserCOLON)
		}
		{
			p.SetState(6598)
			p.Production_item()
		}
		{
			p.SetState(6599)
			p.Match(SystemVerilogParserSEMI)
		}

	case SystemVerilogParserKDEFAULT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6601)
			p.Match(SystemVerilogParserKDEFAULT)
		}
		p.SetState(6603)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserCOLON {
			{
				p.SetState(6602)
				p.Match(SystemVerilogParserCOLON)
			}

		}
		{
			p.SetState(6605)
			p.Production_item()
		}
		{
			p.SetState(6606)
			p.Match(SystemVerilogParserSEMI)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISpecify_blockContext is an interface to support dynamic dispatch.
type ISpecify_blockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSpecify_blockContext differentiates from other interfaces.
	IsSpecify_blockContext()
}

type Specify_blockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpecify_blockContext() *Specify_blockContext {
	var p = new(Specify_blockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_specify_block
	return p
}

func (*Specify_blockContext) IsSpecify_blockContext() {}

func NewSpecify_blockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Specify_blockContext {
	var p = new(Specify_blockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_specify_block

	return p
}

func (s *Specify_blockContext) GetParser() antlr.Parser { return s.parser }

func (s *Specify_blockContext) KSPECIFY() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKSPECIFY, 0)
}

func (s *Specify_blockContext) KENDSPECIFY() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKENDSPECIFY, 0)
}

func (s *Specify_blockContext) AllSpecify_item() []ISpecify_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISpecify_itemContext)(nil)).Elem())
	var tst = make([]ISpecify_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISpecify_itemContext)
		}
	}

	return tst
}

func (s *Specify_blockContext) Specify_item(i int) ISpecify_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecify_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISpecify_itemContext)
}

func (s *Specify_blockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Specify_blockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Specify_blockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterSpecify_block(s)
	}
}

func (s *Specify_blockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitSpecify_block(s)
	}
}

func (p *SystemVerilogParser) Specify_block() (localctx ISpecify_blockContext) {
	this := p
	_ = this

	localctx = NewSpecify_blockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 884, SystemVerilogParserRULE_specify_block)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6610)
		p.Match(SystemVerilogParserKSPECIFY)
	}
	p.SetState(6614)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserLP || _la == SystemVerilogParserKIF || _la == SystemVerilogParserKIFNONE || (((_la-224)&-(0x1f+1)) == 0 && ((1<<uint((_la-224)))&((1<<(SystemVerilogParserKNOSHOWCANCELLED-224))|(1<<(SystemVerilogParserKPULSESTYLE_ONDETECT-224))|(1<<(SystemVerilogParserKPULSESTYLE_ONEVENT-224)))) != 0) || _la == SystemVerilogParserKSHOWCANCELLED || _la == SystemVerilogParserKSPECPARAM {
		{
			p.SetState(6611)
			p.Specify_item()
		}

		p.SetState(6616)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(6617)
		p.Match(SystemVerilogParserKENDSPECIFY)
	}

	return localctx
}

// ISpecify_itemContext is an interface to support dynamic dispatch.
type ISpecify_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSpecify_itemContext differentiates from other interfaces.
	IsSpecify_itemContext()
}

type Specify_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpecify_itemContext() *Specify_itemContext {
	var p = new(Specify_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_specify_item
	return p
}

func (*Specify_itemContext) IsSpecify_itemContext() {}

func NewSpecify_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Specify_itemContext {
	var p = new(Specify_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_specify_item

	return p
}

func (s *Specify_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Specify_itemContext) Specparam_declaration() ISpecparam_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecparam_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpecparam_declarationContext)
}

func (s *Specify_itemContext) Pulsestyle_declaration() IPulsestyle_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPulsestyle_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPulsestyle_declarationContext)
}

func (s *Specify_itemContext) Showcancelled_declaration() IShowcancelled_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IShowcancelled_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IShowcancelled_declarationContext)
}

func (s *Specify_itemContext) Path_declaration() IPath_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPath_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPath_declarationContext)
}

func (s *Specify_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Specify_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Specify_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterSpecify_item(s)
	}
}

func (s *Specify_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitSpecify_item(s)
	}
}

func (p *SystemVerilogParser) Specify_item() (localctx ISpecify_itemContext) {
	this := p
	_ = this

	localctx = NewSpecify_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 886, SystemVerilogParserRULE_specify_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6623)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserKSPECPARAM:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6619)
			p.Specparam_declaration()
		}

	case SystemVerilogParserKPULSESTYLE_ONDETECT, SystemVerilogParserKPULSESTYLE_ONEVENT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6620)
			p.Pulsestyle_declaration()
		}

	case SystemVerilogParserKNOSHOWCANCELLED, SystemVerilogParserKSHOWCANCELLED:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6621)
			p.Showcancelled_declaration()
		}

	case SystemVerilogParserLP, SystemVerilogParserKIF, SystemVerilogParserKIFNONE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6622)
			p.Path_declaration()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPulsestyle_declarationContext is an interface to support dynamic dispatch.
type IPulsestyle_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPulsestyle_declarationContext differentiates from other interfaces.
	IsPulsestyle_declarationContext()
}

type Pulsestyle_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPulsestyle_declarationContext() *Pulsestyle_declarationContext {
	var p = new(Pulsestyle_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_pulsestyle_declaration
	return p
}

func (*Pulsestyle_declarationContext) IsPulsestyle_declarationContext() {}

func NewPulsestyle_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pulsestyle_declarationContext {
	var p = new(Pulsestyle_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_pulsestyle_declaration

	return p
}

func (s *Pulsestyle_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Pulsestyle_declarationContext) List_of_path_outputs() IList_of_path_outputsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_path_outputsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_path_outputsContext)
}

func (s *Pulsestyle_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Pulsestyle_declarationContext) KPULSESTYLE_ONEVENT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKPULSESTYLE_ONEVENT, 0)
}

func (s *Pulsestyle_declarationContext) KPULSESTYLE_ONDETECT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKPULSESTYLE_ONDETECT, 0)
}

func (s *Pulsestyle_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pulsestyle_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pulsestyle_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterPulsestyle_declaration(s)
	}
}

func (s *Pulsestyle_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitPulsestyle_declaration(s)
	}
}

func (p *SystemVerilogParser) Pulsestyle_declaration() (localctx IPulsestyle_declarationContext) {
	this := p
	_ = this

	localctx = NewPulsestyle_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 888, SystemVerilogParserRULE_pulsestyle_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6625)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SystemVerilogParserKPULSESTYLE_ONDETECT || _la == SystemVerilogParserKPULSESTYLE_ONEVENT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(6626)
		p.List_of_path_outputs()
	}
	{
		p.SetState(6627)
		p.Match(SystemVerilogParserSEMI)
	}

	return localctx
}

// IShowcancelled_declarationContext is an interface to support dynamic dispatch.
type IShowcancelled_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsShowcancelled_declarationContext differentiates from other interfaces.
	IsShowcancelled_declarationContext()
}

type Showcancelled_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowcancelled_declarationContext() *Showcancelled_declarationContext {
	var p = new(Showcancelled_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_showcancelled_declaration
	return p
}

func (*Showcancelled_declarationContext) IsShowcancelled_declarationContext() {}

func NewShowcancelled_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Showcancelled_declarationContext {
	var p = new(Showcancelled_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_showcancelled_declaration

	return p
}

func (s *Showcancelled_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Showcancelled_declarationContext) List_of_path_outputs() IList_of_path_outputsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_path_outputsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_path_outputsContext)
}

func (s *Showcancelled_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Showcancelled_declarationContext) KSHOWCANCELLED() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKSHOWCANCELLED, 0)
}

func (s *Showcancelled_declarationContext) KNOSHOWCANCELLED() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKNOSHOWCANCELLED, 0)
}

func (s *Showcancelled_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Showcancelled_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Showcancelled_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterShowcancelled_declaration(s)
	}
}

func (s *Showcancelled_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitShowcancelled_declaration(s)
	}
}

func (p *SystemVerilogParser) Showcancelled_declaration() (localctx IShowcancelled_declarationContext) {
	this := p
	_ = this

	localctx = NewShowcancelled_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 890, SystemVerilogParserRULE_showcancelled_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6629)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SystemVerilogParserKNOSHOWCANCELLED || _la == SystemVerilogParserKSHOWCANCELLED) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(6630)
		p.List_of_path_outputs()
	}
	{
		p.SetState(6631)
		p.Match(SystemVerilogParserSEMI)
	}

	return localctx
}

// IPath_declarationContext is an interface to support dynamic dispatch.
type IPath_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPath_declarationContext differentiates from other interfaces.
	IsPath_declarationContext()
}

type Path_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPath_declarationContext() *Path_declarationContext {
	var p = new(Path_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_path_declaration
	return p
}

func (*Path_declarationContext) IsPath_declarationContext() {}

func NewPath_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Path_declarationContext {
	var p = new(Path_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_path_declaration

	return p
}

func (s *Path_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Path_declarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSEMI, 0)
}

func (s *Path_declarationContext) Simple_path_declaration() ISimple_path_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_path_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimple_path_declarationContext)
}

func (s *Path_declarationContext) Edge_sensitive_path_declaration() IEdge_sensitive_path_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEdge_sensitive_path_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEdge_sensitive_path_declarationContext)
}

func (s *Path_declarationContext) State_dependent_path_declaration() IState_dependent_path_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IState_dependent_path_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IState_dependent_path_declarationContext)
}

func (s *Path_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Path_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Path_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterPath_declaration(s)
	}
}

func (s *Path_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitPath_declaration(s)
	}
}

func (p *SystemVerilogParser) Path_declaration() (localctx IPath_declarationContext) {
	this := p
	_ = this

	localctx = NewPath_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 892, SystemVerilogParserRULE_path_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(6636)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 821, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(6633)
			p.Simple_path_declaration()
		}

	case 2:
		{
			p.SetState(6634)
			p.Edge_sensitive_path_declaration()
		}

	case 3:
		{
			p.SetState(6635)
			p.State_dependent_path_declaration()
		}

	}
	{
		p.SetState(6638)
		p.Match(SystemVerilogParserSEMI)
	}

	return localctx
}

// ISimple_path_declarationContext is an interface to support dynamic dispatch.
type ISimple_path_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimple_path_declarationContext differentiates from other interfaces.
	IsSimple_path_declarationContext()
}

type Simple_path_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimple_path_declarationContext() *Simple_path_declarationContext {
	var p = new(Simple_path_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_simple_path_declaration
	return p
}

func (*Simple_path_declarationContext) IsSimple_path_declarationContext() {}

func NewSimple_path_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Simple_path_declarationContext {
	var p = new(Simple_path_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_simple_path_declaration

	return p
}

func (s *Simple_path_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Simple_path_declarationContext) EQ() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserEQ, 0)
}

func (s *Simple_path_declarationContext) Path_delay_value() IPath_delay_valueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPath_delay_valueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPath_delay_valueContext)
}

func (s *Simple_path_declarationContext) Parallel_path_description() IParallel_path_descriptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParallel_path_descriptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParallel_path_descriptionContext)
}

func (s *Simple_path_declarationContext) Full_path_description() IFull_path_descriptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFull_path_descriptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFull_path_descriptionContext)
}

func (s *Simple_path_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Simple_path_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Simple_path_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterSimple_path_declaration(s)
	}
}

func (s *Simple_path_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitSimple_path_declaration(s)
	}
}

func (p *SystemVerilogParser) Simple_path_declaration() (localctx ISimple_path_declarationContext) {
	this := p
	_ = this

	localctx = NewSimple_path_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 894, SystemVerilogParserRULE_simple_path_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(6642)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 822, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(6640)
			p.Parallel_path_description()
		}

	case 2:
		{
			p.SetState(6641)
			p.Full_path_description()
		}

	}
	{
		p.SetState(6644)
		p.Match(SystemVerilogParserEQ)
	}
	{
		p.SetState(6645)
		p.Path_delay_value()
	}

	return localctx
}

// IParallel_path_descriptionContext is an interface to support dynamic dispatch.
type IParallel_path_descriptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParallel_path_descriptionContext differentiates from other interfaces.
	IsParallel_path_descriptionContext()
}

type Parallel_path_descriptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParallel_path_descriptionContext() *Parallel_path_descriptionContext {
	var p = new(Parallel_path_descriptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_parallel_path_description
	return p
}

func (*Parallel_path_descriptionContext) IsParallel_path_descriptionContext() {}

func NewParallel_path_descriptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Parallel_path_descriptionContext {
	var p = new(Parallel_path_descriptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_parallel_path_description

	return p
}

func (s *Parallel_path_descriptionContext) GetParser() antlr.Parser { return s.parser }

func (s *Parallel_path_descriptionContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Parallel_path_descriptionContext) Specify_input_terminal_descriptor() ISpecify_input_terminal_descriptorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecify_input_terminal_descriptorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpecify_input_terminal_descriptorContext)
}

func (s *Parallel_path_descriptionContext) EQGT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserEQGT, 0)
}

func (s *Parallel_path_descriptionContext) Specify_output_terminal_descriptor() ISpecify_output_terminal_descriptorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecify_output_terminal_descriptorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpecify_output_terminal_descriptorContext)
}

func (s *Parallel_path_descriptionContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Parallel_path_descriptionContext) Polarity_operator() IPolarity_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPolarity_operatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPolarity_operatorContext)
}

func (s *Parallel_path_descriptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parallel_path_descriptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Parallel_path_descriptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterParallel_path_description(s)
	}
}

func (s *Parallel_path_descriptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitParallel_path_description(s)
	}
}

func (p *SystemVerilogParser) Parallel_path_description() (localctx IParallel_path_descriptionContext) {
	this := p
	_ = this

	localctx = NewParallel_path_descriptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 896, SystemVerilogParserRULE_parallel_path_description)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6647)
		p.Match(SystemVerilogParserLP)
	}
	{
		p.SetState(6648)
		p.Specify_input_terminal_descriptor()
	}
	p.SetState(6650)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserMINUS || _la == SystemVerilogParserPLUS {
		{
			p.SetState(6649)
			p.Polarity_operator()
		}

	}
	{
		p.SetState(6652)
		p.Match(SystemVerilogParserEQGT)
	}
	{
		p.SetState(6653)
		p.Specify_output_terminal_descriptor()
	}
	{
		p.SetState(6654)
		p.Match(SystemVerilogParserRP)
	}

	return localctx
}

// IFull_path_descriptionContext is an interface to support dynamic dispatch.
type IFull_path_descriptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFull_path_descriptionContext differentiates from other interfaces.
	IsFull_path_descriptionContext()
}

type Full_path_descriptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFull_path_descriptionContext() *Full_path_descriptionContext {
	var p = new(Full_path_descriptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_full_path_description
	return p
}

func (*Full_path_descriptionContext) IsFull_path_descriptionContext() {}

func NewFull_path_descriptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Full_path_descriptionContext {
	var p = new(Full_path_descriptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_full_path_description

	return p
}

func (s *Full_path_descriptionContext) GetParser() antlr.Parser { return s.parser }

func (s *Full_path_descriptionContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Full_path_descriptionContext) List_of_path_inputs() IList_of_path_inputsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_path_inputsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_path_inputsContext)
}

func (s *Full_path_descriptionContext) SGT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSGT, 0)
}

func (s *Full_path_descriptionContext) List_of_path_outputs() IList_of_path_outputsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_path_outputsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_path_outputsContext)
}

func (s *Full_path_descriptionContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Full_path_descriptionContext) Polarity_operator() IPolarity_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPolarity_operatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPolarity_operatorContext)
}

func (s *Full_path_descriptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Full_path_descriptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Full_path_descriptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterFull_path_description(s)
	}
}

func (s *Full_path_descriptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitFull_path_description(s)
	}
}

func (p *SystemVerilogParser) Full_path_description() (localctx IFull_path_descriptionContext) {
	this := p
	_ = this

	localctx = NewFull_path_descriptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 898, SystemVerilogParserRULE_full_path_description)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6656)
		p.Match(SystemVerilogParserLP)
	}
	{
		p.SetState(6657)
		p.List_of_path_inputs()
	}
	p.SetState(6659)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserMINUS || _la == SystemVerilogParserPLUS {
		{
			p.SetState(6658)
			p.Polarity_operator()
		}

	}
	{
		p.SetState(6661)
		p.Match(SystemVerilogParserSGT)
	}
	{
		p.SetState(6662)
		p.List_of_path_outputs()
	}
	{
		p.SetState(6663)
		p.Match(SystemVerilogParserRP)
	}

	return localctx
}

// IList_of_path_inputsContext is an interface to support dynamic dispatch.
type IList_of_path_inputsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_path_inputsContext differentiates from other interfaces.
	IsList_of_path_inputsContext()
}

type List_of_path_inputsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_path_inputsContext() *List_of_path_inputsContext {
	var p = new(List_of_path_inputsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_list_of_path_inputs
	return p
}

func (*List_of_path_inputsContext) IsList_of_path_inputsContext() {}

func NewList_of_path_inputsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_path_inputsContext {
	var p = new(List_of_path_inputsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_list_of_path_inputs

	return p
}

func (s *List_of_path_inputsContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_path_inputsContext) AllSpecify_input_terminal_descriptor() []ISpecify_input_terminal_descriptorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISpecify_input_terminal_descriptorContext)(nil)).Elem())
	var tst = make([]ISpecify_input_terminal_descriptorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISpecify_input_terminal_descriptorContext)
		}
	}

	return tst
}

func (s *List_of_path_inputsContext) Specify_input_terminal_descriptor(i int) ISpecify_input_terminal_descriptorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecify_input_terminal_descriptorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISpecify_input_terminal_descriptorContext)
}

func (s *List_of_path_inputsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *List_of_path_inputsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *List_of_path_inputsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_path_inputsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_path_inputsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterList_of_path_inputs(s)
	}
}

func (s *List_of_path_inputsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitList_of_path_inputs(s)
	}
}

func (p *SystemVerilogParser) List_of_path_inputs() (localctx IList_of_path_inputsContext) {
	this := p
	_ = this

	localctx = NewList_of_path_inputsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 900, SystemVerilogParserRULE_list_of_path_inputs)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6665)
		p.Specify_input_terminal_descriptor()
	}
	p.SetState(6670)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserCOMMA {
		{
			p.SetState(6666)
			p.Match(SystemVerilogParserCOMMA)
		}
		{
			p.SetState(6667)
			p.Specify_input_terminal_descriptor()
		}

		p.SetState(6672)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IList_of_path_outputsContext is an interface to support dynamic dispatch.
type IList_of_path_outputsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_path_outputsContext differentiates from other interfaces.
	IsList_of_path_outputsContext()
}

type List_of_path_outputsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_path_outputsContext() *List_of_path_outputsContext {
	var p = new(List_of_path_outputsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_list_of_path_outputs
	return p
}

func (*List_of_path_outputsContext) IsList_of_path_outputsContext() {}

func NewList_of_path_outputsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_path_outputsContext {
	var p = new(List_of_path_outputsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_list_of_path_outputs

	return p
}

func (s *List_of_path_outputsContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_path_outputsContext) AllSpecify_output_terminal_descriptor() []ISpecify_output_terminal_descriptorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISpecify_output_terminal_descriptorContext)(nil)).Elem())
	var tst = make([]ISpecify_output_terminal_descriptorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISpecify_output_terminal_descriptorContext)
		}
	}

	return tst
}

func (s *List_of_path_outputsContext) Specify_output_terminal_descriptor(i int) ISpecify_output_terminal_descriptorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecify_output_terminal_descriptorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISpecify_output_terminal_descriptorContext)
}

func (s *List_of_path_outputsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *List_of_path_outputsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *List_of_path_outputsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_path_outputsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_path_outputsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterList_of_path_outputs(s)
	}
}

func (s *List_of_path_outputsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitList_of_path_outputs(s)
	}
}

func (p *SystemVerilogParser) List_of_path_outputs() (localctx IList_of_path_outputsContext) {
	this := p
	_ = this

	localctx = NewList_of_path_outputsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 902, SystemVerilogParserRULE_list_of_path_outputs)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6673)
		p.Specify_output_terminal_descriptor()
	}
	p.SetState(6678)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserCOMMA {
		{
			p.SetState(6674)
			p.Match(SystemVerilogParserCOMMA)
		}
		{
			p.SetState(6675)
			p.Specify_output_terminal_descriptor()
		}

		p.SetState(6680)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISpecify_input_terminal_descriptorContext is an interface to support dynamic dispatch.
type ISpecify_input_terminal_descriptorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSpecify_input_terminal_descriptorContext differentiates from other interfaces.
	IsSpecify_input_terminal_descriptorContext()
}

type Specify_input_terminal_descriptorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpecify_input_terminal_descriptorContext() *Specify_input_terminal_descriptorContext {
	var p = new(Specify_input_terminal_descriptorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_specify_input_terminal_descriptor
	return p
}

func (*Specify_input_terminal_descriptorContext) IsSpecify_input_terminal_descriptorContext() {}

func NewSpecify_input_terminal_descriptorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Specify_input_terminal_descriptorContext {
	var p = new(Specify_input_terminal_descriptorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_specify_input_terminal_descriptor

	return p
}

func (s *Specify_input_terminal_descriptorContext) GetParser() antlr.Parser { return s.parser }

func (s *Specify_input_terminal_descriptorContext) Input_identifier() IInput_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInput_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInput_identifierContext)
}

func (s *Specify_input_terminal_descriptorContext) LB() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLB, 0)
}

func (s *Specify_input_terminal_descriptorContext) Constant_range_expression() IConstant_range_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_range_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_range_expressionContext)
}

func (s *Specify_input_terminal_descriptorContext) RB() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRB, 0)
}

func (s *Specify_input_terminal_descriptorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Specify_input_terminal_descriptorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Specify_input_terminal_descriptorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterSpecify_input_terminal_descriptor(s)
	}
}

func (s *Specify_input_terminal_descriptorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitSpecify_input_terminal_descriptor(s)
	}
}

func (p *SystemVerilogParser) Specify_input_terminal_descriptor() (localctx ISpecify_input_terminal_descriptorContext) {
	this := p
	_ = this

	localctx = NewSpecify_input_terminal_descriptorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 904, SystemVerilogParserRULE_specify_input_terminal_descriptor)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6681)
		p.Input_identifier()
	}
	p.SetState(6686)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserLB {
		{
			p.SetState(6682)
			p.Match(SystemVerilogParserLB)
		}
		{
			p.SetState(6683)
			p.Constant_range_expression()
		}
		{
			p.SetState(6684)
			p.Match(SystemVerilogParserRB)
		}

	}

	return localctx
}

// ISpecify_output_terminal_descriptorContext is an interface to support dynamic dispatch.
type ISpecify_output_terminal_descriptorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSpecify_output_terminal_descriptorContext differentiates from other interfaces.
	IsSpecify_output_terminal_descriptorContext()
}

type Specify_output_terminal_descriptorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpecify_output_terminal_descriptorContext() *Specify_output_terminal_descriptorContext {
	var p = new(Specify_output_terminal_descriptorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_specify_output_terminal_descriptor
	return p
}

func (*Specify_output_terminal_descriptorContext) IsSpecify_output_terminal_descriptorContext() {}

func NewSpecify_output_terminal_descriptorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Specify_output_terminal_descriptorContext {
	var p = new(Specify_output_terminal_descriptorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_specify_output_terminal_descriptor

	return p
}

func (s *Specify_output_terminal_descriptorContext) GetParser() antlr.Parser { return s.parser }

func (s *Specify_output_terminal_descriptorContext) Output_identifier() IOutput_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOutput_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOutput_identifierContext)
}

func (s *Specify_output_terminal_descriptorContext) LB() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLB, 0)
}

func (s *Specify_output_terminal_descriptorContext) Constant_range_expression() IConstant_range_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_range_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_range_expressionContext)
}

func (s *Specify_output_terminal_descriptorContext) RB() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRB, 0)
}

func (s *Specify_output_terminal_descriptorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Specify_output_terminal_descriptorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Specify_output_terminal_descriptorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterSpecify_output_terminal_descriptor(s)
	}
}

func (s *Specify_output_terminal_descriptorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitSpecify_output_terminal_descriptor(s)
	}
}

func (p *SystemVerilogParser) Specify_output_terminal_descriptor() (localctx ISpecify_output_terminal_descriptorContext) {
	this := p
	_ = this

	localctx = NewSpecify_output_terminal_descriptorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 906, SystemVerilogParserRULE_specify_output_terminal_descriptor)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6688)
		p.Output_identifier()
	}
	p.SetState(6693)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserLB {
		{
			p.SetState(6689)
			p.Match(SystemVerilogParserLB)
		}
		{
			p.SetState(6690)
			p.Constant_range_expression()
		}
		{
			p.SetState(6691)
			p.Match(SystemVerilogParserRB)
		}

	}

	return localctx
}

// IInput_identifierContext is an interface to support dynamic dispatch.
type IInput_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInput_identifierContext differentiates from other interfaces.
	IsInput_identifierContext()
}

type Input_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInput_identifierContext() *Input_identifierContext {
	var p = new(Input_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_input_identifier
	return p
}

func (*Input_identifierContext) IsInput_identifierContext() {}

func NewInput_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Input_identifierContext {
	var p = new(Input_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_input_identifier

	return p
}

func (s *Input_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Input_identifierContext) Input_port_identifier() IInput_port_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInput_port_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInput_port_identifierContext)
}

func (s *Input_identifierContext) Inout_port_identifier() IInout_port_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInout_port_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInout_port_identifierContext)
}

func (s *Input_identifierContext) Interface_identifier() IInterface_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterface_identifierContext)
}

func (s *Input_identifierContext) DOT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserDOT, 0)
}

func (s *Input_identifierContext) Port_identifier() IPort_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPort_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPort_identifierContext)
}

func (s *Input_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Input_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Input_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterInput_identifier(s)
	}
}

func (s *Input_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitInput_identifier(s)
	}
}

func (p *SystemVerilogParser) Input_identifier() (localctx IInput_identifierContext) {
	this := p
	_ = this

	localctx = NewInput_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 908, SystemVerilogParserRULE_input_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6701)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 829, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6695)
			p.Input_port_identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6696)
			p.Inout_port_identifier()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6697)
			p.Interface_identifier()
		}
		{
			p.SetState(6698)
			p.Match(SystemVerilogParserDOT)
		}
		{
			p.SetState(6699)
			p.Port_identifier()
		}

	}

	return localctx
}

// IOutput_identifierContext is an interface to support dynamic dispatch.
type IOutput_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOutput_identifierContext differentiates from other interfaces.
	IsOutput_identifierContext()
}

type Output_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOutput_identifierContext() *Output_identifierContext {
	var p = new(Output_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_output_identifier
	return p
}

func (*Output_identifierContext) IsOutput_identifierContext() {}

func NewOutput_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Output_identifierContext {
	var p = new(Output_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_output_identifier

	return p
}

func (s *Output_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Output_identifierContext) Output_port_identifier() IOutput_port_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOutput_port_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOutput_port_identifierContext)
}

func (s *Output_identifierContext) Inout_port_identifier() IInout_port_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInout_port_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInout_port_identifierContext)
}

func (s *Output_identifierContext) Interface_identifier() IInterface_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterface_identifierContext)
}

func (s *Output_identifierContext) DOT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserDOT, 0)
}

func (s *Output_identifierContext) Port_identifier() IPort_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPort_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPort_identifierContext)
}

func (s *Output_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Output_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Output_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterOutput_identifier(s)
	}
}

func (s *Output_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitOutput_identifier(s)
	}
}

func (p *SystemVerilogParser) Output_identifier() (localctx IOutput_identifierContext) {
	this := p
	_ = this

	localctx = NewOutput_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 910, SystemVerilogParserRULE_output_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6709)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 830, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6703)
			p.Output_port_identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6704)
			p.Inout_port_identifier()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6705)
			p.Interface_identifier()
		}
		{
			p.SetState(6706)
			p.Match(SystemVerilogParserDOT)
		}
		{
			p.SetState(6707)
			p.Port_identifier()
		}

	}

	return localctx
}

// IPath_delay_valueContext is an interface to support dynamic dispatch.
type IPath_delay_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPath_delay_valueContext differentiates from other interfaces.
	IsPath_delay_valueContext()
}

type Path_delay_valueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPath_delay_valueContext() *Path_delay_valueContext {
	var p = new(Path_delay_valueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_path_delay_value
	return p
}

func (*Path_delay_valueContext) IsPath_delay_valueContext() {}

func NewPath_delay_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Path_delay_valueContext {
	var p = new(Path_delay_valueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_path_delay_value

	return p
}

func (s *Path_delay_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *Path_delay_valueContext) List_of_path_delay_expressions() IList_of_path_delay_expressionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_path_delay_expressionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_path_delay_expressionsContext)
}

func (s *Path_delay_valueContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Path_delay_valueContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Path_delay_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Path_delay_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Path_delay_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterPath_delay_value(s)
	}
}

func (s *Path_delay_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitPath_delay_value(s)
	}
}

func (p *SystemVerilogParser) Path_delay_value() (localctx IPath_delay_valueContext) {
	this := p
	_ = this

	localctx = NewPath_delay_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 912, SystemVerilogParserRULE_path_delay_value)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6716)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 831, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6711)
			p.List_of_path_delay_expressions()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6712)
			p.Match(SystemVerilogParserLP)
		}
		{
			p.SetState(6713)
			p.List_of_path_delay_expressions()
		}
		{
			p.SetState(6714)
			p.Match(SystemVerilogParserRP)
		}

	}

	return localctx
}

// IList_of_path_delay_expressionsContext is an interface to support dynamic dispatch.
type IList_of_path_delay_expressionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_path_delay_expressionsContext differentiates from other interfaces.
	IsList_of_path_delay_expressionsContext()
}

type List_of_path_delay_expressionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_path_delay_expressionsContext() *List_of_path_delay_expressionsContext {
	var p = new(List_of_path_delay_expressionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_list_of_path_delay_expressions
	return p
}

func (*List_of_path_delay_expressionsContext) IsList_of_path_delay_expressionsContext() {}

func NewList_of_path_delay_expressionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_path_delay_expressionsContext {
	var p = new(List_of_path_delay_expressionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_list_of_path_delay_expressions

	return p
}

func (s *List_of_path_delay_expressionsContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_path_delay_expressionsContext) T_path_delay_expression() IT_path_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IT_path_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IT_path_delay_expressionContext)
}

func (s *List_of_path_delay_expressionsContext) Trise_path_delay_expression() ITrise_path_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITrise_path_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITrise_path_delay_expressionContext)
}

func (s *List_of_path_delay_expressionsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *List_of_path_delay_expressionsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *List_of_path_delay_expressionsContext) Tfall_path_delay_expression() ITfall_path_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITfall_path_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITfall_path_delay_expressionContext)
}

func (s *List_of_path_delay_expressionsContext) Tz_path_delay_expression() ITz_path_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITz_path_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITz_path_delay_expressionContext)
}

func (s *List_of_path_delay_expressionsContext) T01_path_delay_expression() IT01_path_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IT01_path_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IT01_path_delay_expressionContext)
}

func (s *List_of_path_delay_expressionsContext) T10_path_delay_expression() IT10_path_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IT10_path_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IT10_path_delay_expressionContext)
}

func (s *List_of_path_delay_expressionsContext) T0z_path_delay_expression() IT0z_path_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IT0z_path_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IT0z_path_delay_expressionContext)
}

func (s *List_of_path_delay_expressionsContext) Tz1_path_delay_expression() ITz1_path_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITz1_path_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITz1_path_delay_expressionContext)
}

func (s *List_of_path_delay_expressionsContext) T1z_path_delay_expression() IT1z_path_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IT1z_path_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IT1z_path_delay_expressionContext)
}

func (s *List_of_path_delay_expressionsContext) Tz0_path_delay_expression() ITz0_path_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITz0_path_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITz0_path_delay_expressionContext)
}

func (s *List_of_path_delay_expressionsContext) T0x_path_delay_expression() IT0x_path_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IT0x_path_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IT0x_path_delay_expressionContext)
}

func (s *List_of_path_delay_expressionsContext) Tx1_path_delay_expression() ITx1_path_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITx1_path_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITx1_path_delay_expressionContext)
}

func (s *List_of_path_delay_expressionsContext) T1x_path_delay_expression() IT1x_path_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IT1x_path_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IT1x_path_delay_expressionContext)
}

func (s *List_of_path_delay_expressionsContext) Tx0_path_delay_expression() ITx0_path_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITx0_path_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITx0_path_delay_expressionContext)
}

func (s *List_of_path_delay_expressionsContext) Txz_path_delay_expression() ITxz_path_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITxz_path_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITxz_path_delay_expressionContext)
}

func (s *List_of_path_delay_expressionsContext) Tzx_path_delay_expression() ITzx_path_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITzx_path_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITzx_path_delay_expressionContext)
}

func (s *List_of_path_delay_expressionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_path_delay_expressionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_path_delay_expressionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterList_of_path_delay_expressions(s)
	}
}

func (s *List_of_path_delay_expressionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitList_of_path_delay_expressions(s)
	}
}

func (p *SystemVerilogParser) List_of_path_delay_expressions() (localctx IList_of_path_delay_expressionsContext) {
	this := p
	_ = this

	localctx = NewList_of_path_delay_expressionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 914, SystemVerilogParserRULE_list_of_path_delay_expressions)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6752)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 834, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6718)
			p.T_path_delay_expression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6719)
			p.Trise_path_delay_expression()
		}
		{
			p.SetState(6720)
			p.Match(SystemVerilogParserCOMMA)
		}
		{
			p.SetState(6721)
			p.Tfall_path_delay_expression()
		}
		p.SetState(6724)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserCOMMA {
			{
				p.SetState(6722)
				p.Match(SystemVerilogParserCOMMA)
			}
			{
				p.SetState(6723)
				p.Tz_path_delay_expression()
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6726)
			p.T01_path_delay_expression()
		}
		{
			p.SetState(6727)
			p.Match(SystemVerilogParserCOMMA)
		}
		{
			p.SetState(6728)
			p.T10_path_delay_expression()
		}
		{
			p.SetState(6729)
			p.Match(SystemVerilogParserCOMMA)
		}
		{
			p.SetState(6730)
			p.T0z_path_delay_expression()
		}
		{
			p.SetState(6731)
			p.Match(SystemVerilogParserCOMMA)
		}
		{
			p.SetState(6732)
			p.Tz1_path_delay_expression()
		}
		{
			p.SetState(6733)
			p.Match(SystemVerilogParserCOMMA)
		}
		{
			p.SetState(6734)
			p.T1z_path_delay_expression()
		}
		{
			p.SetState(6735)
			p.Match(SystemVerilogParserCOMMA)
		}
		{
			p.SetState(6736)
			p.Tz0_path_delay_expression()
		}
		p.SetState(6750)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserCOMMA {
			{
				p.SetState(6737)
				p.Match(SystemVerilogParserCOMMA)
			}
			{
				p.SetState(6738)
				p.T0x_path_delay_expression()
			}
			{
				p.SetState(6739)
				p.Match(SystemVerilogParserCOMMA)
			}
			{
				p.SetState(6740)
				p.Tx1_path_delay_expression()
			}
			{
				p.SetState(6741)
				p.Match(SystemVerilogParserCOMMA)
			}
			{
				p.SetState(6742)
				p.T1x_path_delay_expression()
			}
			{
				p.SetState(6743)
				p.Match(SystemVerilogParserCOMMA)
			}
			{
				p.SetState(6744)
				p.Tx0_path_delay_expression()
			}
			{
				p.SetState(6745)
				p.Match(SystemVerilogParserCOMMA)
			}
			{
				p.SetState(6746)
				p.Txz_path_delay_expression()
			}
			{
				p.SetState(6747)
				p.Match(SystemVerilogParserCOMMA)
			}
			{
				p.SetState(6748)
				p.Tzx_path_delay_expression()
			}

		}

	}

	return localctx
}

// IT_path_delay_expressionContext is an interface to support dynamic dispatch.
type IT_path_delay_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsT_path_delay_expressionContext differentiates from other interfaces.
	IsT_path_delay_expressionContext()
}

type T_path_delay_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyT_path_delay_expressionContext() *T_path_delay_expressionContext {
	var p = new(T_path_delay_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_t_path_delay_expression
	return p
}

func (*T_path_delay_expressionContext) IsT_path_delay_expressionContext() {}

func NewT_path_delay_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *T_path_delay_expressionContext {
	var p = new(T_path_delay_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_t_path_delay_expression

	return p
}

func (s *T_path_delay_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *T_path_delay_expressionContext) Path_delay_expression() IPath_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPath_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPath_delay_expressionContext)
}

func (s *T_path_delay_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *T_path_delay_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *T_path_delay_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterT_path_delay_expression(s)
	}
}

func (s *T_path_delay_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitT_path_delay_expression(s)
	}
}

func (p *SystemVerilogParser) T_path_delay_expression() (localctx IT_path_delay_expressionContext) {
	this := p
	_ = this

	localctx = NewT_path_delay_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 916, SystemVerilogParserRULE_t_path_delay_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6754)
		p.Path_delay_expression()
	}

	return localctx
}

// ITrise_path_delay_expressionContext is an interface to support dynamic dispatch.
type ITrise_path_delay_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTrise_path_delay_expressionContext differentiates from other interfaces.
	IsTrise_path_delay_expressionContext()
}

type Trise_path_delay_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTrise_path_delay_expressionContext() *Trise_path_delay_expressionContext {
	var p = new(Trise_path_delay_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_trise_path_delay_expression
	return p
}

func (*Trise_path_delay_expressionContext) IsTrise_path_delay_expressionContext() {}

func NewTrise_path_delay_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Trise_path_delay_expressionContext {
	var p = new(Trise_path_delay_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_trise_path_delay_expression

	return p
}

func (s *Trise_path_delay_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Trise_path_delay_expressionContext) Path_delay_expression() IPath_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPath_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPath_delay_expressionContext)
}

func (s *Trise_path_delay_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Trise_path_delay_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Trise_path_delay_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterTrise_path_delay_expression(s)
	}
}

func (s *Trise_path_delay_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitTrise_path_delay_expression(s)
	}
}

func (p *SystemVerilogParser) Trise_path_delay_expression() (localctx ITrise_path_delay_expressionContext) {
	this := p
	_ = this

	localctx = NewTrise_path_delay_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 918, SystemVerilogParserRULE_trise_path_delay_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6756)
		p.Path_delay_expression()
	}

	return localctx
}

// ITfall_path_delay_expressionContext is an interface to support dynamic dispatch.
type ITfall_path_delay_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTfall_path_delay_expressionContext differentiates from other interfaces.
	IsTfall_path_delay_expressionContext()
}

type Tfall_path_delay_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTfall_path_delay_expressionContext() *Tfall_path_delay_expressionContext {
	var p = new(Tfall_path_delay_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_tfall_path_delay_expression
	return p
}

func (*Tfall_path_delay_expressionContext) IsTfall_path_delay_expressionContext() {}

func NewTfall_path_delay_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tfall_path_delay_expressionContext {
	var p = new(Tfall_path_delay_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_tfall_path_delay_expression

	return p
}

func (s *Tfall_path_delay_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Tfall_path_delay_expressionContext) Path_delay_expression() IPath_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPath_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPath_delay_expressionContext)
}

func (s *Tfall_path_delay_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tfall_path_delay_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tfall_path_delay_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterTfall_path_delay_expression(s)
	}
}

func (s *Tfall_path_delay_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitTfall_path_delay_expression(s)
	}
}

func (p *SystemVerilogParser) Tfall_path_delay_expression() (localctx ITfall_path_delay_expressionContext) {
	this := p
	_ = this

	localctx = NewTfall_path_delay_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 920, SystemVerilogParserRULE_tfall_path_delay_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6758)
		p.Path_delay_expression()
	}

	return localctx
}

// ITz_path_delay_expressionContext is an interface to support dynamic dispatch.
type ITz_path_delay_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTz_path_delay_expressionContext differentiates from other interfaces.
	IsTz_path_delay_expressionContext()
}

type Tz_path_delay_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTz_path_delay_expressionContext() *Tz_path_delay_expressionContext {
	var p = new(Tz_path_delay_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_tz_path_delay_expression
	return p
}

func (*Tz_path_delay_expressionContext) IsTz_path_delay_expressionContext() {}

func NewTz_path_delay_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tz_path_delay_expressionContext {
	var p = new(Tz_path_delay_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_tz_path_delay_expression

	return p
}

func (s *Tz_path_delay_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Tz_path_delay_expressionContext) Path_delay_expression() IPath_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPath_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPath_delay_expressionContext)
}

func (s *Tz_path_delay_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tz_path_delay_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tz_path_delay_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterTz_path_delay_expression(s)
	}
}

func (s *Tz_path_delay_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitTz_path_delay_expression(s)
	}
}

func (p *SystemVerilogParser) Tz_path_delay_expression() (localctx ITz_path_delay_expressionContext) {
	this := p
	_ = this

	localctx = NewTz_path_delay_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 922, SystemVerilogParserRULE_tz_path_delay_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6760)
		p.Path_delay_expression()
	}

	return localctx
}

// IT01_path_delay_expressionContext is an interface to support dynamic dispatch.
type IT01_path_delay_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsT01_path_delay_expressionContext differentiates from other interfaces.
	IsT01_path_delay_expressionContext()
}

type T01_path_delay_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyT01_path_delay_expressionContext() *T01_path_delay_expressionContext {
	var p = new(T01_path_delay_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_t01_path_delay_expression
	return p
}

func (*T01_path_delay_expressionContext) IsT01_path_delay_expressionContext() {}

func NewT01_path_delay_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *T01_path_delay_expressionContext {
	var p = new(T01_path_delay_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_t01_path_delay_expression

	return p
}

func (s *T01_path_delay_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *T01_path_delay_expressionContext) Path_delay_expression() IPath_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPath_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPath_delay_expressionContext)
}

func (s *T01_path_delay_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *T01_path_delay_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *T01_path_delay_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterT01_path_delay_expression(s)
	}
}

func (s *T01_path_delay_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitT01_path_delay_expression(s)
	}
}

func (p *SystemVerilogParser) T01_path_delay_expression() (localctx IT01_path_delay_expressionContext) {
	this := p
	_ = this

	localctx = NewT01_path_delay_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 924, SystemVerilogParserRULE_t01_path_delay_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6762)
		p.Path_delay_expression()
	}

	return localctx
}

// IT10_path_delay_expressionContext is an interface to support dynamic dispatch.
type IT10_path_delay_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsT10_path_delay_expressionContext differentiates from other interfaces.
	IsT10_path_delay_expressionContext()
}

type T10_path_delay_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyT10_path_delay_expressionContext() *T10_path_delay_expressionContext {
	var p = new(T10_path_delay_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_t10_path_delay_expression
	return p
}

func (*T10_path_delay_expressionContext) IsT10_path_delay_expressionContext() {}

func NewT10_path_delay_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *T10_path_delay_expressionContext {
	var p = new(T10_path_delay_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_t10_path_delay_expression

	return p
}

func (s *T10_path_delay_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *T10_path_delay_expressionContext) Path_delay_expression() IPath_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPath_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPath_delay_expressionContext)
}

func (s *T10_path_delay_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *T10_path_delay_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *T10_path_delay_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterT10_path_delay_expression(s)
	}
}

func (s *T10_path_delay_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitT10_path_delay_expression(s)
	}
}

func (p *SystemVerilogParser) T10_path_delay_expression() (localctx IT10_path_delay_expressionContext) {
	this := p
	_ = this

	localctx = NewT10_path_delay_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 926, SystemVerilogParserRULE_t10_path_delay_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6764)
		p.Path_delay_expression()
	}

	return localctx
}

// IT0z_path_delay_expressionContext is an interface to support dynamic dispatch.
type IT0z_path_delay_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsT0z_path_delay_expressionContext differentiates from other interfaces.
	IsT0z_path_delay_expressionContext()
}

type T0z_path_delay_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyT0z_path_delay_expressionContext() *T0z_path_delay_expressionContext {
	var p = new(T0z_path_delay_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_t0z_path_delay_expression
	return p
}

func (*T0z_path_delay_expressionContext) IsT0z_path_delay_expressionContext() {}

func NewT0z_path_delay_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *T0z_path_delay_expressionContext {
	var p = new(T0z_path_delay_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_t0z_path_delay_expression

	return p
}

func (s *T0z_path_delay_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *T0z_path_delay_expressionContext) Path_delay_expression() IPath_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPath_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPath_delay_expressionContext)
}

func (s *T0z_path_delay_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *T0z_path_delay_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *T0z_path_delay_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterT0z_path_delay_expression(s)
	}
}

func (s *T0z_path_delay_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitT0z_path_delay_expression(s)
	}
}

func (p *SystemVerilogParser) T0z_path_delay_expression() (localctx IT0z_path_delay_expressionContext) {
	this := p
	_ = this

	localctx = NewT0z_path_delay_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 928, SystemVerilogParserRULE_t0z_path_delay_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6766)
		p.Path_delay_expression()
	}

	return localctx
}

// ITz1_path_delay_expressionContext is an interface to support dynamic dispatch.
type ITz1_path_delay_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTz1_path_delay_expressionContext differentiates from other interfaces.
	IsTz1_path_delay_expressionContext()
}

type Tz1_path_delay_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTz1_path_delay_expressionContext() *Tz1_path_delay_expressionContext {
	var p = new(Tz1_path_delay_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_tz1_path_delay_expression
	return p
}

func (*Tz1_path_delay_expressionContext) IsTz1_path_delay_expressionContext() {}

func NewTz1_path_delay_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tz1_path_delay_expressionContext {
	var p = new(Tz1_path_delay_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_tz1_path_delay_expression

	return p
}

func (s *Tz1_path_delay_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Tz1_path_delay_expressionContext) Path_delay_expression() IPath_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPath_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPath_delay_expressionContext)
}

func (s *Tz1_path_delay_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tz1_path_delay_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tz1_path_delay_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterTz1_path_delay_expression(s)
	}
}

func (s *Tz1_path_delay_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitTz1_path_delay_expression(s)
	}
}

func (p *SystemVerilogParser) Tz1_path_delay_expression() (localctx ITz1_path_delay_expressionContext) {
	this := p
	_ = this

	localctx = NewTz1_path_delay_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 930, SystemVerilogParserRULE_tz1_path_delay_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6768)
		p.Path_delay_expression()
	}

	return localctx
}

// IT1z_path_delay_expressionContext is an interface to support dynamic dispatch.
type IT1z_path_delay_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsT1z_path_delay_expressionContext differentiates from other interfaces.
	IsT1z_path_delay_expressionContext()
}

type T1z_path_delay_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyT1z_path_delay_expressionContext() *T1z_path_delay_expressionContext {
	var p = new(T1z_path_delay_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_t1z_path_delay_expression
	return p
}

func (*T1z_path_delay_expressionContext) IsT1z_path_delay_expressionContext() {}

func NewT1z_path_delay_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *T1z_path_delay_expressionContext {
	var p = new(T1z_path_delay_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_t1z_path_delay_expression

	return p
}

func (s *T1z_path_delay_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *T1z_path_delay_expressionContext) Path_delay_expression() IPath_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPath_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPath_delay_expressionContext)
}

func (s *T1z_path_delay_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *T1z_path_delay_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *T1z_path_delay_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterT1z_path_delay_expression(s)
	}
}

func (s *T1z_path_delay_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitT1z_path_delay_expression(s)
	}
}

func (p *SystemVerilogParser) T1z_path_delay_expression() (localctx IT1z_path_delay_expressionContext) {
	this := p
	_ = this

	localctx = NewT1z_path_delay_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 932, SystemVerilogParserRULE_t1z_path_delay_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6770)
		p.Path_delay_expression()
	}

	return localctx
}

// ITz0_path_delay_expressionContext is an interface to support dynamic dispatch.
type ITz0_path_delay_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTz0_path_delay_expressionContext differentiates from other interfaces.
	IsTz0_path_delay_expressionContext()
}

type Tz0_path_delay_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTz0_path_delay_expressionContext() *Tz0_path_delay_expressionContext {
	var p = new(Tz0_path_delay_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_tz0_path_delay_expression
	return p
}

func (*Tz0_path_delay_expressionContext) IsTz0_path_delay_expressionContext() {}

func NewTz0_path_delay_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tz0_path_delay_expressionContext {
	var p = new(Tz0_path_delay_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_tz0_path_delay_expression

	return p
}

func (s *Tz0_path_delay_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Tz0_path_delay_expressionContext) Path_delay_expression() IPath_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPath_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPath_delay_expressionContext)
}

func (s *Tz0_path_delay_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tz0_path_delay_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tz0_path_delay_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterTz0_path_delay_expression(s)
	}
}

func (s *Tz0_path_delay_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitTz0_path_delay_expression(s)
	}
}

func (p *SystemVerilogParser) Tz0_path_delay_expression() (localctx ITz0_path_delay_expressionContext) {
	this := p
	_ = this

	localctx = NewTz0_path_delay_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 934, SystemVerilogParserRULE_tz0_path_delay_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6772)
		p.Path_delay_expression()
	}

	return localctx
}

// IT0x_path_delay_expressionContext is an interface to support dynamic dispatch.
type IT0x_path_delay_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsT0x_path_delay_expressionContext differentiates from other interfaces.
	IsT0x_path_delay_expressionContext()
}

type T0x_path_delay_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyT0x_path_delay_expressionContext() *T0x_path_delay_expressionContext {
	var p = new(T0x_path_delay_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_t0x_path_delay_expression
	return p
}

func (*T0x_path_delay_expressionContext) IsT0x_path_delay_expressionContext() {}

func NewT0x_path_delay_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *T0x_path_delay_expressionContext {
	var p = new(T0x_path_delay_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_t0x_path_delay_expression

	return p
}

func (s *T0x_path_delay_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *T0x_path_delay_expressionContext) Path_delay_expression() IPath_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPath_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPath_delay_expressionContext)
}

func (s *T0x_path_delay_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *T0x_path_delay_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *T0x_path_delay_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterT0x_path_delay_expression(s)
	}
}

func (s *T0x_path_delay_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitT0x_path_delay_expression(s)
	}
}

func (p *SystemVerilogParser) T0x_path_delay_expression() (localctx IT0x_path_delay_expressionContext) {
	this := p
	_ = this

	localctx = NewT0x_path_delay_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 936, SystemVerilogParserRULE_t0x_path_delay_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6774)
		p.Path_delay_expression()
	}

	return localctx
}

// ITx1_path_delay_expressionContext is an interface to support dynamic dispatch.
type ITx1_path_delay_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTx1_path_delay_expressionContext differentiates from other interfaces.
	IsTx1_path_delay_expressionContext()
}

type Tx1_path_delay_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTx1_path_delay_expressionContext() *Tx1_path_delay_expressionContext {
	var p = new(Tx1_path_delay_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_tx1_path_delay_expression
	return p
}

func (*Tx1_path_delay_expressionContext) IsTx1_path_delay_expressionContext() {}

func NewTx1_path_delay_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tx1_path_delay_expressionContext {
	var p = new(Tx1_path_delay_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_tx1_path_delay_expression

	return p
}

func (s *Tx1_path_delay_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Tx1_path_delay_expressionContext) Path_delay_expression() IPath_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPath_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPath_delay_expressionContext)
}

func (s *Tx1_path_delay_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tx1_path_delay_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tx1_path_delay_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterTx1_path_delay_expression(s)
	}
}

func (s *Tx1_path_delay_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitTx1_path_delay_expression(s)
	}
}

func (p *SystemVerilogParser) Tx1_path_delay_expression() (localctx ITx1_path_delay_expressionContext) {
	this := p
	_ = this

	localctx = NewTx1_path_delay_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 938, SystemVerilogParserRULE_tx1_path_delay_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6776)
		p.Path_delay_expression()
	}

	return localctx
}

// IT1x_path_delay_expressionContext is an interface to support dynamic dispatch.
type IT1x_path_delay_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsT1x_path_delay_expressionContext differentiates from other interfaces.
	IsT1x_path_delay_expressionContext()
}

type T1x_path_delay_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyT1x_path_delay_expressionContext() *T1x_path_delay_expressionContext {
	var p = new(T1x_path_delay_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_t1x_path_delay_expression
	return p
}

func (*T1x_path_delay_expressionContext) IsT1x_path_delay_expressionContext() {}

func NewT1x_path_delay_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *T1x_path_delay_expressionContext {
	var p = new(T1x_path_delay_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_t1x_path_delay_expression

	return p
}

func (s *T1x_path_delay_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *T1x_path_delay_expressionContext) Path_delay_expression() IPath_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPath_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPath_delay_expressionContext)
}

func (s *T1x_path_delay_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *T1x_path_delay_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *T1x_path_delay_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterT1x_path_delay_expression(s)
	}
}

func (s *T1x_path_delay_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitT1x_path_delay_expression(s)
	}
}

func (p *SystemVerilogParser) T1x_path_delay_expression() (localctx IT1x_path_delay_expressionContext) {
	this := p
	_ = this

	localctx = NewT1x_path_delay_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 940, SystemVerilogParserRULE_t1x_path_delay_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6778)
		p.Path_delay_expression()
	}

	return localctx
}

// ITx0_path_delay_expressionContext is an interface to support dynamic dispatch.
type ITx0_path_delay_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTx0_path_delay_expressionContext differentiates from other interfaces.
	IsTx0_path_delay_expressionContext()
}

type Tx0_path_delay_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTx0_path_delay_expressionContext() *Tx0_path_delay_expressionContext {
	var p = new(Tx0_path_delay_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_tx0_path_delay_expression
	return p
}

func (*Tx0_path_delay_expressionContext) IsTx0_path_delay_expressionContext() {}

func NewTx0_path_delay_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tx0_path_delay_expressionContext {
	var p = new(Tx0_path_delay_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_tx0_path_delay_expression

	return p
}

func (s *Tx0_path_delay_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Tx0_path_delay_expressionContext) Path_delay_expression() IPath_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPath_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPath_delay_expressionContext)
}

func (s *Tx0_path_delay_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tx0_path_delay_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tx0_path_delay_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterTx0_path_delay_expression(s)
	}
}

func (s *Tx0_path_delay_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitTx0_path_delay_expression(s)
	}
}

func (p *SystemVerilogParser) Tx0_path_delay_expression() (localctx ITx0_path_delay_expressionContext) {
	this := p
	_ = this

	localctx = NewTx0_path_delay_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 942, SystemVerilogParserRULE_tx0_path_delay_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6780)
		p.Path_delay_expression()
	}

	return localctx
}

// ITxz_path_delay_expressionContext is an interface to support dynamic dispatch.
type ITxz_path_delay_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTxz_path_delay_expressionContext differentiates from other interfaces.
	IsTxz_path_delay_expressionContext()
}

type Txz_path_delay_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTxz_path_delay_expressionContext() *Txz_path_delay_expressionContext {
	var p = new(Txz_path_delay_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_txz_path_delay_expression
	return p
}

func (*Txz_path_delay_expressionContext) IsTxz_path_delay_expressionContext() {}

func NewTxz_path_delay_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Txz_path_delay_expressionContext {
	var p = new(Txz_path_delay_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_txz_path_delay_expression

	return p
}

func (s *Txz_path_delay_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Txz_path_delay_expressionContext) Path_delay_expression() IPath_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPath_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPath_delay_expressionContext)
}

func (s *Txz_path_delay_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Txz_path_delay_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Txz_path_delay_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterTxz_path_delay_expression(s)
	}
}

func (s *Txz_path_delay_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitTxz_path_delay_expression(s)
	}
}

func (p *SystemVerilogParser) Txz_path_delay_expression() (localctx ITxz_path_delay_expressionContext) {
	this := p
	_ = this

	localctx = NewTxz_path_delay_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 944, SystemVerilogParserRULE_txz_path_delay_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6782)
		p.Path_delay_expression()
	}

	return localctx
}

// ITzx_path_delay_expressionContext is an interface to support dynamic dispatch.
type ITzx_path_delay_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTzx_path_delay_expressionContext differentiates from other interfaces.
	IsTzx_path_delay_expressionContext()
}

type Tzx_path_delay_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTzx_path_delay_expressionContext() *Tzx_path_delay_expressionContext {
	var p = new(Tzx_path_delay_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_tzx_path_delay_expression
	return p
}

func (*Tzx_path_delay_expressionContext) IsTzx_path_delay_expressionContext() {}

func NewTzx_path_delay_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tzx_path_delay_expressionContext {
	var p = new(Tzx_path_delay_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_tzx_path_delay_expression

	return p
}

func (s *Tzx_path_delay_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Tzx_path_delay_expressionContext) Path_delay_expression() IPath_delay_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPath_delay_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPath_delay_expressionContext)
}

func (s *Tzx_path_delay_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tzx_path_delay_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tzx_path_delay_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterTzx_path_delay_expression(s)
	}
}

func (s *Tzx_path_delay_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitTzx_path_delay_expression(s)
	}
}

func (p *SystemVerilogParser) Tzx_path_delay_expression() (localctx ITzx_path_delay_expressionContext) {
	this := p
	_ = this

	localctx = NewTzx_path_delay_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 946, SystemVerilogParserRULE_tzx_path_delay_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6784)
		p.Path_delay_expression()
	}

	return localctx
}

// IPath_delay_expressionContext is an interface to support dynamic dispatch.
type IPath_delay_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPath_delay_expressionContext differentiates from other interfaces.
	IsPath_delay_expressionContext()
}

type Path_delay_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPath_delay_expressionContext() *Path_delay_expressionContext {
	var p = new(Path_delay_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_path_delay_expression
	return p
}

func (*Path_delay_expressionContext) IsPath_delay_expressionContext() {}

func NewPath_delay_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Path_delay_expressionContext {
	var p = new(Path_delay_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_path_delay_expression

	return p
}

func (s *Path_delay_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Path_delay_expressionContext) Constant_mintypmax_expression() IConstant_mintypmax_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_mintypmax_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_mintypmax_expressionContext)
}

func (s *Path_delay_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Path_delay_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Path_delay_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterPath_delay_expression(s)
	}
}

func (s *Path_delay_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitPath_delay_expression(s)
	}
}

func (p *SystemVerilogParser) Path_delay_expression() (localctx IPath_delay_expressionContext) {
	this := p
	_ = this

	localctx = NewPath_delay_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 948, SystemVerilogParserRULE_path_delay_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6786)
		p.Constant_mintypmax_expression()
	}

	return localctx
}

// IEdge_sensitive_path_declarationContext is an interface to support dynamic dispatch.
type IEdge_sensitive_path_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEdge_sensitive_path_declarationContext differentiates from other interfaces.
	IsEdge_sensitive_path_declarationContext()
}

type Edge_sensitive_path_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEdge_sensitive_path_declarationContext() *Edge_sensitive_path_declarationContext {
	var p = new(Edge_sensitive_path_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_edge_sensitive_path_declaration
	return p
}

func (*Edge_sensitive_path_declarationContext) IsEdge_sensitive_path_declarationContext() {}

func NewEdge_sensitive_path_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Edge_sensitive_path_declarationContext {
	var p = new(Edge_sensitive_path_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_edge_sensitive_path_declaration

	return p
}

func (s *Edge_sensitive_path_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Edge_sensitive_path_declarationContext) EQ() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserEQ, 0)
}

func (s *Edge_sensitive_path_declarationContext) Path_delay_value() IPath_delay_valueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPath_delay_valueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPath_delay_valueContext)
}

func (s *Edge_sensitive_path_declarationContext) Parallel_edge_sensitive_path_description() IParallel_edge_sensitive_path_descriptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParallel_edge_sensitive_path_descriptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParallel_edge_sensitive_path_descriptionContext)
}

func (s *Edge_sensitive_path_declarationContext) Full_edge_sensitive_path_description() IFull_edge_sensitive_path_descriptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFull_edge_sensitive_path_descriptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFull_edge_sensitive_path_descriptionContext)
}

func (s *Edge_sensitive_path_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Edge_sensitive_path_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Edge_sensitive_path_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterEdge_sensitive_path_declaration(s)
	}
}

func (s *Edge_sensitive_path_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitEdge_sensitive_path_declaration(s)
	}
}

func (p *SystemVerilogParser) Edge_sensitive_path_declaration() (localctx IEdge_sensitive_path_declarationContext) {
	this := p
	_ = this

	localctx = NewEdge_sensitive_path_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 950, SystemVerilogParserRULE_edge_sensitive_path_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(6790)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 835, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(6788)
			p.Parallel_edge_sensitive_path_description()
		}

	case 2:
		{
			p.SetState(6789)
			p.Full_edge_sensitive_path_description()
		}

	}
	{
		p.SetState(6792)
		p.Match(SystemVerilogParserEQ)
	}
	{
		p.SetState(6793)
		p.Path_delay_value()
	}

	return localctx
}

// IParallel_edge_sensitive_path_descriptionContext is an interface to support dynamic dispatch.
type IParallel_edge_sensitive_path_descriptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParallel_edge_sensitive_path_descriptionContext differentiates from other interfaces.
	IsParallel_edge_sensitive_path_descriptionContext()
}

type Parallel_edge_sensitive_path_descriptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParallel_edge_sensitive_path_descriptionContext() *Parallel_edge_sensitive_path_descriptionContext {
	var p = new(Parallel_edge_sensitive_path_descriptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_parallel_edge_sensitive_path_description
	return p
}

func (*Parallel_edge_sensitive_path_descriptionContext) IsParallel_edge_sensitive_path_descriptionContext() {
}

func NewParallel_edge_sensitive_path_descriptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Parallel_edge_sensitive_path_descriptionContext {
	var p = new(Parallel_edge_sensitive_path_descriptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_parallel_edge_sensitive_path_description

	return p
}

func (s *Parallel_edge_sensitive_path_descriptionContext) GetParser() antlr.Parser { return s.parser }

func (s *Parallel_edge_sensitive_path_descriptionContext) AllLP() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserLP)
}

func (s *Parallel_edge_sensitive_path_descriptionContext) LP(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, i)
}

func (s *Parallel_edge_sensitive_path_descriptionContext) Specify_input_terminal_descriptor() ISpecify_input_terminal_descriptorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecify_input_terminal_descriptorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpecify_input_terminal_descriptorContext)
}

func (s *Parallel_edge_sensitive_path_descriptionContext) EQGT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserEQGT, 0)
}

func (s *Parallel_edge_sensitive_path_descriptionContext) Specify_output_terminal_descriptor() ISpecify_output_terminal_descriptorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecify_output_terminal_descriptorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpecify_output_terminal_descriptorContext)
}

func (s *Parallel_edge_sensitive_path_descriptionContext) COLON() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOLON, 0)
}

func (s *Parallel_edge_sensitive_path_descriptionContext) Data_source_expression() IData_source_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IData_source_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IData_source_expressionContext)
}

func (s *Parallel_edge_sensitive_path_descriptionContext) AllRP() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserRP)
}

func (s *Parallel_edge_sensitive_path_descriptionContext) RP(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, i)
}

func (s *Parallel_edge_sensitive_path_descriptionContext) Edge_identifier() IEdge_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEdge_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEdge_identifierContext)
}

func (s *Parallel_edge_sensitive_path_descriptionContext) AllPolarity_operator() []IPolarity_operatorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPolarity_operatorContext)(nil)).Elem())
	var tst = make([]IPolarity_operatorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPolarity_operatorContext)
		}
	}

	return tst
}

func (s *Parallel_edge_sensitive_path_descriptionContext) Polarity_operator(i int) IPolarity_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPolarity_operatorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPolarity_operatorContext)
}

func (s *Parallel_edge_sensitive_path_descriptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parallel_edge_sensitive_path_descriptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Parallel_edge_sensitive_path_descriptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterParallel_edge_sensitive_path_description(s)
	}
}

func (s *Parallel_edge_sensitive_path_descriptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitParallel_edge_sensitive_path_description(s)
	}
}

func (p *SystemVerilogParser) Parallel_edge_sensitive_path_description() (localctx IParallel_edge_sensitive_path_descriptionContext) {
	this := p
	_ = this

	localctx = NewParallel_edge_sensitive_path_descriptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 952, SystemVerilogParserRULE_parallel_edge_sensitive_path_description)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6795)
		p.Match(SystemVerilogParserLP)
	}
	p.SetState(6797)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserKEDGE || _la == SystemVerilogParserKNEGEDGE || _la == SystemVerilogParserKPOSEDGE {
		{
			p.SetState(6796)
			p.Edge_identifier()
		}

	}
	{
		p.SetState(6799)
		p.Specify_input_terminal_descriptor()
	}
	p.SetState(6801)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserMINUS || _la == SystemVerilogParserPLUS {
		{
			p.SetState(6800)
			p.Polarity_operator()
		}

	}
	{
		p.SetState(6803)
		p.Match(SystemVerilogParserEQGT)
	}
	{
		p.SetState(6804)
		p.Match(SystemVerilogParserLP)
	}
	{
		p.SetState(6805)
		p.Specify_output_terminal_descriptor()
	}
	p.SetState(6807)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserMINUS || _la == SystemVerilogParserPLUS {
		{
			p.SetState(6806)
			p.Polarity_operator()
		}

	}
	{
		p.SetState(6809)
		p.Match(SystemVerilogParserCOLON)
	}
	{
		p.SetState(6810)
		p.Data_source_expression()
	}
	{
		p.SetState(6811)
		p.Match(SystemVerilogParserRP)
	}
	{
		p.SetState(6812)
		p.Match(SystemVerilogParserRP)
	}

	return localctx
}

// IFull_edge_sensitive_path_descriptionContext is an interface to support dynamic dispatch.
type IFull_edge_sensitive_path_descriptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFull_edge_sensitive_path_descriptionContext differentiates from other interfaces.
	IsFull_edge_sensitive_path_descriptionContext()
}

type Full_edge_sensitive_path_descriptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFull_edge_sensitive_path_descriptionContext() *Full_edge_sensitive_path_descriptionContext {
	var p = new(Full_edge_sensitive_path_descriptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_full_edge_sensitive_path_description
	return p
}

func (*Full_edge_sensitive_path_descriptionContext) IsFull_edge_sensitive_path_descriptionContext() {}

func NewFull_edge_sensitive_path_descriptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Full_edge_sensitive_path_descriptionContext {
	var p = new(Full_edge_sensitive_path_descriptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_full_edge_sensitive_path_description

	return p
}

func (s *Full_edge_sensitive_path_descriptionContext) GetParser() antlr.Parser { return s.parser }

func (s *Full_edge_sensitive_path_descriptionContext) AllLP() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserLP)
}

func (s *Full_edge_sensitive_path_descriptionContext) LP(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, i)
}

func (s *Full_edge_sensitive_path_descriptionContext) List_of_path_inputs() IList_of_path_inputsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_path_inputsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_path_inputsContext)
}

func (s *Full_edge_sensitive_path_descriptionContext) SGT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSGT, 0)
}

func (s *Full_edge_sensitive_path_descriptionContext) List_of_path_outputs() IList_of_path_outputsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_path_outputsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_path_outputsContext)
}

func (s *Full_edge_sensitive_path_descriptionContext) COLON() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOLON, 0)
}

func (s *Full_edge_sensitive_path_descriptionContext) Data_source_expression() IData_source_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IData_source_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IData_source_expressionContext)
}

func (s *Full_edge_sensitive_path_descriptionContext) AllRP() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserRP)
}

func (s *Full_edge_sensitive_path_descriptionContext) RP(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, i)
}

func (s *Full_edge_sensitive_path_descriptionContext) Edge_identifier() IEdge_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEdge_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEdge_identifierContext)
}

func (s *Full_edge_sensitive_path_descriptionContext) AllPolarity_operator() []IPolarity_operatorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPolarity_operatorContext)(nil)).Elem())
	var tst = make([]IPolarity_operatorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPolarity_operatorContext)
		}
	}

	return tst
}

func (s *Full_edge_sensitive_path_descriptionContext) Polarity_operator(i int) IPolarity_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPolarity_operatorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPolarity_operatorContext)
}

func (s *Full_edge_sensitive_path_descriptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Full_edge_sensitive_path_descriptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Full_edge_sensitive_path_descriptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterFull_edge_sensitive_path_description(s)
	}
}

func (s *Full_edge_sensitive_path_descriptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitFull_edge_sensitive_path_description(s)
	}
}

func (p *SystemVerilogParser) Full_edge_sensitive_path_description() (localctx IFull_edge_sensitive_path_descriptionContext) {
	this := p
	_ = this

	localctx = NewFull_edge_sensitive_path_descriptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 954, SystemVerilogParserRULE_full_edge_sensitive_path_description)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6814)
		p.Match(SystemVerilogParserLP)
	}
	p.SetState(6816)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserKEDGE || _la == SystemVerilogParserKNEGEDGE || _la == SystemVerilogParserKPOSEDGE {
		{
			p.SetState(6815)
			p.Edge_identifier()
		}

	}
	{
		p.SetState(6818)
		p.List_of_path_inputs()
	}
	p.SetState(6820)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserMINUS || _la == SystemVerilogParserPLUS {
		{
			p.SetState(6819)
			p.Polarity_operator()
		}

	}
	{
		p.SetState(6822)
		p.Match(SystemVerilogParserSGT)
	}
	{
		p.SetState(6823)
		p.Match(SystemVerilogParserLP)
	}
	{
		p.SetState(6824)
		p.List_of_path_outputs()
	}
	p.SetState(6826)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserMINUS || _la == SystemVerilogParserPLUS {
		{
			p.SetState(6825)
			p.Polarity_operator()
		}

	}
	{
		p.SetState(6828)
		p.Match(SystemVerilogParserCOLON)
	}
	{
		p.SetState(6829)
		p.Data_source_expression()
	}
	{
		p.SetState(6830)
		p.Match(SystemVerilogParserRP)
	}
	{
		p.SetState(6831)
		p.Match(SystemVerilogParserRP)
	}

	return localctx
}

// IData_source_expressionContext is an interface to support dynamic dispatch.
type IData_source_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsData_source_expressionContext differentiates from other interfaces.
	IsData_source_expressionContext()
}

type Data_source_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyData_source_expressionContext() *Data_source_expressionContext {
	var p = new(Data_source_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_data_source_expression
	return p
}

func (*Data_source_expressionContext) IsData_source_expressionContext() {}

func NewData_source_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Data_source_expressionContext {
	var p = new(Data_source_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_data_source_expression

	return p
}

func (s *Data_source_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Data_source_expressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Data_source_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Data_source_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Data_source_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterData_source_expression(s)
	}
}

func (s *Data_source_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitData_source_expression(s)
	}
}

func (p *SystemVerilogParser) Data_source_expression() (localctx IData_source_expressionContext) {
	this := p
	_ = this

	localctx = NewData_source_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 956, SystemVerilogParserRULE_data_source_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6833)
		p.expression(0)
	}

	return localctx
}

// IEdge_identifierContext is an interface to support dynamic dispatch.
type IEdge_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEdge_identifierContext differentiates from other interfaces.
	IsEdge_identifierContext()
}

type Edge_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEdge_identifierContext() *Edge_identifierContext {
	var p = new(Edge_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_edge_identifier
	return p
}

func (*Edge_identifierContext) IsEdge_identifierContext() {}

func NewEdge_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Edge_identifierContext {
	var p = new(Edge_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_edge_identifier

	return p
}

func (s *Edge_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Edge_identifierContext) KPOSEDGE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKPOSEDGE, 0)
}

func (s *Edge_identifierContext) KNEGEDGE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKNEGEDGE, 0)
}

func (s *Edge_identifierContext) KEDGE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKEDGE, 0)
}

func (s *Edge_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Edge_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Edge_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterEdge_identifier(s)
	}
}

func (s *Edge_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitEdge_identifier(s)
	}
}

func (p *SystemVerilogParser) Edge_identifier() (localctx IEdge_identifierContext) {
	this := p
	_ = this

	localctx = NewEdge_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 958, SystemVerilogParserRULE_edge_identifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6835)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SystemVerilogParserKEDGE || _la == SystemVerilogParserKNEGEDGE || _la == SystemVerilogParserKPOSEDGE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IState_dependent_path_declarationContext is an interface to support dynamic dispatch.
type IState_dependent_path_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsState_dependent_path_declarationContext differentiates from other interfaces.
	IsState_dependent_path_declarationContext()
}

type State_dependent_path_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyState_dependent_path_declarationContext() *State_dependent_path_declarationContext {
	var p = new(State_dependent_path_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_state_dependent_path_declaration
	return p
}

func (*State_dependent_path_declarationContext) IsState_dependent_path_declarationContext() {}

func NewState_dependent_path_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *State_dependent_path_declarationContext {
	var p = new(State_dependent_path_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_state_dependent_path_declaration

	return p
}

func (s *State_dependent_path_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *State_dependent_path_declarationContext) KIF() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKIF, 0)
}

func (s *State_dependent_path_declarationContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *State_dependent_path_declarationContext) Module_path_expression() IModule_path_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_path_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_path_expressionContext)
}

func (s *State_dependent_path_declarationContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *State_dependent_path_declarationContext) Simple_path_declaration() ISimple_path_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_path_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimple_path_declarationContext)
}

func (s *State_dependent_path_declarationContext) Edge_sensitive_path_declaration() IEdge_sensitive_path_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEdge_sensitive_path_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEdge_sensitive_path_declarationContext)
}

func (s *State_dependent_path_declarationContext) KIFNONE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKIFNONE, 0)
}

func (s *State_dependent_path_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *State_dependent_path_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *State_dependent_path_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterState_dependent_path_declaration(s)
	}
}

func (s *State_dependent_path_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitState_dependent_path_declaration(s)
	}
}

func (p *SystemVerilogParser) State_dependent_path_declaration() (localctx IState_dependent_path_declarationContext) {
	this := p
	_ = this

	localctx = NewState_dependent_path_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 960, SystemVerilogParserRULE_state_dependent_path_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6847)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserKIF:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6837)
			p.Match(SystemVerilogParserKIF)
		}
		{
			p.SetState(6838)
			p.Match(SystemVerilogParserLP)
		}
		{
			p.SetState(6839)
			p.module_path_expression(0)
		}
		{
			p.SetState(6840)
			p.Match(SystemVerilogParserRP)
		}
		p.SetState(6843)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 842, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(6841)
				p.Simple_path_declaration()
			}

		case 2:
			{
				p.SetState(6842)
				p.Edge_sensitive_path_declaration()
			}

		}

	case SystemVerilogParserKIFNONE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6845)
			p.Match(SystemVerilogParserKIFNONE)
		}
		{
			p.SetState(6846)
			p.Simple_path_declaration()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPolarity_operatorContext is an interface to support dynamic dispatch.
type IPolarity_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPolarity_operatorContext differentiates from other interfaces.
	IsPolarity_operatorContext()
}

type Polarity_operatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPolarity_operatorContext() *Polarity_operatorContext {
	var p = new(Polarity_operatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_polarity_operator
	return p
}

func (*Polarity_operatorContext) IsPolarity_operatorContext() {}

func NewPolarity_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Polarity_operatorContext {
	var p = new(Polarity_operatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_polarity_operator

	return p
}

func (s *Polarity_operatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Polarity_operatorContext) PLUS() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserPLUS, 0)
}

func (s *Polarity_operatorContext) MINUS() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserMINUS, 0)
}

func (s *Polarity_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Polarity_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Polarity_operatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterPolarity_operator(s)
	}
}

func (s *Polarity_operatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitPolarity_operator(s)
	}
}

func (p *SystemVerilogParser) Polarity_operator() (localctx IPolarity_operatorContext) {
	this := p
	_ = this

	localctx = NewPolarity_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 962, SystemVerilogParserRULE_polarity_operator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6849)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SystemVerilogParserMINUS || _la == SystemVerilogParserPLUS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IConcatenationContext is an interface to support dynamic dispatch.
type IConcatenationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConcatenationContext differentiates from other interfaces.
	IsConcatenationContext()
}

type ConcatenationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConcatenationContext() *ConcatenationContext {
	var p = new(ConcatenationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_concatenation
	return p
}

func (*ConcatenationContext) IsConcatenationContext() {}

func NewConcatenationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConcatenationContext {
	var p = new(ConcatenationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_concatenation

	return p
}

func (s *ConcatenationContext) GetParser() antlr.Parser { return s.parser }

func (s *ConcatenationContext) LC() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLC, 0)
}

func (s *ConcatenationContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *ConcatenationContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ConcatenationContext) RC() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRC, 0)
}

func (s *ConcatenationContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *ConcatenationContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *ConcatenationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConcatenationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConcatenationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterConcatenation(s)
	}
}

func (s *ConcatenationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitConcatenation(s)
	}
}

func (p *SystemVerilogParser) Concatenation() (localctx IConcatenationContext) {
	this := p
	_ = this

	localctx = NewConcatenationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 964, SystemVerilogParserRULE_concatenation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6851)
		p.Match(SystemVerilogParserLC)
	}
	{
		p.SetState(6852)
		p.expression(0)
	}
	p.SetState(6857)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserCOMMA {
		{
			p.SetState(6853)
			p.Match(SystemVerilogParserCOMMA)
		}
		{
			p.SetState(6854)
			p.expression(0)
		}

		p.SetState(6859)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(6860)
		p.Match(SystemVerilogParserRC)
	}

	return localctx
}

// IConstant_concatenationContext is an interface to support dynamic dispatch.
type IConstant_concatenationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstant_concatenationContext differentiates from other interfaces.
	IsConstant_concatenationContext()
}

type Constant_concatenationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstant_concatenationContext() *Constant_concatenationContext {
	var p = new(Constant_concatenationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_constant_concatenation
	return p
}

func (*Constant_concatenationContext) IsConstant_concatenationContext() {}

func NewConstant_concatenationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constant_concatenationContext {
	var p = new(Constant_concatenationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_constant_concatenation

	return p
}

func (s *Constant_concatenationContext) GetParser() antlr.Parser { return s.parser }

func (s *Constant_concatenationContext) LC() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLC, 0)
}

func (s *Constant_concatenationContext) AllConstant_expression() []IConstant_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem())
	var tst = make([]IConstant_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConstant_expressionContext)
		}
	}

	return tst
}

func (s *Constant_concatenationContext) Constant_expression(i int) IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Constant_concatenationContext) RC() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRC, 0)
}

func (s *Constant_concatenationContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *Constant_concatenationContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *Constant_concatenationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constant_concatenationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constant_concatenationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterConstant_concatenation(s)
	}
}

func (s *Constant_concatenationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitConstant_concatenation(s)
	}
}

func (p *SystemVerilogParser) Constant_concatenation() (localctx IConstant_concatenationContext) {
	this := p
	_ = this

	localctx = NewConstant_concatenationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 966, SystemVerilogParserRULE_constant_concatenation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6862)
		p.Match(SystemVerilogParserLC)
	}
	{
		p.SetState(6863)
		p.constant_expression(0)
	}
	p.SetState(6868)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserCOMMA {
		{
			p.SetState(6864)
			p.Match(SystemVerilogParserCOMMA)
		}
		{
			p.SetState(6865)
			p.constant_expression(0)
		}

		p.SetState(6870)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(6871)
		p.Match(SystemVerilogParserRC)
	}

	return localctx
}

// IConstant_multiple_concatenationContext is an interface to support dynamic dispatch.
type IConstant_multiple_concatenationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstant_multiple_concatenationContext differentiates from other interfaces.
	IsConstant_multiple_concatenationContext()
}

type Constant_multiple_concatenationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstant_multiple_concatenationContext() *Constant_multiple_concatenationContext {
	var p = new(Constant_multiple_concatenationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_constant_multiple_concatenation
	return p
}

func (*Constant_multiple_concatenationContext) IsConstant_multiple_concatenationContext() {}

func NewConstant_multiple_concatenationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constant_multiple_concatenationContext {
	var p = new(Constant_multiple_concatenationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_constant_multiple_concatenation

	return p
}

func (s *Constant_multiple_concatenationContext) GetParser() antlr.Parser { return s.parser }

func (s *Constant_multiple_concatenationContext) LC() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLC, 0)
}

func (s *Constant_multiple_concatenationContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Constant_multiple_concatenationContext) Constant_concatenation() IConstant_concatenationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_concatenationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_concatenationContext)
}

func (s *Constant_multiple_concatenationContext) RC() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRC, 0)
}

func (s *Constant_multiple_concatenationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constant_multiple_concatenationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constant_multiple_concatenationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterConstant_multiple_concatenation(s)
	}
}

func (s *Constant_multiple_concatenationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitConstant_multiple_concatenation(s)
	}
}

func (p *SystemVerilogParser) Constant_multiple_concatenation() (localctx IConstant_multiple_concatenationContext) {
	this := p
	_ = this

	localctx = NewConstant_multiple_concatenationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 968, SystemVerilogParserRULE_constant_multiple_concatenation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6873)
		p.Match(SystemVerilogParserLC)
	}
	{
		p.SetState(6874)
		p.constant_expression(0)
	}
	{
		p.SetState(6875)
		p.Constant_concatenation()
	}
	{
		p.SetState(6876)
		p.Match(SystemVerilogParserRC)
	}

	return localctx
}

// IModule_path_concatenationContext is an interface to support dynamic dispatch.
type IModule_path_concatenationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModule_path_concatenationContext differentiates from other interfaces.
	IsModule_path_concatenationContext()
}

type Module_path_concatenationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModule_path_concatenationContext() *Module_path_concatenationContext {
	var p = new(Module_path_concatenationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_module_path_concatenation
	return p
}

func (*Module_path_concatenationContext) IsModule_path_concatenationContext() {}

func NewModule_path_concatenationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Module_path_concatenationContext {
	var p = new(Module_path_concatenationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_module_path_concatenation

	return p
}

func (s *Module_path_concatenationContext) GetParser() antlr.Parser { return s.parser }

func (s *Module_path_concatenationContext) LC() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLC, 0)
}

func (s *Module_path_concatenationContext) AllModule_path_expression() []IModule_path_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IModule_path_expressionContext)(nil)).Elem())
	var tst = make([]IModule_path_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IModule_path_expressionContext)
		}
	}

	return tst
}

func (s *Module_path_concatenationContext) Module_path_expression(i int) IModule_path_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_path_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IModule_path_expressionContext)
}

func (s *Module_path_concatenationContext) RC() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRC, 0)
}

func (s *Module_path_concatenationContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *Module_path_concatenationContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *Module_path_concatenationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Module_path_concatenationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Module_path_concatenationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterModule_path_concatenation(s)
	}
}

func (s *Module_path_concatenationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitModule_path_concatenation(s)
	}
}

func (p *SystemVerilogParser) Module_path_concatenation() (localctx IModule_path_concatenationContext) {
	this := p
	_ = this

	localctx = NewModule_path_concatenationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 970, SystemVerilogParserRULE_module_path_concatenation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6878)
		p.Match(SystemVerilogParserLC)
	}
	{
		p.SetState(6879)
		p.module_path_expression(0)
	}
	p.SetState(6884)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserCOMMA {
		{
			p.SetState(6880)
			p.Match(SystemVerilogParserCOMMA)
		}
		{
			p.SetState(6881)
			p.module_path_expression(0)
		}

		p.SetState(6886)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(6887)
		p.Match(SystemVerilogParserRC)
	}

	return localctx
}

// IModule_path_multiple_concatenationContext is an interface to support dynamic dispatch.
type IModule_path_multiple_concatenationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModule_path_multiple_concatenationContext differentiates from other interfaces.
	IsModule_path_multiple_concatenationContext()
}

type Module_path_multiple_concatenationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModule_path_multiple_concatenationContext() *Module_path_multiple_concatenationContext {
	var p = new(Module_path_multiple_concatenationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_module_path_multiple_concatenation
	return p
}

func (*Module_path_multiple_concatenationContext) IsModule_path_multiple_concatenationContext() {}

func NewModule_path_multiple_concatenationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Module_path_multiple_concatenationContext {
	var p = new(Module_path_multiple_concatenationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_module_path_multiple_concatenation

	return p
}

func (s *Module_path_multiple_concatenationContext) GetParser() antlr.Parser { return s.parser }

func (s *Module_path_multiple_concatenationContext) LC() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLC, 0)
}

func (s *Module_path_multiple_concatenationContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Module_path_multiple_concatenationContext) Module_path_concatenation() IModule_path_concatenationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_path_concatenationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_path_concatenationContext)
}

func (s *Module_path_multiple_concatenationContext) RC() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRC, 0)
}

func (s *Module_path_multiple_concatenationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Module_path_multiple_concatenationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Module_path_multiple_concatenationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterModule_path_multiple_concatenation(s)
	}
}

func (s *Module_path_multiple_concatenationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitModule_path_multiple_concatenation(s)
	}
}

func (p *SystemVerilogParser) Module_path_multiple_concatenation() (localctx IModule_path_multiple_concatenationContext) {
	this := p
	_ = this

	localctx = NewModule_path_multiple_concatenationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 972, SystemVerilogParserRULE_module_path_multiple_concatenation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6889)
		p.Match(SystemVerilogParserLC)
	}
	{
		p.SetState(6890)
		p.constant_expression(0)
	}
	{
		p.SetState(6891)
		p.Module_path_concatenation()
	}
	{
		p.SetState(6892)
		p.Match(SystemVerilogParserRC)
	}

	return localctx
}

// IMultiple_concatenationContext is an interface to support dynamic dispatch.
type IMultiple_concatenationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMultiple_concatenationContext differentiates from other interfaces.
	IsMultiple_concatenationContext()
}

type Multiple_concatenationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiple_concatenationContext() *Multiple_concatenationContext {
	var p = new(Multiple_concatenationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_multiple_concatenation
	return p
}

func (*Multiple_concatenationContext) IsMultiple_concatenationContext() {}

func NewMultiple_concatenationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Multiple_concatenationContext {
	var p = new(Multiple_concatenationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_multiple_concatenation

	return p
}

func (s *Multiple_concatenationContext) GetParser() antlr.Parser { return s.parser }

func (s *Multiple_concatenationContext) LC() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLC, 0)
}

func (s *Multiple_concatenationContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Multiple_concatenationContext) Concatenation() IConcatenationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConcatenationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConcatenationContext)
}

func (s *Multiple_concatenationContext) RC() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRC, 0)
}

func (s *Multiple_concatenationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Multiple_concatenationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Multiple_concatenationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterMultiple_concatenation(s)
	}
}

func (s *Multiple_concatenationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitMultiple_concatenation(s)
	}
}

func (p *SystemVerilogParser) Multiple_concatenation() (localctx IMultiple_concatenationContext) {
	this := p
	_ = this

	localctx = NewMultiple_concatenationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 974, SystemVerilogParserRULE_multiple_concatenation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6894)
		p.Match(SystemVerilogParserLC)
	}
	{
		p.SetState(6895)
		p.expression(0)
	}
	{
		p.SetState(6896)
		p.Concatenation()
	}
	{
		p.SetState(6897)
		p.Match(SystemVerilogParserRC)
	}

	return localctx
}

// IStreaming_concatenationContext is an interface to support dynamic dispatch.
type IStreaming_concatenationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStreaming_concatenationContext differentiates from other interfaces.
	IsStreaming_concatenationContext()
}

type Streaming_concatenationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStreaming_concatenationContext() *Streaming_concatenationContext {
	var p = new(Streaming_concatenationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_streaming_concatenation
	return p
}

func (*Streaming_concatenationContext) IsStreaming_concatenationContext() {}

func NewStreaming_concatenationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Streaming_concatenationContext {
	var p = new(Streaming_concatenationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_streaming_concatenation

	return p
}

func (s *Streaming_concatenationContext) GetParser() antlr.Parser { return s.parser }

func (s *Streaming_concatenationContext) LC() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLC, 0)
}

func (s *Streaming_concatenationContext) Stream_operator() IStream_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStream_operatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStream_operatorContext)
}

func (s *Streaming_concatenationContext) Stream_concatenation() IStream_concatenationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStream_concatenationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStream_concatenationContext)
}

func (s *Streaming_concatenationContext) RC() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRC, 0)
}

func (s *Streaming_concatenationContext) Slice_size() ISlice_sizeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISlice_sizeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISlice_sizeContext)
}

func (s *Streaming_concatenationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Streaming_concatenationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Streaming_concatenationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterStreaming_concatenation(s)
	}
}

func (s *Streaming_concatenationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitStreaming_concatenation(s)
	}
}

func (p *SystemVerilogParser) Streaming_concatenation() (localctx IStreaming_concatenationContext) {
	this := p
	_ = this

	localctx = NewStreaming_concatenationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 976, SystemVerilogParserRULE_streaming_concatenation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6899)
		p.Match(SystemVerilogParserLC)
	}
	{
		p.SetState(6900)
		p.Stream_operator()
	}
	p.SetState(6902)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 847, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(6901)
			p.Slice_size()
		}

	}
	{
		p.SetState(6904)
		p.Stream_concatenation()
	}
	{
		p.SetState(6905)
		p.Match(SystemVerilogParserRC)
	}

	return localctx
}

// IStream_operatorContext is an interface to support dynamic dispatch.
type IStream_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStream_operatorContext differentiates from other interfaces.
	IsStream_operatorContext()
}

type Stream_operatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStream_operatorContext() *Stream_operatorContext {
	var p = new(Stream_operatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_stream_operator
	return p
}

func (*Stream_operatorContext) IsStream_operatorContext() {}

func NewStream_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Stream_operatorContext {
	var p = new(Stream_operatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_stream_operator

	return p
}

func (s *Stream_operatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Stream_operatorContext) GTGT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserGTGT, 0)
}

func (s *Stream_operatorContext) LTLT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLTLT, 0)
}

func (s *Stream_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Stream_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Stream_operatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterStream_operator(s)
	}
}

func (s *Stream_operatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitStream_operator(s)
	}
}

func (p *SystemVerilogParser) Stream_operator() (localctx IStream_operatorContext) {
	this := p
	_ = this

	localctx = NewStream_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 978, SystemVerilogParserRULE_stream_operator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6907)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SystemVerilogParserLTLT || _la == SystemVerilogParserGTGT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ISlice_sizeContext is an interface to support dynamic dispatch.
type ISlice_sizeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSlice_sizeContext differentiates from other interfaces.
	IsSlice_sizeContext()
}

type Slice_sizeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySlice_sizeContext() *Slice_sizeContext {
	var p = new(Slice_sizeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_slice_size
	return p
}

func (*Slice_sizeContext) IsSlice_sizeContext() {}

func NewSlice_sizeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Slice_sizeContext {
	var p = new(Slice_sizeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_slice_size

	return p
}

func (s *Slice_sizeContext) GetParser() antlr.Parser { return s.parser }

func (s *Slice_sizeContext) Simple_type() ISimple_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimple_typeContext)
}

func (s *Slice_sizeContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Slice_sizeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Slice_sizeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Slice_sizeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterSlice_size(s)
	}
}

func (s *Slice_sizeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitSlice_size(s)
	}
}

func (p *SystemVerilogParser) Slice_size() (localctx ISlice_sizeContext) {
	this := p
	_ = this

	localctx = NewSlice_sizeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 980, SystemVerilogParserRULE_slice_size)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6911)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 848, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6909)
			p.Simple_type()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6910)
			p.constant_expression(0)
		}

	}

	return localctx
}

// IStream_concatenationContext is an interface to support dynamic dispatch.
type IStream_concatenationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStream_concatenationContext differentiates from other interfaces.
	IsStream_concatenationContext()
}

type Stream_concatenationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStream_concatenationContext() *Stream_concatenationContext {
	var p = new(Stream_concatenationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_stream_concatenation
	return p
}

func (*Stream_concatenationContext) IsStream_concatenationContext() {}

func NewStream_concatenationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Stream_concatenationContext {
	var p = new(Stream_concatenationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_stream_concatenation

	return p
}

func (s *Stream_concatenationContext) GetParser() antlr.Parser { return s.parser }

func (s *Stream_concatenationContext) LC() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLC, 0)
}

func (s *Stream_concatenationContext) AllStream_expression() []IStream_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStream_expressionContext)(nil)).Elem())
	var tst = make([]IStream_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStream_expressionContext)
		}
	}

	return tst
}

func (s *Stream_concatenationContext) Stream_expression(i int) IStream_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStream_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStream_expressionContext)
}

func (s *Stream_concatenationContext) RC() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRC, 0)
}

func (s *Stream_concatenationContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *Stream_concatenationContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *Stream_concatenationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Stream_concatenationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Stream_concatenationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterStream_concatenation(s)
	}
}

func (s *Stream_concatenationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitStream_concatenation(s)
	}
}

func (p *SystemVerilogParser) Stream_concatenation() (localctx IStream_concatenationContext) {
	this := p
	_ = this

	localctx = NewStream_concatenationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 982, SystemVerilogParserRULE_stream_concatenation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6913)
		p.Match(SystemVerilogParserLC)
	}
	{
		p.SetState(6914)
		p.Stream_expression()
	}
	p.SetState(6919)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserCOMMA {
		{
			p.SetState(6915)
			p.Match(SystemVerilogParserCOMMA)
		}
		{
			p.SetState(6916)
			p.Stream_expression()
		}

		p.SetState(6921)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(6922)
		p.Match(SystemVerilogParserRC)
	}

	return localctx
}

// IStream_expressionContext is an interface to support dynamic dispatch.
type IStream_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStream_expressionContext differentiates from other interfaces.
	IsStream_expressionContext()
}

type Stream_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStream_expressionContext() *Stream_expressionContext {
	var p = new(Stream_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_stream_expression
	return p
}

func (*Stream_expressionContext) IsStream_expressionContext() {}

func NewStream_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Stream_expressionContext {
	var p = new(Stream_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_stream_expression

	return p
}

func (s *Stream_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Stream_expressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Stream_expressionContext) KWITH() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKWITH, 0)
}

func (s *Stream_expressionContext) LB() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLB, 0)
}

func (s *Stream_expressionContext) Array_range_expression() IArray_range_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArray_range_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArray_range_expressionContext)
}

func (s *Stream_expressionContext) RB() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRB, 0)
}

func (s *Stream_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Stream_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Stream_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterStream_expression(s)
	}
}

func (s *Stream_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitStream_expression(s)
	}
}

func (p *SystemVerilogParser) Stream_expression() (localctx IStream_expressionContext) {
	this := p
	_ = this

	localctx = NewStream_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 984, SystemVerilogParserRULE_stream_expression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6924)
		p.expression(0)
	}
	p.SetState(6930)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserKWITH {
		{
			p.SetState(6925)
			p.Match(SystemVerilogParserKWITH)
		}
		{
			p.SetState(6926)
			p.Match(SystemVerilogParserLB)
		}
		{
			p.SetState(6927)
			p.Array_range_expression()
		}
		{
			p.SetState(6928)
			p.Match(SystemVerilogParserRB)
		}

	}

	return localctx
}

// IArray_range_expressionContext is an interface to support dynamic dispatch.
type IArray_range_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArray_range_expressionContext differentiates from other interfaces.
	IsArray_range_expressionContext()
}

type Array_range_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArray_range_expressionContext() *Array_range_expressionContext {
	var p = new(Array_range_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_array_range_expression
	return p
}

func (*Array_range_expressionContext) IsArray_range_expressionContext() {}

func NewArray_range_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Array_range_expressionContext {
	var p = new(Array_range_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_array_range_expression

	return p
}

func (s *Array_range_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Array_range_expressionContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *Array_range_expressionContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Array_range_expressionContext) COLON() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOLON, 0)
}

func (s *Array_range_expressionContext) PLUSCOLON() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserPLUSCOLON, 0)
}

func (s *Array_range_expressionContext) MCOLON() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserMCOLON, 0)
}

func (s *Array_range_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Array_range_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Array_range_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterArray_range_expression(s)
	}
}

func (s *Array_range_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitArray_range_expression(s)
	}
}

func (p *SystemVerilogParser) Array_range_expression() (localctx IArray_range_expressionContext) {
	this := p
	_ = this

	localctx = NewArray_range_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 986, SystemVerilogParserRULE_array_range_expression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6932)
		p.expression(0)
	}
	p.SetState(6935)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la-41)&-(0x1f+1)) == 0 && ((1<<uint((_la-41)))&((1<<(SystemVerilogParserCOLON-41))|(1<<(SystemVerilogParserMCOLON-41))|(1<<(SystemVerilogParserPLUSCOLON-41)))) != 0 {
		{
			p.SetState(6933)
			_la = p.GetTokenStream().LA(1)

			if !(((_la-41)&-(0x1f+1)) == 0 && ((1<<uint((_la-41)))&((1<<(SystemVerilogParserCOLON-41))|(1<<(SystemVerilogParserMCOLON-41))|(1<<(SystemVerilogParserPLUSCOLON-41)))) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(6934)
			p.expression(0)
		}

	}

	return localctx
}

// IEmpty_unpacked_array_concatenationContext is an interface to support dynamic dispatch.
type IEmpty_unpacked_array_concatenationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEmpty_unpacked_array_concatenationContext differentiates from other interfaces.
	IsEmpty_unpacked_array_concatenationContext()
}

type Empty_unpacked_array_concatenationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEmpty_unpacked_array_concatenationContext() *Empty_unpacked_array_concatenationContext {
	var p = new(Empty_unpacked_array_concatenationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_empty_unpacked_array_concatenation
	return p
}

func (*Empty_unpacked_array_concatenationContext) IsEmpty_unpacked_array_concatenationContext() {}

func NewEmpty_unpacked_array_concatenationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Empty_unpacked_array_concatenationContext {
	var p = new(Empty_unpacked_array_concatenationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_empty_unpacked_array_concatenation

	return p
}

func (s *Empty_unpacked_array_concatenationContext) GetParser() antlr.Parser { return s.parser }

func (s *Empty_unpacked_array_concatenationContext) LC() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLC, 0)
}

func (s *Empty_unpacked_array_concatenationContext) RC() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRC, 0)
}

func (s *Empty_unpacked_array_concatenationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Empty_unpacked_array_concatenationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Empty_unpacked_array_concatenationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterEmpty_unpacked_array_concatenation(s)
	}
}

func (s *Empty_unpacked_array_concatenationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitEmpty_unpacked_array_concatenation(s)
	}
}

func (p *SystemVerilogParser) Empty_unpacked_array_concatenation() (localctx IEmpty_unpacked_array_concatenationContext) {
	this := p
	_ = this

	localctx = NewEmpty_unpacked_array_concatenationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 988, SystemVerilogParserRULE_empty_unpacked_array_concatenation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6937)
		p.Match(SystemVerilogParserLC)
	}
	{
		p.SetState(6938)
		p.Match(SystemVerilogParserRC)
	}

	return localctx
}

// IConstant_function_callContext is an interface to support dynamic dispatch.
type IConstant_function_callContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstant_function_callContext differentiates from other interfaces.
	IsConstant_function_callContext()
}

type Constant_function_callContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstant_function_callContext() *Constant_function_callContext {
	var p = new(Constant_function_callContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_constant_function_call
	return p
}

func (*Constant_function_callContext) IsConstant_function_callContext() {}

func NewConstant_function_callContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constant_function_callContext {
	var p = new(Constant_function_callContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_constant_function_call

	return p
}

func (s *Constant_function_callContext) GetParser() antlr.Parser { return s.parser }

func (s *Constant_function_callContext) Function_subroutine_call() IFunction_subroutine_callContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_subroutine_callContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_subroutine_callContext)
}

func (s *Constant_function_callContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constant_function_callContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constant_function_callContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterConstant_function_call(s)
	}
}

func (s *Constant_function_callContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitConstant_function_call(s)
	}
}

func (p *SystemVerilogParser) Constant_function_call() (localctx IConstant_function_callContext) {
	this := p
	_ = this

	localctx = NewConstant_function_callContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 990, SystemVerilogParserRULE_constant_function_call)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6940)
		p.Function_subroutine_call()
	}

	return localctx
}

// ITf_callContext is an interface to support dynamic dispatch.
type ITf_callContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTf_callContext differentiates from other interfaces.
	IsTf_callContext()
}

type Tf_callContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTf_callContext() *Tf_callContext {
	var p = new(Tf_callContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_tf_call
	return p
}

func (*Tf_callContext) IsTf_callContext() {}

func NewTf_callContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tf_callContext {
	var p = new(Tf_callContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_tf_call

	return p
}

func (s *Tf_callContext) GetParser() antlr.Parser { return s.parser }

func (s *Tf_callContext) Ps_or_hierarchical_tf_identifier() IPs_or_hierarchical_tf_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPs_or_hierarchical_tf_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPs_or_hierarchical_tf_identifierContext)
}

func (s *Tf_callContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Tf_callContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Tf_callContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Tf_callContext) List_of_arguments() IList_of_argumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_argumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_argumentsContext)
}

func (s *Tf_callContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Tf_callContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tf_callContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tf_callContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterTf_call(s)
	}
}

func (s *Tf_callContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitTf_call(s)
	}
}

func (p *SystemVerilogParser) Tf_call() (localctx ITf_callContext) {
	this := p
	_ = this

	localctx = NewTf_callContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 992, SystemVerilogParserRULE_tf_call)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6942)
		p.Ps_or_hierarchical_tf_identifier()
	}
	p.SetState(6946)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 852, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(6943)
				p.Attribute_instance()
			}

		}
		p.SetState(6948)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 852, p.GetParserRuleContext())
	}
	p.SetState(6953)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 853, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(6949)
			p.Match(SystemVerilogParserLP)
		}
		{
			p.SetState(6950)
			p.List_of_arguments()
		}
		{
			p.SetState(6951)
			p.Match(SystemVerilogParserRP)
		}

	}

	return localctx
}

// ISystem_tf_callContext is an interface to support dynamic dispatch.
type ISystem_tf_callContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSystem_tf_callContext differentiates from other interfaces.
	IsSystem_tf_callContext()
}

type System_tf_callContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySystem_tf_callContext() *System_tf_callContext {
	var p = new(System_tf_callContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_system_tf_call
	return p
}

func (*System_tf_callContext) IsSystem_tf_callContext() {}

func NewSystem_tf_callContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *System_tf_callContext {
	var p = new(System_tf_callContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_system_tf_call

	return p
}

func (s *System_tf_callContext) GetParser() antlr.Parser { return s.parser }

func (s *System_tf_callContext) SYSTEM_TF_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSYSTEM_TF_IDENTIFIER, 0)
}

func (s *System_tf_callContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *System_tf_callContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *System_tf_callContext) Data_type() IData_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IData_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IData_typeContext)
}

func (s *System_tf_callContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *System_tf_callContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *System_tf_callContext) List_of_arguments() IList_of_argumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_argumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_argumentsContext)
}

func (s *System_tf_callContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *System_tf_callContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *System_tf_callContext) Clocking_event() IClocking_eventContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClocking_eventContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClocking_eventContext)
}

func (s *System_tf_callContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *System_tf_callContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *System_tf_callContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterSystem_tf_call(s)
	}
}

func (s *System_tf_callContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitSystem_tf_call(s)
	}
}

func (p *SystemVerilogParser) System_tf_call() (localctx ISystem_tf_callContext) {
	this := p
	_ = this

	localctx = NewSystem_tf_callContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 994, SystemVerilogParserRULE_system_tf_call)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6955)
		p.Match(SystemVerilogParserSYSTEM_TF_IDENTIFIER)
	}
	p.SetState(6988)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 861, p.GetParserRuleContext()) {
	case 1:
		p.SetState(6960)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 854, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6956)
				p.Match(SystemVerilogParserLP)
			}
			{
				p.SetState(6957)
				p.List_of_arguments()
			}
			{
				p.SetState(6958)
				p.Match(SystemVerilogParserRP)
			}

		}

	case 2:
		{
			p.SetState(6962)
			p.Match(SystemVerilogParserLP)
		}
		p.SetState(6984)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 860, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(6963)
				p.Data_type()
			}
			p.SetState(6966)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == SystemVerilogParserCOMMA {
				{
					p.SetState(6964)
					p.Match(SystemVerilogParserCOMMA)
				}
				{
					p.SetState(6965)
					p.expression(0)
				}

			}

		case 2:
			{
				p.SetState(6968)
				p.expression(0)
			}
			p.SetState(6975)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 857, p.GetParserRuleContext())

			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(6969)
						p.Match(SystemVerilogParserCOMMA)
					}
					p.SetState(6971)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)

					if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SystemVerilogParserMINUS)|(1<<SystemVerilogParserMINUSMINS)|(1<<SystemVerilogParserNOT)|(1<<SystemVerilogParserDOLLAR)|(1<<SystemVerilogParserDROOT)|(1<<SystemVerilogParserDUNIT)|(1<<SystemVerilogParserAND)|(1<<SystemVerilogParserLP))) != 0) || (((_la-51)&-(0x1f+1)) == 0 && ((1<<uint((_la-51)))&((1<<(SystemVerilogParserQUOTE-51))|(1<<(SystemVerilogParserCARET-51))|(1<<(SystemVerilogParserCARETSQUIG-51))|(1<<(SystemVerilogParserLC-51))|(1<<(SystemVerilogParserBAR-51))|(1<<(SystemVerilogParserSQUIG-51))|(1<<(SystemVerilogParserSQUIGAND-51))|(1<<(SystemVerilogParserSQUIGCARET-51))|(1<<(SystemVerilogParserSQUIGBAR-51))|(1<<(SystemVerilogParserPLUS-51))|(1<<(SystemVerilogParserPLUSPLUS-51)))) != 0) || (((_la-109)&-(0x1f+1)) == 0 && ((1<<uint((_la-109)))&((1<<(SystemVerilogParserKBIT-109))|(1<<(SystemVerilogParserKBYTE-109))|(1<<(SystemVerilogParserKCONST-109)))) != 0) || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SystemVerilogParserKINT-195))|(1<<(SystemVerilogParserKINTEGER-195))|(1<<(SystemVerilogParserKLOCAL-195))|(1<<(SystemVerilogParserKLOGIC-195))|(1<<(SystemVerilogParserKLONGINT-195)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(SystemVerilogParserKNULL-228))|(1<<(SystemVerilogParserKRANDOMIZE-228))|(1<<(SystemVerilogParserKREAL-228))|(1<<(SystemVerilogParserKREALTIME-228))|(1<<(SystemVerilogParserKREG-228)))) != 0) || (((_la-276)&-(0x1f+1)) == 0 && ((1<<uint((_la-276)))&((1<<(SystemVerilogParserKSHORTINT-276))|(1<<(SystemVerilogParserKSHORTREAL-276))|(1<<(SystemVerilogParserKSIGNED-276))|(1<<(SystemVerilogParserKSTD-276))|(1<<(SystemVerilogParserKSTRING-276))|(1<<(SystemVerilogParserKSUPER-276))|(1<<(SystemVerilogParserKTAGGED-276))|(1<<(SystemVerilogParserKTHIS-276))|(1<<(SystemVerilogParserKTIME-276)))) != 0) || _la == SystemVerilogParserKTYPE || _la == SystemVerilogParserKUNSIGNED || (((_la-345)&-(0x1f+1)) == 0 && ((1<<uint((_la-345)))&((1<<(SystemVerilogParserTIME_LITERAL-345))|(1<<(SystemVerilogParserDECIMAL_NUMBER-345))|(1<<(SystemVerilogParserBINARY_NUMBER-345))|(1<<(SystemVerilogParserOCTAL_NUMBER-345))|(1<<(SystemVerilogParserHEX_NUMBER-345))|(1<<(SystemVerilogParserREAL_NUMBER-345))|(1<<(SystemVerilogParserUNSIGNED_NUMBER-345))|(1<<(SystemVerilogParserSTRING_LITERAL-345))|(1<<(SystemVerilogParserSIMPLE_IDENTIFIER-345))|(1<<(SystemVerilogParserSYSTEM_TF_IDENTIFIER-345)))) != 0) {
						{
							p.SetState(6970)
							p.expression(0)
						}

					}

				}
				p.SetState(6977)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 857, p.GetParserRuleContext())
			}
			p.SetState(6982)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == SystemVerilogParserCOMMA {
				{
					p.SetState(6978)
					p.Match(SystemVerilogParserCOMMA)
				}
				p.SetState(6980)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == SystemVerilogParserAT {
					{
						p.SetState(6979)
						p.Clocking_event()
					}

				}

			}

		}
		{
			p.SetState(6986)
			p.Match(SystemVerilogParserRP)
		}

	}

	return localctx
}

// ISubroutine_callContext is an interface to support dynamic dispatch.
type ISubroutine_callContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubroutine_callContext differentiates from other interfaces.
	IsSubroutine_callContext()
}

type Subroutine_callContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubroutine_callContext() *Subroutine_callContext {
	var p = new(Subroutine_callContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_subroutine_call
	return p
}

func (*Subroutine_callContext) IsSubroutine_callContext() {}

func NewSubroutine_callContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Subroutine_callContext {
	var p = new(Subroutine_callContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_subroutine_call

	return p
}

func (s *Subroutine_callContext) GetParser() antlr.Parser { return s.parser }

func (s *Subroutine_callContext) Tf_call() ITf_callContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITf_callContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITf_callContext)
}

func (s *Subroutine_callContext) System_tf_call() ISystem_tf_callContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISystem_tf_callContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISystem_tf_callContext)
}

func (s *Subroutine_callContext) DOT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserDOT, 0)
}

func (s *Subroutine_callContext) Method_call_body() IMethod_call_bodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMethod_call_bodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMethod_call_bodyContext)
}

func (s *Subroutine_callContext) Primary_literal() IPrimary_literalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimary_literalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimary_literalContext)
}

func (s *Subroutine_callContext) Hierarchical_identifier() IHierarchical_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_identifierContext)
}

func (s *Subroutine_callContext) Select_() ISelect_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelect_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelect_Context)
}

func (s *Subroutine_callContext) Empty_unpacked_array_concatenation() IEmpty_unpacked_array_concatenationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEmpty_unpacked_array_concatenationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEmpty_unpacked_array_concatenationContext)
}

func (s *Subroutine_callContext) Concatenation() IConcatenationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConcatenationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConcatenationContext)
}

func (s *Subroutine_callContext) Multiple_concatenation() IMultiple_concatenationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMultiple_concatenationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMultiple_concatenationContext)
}

func (s *Subroutine_callContext) Let_expression() ILet_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILet_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILet_expressionContext)
}

func (s *Subroutine_callContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Subroutine_callContext) Mintypmax_expression() IMintypmax_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMintypmax_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMintypmax_expressionContext)
}

func (s *Subroutine_callContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Subroutine_callContext) Assignment_pattern_expression() IAssignment_pattern_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignment_pattern_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignment_pattern_expressionContext)
}

func (s *Subroutine_callContext) Streaming_concatenation() IStreaming_concatenationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStreaming_concatenationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStreaming_concatenationContext)
}

func (s *Subroutine_callContext) Sequence_method_call() ISequence_method_callContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequence_method_callContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISequence_method_callContext)
}

func (s *Subroutine_callContext) KTHIS() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKTHIS, 0)
}

func (s *Subroutine_callContext) DOLLAR() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserDOLLAR, 0)
}

func (s *Subroutine_callContext) KNULL() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKNULL, 0)
}

func (s *Subroutine_callContext) Implicit_class_handle() IImplicit_class_handleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImplicit_class_handleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImplicit_class_handleContext)
}

func (s *Subroutine_callContext) Class_qualifier() IClass_qualifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_qualifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClass_qualifierContext)
}

func (s *Subroutine_callContext) Package_scope() IPackage_scopeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackage_scopeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPackage_scopeContext)
}

func (s *Subroutine_callContext) LB() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLB, 0)
}

func (s *Subroutine_callContext) Range_expression() IRange_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_expressionContext)
}

func (s *Subroutine_callContext) RB() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRB, 0)
}

func (s *Subroutine_callContext) Randomize_call() IRandomize_callContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRandomize_callContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRandomize_callContext)
}

func (s *Subroutine_callContext) KSTD() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKSTD, 0)
}

func (s *Subroutine_callContext) COLONCOLON() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOLONCOLON, 0)
}

func (s *Subroutine_callContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Subroutine_callContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Subroutine_callContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterSubroutine_call(s)
	}
}

func (s *Subroutine_callContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitSubroutine_call(s)
	}
}

func (p *SystemVerilogParser) Subroutine_call() (localctx ISubroutine_callContext) {
	this := p
	_ = this

	localctx = NewSubroutine_callContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 996, SystemVerilogParserRULE_subroutine_call)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(7036)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 867, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6990)
			p.Tf_call()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6991)
			p.System_tf_call()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(7027)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 865, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(6992)
				p.Primary_literal()
			}

		case 2:
			p.SetState(6995)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 862, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(6993)
					p.Class_qualifier()
				}

			} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 862, p.GetParserRuleContext()) == 2 {
				{
					p.SetState(6994)
					p.Package_scope()
				}

			}
			{
				p.SetState(6997)
				p.Hierarchical_identifier()
			}
			{
				p.SetState(6998)
				p.Select_()
			}

		case 3:
			{
				p.SetState(7000)
				p.Empty_unpacked_array_concatenation()
			}

		case 4:
			{
				p.SetState(7001)
				p.Concatenation()
			}
			p.SetState(7006)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == SystemVerilogParserLB {
				{
					p.SetState(7002)
					p.Match(SystemVerilogParserLB)
				}
				{
					p.SetState(7003)
					p.Range_expression()
				}
				{
					p.SetState(7004)
					p.Match(SystemVerilogParserRB)
				}

			}

		case 5:
			{
				p.SetState(7008)
				p.Multiple_concatenation()
			}
			p.SetState(7013)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == SystemVerilogParserLB {
				{
					p.SetState(7009)
					p.Match(SystemVerilogParserLB)
				}
				{
					p.SetState(7010)
					p.Range_expression()
				}
				{
					p.SetState(7011)
					p.Match(SystemVerilogParserRB)
				}

			}

		case 6:
			{
				p.SetState(7015)
				p.Let_expression()
			}

		case 7:
			{
				p.SetState(7016)
				p.Match(SystemVerilogParserLP)
			}
			{
				p.SetState(7017)
				p.Mintypmax_expression()
			}
			{
				p.SetState(7018)
				p.Match(SystemVerilogParserRP)
			}

		case 8:
			{
				p.SetState(7020)
				p.Assignment_pattern_expression()
			}

		case 9:
			{
				p.SetState(7021)
				p.Streaming_concatenation()
			}

		case 10:
			{
				p.SetState(7022)
				p.Sequence_method_call()
			}

		case 11:
			{
				p.SetState(7023)
				p.Match(SystemVerilogParserKTHIS)
			}

		case 12:
			{
				p.SetState(7024)
				p.Match(SystemVerilogParserDOLLAR)
			}

		case 13:
			{
				p.SetState(7025)
				p.Match(SystemVerilogParserKNULL)
			}

		case 14:
			{
				p.SetState(7026)
				p.Implicit_class_handle()
			}

		}
		{
			p.SetState(7029)
			p.Match(SystemVerilogParserDOT)
		}
		{
			p.SetState(7030)
			p.Method_call_body()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(7033)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserKSTD {
			{
				p.SetState(7031)
				p.Match(SystemVerilogParserKSTD)
			}
			{
				p.SetState(7032)
				p.Match(SystemVerilogParserCOLONCOLON)
			}

		}
		{
			p.SetState(7035)
			p.Randomize_call()
		}

	}

	return localctx
}

// IFunction_subroutine_callContext is an interface to support dynamic dispatch.
type IFunction_subroutine_callContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_subroutine_callContext differentiates from other interfaces.
	IsFunction_subroutine_callContext()
}

type Function_subroutine_callContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_subroutine_callContext() *Function_subroutine_callContext {
	var p = new(Function_subroutine_callContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_function_subroutine_call
	return p
}

func (*Function_subroutine_callContext) IsFunction_subroutine_callContext() {}

func NewFunction_subroutine_callContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_subroutine_callContext {
	var p = new(Function_subroutine_callContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_function_subroutine_call

	return p
}

func (s *Function_subroutine_callContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_subroutine_callContext) Subroutine_call() ISubroutine_callContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubroutine_callContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubroutine_callContext)
}

func (s *Function_subroutine_callContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_subroutine_callContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_subroutine_callContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterFunction_subroutine_call(s)
	}
}

func (s *Function_subroutine_callContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitFunction_subroutine_call(s)
	}
}

func (p *SystemVerilogParser) Function_subroutine_call() (localctx IFunction_subroutine_callContext) {
	this := p
	_ = this

	localctx = NewFunction_subroutine_callContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 998, SystemVerilogParserRULE_function_subroutine_call)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7038)
		p.Subroutine_call()
	}

	return localctx
}

// IList_of_argumentsContext is an interface to support dynamic dispatch.
type IList_of_argumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_of_argumentsContext differentiates from other interfaces.
	IsList_of_argumentsContext()
}

type List_of_argumentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_of_argumentsContext() *List_of_argumentsContext {
	var p = new(List_of_argumentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_list_of_arguments
	return p
}

func (*List_of_argumentsContext) IsList_of_argumentsContext() {}

func NewList_of_argumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_of_argumentsContext {
	var p = new(List_of_argumentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_list_of_arguments

	return p
}

func (s *List_of_argumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *List_of_argumentsContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserDOT)
}

func (s *List_of_argumentsContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserDOT, i)
}

func (s *List_of_argumentsContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *List_of_argumentsContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *List_of_argumentsContext) AllLP() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserLP)
}

func (s *List_of_argumentsContext) LP(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, i)
}

func (s *List_of_argumentsContext) AllRP() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserRP)
}

func (s *List_of_argumentsContext) RP(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, i)
}

func (s *List_of_argumentsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *List_of_argumentsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *List_of_argumentsContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *List_of_argumentsContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *List_of_argumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_of_argumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_of_argumentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterList_of_arguments(s)
	}
}

func (s *List_of_argumentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitList_of_arguments(s)
	}
}

func (p *SystemVerilogParser) List_of_arguments() (localctx IList_of_argumentsContext) {
	this := p
	_ = this

	localctx = NewList_of_argumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1000, SystemVerilogParserRULE_list_of_arguments)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(7060)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserMINUS, SystemVerilogParserMINUSMINS, SystemVerilogParserNOT, SystemVerilogParserDOLLAR, SystemVerilogParserDROOT, SystemVerilogParserDUNIT, SystemVerilogParserAND, SystemVerilogParserLP, SystemVerilogParserRP, SystemVerilogParserCOMMA, SystemVerilogParserQUOTE, SystemVerilogParserCARET, SystemVerilogParserCARETSQUIG, SystemVerilogParserLC, SystemVerilogParserBAR, SystemVerilogParserSQUIG, SystemVerilogParserSQUIGAND, SystemVerilogParserSQUIGCARET, SystemVerilogParserSQUIGBAR, SystemVerilogParserPLUS, SystemVerilogParserPLUSPLUS, SystemVerilogParserKBIT, SystemVerilogParserKBYTE, SystemVerilogParserKCONST, SystemVerilogParserKINT, SystemVerilogParserKINTEGER, SystemVerilogParserKLOCAL, SystemVerilogParserKLOGIC, SystemVerilogParserKLONGINT, SystemVerilogParserKNULL, SystemVerilogParserKRANDOMIZE, SystemVerilogParserKREAL, SystemVerilogParserKREALTIME, SystemVerilogParserKREG, SystemVerilogParserKSHORTINT, SystemVerilogParserKSHORTREAL, SystemVerilogParserKSIGNED, SystemVerilogParserKSTD, SystemVerilogParserKSTRING, SystemVerilogParserKSUPER, SystemVerilogParserKTAGGED, SystemVerilogParserKTHIS, SystemVerilogParserKTIME, SystemVerilogParserKTYPE, SystemVerilogParserKUNSIGNED, SystemVerilogParserTIME_LITERAL, SystemVerilogParserDECIMAL_NUMBER, SystemVerilogParserBINARY_NUMBER, SystemVerilogParserOCTAL_NUMBER, SystemVerilogParserHEX_NUMBER, SystemVerilogParserREAL_NUMBER, SystemVerilogParserUNSIGNED_NUMBER, SystemVerilogParserSTRING_LITERAL, SystemVerilogParserSIMPLE_IDENTIFIER, SystemVerilogParserSYSTEM_TF_IDENTIFIER:
		p.SetState(7041)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SystemVerilogParserMINUS)|(1<<SystemVerilogParserMINUSMINS)|(1<<SystemVerilogParserNOT)|(1<<SystemVerilogParserDOLLAR)|(1<<SystemVerilogParserDROOT)|(1<<SystemVerilogParserDUNIT)|(1<<SystemVerilogParserAND)|(1<<SystemVerilogParserLP))) != 0) || (((_la-51)&-(0x1f+1)) == 0 && ((1<<uint((_la-51)))&((1<<(SystemVerilogParserQUOTE-51))|(1<<(SystemVerilogParserCARET-51))|(1<<(SystemVerilogParserCARETSQUIG-51))|(1<<(SystemVerilogParserLC-51))|(1<<(SystemVerilogParserBAR-51))|(1<<(SystemVerilogParserSQUIG-51))|(1<<(SystemVerilogParserSQUIGAND-51))|(1<<(SystemVerilogParserSQUIGCARET-51))|(1<<(SystemVerilogParserSQUIGBAR-51))|(1<<(SystemVerilogParserPLUS-51))|(1<<(SystemVerilogParserPLUSPLUS-51)))) != 0) || (((_la-109)&-(0x1f+1)) == 0 && ((1<<uint((_la-109)))&((1<<(SystemVerilogParserKBIT-109))|(1<<(SystemVerilogParserKBYTE-109))|(1<<(SystemVerilogParserKCONST-109)))) != 0) || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SystemVerilogParserKINT-195))|(1<<(SystemVerilogParserKINTEGER-195))|(1<<(SystemVerilogParserKLOCAL-195))|(1<<(SystemVerilogParserKLOGIC-195))|(1<<(SystemVerilogParserKLONGINT-195)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(SystemVerilogParserKNULL-228))|(1<<(SystemVerilogParserKRANDOMIZE-228))|(1<<(SystemVerilogParserKREAL-228))|(1<<(SystemVerilogParserKREALTIME-228))|(1<<(SystemVerilogParserKREG-228)))) != 0) || (((_la-276)&-(0x1f+1)) == 0 && ((1<<uint((_la-276)))&((1<<(SystemVerilogParserKSHORTINT-276))|(1<<(SystemVerilogParserKSHORTREAL-276))|(1<<(SystemVerilogParserKSIGNED-276))|(1<<(SystemVerilogParserKSTD-276))|(1<<(SystemVerilogParserKSTRING-276))|(1<<(SystemVerilogParserKSUPER-276))|(1<<(SystemVerilogParserKTAGGED-276))|(1<<(SystemVerilogParserKTHIS-276))|(1<<(SystemVerilogParserKTIME-276)))) != 0) || _la == SystemVerilogParserKTYPE || _la == SystemVerilogParserKUNSIGNED || (((_la-345)&-(0x1f+1)) == 0 && ((1<<uint((_la-345)))&((1<<(SystemVerilogParserTIME_LITERAL-345))|(1<<(SystemVerilogParserDECIMAL_NUMBER-345))|(1<<(SystemVerilogParserBINARY_NUMBER-345))|(1<<(SystemVerilogParserOCTAL_NUMBER-345))|(1<<(SystemVerilogParserHEX_NUMBER-345))|(1<<(SystemVerilogParserREAL_NUMBER-345))|(1<<(SystemVerilogParserUNSIGNED_NUMBER-345))|(1<<(SystemVerilogParserSTRING_LITERAL-345))|(1<<(SystemVerilogParserSIMPLE_IDENTIFIER-345))|(1<<(SystemVerilogParserSYSTEM_TF_IDENTIFIER-345)))) != 0) {
			{
				p.SetState(7040)
				p.expression(0)
			}

		}
		p.SetState(7049)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 870, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(7043)
					p.Match(SystemVerilogParserCOMMA)
				}
				p.SetState(7045)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SystemVerilogParserMINUS)|(1<<SystemVerilogParserMINUSMINS)|(1<<SystemVerilogParserNOT)|(1<<SystemVerilogParserDOLLAR)|(1<<SystemVerilogParserDROOT)|(1<<SystemVerilogParserDUNIT)|(1<<SystemVerilogParserAND)|(1<<SystemVerilogParserLP))) != 0) || (((_la-51)&-(0x1f+1)) == 0 && ((1<<uint((_la-51)))&((1<<(SystemVerilogParserQUOTE-51))|(1<<(SystemVerilogParserCARET-51))|(1<<(SystemVerilogParserCARETSQUIG-51))|(1<<(SystemVerilogParserLC-51))|(1<<(SystemVerilogParserBAR-51))|(1<<(SystemVerilogParserSQUIG-51))|(1<<(SystemVerilogParserSQUIGAND-51))|(1<<(SystemVerilogParserSQUIGCARET-51))|(1<<(SystemVerilogParserSQUIGBAR-51))|(1<<(SystemVerilogParserPLUS-51))|(1<<(SystemVerilogParserPLUSPLUS-51)))) != 0) || (((_la-109)&-(0x1f+1)) == 0 && ((1<<uint((_la-109)))&((1<<(SystemVerilogParserKBIT-109))|(1<<(SystemVerilogParserKBYTE-109))|(1<<(SystemVerilogParserKCONST-109)))) != 0) || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SystemVerilogParserKINT-195))|(1<<(SystemVerilogParserKINTEGER-195))|(1<<(SystemVerilogParserKLOCAL-195))|(1<<(SystemVerilogParserKLOGIC-195))|(1<<(SystemVerilogParserKLONGINT-195)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(SystemVerilogParserKNULL-228))|(1<<(SystemVerilogParserKRANDOMIZE-228))|(1<<(SystemVerilogParserKREAL-228))|(1<<(SystemVerilogParserKREALTIME-228))|(1<<(SystemVerilogParserKREG-228)))) != 0) || (((_la-276)&-(0x1f+1)) == 0 && ((1<<uint((_la-276)))&((1<<(SystemVerilogParserKSHORTINT-276))|(1<<(SystemVerilogParserKSHORTREAL-276))|(1<<(SystemVerilogParserKSIGNED-276))|(1<<(SystemVerilogParserKSTD-276))|(1<<(SystemVerilogParserKSTRING-276))|(1<<(SystemVerilogParserKSUPER-276))|(1<<(SystemVerilogParserKTAGGED-276))|(1<<(SystemVerilogParserKTHIS-276))|(1<<(SystemVerilogParserKTIME-276)))) != 0) || _la == SystemVerilogParserKTYPE || _la == SystemVerilogParserKUNSIGNED || (((_la-345)&-(0x1f+1)) == 0 && ((1<<uint((_la-345)))&((1<<(SystemVerilogParserTIME_LITERAL-345))|(1<<(SystemVerilogParserDECIMAL_NUMBER-345))|(1<<(SystemVerilogParserBINARY_NUMBER-345))|(1<<(SystemVerilogParserOCTAL_NUMBER-345))|(1<<(SystemVerilogParserHEX_NUMBER-345))|(1<<(SystemVerilogParserREAL_NUMBER-345))|(1<<(SystemVerilogParserUNSIGNED_NUMBER-345))|(1<<(SystemVerilogParserSTRING_LITERAL-345))|(1<<(SystemVerilogParserSIMPLE_IDENTIFIER-345))|(1<<(SystemVerilogParserSYSTEM_TF_IDENTIFIER-345)))) != 0) {
					{
						p.SetState(7044)
						p.expression(0)
					}

				}

			}
			p.SetState(7051)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 870, p.GetParserRuleContext())
		}

	case SystemVerilogParserDOT:
		{
			p.SetState(7052)
			p.Match(SystemVerilogParserDOT)
		}
		{
			p.SetState(7053)
			p.Identifier()
		}
		{
			p.SetState(7054)
			p.Match(SystemVerilogParserLP)
		}
		p.SetState(7056)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SystemVerilogParserMINUS)|(1<<SystemVerilogParserMINUSMINS)|(1<<SystemVerilogParserNOT)|(1<<SystemVerilogParserDOLLAR)|(1<<SystemVerilogParserDROOT)|(1<<SystemVerilogParserDUNIT)|(1<<SystemVerilogParserAND)|(1<<SystemVerilogParserLP))) != 0) || (((_la-51)&-(0x1f+1)) == 0 && ((1<<uint((_la-51)))&((1<<(SystemVerilogParserQUOTE-51))|(1<<(SystemVerilogParserCARET-51))|(1<<(SystemVerilogParserCARETSQUIG-51))|(1<<(SystemVerilogParserLC-51))|(1<<(SystemVerilogParserBAR-51))|(1<<(SystemVerilogParserSQUIG-51))|(1<<(SystemVerilogParserSQUIGAND-51))|(1<<(SystemVerilogParserSQUIGCARET-51))|(1<<(SystemVerilogParserSQUIGBAR-51))|(1<<(SystemVerilogParserPLUS-51))|(1<<(SystemVerilogParserPLUSPLUS-51)))) != 0) || (((_la-109)&-(0x1f+1)) == 0 && ((1<<uint((_la-109)))&((1<<(SystemVerilogParserKBIT-109))|(1<<(SystemVerilogParserKBYTE-109))|(1<<(SystemVerilogParserKCONST-109)))) != 0) || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SystemVerilogParserKINT-195))|(1<<(SystemVerilogParserKINTEGER-195))|(1<<(SystemVerilogParserKLOCAL-195))|(1<<(SystemVerilogParserKLOGIC-195))|(1<<(SystemVerilogParserKLONGINT-195)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(SystemVerilogParserKNULL-228))|(1<<(SystemVerilogParserKRANDOMIZE-228))|(1<<(SystemVerilogParserKREAL-228))|(1<<(SystemVerilogParserKREALTIME-228))|(1<<(SystemVerilogParserKREG-228)))) != 0) || (((_la-276)&-(0x1f+1)) == 0 && ((1<<uint((_la-276)))&((1<<(SystemVerilogParserKSHORTINT-276))|(1<<(SystemVerilogParserKSHORTREAL-276))|(1<<(SystemVerilogParserKSIGNED-276))|(1<<(SystemVerilogParserKSTD-276))|(1<<(SystemVerilogParserKSTRING-276))|(1<<(SystemVerilogParserKSUPER-276))|(1<<(SystemVerilogParserKTAGGED-276))|(1<<(SystemVerilogParserKTHIS-276))|(1<<(SystemVerilogParserKTIME-276)))) != 0) || _la == SystemVerilogParserKTYPE || _la == SystemVerilogParserKUNSIGNED || (((_la-345)&-(0x1f+1)) == 0 && ((1<<uint((_la-345)))&((1<<(SystemVerilogParserTIME_LITERAL-345))|(1<<(SystemVerilogParserDECIMAL_NUMBER-345))|(1<<(SystemVerilogParserBINARY_NUMBER-345))|(1<<(SystemVerilogParserOCTAL_NUMBER-345))|(1<<(SystemVerilogParserHEX_NUMBER-345))|(1<<(SystemVerilogParserREAL_NUMBER-345))|(1<<(SystemVerilogParserUNSIGNED_NUMBER-345))|(1<<(SystemVerilogParserSTRING_LITERAL-345))|(1<<(SystemVerilogParserSIMPLE_IDENTIFIER-345))|(1<<(SystemVerilogParserSYSTEM_TF_IDENTIFIER-345)))) != 0) {
			{
				p.SetState(7055)
				p.expression(0)
			}

		}
		{
			p.SetState(7058)
			p.Match(SystemVerilogParserRP)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(7073)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserCOMMA {
		{
			p.SetState(7062)
			p.Match(SystemVerilogParserCOMMA)
		}
		{
			p.SetState(7063)
			p.Match(SystemVerilogParserDOT)
		}
		{
			p.SetState(7064)
			p.Identifier()
		}
		{
			p.SetState(7065)
			p.Match(SystemVerilogParserLP)
		}
		p.SetState(7067)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SystemVerilogParserMINUS)|(1<<SystemVerilogParserMINUSMINS)|(1<<SystemVerilogParserNOT)|(1<<SystemVerilogParserDOLLAR)|(1<<SystemVerilogParserDROOT)|(1<<SystemVerilogParserDUNIT)|(1<<SystemVerilogParserAND)|(1<<SystemVerilogParserLP))) != 0) || (((_la-51)&-(0x1f+1)) == 0 && ((1<<uint((_la-51)))&((1<<(SystemVerilogParserQUOTE-51))|(1<<(SystemVerilogParserCARET-51))|(1<<(SystemVerilogParserCARETSQUIG-51))|(1<<(SystemVerilogParserLC-51))|(1<<(SystemVerilogParserBAR-51))|(1<<(SystemVerilogParserSQUIG-51))|(1<<(SystemVerilogParserSQUIGAND-51))|(1<<(SystemVerilogParserSQUIGCARET-51))|(1<<(SystemVerilogParserSQUIGBAR-51))|(1<<(SystemVerilogParserPLUS-51))|(1<<(SystemVerilogParserPLUSPLUS-51)))) != 0) || (((_la-109)&-(0x1f+1)) == 0 && ((1<<uint((_la-109)))&((1<<(SystemVerilogParserKBIT-109))|(1<<(SystemVerilogParserKBYTE-109))|(1<<(SystemVerilogParserKCONST-109)))) != 0) || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SystemVerilogParserKINT-195))|(1<<(SystemVerilogParserKINTEGER-195))|(1<<(SystemVerilogParserKLOCAL-195))|(1<<(SystemVerilogParserKLOGIC-195))|(1<<(SystemVerilogParserKLONGINT-195)))) != 0) || (((_la-228)&-(0x1f+1)) == 0 && ((1<<uint((_la-228)))&((1<<(SystemVerilogParserKNULL-228))|(1<<(SystemVerilogParserKRANDOMIZE-228))|(1<<(SystemVerilogParserKREAL-228))|(1<<(SystemVerilogParserKREALTIME-228))|(1<<(SystemVerilogParserKREG-228)))) != 0) || (((_la-276)&-(0x1f+1)) == 0 && ((1<<uint((_la-276)))&((1<<(SystemVerilogParserKSHORTINT-276))|(1<<(SystemVerilogParserKSHORTREAL-276))|(1<<(SystemVerilogParserKSIGNED-276))|(1<<(SystemVerilogParserKSTD-276))|(1<<(SystemVerilogParserKSTRING-276))|(1<<(SystemVerilogParserKSUPER-276))|(1<<(SystemVerilogParserKTAGGED-276))|(1<<(SystemVerilogParserKTHIS-276))|(1<<(SystemVerilogParserKTIME-276)))) != 0) || _la == SystemVerilogParserKTYPE || _la == SystemVerilogParserKUNSIGNED || (((_la-345)&-(0x1f+1)) == 0 && ((1<<uint((_la-345)))&((1<<(SystemVerilogParserTIME_LITERAL-345))|(1<<(SystemVerilogParserDECIMAL_NUMBER-345))|(1<<(SystemVerilogParserBINARY_NUMBER-345))|(1<<(SystemVerilogParserOCTAL_NUMBER-345))|(1<<(SystemVerilogParserHEX_NUMBER-345))|(1<<(SystemVerilogParserREAL_NUMBER-345))|(1<<(SystemVerilogParserUNSIGNED_NUMBER-345))|(1<<(SystemVerilogParserSTRING_LITERAL-345))|(1<<(SystemVerilogParserSIMPLE_IDENTIFIER-345))|(1<<(SystemVerilogParserSYSTEM_TF_IDENTIFIER-345)))) != 0) {
			{
				p.SetState(7066)
				p.expression(0)
			}

		}
		{
			p.SetState(7069)
			p.Match(SystemVerilogParserRP)
		}

		p.SetState(7075)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IMethod_call_bodyContext is an interface to support dynamic dispatch.
type IMethod_call_bodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMethod_call_bodyContext differentiates from other interfaces.
	IsMethod_call_bodyContext()
}

type Method_call_bodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethod_call_bodyContext() *Method_call_bodyContext {
	var p = new(Method_call_bodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_method_call_body
	return p
}

func (*Method_call_bodyContext) IsMethod_call_bodyContext() {}

func NewMethod_call_bodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Method_call_bodyContext {
	var p = new(Method_call_bodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_method_call_body

	return p
}

func (s *Method_call_bodyContext) GetParser() antlr.Parser { return s.parser }

func (s *Method_call_bodyContext) Method_identifier() IMethod_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMethod_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMethod_identifierContext)
}

func (s *Method_call_bodyContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Method_call_bodyContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Method_call_bodyContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Method_call_bodyContext) List_of_arguments() IList_of_argumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_argumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_argumentsContext)
}

func (s *Method_call_bodyContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Method_call_bodyContext) Built_in_method_call() IBuilt_in_method_callContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBuilt_in_method_callContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBuilt_in_method_callContext)
}

func (s *Method_call_bodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Method_call_bodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Method_call_bodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterMethod_call_body(s)
	}
}

func (s *Method_call_bodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitMethod_call_body(s)
	}
}

func (p *SystemVerilogParser) Method_call_body() (localctx IMethod_call_bodyContext) {
	this := p
	_ = this

	localctx = NewMethod_call_bodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1002, SystemVerilogParserRULE_method_call_body)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(7090)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 877, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7076)
			p.Method_identifier()
		}
		p.SetState(7080)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 875, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(7077)
					p.Attribute_instance()
				}

			}
			p.SetState(7082)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 875, p.GetParserRuleContext())
		}
		p.SetState(7087)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 876, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7083)
				p.Match(SystemVerilogParserLP)
			}
			{
				p.SetState(7084)
				p.List_of_arguments()
			}
			{
				p.SetState(7085)
				p.Match(SystemVerilogParserRP)
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7089)
			p.Built_in_method_call()
		}

	}

	return localctx
}

// IBuilt_in_method_callContext is an interface to support dynamic dispatch.
type IBuilt_in_method_callContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBuilt_in_method_callContext differentiates from other interfaces.
	IsBuilt_in_method_callContext()
}

type Built_in_method_callContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBuilt_in_method_callContext() *Built_in_method_callContext {
	var p = new(Built_in_method_callContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_built_in_method_call
	return p
}

func (*Built_in_method_callContext) IsBuilt_in_method_callContext() {}

func NewBuilt_in_method_callContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Built_in_method_callContext {
	var p = new(Built_in_method_callContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_built_in_method_call

	return p
}

func (s *Built_in_method_callContext) GetParser() antlr.Parser { return s.parser }

func (s *Built_in_method_callContext) Array_manipulation_call() IArray_manipulation_callContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArray_manipulation_callContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArray_manipulation_callContext)
}

func (s *Built_in_method_callContext) Randomize_call() IRandomize_callContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRandomize_callContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRandomize_callContext)
}

func (s *Built_in_method_callContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Built_in_method_callContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Built_in_method_callContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterBuilt_in_method_call(s)
	}
}

func (s *Built_in_method_callContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitBuilt_in_method_call(s)
	}
}

func (p *SystemVerilogParser) Built_in_method_call() (localctx IBuilt_in_method_callContext) {
	this := p
	_ = this

	localctx = NewBuilt_in_method_callContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1004, SystemVerilogParserRULE_built_in_method_call)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(7094)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserKAND, SystemVerilogParserKOR, SystemVerilogParserKUNIQUE, SystemVerilogParserKXOR, SystemVerilogParserSIMPLE_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7092)
			p.Array_manipulation_call()
		}

	case SystemVerilogParserKRANDOMIZE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7093)
			p.Randomize_call()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IArray_manipulation_callContext is an interface to support dynamic dispatch.
type IArray_manipulation_callContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArray_manipulation_callContext differentiates from other interfaces.
	IsArray_manipulation_callContext()
}

type Array_manipulation_callContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArray_manipulation_callContext() *Array_manipulation_callContext {
	var p = new(Array_manipulation_callContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_array_manipulation_call
	return p
}

func (*Array_manipulation_callContext) IsArray_manipulation_callContext() {}

func NewArray_manipulation_callContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Array_manipulation_callContext {
	var p = new(Array_manipulation_callContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_array_manipulation_call

	return p
}

func (s *Array_manipulation_callContext) GetParser() antlr.Parser { return s.parser }

func (s *Array_manipulation_callContext) Array_method_name() IArray_method_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArray_method_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArray_method_nameContext)
}

func (s *Array_manipulation_callContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Array_manipulation_callContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Array_manipulation_callContext) AllLP() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserLP)
}

func (s *Array_manipulation_callContext) LP(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, i)
}

func (s *Array_manipulation_callContext) List_of_arguments() IList_of_argumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_of_argumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_of_argumentsContext)
}

func (s *Array_manipulation_callContext) AllRP() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserRP)
}

func (s *Array_manipulation_callContext) RP(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, i)
}

func (s *Array_manipulation_callContext) KWITH() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKWITH, 0)
}

func (s *Array_manipulation_callContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Array_manipulation_callContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Array_manipulation_callContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Array_manipulation_callContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterArray_manipulation_call(s)
	}
}

func (s *Array_manipulation_callContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitArray_manipulation_call(s)
	}
}

func (p *SystemVerilogParser) Array_manipulation_call() (localctx IArray_manipulation_callContext) {
	this := p
	_ = this

	localctx = NewArray_manipulation_callContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1006, SystemVerilogParserRULE_array_manipulation_call)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7096)
		p.Array_method_name()
	}
	p.SetState(7100)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 879, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(7097)
				p.Attribute_instance()
			}

		}
		p.SetState(7102)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 879, p.GetParserRuleContext())
	}
	p.SetState(7107)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 880, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(7103)
			p.Match(SystemVerilogParserLP)
		}
		{
			p.SetState(7104)
			p.List_of_arguments()
		}
		{
			p.SetState(7105)
			p.Match(SystemVerilogParserRP)
		}

	}
	p.SetState(7114)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 881, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(7109)
			p.Match(SystemVerilogParserKWITH)
		}
		{
			p.SetState(7110)
			p.Match(SystemVerilogParserLP)
		}
		{
			p.SetState(7111)
			p.expression(0)
		}
		{
			p.SetState(7112)
			p.Match(SystemVerilogParserRP)
		}

	}

	return localctx
}

// IRandomize_callContext is an interface to support dynamic dispatch.
type IRandomize_callContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRandomize_callContext differentiates from other interfaces.
	IsRandomize_callContext()
}

type Randomize_callContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRandomize_callContext() *Randomize_callContext {
	var p = new(Randomize_callContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_randomize_call
	return p
}

func (*Randomize_callContext) IsRandomize_callContext() {}

func NewRandomize_callContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Randomize_callContext {
	var p = new(Randomize_callContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_randomize_call

	return p
}

func (s *Randomize_callContext) GetParser() antlr.Parser { return s.parser }

func (s *Randomize_callContext) KRANDOMIZE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKRANDOMIZE, 0)
}

func (s *Randomize_callContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Randomize_callContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Randomize_callContext) AllLP() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserLP)
}

func (s *Randomize_callContext) LP(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, i)
}

func (s *Randomize_callContext) AllRP() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserRP)
}

func (s *Randomize_callContext) RP(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, i)
}

func (s *Randomize_callContext) KWITH() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKWITH, 0)
}

func (s *Randomize_callContext) Constraint_block() IConstraint_blockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstraint_blockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstraint_blockContext)
}

func (s *Randomize_callContext) Variable_identifier_list() IVariable_identifier_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_identifier_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_identifier_listContext)
}

func (s *Randomize_callContext) KNULL() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKNULL, 0)
}

func (s *Randomize_callContext) Identifier_list() IIdentifier_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifier_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifier_listContext)
}

func (s *Randomize_callContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Randomize_callContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Randomize_callContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterRandomize_call(s)
	}
}

func (s *Randomize_callContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitRandomize_call(s)
	}
}

func (p *SystemVerilogParser) Randomize_call() (localctx IRandomize_callContext) {
	this := p
	_ = this

	localctx = NewRandomize_callContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1008, SystemVerilogParserRULE_randomize_call)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7116)
		p.Match(SystemVerilogParserKRANDOMIZE)
	}
	p.SetState(7120)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 882, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(7117)
				p.Attribute_instance()
			}

		}
		p.SetState(7122)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 882, p.GetParserRuleContext())
	}
	p.SetState(7129)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 884, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(7123)
			p.Match(SystemVerilogParserLP)
		}
		p.SetState(7126)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SystemVerilogParserSIMPLE_IDENTIFIER:
			{
				p.SetState(7124)
				p.Variable_identifier_list()
			}

		case SystemVerilogParserKNULL:
			{
				p.SetState(7125)
				p.Match(SystemVerilogParserKNULL)
			}

		case SystemVerilogParserRP:

		default:
		}
		{
			p.SetState(7128)
			p.Match(SystemVerilogParserRP)
		}

	}
	p.SetState(7140)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 887, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(7131)
			p.Match(SystemVerilogParserKWITH)
		}
		p.SetState(7137)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserLP {
			{
				p.SetState(7132)
				p.Match(SystemVerilogParserLP)
			}
			p.SetState(7134)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == SystemVerilogParserSIMPLE_IDENTIFIER {
				{
					p.SetState(7133)
					p.Identifier_list()
				}

			}
			{
				p.SetState(7136)
				p.Match(SystemVerilogParserRP)
			}

		}
		{
			p.SetState(7139)
			p.Constraint_block()
		}

	}

	return localctx
}

// IArray_method_nameContext is an interface to support dynamic dispatch.
type IArray_method_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArray_method_nameContext differentiates from other interfaces.
	IsArray_method_nameContext()
}

type Array_method_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArray_method_nameContext() *Array_method_nameContext {
	var p = new(Array_method_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_array_method_name
	return p
}

func (*Array_method_nameContext) IsArray_method_nameContext() {}

func NewArray_method_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Array_method_nameContext {
	var p = new(Array_method_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_array_method_name

	return p
}

func (s *Array_method_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Array_method_nameContext) Method_identifier() IMethod_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMethod_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMethod_identifierContext)
}

func (s *Array_method_nameContext) KUNIQUE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKUNIQUE, 0)
}

func (s *Array_method_nameContext) KAND() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKAND, 0)
}

func (s *Array_method_nameContext) KOR() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKOR, 0)
}

func (s *Array_method_nameContext) KXOR() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKXOR, 0)
}

func (s *Array_method_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Array_method_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Array_method_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterArray_method_name(s)
	}
}

func (s *Array_method_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitArray_method_name(s)
	}
}

func (p *SystemVerilogParser) Array_method_name() (localctx IArray_method_nameContext) {
	this := p
	_ = this

	localctx = NewArray_method_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1010, SystemVerilogParserRULE_array_method_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(7147)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserSIMPLE_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7142)
			p.Method_identifier()
		}

	case SystemVerilogParserKUNIQUE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7143)
			p.Match(SystemVerilogParserKUNIQUE)
		}

	case SystemVerilogParserKAND:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7144)
			p.Match(SystemVerilogParserKAND)
		}

	case SystemVerilogParserKOR:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7145)
			p.Match(SystemVerilogParserKOR)
		}

	case SystemVerilogParserKXOR:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(7146)
			p.Match(SystemVerilogParserKXOR)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IInc_or_dec_expressionContext is an interface to support dynamic dispatch.
type IInc_or_dec_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInc_or_dec_expressionContext differentiates from other interfaces.
	IsInc_or_dec_expressionContext()
}

type Inc_or_dec_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInc_or_dec_expressionContext() *Inc_or_dec_expressionContext {
	var p = new(Inc_or_dec_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_inc_or_dec_expression
	return p
}

func (*Inc_or_dec_expressionContext) IsInc_or_dec_expressionContext() {}

func NewInc_or_dec_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Inc_or_dec_expressionContext {
	var p = new(Inc_or_dec_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_inc_or_dec_expression

	return p
}

func (s *Inc_or_dec_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Inc_or_dec_expressionContext) Inc_or_dec_operator() IInc_or_dec_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInc_or_dec_operatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInc_or_dec_operatorContext)
}

func (s *Inc_or_dec_expressionContext) Variable_lvalue() IVariable_lvalueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_lvalueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_lvalueContext)
}

func (s *Inc_or_dec_expressionContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Inc_or_dec_expressionContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Inc_or_dec_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Inc_or_dec_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Inc_or_dec_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterInc_or_dec_expression(s)
	}
}

func (s *Inc_or_dec_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitInc_or_dec_expression(s)
	}
}

func (p *SystemVerilogParser) Inc_or_dec_expression() (localctx IInc_or_dec_expressionContext) {
	this := p
	_ = this

	localctx = NewInc_or_dec_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1012, SystemVerilogParserRULE_inc_or_dec_expression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(7167)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserMINUSMINS, SystemVerilogParserPLUSPLUS:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7149)
			p.Inc_or_dec_operator()
		}
		p.SetState(7153)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserLPS {
			{
				p.SetState(7150)
				p.Attribute_instance()
			}

			p.SetState(7155)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(7156)
			p.Variable_lvalue()
		}

	case SystemVerilogParserDROOT, SystemVerilogParserDUNIT, SystemVerilogParserQUOTE, SystemVerilogParserLC, SystemVerilogParserKBYTE, SystemVerilogParserKINT, SystemVerilogParserKINTEGER, SystemVerilogParserKLOCAL, SystemVerilogParserKLONGINT, SystemVerilogParserKSHORTINT, SystemVerilogParserKSUPER, SystemVerilogParserKTHIS, SystemVerilogParserKTIME, SystemVerilogParserKTYPE, SystemVerilogParserSIMPLE_IDENTIFIER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7158)
			p.Variable_lvalue()
		}
		p.SetState(7162)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserLPS {
			{
				p.SetState(7159)
				p.Attribute_instance()
			}

			p.SetState(7164)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(7165)
			p.Inc_or_dec_operator()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IConstant_expressionContext is an interface to support dynamic dispatch.
type IConstant_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstant_expressionContext differentiates from other interfaces.
	IsConstant_expressionContext()
}

type Constant_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstant_expressionContext() *Constant_expressionContext {
	var p = new(Constant_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_constant_expression
	return p
}

func (*Constant_expressionContext) IsConstant_expressionContext() {}

func NewConstant_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constant_expressionContext {
	var p = new(Constant_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_constant_expression

	return p
}

func (s *Constant_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Constant_expressionContext) Constant_primary() IConstant_primaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_primaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_primaryContext)
}

func (s *Constant_expressionContext) Unary_operator() IUnary_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnary_operatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnary_operatorContext)
}

func (s *Constant_expressionContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Constant_expressionContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Constant_expressionContext) AllConstant_expression() []IConstant_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem())
	var tst = make([]IConstant_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConstant_expressionContext)
		}
	}

	return tst
}

func (s *Constant_expressionContext) Constant_expression(i int) IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Constant_expressionContext) Binary_operator() IBinary_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBinary_operatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBinary_operatorContext)
}

func (s *Constant_expressionContext) QUES() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserQUES, 0)
}

func (s *Constant_expressionContext) COLON() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOLON, 0)
}

func (s *Constant_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constant_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constant_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterConstant_expression(s)
	}
}

func (s *Constant_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitConstant_expression(s)
	}
}

func (p *SystemVerilogParser) Constant_expression() (localctx IConstant_expressionContext) {
	return p.constant_expression(0)
}

func (p *SystemVerilogParser) constant_expression(_p int) (localctx IConstant_expressionContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewConstant_expressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IConstant_expressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 1014
	p.EnterRecursionRule(localctx, 1014, SystemVerilogParserRULE_constant_expression, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(7177)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SystemVerilogParserMINUS)|(1<<SystemVerilogParserNOT)|(1<<SystemVerilogParserAND))) != 0) || (((_la-53)&-(0x1f+1)) == 0 && ((1<<uint((_la-53)))&((1<<(SystemVerilogParserCARET-53))|(1<<(SystemVerilogParserCARETSQUIG-53))|(1<<(SystemVerilogParserBAR-53))|(1<<(SystemVerilogParserSQUIG-53))|(1<<(SystemVerilogParserSQUIGAND-53))|(1<<(SystemVerilogParserSQUIGCARET-53))|(1<<(SystemVerilogParserSQUIGBAR-53))|(1<<(SystemVerilogParserPLUS-53)))) != 0) {
		{
			p.SetState(7170)
			p.Unary_operator()
		}
		p.SetState(7174)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserLPS {
			{
				p.SetState(7171)
				p.Attribute_instance()
			}

			p.SetState(7176)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(7179)
		p.Constant_primary()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(7205)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 897, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewConstant_expressionContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, SystemVerilogParserRULE_constant_expression)
			p.SetState(7181)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			p.SetState(7199)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case SystemVerilogParserMINUS, SystemVerilogParserMINUSMINS, SystemVerilogParserNE, SystemVerilogParserNEQ, SystemVerilogParserNEE, SystemVerilogParserPER, SystemVerilogParserAND, SystemVerilogParserANDAND, SystemVerilogParserSTAR, SystemVerilogParserSS, SystemVerilogParserSLASH, SystemVerilogParserCARET, SystemVerilogParserCARETSQUIG, SystemVerilogParserBAR, SystemVerilogParserBARBAR, SystemVerilogParserSQUIGCARET, SystemVerilogParserPLUS, SystemVerilogParserPLUSPLUS, SystemVerilogParserLT, SystemVerilogParserLTLT, SystemVerilogParserLTLTLT, SystemVerilogParserLTEQ, SystemVerilogParserLTMINUSGT, SystemVerilogParserEQEQ, SystemVerilogParserEQEQQUEST, SystemVerilogParserEQEQEQ, SystemVerilogParserGT, SystemVerilogParserARROW, SystemVerilogParserGE, SystemVerilogParserGTGT, SystemVerilogParserGTGTGT:
				{
					p.SetState(7182)
					p.Binary_operator()
				}
				p.SetState(7186)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				for _la == SystemVerilogParserLPS {
					{
						p.SetState(7183)
						p.Attribute_instance()
					}

					p.SetState(7188)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)
				}

			case SystemVerilogParserQUES:
				{
					p.SetState(7189)
					p.Match(SystemVerilogParserQUES)
				}
				p.SetState(7193)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				for _la == SystemVerilogParserLPS {
					{
						p.SetState(7190)
						p.Attribute_instance()
					}

					p.SetState(7195)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(7196)
					p.constant_expression(0)
				}
				{
					p.SetState(7197)
					p.Match(SystemVerilogParserCOLON)
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}
			{
				p.SetState(7201)
				p.constant_expression(2)
			}

		}
		p.SetState(7207)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 897, p.GetParserRuleContext())
	}

	return localctx
}

// IConstant_mintypmax_expressionContext is an interface to support dynamic dispatch.
type IConstant_mintypmax_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstant_mintypmax_expressionContext differentiates from other interfaces.
	IsConstant_mintypmax_expressionContext()
}

type Constant_mintypmax_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstant_mintypmax_expressionContext() *Constant_mintypmax_expressionContext {
	var p = new(Constant_mintypmax_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_constant_mintypmax_expression
	return p
}

func (*Constant_mintypmax_expressionContext) IsConstant_mintypmax_expressionContext() {}

func NewConstant_mintypmax_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constant_mintypmax_expressionContext {
	var p = new(Constant_mintypmax_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_constant_mintypmax_expression

	return p
}

func (s *Constant_mintypmax_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Constant_mintypmax_expressionContext) AllConstant_expression() []IConstant_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem())
	var tst = make([]IConstant_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConstant_expressionContext)
		}
	}

	return tst
}

func (s *Constant_mintypmax_expressionContext) Constant_expression(i int) IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Constant_mintypmax_expressionContext) AllCOLON() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOLON)
}

func (s *Constant_mintypmax_expressionContext) COLON(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOLON, i)
}

func (s *Constant_mintypmax_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constant_mintypmax_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constant_mintypmax_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterConstant_mintypmax_expression(s)
	}
}

func (s *Constant_mintypmax_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitConstant_mintypmax_expression(s)
	}
}

func (p *SystemVerilogParser) Constant_mintypmax_expression() (localctx IConstant_mintypmax_expressionContext) {
	this := p
	_ = this

	localctx = NewConstant_mintypmax_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1016, SystemVerilogParserRULE_constant_mintypmax_expression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7208)
		p.constant_expression(0)
	}
	p.SetState(7214)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserCOLON {
		{
			p.SetState(7209)
			p.Match(SystemVerilogParserCOLON)
		}
		{
			p.SetState(7210)
			p.constant_expression(0)
		}
		{
			p.SetState(7211)
			p.Match(SystemVerilogParserCOLON)
		}
		{
			p.SetState(7212)
			p.constant_expression(0)
		}

	}

	return localctx
}

// IConstant_param_expressionContext is an interface to support dynamic dispatch.
type IConstant_param_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstant_param_expressionContext differentiates from other interfaces.
	IsConstant_param_expressionContext()
}

type Constant_param_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstant_param_expressionContext() *Constant_param_expressionContext {
	var p = new(Constant_param_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_constant_param_expression
	return p
}

func (*Constant_param_expressionContext) IsConstant_param_expressionContext() {}

func NewConstant_param_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constant_param_expressionContext {
	var p = new(Constant_param_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_constant_param_expression

	return p
}

func (s *Constant_param_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Constant_param_expressionContext) Constant_mintypmax_expression() IConstant_mintypmax_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_mintypmax_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_mintypmax_expressionContext)
}

func (s *Constant_param_expressionContext) Data_type() IData_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IData_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IData_typeContext)
}

func (s *Constant_param_expressionContext) DOLLAR() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserDOLLAR, 0)
}

func (s *Constant_param_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constant_param_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constant_param_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterConstant_param_expression(s)
	}
}

func (s *Constant_param_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitConstant_param_expression(s)
	}
}

func (p *SystemVerilogParser) Constant_param_expression() (localctx IConstant_param_expressionContext) {
	this := p
	_ = this

	localctx = NewConstant_param_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1018, SystemVerilogParserRULE_constant_param_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(7219)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 899, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7216)
			p.Constant_mintypmax_expression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7217)
			p.Data_type()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7218)
			p.Match(SystemVerilogParserDOLLAR)
		}

	}

	return localctx
}

// IParam_expressionContext is an interface to support dynamic dispatch.
type IParam_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParam_expressionContext differentiates from other interfaces.
	IsParam_expressionContext()
}

type Param_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParam_expressionContext() *Param_expressionContext {
	var p = new(Param_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_param_expression
	return p
}

func (*Param_expressionContext) IsParam_expressionContext() {}

func NewParam_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Param_expressionContext {
	var p = new(Param_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_param_expression

	return p
}

func (s *Param_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Param_expressionContext) Mintypmax_expression() IMintypmax_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMintypmax_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMintypmax_expressionContext)
}

func (s *Param_expressionContext) Data_type() IData_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IData_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IData_typeContext)
}

func (s *Param_expressionContext) DOLLAR() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserDOLLAR, 0)
}

func (s *Param_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Param_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Param_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterParam_expression(s)
	}
}

func (s *Param_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitParam_expression(s)
	}
}

func (p *SystemVerilogParser) Param_expression() (localctx IParam_expressionContext) {
	this := p
	_ = this

	localctx = NewParam_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1020, SystemVerilogParserRULE_param_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(7224)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 900, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7221)
			p.Mintypmax_expression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7222)
			p.Data_type()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7223)
			p.Match(SystemVerilogParserDOLLAR)
		}

	}

	return localctx
}

// IConstant_range_expressionContext is an interface to support dynamic dispatch.
type IConstant_range_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstant_range_expressionContext differentiates from other interfaces.
	IsConstant_range_expressionContext()
}

type Constant_range_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstant_range_expressionContext() *Constant_range_expressionContext {
	var p = new(Constant_range_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_constant_range_expression
	return p
}

func (*Constant_range_expressionContext) IsConstant_range_expressionContext() {}

func NewConstant_range_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constant_range_expressionContext {
	var p = new(Constant_range_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_constant_range_expression

	return p
}

func (s *Constant_range_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Constant_range_expressionContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Constant_range_expressionContext) Constant_part_select_range() IConstant_part_select_rangeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_part_select_rangeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_part_select_rangeContext)
}

func (s *Constant_range_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constant_range_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constant_range_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterConstant_range_expression(s)
	}
}

func (s *Constant_range_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitConstant_range_expression(s)
	}
}

func (p *SystemVerilogParser) Constant_range_expression() (localctx IConstant_range_expressionContext) {
	this := p
	_ = this

	localctx = NewConstant_range_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1022, SystemVerilogParserRULE_constant_range_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(7228)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 901, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7226)
			p.constant_expression(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7227)
			p.Constant_part_select_range()
		}

	}

	return localctx
}

// IConstant_part_select_rangeContext is an interface to support dynamic dispatch.
type IConstant_part_select_rangeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstant_part_select_rangeContext differentiates from other interfaces.
	IsConstant_part_select_rangeContext()
}

type Constant_part_select_rangeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstant_part_select_rangeContext() *Constant_part_select_rangeContext {
	var p = new(Constant_part_select_rangeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_constant_part_select_range
	return p
}

func (*Constant_part_select_rangeContext) IsConstant_part_select_rangeContext() {}

func NewConstant_part_select_rangeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constant_part_select_rangeContext {
	var p = new(Constant_part_select_rangeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_constant_part_select_range

	return p
}

func (s *Constant_part_select_rangeContext) GetParser() antlr.Parser { return s.parser }

func (s *Constant_part_select_rangeContext) Constant_range() IConstant_rangeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_rangeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_rangeContext)
}

func (s *Constant_part_select_rangeContext) Constant_indexed_range() IConstant_indexed_rangeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_indexed_rangeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_indexed_rangeContext)
}

func (s *Constant_part_select_rangeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constant_part_select_rangeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constant_part_select_rangeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterConstant_part_select_range(s)
	}
}

func (s *Constant_part_select_rangeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitConstant_part_select_range(s)
	}
}

func (p *SystemVerilogParser) Constant_part_select_range() (localctx IConstant_part_select_rangeContext) {
	this := p
	_ = this

	localctx = NewConstant_part_select_rangeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1024, SystemVerilogParserRULE_constant_part_select_range)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(7232)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 902, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7230)
			p.Constant_range()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7231)
			p.Constant_indexed_range()
		}

	}

	return localctx
}

// IConstant_rangeContext is an interface to support dynamic dispatch.
type IConstant_rangeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstant_rangeContext differentiates from other interfaces.
	IsConstant_rangeContext()
}

type Constant_rangeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstant_rangeContext() *Constant_rangeContext {
	var p = new(Constant_rangeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_constant_range
	return p
}

func (*Constant_rangeContext) IsConstant_rangeContext() {}

func NewConstant_rangeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constant_rangeContext {
	var p = new(Constant_rangeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_constant_range

	return p
}

func (s *Constant_rangeContext) GetParser() antlr.Parser { return s.parser }

func (s *Constant_rangeContext) AllConstant_expression() []IConstant_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem())
	var tst = make([]IConstant_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConstant_expressionContext)
		}
	}

	return tst
}

func (s *Constant_rangeContext) Constant_expression(i int) IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Constant_rangeContext) COLON() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOLON, 0)
}

func (s *Constant_rangeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constant_rangeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constant_rangeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterConstant_range(s)
	}
}

func (s *Constant_rangeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitConstant_range(s)
	}
}

func (p *SystemVerilogParser) Constant_range() (localctx IConstant_rangeContext) {
	this := p
	_ = this

	localctx = NewConstant_rangeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1026, SystemVerilogParserRULE_constant_range)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7234)
		p.constant_expression(0)
	}
	{
		p.SetState(7235)
		p.Match(SystemVerilogParserCOLON)
	}
	{
		p.SetState(7236)
		p.constant_expression(0)
	}

	return localctx
}

// IConstant_indexed_rangeContext is an interface to support dynamic dispatch.
type IConstant_indexed_rangeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstant_indexed_rangeContext differentiates from other interfaces.
	IsConstant_indexed_rangeContext()
}

type Constant_indexed_rangeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstant_indexed_rangeContext() *Constant_indexed_rangeContext {
	var p = new(Constant_indexed_rangeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_constant_indexed_range
	return p
}

func (*Constant_indexed_rangeContext) IsConstant_indexed_rangeContext() {}

func NewConstant_indexed_rangeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constant_indexed_rangeContext {
	var p = new(Constant_indexed_rangeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_constant_indexed_range

	return p
}

func (s *Constant_indexed_rangeContext) GetParser() antlr.Parser { return s.parser }

func (s *Constant_indexed_rangeContext) AllConstant_expression() []IConstant_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem())
	var tst = make([]IConstant_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConstant_expressionContext)
		}
	}

	return tst
}

func (s *Constant_indexed_rangeContext) Constant_expression(i int) IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Constant_indexed_rangeContext) PLUSCOLON() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserPLUSCOLON, 0)
}

func (s *Constant_indexed_rangeContext) MCOLON() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserMCOLON, 0)
}

func (s *Constant_indexed_rangeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constant_indexed_rangeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constant_indexed_rangeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterConstant_indexed_range(s)
	}
}

func (s *Constant_indexed_rangeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitConstant_indexed_range(s)
	}
}

func (p *SystemVerilogParser) Constant_indexed_range() (localctx IConstant_indexed_rangeContext) {
	this := p
	_ = this

	localctx = NewConstant_indexed_rangeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1028, SystemVerilogParserRULE_constant_indexed_range)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7238)
		p.constant_expression(0)
	}
	{
		p.SetState(7239)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SystemVerilogParserMCOLON || _la == SystemVerilogParserPLUSCOLON) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(7240)
		p.constant_expression(0)
	}

	return localctx
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_expression
	return p
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) Primary() IPrimaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimaryContext)
}

func (s *ExpressionContext) Unary_operator() IUnary_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnary_operatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnary_operatorContext)
}

func (s *ExpressionContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *ExpressionContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *ExpressionContext) Inc_or_dec_expression() IInc_or_dec_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInc_or_dec_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInc_or_dec_expressionContext)
}

func (s *ExpressionContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *ExpressionContext) Variable_lvalue() IVariable_lvalueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_lvalueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_lvalueContext)
}

func (s *ExpressionContext) Assignment_operator() IAssignment_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignment_operatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignment_operatorContext)
}

func (s *ExpressionContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *ExpressionContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *ExpressionContext) KTAGGED() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKTAGGED, 0)
}

func (s *ExpressionContext) Member_identifier() IMember_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMember_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMember_identifierContext)
}

func (s *ExpressionContext) Binary_operator() IBinary_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBinary_operatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBinary_operatorContext)
}

func (s *ExpressionContext) QUES() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserQUES, 0)
}

func (s *ExpressionContext) COLON() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOLON, 0)
}

func (s *ExpressionContext) AllANDANDAND() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserANDANDAND)
}

func (s *ExpressionContext) ANDANDAND(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserANDANDAND, i)
}

func (s *ExpressionContext) KINSIDE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKINSIDE, 0)
}

func (s *ExpressionContext) AllOpen_range_list() []IOpen_range_listContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOpen_range_listContext)(nil)).Elem())
	var tst = make([]IOpen_range_listContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOpen_range_listContext)
		}
	}

	return tst
}

func (s *ExpressionContext) Open_range_list(i int) IOpen_range_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOpen_range_listContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOpen_range_listContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterExpression(s)
	}
}

func (s *ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitExpression(s)
	}
}

func (p *SystemVerilogParser) Expression() (localctx IExpressionContext) {
	return p.expression(0)
}

func (p *SystemVerilogParser) expression(_p int) (localctx IExpressionContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 1030
	p.EnterRecursionRule(localctx, 1030, SystemVerilogParserRULE_expression, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(7265)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 906, p.GetParserRuleContext()) {
	case 1:
		p.SetState(7250)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SystemVerilogParserMINUS)|(1<<SystemVerilogParserNOT)|(1<<SystemVerilogParserAND))) != 0) || (((_la-53)&-(0x1f+1)) == 0 && ((1<<uint((_la-53)))&((1<<(SystemVerilogParserCARET-53))|(1<<(SystemVerilogParserCARETSQUIG-53))|(1<<(SystemVerilogParserBAR-53))|(1<<(SystemVerilogParserSQUIG-53))|(1<<(SystemVerilogParserSQUIGAND-53))|(1<<(SystemVerilogParserSQUIGCARET-53))|(1<<(SystemVerilogParserSQUIGBAR-53))|(1<<(SystemVerilogParserPLUS-53)))) != 0) {
			{
				p.SetState(7243)
				p.Unary_operator()
			}
			p.SetState(7247)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SystemVerilogParserLPS {
				{
					p.SetState(7244)
					p.Attribute_instance()
				}

				p.SetState(7249)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(7252)
			p.Primary()
		}

	case 2:
		{
			p.SetState(7253)
			p.Inc_or_dec_expression()
		}

	case 3:
		{
			p.SetState(7254)
			p.Match(SystemVerilogParserLP)
		}
		{
			p.SetState(7255)
			p.Variable_lvalue()
		}
		{
			p.SetState(7256)
			p.Assignment_operator()
		}
		{
			p.SetState(7257)
			p.expression(0)
		}
		{
			p.SetState(7258)
			p.Match(SystemVerilogParserRP)
		}

	case 4:
		{
			p.SetState(7260)
			p.Match(SystemVerilogParserKTAGGED)
		}
		{
			p.SetState(7261)
			p.Member_identifier()
		}
		p.SetState(7263)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 905, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7262)
				p.expression(0)
			}

		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(7306)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 912, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(7304)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 911, p.GetParserRuleContext()) {
			case 1:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SystemVerilogParserRULE_expression)
				p.SetState(7267)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
				}
				{
					p.SetState(7268)
					p.Binary_operator()
				}
				p.SetState(7272)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				for _la == SystemVerilogParserLPS {
					{
						p.SetState(7269)
						p.Attribute_instance()
					}

					p.SetState(7274)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(7275)
					p.expression(5)
				}

			case 2:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SystemVerilogParserRULE_expression)
				p.SetState(7277)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				}
				p.SetState(7282)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				for _la == SystemVerilogParserANDANDAND {
					{
						p.SetState(7278)
						p.Match(SystemVerilogParserANDANDAND)
					}
					{
						p.SetState(7279)
						p.expression(0)
					}

					p.SetState(7284)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(7285)
					p.Match(SystemVerilogParserQUES)
				}
				p.SetState(7289)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				for _la == SystemVerilogParserLPS {
					{
						p.SetState(7286)
						p.Attribute_instance()
					}

					p.SetState(7291)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(7292)
					p.expression(0)
				}
				{
					p.SetState(7293)
					p.Match(SystemVerilogParserCOLON)
				}
				{
					p.SetState(7294)
					p.expression(4)
				}

			case 3:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SystemVerilogParserRULE_expression)
				p.SetState(7296)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(7297)
					p.Match(SystemVerilogParserKINSIDE)
				}
				p.SetState(7301)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 910, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(7298)
							p.Open_range_list()
						}

					}
					p.SetState(7303)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 910, p.GetParserRuleContext())
				}

			}

		}
		p.SetState(7308)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 912, p.GetParserRuleContext())
	}

	return localctx
}

// IValue_rangeContext is an interface to support dynamic dispatch.
type IValue_rangeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsValue_rangeContext differentiates from other interfaces.
	IsValue_rangeContext()
}

type Value_rangeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValue_rangeContext() *Value_rangeContext {
	var p = new(Value_rangeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_value_range
	return p
}

func (*Value_rangeContext) IsValue_rangeContext() {}

func NewValue_rangeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Value_rangeContext {
	var p = new(Value_rangeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_value_range

	return p
}

func (s *Value_rangeContext) GetParser() antlr.Parser { return s.parser }

func (s *Value_rangeContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *Value_rangeContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Value_rangeContext) LB() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLB, 0)
}

func (s *Value_rangeContext) COLON() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOLON, 0)
}

func (s *Value_rangeContext) RB() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRB, 0)
}

func (s *Value_rangeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Value_rangeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Value_rangeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterValue_range(s)
	}
}

func (s *Value_rangeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitValue_range(s)
	}
}

func (p *SystemVerilogParser) Value_range() (localctx IValue_rangeContext) {
	this := p
	_ = this

	localctx = NewValue_rangeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1032, SystemVerilogParserRULE_value_range)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(7316)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserMINUS, SystemVerilogParserMINUSMINS, SystemVerilogParserNOT, SystemVerilogParserDOLLAR, SystemVerilogParserDROOT, SystemVerilogParserDUNIT, SystemVerilogParserAND, SystemVerilogParserLP, SystemVerilogParserQUOTE, SystemVerilogParserCARET, SystemVerilogParserCARETSQUIG, SystemVerilogParserLC, SystemVerilogParserBAR, SystemVerilogParserSQUIG, SystemVerilogParserSQUIGAND, SystemVerilogParserSQUIGCARET, SystemVerilogParserSQUIGBAR, SystemVerilogParserPLUS, SystemVerilogParserPLUSPLUS, SystemVerilogParserKBIT, SystemVerilogParserKBYTE, SystemVerilogParserKCONST, SystemVerilogParserKINT, SystemVerilogParserKINTEGER, SystemVerilogParserKLOCAL, SystemVerilogParserKLOGIC, SystemVerilogParserKLONGINT, SystemVerilogParserKNULL, SystemVerilogParserKRANDOMIZE, SystemVerilogParserKREAL, SystemVerilogParserKREALTIME, SystemVerilogParserKREG, SystemVerilogParserKSHORTINT, SystemVerilogParserKSHORTREAL, SystemVerilogParserKSIGNED, SystemVerilogParserKSTD, SystemVerilogParserKSTRING, SystemVerilogParserKSUPER, SystemVerilogParserKTAGGED, SystemVerilogParserKTHIS, SystemVerilogParserKTIME, SystemVerilogParserKTYPE, SystemVerilogParserKUNSIGNED, SystemVerilogParserTIME_LITERAL, SystemVerilogParserDECIMAL_NUMBER, SystemVerilogParserBINARY_NUMBER, SystemVerilogParserOCTAL_NUMBER, SystemVerilogParserHEX_NUMBER, SystemVerilogParserREAL_NUMBER, SystemVerilogParserUNSIGNED_NUMBER, SystemVerilogParserSTRING_LITERAL, SystemVerilogParserSIMPLE_IDENTIFIER, SystemVerilogParserSYSTEM_TF_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7309)
			p.expression(0)
		}

	case SystemVerilogParserLB:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7310)
			p.Match(SystemVerilogParserLB)
		}
		{
			p.SetState(7311)
			p.expression(0)
		}
		{
			p.SetState(7312)
			p.Match(SystemVerilogParserCOLON)
		}
		{
			p.SetState(7313)
			p.expression(0)
		}
		{
			p.SetState(7314)
			p.Match(SystemVerilogParserRB)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IMintypmax_expressionContext is an interface to support dynamic dispatch.
type IMintypmax_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMintypmax_expressionContext differentiates from other interfaces.
	IsMintypmax_expressionContext()
}

type Mintypmax_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMintypmax_expressionContext() *Mintypmax_expressionContext {
	var p = new(Mintypmax_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_mintypmax_expression
	return p
}

func (*Mintypmax_expressionContext) IsMintypmax_expressionContext() {}

func NewMintypmax_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Mintypmax_expressionContext {
	var p = new(Mintypmax_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_mintypmax_expression

	return p
}

func (s *Mintypmax_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Mintypmax_expressionContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *Mintypmax_expressionContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Mintypmax_expressionContext) AllCOLON() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOLON)
}

func (s *Mintypmax_expressionContext) COLON(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOLON, i)
}

func (s *Mintypmax_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Mintypmax_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Mintypmax_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterMintypmax_expression(s)
	}
}

func (s *Mintypmax_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitMintypmax_expression(s)
	}
}

func (p *SystemVerilogParser) Mintypmax_expression() (localctx IMintypmax_expressionContext) {
	this := p
	_ = this

	localctx = NewMintypmax_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1034, SystemVerilogParserRULE_mintypmax_expression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7318)
		p.expression(0)
	}
	p.SetState(7324)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserCOLON {
		{
			p.SetState(7319)
			p.Match(SystemVerilogParserCOLON)
		}
		{
			p.SetState(7320)
			p.expression(0)
		}
		{
			p.SetState(7321)
			p.Match(SystemVerilogParserCOLON)
		}
		{
			p.SetState(7322)
			p.expression(0)
		}

	}

	return localctx
}

// IModule_path_expressionContext is an interface to support dynamic dispatch.
type IModule_path_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModule_path_expressionContext differentiates from other interfaces.
	IsModule_path_expressionContext()
}

type Module_path_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModule_path_expressionContext() *Module_path_expressionContext {
	var p = new(Module_path_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_module_path_expression
	return p
}

func (*Module_path_expressionContext) IsModule_path_expressionContext() {}

func NewModule_path_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Module_path_expressionContext {
	var p = new(Module_path_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_module_path_expression

	return p
}

func (s *Module_path_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Module_path_expressionContext) Module_path_primary() IModule_path_primaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_path_primaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_path_primaryContext)
}

func (s *Module_path_expressionContext) Unary_module_path_operator() IUnary_module_path_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnary_module_path_operatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnary_module_path_operatorContext)
}

func (s *Module_path_expressionContext) AllAttribute_instance() []IAttribute_instanceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem())
	var tst = make([]IAttribute_instanceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_instanceContext)
		}
	}

	return tst
}

func (s *Module_path_expressionContext) Attribute_instance(i int) IAttribute_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_instanceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_instanceContext)
}

func (s *Module_path_expressionContext) AllModule_path_expression() []IModule_path_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IModule_path_expressionContext)(nil)).Elem())
	var tst = make([]IModule_path_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IModule_path_expressionContext)
		}
	}

	return tst
}

func (s *Module_path_expressionContext) Module_path_expression(i int) IModule_path_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_path_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IModule_path_expressionContext)
}

func (s *Module_path_expressionContext) Binary_module_path_operator() IBinary_module_path_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBinary_module_path_operatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBinary_module_path_operatorContext)
}

func (s *Module_path_expressionContext) QUES() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserQUES, 0)
}

func (s *Module_path_expressionContext) COLON() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOLON, 0)
}

func (s *Module_path_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Module_path_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Module_path_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterModule_path_expression(s)
	}
}

func (s *Module_path_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitModule_path_expression(s)
	}
}

func (p *SystemVerilogParser) Module_path_expression() (localctx IModule_path_expressionContext) {
	return p.module_path_expression(0)
}

func (p *SystemVerilogParser) module_path_expression(_p int) (localctx IModule_path_expressionContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewModule_path_expressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IModule_path_expressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 1036
	p.EnterRecursionRule(localctx, 1036, SystemVerilogParserRULE_module_path_expression, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(7334)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserNOT || _la == SystemVerilogParserAND || (((_la-53)&-(0x1f+1)) == 0 && ((1<<uint((_la-53)))&((1<<(SystemVerilogParserCARET-53))|(1<<(SystemVerilogParserCARETSQUIG-53))|(1<<(SystemVerilogParserBAR-53))|(1<<(SystemVerilogParserSQUIG-53))|(1<<(SystemVerilogParserSQUIGAND-53))|(1<<(SystemVerilogParserSQUIGCARET-53))|(1<<(SystemVerilogParserSQUIGBAR-53)))) != 0) {
		{
			p.SetState(7327)
			p.Unary_module_path_operator()
		}
		p.SetState(7331)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserLPS {
			{
				p.SetState(7328)
				p.Attribute_instance()
			}

			p.SetState(7333)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(7336)
		p.Module_path_primary()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(7362)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 920, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(7360)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 919, p.GetParserRuleContext()) {
			case 1:
				localctx = NewModule_path_expressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SystemVerilogParserRULE_module_path_expression)
				p.SetState(7338)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(7339)
					p.Binary_module_path_operator()
				}
				p.SetState(7343)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				for _la == SystemVerilogParserLPS {
					{
						p.SetState(7340)
						p.Attribute_instance()
					}

					p.SetState(7345)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(7346)
					p.module_path_expression(3)
				}

			case 2:
				localctx = NewModule_path_expressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SystemVerilogParserRULE_module_path_expression)
				p.SetState(7348)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				}
				{
					p.SetState(7349)
					p.Match(SystemVerilogParserQUES)
				}
				p.SetState(7353)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				for _la == SystemVerilogParserLPS {
					{
						p.SetState(7350)
						p.Attribute_instance()
					}

					p.SetState(7355)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(7356)
					p.module_path_expression(0)
				}
				{
					p.SetState(7357)
					p.Match(SystemVerilogParserCOLON)
				}
				{
					p.SetState(7358)
					p.module_path_expression(2)
				}

			}

		}
		p.SetState(7364)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 920, p.GetParserRuleContext())
	}

	return localctx
}

// IModule_path_mintypmax_expressionContext is an interface to support dynamic dispatch.
type IModule_path_mintypmax_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModule_path_mintypmax_expressionContext differentiates from other interfaces.
	IsModule_path_mintypmax_expressionContext()
}

type Module_path_mintypmax_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModule_path_mintypmax_expressionContext() *Module_path_mintypmax_expressionContext {
	var p = new(Module_path_mintypmax_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_module_path_mintypmax_expression
	return p
}

func (*Module_path_mintypmax_expressionContext) IsModule_path_mintypmax_expressionContext() {}

func NewModule_path_mintypmax_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Module_path_mintypmax_expressionContext {
	var p = new(Module_path_mintypmax_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_module_path_mintypmax_expression

	return p
}

func (s *Module_path_mintypmax_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Module_path_mintypmax_expressionContext) AllModule_path_expression() []IModule_path_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IModule_path_expressionContext)(nil)).Elem())
	var tst = make([]IModule_path_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IModule_path_expressionContext)
		}
	}

	return tst
}

func (s *Module_path_mintypmax_expressionContext) Module_path_expression(i int) IModule_path_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_path_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IModule_path_expressionContext)
}

func (s *Module_path_mintypmax_expressionContext) AllCOLON() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOLON)
}

func (s *Module_path_mintypmax_expressionContext) COLON(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOLON, i)
}

func (s *Module_path_mintypmax_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Module_path_mintypmax_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Module_path_mintypmax_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterModule_path_mintypmax_expression(s)
	}
}

func (s *Module_path_mintypmax_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitModule_path_mintypmax_expression(s)
	}
}

func (p *SystemVerilogParser) Module_path_mintypmax_expression() (localctx IModule_path_mintypmax_expressionContext) {
	this := p
	_ = this

	localctx = NewModule_path_mintypmax_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1038, SystemVerilogParserRULE_module_path_mintypmax_expression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7365)
		p.module_path_expression(0)
	}
	p.SetState(7371)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserCOLON {
		{
			p.SetState(7366)
			p.Match(SystemVerilogParserCOLON)
		}
		{
			p.SetState(7367)
			p.module_path_expression(0)
		}
		{
			p.SetState(7368)
			p.Match(SystemVerilogParserCOLON)
		}
		{
			p.SetState(7369)
			p.module_path_expression(0)
		}

	}

	return localctx
}

// IPart_select_rangeContext is an interface to support dynamic dispatch.
type IPart_select_rangeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPart_select_rangeContext differentiates from other interfaces.
	IsPart_select_rangeContext()
}

type Part_select_rangeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPart_select_rangeContext() *Part_select_rangeContext {
	var p = new(Part_select_rangeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_part_select_range
	return p
}

func (*Part_select_rangeContext) IsPart_select_rangeContext() {}

func NewPart_select_rangeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Part_select_rangeContext {
	var p = new(Part_select_rangeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_part_select_range

	return p
}

func (s *Part_select_rangeContext) GetParser() antlr.Parser { return s.parser }

func (s *Part_select_rangeContext) Constant_range() IConstant_rangeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_rangeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_rangeContext)
}

func (s *Part_select_rangeContext) Indexed_range() IIndexed_rangeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIndexed_rangeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIndexed_rangeContext)
}

func (s *Part_select_rangeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Part_select_rangeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Part_select_rangeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterPart_select_range(s)
	}
}

func (s *Part_select_rangeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitPart_select_range(s)
	}
}

func (p *SystemVerilogParser) Part_select_range() (localctx IPart_select_rangeContext) {
	this := p
	_ = this

	localctx = NewPart_select_rangeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1040, SystemVerilogParserRULE_part_select_range)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(7375)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 922, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7373)
			p.Constant_range()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7374)
			p.Indexed_range()
		}

	}

	return localctx
}

// IIndexed_rangeContext is an interface to support dynamic dispatch.
type IIndexed_rangeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIndexed_rangeContext differentiates from other interfaces.
	IsIndexed_rangeContext()
}

type Indexed_rangeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexed_rangeContext() *Indexed_rangeContext {
	var p = new(Indexed_rangeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_indexed_range
	return p
}

func (*Indexed_rangeContext) IsIndexed_rangeContext() {}

func NewIndexed_rangeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Indexed_rangeContext {
	var p = new(Indexed_rangeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_indexed_range

	return p
}

func (s *Indexed_rangeContext) GetParser() antlr.Parser { return s.parser }

func (s *Indexed_rangeContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Indexed_rangeContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Indexed_rangeContext) PLUSCOLON() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserPLUSCOLON, 0)
}

func (s *Indexed_rangeContext) MCOLON() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserMCOLON, 0)
}

func (s *Indexed_rangeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Indexed_rangeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Indexed_rangeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterIndexed_range(s)
	}
}

func (s *Indexed_rangeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitIndexed_range(s)
	}
}

func (p *SystemVerilogParser) Indexed_range() (localctx IIndexed_rangeContext) {
	this := p
	_ = this

	localctx = NewIndexed_rangeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1042, SystemVerilogParserRULE_indexed_range)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7377)
		p.expression(0)
	}
	{
		p.SetState(7378)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SystemVerilogParserMCOLON || _la == SystemVerilogParserPLUSCOLON) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(7379)
		p.constant_expression(0)
	}

	return localctx
}

// IGenvar_expressionContext is an interface to support dynamic dispatch.
type IGenvar_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenvar_expressionContext differentiates from other interfaces.
	IsGenvar_expressionContext()
}

type Genvar_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenvar_expressionContext() *Genvar_expressionContext {
	var p = new(Genvar_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_genvar_expression
	return p
}

func (*Genvar_expressionContext) IsGenvar_expressionContext() {}

func NewGenvar_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Genvar_expressionContext {
	var p = new(Genvar_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_genvar_expression

	return p
}

func (s *Genvar_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Genvar_expressionContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Genvar_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Genvar_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Genvar_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterGenvar_expression(s)
	}
}

func (s *Genvar_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitGenvar_expression(s)
	}
}

func (p *SystemVerilogParser) Genvar_expression() (localctx IGenvar_expressionContext) {
	this := p
	_ = this

	localctx = NewGenvar_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1044, SystemVerilogParserRULE_genvar_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7381)
		p.constant_expression(0)
	}

	return localctx
}

// IConstant_primaryContext is an interface to support dynamic dispatch.
type IConstant_primaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstant_primaryContext differentiates from other interfaces.
	IsConstant_primaryContext()
}

type Constant_primaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstant_primaryContext() *Constant_primaryContext {
	var p = new(Constant_primaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_constant_primary
	return p
}

func (*Constant_primaryContext) IsConstant_primaryContext() {}

func NewConstant_primaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constant_primaryContext {
	var p = new(Constant_primaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_constant_primary

	return p
}

func (s *Constant_primaryContext) GetParser() antlr.Parser { return s.parser }

func (s *Constant_primaryContext) Primary_literal() IPrimary_literalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimary_literalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimary_literalContext)
}

func (s *Constant_primaryContext) Constant_select() IConstant_selectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_selectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_selectContext)
}

func (s *Constant_primaryContext) Ps_parameter_identifier() IPs_parameter_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPs_parameter_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPs_parameter_identifierContext)
}

func (s *Constant_primaryContext) Formal_port_identifier() IFormal_port_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormal_port_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFormal_port_identifierContext)
}

func (s *Constant_primaryContext) Specparam_identifier() ISpecparam_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecparam_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpecparam_identifierContext)
}

func (s *Constant_primaryContext) Constant_concatenation() IConstant_concatenationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_concatenationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_concatenationContext)
}

func (s *Constant_primaryContext) Constant_multiple_concatenation() IConstant_multiple_concatenationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_multiple_concatenationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_multiple_concatenationContext)
}

func (s *Constant_primaryContext) LB() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLB, 0)
}

func (s *Constant_primaryContext) Constant_range_expression() IConstant_range_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_range_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_range_expressionContext)
}

func (s *Constant_primaryContext) RB() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRB, 0)
}

func (s *Constant_primaryContext) Genvar_identifier() IGenvar_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenvar_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenvar_identifierContext)
}

func (s *Constant_primaryContext) Enum_identifier() IEnum_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnum_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnum_identifierContext)
}

func (s *Constant_primaryContext) Package_scope() IPackage_scopeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackage_scopeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPackage_scopeContext)
}

func (s *Constant_primaryContext) Class_scope() IClass_scopeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_scopeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClass_scopeContext)
}

func (s *Constant_primaryContext) Constant_function_call() IConstant_function_callContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_function_callContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_function_callContext)
}

func (s *Constant_primaryContext) Constant_let_expression() IConstant_let_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_let_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_let_expressionContext)
}

func (s *Constant_primaryContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Constant_primaryContext) Constant_mintypmax_expression() IConstant_mintypmax_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_mintypmax_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_mintypmax_expressionContext)
}

func (s *Constant_primaryContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Constant_primaryContext) Constant_assignment_pattern_expression() IConstant_assignment_pattern_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_assignment_pattern_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_assignment_pattern_expressionContext)
}

func (s *Constant_primaryContext) Type_reference() IType_referenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_referenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_referenceContext)
}

func (s *Constant_primaryContext) KNULL() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKNULL, 0)
}

func (s *Constant_primaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constant_primaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constant_primaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterConstant_primary(s)
	}
}

func (s *Constant_primaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitConstant_primary(s)
	}
}

func (p *SystemVerilogParser) Constant_primary() (localctx IConstant_primaryContext) {
	this := p
	_ = this

	localctx = NewConstant_primaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1046, SystemVerilogParserRULE_constant_primary)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(7416)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 927, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7383)
			p.Primary_literal()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(7386)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 923, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(7384)
				p.Ps_parameter_identifier()
			}

		case 2:
			{
				p.SetState(7385)
				p.Formal_port_identifier()
			}

		}
		{
			p.SetState(7388)
			p.Constant_select()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(7393)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 924, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(7390)
				p.Specparam_identifier()
			}

		case 2:
			{
				p.SetState(7391)
				p.Constant_concatenation()
			}

		case 3:
			{
				p.SetState(7392)
				p.Constant_multiple_concatenation()
			}

		}
		p.SetState(7399)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 925, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7395)
				p.Match(SystemVerilogParserLB)
			}
			{
				p.SetState(7396)
				p.Constant_range_expression()
			}
			{
				p.SetState(7397)
				p.Match(SystemVerilogParserRB)
			}

		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7401)
			p.Genvar_identifier()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		p.SetState(7404)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 926, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7402)
				p.Package_scope()
			}

		} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 926, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(7403)
				p.Class_scope()
			}

		}
		{
			p.SetState(7406)
			p.Enum_identifier()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(7407)
			p.Constant_function_call()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(7408)
			p.Constant_let_expression()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(7409)
			p.Match(SystemVerilogParserLP)
		}
		{
			p.SetState(7410)
			p.Constant_mintypmax_expression()
		}
		{
			p.SetState(7411)
			p.Match(SystemVerilogParserRP)
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(7413)
			p.Constant_assignment_pattern_expression()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(7414)
			p.Type_reference()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(7415)
			p.Match(SystemVerilogParserKNULL)
		}

	}

	return localctx
}

// IModule_path_primaryContext is an interface to support dynamic dispatch.
type IModule_path_primaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModule_path_primaryContext differentiates from other interfaces.
	IsModule_path_primaryContext()
}

type Module_path_primaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModule_path_primaryContext() *Module_path_primaryContext {
	var p = new(Module_path_primaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_module_path_primary
	return p
}

func (*Module_path_primaryContext) IsModule_path_primaryContext() {}

func NewModule_path_primaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Module_path_primaryContext {
	var p = new(Module_path_primaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_module_path_primary

	return p
}

func (s *Module_path_primaryContext) GetParser() antlr.Parser { return s.parser }

func (s *Module_path_primaryContext) Number() INumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *Module_path_primaryContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Module_path_primaryContext) Module_path_concatenation() IModule_path_concatenationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_path_concatenationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_path_concatenationContext)
}

func (s *Module_path_primaryContext) Module_path_multiple_concatenation() IModule_path_multiple_concatenationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_path_multiple_concatenationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_path_multiple_concatenationContext)
}

func (s *Module_path_primaryContext) Function_subroutine_call() IFunction_subroutine_callContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_subroutine_callContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_subroutine_callContext)
}

func (s *Module_path_primaryContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *Module_path_primaryContext) Module_path_mintypmax_expression() IModule_path_mintypmax_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModule_path_mintypmax_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModule_path_mintypmax_expressionContext)
}

func (s *Module_path_primaryContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *Module_path_primaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Module_path_primaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Module_path_primaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterModule_path_primary(s)
	}
}

func (s *Module_path_primaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitModule_path_primary(s)
	}
}

func (p *SystemVerilogParser) Module_path_primary() (localctx IModule_path_primaryContext) {
	this := p
	_ = this

	localctx = NewModule_path_primaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1048, SystemVerilogParserRULE_module_path_primary)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(7427)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 928, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7418)
			p.Number()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7419)
			p.Identifier()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7420)
			p.Module_path_concatenation()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7421)
			p.Module_path_multiple_concatenation()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(7422)
			p.Function_subroutine_call()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(7423)
			p.Match(SystemVerilogParserLP)
		}
		{
			p.SetState(7424)
			p.Module_path_mintypmax_expression()
		}
		{
			p.SetState(7425)
			p.Match(SystemVerilogParserRP)
		}

	}

	return localctx
}

// IPrimaryContext is an interface to support dynamic dispatch.
type IPrimaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimaryContext differentiates from other interfaces.
	IsPrimaryContext()
}

type PrimaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryContext() *PrimaryContext {
	var p = new(PrimaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_primary
	return p
}

func (*PrimaryContext) IsPrimaryContext() {}

func NewPrimaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryContext {
	var p = new(PrimaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_primary

	return p
}

func (s *PrimaryContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryContext) Primary_literal() IPrimary_literalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimary_literalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimary_literalContext)
}

func (s *PrimaryContext) Hierarchical_identifier() IHierarchical_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_identifierContext)
}

func (s *PrimaryContext) Select_() ISelect_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelect_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelect_Context)
}

func (s *PrimaryContext) Class_qualifier() IClass_qualifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_qualifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClass_qualifierContext)
}

func (s *PrimaryContext) Package_scope() IPackage_scopeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackage_scopeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPackage_scopeContext)
}

func (s *PrimaryContext) Empty_unpacked_array_concatenation() IEmpty_unpacked_array_concatenationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEmpty_unpacked_array_concatenationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEmpty_unpacked_array_concatenationContext)
}

func (s *PrimaryContext) Concatenation() IConcatenationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConcatenationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConcatenationContext)
}

func (s *PrimaryContext) LB() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLB, 0)
}

func (s *PrimaryContext) Range_expression() IRange_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_expressionContext)
}

func (s *PrimaryContext) RB() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRB, 0)
}

func (s *PrimaryContext) Multiple_concatenation() IMultiple_concatenationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMultiple_concatenationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMultiple_concatenationContext)
}

func (s *PrimaryContext) Function_subroutine_call() IFunction_subroutine_callContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_subroutine_callContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_subroutine_callContext)
}

func (s *PrimaryContext) Let_expression() ILet_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILet_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILet_expressionContext)
}

func (s *PrimaryContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *PrimaryContext) Mintypmax_expression() IMintypmax_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMintypmax_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMintypmax_expressionContext)
}

func (s *PrimaryContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *PrimaryContext) Cast() ICastContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICastContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICastContext)
}

func (s *PrimaryContext) Assignment_pattern_expression() IAssignment_pattern_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignment_pattern_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignment_pattern_expressionContext)
}

func (s *PrimaryContext) Streaming_concatenation() IStreaming_concatenationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStreaming_concatenationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStreaming_concatenationContext)
}

func (s *PrimaryContext) Sequence_method_call() ISequence_method_callContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequence_method_callContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISequence_method_callContext)
}

func (s *PrimaryContext) KTHIS() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKTHIS, 0)
}

func (s *PrimaryContext) DOLLAR() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserDOLLAR, 0)
}

func (s *PrimaryContext) KNULL() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKNULL, 0)
}

func (s *PrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterPrimary(s)
	}
}

func (s *PrimaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitPrimary(s)
	}
}

func (p *SystemVerilogParser) Primary() (localctx IPrimaryContext) {
	this := p
	_ = this

	localctx = NewPrimaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1050, SystemVerilogParserRULE_primary)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(7465)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 932, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7429)
			p.Primary_literal()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(7432)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 929, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7430)
				p.Class_qualifier()
			}

		} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 929, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(7431)
				p.Package_scope()
			}

		}
		{
			p.SetState(7434)
			p.Hierarchical_identifier()
		}
		{
			p.SetState(7435)
			p.Select_()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7437)
			p.Empty_unpacked_array_concatenation()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7438)
			p.Concatenation()
		}
		p.SetState(7443)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 930, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7439)
				p.Match(SystemVerilogParserLB)
			}
			{
				p.SetState(7440)
				p.Range_expression()
			}
			{
				p.SetState(7441)
				p.Match(SystemVerilogParserRB)
			}

		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(7445)
			p.Multiple_concatenation()
		}
		p.SetState(7450)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 931, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7446)
				p.Match(SystemVerilogParserLB)
			}
			{
				p.SetState(7447)
				p.Range_expression()
			}
			{
				p.SetState(7448)
				p.Match(SystemVerilogParserRB)
			}

		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(7452)
			p.Function_subroutine_call()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(7453)
			p.Let_expression()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(7454)
			p.Match(SystemVerilogParserLP)
		}
		{
			p.SetState(7455)
			p.Mintypmax_expression()
		}
		{
			p.SetState(7456)
			p.Match(SystemVerilogParserRP)
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(7458)
			p.Cast()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(7459)
			p.Assignment_pattern_expression()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(7460)
			p.Streaming_concatenation()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(7461)
			p.Sequence_method_call()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(7462)
			p.Match(SystemVerilogParserKTHIS)
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(7463)
			p.Match(SystemVerilogParserDOLLAR)
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(7464)
			p.Match(SystemVerilogParserKNULL)
		}

	}

	return localctx
}

// IClass_qualifierContext is an interface to support dynamic dispatch.
type IClass_qualifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClass_qualifierContext differentiates from other interfaces.
	IsClass_qualifierContext()
}

type Class_qualifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClass_qualifierContext() *Class_qualifierContext {
	var p = new(Class_qualifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_class_qualifier
	return p
}

func (*Class_qualifierContext) IsClass_qualifierContext() {}

func NewClass_qualifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Class_qualifierContext {
	var p = new(Class_qualifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_class_qualifier

	return p
}

func (s *Class_qualifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Class_qualifierContext) KLOCAL() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKLOCAL, 0)
}

func (s *Class_qualifierContext) COLONCOLON() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOLONCOLON, 0)
}

func (s *Class_qualifierContext) Implicit_class_handle() IImplicit_class_handleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImplicit_class_handleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImplicit_class_handleContext)
}

func (s *Class_qualifierContext) DOT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserDOT, 0)
}

func (s *Class_qualifierContext) Class_scope() IClass_scopeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_scopeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClass_scopeContext)
}

func (s *Class_qualifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Class_qualifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Class_qualifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterClass_qualifier(s)
	}
}

func (s *Class_qualifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitClass_qualifier(s)
	}
}

func (p *SystemVerilogParser) Class_qualifier() (localctx IClass_qualifierContext) {
	this := p
	_ = this

	localctx = NewClass_qualifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1052, SystemVerilogParserRULE_class_qualifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(7469)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserKLOCAL {
		{
			p.SetState(7467)
			p.Match(SystemVerilogParserKLOCAL)
		}
		{
			p.SetState(7468)
			p.Match(SystemVerilogParserCOLONCOLON)
		}

	}
	p.SetState(7475)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 934, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(7471)
			p.Implicit_class_handle()
		}
		{
			p.SetState(7472)
			p.Match(SystemVerilogParserDOT)
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 934, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(7474)
			p.Class_scope()
		}

	}

	return localctx
}

// IRange_expressionContext is an interface to support dynamic dispatch.
type IRange_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRange_expressionContext differentiates from other interfaces.
	IsRange_expressionContext()
}

type Range_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRange_expressionContext() *Range_expressionContext {
	var p = new(Range_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_range_expression
	return p
}

func (*Range_expressionContext) IsRange_expressionContext() {}

func NewRange_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Range_expressionContext {
	var p = new(Range_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_range_expression

	return p
}

func (s *Range_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Range_expressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Range_expressionContext) Part_select_range() IPart_select_rangeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPart_select_rangeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPart_select_rangeContext)
}

func (s *Range_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Range_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Range_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterRange_expression(s)
	}
}

func (s *Range_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitRange_expression(s)
	}
}

func (p *SystemVerilogParser) Range_expression() (localctx IRange_expressionContext) {
	this := p
	_ = this

	localctx = NewRange_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1054, SystemVerilogParserRULE_range_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(7479)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 935, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7477)
			p.expression(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7478)
			p.Part_select_range()
		}

	}

	return localctx
}

// IPrimary_literalContext is an interface to support dynamic dispatch.
type IPrimary_literalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimary_literalContext differentiates from other interfaces.
	IsPrimary_literalContext()
}

type Primary_literalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimary_literalContext() *Primary_literalContext {
	var p = new(Primary_literalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_primary_literal
	return p
}

func (*Primary_literalContext) IsPrimary_literalContext() {}

func NewPrimary_literalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Primary_literalContext {
	var p = new(Primary_literalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_primary_literal

	return p
}

func (s *Primary_literalContext) GetParser() antlr.Parser { return s.parser }

func (s *Primary_literalContext) Number() INumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *Primary_literalContext) TIME_LITERAL() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserTIME_LITERAL, 0)
}

func (s *Primary_literalContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSTRING_LITERAL, 0)
}

func (s *Primary_literalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Primary_literalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Primary_literalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterPrimary_literal(s)
	}
}

func (s *Primary_literalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitPrimary_literal(s)
	}
}

func (p *SystemVerilogParser) Primary_literal() (localctx IPrimary_literalContext) {
	this := p
	_ = this

	localctx = NewPrimary_literalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1056, SystemVerilogParserRULE_primary_literal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(7484)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserDECIMAL_NUMBER, SystemVerilogParserBINARY_NUMBER, SystemVerilogParserOCTAL_NUMBER, SystemVerilogParserHEX_NUMBER, SystemVerilogParserREAL_NUMBER, SystemVerilogParserUNSIGNED_NUMBER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7481)
			p.Number()
		}

	case SystemVerilogParserTIME_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7482)
			p.Match(SystemVerilogParserTIME_LITERAL)
		}

	case SystemVerilogParserSTRING_LITERAL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7483)
			p.Match(SystemVerilogParserSTRING_LITERAL)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IImplicit_class_handleContext is an interface to support dynamic dispatch.
type IImplicit_class_handleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImplicit_class_handleContext differentiates from other interfaces.
	IsImplicit_class_handleContext()
}

type Implicit_class_handleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImplicit_class_handleContext() *Implicit_class_handleContext {
	var p = new(Implicit_class_handleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_implicit_class_handle
	return p
}

func (*Implicit_class_handleContext) IsImplicit_class_handleContext() {}

func NewImplicit_class_handleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Implicit_class_handleContext {
	var p = new(Implicit_class_handleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_implicit_class_handle

	return p
}

func (s *Implicit_class_handleContext) GetParser() antlr.Parser { return s.parser }

func (s *Implicit_class_handleContext) KTHIS() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKTHIS, 0)
}

func (s *Implicit_class_handleContext) DOT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserDOT, 0)
}

func (s *Implicit_class_handleContext) KSUPER() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKSUPER, 0)
}

func (s *Implicit_class_handleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Implicit_class_handleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Implicit_class_handleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterImplicit_class_handle(s)
	}
}

func (s *Implicit_class_handleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitImplicit_class_handle(s)
	}
}

func (p *SystemVerilogParser) Implicit_class_handle() (localctx IImplicit_class_handleContext) {
	this := p
	_ = this

	localctx = NewImplicit_class_handleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1058, SystemVerilogParserRULE_implicit_class_handle)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(7492)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserKTHIS:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7486)
			p.Match(SystemVerilogParserKTHIS)
		}
		p.SetState(7489)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 937, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7487)
				p.Match(SystemVerilogParserDOT)
			}
			{
				p.SetState(7488)
				p.Match(SystemVerilogParserKSUPER)
			}

		}

	case SystemVerilogParserKSUPER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7491)
			p.Match(SystemVerilogParserKSUPER)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IBit_selectContext is an interface to support dynamic dispatch.
type IBit_selectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBit_selectContext differentiates from other interfaces.
	IsBit_selectContext()
}

type Bit_selectContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBit_selectContext() *Bit_selectContext {
	var p = new(Bit_selectContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_bit_select
	return p
}

func (*Bit_selectContext) IsBit_selectContext() {}

func NewBit_selectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bit_selectContext {
	var p = new(Bit_selectContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_bit_select

	return p
}

func (s *Bit_selectContext) GetParser() antlr.Parser { return s.parser }

func (s *Bit_selectContext) AllLB() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserLB)
}

func (s *Bit_selectContext) LB(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLB, i)
}

func (s *Bit_selectContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *Bit_selectContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Bit_selectContext) AllRB() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserRB)
}

func (s *Bit_selectContext) RB(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRB, i)
}

func (s *Bit_selectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bit_selectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Bit_selectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterBit_select(s)
	}
}

func (s *Bit_selectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitBit_select(s)
	}
}

func (p *SystemVerilogParser) Bit_select() (localctx IBit_selectContext) {
	this := p
	_ = this

	localctx = NewBit_selectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1060, SystemVerilogParserRULE_bit_select)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(7500)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 939, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(7494)
				p.Match(SystemVerilogParserLB)
			}
			{
				p.SetState(7495)
				p.expression(0)
			}
			{
				p.SetState(7496)
				p.Match(SystemVerilogParserRB)
			}

		}
		p.SetState(7502)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 939, p.GetParserRuleContext())
	}

	return localctx
}

// ISelect_Context is an interface to support dynamic dispatch.
type ISelect_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelect_Context differentiates from other interfaces.
	IsSelect_Context()
}

type Select_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_Context() *Select_Context {
	var p = new(Select_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_select_
	return p
}

func (*Select_Context) IsSelect_Context() {}

func NewSelect_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_Context {
	var p = new(Select_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_select_

	return p
}

func (s *Select_Context) GetParser() antlr.Parser { return s.parser }

func (s *Select_Context) AllBit_select() []IBit_selectContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBit_selectContext)(nil)).Elem())
	var tst = make([]IBit_selectContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBit_selectContext)
		}
	}

	return tst
}

func (s *Select_Context) Bit_select(i int) IBit_selectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBit_selectContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBit_selectContext)
}

func (s *Select_Context) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserDOT)
}

func (s *Select_Context) DOT(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserDOT, i)
}

func (s *Select_Context) AllMember_identifier() []IMember_identifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMember_identifierContext)(nil)).Elem())
	var tst = make([]IMember_identifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMember_identifierContext)
		}
	}

	return tst
}

func (s *Select_Context) Member_identifier(i int) IMember_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMember_identifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMember_identifierContext)
}

func (s *Select_Context) LB() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLB, 0)
}

func (s *Select_Context) Part_select_range() IPart_select_rangeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPart_select_rangeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPart_select_rangeContext)
}

func (s *Select_Context) RB() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRB, 0)
}

func (s *Select_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Select_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterSelect_(s)
	}
}

func (s *Select_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitSelect_(s)
	}
}

func (p *SystemVerilogParser) Select_() (localctx ISelect_Context) {
	this := p
	_ = this

	localctx = NewSelect_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1062, SystemVerilogParserRULE_select_)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(7514)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 941, p.GetParserRuleContext()) == 1 {
		p.SetState(7509)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 940, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(7503)
					p.Match(SystemVerilogParserDOT)
				}
				{
					p.SetState(7504)
					p.Member_identifier()
				}
				{
					p.SetState(7505)
					p.Bit_select()
				}

			}
			p.SetState(7511)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 940, p.GetParserRuleContext())
		}
		{
			p.SetState(7512)
			p.Match(SystemVerilogParserDOT)
		}
		{
			p.SetState(7513)
			p.Member_identifier()
		}

	}
	{
		p.SetState(7516)
		p.Bit_select()
	}
	p.SetState(7521)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 942, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(7517)
			p.Match(SystemVerilogParserLB)
		}
		{
			p.SetState(7518)
			p.Part_select_range()
		}
		{
			p.SetState(7519)
			p.Match(SystemVerilogParserRB)
		}

	}

	return localctx
}

// INonrange_selectContext is an interface to support dynamic dispatch.
type INonrange_selectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNonrange_selectContext differentiates from other interfaces.
	IsNonrange_selectContext()
}

type Nonrange_selectContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNonrange_selectContext() *Nonrange_selectContext {
	var p = new(Nonrange_selectContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_nonrange_select
	return p
}

func (*Nonrange_selectContext) IsNonrange_selectContext() {}

func NewNonrange_selectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Nonrange_selectContext {
	var p = new(Nonrange_selectContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_nonrange_select

	return p
}

func (s *Nonrange_selectContext) GetParser() antlr.Parser { return s.parser }

func (s *Nonrange_selectContext) AllBit_select() []IBit_selectContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBit_selectContext)(nil)).Elem())
	var tst = make([]IBit_selectContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBit_selectContext)
		}
	}

	return tst
}

func (s *Nonrange_selectContext) Bit_select(i int) IBit_selectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBit_selectContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBit_selectContext)
}

func (s *Nonrange_selectContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserDOT)
}

func (s *Nonrange_selectContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserDOT, i)
}

func (s *Nonrange_selectContext) AllMember_identifier() []IMember_identifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMember_identifierContext)(nil)).Elem())
	var tst = make([]IMember_identifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMember_identifierContext)
		}
	}

	return tst
}

func (s *Nonrange_selectContext) Member_identifier(i int) IMember_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMember_identifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMember_identifierContext)
}

func (s *Nonrange_selectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Nonrange_selectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Nonrange_selectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterNonrange_select(s)
	}
}

func (s *Nonrange_selectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitNonrange_select(s)
	}
}

func (p *SystemVerilogParser) Nonrange_select() (localctx INonrange_selectContext) {
	this := p
	_ = this

	localctx = NewNonrange_selectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1064, SystemVerilogParserRULE_nonrange_select)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(7534)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserDOT {
		p.SetState(7529)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 943, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(7523)
					p.Match(SystemVerilogParserDOT)
				}
				{
					p.SetState(7524)
					p.Member_identifier()
				}
				{
					p.SetState(7525)
					p.Bit_select()
				}

			}
			p.SetState(7531)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 943, p.GetParserRuleContext())
		}
		{
			p.SetState(7532)
			p.Match(SystemVerilogParserDOT)
		}
		{
			p.SetState(7533)
			p.Member_identifier()
		}

	}
	{
		p.SetState(7536)
		p.Bit_select()
	}

	return localctx
}

// IConstant_bit_selectContext is an interface to support dynamic dispatch.
type IConstant_bit_selectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstant_bit_selectContext differentiates from other interfaces.
	IsConstant_bit_selectContext()
}

type Constant_bit_selectContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstant_bit_selectContext() *Constant_bit_selectContext {
	var p = new(Constant_bit_selectContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_constant_bit_select
	return p
}

func (*Constant_bit_selectContext) IsConstant_bit_selectContext() {}

func NewConstant_bit_selectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constant_bit_selectContext {
	var p = new(Constant_bit_selectContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_constant_bit_select

	return p
}

func (s *Constant_bit_selectContext) GetParser() antlr.Parser { return s.parser }

func (s *Constant_bit_selectContext) AllLB() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserLB)
}

func (s *Constant_bit_selectContext) LB(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLB, i)
}

func (s *Constant_bit_selectContext) AllConstant_expression() []IConstant_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem())
	var tst = make([]IConstant_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConstant_expressionContext)
		}
	}

	return tst
}

func (s *Constant_bit_selectContext) Constant_expression(i int) IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Constant_bit_selectContext) AllRB() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserRB)
}

func (s *Constant_bit_selectContext) RB(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRB, i)
}

func (s *Constant_bit_selectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constant_bit_selectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constant_bit_selectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterConstant_bit_select(s)
	}
}

func (s *Constant_bit_selectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitConstant_bit_select(s)
	}
}

func (p *SystemVerilogParser) Constant_bit_select() (localctx IConstant_bit_selectContext) {
	this := p
	_ = this

	localctx = NewConstant_bit_selectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1066, SystemVerilogParserRULE_constant_bit_select)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(7544)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 945, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(7538)
				p.Match(SystemVerilogParserLB)
			}
			{
				p.SetState(7539)
				p.constant_expression(0)
			}
			{
				p.SetState(7540)
				p.Match(SystemVerilogParserRB)
			}

		}
		p.SetState(7546)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 945, p.GetParserRuleContext())
	}

	return localctx
}

// IConstant_selectContext is an interface to support dynamic dispatch.
type IConstant_selectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstant_selectContext differentiates from other interfaces.
	IsConstant_selectContext()
}

type Constant_selectContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstant_selectContext() *Constant_selectContext {
	var p = new(Constant_selectContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_constant_select
	return p
}

func (*Constant_selectContext) IsConstant_selectContext() {}

func NewConstant_selectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constant_selectContext {
	var p = new(Constant_selectContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_constant_select

	return p
}

func (s *Constant_selectContext) GetParser() antlr.Parser { return s.parser }

func (s *Constant_selectContext) AllConstant_bit_select() []IConstant_bit_selectContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConstant_bit_selectContext)(nil)).Elem())
	var tst = make([]IConstant_bit_selectContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConstant_bit_selectContext)
		}
	}

	return tst
}

func (s *Constant_selectContext) Constant_bit_select(i int) IConstant_bit_selectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_bit_selectContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConstant_bit_selectContext)
}

func (s *Constant_selectContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserDOT)
}

func (s *Constant_selectContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserDOT, i)
}

func (s *Constant_selectContext) AllMember_identifier() []IMember_identifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMember_identifierContext)(nil)).Elem())
	var tst = make([]IMember_identifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMember_identifierContext)
		}
	}

	return tst
}

func (s *Constant_selectContext) Member_identifier(i int) IMember_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMember_identifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMember_identifierContext)
}

func (s *Constant_selectContext) LB() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLB, 0)
}

func (s *Constant_selectContext) Constant_part_select_range() IConstant_part_select_rangeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_part_select_rangeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_part_select_rangeContext)
}

func (s *Constant_selectContext) RB() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRB, 0)
}

func (s *Constant_selectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constant_selectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constant_selectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterConstant_select(s)
	}
}

func (s *Constant_selectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitConstant_select(s)
	}
}

func (p *SystemVerilogParser) Constant_select() (localctx IConstant_selectContext) {
	this := p
	_ = this

	localctx = NewConstant_selectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1068, SystemVerilogParserRULE_constant_select)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(7558)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 947, p.GetParserRuleContext()) == 1 {
		p.SetState(7553)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 946, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(7547)
					p.Match(SystemVerilogParserDOT)
				}
				{
					p.SetState(7548)
					p.Member_identifier()
				}
				{
					p.SetState(7549)
					p.Constant_bit_select()
				}

			}
			p.SetState(7555)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 946, p.GetParserRuleContext())
		}
		{
			p.SetState(7556)
			p.Match(SystemVerilogParserDOT)
		}
		{
			p.SetState(7557)
			p.Member_identifier()
		}

	}
	{
		p.SetState(7560)
		p.Constant_bit_select()
	}
	p.SetState(7565)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 948, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(7561)
			p.Match(SystemVerilogParserLB)
		}
		{
			p.SetState(7562)
			p.Constant_part_select_range()
		}
		{
			p.SetState(7563)
			p.Match(SystemVerilogParserRB)
		}

	}

	return localctx
}

// IConstant_let_expressionContext is an interface to support dynamic dispatch.
type IConstant_let_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstant_let_expressionContext differentiates from other interfaces.
	IsConstant_let_expressionContext()
}

type Constant_let_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstant_let_expressionContext() *Constant_let_expressionContext {
	var p = new(Constant_let_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_constant_let_expression
	return p
}

func (*Constant_let_expressionContext) IsConstant_let_expressionContext() {}

func NewConstant_let_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constant_let_expressionContext {
	var p = new(Constant_let_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_constant_let_expression

	return p
}

func (s *Constant_let_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Constant_let_expressionContext) Let_expression() ILet_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILet_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILet_expressionContext)
}

func (s *Constant_let_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constant_let_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constant_let_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterConstant_let_expression(s)
	}
}

func (s *Constant_let_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitConstant_let_expression(s)
	}
}

func (p *SystemVerilogParser) Constant_let_expression() (localctx IConstant_let_expressionContext) {
	this := p
	_ = this

	localctx = NewConstant_let_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1070, SystemVerilogParserRULE_constant_let_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7567)
		p.Let_expression()
	}

	return localctx
}

// ICastContext is an interface to support dynamic dispatch.
type ICastContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCastContext differentiates from other interfaces.
	IsCastContext()
}

type CastContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCastContext() *CastContext {
	var p = new(CastContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_cast
	return p
}

func (*CastContext) IsCastContext() {}

func NewCastContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CastContext {
	var p = new(CastContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_cast

	return p
}

func (s *CastContext) GetParser() antlr.Parser { return s.parser }

func (s *CastContext) Casting_type() ICasting_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICasting_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICasting_typeContext)
}

func (s *CastContext) QUOTE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserQUOTE, 0)
}

func (s *CastContext) LP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLP, 0)
}

func (s *CastContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CastContext) RP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRP, 0)
}

func (s *CastContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CastContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterCast(s)
	}
}

func (s *CastContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitCast(s)
	}
}

func (p *SystemVerilogParser) Cast() (localctx ICastContext) {
	this := p
	_ = this

	localctx = NewCastContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1072, SystemVerilogParserRULE_cast)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7569)
		p.Casting_type()
	}
	{
		p.SetState(7570)
		p.Match(SystemVerilogParserQUOTE)
	}
	{
		p.SetState(7571)
		p.Match(SystemVerilogParserLP)
	}
	{
		p.SetState(7572)
		p.expression(0)
	}
	{
		p.SetState(7573)
		p.Match(SystemVerilogParserRP)
	}

	return localctx
}

// INet_lvalueContext is an interface to support dynamic dispatch.
type INet_lvalueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNet_lvalueContext differentiates from other interfaces.
	IsNet_lvalueContext()
}

type Net_lvalueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNet_lvalueContext() *Net_lvalueContext {
	var p = new(Net_lvalueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_net_lvalue
	return p
}

func (*Net_lvalueContext) IsNet_lvalueContext() {}

func NewNet_lvalueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Net_lvalueContext {
	var p = new(Net_lvalueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_net_lvalue

	return p
}

func (s *Net_lvalueContext) GetParser() antlr.Parser { return s.parser }

func (s *Net_lvalueContext) Ps_or_hierarchical_net_identifier() IPs_or_hierarchical_net_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPs_or_hierarchical_net_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPs_or_hierarchical_net_identifierContext)
}

func (s *Net_lvalueContext) Constant_select() IConstant_selectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_selectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_selectContext)
}

func (s *Net_lvalueContext) LC() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLC, 0)
}

func (s *Net_lvalueContext) AllNet_lvalue() []INet_lvalueContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INet_lvalueContext)(nil)).Elem())
	var tst = make([]INet_lvalueContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INet_lvalueContext)
		}
	}

	return tst
}

func (s *Net_lvalueContext) Net_lvalue(i int) INet_lvalueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_lvalueContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INet_lvalueContext)
}

func (s *Net_lvalueContext) RC() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRC, 0)
}

func (s *Net_lvalueContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *Net_lvalueContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *Net_lvalueContext) Assignment_pattern_net_lvalue() IAssignment_pattern_net_lvalueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignment_pattern_net_lvalueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignment_pattern_net_lvalueContext)
}

func (s *Net_lvalueContext) Assignment_pattern_expression_type() IAssignment_pattern_expression_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignment_pattern_expression_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignment_pattern_expression_typeContext)
}

func (s *Net_lvalueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Net_lvalueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Net_lvalueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterNet_lvalue(s)
	}
}

func (s *Net_lvalueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitNet_lvalue(s)
	}
}

func (p *SystemVerilogParser) Net_lvalue() (localctx INet_lvalueContext) {
	this := p
	_ = this

	localctx = NewNet_lvalueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1074, SystemVerilogParserRULE_net_lvalue)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(7593)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 951, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7575)
			p.Ps_or_hierarchical_net_identifier()
		}
		{
			p.SetState(7576)
			p.Constant_select()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7578)
			p.Match(SystemVerilogParserLC)
		}
		{
			p.SetState(7579)
			p.Net_lvalue()
		}
		p.SetState(7584)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserCOMMA {
			{
				p.SetState(7580)
				p.Match(SystemVerilogParserCOMMA)
			}
			{
				p.SetState(7581)
				p.Net_lvalue()
			}

			p.SetState(7586)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(7587)
			p.Match(SystemVerilogParserRC)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(7590)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserDUNIT || _la == SystemVerilogParserKBYTE || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SystemVerilogParserKINT-195))|(1<<(SystemVerilogParserKINTEGER-195))|(1<<(SystemVerilogParserKLOCAL-195))|(1<<(SystemVerilogParserKLONGINT-195)))) != 0) || _la == SystemVerilogParserKSHORTINT || _la == SystemVerilogParserKTIME || _la == SystemVerilogParserKTYPE || _la == SystemVerilogParserSIMPLE_IDENTIFIER {
			{
				p.SetState(7589)
				p.Assignment_pattern_expression_type()
			}

		}
		{
			p.SetState(7592)
			p.Assignment_pattern_net_lvalue()
		}

	}

	return localctx
}

// IVariable_lvalueContext is an interface to support dynamic dispatch.
type IVariable_lvalueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariable_lvalueContext differentiates from other interfaces.
	IsVariable_lvalueContext()
}

type Variable_lvalueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariable_lvalueContext() *Variable_lvalueContext {
	var p = new(Variable_lvalueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_variable_lvalue
	return p
}

func (*Variable_lvalueContext) IsVariable_lvalueContext() {}

func NewVariable_lvalueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Variable_lvalueContext {
	var p = new(Variable_lvalueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_variable_lvalue

	return p
}

func (s *Variable_lvalueContext) GetParser() antlr.Parser { return s.parser }

func (s *Variable_lvalueContext) Hierarchical_variable_identifier() IHierarchical_variable_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_variable_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_variable_identifierContext)
}

func (s *Variable_lvalueContext) Select_() ISelect_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelect_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelect_Context)
}

func (s *Variable_lvalueContext) Implicit_class_handle() IImplicit_class_handleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImplicit_class_handleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImplicit_class_handleContext)
}

func (s *Variable_lvalueContext) DOT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserDOT, 0)
}

func (s *Variable_lvalueContext) Package_scope() IPackage_scopeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackage_scopeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPackage_scopeContext)
}

func (s *Variable_lvalueContext) LC() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLC, 0)
}

func (s *Variable_lvalueContext) AllVariable_lvalue() []IVariable_lvalueContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariable_lvalueContext)(nil)).Elem())
	var tst = make([]IVariable_lvalueContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariable_lvalueContext)
		}
	}

	return tst
}

func (s *Variable_lvalueContext) Variable_lvalue(i int) IVariable_lvalueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_lvalueContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariable_lvalueContext)
}

func (s *Variable_lvalueContext) RC() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRC, 0)
}

func (s *Variable_lvalueContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *Variable_lvalueContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *Variable_lvalueContext) Assignment_pattern_variable_lvalue() IAssignment_pattern_variable_lvalueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignment_pattern_variable_lvalueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignment_pattern_variable_lvalueContext)
}

func (s *Variable_lvalueContext) Assignment_pattern_expression_type() IAssignment_pattern_expression_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignment_pattern_expression_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignment_pattern_expression_typeContext)
}

func (s *Variable_lvalueContext) Streaming_concatenation() IStreaming_concatenationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStreaming_concatenationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStreaming_concatenationContext)
}

func (s *Variable_lvalueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Variable_lvalueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Variable_lvalueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterVariable_lvalue(s)
	}
}

func (s *Variable_lvalueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitVariable_lvalue(s)
	}
}

func (p *SystemVerilogParser) Variable_lvalue() (localctx IVariable_lvalueContext) {
	this := p
	_ = this

	localctx = NewVariable_lvalueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1076, SystemVerilogParserRULE_variable_lvalue)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(7620)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 955, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(7599)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 952, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7595)
				p.Implicit_class_handle()
			}
			{
				p.SetState(7596)
				p.Match(SystemVerilogParserDOT)
			}

		} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 952, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(7598)
				p.Package_scope()
			}

		}
		{
			p.SetState(7601)
			p.Hierarchical_variable_identifier()
		}
		{
			p.SetState(7602)
			p.Select_()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7604)
			p.Match(SystemVerilogParserLC)
		}
		{
			p.SetState(7605)
			p.Variable_lvalue()
		}
		p.SetState(7610)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SystemVerilogParserCOMMA {
			{
				p.SetState(7606)
				p.Match(SystemVerilogParserCOMMA)
			}
			{
				p.SetState(7607)
				p.Variable_lvalue()
			}

			p.SetState(7612)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(7613)
			p.Match(SystemVerilogParserRC)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(7616)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SystemVerilogParserDUNIT || _la == SystemVerilogParserKBYTE || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SystemVerilogParserKINT-195))|(1<<(SystemVerilogParserKINTEGER-195))|(1<<(SystemVerilogParserKLOCAL-195))|(1<<(SystemVerilogParserKLONGINT-195)))) != 0) || _la == SystemVerilogParserKSHORTINT || _la == SystemVerilogParserKTIME || _la == SystemVerilogParserKTYPE || _la == SystemVerilogParserSIMPLE_IDENTIFIER {
			{
				p.SetState(7615)
				p.Assignment_pattern_expression_type()
			}

		}
		{
			p.SetState(7618)
			p.Assignment_pattern_variable_lvalue()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7619)
			p.Streaming_concatenation()
		}

	}

	return localctx
}

// INonrange_variable_lvalueContext is an interface to support dynamic dispatch.
type INonrange_variable_lvalueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNonrange_variable_lvalueContext differentiates from other interfaces.
	IsNonrange_variable_lvalueContext()
}

type Nonrange_variable_lvalueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNonrange_variable_lvalueContext() *Nonrange_variable_lvalueContext {
	var p = new(Nonrange_variable_lvalueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_nonrange_variable_lvalue
	return p
}

func (*Nonrange_variable_lvalueContext) IsNonrange_variable_lvalueContext() {}

func NewNonrange_variable_lvalueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Nonrange_variable_lvalueContext {
	var p = new(Nonrange_variable_lvalueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_nonrange_variable_lvalue

	return p
}

func (s *Nonrange_variable_lvalueContext) GetParser() antlr.Parser { return s.parser }

func (s *Nonrange_variable_lvalueContext) Hierarchical_variable_identifier() IHierarchical_variable_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_variable_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_variable_identifierContext)
}

func (s *Nonrange_variable_lvalueContext) Nonrange_select() INonrange_selectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INonrange_selectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INonrange_selectContext)
}

func (s *Nonrange_variable_lvalueContext) Implicit_class_handle() IImplicit_class_handleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImplicit_class_handleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImplicit_class_handleContext)
}

func (s *Nonrange_variable_lvalueContext) DOT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserDOT, 0)
}

func (s *Nonrange_variable_lvalueContext) Package_scope() IPackage_scopeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackage_scopeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPackage_scopeContext)
}

func (s *Nonrange_variable_lvalueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Nonrange_variable_lvalueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Nonrange_variable_lvalueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterNonrange_variable_lvalue(s)
	}
}

func (s *Nonrange_variable_lvalueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitNonrange_variable_lvalue(s)
	}
}

func (p *SystemVerilogParser) Nonrange_variable_lvalue() (localctx INonrange_variable_lvalueContext) {
	this := p
	_ = this

	localctx = NewNonrange_variable_lvalueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1078, SystemVerilogParserRULE_nonrange_variable_lvalue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(7626)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 956, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(7622)
			p.Implicit_class_handle()
		}
		{
			p.SetState(7623)
			p.Match(SystemVerilogParserDOT)
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 956, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(7625)
			p.Package_scope()
		}

	}
	{
		p.SetState(7628)
		p.Hierarchical_variable_identifier()
	}
	{
		p.SetState(7629)
		p.Nonrange_select()
	}

	return localctx
}

// IUnary_operatorContext is an interface to support dynamic dispatch.
type IUnary_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnary_operatorContext differentiates from other interfaces.
	IsUnary_operatorContext()
}

type Unary_operatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnary_operatorContext() *Unary_operatorContext {
	var p = new(Unary_operatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_unary_operator
	return p
}

func (*Unary_operatorContext) IsUnary_operatorContext() {}

func NewUnary_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unary_operatorContext {
	var p = new(Unary_operatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_unary_operator

	return p
}

func (s *Unary_operatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Unary_operatorContext) PLUS() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserPLUS, 0)
}

func (s *Unary_operatorContext) MINUS() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserMINUS, 0)
}

func (s *Unary_operatorContext) NOT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserNOT, 0)
}

func (s *Unary_operatorContext) SQUIG() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSQUIG, 0)
}

func (s *Unary_operatorContext) AND() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserAND, 0)
}

func (s *Unary_operatorContext) SQUIGAND() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSQUIGAND, 0)
}

func (s *Unary_operatorContext) BAR() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserBAR, 0)
}

func (s *Unary_operatorContext) SQUIGBAR() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSQUIGBAR, 0)
}

func (s *Unary_operatorContext) CARET() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCARET, 0)
}

func (s *Unary_operatorContext) SQUIGCARET() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSQUIGCARET, 0)
}

func (s *Unary_operatorContext) CARETSQUIG() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCARETSQUIG, 0)
}

func (s *Unary_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unary_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Unary_operatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterUnary_operator(s)
	}
}

func (s *Unary_operatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitUnary_operator(s)
	}
}

func (p *SystemVerilogParser) Unary_operator() (localctx IUnary_operatorContext) {
	this := p
	_ = this

	localctx = NewUnary_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1080, SystemVerilogParserRULE_unary_operator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7631)
		_la = p.GetTokenStream().LA(1)

		if !((((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SystemVerilogParserMINUS)|(1<<SystemVerilogParserNOT)|(1<<SystemVerilogParserAND))) != 0) || (((_la-53)&-(0x1f+1)) == 0 && ((1<<uint((_la-53)))&((1<<(SystemVerilogParserCARET-53))|(1<<(SystemVerilogParserCARETSQUIG-53))|(1<<(SystemVerilogParserBAR-53))|(1<<(SystemVerilogParserSQUIG-53))|(1<<(SystemVerilogParserSQUIGAND-53))|(1<<(SystemVerilogParserSQUIGCARET-53))|(1<<(SystemVerilogParserSQUIGBAR-53))|(1<<(SystemVerilogParserPLUS-53)))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IBinary_operatorContext is an interface to support dynamic dispatch.
type IBinary_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBinary_operatorContext differentiates from other interfaces.
	IsBinary_operatorContext()
}

type Binary_operatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBinary_operatorContext() *Binary_operatorContext {
	var p = new(Binary_operatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_binary_operator
	return p
}

func (*Binary_operatorContext) IsBinary_operatorContext() {}

func NewBinary_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Binary_operatorContext {
	var p = new(Binary_operatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_binary_operator

	return p
}

func (s *Binary_operatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Binary_operatorContext) PLUS() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserPLUS, 0)
}

func (s *Binary_operatorContext) MINUS() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserMINUS, 0)
}

func (s *Binary_operatorContext) STAR() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSTAR, 0)
}

func (s *Binary_operatorContext) SLASH() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSLASH, 0)
}

func (s *Binary_operatorContext) PER() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserPER, 0)
}

func (s *Binary_operatorContext) EQEQ() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserEQEQ, 0)
}

func (s *Binary_operatorContext) NE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserNE, 0)
}

func (s *Binary_operatorContext) EQEQEQ() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserEQEQEQ, 0)
}

func (s *Binary_operatorContext) NEE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserNEE, 0)
}

func (s *Binary_operatorContext) EQEQQUEST() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserEQEQQUEST, 0)
}

func (s *Binary_operatorContext) NEQ() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserNEQ, 0)
}

func (s *Binary_operatorContext) ANDAND() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserANDAND, 0)
}

func (s *Binary_operatorContext) BARBAR() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserBARBAR, 0)
}

func (s *Binary_operatorContext) SS() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSS, 0)
}

func (s *Binary_operatorContext) LT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLT, 0)
}

func (s *Binary_operatorContext) LTEQ() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLTEQ, 0)
}

func (s *Binary_operatorContext) GT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserGT, 0)
}

func (s *Binary_operatorContext) GE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserGE, 0)
}

func (s *Binary_operatorContext) AND() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserAND, 0)
}

func (s *Binary_operatorContext) BAR() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserBAR, 0)
}

func (s *Binary_operatorContext) CARET() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCARET, 0)
}

func (s *Binary_operatorContext) SQUIGCARET() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSQUIGCARET, 0)
}

func (s *Binary_operatorContext) CARETSQUIG() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCARETSQUIG, 0)
}

func (s *Binary_operatorContext) GTGT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserGTGT, 0)
}

func (s *Binary_operatorContext) LTLT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLTLT, 0)
}

func (s *Binary_operatorContext) GTGTGT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserGTGTGT, 0)
}

func (s *Binary_operatorContext) LTLTLT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLTLTLT, 0)
}

func (s *Binary_operatorContext) ARROW() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserARROW, 0)
}

func (s *Binary_operatorContext) LTMINUSGT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLTMINUSGT, 0)
}

func (s *Binary_operatorContext) PLUSPLUS() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserPLUSPLUS, 0)
}

func (s *Binary_operatorContext) MINUSMINS() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserMINUSMINS, 0)
}

func (s *Binary_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Binary_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Binary_operatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterBinary_operator(s)
	}
}

func (s *Binary_operatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitBinary_operator(s)
	}
}

func (p *SystemVerilogParser) Binary_operator() (localctx IBinary_operatorContext) {
	this := p
	_ = this

	localctx = NewBinary_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1082, SystemVerilogParserRULE_binary_operator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7633)
		_la = p.GetTokenStream().LA(1)

		if !((((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SystemVerilogParserMINUS)|(1<<SystemVerilogParserMINUSMINS)|(1<<SystemVerilogParserNE)|(1<<SystemVerilogParserNEQ)|(1<<SystemVerilogParserNEE)|(1<<SystemVerilogParserPER)|(1<<SystemVerilogParserAND)|(1<<SystemVerilogParserANDAND)|(1<<SystemVerilogParserSTAR))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(SystemVerilogParserSS-32))|(1<<(SystemVerilogParserSLASH-32))|(1<<(SystemVerilogParserCARET-32))|(1<<(SystemVerilogParserCARETSQUIG-32))|(1<<(SystemVerilogParserBAR-32))|(1<<(SystemVerilogParserBARBAR-32)))) != 0) || (((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(SystemVerilogParserSQUIGCARET-65))|(1<<(SystemVerilogParserPLUS-65))|(1<<(SystemVerilogParserPLUSPLUS-65))|(1<<(SystemVerilogParserLT-65))|(1<<(SystemVerilogParserLTLT-65))|(1<<(SystemVerilogParserLTLTLT-65))|(1<<(SystemVerilogParserLTEQ-65))|(1<<(SystemVerilogParserLTMINUSGT-65))|(1<<(SystemVerilogParserEQEQ-65))|(1<<(SystemVerilogParserEQEQQUEST-65))|(1<<(SystemVerilogParserEQEQEQ-65))|(1<<(SystemVerilogParserGT-65))|(1<<(SystemVerilogParserARROW-65))|(1<<(SystemVerilogParserGE-65))|(1<<(SystemVerilogParserGTGT-65))|(1<<(SystemVerilogParserGTGTGT-65)))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IInc_or_dec_operatorContext is an interface to support dynamic dispatch.
type IInc_or_dec_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInc_or_dec_operatorContext differentiates from other interfaces.
	IsInc_or_dec_operatorContext()
}

type Inc_or_dec_operatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInc_or_dec_operatorContext() *Inc_or_dec_operatorContext {
	var p = new(Inc_or_dec_operatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_inc_or_dec_operator
	return p
}

func (*Inc_or_dec_operatorContext) IsInc_or_dec_operatorContext() {}

func NewInc_or_dec_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Inc_or_dec_operatorContext {
	var p = new(Inc_or_dec_operatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_inc_or_dec_operator

	return p
}

func (s *Inc_or_dec_operatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Inc_or_dec_operatorContext) PLUSPLUS() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserPLUSPLUS, 0)
}

func (s *Inc_or_dec_operatorContext) MINUSMINS() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserMINUSMINS, 0)
}

func (s *Inc_or_dec_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Inc_or_dec_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Inc_or_dec_operatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterInc_or_dec_operator(s)
	}
}

func (s *Inc_or_dec_operatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitInc_or_dec_operator(s)
	}
}

func (p *SystemVerilogParser) Inc_or_dec_operator() (localctx IInc_or_dec_operatorContext) {
	this := p
	_ = this

	localctx = NewInc_or_dec_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1084, SystemVerilogParserRULE_inc_or_dec_operator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7635)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SystemVerilogParserMINUSMINS || _la == SystemVerilogParserPLUSPLUS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IUnary_module_path_operatorContext is an interface to support dynamic dispatch.
type IUnary_module_path_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnary_module_path_operatorContext differentiates from other interfaces.
	IsUnary_module_path_operatorContext()
}

type Unary_module_path_operatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnary_module_path_operatorContext() *Unary_module_path_operatorContext {
	var p = new(Unary_module_path_operatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_unary_module_path_operator
	return p
}

func (*Unary_module_path_operatorContext) IsUnary_module_path_operatorContext() {}

func NewUnary_module_path_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unary_module_path_operatorContext {
	var p = new(Unary_module_path_operatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_unary_module_path_operator

	return p
}

func (s *Unary_module_path_operatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Unary_module_path_operatorContext) NOT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserNOT, 0)
}

func (s *Unary_module_path_operatorContext) SQUIG() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSQUIG, 0)
}

func (s *Unary_module_path_operatorContext) AND() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserAND, 0)
}

func (s *Unary_module_path_operatorContext) SQUIGAND() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSQUIGAND, 0)
}

func (s *Unary_module_path_operatorContext) BAR() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserBAR, 0)
}

func (s *Unary_module_path_operatorContext) SQUIGBAR() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSQUIGBAR, 0)
}

func (s *Unary_module_path_operatorContext) CARET() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCARET, 0)
}

func (s *Unary_module_path_operatorContext) SQUIGCARET() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSQUIGCARET, 0)
}

func (s *Unary_module_path_operatorContext) CARETSQUIG() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCARETSQUIG, 0)
}

func (s *Unary_module_path_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unary_module_path_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Unary_module_path_operatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterUnary_module_path_operator(s)
	}
}

func (s *Unary_module_path_operatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitUnary_module_path_operator(s)
	}
}

func (p *SystemVerilogParser) Unary_module_path_operator() (localctx IUnary_module_path_operatorContext) {
	this := p
	_ = this

	localctx = NewUnary_module_path_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1086, SystemVerilogParserRULE_unary_module_path_operator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7637)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SystemVerilogParserNOT || _la == SystemVerilogParserAND || (((_la-53)&-(0x1f+1)) == 0 && ((1<<uint((_la-53)))&((1<<(SystemVerilogParserCARET-53))|(1<<(SystemVerilogParserCARETSQUIG-53))|(1<<(SystemVerilogParserBAR-53))|(1<<(SystemVerilogParserSQUIG-53))|(1<<(SystemVerilogParserSQUIGAND-53))|(1<<(SystemVerilogParserSQUIGCARET-53))|(1<<(SystemVerilogParserSQUIGBAR-53)))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IBinary_module_path_operatorContext is an interface to support dynamic dispatch.
type IBinary_module_path_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBinary_module_path_operatorContext differentiates from other interfaces.
	IsBinary_module_path_operatorContext()
}

type Binary_module_path_operatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBinary_module_path_operatorContext() *Binary_module_path_operatorContext {
	var p = new(Binary_module_path_operatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_binary_module_path_operator
	return p
}

func (*Binary_module_path_operatorContext) IsBinary_module_path_operatorContext() {}

func NewBinary_module_path_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Binary_module_path_operatorContext {
	var p = new(Binary_module_path_operatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_binary_module_path_operator

	return p
}

func (s *Binary_module_path_operatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Binary_module_path_operatorContext) EQEQ() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserEQEQ, 0)
}

func (s *Binary_module_path_operatorContext) NE() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserNE, 0)
}

func (s *Binary_module_path_operatorContext) ANDAND() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserANDAND, 0)
}

func (s *Binary_module_path_operatorContext) BARBAR() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserBARBAR, 0)
}

func (s *Binary_module_path_operatorContext) AND() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserAND, 0)
}

func (s *Binary_module_path_operatorContext) BAR() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserBAR, 0)
}

func (s *Binary_module_path_operatorContext) CARET() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCARET, 0)
}

func (s *Binary_module_path_operatorContext) CARETSQUIG() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCARETSQUIG, 0)
}

func (s *Binary_module_path_operatorContext) SQUIGCARET() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSQUIGCARET, 0)
}

func (s *Binary_module_path_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Binary_module_path_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Binary_module_path_operatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterBinary_module_path_operator(s)
	}
}

func (s *Binary_module_path_operatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitBinary_module_path_operator(s)
	}
}

func (p *SystemVerilogParser) Binary_module_path_operator() (localctx IBinary_module_path_operatorContext) {
	this := p
	_ = this

	localctx = NewBinary_module_path_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1088, SystemVerilogParserRULE_binary_module_path_operator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7639)
		_la = p.GetTokenStream().LA(1)

		if !((((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SystemVerilogParserNE)|(1<<SystemVerilogParserAND)|(1<<SystemVerilogParserANDAND))) != 0) || (((_la-53)&-(0x1f+1)) == 0 && ((1<<uint((_la-53)))&((1<<(SystemVerilogParserCARET-53))|(1<<(SystemVerilogParserCARETSQUIG-53))|(1<<(SystemVerilogParserBAR-53))|(1<<(SystemVerilogParserBARBAR-53))|(1<<(SystemVerilogParserSQUIGCARET-53))|(1<<(SystemVerilogParserEQEQ-53)))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// INumberContext is an interface to support dynamic dispatch.
type INumberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNumberContext differentiates from other interfaces.
	IsNumberContext()
}

type NumberContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumberContext() *NumberContext {
	var p = new(NumberContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_number
	return p
}

func (*NumberContext) IsNumberContext() {}

func NewNumberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumberContext {
	var p = new(NumberContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_number

	return p
}

func (s *NumberContext) GetParser() antlr.Parser { return s.parser }

func (s *NumberContext) DECIMAL_NUMBER() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserDECIMAL_NUMBER, 0)
}

func (s *NumberContext) UNSIGNED_NUMBER() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserUNSIGNED_NUMBER, 0)
}

func (s *NumberContext) OCTAL_NUMBER() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserOCTAL_NUMBER, 0)
}

func (s *NumberContext) BINARY_NUMBER() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserBINARY_NUMBER, 0)
}

func (s *NumberContext) HEX_NUMBER() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserHEX_NUMBER, 0)
}

func (s *NumberContext) REAL_NUMBER() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserREAL_NUMBER, 0)
}

func (s *NumberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NumberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterNumber(s)
	}
}

func (s *NumberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitNumber(s)
	}
}

func (p *SystemVerilogParser) Number() (localctx INumberContext) {
	this := p
	_ = this

	localctx = NewNumberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1090, SystemVerilogParserRULE_number)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7641)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-346)&-(0x1f+1)) == 0 && ((1<<uint((_la-346)))&((1<<(SystemVerilogParserDECIMAL_NUMBER-346))|(1<<(SystemVerilogParserBINARY_NUMBER-346))|(1<<(SystemVerilogParserOCTAL_NUMBER-346))|(1<<(SystemVerilogParserHEX_NUMBER-346))|(1<<(SystemVerilogParserREAL_NUMBER-346))|(1<<(SystemVerilogParserUNSIGNED_NUMBER-346)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IAttribute_instanceContext is an interface to support dynamic dispatch.
type IAttribute_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttribute_instanceContext differentiates from other interfaces.
	IsAttribute_instanceContext()
}

type Attribute_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttribute_instanceContext() *Attribute_instanceContext {
	var p = new(Attribute_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_attribute_instance
	return p
}

func (*Attribute_instanceContext) IsAttribute_instanceContext() {}

func NewAttribute_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Attribute_instanceContext {
	var p = new(Attribute_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_attribute_instance

	return p
}

func (s *Attribute_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *Attribute_instanceContext) LPS() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLPS, 0)
}

func (s *Attribute_instanceContext) AllAttr_spec() []IAttr_specContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttr_specContext)(nil)).Elem())
	var tst = make([]IAttr_specContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttr_specContext)
		}
	}

	return tst
}

func (s *Attribute_instanceContext) Attr_spec(i int) IAttr_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttr_specContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttr_specContext)
}

func (s *Attribute_instanceContext) SRP() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSRP, 0)
}

func (s *Attribute_instanceContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserCOMMA)
}

func (s *Attribute_instanceContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOMMA, i)
}

func (s *Attribute_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Attribute_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Attribute_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterAttribute_instance(s)
	}
}

func (s *Attribute_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitAttribute_instance(s)
	}
}

func (p *SystemVerilogParser) Attribute_instance() (localctx IAttribute_instanceContext) {
	this := p
	_ = this

	localctx = NewAttribute_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1092, SystemVerilogParserRULE_attribute_instance)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7643)
		p.Match(SystemVerilogParserLPS)
	}
	{
		p.SetState(7644)
		p.Attr_spec()
	}
	p.SetState(7649)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SystemVerilogParserCOMMA {
		{
			p.SetState(7645)
			p.Match(SystemVerilogParserCOMMA)
		}
		{
			p.SetState(7646)
			p.Attr_spec()
		}

		p.SetState(7651)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(7652)
		p.Match(SystemVerilogParserSRP)
	}

	return localctx
}

// IAttr_specContext is an interface to support dynamic dispatch.
type IAttr_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttr_specContext differentiates from other interfaces.
	IsAttr_specContext()
}

type Attr_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttr_specContext() *Attr_specContext {
	var p = new(Attr_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_attr_spec
	return p
}

func (*Attr_specContext) IsAttr_specContext() {}

func NewAttr_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Attr_specContext {
	var p = new(Attr_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_attr_spec

	return p
}

func (s *Attr_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Attr_specContext) Attr_name() IAttr_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttr_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttr_nameContext)
}

func (s *Attr_specContext) EQ() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserEQ, 0)
}

func (s *Attr_specContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Attr_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Attr_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Attr_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterAttr_spec(s)
	}
}

func (s *Attr_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitAttr_spec(s)
	}
}

func (p *SystemVerilogParser) Attr_spec() (localctx IAttr_specContext) {
	this := p
	_ = this

	localctx = NewAttr_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1094, SystemVerilogParserRULE_attr_spec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7654)
		p.Attr_name()
	}
	p.SetState(7657)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserEQ {
		{
			p.SetState(7655)
			p.Match(SystemVerilogParserEQ)
		}
		{
			p.SetState(7656)
			p.constant_expression(0)
		}

	}

	return localctx
}

// IAttr_nameContext is an interface to support dynamic dispatch.
type IAttr_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttr_nameContext differentiates from other interfaces.
	IsAttr_nameContext()
}

type Attr_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttr_nameContext() *Attr_nameContext {
	var p = new(Attr_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_attr_name
	return p
}

func (*Attr_nameContext) IsAttr_nameContext() {}

func NewAttr_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Attr_nameContext {
	var p = new(Attr_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_attr_name

	return p
}

func (s *Attr_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Attr_nameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Attr_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Attr_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Attr_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterAttr_name(s)
	}
}

func (s *Attr_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitAttr_name(s)
	}
}

func (p *SystemVerilogParser) Attr_name() (localctx IAttr_nameContext) {
	this := p
	_ = this

	localctx = NewAttr_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1096, SystemVerilogParserRULE_attr_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7659)
		p.Identifier()
	}

	return localctx
}

// IArray_identifierContext is an interface to support dynamic dispatch.
type IArray_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArray_identifierContext differentiates from other interfaces.
	IsArray_identifierContext()
}

type Array_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArray_identifierContext() *Array_identifierContext {
	var p = new(Array_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_array_identifier
	return p
}

func (*Array_identifierContext) IsArray_identifierContext() {}

func NewArray_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Array_identifierContext {
	var p = new(Array_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_array_identifier

	return p
}

func (s *Array_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Array_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Array_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Array_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Array_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterArray_identifier(s)
	}
}

func (s *Array_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitArray_identifier(s)
	}
}

func (p *SystemVerilogParser) Array_identifier() (localctx IArray_identifierContext) {
	this := p
	_ = this

	localctx = NewArray_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1098, SystemVerilogParserRULE_array_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7661)
		p.Identifier()
	}

	return localctx
}

// IBlock_identifierContext is an interface to support dynamic dispatch.
type IBlock_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlock_identifierContext differentiates from other interfaces.
	IsBlock_identifierContext()
}

type Block_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlock_identifierContext() *Block_identifierContext {
	var p = new(Block_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_block_identifier
	return p
}

func (*Block_identifierContext) IsBlock_identifierContext() {}

func NewBlock_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Block_identifierContext {
	var p = new(Block_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_block_identifier

	return p
}

func (s *Block_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Block_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Block_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Block_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Block_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterBlock_identifier(s)
	}
}

func (s *Block_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitBlock_identifier(s)
	}
}

func (p *SystemVerilogParser) Block_identifier() (localctx IBlock_identifierContext) {
	this := p
	_ = this

	localctx = NewBlock_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1100, SystemVerilogParserRULE_block_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7663)
		p.Identifier()
	}

	return localctx
}

// IBin_identifierContext is an interface to support dynamic dispatch.
type IBin_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBin_identifierContext differentiates from other interfaces.
	IsBin_identifierContext()
}

type Bin_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBin_identifierContext() *Bin_identifierContext {
	var p = new(Bin_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_bin_identifier
	return p
}

func (*Bin_identifierContext) IsBin_identifierContext() {}

func NewBin_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bin_identifierContext {
	var p = new(Bin_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_bin_identifier

	return p
}

func (s *Bin_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Bin_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Bin_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bin_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Bin_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterBin_identifier(s)
	}
}

func (s *Bin_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitBin_identifier(s)
	}
}

func (p *SystemVerilogParser) Bin_identifier() (localctx IBin_identifierContext) {
	this := p
	_ = this

	localctx = NewBin_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1102, SystemVerilogParserRULE_bin_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7665)
		p.Identifier()
	}

	return localctx
}

// IC_identifierContext is an interface to support dynamic dispatch.
type IC_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsC_identifierContext differentiates from other interfaces.
	IsC_identifierContext()
}

type C_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyC_identifierContext() *C_identifierContext {
	var p = new(C_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_c_identifier
	return p
}

func (*C_identifierContext) IsC_identifierContext() {}

func NewC_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *C_identifierContext {
	var p = new(C_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_c_identifier

	return p
}

func (s *C_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *C_identifierContext) SIMPLE_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSIMPLE_IDENTIFIER, 0)
}

func (s *C_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *C_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *C_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterC_identifier(s)
	}
}

func (s *C_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitC_identifier(s)
	}
}

func (p *SystemVerilogParser) C_identifier() (localctx IC_identifierContext) {
	this := p
	_ = this

	localctx = NewC_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1104, SystemVerilogParserRULE_c_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7667)
		p.Match(SystemVerilogParserSIMPLE_IDENTIFIER)
	}

	return localctx
}

// ICell_identifierContext is an interface to support dynamic dispatch.
type ICell_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCell_identifierContext differentiates from other interfaces.
	IsCell_identifierContext()
}

type Cell_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCell_identifierContext() *Cell_identifierContext {
	var p = new(Cell_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_cell_identifier
	return p
}

func (*Cell_identifierContext) IsCell_identifierContext() {}

func NewCell_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cell_identifierContext {
	var p = new(Cell_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_cell_identifier

	return p
}

func (s *Cell_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Cell_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Cell_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cell_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cell_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterCell_identifier(s)
	}
}

func (s *Cell_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitCell_identifier(s)
	}
}

func (p *SystemVerilogParser) Cell_identifier() (localctx ICell_identifierContext) {
	this := p
	_ = this

	localctx = NewCell_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1106, SystemVerilogParserRULE_cell_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7669)
		p.Identifier()
	}

	return localctx
}

// IChecker_identifierContext is an interface to support dynamic dispatch.
type IChecker_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsChecker_identifierContext differentiates from other interfaces.
	IsChecker_identifierContext()
}

type Checker_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChecker_identifierContext() *Checker_identifierContext {
	var p = new(Checker_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_checker_identifier
	return p
}

func (*Checker_identifierContext) IsChecker_identifierContext() {}

func NewChecker_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Checker_identifierContext {
	var p = new(Checker_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_checker_identifier

	return p
}

func (s *Checker_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Checker_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Checker_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Checker_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Checker_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterChecker_identifier(s)
	}
}

func (s *Checker_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitChecker_identifier(s)
	}
}

func (p *SystemVerilogParser) Checker_identifier() (localctx IChecker_identifierContext) {
	this := p
	_ = this

	localctx = NewChecker_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1108, SystemVerilogParserRULE_checker_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7671)
		p.Identifier()
	}

	return localctx
}

// IClass_identifierContext is an interface to support dynamic dispatch.
type IClass_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClass_identifierContext differentiates from other interfaces.
	IsClass_identifierContext()
}

type Class_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClass_identifierContext() *Class_identifierContext {
	var p = new(Class_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_class_identifier
	return p
}

func (*Class_identifierContext) IsClass_identifierContext() {}

func NewClass_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Class_identifierContext {
	var p = new(Class_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_class_identifier

	return p
}

func (s *Class_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Class_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Class_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Class_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Class_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterClass_identifier(s)
	}
}

func (s *Class_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitClass_identifier(s)
	}
}

func (p *SystemVerilogParser) Class_identifier() (localctx IClass_identifierContext) {
	this := p
	_ = this

	localctx = NewClass_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1110, SystemVerilogParserRULE_class_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7673)
		p.Identifier()
	}

	return localctx
}

// IClass_variable_identifierContext is an interface to support dynamic dispatch.
type IClass_variable_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClass_variable_identifierContext differentiates from other interfaces.
	IsClass_variable_identifierContext()
}

type Class_variable_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClass_variable_identifierContext() *Class_variable_identifierContext {
	var p = new(Class_variable_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_class_variable_identifier
	return p
}

func (*Class_variable_identifierContext) IsClass_variable_identifierContext() {}

func NewClass_variable_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Class_variable_identifierContext {
	var p = new(Class_variable_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_class_variable_identifier

	return p
}

func (s *Class_variable_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Class_variable_identifierContext) Variable_identifier() IVariable_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_identifierContext)
}

func (s *Class_variable_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Class_variable_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Class_variable_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterClass_variable_identifier(s)
	}
}

func (s *Class_variable_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitClass_variable_identifier(s)
	}
}

func (p *SystemVerilogParser) Class_variable_identifier() (localctx IClass_variable_identifierContext) {
	this := p
	_ = this

	localctx = NewClass_variable_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1112, SystemVerilogParserRULE_class_variable_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7675)
		p.Variable_identifier()
	}

	return localctx
}

// IClocking_identifierContext is an interface to support dynamic dispatch.
type IClocking_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClocking_identifierContext differentiates from other interfaces.
	IsClocking_identifierContext()
}

type Clocking_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClocking_identifierContext() *Clocking_identifierContext {
	var p = new(Clocking_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_clocking_identifier
	return p
}

func (*Clocking_identifierContext) IsClocking_identifierContext() {}

func NewClocking_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Clocking_identifierContext {
	var p = new(Clocking_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_clocking_identifier

	return p
}

func (s *Clocking_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Clocking_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Clocking_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Clocking_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Clocking_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterClocking_identifier(s)
	}
}

func (s *Clocking_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitClocking_identifier(s)
	}
}

func (p *SystemVerilogParser) Clocking_identifier() (localctx IClocking_identifierContext) {
	this := p
	_ = this

	localctx = NewClocking_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1114, SystemVerilogParserRULE_clocking_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7677)
		p.Identifier()
	}

	return localctx
}

// IConfig_identifierContext is an interface to support dynamic dispatch.
type IConfig_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConfig_identifierContext differentiates from other interfaces.
	IsConfig_identifierContext()
}

type Config_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConfig_identifierContext() *Config_identifierContext {
	var p = new(Config_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_config_identifier
	return p
}

func (*Config_identifierContext) IsConfig_identifierContext() {}

func NewConfig_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Config_identifierContext {
	var p = new(Config_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_config_identifier

	return p
}

func (s *Config_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Config_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Config_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Config_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Config_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterConfig_identifier(s)
	}
}

func (s *Config_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitConfig_identifier(s)
	}
}

func (p *SystemVerilogParser) Config_identifier() (localctx IConfig_identifierContext) {
	this := p
	_ = this

	localctx = NewConfig_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1116, SystemVerilogParserRULE_config_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7679)
		p.Identifier()
	}

	return localctx
}

// IConst_identifierContext is an interface to support dynamic dispatch.
type IConst_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConst_identifierContext differentiates from other interfaces.
	IsConst_identifierContext()
}

type Const_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConst_identifierContext() *Const_identifierContext {
	var p = new(Const_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_const_identifier
	return p
}

func (*Const_identifierContext) IsConst_identifierContext() {}

func NewConst_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Const_identifierContext {
	var p = new(Const_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_const_identifier

	return p
}

func (s *Const_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Const_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Const_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Const_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Const_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterConst_identifier(s)
	}
}

func (s *Const_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitConst_identifier(s)
	}
}

func (p *SystemVerilogParser) Const_identifier() (localctx IConst_identifierContext) {
	this := p
	_ = this

	localctx = NewConst_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1118, SystemVerilogParserRULE_const_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7681)
		p.Identifier()
	}

	return localctx
}

// IConstraint_identifierContext is an interface to support dynamic dispatch.
type IConstraint_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstraint_identifierContext differentiates from other interfaces.
	IsConstraint_identifierContext()
}

type Constraint_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstraint_identifierContext() *Constraint_identifierContext {
	var p = new(Constraint_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_constraint_identifier
	return p
}

func (*Constraint_identifierContext) IsConstraint_identifierContext() {}

func NewConstraint_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constraint_identifierContext {
	var p = new(Constraint_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_constraint_identifier

	return p
}

func (s *Constraint_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Constraint_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Constraint_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constraint_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constraint_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterConstraint_identifier(s)
	}
}

func (s *Constraint_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitConstraint_identifier(s)
	}
}

func (p *SystemVerilogParser) Constraint_identifier() (localctx IConstraint_identifierContext) {
	this := p
	_ = this

	localctx = NewConstraint_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1120, SystemVerilogParserRULE_constraint_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7683)
		p.Identifier()
	}

	return localctx
}

// ICovergroup_identifierContext is an interface to support dynamic dispatch.
type ICovergroup_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCovergroup_identifierContext differentiates from other interfaces.
	IsCovergroup_identifierContext()
}

type Covergroup_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCovergroup_identifierContext() *Covergroup_identifierContext {
	var p = new(Covergroup_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_covergroup_identifier
	return p
}

func (*Covergroup_identifierContext) IsCovergroup_identifierContext() {}

func NewCovergroup_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Covergroup_identifierContext {
	var p = new(Covergroup_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_covergroup_identifier

	return p
}

func (s *Covergroup_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Covergroup_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Covergroup_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Covergroup_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Covergroup_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterCovergroup_identifier(s)
	}
}

func (s *Covergroup_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitCovergroup_identifier(s)
	}
}

func (p *SystemVerilogParser) Covergroup_identifier() (localctx ICovergroup_identifierContext) {
	this := p
	_ = this

	localctx = NewCovergroup_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1122, SystemVerilogParserRULE_covergroup_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7685)
		p.Identifier()
	}

	return localctx
}

// ICovergroup_variable_identifierContext is an interface to support dynamic dispatch.
type ICovergroup_variable_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCovergroup_variable_identifierContext differentiates from other interfaces.
	IsCovergroup_variable_identifierContext()
}

type Covergroup_variable_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCovergroup_variable_identifierContext() *Covergroup_variable_identifierContext {
	var p = new(Covergroup_variable_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_covergroup_variable_identifier
	return p
}

func (*Covergroup_variable_identifierContext) IsCovergroup_variable_identifierContext() {}

func NewCovergroup_variable_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Covergroup_variable_identifierContext {
	var p = new(Covergroup_variable_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_covergroup_variable_identifier

	return p
}

func (s *Covergroup_variable_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Covergroup_variable_identifierContext) Variable_identifier() IVariable_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_identifierContext)
}

func (s *Covergroup_variable_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Covergroup_variable_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Covergroup_variable_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterCovergroup_variable_identifier(s)
	}
}

func (s *Covergroup_variable_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitCovergroup_variable_identifier(s)
	}
}

func (p *SystemVerilogParser) Covergroup_variable_identifier() (localctx ICovergroup_variable_identifierContext) {
	this := p
	_ = this

	localctx = NewCovergroup_variable_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1124, SystemVerilogParserRULE_covergroup_variable_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7687)
		p.Variable_identifier()
	}

	return localctx
}

// ICover_point_identifierContext is an interface to support dynamic dispatch.
type ICover_point_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCover_point_identifierContext differentiates from other interfaces.
	IsCover_point_identifierContext()
}

type Cover_point_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCover_point_identifierContext() *Cover_point_identifierContext {
	var p = new(Cover_point_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_cover_point_identifier
	return p
}

func (*Cover_point_identifierContext) IsCover_point_identifierContext() {}

func NewCover_point_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cover_point_identifierContext {
	var p = new(Cover_point_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_cover_point_identifier

	return p
}

func (s *Cover_point_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Cover_point_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Cover_point_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cover_point_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cover_point_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterCover_point_identifier(s)
	}
}

func (s *Cover_point_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitCover_point_identifier(s)
	}
}

func (p *SystemVerilogParser) Cover_point_identifier() (localctx ICover_point_identifierContext) {
	this := p
	_ = this

	localctx = NewCover_point_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1126, SystemVerilogParserRULE_cover_point_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7689)
		p.Identifier()
	}

	return localctx
}

// ICross_identifierContext is an interface to support dynamic dispatch.
type ICross_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCross_identifierContext differentiates from other interfaces.
	IsCross_identifierContext()
}

type Cross_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCross_identifierContext() *Cross_identifierContext {
	var p = new(Cross_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_cross_identifier
	return p
}

func (*Cross_identifierContext) IsCross_identifierContext() {}

func NewCross_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cross_identifierContext {
	var p = new(Cross_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_cross_identifier

	return p
}

func (s *Cross_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Cross_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Cross_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cross_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cross_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterCross_identifier(s)
	}
}

func (s *Cross_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitCross_identifier(s)
	}
}

func (p *SystemVerilogParser) Cross_identifier() (localctx ICross_identifierContext) {
	this := p
	_ = this

	localctx = NewCross_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1128, SystemVerilogParserRULE_cross_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7691)
		p.Identifier()
	}

	return localctx
}

// IDynamic_array_variable_identifierContext is an interface to support dynamic dispatch.
type IDynamic_array_variable_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDynamic_array_variable_identifierContext differentiates from other interfaces.
	IsDynamic_array_variable_identifierContext()
}

type Dynamic_array_variable_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDynamic_array_variable_identifierContext() *Dynamic_array_variable_identifierContext {
	var p = new(Dynamic_array_variable_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_dynamic_array_variable_identifier
	return p
}

func (*Dynamic_array_variable_identifierContext) IsDynamic_array_variable_identifierContext() {}

func NewDynamic_array_variable_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dynamic_array_variable_identifierContext {
	var p = new(Dynamic_array_variable_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_dynamic_array_variable_identifier

	return p
}

func (s *Dynamic_array_variable_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Dynamic_array_variable_identifierContext) Variable_identifier() IVariable_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_identifierContext)
}

func (s *Dynamic_array_variable_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dynamic_array_variable_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dynamic_array_variable_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterDynamic_array_variable_identifier(s)
	}
}

func (s *Dynamic_array_variable_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitDynamic_array_variable_identifier(s)
	}
}

func (p *SystemVerilogParser) Dynamic_array_variable_identifier() (localctx IDynamic_array_variable_identifierContext) {
	this := p
	_ = this

	localctx = NewDynamic_array_variable_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1130, SystemVerilogParserRULE_dynamic_array_variable_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7693)
		p.Variable_identifier()
	}

	return localctx
}

// IEnum_identifierContext is an interface to support dynamic dispatch.
type IEnum_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnum_identifierContext differentiates from other interfaces.
	IsEnum_identifierContext()
}

type Enum_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnum_identifierContext() *Enum_identifierContext {
	var p = new(Enum_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_enum_identifier
	return p
}

func (*Enum_identifierContext) IsEnum_identifierContext() {}

func NewEnum_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Enum_identifierContext {
	var p = new(Enum_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_enum_identifier

	return p
}

func (s *Enum_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Enum_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Enum_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Enum_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Enum_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterEnum_identifier(s)
	}
}

func (s *Enum_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitEnum_identifier(s)
	}
}

func (p *SystemVerilogParser) Enum_identifier() (localctx IEnum_identifierContext) {
	this := p
	_ = this

	localctx = NewEnum_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1132, SystemVerilogParserRULE_enum_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7695)
		p.Identifier()
	}

	return localctx
}

// IFormal_port_identifierContext is an interface to support dynamic dispatch.
type IFormal_port_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFormal_port_identifierContext differentiates from other interfaces.
	IsFormal_port_identifierContext()
}

type Formal_port_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormal_port_identifierContext() *Formal_port_identifierContext {
	var p = new(Formal_port_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_formal_port_identifier
	return p
}

func (*Formal_port_identifierContext) IsFormal_port_identifierContext() {}

func NewFormal_port_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Formal_port_identifierContext {
	var p = new(Formal_port_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_formal_port_identifier

	return p
}

func (s *Formal_port_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Formal_port_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Formal_port_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Formal_port_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Formal_port_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterFormal_port_identifier(s)
	}
}

func (s *Formal_port_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitFormal_port_identifier(s)
	}
}

func (p *SystemVerilogParser) Formal_port_identifier() (localctx IFormal_port_identifierContext) {
	this := p
	_ = this

	localctx = NewFormal_port_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1134, SystemVerilogParserRULE_formal_port_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7697)
		p.Identifier()
	}

	return localctx
}

// IFunction_identifierContext is an interface to support dynamic dispatch.
type IFunction_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_identifierContext differentiates from other interfaces.
	IsFunction_identifierContext()
}

type Function_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_identifierContext() *Function_identifierContext {
	var p = new(Function_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_function_identifier
	return p
}

func (*Function_identifierContext) IsFunction_identifierContext() {}

func NewFunction_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_identifierContext {
	var p = new(Function_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_function_identifier

	return p
}

func (s *Function_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Function_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterFunction_identifier(s)
	}
}

func (s *Function_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitFunction_identifier(s)
	}
}

func (p *SystemVerilogParser) Function_identifier() (localctx IFunction_identifierContext) {
	this := p
	_ = this

	localctx = NewFunction_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1136, SystemVerilogParserRULE_function_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7699)
		p.Identifier()
	}

	return localctx
}

// IGenerate_block_identifierContext is an interface to support dynamic dispatch.
type IGenerate_block_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenerate_block_identifierContext differentiates from other interfaces.
	IsGenerate_block_identifierContext()
}

type Generate_block_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenerate_block_identifierContext() *Generate_block_identifierContext {
	var p = new(Generate_block_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_generate_block_identifier
	return p
}

func (*Generate_block_identifierContext) IsGenerate_block_identifierContext() {}

func NewGenerate_block_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Generate_block_identifierContext {
	var p = new(Generate_block_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_generate_block_identifier

	return p
}

func (s *Generate_block_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Generate_block_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Generate_block_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Generate_block_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Generate_block_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterGenerate_block_identifier(s)
	}
}

func (s *Generate_block_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitGenerate_block_identifier(s)
	}
}

func (p *SystemVerilogParser) Generate_block_identifier() (localctx IGenerate_block_identifierContext) {
	this := p
	_ = this

	localctx = NewGenerate_block_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1138, SystemVerilogParserRULE_generate_block_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7701)
		p.Identifier()
	}

	return localctx
}

// IGenvar_identifierContext is an interface to support dynamic dispatch.
type IGenvar_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenvar_identifierContext differentiates from other interfaces.
	IsGenvar_identifierContext()
}

type Genvar_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenvar_identifierContext() *Genvar_identifierContext {
	var p = new(Genvar_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_genvar_identifier
	return p
}

func (*Genvar_identifierContext) IsGenvar_identifierContext() {}

func NewGenvar_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Genvar_identifierContext {
	var p = new(Genvar_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_genvar_identifier

	return p
}

func (s *Genvar_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Genvar_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Genvar_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Genvar_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Genvar_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterGenvar_identifier(s)
	}
}

func (s *Genvar_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitGenvar_identifier(s)
	}
}

func (p *SystemVerilogParser) Genvar_identifier() (localctx IGenvar_identifierContext) {
	this := p
	_ = this

	localctx = NewGenvar_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1140, SystemVerilogParserRULE_genvar_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7703)
		p.Identifier()
	}

	return localctx
}

// IHierarchical_array_identifierContext is an interface to support dynamic dispatch.
type IHierarchical_array_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHierarchical_array_identifierContext differentiates from other interfaces.
	IsHierarchical_array_identifierContext()
}

type Hierarchical_array_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHierarchical_array_identifierContext() *Hierarchical_array_identifierContext {
	var p = new(Hierarchical_array_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_hierarchical_array_identifier
	return p
}

func (*Hierarchical_array_identifierContext) IsHierarchical_array_identifierContext() {}

func NewHierarchical_array_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Hierarchical_array_identifierContext {
	var p = new(Hierarchical_array_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_hierarchical_array_identifier

	return p
}

func (s *Hierarchical_array_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Hierarchical_array_identifierContext) Hierarchical_identifier() IHierarchical_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_identifierContext)
}

func (s *Hierarchical_array_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Hierarchical_array_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Hierarchical_array_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterHierarchical_array_identifier(s)
	}
}

func (s *Hierarchical_array_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitHierarchical_array_identifier(s)
	}
}

func (p *SystemVerilogParser) Hierarchical_array_identifier() (localctx IHierarchical_array_identifierContext) {
	this := p
	_ = this

	localctx = NewHierarchical_array_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1142, SystemVerilogParserRULE_hierarchical_array_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7705)
		p.Hierarchical_identifier()
	}

	return localctx
}

// IHierarchical_block_identifierContext is an interface to support dynamic dispatch.
type IHierarchical_block_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHierarchical_block_identifierContext differentiates from other interfaces.
	IsHierarchical_block_identifierContext()
}

type Hierarchical_block_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHierarchical_block_identifierContext() *Hierarchical_block_identifierContext {
	var p = new(Hierarchical_block_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_hierarchical_block_identifier
	return p
}

func (*Hierarchical_block_identifierContext) IsHierarchical_block_identifierContext() {}

func NewHierarchical_block_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Hierarchical_block_identifierContext {
	var p = new(Hierarchical_block_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_hierarchical_block_identifier

	return p
}

func (s *Hierarchical_block_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Hierarchical_block_identifierContext) Hierarchical_identifier() IHierarchical_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_identifierContext)
}

func (s *Hierarchical_block_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Hierarchical_block_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Hierarchical_block_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterHierarchical_block_identifier(s)
	}
}

func (s *Hierarchical_block_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitHierarchical_block_identifier(s)
	}
}

func (p *SystemVerilogParser) Hierarchical_block_identifier() (localctx IHierarchical_block_identifierContext) {
	this := p
	_ = this

	localctx = NewHierarchical_block_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1144, SystemVerilogParserRULE_hierarchical_block_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7707)
		p.Hierarchical_identifier()
	}

	return localctx
}

// IHierarchical_event_identifierContext is an interface to support dynamic dispatch.
type IHierarchical_event_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHierarchical_event_identifierContext differentiates from other interfaces.
	IsHierarchical_event_identifierContext()
}

type Hierarchical_event_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHierarchical_event_identifierContext() *Hierarchical_event_identifierContext {
	var p = new(Hierarchical_event_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_hierarchical_event_identifier
	return p
}

func (*Hierarchical_event_identifierContext) IsHierarchical_event_identifierContext() {}

func NewHierarchical_event_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Hierarchical_event_identifierContext {
	var p = new(Hierarchical_event_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_hierarchical_event_identifier

	return p
}

func (s *Hierarchical_event_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Hierarchical_event_identifierContext) Hierarchical_identifier() IHierarchical_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_identifierContext)
}

func (s *Hierarchical_event_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Hierarchical_event_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Hierarchical_event_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterHierarchical_event_identifier(s)
	}
}

func (s *Hierarchical_event_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitHierarchical_event_identifier(s)
	}
}

func (p *SystemVerilogParser) Hierarchical_event_identifier() (localctx IHierarchical_event_identifierContext) {
	this := p
	_ = this

	localctx = NewHierarchical_event_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1146, SystemVerilogParserRULE_hierarchical_event_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7709)
		p.Hierarchical_identifier()
	}

	return localctx
}

// IHierarchical_identifierContext is an interface to support dynamic dispatch.
type IHierarchical_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHierarchical_identifierContext differentiates from other interfaces.
	IsHierarchical_identifierContext()
}

type Hierarchical_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHierarchical_identifierContext() *Hierarchical_identifierContext {
	var p = new(Hierarchical_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_hierarchical_identifier
	return p
}

func (*Hierarchical_identifierContext) IsHierarchical_identifierContext() {}

func NewHierarchical_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Hierarchical_identifierContext {
	var p = new(Hierarchical_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_hierarchical_identifier

	return p
}

func (s *Hierarchical_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Hierarchical_identifierContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *Hierarchical_identifierContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Hierarchical_identifierContext) DROOT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserDROOT, 0)
}

func (s *Hierarchical_identifierContext) AllConstant_bit_select() []IConstant_bit_selectContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConstant_bit_selectContext)(nil)).Elem())
	var tst = make([]IConstant_bit_selectContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConstant_bit_selectContext)
		}
	}

	return tst
}

func (s *Hierarchical_identifierContext) Constant_bit_select(i int) IConstant_bit_selectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_bit_selectContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConstant_bit_selectContext)
}

func (s *Hierarchical_identifierContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserDOT)
}

func (s *Hierarchical_identifierContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserDOT, i)
}

func (s *Hierarchical_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Hierarchical_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Hierarchical_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterHierarchical_identifier(s)
	}
}

func (s *Hierarchical_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitHierarchical_identifier(s)
	}
}

func (p *SystemVerilogParser) Hierarchical_identifier() (localctx IHierarchical_identifierContext) {
	this := p
	_ = this

	localctx = NewHierarchical_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1148, SystemVerilogParserRULE_hierarchical_identifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(7712)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SystemVerilogParserDROOT {
		{
			p.SetState(7711)
			p.Match(SystemVerilogParserDROOT)
		}

	}
	p.SetState(7720)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 960, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(7714)
				p.Identifier()
			}
			{
				p.SetState(7715)
				p.Constant_bit_select()
			}
			{
				p.SetState(7716)
				p.Match(SystemVerilogParserDOT)
			}

		}
		p.SetState(7722)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 960, p.GetParserRuleContext())
	}
	{
		p.SetState(7723)
		p.Identifier()
	}

	return localctx
}

// IHierarchical_net_identifierContext is an interface to support dynamic dispatch.
type IHierarchical_net_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHierarchical_net_identifierContext differentiates from other interfaces.
	IsHierarchical_net_identifierContext()
}

type Hierarchical_net_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHierarchical_net_identifierContext() *Hierarchical_net_identifierContext {
	var p = new(Hierarchical_net_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_hierarchical_net_identifier
	return p
}

func (*Hierarchical_net_identifierContext) IsHierarchical_net_identifierContext() {}

func NewHierarchical_net_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Hierarchical_net_identifierContext {
	var p = new(Hierarchical_net_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_hierarchical_net_identifier

	return p
}

func (s *Hierarchical_net_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Hierarchical_net_identifierContext) Hierarchical_identifier() IHierarchical_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_identifierContext)
}

func (s *Hierarchical_net_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Hierarchical_net_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Hierarchical_net_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterHierarchical_net_identifier(s)
	}
}

func (s *Hierarchical_net_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitHierarchical_net_identifier(s)
	}
}

func (p *SystemVerilogParser) Hierarchical_net_identifier() (localctx IHierarchical_net_identifierContext) {
	this := p
	_ = this

	localctx = NewHierarchical_net_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1150, SystemVerilogParserRULE_hierarchical_net_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7725)
		p.Hierarchical_identifier()
	}

	return localctx
}

// IHierarchical_parameter_identifierContext is an interface to support dynamic dispatch.
type IHierarchical_parameter_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHierarchical_parameter_identifierContext differentiates from other interfaces.
	IsHierarchical_parameter_identifierContext()
}

type Hierarchical_parameter_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHierarchical_parameter_identifierContext() *Hierarchical_parameter_identifierContext {
	var p = new(Hierarchical_parameter_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_hierarchical_parameter_identifier
	return p
}

func (*Hierarchical_parameter_identifierContext) IsHierarchical_parameter_identifierContext() {}

func NewHierarchical_parameter_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Hierarchical_parameter_identifierContext {
	var p = new(Hierarchical_parameter_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_hierarchical_parameter_identifier

	return p
}

func (s *Hierarchical_parameter_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Hierarchical_parameter_identifierContext) Hierarchical_identifier() IHierarchical_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_identifierContext)
}

func (s *Hierarchical_parameter_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Hierarchical_parameter_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Hierarchical_parameter_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterHierarchical_parameter_identifier(s)
	}
}

func (s *Hierarchical_parameter_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitHierarchical_parameter_identifier(s)
	}
}

func (p *SystemVerilogParser) Hierarchical_parameter_identifier() (localctx IHierarchical_parameter_identifierContext) {
	this := p
	_ = this

	localctx = NewHierarchical_parameter_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1152, SystemVerilogParserRULE_hierarchical_parameter_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7727)
		p.Hierarchical_identifier()
	}

	return localctx
}

// IHierarchical_property_identifierContext is an interface to support dynamic dispatch.
type IHierarchical_property_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHierarchical_property_identifierContext differentiates from other interfaces.
	IsHierarchical_property_identifierContext()
}

type Hierarchical_property_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHierarchical_property_identifierContext() *Hierarchical_property_identifierContext {
	var p = new(Hierarchical_property_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_hierarchical_property_identifier
	return p
}

func (*Hierarchical_property_identifierContext) IsHierarchical_property_identifierContext() {}

func NewHierarchical_property_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Hierarchical_property_identifierContext {
	var p = new(Hierarchical_property_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_hierarchical_property_identifier

	return p
}

func (s *Hierarchical_property_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Hierarchical_property_identifierContext) Hierarchical_identifier() IHierarchical_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_identifierContext)
}

func (s *Hierarchical_property_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Hierarchical_property_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Hierarchical_property_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterHierarchical_property_identifier(s)
	}
}

func (s *Hierarchical_property_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitHierarchical_property_identifier(s)
	}
}

func (p *SystemVerilogParser) Hierarchical_property_identifier() (localctx IHierarchical_property_identifierContext) {
	this := p
	_ = this

	localctx = NewHierarchical_property_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1154, SystemVerilogParserRULE_hierarchical_property_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7729)
		p.Hierarchical_identifier()
	}

	return localctx
}

// IHierarchical_sequence_identifierContext is an interface to support dynamic dispatch.
type IHierarchical_sequence_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHierarchical_sequence_identifierContext differentiates from other interfaces.
	IsHierarchical_sequence_identifierContext()
}

type Hierarchical_sequence_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHierarchical_sequence_identifierContext() *Hierarchical_sequence_identifierContext {
	var p = new(Hierarchical_sequence_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_hierarchical_sequence_identifier
	return p
}

func (*Hierarchical_sequence_identifierContext) IsHierarchical_sequence_identifierContext() {}

func NewHierarchical_sequence_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Hierarchical_sequence_identifierContext {
	var p = new(Hierarchical_sequence_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_hierarchical_sequence_identifier

	return p
}

func (s *Hierarchical_sequence_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Hierarchical_sequence_identifierContext) Hierarchical_identifier() IHierarchical_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_identifierContext)
}

func (s *Hierarchical_sequence_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Hierarchical_sequence_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Hierarchical_sequence_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterHierarchical_sequence_identifier(s)
	}
}

func (s *Hierarchical_sequence_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitHierarchical_sequence_identifier(s)
	}
}

func (p *SystemVerilogParser) Hierarchical_sequence_identifier() (localctx IHierarchical_sequence_identifierContext) {
	this := p
	_ = this

	localctx = NewHierarchical_sequence_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1156, SystemVerilogParserRULE_hierarchical_sequence_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7731)
		p.Hierarchical_identifier()
	}

	return localctx
}

// IHierarchical_task_identifierContext is an interface to support dynamic dispatch.
type IHierarchical_task_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHierarchical_task_identifierContext differentiates from other interfaces.
	IsHierarchical_task_identifierContext()
}

type Hierarchical_task_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHierarchical_task_identifierContext() *Hierarchical_task_identifierContext {
	var p = new(Hierarchical_task_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_hierarchical_task_identifier
	return p
}

func (*Hierarchical_task_identifierContext) IsHierarchical_task_identifierContext() {}

func NewHierarchical_task_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Hierarchical_task_identifierContext {
	var p = new(Hierarchical_task_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_hierarchical_task_identifier

	return p
}

func (s *Hierarchical_task_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Hierarchical_task_identifierContext) Hierarchical_identifier() IHierarchical_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_identifierContext)
}

func (s *Hierarchical_task_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Hierarchical_task_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Hierarchical_task_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterHierarchical_task_identifier(s)
	}
}

func (s *Hierarchical_task_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitHierarchical_task_identifier(s)
	}
}

func (p *SystemVerilogParser) Hierarchical_task_identifier() (localctx IHierarchical_task_identifierContext) {
	this := p
	_ = this

	localctx = NewHierarchical_task_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1158, SystemVerilogParserRULE_hierarchical_task_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7733)
		p.Hierarchical_identifier()
	}

	return localctx
}

// IHierarchical_tf_identifierContext is an interface to support dynamic dispatch.
type IHierarchical_tf_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHierarchical_tf_identifierContext differentiates from other interfaces.
	IsHierarchical_tf_identifierContext()
}

type Hierarchical_tf_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHierarchical_tf_identifierContext() *Hierarchical_tf_identifierContext {
	var p = new(Hierarchical_tf_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_hierarchical_tf_identifier
	return p
}

func (*Hierarchical_tf_identifierContext) IsHierarchical_tf_identifierContext() {}

func NewHierarchical_tf_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Hierarchical_tf_identifierContext {
	var p = new(Hierarchical_tf_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_hierarchical_tf_identifier

	return p
}

func (s *Hierarchical_tf_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Hierarchical_tf_identifierContext) Hierarchical_identifier() IHierarchical_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_identifierContext)
}

func (s *Hierarchical_tf_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Hierarchical_tf_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Hierarchical_tf_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterHierarchical_tf_identifier(s)
	}
}

func (s *Hierarchical_tf_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitHierarchical_tf_identifier(s)
	}
}

func (p *SystemVerilogParser) Hierarchical_tf_identifier() (localctx IHierarchical_tf_identifierContext) {
	this := p
	_ = this

	localctx = NewHierarchical_tf_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1160, SystemVerilogParserRULE_hierarchical_tf_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7735)
		p.Hierarchical_identifier()
	}

	return localctx
}

// IHierarchical_variable_identifierContext is an interface to support dynamic dispatch.
type IHierarchical_variable_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHierarchical_variable_identifierContext differentiates from other interfaces.
	IsHierarchical_variable_identifierContext()
}

type Hierarchical_variable_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHierarchical_variable_identifierContext() *Hierarchical_variable_identifierContext {
	var p = new(Hierarchical_variable_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_hierarchical_variable_identifier
	return p
}

func (*Hierarchical_variable_identifierContext) IsHierarchical_variable_identifierContext() {}

func NewHierarchical_variable_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Hierarchical_variable_identifierContext {
	var p = new(Hierarchical_variable_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_hierarchical_variable_identifier

	return p
}

func (s *Hierarchical_variable_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Hierarchical_variable_identifierContext) Hierarchical_identifier() IHierarchical_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_identifierContext)
}

func (s *Hierarchical_variable_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Hierarchical_variable_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Hierarchical_variable_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterHierarchical_variable_identifier(s)
	}
}

func (s *Hierarchical_variable_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitHierarchical_variable_identifier(s)
	}
}

func (p *SystemVerilogParser) Hierarchical_variable_identifier() (localctx IHierarchical_variable_identifierContext) {
	this := p
	_ = this

	localctx = NewHierarchical_variable_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1162, SystemVerilogParserRULE_hierarchical_variable_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7737)
		p.Hierarchical_identifier()
	}

	return localctx
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_identifier
	return p
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) SIMPLE_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserSIMPLE_IDENTIFIER, 0)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterIdentifier(s)
	}
}

func (s *IdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitIdentifier(s)
	}
}

func (p *SystemVerilogParser) Identifier() (localctx IIdentifierContext) {
	this := p
	_ = this

	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1164, SystemVerilogParserRULE_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7739)
		p.Match(SystemVerilogParserSIMPLE_IDENTIFIER)
	}

	return localctx
}

// IIndex_variable_identifierContext is an interface to support dynamic dispatch.
type IIndex_variable_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIndex_variable_identifierContext differentiates from other interfaces.
	IsIndex_variable_identifierContext()
}

type Index_variable_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndex_variable_identifierContext() *Index_variable_identifierContext {
	var p = new(Index_variable_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_index_variable_identifier
	return p
}

func (*Index_variable_identifierContext) IsIndex_variable_identifierContext() {}

func NewIndex_variable_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Index_variable_identifierContext {
	var p = new(Index_variable_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_index_variable_identifier

	return p
}

func (s *Index_variable_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Index_variable_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Index_variable_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Index_variable_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Index_variable_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterIndex_variable_identifier(s)
	}
}

func (s *Index_variable_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitIndex_variable_identifier(s)
	}
}

func (p *SystemVerilogParser) Index_variable_identifier() (localctx IIndex_variable_identifierContext) {
	this := p
	_ = this

	localctx = NewIndex_variable_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1166, SystemVerilogParserRULE_index_variable_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7741)
		p.Identifier()
	}

	return localctx
}

// IInterface_identifierContext is an interface to support dynamic dispatch.
type IInterface_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterface_identifierContext differentiates from other interfaces.
	IsInterface_identifierContext()
}

type Interface_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterface_identifierContext() *Interface_identifierContext {
	var p = new(Interface_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_interface_identifier
	return p
}

func (*Interface_identifierContext) IsInterface_identifierContext() {}

func NewInterface_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Interface_identifierContext {
	var p = new(Interface_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_interface_identifier

	return p
}

func (s *Interface_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Interface_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Interface_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Interface_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Interface_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterInterface_identifier(s)
	}
}

func (s *Interface_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitInterface_identifier(s)
	}
}

func (p *SystemVerilogParser) Interface_identifier() (localctx IInterface_identifierContext) {
	this := p
	_ = this

	localctx = NewInterface_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1168, SystemVerilogParserRULE_interface_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7743)
		p.Identifier()
	}

	return localctx
}

// IInterface_instance_identifierContext is an interface to support dynamic dispatch.
type IInterface_instance_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterface_instance_identifierContext differentiates from other interfaces.
	IsInterface_instance_identifierContext()
}

type Interface_instance_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterface_instance_identifierContext() *Interface_instance_identifierContext {
	var p = new(Interface_instance_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_interface_instance_identifier
	return p
}

func (*Interface_instance_identifierContext) IsInterface_instance_identifierContext() {}

func NewInterface_instance_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Interface_instance_identifierContext {
	var p = new(Interface_instance_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_interface_instance_identifier

	return p
}

func (s *Interface_instance_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Interface_instance_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Interface_instance_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Interface_instance_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Interface_instance_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterInterface_instance_identifier(s)
	}
}

func (s *Interface_instance_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitInterface_instance_identifier(s)
	}
}

func (p *SystemVerilogParser) Interface_instance_identifier() (localctx IInterface_instance_identifierContext) {
	this := p
	_ = this

	localctx = NewInterface_instance_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1170, SystemVerilogParserRULE_interface_instance_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7745)
		p.Identifier()
	}

	return localctx
}

// IInout_port_identifierContext is an interface to support dynamic dispatch.
type IInout_port_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInout_port_identifierContext differentiates from other interfaces.
	IsInout_port_identifierContext()
}

type Inout_port_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInout_port_identifierContext() *Inout_port_identifierContext {
	var p = new(Inout_port_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_inout_port_identifier
	return p
}

func (*Inout_port_identifierContext) IsInout_port_identifierContext() {}

func NewInout_port_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Inout_port_identifierContext {
	var p = new(Inout_port_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_inout_port_identifier

	return p
}

func (s *Inout_port_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Inout_port_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Inout_port_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Inout_port_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Inout_port_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterInout_port_identifier(s)
	}
}

func (s *Inout_port_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitInout_port_identifier(s)
	}
}

func (p *SystemVerilogParser) Inout_port_identifier() (localctx IInout_port_identifierContext) {
	this := p
	_ = this

	localctx = NewInout_port_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1172, SystemVerilogParserRULE_inout_port_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7747)
		p.Identifier()
	}

	return localctx
}

// IInput_port_identifierContext is an interface to support dynamic dispatch.
type IInput_port_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInput_port_identifierContext differentiates from other interfaces.
	IsInput_port_identifierContext()
}

type Input_port_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInput_port_identifierContext() *Input_port_identifierContext {
	var p = new(Input_port_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_input_port_identifier
	return p
}

func (*Input_port_identifierContext) IsInput_port_identifierContext() {}

func NewInput_port_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Input_port_identifierContext {
	var p = new(Input_port_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_input_port_identifier

	return p
}

func (s *Input_port_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Input_port_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Input_port_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Input_port_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Input_port_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterInput_port_identifier(s)
	}
}

func (s *Input_port_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitInput_port_identifier(s)
	}
}

func (p *SystemVerilogParser) Input_port_identifier() (localctx IInput_port_identifierContext) {
	this := p
	_ = this

	localctx = NewInput_port_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1174, SystemVerilogParserRULE_input_port_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7749)
		p.Identifier()
	}

	return localctx
}

// IInstance_identifierContext is an interface to support dynamic dispatch.
type IInstance_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInstance_identifierContext differentiates from other interfaces.
	IsInstance_identifierContext()
}

type Instance_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInstance_identifierContext() *Instance_identifierContext {
	var p = new(Instance_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_instance_identifier
	return p
}

func (*Instance_identifierContext) IsInstance_identifierContext() {}

func NewInstance_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Instance_identifierContext {
	var p = new(Instance_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_instance_identifier

	return p
}

func (s *Instance_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Instance_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Instance_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Instance_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Instance_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterInstance_identifier(s)
	}
}

func (s *Instance_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitInstance_identifier(s)
	}
}

func (p *SystemVerilogParser) Instance_identifier() (localctx IInstance_identifierContext) {
	this := p
	_ = this

	localctx = NewInstance_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1176, SystemVerilogParserRULE_instance_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7751)
		p.Identifier()
	}

	return localctx
}

// ILibrary_identifierContext is an interface to support dynamic dispatch.
type ILibrary_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibrary_identifierContext differentiates from other interfaces.
	IsLibrary_identifierContext()
}

type Library_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibrary_identifierContext() *Library_identifierContext {
	var p = new(Library_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_library_identifier
	return p
}

func (*Library_identifierContext) IsLibrary_identifierContext() {}

func NewLibrary_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Library_identifierContext {
	var p = new(Library_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_library_identifier

	return p
}

func (s *Library_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Library_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Library_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Library_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Library_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterLibrary_identifier(s)
	}
}

func (s *Library_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitLibrary_identifier(s)
	}
}

func (p *SystemVerilogParser) Library_identifier() (localctx ILibrary_identifierContext) {
	this := p
	_ = this

	localctx = NewLibrary_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1178, SystemVerilogParserRULE_library_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7753)
		p.Identifier()
	}

	return localctx
}

// IMember_identifierContext is an interface to support dynamic dispatch.
type IMember_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMember_identifierContext differentiates from other interfaces.
	IsMember_identifierContext()
}

type Member_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMember_identifierContext() *Member_identifierContext {
	var p = new(Member_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_member_identifier
	return p
}

func (*Member_identifierContext) IsMember_identifierContext() {}

func NewMember_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Member_identifierContext {
	var p = new(Member_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_member_identifier

	return p
}

func (s *Member_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Member_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Member_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Member_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Member_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterMember_identifier(s)
	}
}

func (s *Member_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitMember_identifier(s)
	}
}

func (p *SystemVerilogParser) Member_identifier() (localctx IMember_identifierContext) {
	this := p
	_ = this

	localctx = NewMember_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1180, SystemVerilogParserRULE_member_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7755)
		p.Identifier()
	}

	return localctx
}

// IMethod_identifierContext is an interface to support dynamic dispatch.
type IMethod_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMethod_identifierContext differentiates from other interfaces.
	IsMethod_identifierContext()
}

type Method_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethod_identifierContext() *Method_identifierContext {
	var p = new(Method_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_method_identifier
	return p
}

func (*Method_identifierContext) IsMethod_identifierContext() {}

func NewMethod_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Method_identifierContext {
	var p = new(Method_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_method_identifier

	return p
}

func (s *Method_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Method_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Method_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Method_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Method_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterMethod_identifier(s)
	}
}

func (s *Method_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitMethod_identifier(s)
	}
}

func (p *SystemVerilogParser) Method_identifier() (localctx IMethod_identifierContext) {
	this := p
	_ = this

	localctx = NewMethod_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1182, SystemVerilogParserRULE_method_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7757)
		p.Identifier()
	}

	return localctx
}

// IModport_identifierContext is an interface to support dynamic dispatch.
type IModport_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModport_identifierContext differentiates from other interfaces.
	IsModport_identifierContext()
}

type Modport_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModport_identifierContext() *Modport_identifierContext {
	var p = new(Modport_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_modport_identifier
	return p
}

func (*Modport_identifierContext) IsModport_identifierContext() {}

func NewModport_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Modport_identifierContext {
	var p = new(Modport_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_modport_identifier

	return p
}

func (s *Modport_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Modport_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Modport_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Modport_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Modport_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterModport_identifier(s)
	}
}

func (s *Modport_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitModport_identifier(s)
	}
}

func (p *SystemVerilogParser) Modport_identifier() (localctx IModport_identifierContext) {
	this := p
	_ = this

	localctx = NewModport_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1184, SystemVerilogParserRULE_modport_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7759)
		p.Identifier()
	}

	return localctx
}

// IModule_identifierContext is an interface to support dynamic dispatch.
type IModule_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModule_identifierContext differentiates from other interfaces.
	IsModule_identifierContext()
}

type Module_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModule_identifierContext() *Module_identifierContext {
	var p = new(Module_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_module_identifier
	return p
}

func (*Module_identifierContext) IsModule_identifierContext() {}

func NewModule_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Module_identifierContext {
	var p = new(Module_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_module_identifier

	return p
}

func (s *Module_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Module_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Module_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Module_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Module_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterModule_identifier(s)
	}
}

func (s *Module_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitModule_identifier(s)
	}
}

func (p *SystemVerilogParser) Module_identifier() (localctx IModule_identifierContext) {
	this := p
	_ = this

	localctx = NewModule_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1186, SystemVerilogParserRULE_module_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7761)
		p.Identifier()
	}

	return localctx
}

// INet_identifierContext is an interface to support dynamic dispatch.
type INet_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNet_identifierContext differentiates from other interfaces.
	IsNet_identifierContext()
}

type Net_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNet_identifierContext() *Net_identifierContext {
	var p = new(Net_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_net_identifier
	return p
}

func (*Net_identifierContext) IsNet_identifierContext() {}

func NewNet_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Net_identifierContext {
	var p = new(Net_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_net_identifier

	return p
}

func (s *Net_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Net_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Net_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Net_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Net_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterNet_identifier(s)
	}
}

func (s *Net_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitNet_identifier(s)
	}
}

func (p *SystemVerilogParser) Net_identifier() (localctx INet_identifierContext) {
	this := p
	_ = this

	localctx = NewNet_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1188, SystemVerilogParserRULE_net_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7763)
		p.Identifier()
	}

	return localctx
}

// INet_type_identifierContext is an interface to support dynamic dispatch.
type INet_type_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNet_type_identifierContext differentiates from other interfaces.
	IsNet_type_identifierContext()
}

type Net_type_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNet_type_identifierContext() *Net_type_identifierContext {
	var p = new(Net_type_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_net_type_identifier
	return p
}

func (*Net_type_identifierContext) IsNet_type_identifierContext() {}

func NewNet_type_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Net_type_identifierContext {
	var p = new(Net_type_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_net_type_identifier

	return p
}

func (s *Net_type_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Net_type_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Net_type_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Net_type_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Net_type_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterNet_type_identifier(s)
	}
}

func (s *Net_type_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitNet_type_identifier(s)
	}
}

func (p *SystemVerilogParser) Net_type_identifier() (localctx INet_type_identifierContext) {
	this := p
	_ = this

	localctx = NewNet_type_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1190, SystemVerilogParserRULE_net_type_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7765)
		p.Identifier()
	}

	return localctx
}

// IOutput_port_identifierContext is an interface to support dynamic dispatch.
type IOutput_port_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOutput_port_identifierContext differentiates from other interfaces.
	IsOutput_port_identifierContext()
}

type Output_port_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOutput_port_identifierContext() *Output_port_identifierContext {
	var p = new(Output_port_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_output_port_identifier
	return p
}

func (*Output_port_identifierContext) IsOutput_port_identifierContext() {}

func NewOutput_port_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Output_port_identifierContext {
	var p = new(Output_port_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_output_port_identifier

	return p
}

func (s *Output_port_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Output_port_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Output_port_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Output_port_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Output_port_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterOutput_port_identifier(s)
	}
}

func (s *Output_port_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitOutput_port_identifier(s)
	}
}

func (p *SystemVerilogParser) Output_port_identifier() (localctx IOutput_port_identifierContext) {
	this := p
	_ = this

	localctx = NewOutput_port_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1192, SystemVerilogParserRULE_output_port_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7767)
		p.Identifier()
	}

	return localctx
}

// IPackage_identifierContext is an interface to support dynamic dispatch.
type IPackage_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPackage_identifierContext differentiates from other interfaces.
	IsPackage_identifierContext()
}

type Package_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackage_identifierContext() *Package_identifierContext {
	var p = new(Package_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_package_identifier
	return p
}

func (*Package_identifierContext) IsPackage_identifierContext() {}

func NewPackage_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Package_identifierContext {
	var p = new(Package_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_package_identifier

	return p
}

func (s *Package_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Package_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Package_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Package_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Package_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterPackage_identifier(s)
	}
}

func (s *Package_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitPackage_identifier(s)
	}
}

func (p *SystemVerilogParser) Package_identifier() (localctx IPackage_identifierContext) {
	this := p
	_ = this

	localctx = NewPackage_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1194, SystemVerilogParserRULE_package_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7769)
		p.Identifier()
	}

	return localctx
}

// IPackage_scopeContext is an interface to support dynamic dispatch.
type IPackage_scopeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPackage_scopeContext differentiates from other interfaces.
	IsPackage_scopeContext()
}

type Package_scopeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackage_scopeContext() *Package_scopeContext {
	var p = new(Package_scopeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_package_scope
	return p
}

func (*Package_scopeContext) IsPackage_scopeContext() {}

func NewPackage_scopeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Package_scopeContext {
	var p = new(Package_scopeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_package_scope

	return p
}

func (s *Package_scopeContext) GetParser() antlr.Parser { return s.parser }

func (s *Package_scopeContext) COLONCOLON() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOLONCOLON, 0)
}

func (s *Package_scopeContext) Package_identifier() IPackage_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackage_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPackage_identifierContext)
}

func (s *Package_scopeContext) DUNIT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserDUNIT, 0)
}

func (s *Package_scopeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Package_scopeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Package_scopeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterPackage_scope(s)
	}
}

func (s *Package_scopeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitPackage_scope(s)
	}
}

func (p *SystemVerilogParser) Package_scope() (localctx IPackage_scopeContext) {
	this := p
	_ = this

	localctx = NewPackage_scopeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1196, SystemVerilogParserRULE_package_scope)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(7773)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SystemVerilogParserSIMPLE_IDENTIFIER:
		{
			p.SetState(7771)
			p.Package_identifier()
		}

	case SystemVerilogParserDUNIT:
		{
			p.SetState(7772)
			p.Match(SystemVerilogParserDUNIT)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(7775)
		p.Match(SystemVerilogParserCOLONCOLON)
	}

	return localctx
}

// IParameter_identifierContext is an interface to support dynamic dispatch.
type IParameter_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameter_identifierContext differentiates from other interfaces.
	IsParameter_identifierContext()
}

type Parameter_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameter_identifierContext() *Parameter_identifierContext {
	var p = new(Parameter_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_parameter_identifier
	return p
}

func (*Parameter_identifierContext) IsParameter_identifierContext() {}

func NewParameter_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Parameter_identifierContext {
	var p = new(Parameter_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_parameter_identifier

	return p
}

func (s *Parameter_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Parameter_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Parameter_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parameter_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Parameter_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterParameter_identifier(s)
	}
}

func (s *Parameter_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitParameter_identifier(s)
	}
}

func (p *SystemVerilogParser) Parameter_identifier() (localctx IParameter_identifierContext) {
	this := p
	_ = this

	localctx = NewParameter_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1198, SystemVerilogParserRULE_parameter_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7777)
		p.Identifier()
	}

	return localctx
}

// IPort_identifierContext is an interface to support dynamic dispatch.
type IPort_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPort_identifierContext differentiates from other interfaces.
	IsPort_identifierContext()
}

type Port_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPort_identifierContext() *Port_identifierContext {
	var p = new(Port_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_port_identifier
	return p
}

func (*Port_identifierContext) IsPort_identifierContext() {}

func NewPort_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Port_identifierContext {
	var p = new(Port_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_port_identifier

	return p
}

func (s *Port_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Port_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Port_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Port_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Port_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterPort_identifier(s)
	}
}

func (s *Port_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitPort_identifier(s)
	}
}

func (p *SystemVerilogParser) Port_identifier() (localctx IPort_identifierContext) {
	this := p
	_ = this

	localctx = NewPort_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1200, SystemVerilogParserRULE_port_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7779)
		p.Identifier()
	}

	return localctx
}

// IProduction_identifierContext is an interface to support dynamic dispatch.
type IProduction_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProduction_identifierContext differentiates from other interfaces.
	IsProduction_identifierContext()
}

type Production_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProduction_identifierContext() *Production_identifierContext {
	var p = new(Production_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_production_identifier
	return p
}

func (*Production_identifierContext) IsProduction_identifierContext() {}

func NewProduction_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Production_identifierContext {
	var p = new(Production_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_production_identifier

	return p
}

func (s *Production_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Production_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Production_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Production_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Production_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterProduction_identifier(s)
	}
}

func (s *Production_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitProduction_identifier(s)
	}
}

func (p *SystemVerilogParser) Production_identifier() (localctx IProduction_identifierContext) {
	this := p
	_ = this

	localctx = NewProduction_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1202, SystemVerilogParserRULE_production_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7781)
		p.Identifier()
	}

	return localctx
}

// IProgram_identifierContext is an interface to support dynamic dispatch.
type IProgram_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProgram_identifierContext differentiates from other interfaces.
	IsProgram_identifierContext()
}

type Program_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProgram_identifierContext() *Program_identifierContext {
	var p = new(Program_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_program_identifier
	return p
}

func (*Program_identifierContext) IsProgram_identifierContext() {}

func NewProgram_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Program_identifierContext {
	var p = new(Program_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_program_identifier

	return p
}

func (s *Program_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Program_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Program_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Program_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Program_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterProgram_identifier(s)
	}
}

func (s *Program_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitProgram_identifier(s)
	}
}

func (p *SystemVerilogParser) Program_identifier() (localctx IProgram_identifierContext) {
	this := p
	_ = this

	localctx = NewProgram_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1204, SystemVerilogParserRULE_program_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7783)
		p.Identifier()
	}

	return localctx
}

// IProperty_identifierContext is an interface to support dynamic dispatch.
type IProperty_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProperty_identifierContext differentiates from other interfaces.
	IsProperty_identifierContext()
}

type Property_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProperty_identifierContext() *Property_identifierContext {
	var p = new(Property_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_property_identifier
	return p
}

func (*Property_identifierContext) IsProperty_identifierContext() {}

func NewProperty_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Property_identifierContext {
	var p = new(Property_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_property_identifier

	return p
}

func (s *Property_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Property_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Property_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Property_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Property_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterProperty_identifier(s)
	}
}

func (s *Property_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitProperty_identifier(s)
	}
}

func (p *SystemVerilogParser) Property_identifier() (localctx IProperty_identifierContext) {
	this := p
	_ = this

	localctx = NewProperty_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1206, SystemVerilogParserRULE_property_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7785)
		p.Identifier()
	}

	return localctx
}

// IPs_class_identifierContext is an interface to support dynamic dispatch.
type IPs_class_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPs_class_identifierContext differentiates from other interfaces.
	IsPs_class_identifierContext()
}

type Ps_class_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPs_class_identifierContext() *Ps_class_identifierContext {
	var p = new(Ps_class_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_ps_class_identifier
	return p
}

func (*Ps_class_identifierContext) IsPs_class_identifierContext() {}

func NewPs_class_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Ps_class_identifierContext {
	var p = new(Ps_class_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_ps_class_identifier

	return p
}

func (s *Ps_class_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Ps_class_identifierContext) Class_identifier() IClass_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClass_identifierContext)
}

func (s *Ps_class_identifierContext) Package_scope() IPackage_scopeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackage_scopeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPackage_scopeContext)
}

func (s *Ps_class_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ps_class_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Ps_class_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterPs_class_identifier(s)
	}
}

func (s *Ps_class_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitPs_class_identifier(s)
	}
}

func (p *SystemVerilogParser) Ps_class_identifier() (localctx IPs_class_identifierContext) {
	this := p
	_ = this

	localctx = NewPs_class_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1208, SystemVerilogParserRULE_ps_class_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(7788)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 962, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(7787)
			p.Package_scope()
		}

	}
	{
		p.SetState(7790)
		p.Class_identifier()
	}

	return localctx
}

// IPs_covergroup_identifierContext is an interface to support dynamic dispatch.
type IPs_covergroup_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPs_covergroup_identifierContext differentiates from other interfaces.
	IsPs_covergroup_identifierContext()
}

type Ps_covergroup_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPs_covergroup_identifierContext() *Ps_covergroup_identifierContext {
	var p = new(Ps_covergroup_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_ps_covergroup_identifier
	return p
}

func (*Ps_covergroup_identifierContext) IsPs_covergroup_identifierContext() {}

func NewPs_covergroup_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Ps_covergroup_identifierContext {
	var p = new(Ps_covergroup_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_ps_covergroup_identifier

	return p
}

func (s *Ps_covergroup_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Ps_covergroup_identifierContext) Covergroup_identifier() ICovergroup_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICovergroup_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICovergroup_identifierContext)
}

func (s *Ps_covergroup_identifierContext) Package_scope() IPackage_scopeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackage_scopeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPackage_scopeContext)
}

func (s *Ps_covergroup_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ps_covergroup_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Ps_covergroup_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterPs_covergroup_identifier(s)
	}
}

func (s *Ps_covergroup_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitPs_covergroup_identifier(s)
	}
}

func (p *SystemVerilogParser) Ps_covergroup_identifier() (localctx IPs_covergroup_identifierContext) {
	this := p
	_ = this

	localctx = NewPs_covergroup_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1210, SystemVerilogParserRULE_ps_covergroup_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(7793)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 963, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(7792)
			p.Package_scope()
		}

	}
	{
		p.SetState(7795)
		p.Covergroup_identifier()
	}

	return localctx
}

// IPs_checker_identifierContext is an interface to support dynamic dispatch.
type IPs_checker_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPs_checker_identifierContext differentiates from other interfaces.
	IsPs_checker_identifierContext()
}

type Ps_checker_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPs_checker_identifierContext() *Ps_checker_identifierContext {
	var p = new(Ps_checker_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_ps_checker_identifier
	return p
}

func (*Ps_checker_identifierContext) IsPs_checker_identifierContext() {}

func NewPs_checker_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Ps_checker_identifierContext {
	var p = new(Ps_checker_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_ps_checker_identifier

	return p
}

func (s *Ps_checker_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Ps_checker_identifierContext) Checker_identifier() IChecker_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IChecker_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IChecker_identifierContext)
}

func (s *Ps_checker_identifierContext) Package_scope() IPackage_scopeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackage_scopeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPackage_scopeContext)
}

func (s *Ps_checker_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ps_checker_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Ps_checker_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterPs_checker_identifier(s)
	}
}

func (s *Ps_checker_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitPs_checker_identifier(s)
	}
}

func (p *SystemVerilogParser) Ps_checker_identifier() (localctx IPs_checker_identifierContext) {
	this := p
	_ = this

	localctx = NewPs_checker_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1212, SystemVerilogParserRULE_ps_checker_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(7798)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 964, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(7797)
			p.Package_scope()
		}

	}
	{
		p.SetState(7800)
		p.Checker_identifier()
	}

	return localctx
}

// IPs_identifierContext is an interface to support dynamic dispatch.
type IPs_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPs_identifierContext differentiates from other interfaces.
	IsPs_identifierContext()
}

type Ps_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPs_identifierContext() *Ps_identifierContext {
	var p = new(Ps_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_ps_identifier
	return p
}

func (*Ps_identifierContext) IsPs_identifierContext() {}

func NewPs_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Ps_identifierContext {
	var p = new(Ps_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_ps_identifier

	return p
}

func (s *Ps_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Ps_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Ps_identifierContext) Package_scope() IPackage_scopeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackage_scopeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPackage_scopeContext)
}

func (s *Ps_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ps_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Ps_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterPs_identifier(s)
	}
}

func (s *Ps_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitPs_identifier(s)
	}
}

func (p *SystemVerilogParser) Ps_identifier() (localctx IPs_identifierContext) {
	this := p
	_ = this

	localctx = NewPs_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1214, SystemVerilogParserRULE_ps_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(7803)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 965, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(7802)
			p.Package_scope()
		}

	}
	{
		p.SetState(7805)
		p.Identifier()
	}

	return localctx
}

// IPs_or_hierarchical_array_identifierContext is an interface to support dynamic dispatch.
type IPs_or_hierarchical_array_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPs_or_hierarchical_array_identifierContext differentiates from other interfaces.
	IsPs_or_hierarchical_array_identifierContext()
}

type Ps_or_hierarchical_array_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPs_or_hierarchical_array_identifierContext() *Ps_or_hierarchical_array_identifierContext {
	var p = new(Ps_or_hierarchical_array_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_ps_or_hierarchical_array_identifier
	return p
}

func (*Ps_or_hierarchical_array_identifierContext) IsPs_or_hierarchical_array_identifierContext() {}

func NewPs_or_hierarchical_array_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Ps_or_hierarchical_array_identifierContext {
	var p = new(Ps_or_hierarchical_array_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_ps_or_hierarchical_array_identifier

	return p
}

func (s *Ps_or_hierarchical_array_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Ps_or_hierarchical_array_identifierContext) Hierarchical_array_identifier() IHierarchical_array_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_array_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_array_identifierContext)
}

func (s *Ps_or_hierarchical_array_identifierContext) Implicit_class_handle() IImplicit_class_handleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImplicit_class_handleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImplicit_class_handleContext)
}

func (s *Ps_or_hierarchical_array_identifierContext) DOT() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserDOT, 0)
}

func (s *Ps_or_hierarchical_array_identifierContext) Class_scope() IClass_scopeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_scopeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClass_scopeContext)
}

func (s *Ps_or_hierarchical_array_identifierContext) Package_scope() IPackage_scopeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackage_scopeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPackage_scopeContext)
}

func (s *Ps_or_hierarchical_array_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ps_or_hierarchical_array_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Ps_or_hierarchical_array_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterPs_or_hierarchical_array_identifier(s)
	}
}

func (s *Ps_or_hierarchical_array_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitPs_or_hierarchical_array_identifier(s)
	}
}

func (p *SystemVerilogParser) Ps_or_hierarchical_array_identifier() (localctx IPs_or_hierarchical_array_identifierContext) {
	this := p
	_ = this

	localctx = NewPs_or_hierarchical_array_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1216, SystemVerilogParserRULE_ps_or_hierarchical_array_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(7812)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 966, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(7807)
			p.Implicit_class_handle()
		}
		{
			p.SetState(7808)
			p.Match(SystemVerilogParserDOT)
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 966, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(7810)
			p.Class_scope()
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 966, p.GetParserRuleContext()) == 3 {
		{
			p.SetState(7811)
			p.Package_scope()
		}

	}
	{
		p.SetState(7814)
		p.Hierarchical_array_identifier()
	}

	return localctx
}

// IPs_or_hierarchical_net_identifierContext is an interface to support dynamic dispatch.
type IPs_or_hierarchical_net_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPs_or_hierarchical_net_identifierContext differentiates from other interfaces.
	IsPs_or_hierarchical_net_identifierContext()
}

type Ps_or_hierarchical_net_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPs_or_hierarchical_net_identifierContext() *Ps_or_hierarchical_net_identifierContext {
	var p = new(Ps_or_hierarchical_net_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_ps_or_hierarchical_net_identifier
	return p
}

func (*Ps_or_hierarchical_net_identifierContext) IsPs_or_hierarchical_net_identifierContext() {}

func NewPs_or_hierarchical_net_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Ps_or_hierarchical_net_identifierContext {
	var p = new(Ps_or_hierarchical_net_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_ps_or_hierarchical_net_identifier

	return p
}

func (s *Ps_or_hierarchical_net_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Ps_or_hierarchical_net_identifierContext) Net_identifier() INet_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INet_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INet_identifierContext)
}

func (s *Ps_or_hierarchical_net_identifierContext) Package_scope() IPackage_scopeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackage_scopeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPackage_scopeContext)
}

func (s *Ps_or_hierarchical_net_identifierContext) Hierarchical_net_identifier() IHierarchical_net_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_net_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_net_identifierContext)
}

func (s *Ps_or_hierarchical_net_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ps_or_hierarchical_net_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Ps_or_hierarchical_net_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterPs_or_hierarchical_net_identifier(s)
	}
}

func (s *Ps_or_hierarchical_net_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitPs_or_hierarchical_net_identifier(s)
	}
}

func (p *SystemVerilogParser) Ps_or_hierarchical_net_identifier() (localctx IPs_or_hierarchical_net_identifierContext) {
	this := p
	_ = this

	localctx = NewPs_or_hierarchical_net_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1218, SystemVerilogParserRULE_ps_or_hierarchical_net_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(7821)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 968, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(7817)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 967, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7816)
				p.Package_scope()
			}

		}
		{
			p.SetState(7819)
			p.Net_identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7820)
			p.Hierarchical_net_identifier()
		}

	}

	return localctx
}

// IPs_or_hierarchical_property_identifierContext is an interface to support dynamic dispatch.
type IPs_or_hierarchical_property_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPs_or_hierarchical_property_identifierContext differentiates from other interfaces.
	IsPs_or_hierarchical_property_identifierContext()
}

type Ps_or_hierarchical_property_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPs_or_hierarchical_property_identifierContext() *Ps_or_hierarchical_property_identifierContext {
	var p = new(Ps_or_hierarchical_property_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_ps_or_hierarchical_property_identifier
	return p
}

func (*Ps_or_hierarchical_property_identifierContext) IsPs_or_hierarchical_property_identifierContext() {
}

func NewPs_or_hierarchical_property_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Ps_or_hierarchical_property_identifierContext {
	var p = new(Ps_or_hierarchical_property_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_ps_or_hierarchical_property_identifier

	return p
}

func (s *Ps_or_hierarchical_property_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Ps_or_hierarchical_property_identifierContext) Property_identifier() IProperty_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProperty_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProperty_identifierContext)
}

func (s *Ps_or_hierarchical_property_identifierContext) Package_scope() IPackage_scopeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackage_scopeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPackage_scopeContext)
}

func (s *Ps_or_hierarchical_property_identifierContext) Hierarchical_property_identifier() IHierarchical_property_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_property_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_property_identifierContext)
}

func (s *Ps_or_hierarchical_property_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ps_or_hierarchical_property_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Ps_or_hierarchical_property_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterPs_or_hierarchical_property_identifier(s)
	}
}

func (s *Ps_or_hierarchical_property_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitPs_or_hierarchical_property_identifier(s)
	}
}

func (p *SystemVerilogParser) Ps_or_hierarchical_property_identifier() (localctx IPs_or_hierarchical_property_identifierContext) {
	this := p
	_ = this

	localctx = NewPs_or_hierarchical_property_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1220, SystemVerilogParserRULE_ps_or_hierarchical_property_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(7828)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 970, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(7824)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 969, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7823)
				p.Package_scope()
			}

		}
		{
			p.SetState(7826)
			p.Property_identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7827)
			p.Hierarchical_property_identifier()
		}

	}

	return localctx
}

// IPs_or_hierarchical_sequence_identifierContext is an interface to support dynamic dispatch.
type IPs_or_hierarchical_sequence_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPs_or_hierarchical_sequence_identifierContext differentiates from other interfaces.
	IsPs_or_hierarchical_sequence_identifierContext()
}

type Ps_or_hierarchical_sequence_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPs_or_hierarchical_sequence_identifierContext() *Ps_or_hierarchical_sequence_identifierContext {
	var p = new(Ps_or_hierarchical_sequence_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_ps_or_hierarchical_sequence_identifier
	return p
}

func (*Ps_or_hierarchical_sequence_identifierContext) IsPs_or_hierarchical_sequence_identifierContext() {
}

func NewPs_or_hierarchical_sequence_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Ps_or_hierarchical_sequence_identifierContext {
	var p = new(Ps_or_hierarchical_sequence_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_ps_or_hierarchical_sequence_identifier

	return p
}

func (s *Ps_or_hierarchical_sequence_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Ps_or_hierarchical_sequence_identifierContext) Sequence_identifier() ISequence_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequence_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISequence_identifierContext)
}

func (s *Ps_or_hierarchical_sequence_identifierContext) Package_scope() IPackage_scopeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackage_scopeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPackage_scopeContext)
}

func (s *Ps_or_hierarchical_sequence_identifierContext) Hierarchical_sequence_identifier() IHierarchical_sequence_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_sequence_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_sequence_identifierContext)
}

func (s *Ps_or_hierarchical_sequence_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ps_or_hierarchical_sequence_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Ps_or_hierarchical_sequence_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterPs_or_hierarchical_sequence_identifier(s)
	}
}

func (s *Ps_or_hierarchical_sequence_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitPs_or_hierarchical_sequence_identifier(s)
	}
}

func (p *SystemVerilogParser) Ps_or_hierarchical_sequence_identifier() (localctx IPs_or_hierarchical_sequence_identifierContext) {
	this := p
	_ = this

	localctx = NewPs_or_hierarchical_sequence_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1222, SystemVerilogParserRULE_ps_or_hierarchical_sequence_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(7835)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 972, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(7831)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 971, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7830)
				p.Package_scope()
			}

		}
		{
			p.SetState(7833)
			p.Sequence_identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7834)
			p.Hierarchical_sequence_identifier()
		}

	}

	return localctx
}

// IPs_or_hierarchical_tf_identifierContext is an interface to support dynamic dispatch.
type IPs_or_hierarchical_tf_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPs_or_hierarchical_tf_identifierContext differentiates from other interfaces.
	IsPs_or_hierarchical_tf_identifierContext()
}

type Ps_or_hierarchical_tf_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPs_or_hierarchical_tf_identifierContext() *Ps_or_hierarchical_tf_identifierContext {
	var p = new(Ps_or_hierarchical_tf_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_ps_or_hierarchical_tf_identifier
	return p
}

func (*Ps_or_hierarchical_tf_identifierContext) IsPs_or_hierarchical_tf_identifierContext() {}

func NewPs_or_hierarchical_tf_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Ps_or_hierarchical_tf_identifierContext {
	var p = new(Ps_or_hierarchical_tf_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_ps_or_hierarchical_tf_identifier

	return p
}

func (s *Ps_or_hierarchical_tf_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Ps_or_hierarchical_tf_identifierContext) Tf_identifier() ITf_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITf_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITf_identifierContext)
}

func (s *Ps_or_hierarchical_tf_identifierContext) Package_scope() IPackage_scopeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackage_scopeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPackage_scopeContext)
}

func (s *Ps_or_hierarchical_tf_identifierContext) Hierarchical_tf_identifier() IHierarchical_tf_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHierarchical_tf_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHierarchical_tf_identifierContext)
}

func (s *Ps_or_hierarchical_tf_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ps_or_hierarchical_tf_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Ps_or_hierarchical_tf_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterPs_or_hierarchical_tf_identifier(s)
	}
}

func (s *Ps_or_hierarchical_tf_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitPs_or_hierarchical_tf_identifier(s)
	}
}

func (p *SystemVerilogParser) Ps_or_hierarchical_tf_identifier() (localctx IPs_or_hierarchical_tf_identifierContext) {
	this := p
	_ = this

	localctx = NewPs_or_hierarchical_tf_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1224, SystemVerilogParserRULE_ps_or_hierarchical_tf_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(7842)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 974, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(7838)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 973, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7837)
				p.Package_scope()
			}

		}
		{
			p.SetState(7840)
			p.Tf_identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7841)
			p.Hierarchical_tf_identifier()
		}

	}

	return localctx
}

// IPs_parameter_identifierContext is an interface to support dynamic dispatch.
type IPs_parameter_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPs_parameter_identifierContext differentiates from other interfaces.
	IsPs_parameter_identifierContext()
}

type Ps_parameter_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPs_parameter_identifierContext() *Ps_parameter_identifierContext {
	var p = new(Ps_parameter_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_ps_parameter_identifier
	return p
}

func (*Ps_parameter_identifierContext) IsPs_parameter_identifierContext() {}

func NewPs_parameter_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Ps_parameter_identifierContext {
	var p = new(Ps_parameter_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_ps_parameter_identifier

	return p
}

func (s *Ps_parameter_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Ps_parameter_identifierContext) Parameter_identifier() IParameter_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_identifierContext)
}

func (s *Ps_parameter_identifierContext) Package_scope() IPackage_scopeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackage_scopeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPackage_scopeContext)
}

func (s *Ps_parameter_identifierContext) Class_scope() IClass_scopeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_scopeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClass_scopeContext)
}

func (s *Ps_parameter_identifierContext) AllGenerate_block_identifier() []IGenerate_block_identifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IGenerate_block_identifierContext)(nil)).Elem())
	var tst = make([]IGenerate_block_identifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IGenerate_block_identifierContext)
		}
	}

	return tst
}

func (s *Ps_parameter_identifierContext) Generate_block_identifier(i int) IGenerate_block_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenerate_block_identifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IGenerate_block_identifierContext)
}

func (s *Ps_parameter_identifierContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserDOT)
}

func (s *Ps_parameter_identifierContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserDOT, i)
}

func (s *Ps_parameter_identifierContext) AllLB() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserLB)
}

func (s *Ps_parameter_identifierContext) LB(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserLB, i)
}

func (s *Ps_parameter_identifierContext) AllConstant_expression() []IConstant_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem())
	var tst = make([]IConstant_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConstant_expressionContext)
		}
	}

	return tst
}

func (s *Ps_parameter_identifierContext) Constant_expression(i int) IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Ps_parameter_identifierContext) AllRB() []antlr.TerminalNode {
	return s.GetTokens(SystemVerilogParserRB)
}

func (s *Ps_parameter_identifierContext) RB(i int) antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserRB, i)
}

func (s *Ps_parameter_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ps_parameter_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Ps_parameter_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterPs_parameter_identifier(s)
	}
}

func (s *Ps_parameter_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitPs_parameter_identifier(s)
	}
}

func (p *SystemVerilogParser) Ps_parameter_identifier() (localctx IPs_parameter_identifierContext) {
	this := p
	_ = this

	localctx = NewPs_parameter_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1226, SystemVerilogParserRULE_ps_parameter_identifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(7864)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 978, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(7846)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 975, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7844)
				p.Package_scope()
			}

		} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 975, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(7845)
				p.Class_scope()
			}

		}
		{
			p.SetState(7848)
			p.Parameter_identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(7860)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 977, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(7849)
					p.Generate_block_identifier()
				}
				p.SetState(7854)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == SystemVerilogParserLB {
					{
						p.SetState(7850)
						p.Match(SystemVerilogParserLB)
					}
					{
						p.SetState(7851)
						p.constant_expression(0)
					}
					{
						p.SetState(7852)
						p.Match(SystemVerilogParserRB)
					}

				}
				{
					p.SetState(7856)
					p.Match(SystemVerilogParserDOT)
				}

			}
			p.SetState(7862)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 977, p.GetParserRuleContext())
		}
		{
			p.SetState(7863)
			p.Parameter_identifier()
		}

	}

	return localctx
}

// IPs_type_identifierContext is an interface to support dynamic dispatch.
type IPs_type_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPs_type_identifierContext differentiates from other interfaces.
	IsPs_type_identifierContext()
}

type Ps_type_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPs_type_identifierContext() *Ps_type_identifierContext {
	var p = new(Ps_type_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_ps_type_identifier
	return p
}

func (*Ps_type_identifierContext) IsPs_type_identifierContext() {}

func NewPs_type_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Ps_type_identifierContext {
	var p = new(Ps_type_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_ps_type_identifier

	return p
}

func (s *Ps_type_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Ps_type_identifierContext) Type_identifier() IType_identifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_identifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_identifierContext)
}

func (s *Ps_type_identifierContext) KLOCAL() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserKLOCAL, 0)
}

func (s *Ps_type_identifierContext) COLONCOLON() antlr.TerminalNode {
	return s.GetToken(SystemVerilogParserCOLONCOLON, 0)
}

func (s *Ps_type_identifierContext) Package_scope() IPackage_scopeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackage_scopeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPackage_scopeContext)
}

func (s *Ps_type_identifierContext) Class_scope() IClass_scopeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_scopeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClass_scopeContext)
}

func (s *Ps_type_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ps_type_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Ps_type_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterPs_type_identifier(s)
	}
}

func (s *Ps_type_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitPs_type_identifier(s)
	}
}

func (p *SystemVerilogParser) Ps_type_identifier() (localctx IPs_type_identifierContext) {
	this := p
	_ = this

	localctx = NewPs_type_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1228, SystemVerilogParserRULE_ps_type_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(7870)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 979, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(7866)
			p.Match(SystemVerilogParserKLOCAL)
		}
		{
			p.SetState(7867)
			p.Match(SystemVerilogParserCOLONCOLON)
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 979, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(7868)
			p.Package_scope()
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 979, p.GetParserRuleContext()) == 3 {
		{
			p.SetState(7869)
			p.Class_scope()
		}

	}
	{
		p.SetState(7872)
		p.Type_identifier()
	}

	return localctx
}

// ISequence_identifierContext is an interface to support dynamic dispatch.
type ISequence_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSequence_identifierContext differentiates from other interfaces.
	IsSequence_identifierContext()
}

type Sequence_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySequence_identifierContext() *Sequence_identifierContext {
	var p = new(Sequence_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_sequence_identifier
	return p
}

func (*Sequence_identifierContext) IsSequence_identifierContext() {}

func NewSequence_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sequence_identifierContext {
	var p = new(Sequence_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_sequence_identifier

	return p
}

func (s *Sequence_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Sequence_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Sequence_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sequence_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sequence_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterSequence_identifier(s)
	}
}

func (s *Sequence_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitSequence_identifier(s)
	}
}

func (p *SystemVerilogParser) Sequence_identifier() (localctx ISequence_identifierContext) {
	this := p
	_ = this

	localctx = NewSequence_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1230, SystemVerilogParserRULE_sequence_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7874)
		p.Identifier()
	}

	return localctx
}

// ISignal_identifierContext is an interface to support dynamic dispatch.
type ISignal_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSignal_identifierContext differentiates from other interfaces.
	IsSignal_identifierContext()
}

type Signal_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySignal_identifierContext() *Signal_identifierContext {
	var p = new(Signal_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_signal_identifier
	return p
}

func (*Signal_identifierContext) IsSignal_identifierContext() {}

func NewSignal_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Signal_identifierContext {
	var p = new(Signal_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_signal_identifier

	return p
}

func (s *Signal_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Signal_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Signal_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Signal_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Signal_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterSignal_identifier(s)
	}
}

func (s *Signal_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitSignal_identifier(s)
	}
}

func (p *SystemVerilogParser) Signal_identifier() (localctx ISignal_identifierContext) {
	this := p
	_ = this

	localctx = NewSignal_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1232, SystemVerilogParserRULE_signal_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7876)
		p.Identifier()
	}

	return localctx
}

// ISpecparam_identifierContext is an interface to support dynamic dispatch.
type ISpecparam_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSpecparam_identifierContext differentiates from other interfaces.
	IsSpecparam_identifierContext()
}

type Specparam_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpecparam_identifierContext() *Specparam_identifierContext {
	var p = new(Specparam_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_specparam_identifier
	return p
}

func (*Specparam_identifierContext) IsSpecparam_identifierContext() {}

func NewSpecparam_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Specparam_identifierContext {
	var p = new(Specparam_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_specparam_identifier

	return p
}

func (s *Specparam_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Specparam_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Specparam_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Specparam_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Specparam_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterSpecparam_identifier(s)
	}
}

func (s *Specparam_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitSpecparam_identifier(s)
	}
}

func (p *SystemVerilogParser) Specparam_identifier() (localctx ISpecparam_identifierContext) {
	this := p
	_ = this

	localctx = NewSpecparam_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1234, SystemVerilogParserRULE_specparam_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7878)
		p.Identifier()
	}

	return localctx
}

// ITask_identifierContext is an interface to support dynamic dispatch.
type ITask_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTask_identifierContext differentiates from other interfaces.
	IsTask_identifierContext()
}

type Task_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTask_identifierContext() *Task_identifierContext {
	var p = new(Task_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_task_identifier
	return p
}

func (*Task_identifierContext) IsTask_identifierContext() {}

func NewTask_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Task_identifierContext {
	var p = new(Task_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_task_identifier

	return p
}

func (s *Task_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Task_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Task_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Task_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Task_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterTask_identifier(s)
	}
}

func (s *Task_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitTask_identifier(s)
	}
}

func (p *SystemVerilogParser) Task_identifier() (localctx ITask_identifierContext) {
	this := p
	_ = this

	localctx = NewTask_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1236, SystemVerilogParserRULE_task_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7880)
		p.Identifier()
	}

	return localctx
}

// ITf_identifierContext is an interface to support dynamic dispatch.
type ITf_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTf_identifierContext differentiates from other interfaces.
	IsTf_identifierContext()
}

type Tf_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTf_identifierContext() *Tf_identifierContext {
	var p = new(Tf_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_tf_identifier
	return p
}

func (*Tf_identifierContext) IsTf_identifierContext() {}

func NewTf_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tf_identifierContext {
	var p = new(Tf_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_tf_identifier

	return p
}

func (s *Tf_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Tf_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Tf_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tf_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tf_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterTf_identifier(s)
	}
}

func (s *Tf_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitTf_identifier(s)
	}
}

func (p *SystemVerilogParser) Tf_identifier() (localctx ITf_identifierContext) {
	this := p
	_ = this

	localctx = NewTf_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1238, SystemVerilogParserRULE_tf_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7882)
		p.Identifier()
	}

	return localctx
}

// ITopmodule_identifierContext is an interface to support dynamic dispatch.
type ITopmodule_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTopmodule_identifierContext differentiates from other interfaces.
	IsTopmodule_identifierContext()
}

type Topmodule_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTopmodule_identifierContext() *Topmodule_identifierContext {
	var p = new(Topmodule_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_topmodule_identifier
	return p
}

func (*Topmodule_identifierContext) IsTopmodule_identifierContext() {}

func NewTopmodule_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Topmodule_identifierContext {
	var p = new(Topmodule_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_topmodule_identifier

	return p
}

func (s *Topmodule_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Topmodule_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Topmodule_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Topmodule_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Topmodule_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterTopmodule_identifier(s)
	}
}

func (s *Topmodule_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitTopmodule_identifier(s)
	}
}

func (p *SystemVerilogParser) Topmodule_identifier() (localctx ITopmodule_identifierContext) {
	this := p
	_ = this

	localctx = NewTopmodule_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1240, SystemVerilogParserRULE_topmodule_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7884)
		p.Identifier()
	}

	return localctx
}

// IType_identifierContext is an interface to support dynamic dispatch.
type IType_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsType_identifierContext differentiates from other interfaces.
	IsType_identifierContext()
}

type Type_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_identifierContext() *Type_identifierContext {
	var p = new(Type_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_type_identifier
	return p
}

func (*Type_identifierContext) IsType_identifierContext() {}

func NewType_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_identifierContext {
	var p = new(Type_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_type_identifier

	return p
}

func (s *Type_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Type_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterType_identifier(s)
	}
}

func (s *Type_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitType_identifier(s)
	}
}

func (p *SystemVerilogParser) Type_identifier() (localctx IType_identifierContext) {
	this := p
	_ = this

	localctx = NewType_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1242, SystemVerilogParserRULE_type_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7886)
		p.Identifier()
	}

	return localctx
}

// IVariable_identifierContext is an interface to support dynamic dispatch.
type IVariable_identifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariable_identifierContext differentiates from other interfaces.
	IsVariable_identifierContext()
}

type Variable_identifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariable_identifierContext() *Variable_identifierContext {
	var p = new(Variable_identifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SystemVerilogParserRULE_variable_identifier
	return p
}

func (*Variable_identifierContext) IsVariable_identifierContext() {}

func NewVariable_identifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Variable_identifierContext {
	var p = new(Variable_identifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SystemVerilogParserRULE_variable_identifier

	return p
}

func (s *Variable_identifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Variable_identifierContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Variable_identifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Variable_identifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Variable_identifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.EnterVariable_identifier(s)
	}
}

func (s *Variable_identifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SystemVerilogParserListener); ok {
		listenerT.ExitVariable_identifier(s)
	}
}

func (p *SystemVerilogParser) Variable_identifier() (localctx IVariable_identifierContext) {
	this := p
	_ = this

	localctx = NewVariable_identifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1244, SystemVerilogParserRULE_variable_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7888)
		p.Identifier()
	}

	return localctx
}

func (p *SystemVerilogParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 224:
		var t *Property_exprContext = nil
		if localctx != nil {
			t = localctx.(*Property_exprContext)
		}
		return p.Property_expr_Sempred(t, predIndex)

	case 231:
		var t *Sequence_exprContext = nil
		if localctx != nil {
			t = localctx.(*Sequence_exprContext)
		}
		return p.Sequence_expr_Sempred(t, predIndex)

	case 252:
		var t *Block_event_expressionContext = nil
		if localctx != nil {
			t = localctx.(*Block_event_expressionContext)
		}
		return p.Block_event_expression_Sempred(t, predIndex)

	case 270:
		var t *Select_expressionContext = nil
		if localctx != nil {
			t = localctx.(*Select_expressionContext)
		}
		return p.Select_expression_Sempred(t, predIndex)

	case 367:
		var t *Event_expressionContext = nil
		if localctx != nil {
			t = localctx.(*Event_expressionContext)
		}
		return p.Event_expression_Sempred(t, predIndex)

	case 507:
		var t *Constant_expressionContext = nil
		if localctx != nil {
			t = localctx.(*Constant_expressionContext)
		}
		return p.Constant_expression_Sempred(t, predIndex)

	case 515:
		var t *ExpressionContext = nil
		if localctx != nil {
			t = localctx.(*ExpressionContext)
		}
		return p.Expression_Sempred(t, predIndex)

	case 518:
		var t *Module_path_expressionContext = nil
		if localctx != nil {
			t = localctx.(*Module_path_expressionContext)
		}
		return p.Module_path_expression_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *SystemVerilogParser) Property_expr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 9)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SystemVerilogParser) Sequence_expr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 1:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 2:
		return p.Precpred(p.GetParserRuleContext(), 7)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SystemVerilogParser) Block_event_expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 3:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SystemVerilogParser) Select_expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 4:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 5:
		return p.Precpred(p.GetParserRuleContext(), 3)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SystemVerilogParser) Event_expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 6:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SystemVerilogParser) Constant_expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 7:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SystemVerilogParser) Expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 8:
		return p.Precpred(p.GetParserRuleContext(), 4)

	case 9:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 10:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SystemVerilogParser) Module_path_expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 11:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 12:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
