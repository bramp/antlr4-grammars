// Code generated from Scala.g4 by ANTLR 4.9.3. DO NOT EDIT.

package scala // Scala
import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 80, 1446,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4,
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55,
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9,
	60, 4, 61, 9, 61, 4, 62, 9, 62, 4, 63, 9, 63, 4, 64, 9, 64, 4, 65, 9, 65,
	4, 66, 9, 66, 4, 67, 9, 67, 4, 68, 9, 68, 4, 69, 9, 69, 4, 70, 9, 70, 4,
	71, 9, 71, 4, 72, 9, 72, 4, 73, 9, 73, 4, 74, 9, 74, 4, 75, 9, 75, 4, 76,
	9, 76, 4, 77, 9, 77, 4, 78, 9, 78, 4, 79, 9, 79, 4, 80, 9, 80, 4, 81, 9,
	81, 4, 82, 9, 82, 4, 83, 9, 83, 4, 84, 9, 84, 4, 85, 9, 85, 4, 86, 9, 86,
	4, 87, 9, 87, 4, 88, 9, 88, 4, 89, 9, 89, 4, 90, 9, 90, 4, 91, 9, 91, 4,
	92, 9, 92, 4, 93, 9, 93, 4, 94, 9, 94, 4, 95, 9, 95, 4, 96, 9, 96, 4, 97,
	9, 97, 4, 98, 9, 98, 4, 99, 9, 99, 4, 100, 9, 100, 4, 101, 9, 101, 4, 102,
	9, 102, 4, 103, 9, 103, 4, 104, 9, 104, 4, 105, 9, 105, 4, 106, 9, 106,
	4, 107, 9, 107, 3, 2, 5, 2, 216, 10, 2, 3, 2, 3, 2, 5, 2, 220, 10, 2, 3,
	2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 5, 2, 228, 10, 2, 3, 3, 3, 3, 3, 3, 7,
	3, 233, 10, 3, 12, 3, 14, 3, 236, 11, 3, 3, 4, 3, 4, 3, 4, 7, 4, 241, 10,
	4, 12, 4, 14, 4, 244, 11, 4, 3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 250, 10, 5,
	3, 5, 3, 5, 3, 5, 5, 5, 255, 10, 5, 3, 5, 3, 5, 5, 5, 259, 10, 5, 5, 5,
	261, 10, 5, 3, 5, 3, 5, 3, 5, 7, 5, 266, 10, 5, 12, 5, 14, 5, 269, 11,
	5, 3, 6, 3, 6, 3, 6, 3, 6, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 5, 7, 281,
	10, 7, 5, 7, 283, 10, 7, 3, 8, 3, 8, 3, 8, 3, 8, 3, 8, 7, 8, 290, 10, 8,
	12, 8, 14, 8, 293, 11, 8, 5, 8, 295, 10, 8, 3, 8, 5, 8, 298, 10, 8, 3,
	9, 3, 9, 3, 9, 6, 9, 303, 10, 9, 13, 9, 14, 9, 304, 3, 9, 3, 9, 3, 10,
	3, 10, 3, 10, 3, 10, 5, 10, 313, 10, 10, 3, 11, 3, 11, 3, 11, 7, 11, 318,
	10, 11, 12, 11, 14, 11, 321, 11, 11, 3, 12, 3, 12, 3, 12, 7, 12, 326, 10,
	12, 12, 12, 14, 12, 329, 11, 12, 3, 12, 5, 12, 332, 10, 12, 3, 12, 5, 12,
	335, 10, 12, 3, 13, 3, 13, 7, 13, 339, 10, 13, 12, 13, 14, 13, 342, 11,
	13, 3, 14, 3, 14, 3, 14, 3, 14, 5, 14, 348, 10, 14, 3, 14, 3, 14, 3, 14,
	3, 14, 5, 14, 354, 10, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 7, 14, 361,
	10, 14, 12, 14, 14, 14, 364, 11, 14, 3, 15, 3, 15, 3, 15, 3, 15, 3, 16,
	3, 16, 3, 16, 7, 16, 373, 10, 16, 12, 16, 14, 16, 376, 11, 16, 3, 17, 5,
	17, 379, 10, 17, 3, 17, 3, 17, 6, 17, 383, 10, 17, 13, 17, 14, 17, 384,
	3, 17, 3, 17, 3, 18, 3, 18, 3, 18, 5, 18, 392, 10, 18, 3, 19, 3, 19, 3,
	20, 3, 20, 3, 20, 3, 20, 6, 20, 400, 10, 20, 13, 20, 14, 20, 401, 3, 20,
	3, 20, 3, 20, 5, 20, 407, 10, 20, 3, 21, 3, 21, 5, 21, 411, 10, 21, 3,
	21, 3, 21, 5, 21, 415, 10, 21, 3, 21, 3, 21, 3, 21, 5, 21, 420, 10, 21,
	3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 7, 22, 427, 10, 22, 12, 22, 14, 22,
	430, 11, 22, 3, 22, 3, 22, 3, 22, 5, 22, 435, 10, 22, 3, 22, 3, 22, 3,
	22, 3, 22, 3, 22, 7, 22, 442, 10, 22, 12, 22, 14, 22, 445, 11, 22, 3, 22,
	3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 5, 22, 453, 10, 22, 3, 22, 3, 22, 5,
	22, 457, 10, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22,
	3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 5, 22, 475, 10,
	22, 3, 22, 5, 22, 478, 10, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22,
	5, 22, 486, 10, 22, 3, 22, 3, 22, 3, 22, 5, 22, 491, 10, 22, 5, 22, 493,
	10, 22, 3, 22, 3, 22, 5, 22, 497, 10, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3,
	22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 5, 22, 509, 10, 22, 3, 22, 3, 22,
	3, 22, 3, 22, 3, 22, 3, 22, 5, 22, 517, 10, 22, 3, 23, 3, 23, 3, 24, 3,
	24, 5, 24, 523, 10, 24, 3, 24, 3, 24, 3, 24, 7, 24, 528, 10, 24, 12, 24,
	14, 24, 531, 11, 24, 3, 24, 5, 24, 534, 10, 24, 3, 25, 3, 25, 3, 25, 3,
	25, 3, 25, 3, 25, 5, 25, 542, 10, 25, 3, 25, 7, 25, 545, 10, 25, 12, 25,
	14, 25, 548, 11, 25, 3, 26, 5, 26, 551, 10, 26, 3, 26, 3, 26, 3, 26, 5,
	26, 556, 10, 26, 5, 26, 558, 10, 26, 3, 27, 3, 27, 3, 27, 5, 27, 563, 10,
	27, 3, 27, 5, 27, 566, 10, 27, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28,
	5, 28, 574, 10, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3,
	28, 5, 28, 584, 10, 28, 3, 28, 3, 28, 5, 28, 588, 10, 28, 3, 28, 3, 28,
	3, 28, 3, 28, 5, 28, 594, 10, 28, 3, 28, 3, 28, 3, 28, 7, 28, 599, 10,
	28, 12, 28, 14, 28, 602, 11, 28, 3, 29, 3, 29, 3, 29, 7, 29, 607, 10, 29,
	12, 29, 14, 29, 610, 11, 29, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30,
	3, 30, 3, 30, 3, 30, 5, 30, 621, 10, 30, 3, 30, 5, 30, 624, 10, 30, 3,
	31, 5, 31, 627, 10, 31, 3, 31, 3, 31, 3, 31, 5, 31, 632, 10, 31, 3, 31,
	3, 31, 5, 31, 636, 10, 31, 5, 31, 638, 10, 31, 3, 32, 3, 32, 3, 32, 3,
	32, 3, 32, 3, 32, 3, 32, 3, 32, 5, 32, 648, 10, 32, 3, 33, 6, 33, 651,
	10, 33, 13, 33, 14, 33, 652, 3, 33, 5, 33, 656, 10, 33, 3, 34, 3, 34, 7,
	34, 660, 10, 34, 12, 34, 14, 34, 663, 11, 34, 3, 34, 5, 34, 666, 10, 34,
	3, 34, 3, 34, 7, 34, 670, 10, 34, 12, 34, 14, 34, 673, 11, 34, 3, 34, 7,
	34, 676, 10, 34, 12, 34, 14, 34, 679, 11, 34, 3, 34, 3, 34, 5, 34, 683,
	10, 34, 3, 35, 3, 35, 3, 35, 5, 35, 688, 10, 35, 3, 35, 3, 35, 5, 35, 692,
	10, 35, 3, 35, 3, 35, 5, 35, 696, 10, 35, 3, 35, 3, 35, 3, 35, 5, 35, 701,
	10, 35, 3, 36, 6, 36, 704, 10, 36, 13, 36, 14, 36, 705, 3, 37, 3, 37, 3,
	37, 3, 37, 3, 37, 3, 37, 3, 37, 3, 37, 7, 37, 716, 10, 37, 12, 37, 14,
	37, 719, 11, 37, 3, 38, 6, 38, 722, 10, 38, 13, 38, 14, 38, 723, 3, 39,
	3, 39, 3, 39, 5, 39, 729, 10, 39, 3, 39, 3, 39, 3, 39, 3, 40, 3, 40, 3,
	40, 3, 41, 3, 41, 3, 41, 7, 41, 740, 10, 41, 12, 41, 14, 41, 743, 11, 41,
	3, 42, 3, 42, 3, 42, 3, 42, 5, 42, 749, 10, 42, 3, 43, 3, 43, 3, 43, 5,
	43, 754, 10, 43, 3, 43, 5, 43, 757, 10, 43, 3, 44, 3, 44, 3, 44, 3, 44,
	5, 44, 763, 10, 44, 3, 44, 7, 44, 766, 10, 44, 12, 44, 14, 44, 769, 11,
	44, 5, 44, 771, 10, 44, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 5, 45,
	779, 10, 45, 3, 45, 5, 45, 782, 10, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3,
	45, 5, 45, 789, 10, 45, 3, 45, 3, 45, 5, 45, 793, 10, 45, 3, 45, 3, 45,
	3, 45, 3, 45, 3, 45, 3, 45, 5, 45, 801, 10, 45, 3, 45, 5, 45, 804, 10,
	45, 3, 46, 3, 46, 3, 46, 5, 46, 809, 10, 46, 3, 46, 3, 46, 5, 46, 813,
	10, 46, 3, 47, 3, 47, 3, 47, 3, 47, 7, 47, 819, 10, 47, 12, 47, 14, 47,
	822, 11, 47, 3, 47, 3, 47, 3, 48, 3, 48, 3, 48, 3, 48, 7, 48, 830, 10,
	48, 12, 48, 14, 48, 833, 11, 48, 3, 48, 3, 48, 3, 49, 7, 49, 838, 10, 49,
	12, 49, 14, 49, 841, 11, 49, 3, 49, 5, 49, 844, 10, 49, 3, 49, 3, 49, 3,
	50, 3, 50, 5, 50, 850, 10, 50, 3, 50, 3, 50, 5, 50, 854, 10, 50, 3, 50,
	3, 50, 5, 50, 858, 10, 50, 3, 50, 3, 50, 7, 50, 862, 10, 50, 12, 50, 14,
	50, 865, 11, 50, 3, 50, 3, 50, 7, 50, 869, 10, 50, 12, 50, 14, 50, 872,
	11, 50, 3, 51, 7, 51, 875, 10, 51, 12, 51, 14, 51, 878, 11, 51, 3, 51,
	5, 51, 881, 10, 51, 3, 51, 3, 51, 3, 51, 3, 51, 3, 51, 5, 51, 888, 10,
	51, 3, 52, 5, 52, 891, 10, 52, 3, 52, 3, 52, 5, 52, 895, 10, 52, 3, 52,
	3, 52, 3, 53, 3, 53, 3, 53, 7, 53, 902, 10, 53, 12, 53, 14, 53, 905, 11,
	53, 3, 54, 7, 54, 908, 10, 54, 12, 54, 14, 54, 911, 11, 54, 3, 54, 3, 54,
	3, 54, 5, 54, 916, 10, 54, 3, 54, 3, 54, 5, 54, 920, 10, 54, 3, 55, 3,
	55, 3, 55, 3, 55, 3, 55, 3, 55, 5, 55, 928, 10, 55, 3, 56, 7, 56, 931,
	10, 56, 12, 56, 14, 56, 934, 11, 56, 3, 56, 5, 56, 937, 10, 56, 3, 56,
	3, 56, 3, 56, 3, 56, 3, 56, 5, 56, 944, 10, 56, 3, 57, 5, 57, 947, 10,
	57, 3, 57, 3, 57, 5, 57, 951, 10, 57, 3, 57, 3, 57, 3, 58, 3, 58, 3, 58,
	7, 58, 958, 10, 58, 12, 58, 14, 58, 961, 11, 58, 3, 59, 7, 59, 964, 10,
	59, 12, 59, 14, 59, 967, 11, 59, 3, 59, 7, 59, 970, 10, 59, 12, 59, 14,
	59, 973, 11, 59, 3, 59, 5, 59, 976, 10, 59, 3, 59, 3, 59, 3, 59, 3, 59,
	3, 59, 5, 59, 983, 10, 59, 3, 60, 3, 60, 3, 60, 3, 60, 7, 60, 989, 10,
	60, 12, 60, 14, 60, 992, 11, 60, 3, 60, 3, 60, 3, 61, 3, 61, 3, 61, 5,
	61, 999, 10, 61, 3, 62, 3, 62, 3, 62, 5, 62, 1004, 10, 62, 3, 63, 3, 63,
	3, 64, 3, 64, 5, 64, 1010, 10, 64, 3, 65, 3, 65, 3, 65, 3, 65, 3, 66, 3,
	66, 3, 66, 7, 66, 1019, 10, 66, 12, 66, 14, 66, 1022, 11, 66, 3, 67, 3,
	67, 3, 67, 3, 67, 3, 68, 5, 68, 1029, 10, 68, 3, 68, 3, 68, 5, 68, 1033,
	10, 68, 3, 68, 6, 68, 1036, 10, 68, 13, 68, 14, 68, 1037, 3, 68, 3, 68,
	3, 69, 3, 69, 3, 69, 5, 69, 1045, 10, 69, 7, 69, 1047, 10, 69, 12, 69,
	14, 69, 1050, 11, 69, 3, 69, 7, 69, 1053, 10, 69, 12, 69, 14, 69, 1056,
	11, 69, 3, 69, 3, 69, 3, 69, 5, 69, 1061, 10, 69, 7, 69, 1063, 10, 69,
	12, 69, 14, 69, 1066, 11, 69, 3, 69, 7, 69, 1069, 10, 69, 12, 69, 14, 69,
	1072, 11, 69, 3, 69, 3, 69, 5, 69, 1076, 10, 69, 3, 70, 3, 70, 3, 70, 5,
	70, 1081, 10, 70, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 5, 70, 1089,
	10, 70, 3, 71, 3, 71, 3, 71, 3, 71, 7, 71, 1095, 10, 71, 12, 71, 14, 71,
	1098, 11, 71, 3, 72, 3, 72, 3, 72, 3, 72, 3, 72, 5, 72, 1105, 10, 72, 5,
	72, 1107, 10, 72, 3, 73, 3, 73, 3, 73, 3, 73, 7, 73, 1113, 10, 73, 12,
	73, 14, 73, 1116, 11, 73, 3, 73, 3, 73, 5, 73, 1120, 10, 73, 3, 73, 3,
	73, 3, 74, 3, 74, 3, 74, 5, 74, 1127, 10, 74, 3, 75, 3, 75, 3, 75, 3, 75,
	3, 75, 3, 75, 3, 75, 3, 75, 7, 75, 1137, 10, 75, 12, 75, 14, 75, 1140,
	11, 75, 3, 75, 5, 75, 1143, 10, 75, 3, 76, 3, 76, 3, 76, 3, 76, 3, 77,
	3, 77, 3, 77, 3, 77, 3, 78, 3, 78, 3, 78, 5, 78, 1156, 10, 78, 3, 79, 3,
	79, 5, 79, 1160, 10, 79, 3, 79, 3, 79, 3, 80, 3, 80, 5, 80, 1166, 10, 80,
	3, 80, 3, 80, 5, 80, 1170, 10, 80, 3, 80, 3, 80, 5, 80, 1174, 10, 80, 3,
	81, 3, 81, 3, 81, 3, 81, 5, 81, 1180, 10, 81, 3, 82, 3, 82, 3, 82, 3, 82,
	3, 82, 7, 82, 1187, 10, 82, 12, 82, 14, 82, 1190, 11, 82, 3, 82, 3, 82,
	5, 82, 1194, 10, 82, 3, 83, 3, 83, 3, 83, 7, 83, 1199, 10, 83, 12, 83,
	14, 83, 1202, 11, 83, 3, 83, 3, 83, 5, 83, 1206, 10, 83, 3, 83, 3, 83,
	3, 83, 3, 84, 3, 84, 3, 84, 3, 84, 3, 84, 3, 84, 3, 84, 5, 84, 1218, 10,
	84, 3, 85, 3, 85, 3, 85, 5, 85, 1223, 10, 85, 3, 85, 3, 85, 3, 85, 3, 85,
	3, 85, 5, 85, 1230, 10, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3,
	85, 3, 85, 3, 85, 3, 85, 5, 85, 1242, 10, 85, 3, 85, 5, 85, 1245, 10, 85,
	5, 85, 1247, 10, 85, 3, 86, 3, 86, 5, 86, 1251, 10, 86, 3, 86, 3, 86, 3,
	86, 3, 87, 5, 87, 1257, 10, 87, 3, 87, 3, 87, 3, 87, 5, 87, 1262, 10, 87,
	3, 87, 3, 87, 3, 87, 3, 87, 5, 87, 1268, 10, 87, 3, 88, 3, 88, 5, 88, 1272,
	10, 88, 3, 88, 7, 88, 1275, 10, 88, 12, 88, 14, 88, 1278, 11, 88, 3, 88,
	5, 88, 1281, 10, 88, 3, 88, 3, 88, 3, 88, 3, 89, 3, 89, 5, 89, 1288, 10,
	89, 3, 89, 3, 89, 3, 90, 3, 90, 3, 90, 3, 91, 3, 91, 3, 91, 5, 91, 1298,
	10, 91, 3, 91, 5, 91, 1301, 10, 91, 5, 91, 1303, 10, 91, 3, 92, 3, 92,
	3, 92, 5, 92, 1308, 10, 92, 3, 92, 5, 92, 1311, 10, 92, 5, 92, 1313, 10,
	92, 3, 93, 5, 93, 1316, 10, 93, 3, 93, 3, 93, 5, 93, 1320, 10, 93, 3, 94,
	5, 94, 1323, 10, 94, 3, 94, 3, 94, 5, 94, 1327, 10, 94, 3, 95, 3, 95, 3,
	95, 7, 95, 1332, 10, 95, 12, 95, 14, 95, 1335, 11, 95, 3, 96, 3, 96, 3,
	96, 7, 96, 1340, 10, 96, 12, 96, 14, 96, 1343, 11, 96, 3, 97, 3, 97, 7,
	97, 1347, 10, 97, 12, 97, 14, 97, 1350, 11, 97, 3, 98, 3, 98, 6, 98, 1354,
	10, 98, 13, 98, 14, 98, 1355, 3, 98, 3, 98, 3, 98, 3, 99, 3, 99, 5, 99,
	1363, 10, 99, 7, 99, 1365, 10, 99, 12, 99, 14, 99, 1368, 11, 99, 3, 99,
	7, 99, 1371, 10, 99, 12, 99, 14, 99, 1374, 11, 99, 3, 99, 3, 99, 3, 100,
	3, 100, 5, 100, 1380, 10, 100, 3, 101, 3, 101, 3, 101, 7, 101, 1385, 10,
	101, 12, 101, 14, 101, 1388, 11, 101, 3, 101, 3, 101, 3, 102, 3, 102, 6,
	102, 1394, 10, 102, 13, 102, 14, 102, 1395, 3, 103, 6, 103, 1399, 10, 103,
	13, 103, 14, 103, 1400, 3, 104, 3, 104, 5, 104, 1405, 10, 104, 7, 104,
	1407, 10, 104, 12, 104, 14, 104, 1410, 11, 104, 3, 104, 7, 104, 1413, 10,
	104, 12, 104, 14, 104, 1416, 11, 104, 3, 104, 3, 104, 3, 104, 3, 104, 5,
	104, 1422, 10, 104, 3, 105, 3, 105, 3, 105, 5, 105, 1427, 10, 105, 3, 105,
	3, 105, 3, 105, 3, 105, 3, 106, 3, 106, 3, 106, 3, 106, 3, 107, 3, 107,
	7, 107, 1439, 10, 107, 12, 107, 14, 107, 1442, 11, 107, 3, 107, 3, 107,
	3, 107, 2, 6, 8, 26, 48, 54, 108, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22,
	24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58,
	60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94,
	96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124,
	126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150, 152, 154,
	156, 158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180, 182, 184,
	186, 188, 190, 192, 194, 196, 198, 200, 202, 204, 206, 208, 210, 212, 2,
	12, 4, 2, 3, 3, 38, 40, 3, 2, 21, 23, 4, 2, 24, 24, 42, 42, 5, 2, 22, 22,
	64, 64, 72, 72, 4, 2, 3, 3, 38, 38, 4, 2, 22, 22, 64, 64, 4, 2, 18, 18,
	50, 50, 5, 2, 24, 24, 42, 42, 52, 54, 3, 2, 55, 56, 4, 2, 7, 7, 64, 64,
	2, 1588, 2, 227, 3, 2, 2, 2, 4, 229, 3, 2, 2, 2, 6, 237, 3, 2, 2, 2, 8,
	260, 3, 2, 2, 2, 10, 270, 3, 2, 2, 2, 12, 282, 3, 2, 2, 2, 14, 297, 3,
	2, 2, 2, 16, 299, 3, 2, 2, 2, 18, 312, 3, 2, 2, 2, 20, 314, 3, 2, 2, 2,
	22, 334, 3, 2, 2, 2, 24, 336, 3, 2, 2, 2, 26, 353, 3, 2, 2, 2, 28, 365,
	3, 2, 2, 2, 30, 369, 3, 2, 2, 2, 32, 378, 3, 2, 2, 2, 34, 391, 3, 2, 2,
	2, 36, 393, 3, 2, 2, 2, 38, 406, 3, 2, 2, 2, 40, 419, 3, 2, 2, 2, 42, 516,
	3, 2, 2, 2, 44, 518, 3, 2, 2, 2, 46, 520, 3, 2, 2, 2, 48, 535, 3, 2, 2,
	2, 50, 550, 3, 2, 2, 2, 52, 565, 3, 2, 2, 2, 54, 583, 3, 2, 2, 2, 56, 603,
	3, 2, 2, 2, 58, 623, 3, 2, 2, 2, 60, 637, 3, 2, 2, 2, 62, 647, 3, 2, 2,
	2, 64, 650, 3, 2, 2, 2, 66, 682, 3, 2, 2, 2, 68, 700, 3, 2, 2, 2, 70, 703,
	3, 2, 2, 2, 72, 707, 3, 2, 2, 2, 74, 721, 3, 2, 2, 2, 76, 725, 3, 2, 2,
	2, 78, 733, 3, 2, 2, 2, 80, 736, 3, 2, 2, 2, 82, 748, 3, 2, 2, 2, 84, 756,
	3, 2, 2, 2, 86, 770, 3, 2, 2, 2, 88, 803, 3, 2, 2, 2, 90, 812, 3, 2, 2,
	2, 92, 814, 3, 2, 2, 2, 94, 825, 3, 2, 2, 2, 96, 839, 3, 2, 2, 2, 98, 847,
	3, 2, 2, 2, 100, 876, 3, 2, 2, 2, 102, 890, 3, 2, 2, 2, 104, 898, 3, 2,
	2, 2, 106, 909, 3, 2, 2, 2, 108, 927, 3, 2, 2, 2, 110, 932, 3, 2, 2, 2,
	112, 946, 3, 2, 2, 2, 114, 954, 3, 2, 2, 2, 116, 965, 3, 2, 2, 2, 118,
	984, 3, 2, 2, 2, 120, 995, 3, 2, 2, 2, 122, 1003, 3, 2, 2, 2, 124, 1005,
	3, 2, 2, 2, 126, 1007, 3, 2, 2, 2, 128, 1011, 3, 2, 2, 2, 130, 1015, 3,
	2, 2, 2, 132, 1023, 3, 2, 2, 2, 134, 1028, 3, 2, 2, 2, 136, 1075, 3, 2,
	2, 2, 138, 1088, 3, 2, 2, 2, 140, 1090, 3, 2, 2, 2, 142, 1099, 3, 2, 2,
	2, 144, 1108, 3, 2, 2, 2, 146, 1123, 3, 2, 2, 2, 148, 1142, 3, 2, 2, 2,
	150, 1144, 3, 2, 2, 2, 152, 1148, 3, 2, 2, 2, 154, 1152, 3, 2, 2, 2, 156,
	1157, 3, 2, 2, 2, 158, 1163, 3, 2, 2, 2, 160, 1179, 3, 2, 2, 2, 162, 1193,
	3, 2, 2, 2, 164, 1195, 3, 2, 2, 2, 166, 1217, 3, 2, 2, 2, 168, 1246, 3,
	2, 2, 2, 170, 1248, 3, 2, 2, 2, 172, 1267, 3, 2, 2, 2, 174, 1269, 3, 2,
	2, 2, 176, 1285, 3, 2, 2, 2, 178, 1291, 3, 2, 2, 2, 180, 1302, 3, 2, 2,
	2, 182, 1312, 3, 2, 2, 2, 184, 1315, 3, 2, 2, 2, 186, 1322, 3, 2, 2, 2,
	188, 1328, 3, 2, 2, 2, 190, 1336, 3, 2, 2, 2, 192, 1344, 3, 2, 2, 2, 194,
	1351, 3, 2, 2, 2, 196, 1366, 3, 2, 2, 2, 198, 1379, 3, 2, 2, 2, 200, 1381,
	3, 2, 2, 2, 202, 1391, 3, 2, 2, 2, 204, 1398, 3, 2, 2, 2, 206, 1421, 3,
	2, 2, 2, 208, 1423, 3, 2, 2, 2, 210, 1432, 3, 2, 2, 2, 212, 1440, 3, 2,
	2, 2, 214, 216, 7, 3, 2, 2, 215, 214, 3, 2, 2, 2, 215, 216, 3, 2, 2, 2,
	216, 217, 3, 2, 2, 2, 217, 228, 7, 68, 2, 2, 218, 220, 7, 3, 2, 2, 219,
	218, 3, 2, 2, 2, 219, 220, 3, 2, 2, 2, 220, 221, 3, 2, 2, 2, 221, 228,
	7, 70, 2, 2, 222, 228, 7, 65, 2, 2, 223, 228, 7, 66, 2, 2, 224, 228, 7,
	69, 2, 2, 225, 228, 7, 67, 2, 2, 226, 228, 7, 4, 2, 2, 227, 215, 3, 2,
	2, 2, 227, 219, 3, 2, 2, 2, 227, 222, 3, 2, 2, 2, 227, 223, 3, 2, 2, 2,
	227, 224, 3, 2, 2, 2, 227, 225, 3, 2, 2, 2, 227, 226, 3, 2, 2, 2, 228,
	3, 3, 2, 2, 2, 229, 234, 7, 64, 2, 2, 230, 231, 7, 5, 2, 2, 231, 233, 7,
	64, 2, 2, 232, 230, 3, 2, 2, 2, 233, 236, 3, 2, 2, 2, 234, 232, 3, 2, 2,
	2, 234, 235, 3, 2, 2, 2, 235, 5, 3, 2, 2, 2, 236, 234, 3, 2, 2, 2, 237,
	242, 7, 64, 2, 2, 238, 239, 7, 6, 2, 2, 239, 241, 7, 64, 2, 2, 240, 238,
	3, 2, 2, 2, 241, 244, 3, 2, 2, 2, 242, 240, 3, 2, 2, 2, 242, 243, 3, 2,
	2, 2, 243, 7, 3, 2, 2, 2, 244, 242, 3, 2, 2, 2, 245, 246, 8, 5, 1, 2, 246,
	261, 7, 64, 2, 2, 247, 248, 7, 64, 2, 2, 248, 250, 7, 5, 2, 2, 249, 247,
	3, 2, 2, 2, 249, 250, 3, 2, 2, 2, 250, 258, 3, 2, 2, 2, 251, 259, 7, 7,
	2, 2, 252, 254, 7, 8, 2, 2, 253, 255, 5, 10, 6, 2, 254, 253, 3, 2, 2, 2,
	254, 255, 3, 2, 2, 2, 255, 256, 3, 2, 2, 2, 256, 257, 7, 5, 2, 2, 257,
	259, 7, 64, 2, 2, 258, 251, 3, 2, 2, 2, 258, 252, 3, 2, 2, 2, 259, 261,
	3, 2, 2, 2, 260, 245, 3, 2, 2, 2, 260, 249, 3, 2, 2, 2, 261, 267, 3, 2,
	2, 2, 262, 263, 12, 4, 2, 2, 263, 264, 7, 5, 2, 2, 264, 266, 7, 64, 2,
	2, 265, 262, 3, 2, 2, 2, 266, 269, 3, 2, 2, 2, 267, 265, 3, 2, 2, 2, 267,
	268, 3, 2, 2, 2, 268, 9, 3, 2, 2, 2, 269, 267, 3, 2, 2, 2, 270, 271, 7,
	9, 2, 2, 271, 272, 7, 64, 2, 2, 272, 273, 7, 10, 2, 2, 273, 11, 3, 2, 2,
	2, 274, 275, 5, 14, 8, 2, 275, 276, 7, 11, 2, 2, 276, 277, 5, 12, 7, 2,
	277, 283, 3, 2, 2, 2, 278, 280, 5, 20, 11, 2, 279, 281, 5, 16, 9, 2, 280,
	279, 3, 2, 2, 2, 280, 281, 3, 2, 2, 2, 281, 283, 3, 2, 2, 2, 282, 274,
	3, 2, 2, 2, 282, 278, 3, 2, 2, 2, 283, 13, 3, 2, 2, 2, 284, 298, 5, 20,
	11, 2, 285, 294, 7, 12, 2, 2, 286, 291, 5, 108, 55, 2, 287, 288, 7, 6,
	2, 2, 288, 290, 5, 108, 55, 2, 289, 287, 3, 2, 2, 2, 290, 293, 3, 2, 2,
	2, 291, 289, 3, 2, 2, 2, 291, 292, 3, 2, 2, 2, 292, 295, 3, 2, 2, 2, 293,
	291, 3, 2, 2, 2, 294, 286, 3, 2, 2, 2, 294, 295, 3, 2, 2, 2, 295, 296,
	3, 2, 2, 2, 296, 298, 7, 13, 2, 2, 297, 284, 3, 2, 2, 2, 297, 285, 3, 2,
	2, 2, 298, 15, 3, 2, 2, 2, 299, 300, 7, 14, 2, 2, 300, 302, 7, 15, 2, 2,
	301, 303, 5, 18, 10, 2, 302, 301, 3, 2, 2, 2, 303, 304, 3, 2, 2, 2, 304,
	302, 3, 2, 2, 2, 304, 305, 3, 2, 2, 2, 305, 306, 3, 2, 2, 2, 306, 307,
	7, 16, 2, 2, 307, 17, 3, 2, 2, 2, 308, 309, 7, 17, 2, 2, 309, 313, 5, 158,
	80, 2, 310, 311, 7, 18, 2, 2, 311, 313, 5, 150, 76, 2, 312, 308, 3, 2,
	2, 2, 312, 310, 3, 2, 2, 2, 313, 19, 3, 2, 2, 2, 314, 319, 5, 22, 12, 2,
	315, 316, 7, 64, 2, 2, 316, 318, 5, 22, 12, 2, 317, 315, 3, 2, 2, 2, 318,
	321, 3, 2, 2, 2, 319, 317, 3, 2, 2, 2, 319, 320, 3, 2, 2, 2, 320, 21, 3,
	2, 2, 2, 321, 319, 3, 2, 2, 2, 322, 327, 5, 24, 13, 2, 323, 324, 7, 19,
	2, 2, 324, 326, 5, 24, 13, 2, 325, 323, 3, 2, 2, 2, 326, 329, 3, 2, 2,
	2, 327, 325, 3, 2, 2, 2, 327, 328, 3, 2, 2, 2, 328, 331, 3, 2, 2, 2, 329,
	327, 3, 2, 2, 2, 330, 332, 5, 32, 17, 2, 331, 330, 3, 2, 2, 2, 331, 332,
	3, 2, 2, 2, 332, 335, 3, 2, 2, 2, 333, 335, 5, 32, 17, 2, 334, 322, 3,
	2, 2, 2, 334, 333, 3, 2, 2, 2, 335, 23, 3, 2, 2, 2, 336, 340, 5, 26, 14,
	2, 337, 339, 5, 130, 66, 2, 338, 337, 3, 2, 2, 2, 339, 342, 3, 2, 2, 2,
	340, 338, 3, 2, 2, 2, 340, 341, 3, 2, 2, 2, 341, 25, 3, 2, 2, 2, 342, 340,
	3, 2, 2, 2, 343, 344, 8, 14, 1, 2, 344, 347, 5, 8, 5, 2, 345, 346, 7, 5,
	2, 2, 346, 348, 7, 17, 2, 2, 347, 345, 3, 2, 2, 2, 347, 348, 3, 2, 2, 2,
	348, 354, 3, 2, 2, 2, 349, 350, 7, 12, 2, 2, 350, 351, 5, 30, 16, 2, 351,
	352, 7, 13, 2, 2, 352, 354, 3, 2, 2, 2, 353, 343, 3, 2, 2, 2, 353, 349,
	3, 2, 2, 2, 354, 362, 3, 2, 2, 2, 355, 356, 12, 6, 2, 2, 356, 361, 5, 28,
	15, 2, 357, 358, 12, 5, 2, 2, 358, 359, 7, 20, 2, 2, 359, 361, 7, 64, 2,
	2, 360, 355, 3, 2, 2, 2, 360, 357, 3, 2, 2, 2, 361, 364, 3, 2, 2, 2, 362,
	360, 3, 2, 2, 2, 362, 363, 3, 2, 2, 2, 363, 27, 3, 2, 2, 2, 364, 362, 3,
	2, 2, 2, 365, 366, 7, 9, 2, 2, 366, 367, 5, 30, 16, 2, 367, 368, 7, 10,
	2, 2, 368, 29, 3, 2, 2, 2, 369, 374, 5, 12, 7, 2, 370, 371, 7, 6, 2, 2,
	371, 373, 5, 12, 7, 2, 372, 370, 3, 2, 2, 2, 373, 376, 3, 2, 2, 2, 374,
	372, 3, 2, 2, 2, 374, 375, 3, 2, 2, 2, 375, 31, 3, 2, 2, 2, 376, 374, 3,
	2, 2, 2, 377, 379, 7, 76, 2, 2, 378, 377, 3, 2, 2, 2, 378, 379, 3, 2, 2,
	2, 379, 380, 3, 2, 2, 2, 380, 382, 7, 15, 2, 2, 381, 383, 5, 34, 18, 2,
	382, 381, 3, 2, 2, 2, 383, 384, 3, 2, 2, 2, 384, 382, 3, 2, 2, 2, 384,
	385, 3, 2, 2, 2, 385, 386, 3, 2, 2, 2, 386, 387, 7, 16, 2, 2, 387, 33,
	3, 2, 2, 2, 388, 392, 5, 148, 75, 2, 389, 390, 7, 17, 2, 2, 390, 392, 5,
	170, 86, 2, 391, 388, 3, 2, 2, 2, 391, 389, 3, 2, 2, 2, 392, 35, 3, 2,
	2, 2, 393, 394, 5, 12, 7, 2, 394, 37, 3, 2, 2, 2, 395, 396, 7, 21, 2, 2,
	396, 407, 5, 20, 11, 2, 397, 399, 7, 21, 2, 2, 398, 400, 5, 130, 66, 2,
	399, 398, 3, 2, 2, 2, 400, 401, 3, 2, 2, 2, 401, 399, 3, 2, 2, 2, 401,
	402, 3, 2, 2, 2, 402, 407, 3, 2, 2, 2, 403, 404, 7, 21, 2, 2, 404, 405,
	7, 22, 2, 2, 405, 407, 7, 23, 2, 2, 406, 395, 3, 2, 2, 2, 406, 397, 3,
	2, 2, 2, 406, 403, 3, 2, 2, 2, 407, 39, 3, 2, 2, 2, 408, 415, 5, 118, 60,
	2, 409, 411, 7, 24, 2, 2, 410, 409, 3, 2, 2, 2, 410, 411, 3, 2, 2, 2, 411,
	412, 3, 2, 2, 2, 412, 415, 7, 64, 2, 2, 413, 415, 7, 22, 2, 2, 414, 408,
	3, 2, 2, 2, 414, 410, 3, 2, 2, 2, 414, 413, 3, 2, 2, 2, 415, 416, 3, 2,
	2, 2, 416, 417, 7, 11, 2, 2, 417, 420, 5, 40, 21, 2, 418, 420, 5, 42, 22,
	2, 419, 414, 3, 2, 2, 2, 419, 418, 3, 2, 2, 2, 420, 41, 3, 2, 2, 2, 421,
	422, 7, 25, 2, 2, 422, 423, 7, 12, 2, 2, 423, 424, 5, 40, 21, 2, 424, 428,
	7, 13, 2, 2, 425, 427, 7, 76, 2, 2, 426, 425, 3, 2, 2, 2, 427, 430, 3,
	2, 2, 2, 428, 426, 3, 2, 2, 2, 428, 429, 3, 2, 2, 2, 429, 431, 3, 2, 2,
	2, 430, 428, 3, 2, 2, 2, 431, 434, 5, 40, 21, 2, 432, 433, 7, 26, 2, 2,
	433, 435, 5, 40, 21, 2, 434, 432, 3, 2, 2, 2, 434, 435, 3, 2, 2, 2, 435,
	517, 3, 2, 2, 2, 436, 437, 7, 27, 2, 2, 437, 438, 7, 12, 2, 2, 438, 439,
	5, 40, 21, 2, 439, 443, 7, 13, 2, 2, 440, 442, 7, 76, 2, 2, 441, 440, 3,
	2, 2, 2, 442, 445, 3, 2, 2, 2, 443, 441, 3, 2, 2, 2, 443, 444, 3, 2, 2,
	2, 444, 446, 3, 2, 2, 2, 445, 443, 3, 2, 2, 2, 446, 447, 5, 40, 21, 2,
	447, 517, 3, 2, 2, 2, 448, 449, 7, 28, 2, 2, 449, 452, 5, 40, 21, 2, 450,
	451, 7, 29, 2, 2, 451, 453, 5, 40, 21, 2, 452, 450, 3, 2, 2, 2, 452, 453,
	3, 2, 2, 2, 453, 456, 3, 2, 2, 2, 454, 455, 7, 30, 2, 2, 455, 457, 5, 40,
	21, 2, 456, 454, 3, 2, 2, 2, 456, 457, 3, 2, 2, 2, 457, 517, 3, 2, 2, 2,
	458, 459, 7, 31, 2, 2, 459, 460, 5, 40, 21, 2, 460, 461, 7, 27, 2, 2, 461,
	462, 7, 12, 2, 2, 462, 463, 5, 40, 21, 2, 463, 464, 7, 13, 2, 2, 464, 517,
	3, 2, 2, 2, 465, 474, 7, 32, 2, 2, 466, 467, 7, 12, 2, 2, 467, 468, 5,
	70, 36, 2, 468, 469, 7, 13, 2, 2, 469, 475, 3, 2, 2, 2, 470, 471, 7, 15,
	2, 2, 471, 472, 5, 70, 36, 2, 472, 473, 7, 16, 2, 2, 473, 475, 3, 2, 2,
	2, 474, 466, 3, 2, 2, 2, 474, 470, 3, 2, 2, 2, 475, 477, 3, 2, 2, 2, 476,
	478, 7, 33, 2, 2, 477, 476, 3, 2, 2, 2, 477, 478, 3, 2, 2, 2, 478, 479,
	3, 2, 2, 2, 479, 480, 5, 40, 21, 2, 480, 517, 3, 2, 2, 2, 481, 482, 7,
	34, 2, 2, 482, 517, 5, 40, 21, 2, 483, 485, 7, 35, 2, 2, 484, 486, 5, 40,
	21, 2, 485, 484, 3, 2, 2, 2, 485, 486, 3, 2, 2, 2, 486, 517, 3, 2, 2, 2,
	487, 493, 5, 52, 27, 2, 488, 490, 5, 54, 28, 2, 489, 491, 7, 22, 2, 2,
	490, 489, 3, 2, 2, 2, 490, 491, 3, 2, 2, 2, 491, 493, 3, 2, 2, 2, 492,
	487, 3, 2, 2, 2, 492, 488, 3, 2, 2, 2, 493, 494, 3, 2, 2, 2, 494, 495,
	7, 5, 2, 2, 495, 497, 3, 2, 2, 2, 496, 492, 3, 2, 2, 2, 496, 497, 3, 2,
	2, 2, 497, 498, 3, 2, 2, 2, 498, 499, 7, 64, 2, 2, 499, 500, 7, 36, 2,
	2, 500, 517, 5, 40, 21, 2, 501, 502, 5, 54, 28, 2, 502, 503, 5, 58, 30,
	2, 503, 504, 7, 36, 2, 2, 504, 505, 5, 40, 21, 2, 505, 517, 3, 2, 2, 2,
	506, 508, 5, 46, 24, 2, 507, 509, 5, 38, 20, 2, 508, 507, 3, 2, 2, 2, 508,
	509, 3, 2, 2, 2, 509, 517, 3, 2, 2, 2, 510, 511, 5, 46, 24, 2, 511, 512,
	7, 37, 2, 2, 512, 513, 7, 15, 2, 2, 513, 514, 5, 74, 38, 2, 514, 515, 7,
	16, 2, 2, 515, 517, 3, 2, 2, 2, 516, 421, 3, 2, 2, 2, 516, 436, 3, 2, 2,
	2, 516, 448, 3, 2, 2, 2, 516, 458, 3, 2, 2, 2, 516, 465, 3, 2, 2, 2, 516,
	481, 3, 2, 2, 2, 516, 483, 3, 2, 2, 2, 516, 496, 3, 2, 2, 2, 516, 501,
	3, 2, 2, 2, 516, 506, 3, 2, 2, 2, 516, 510, 3, 2, 2, 2, 517, 43, 3, 2,
	2, 2, 518, 519, 9, 2, 2, 2, 519, 45, 3, 2, 2, 2, 520, 522, 5, 48, 25, 2,
	521, 523, 7, 64, 2, 2, 522, 521, 3, 2, 2, 2, 522, 523, 3, 2, 2, 2, 523,
	529, 3, 2, 2, 2, 524, 525, 5, 44, 23, 2, 525, 526, 5, 54, 28, 2, 526, 528,
	3, 2, 2, 2, 527, 524, 3, 2, 2, 2, 528, 531, 3, 2, 2, 2, 529, 527, 3, 2,
	2, 2, 529, 530, 3, 2, 2, 2, 530, 533, 3, 2, 2, 2, 531, 529, 3, 2, 2, 2,
	532, 534, 7, 76, 2, 2, 533, 532, 3, 2, 2, 2, 533, 534, 3, 2, 2, 2, 534,
	47, 3, 2, 2, 2, 535, 536, 8, 25, 1, 2, 536, 537, 5, 50, 26, 2, 537, 546,
	3, 2, 2, 2, 538, 539, 12, 3, 2, 2, 539, 541, 7, 64, 2, 2, 540, 542, 7,
	76, 2, 2, 541, 540, 3, 2, 2, 2, 541, 542, 3, 2, 2, 2, 542, 543, 3, 2, 2,
	2, 543, 545, 5, 48, 25, 4, 544, 538, 3, 2, 2, 2, 545, 548, 3, 2, 2, 2,
	546, 544, 3, 2, 2, 2, 546, 547, 3, 2, 2, 2, 547, 49, 3, 2, 2, 2, 548, 546,
	3, 2, 2, 2, 549, 551, 5, 44, 23, 2, 550, 549, 3, 2, 2, 2, 550, 551, 3,
	2, 2, 2, 551, 557, 3, 2, 2, 2, 552, 558, 5, 52, 27, 2, 553, 555, 5, 54,
	28, 2, 554, 556, 7, 22, 2, 2, 555, 554, 3, 2, 2, 2, 555, 556, 3, 2, 2,
	2, 556, 558, 3, 2, 2, 2, 557, 552, 3, 2, 2, 2, 557, 553, 3, 2, 2, 2, 558,
	51, 3, 2, 2, 2, 559, 562, 7, 41, 2, 2, 560, 563, 5, 184, 93, 2, 561, 563,
	5, 134, 68, 2, 562, 560, 3, 2, 2, 2, 562, 561, 3, 2, 2, 2, 563, 566, 3,
	2, 2, 2, 564, 566, 5, 62, 32, 2, 565, 559, 3, 2, 2, 2, 565, 564, 3, 2,
	2, 2, 566, 53, 3, 2, 2, 2, 567, 568, 8, 28, 1, 2, 568, 584, 5, 2, 2, 2,
	569, 584, 5, 8, 5, 2, 570, 584, 7, 22, 2, 2, 571, 573, 7, 12, 2, 2, 572,
	574, 5, 56, 29, 2, 573, 572, 3, 2, 2, 2, 573, 574, 3, 2, 2, 2, 574, 575,
	3, 2, 2, 2, 575, 584, 7, 13, 2, 2, 576, 577, 5, 52, 27, 2, 577, 578, 7,
	5, 2, 2, 578, 579, 7, 64, 2, 2, 579, 584, 3, 2, 2, 2, 580, 581, 5, 52,
	27, 2, 581, 582, 5, 28, 15, 2, 582, 584, 3, 2, 2, 2, 583, 567, 3, 2, 2,
	2, 583, 569, 3, 2, 2, 2, 583, 570, 3, 2, 2, 2, 583, 571, 3, 2, 2, 2, 583,
	576, 3, 2, 2, 2, 583, 580, 3, 2, 2, 2, 584, 600, 3, 2, 2, 2, 585, 587,
	12, 6, 2, 2, 586, 588, 7, 22, 2, 2, 587, 586, 3, 2, 2, 2, 587, 588, 3,
	2, 2, 2, 588, 589, 3, 2, 2, 2, 589, 590, 7, 5, 2, 2, 590, 599, 7, 64, 2,
	2, 591, 593, 12, 4, 2, 2, 592, 594, 7, 22, 2, 2, 593, 592, 3, 2, 2, 2,
	593, 594, 3, 2, 2, 2, 594, 595, 3, 2, 2, 2, 595, 599, 5, 28, 15, 2, 596,
	597, 12, 3, 2, 2, 597, 599, 5, 58, 30, 2, 598, 585, 3, 2, 2, 2, 598, 591,
	3, 2, 2, 2, 598, 596, 3, 2, 2, 2, 599, 602, 3, 2, 2, 2, 600, 598, 3, 2,
	2, 2, 600, 601, 3, 2, 2, 2, 601, 55, 3, 2, 2, 2, 602, 600, 3, 2, 2, 2,
	603, 608, 5, 40, 21, 2, 604, 605, 7, 6, 2, 2, 605, 607, 5, 40, 21, 2, 606,
	604, 3, 2, 2, 2, 607, 610, 3, 2, 2, 2, 608, 606, 3, 2, 2, 2, 608, 609,
	3, 2, 2, 2, 609, 57, 3, 2, 2, 2, 610, 608, 3, 2, 2, 2, 611, 612, 7, 12,
	2, 2, 612, 613, 5, 60, 31, 2, 613, 614, 7, 13, 2, 2, 614, 624, 3, 2, 2,
	2, 615, 616, 7, 15, 2, 2, 616, 617, 5, 60, 31, 2, 617, 618, 7, 16, 2, 2,
	618, 624, 3, 2, 2, 2, 619, 621, 7, 76, 2, 2, 620, 619, 3, 2, 2, 2, 620,
	621, 3, 2, 2, 2, 621, 622, 3, 2, 2, 2, 622, 624, 5, 62, 32, 2, 623, 611,
	3, 2, 2, 2, 623, 615, 3, 2, 2, 2, 623, 620, 3, 2, 2, 2, 624, 59, 3, 2,
	2, 2, 625, 627, 5, 56, 29, 2, 626, 625, 3, 2, 2, 2, 626, 627, 3, 2, 2,
	2, 627, 638, 3, 2, 2, 2, 628, 629, 5, 56, 29, 2, 629, 630, 7, 6, 2, 2,
	630, 632, 3, 2, 2, 2, 631, 628, 3, 2, 2, 2, 631, 632, 3, 2, 2, 2, 632,
	633, 3, 2, 2, 2, 633, 635, 5, 46, 24, 2, 634, 636, 9, 3, 2, 2, 635, 634,
	3, 2, 2, 2, 635, 636, 3, 2, 2, 2, 636, 638, 3, 2, 2, 2, 637, 626, 3, 2,
	2, 2, 637, 631, 3, 2, 2, 2, 638, 61, 3, 2, 2, 2, 639, 640, 7, 15, 2, 2,
	640, 641, 5, 74, 38, 2, 641, 642, 7, 16, 2, 2, 642, 648, 3, 2, 2, 2, 643,
	644, 7, 15, 2, 2, 644, 645, 5, 64, 33, 2, 645, 646, 7, 16, 2, 2, 646, 648,
	3, 2, 2, 2, 647, 639, 3, 2, 2, 2, 647, 643, 3, 2, 2, 2, 648, 63, 3, 2,
	2, 2, 649, 651, 5, 66, 34, 2, 650, 649, 3, 2, 2, 2, 651, 652, 3, 2, 2,
	2, 652, 650, 3, 2, 2, 2, 652, 653, 3, 2, 2, 2, 653, 655, 3, 2, 2, 2, 654,
	656, 5, 68, 35, 2, 655, 654, 3, 2, 2, 2, 655, 656, 3, 2, 2, 2, 656, 65,
	3, 2, 2, 2, 657, 683, 5, 140, 71, 2, 658, 660, 5, 130, 66, 2, 659, 658,
	3, 2, 2, 2, 660, 663, 3, 2, 2, 2, 661, 659, 3, 2, 2, 2, 661, 662, 3, 2,
	2, 2, 662, 665, 3, 2, 2, 2, 663, 661, 3, 2, 2, 2, 664, 666, 9, 4, 2, 2,
	665, 664, 3, 2, 2, 2, 665, 666, 3, 2, 2, 2, 666, 667, 3, 2, 2, 2, 667,
	683, 5, 162, 82, 2, 668, 670, 5, 130, 66, 2, 669, 668, 3, 2, 2, 2, 670,
	673, 3, 2, 2, 2, 671, 669, 3, 2, 2, 2, 671, 672, 3, 2, 2, 2, 672, 677,
	3, 2, 2, 2, 673, 671, 3, 2, 2, 2, 674, 676, 5, 124, 63, 2, 675, 674, 3,
	2, 2, 2, 676, 679, 3, 2, 2, 2, 677, 675, 3, 2, 2, 2, 677, 678, 3, 2, 2,
	2, 678, 680, 3, 2, 2, 2, 679, 677, 3, 2, 2, 2, 680, 683, 5, 172, 87, 2,
	681, 683, 5, 42, 22, 2, 682, 657, 3, 2, 2, 2, 682, 661, 3, 2, 2, 2, 682,
	671, 3, 2, 2, 2, 682, 681, 3, 2, 2, 2, 683, 67, 3, 2, 2, 2, 684, 701, 5,
	42, 22, 2, 685, 696, 5, 118, 60, 2, 686, 688, 7, 24, 2, 2, 687, 686, 3,
	2, 2, 2, 687, 688, 3, 2, 2, 2, 688, 689, 3, 2, 2, 2, 689, 692, 7, 64, 2,
	2, 690, 692, 7, 22, 2, 2, 691, 687, 3, 2, 2, 2, 691, 690, 3, 2, 2, 2, 692,
	693, 3, 2, 2, 2, 693, 694, 7, 21, 2, 2, 694, 696, 5, 22, 12, 2, 695, 685,
	3, 2, 2, 2, 695, 691, 3, 2, 2, 2, 696, 697, 3, 2, 2, 2, 697, 698, 7, 11,
	2, 2, 698, 699, 5, 64, 33, 2, 699, 701, 3, 2, 2, 2, 700, 684, 3, 2, 2,
	2, 700, 695, 3, 2, 2, 2, 701, 69, 3, 2, 2, 2, 702, 704, 5, 72, 37, 2, 703,
	702, 3, 2, 2, 2, 704, 705, 3, 2, 2, 2, 705, 703, 3, 2, 2, 2, 705, 706,
	3, 2, 2, 2, 706, 71, 3, 2, 2, 2, 707, 708, 5, 82, 42, 2, 708, 709, 7, 43,
	2, 2, 709, 717, 5, 40, 21, 2, 710, 716, 5, 78, 40, 2, 711, 712, 5, 82,
	42, 2, 712, 713, 7, 36, 2, 2, 713, 714, 5, 40, 21, 2, 714, 716, 3, 2, 2,
	2, 715, 710, 3, 2, 2, 2, 715, 711, 3, 2, 2, 2, 716, 719, 3, 2, 2, 2, 717,
	715, 3, 2, 2, 2, 717, 718, 3, 2, 2, 2, 718, 73, 3, 2, 2, 2, 719, 717, 3,
	2, 2, 2, 720, 722, 5, 76, 39, 2, 721, 720, 3, 2, 2, 2, 722, 723, 3, 2,
	2, 2, 723, 721, 3, 2, 2, 2, 723, 724, 3, 2, 2, 2, 724, 75, 3, 2, 2, 2,
	725, 726, 7, 44, 2, 2, 726, 728, 5, 80, 41, 2, 727, 729, 5, 78, 40, 2,
	728, 727, 3, 2, 2, 2, 728, 729, 3, 2, 2, 2, 729, 730, 3, 2, 2, 2, 730,
	731, 7, 11, 2, 2, 731, 732, 5, 64, 33, 2, 732, 77, 3, 2, 2, 2, 733, 734,
	7, 25, 2, 2, 734, 735, 5, 46, 24, 2, 735, 79, 3, 2, 2, 2, 736, 741, 5,
	82, 42, 2, 737, 738, 7, 45, 2, 2, 738, 740, 5, 82, 42, 2, 739, 737, 3,
	2, 2, 2, 740, 743, 3, 2, 2, 2, 741, 739, 3, 2, 2, 2, 741, 742, 3, 2, 2,
	2, 742, 81, 3, 2, 2, 2, 743, 741, 3, 2, 2, 2, 744, 745, 9, 5, 2, 2, 745,
	746, 7, 21, 2, 2, 746, 749, 5, 36, 19, 2, 747, 749, 5, 84, 43, 2, 748,
	744, 3, 2, 2, 2, 748, 747, 3, 2, 2, 2, 749, 83, 3, 2, 2, 2, 750, 753, 7,
	64, 2, 2, 751, 752, 7, 46, 2, 2, 752, 754, 5, 86, 44, 2, 753, 751, 3, 2,
	2, 2, 753, 754, 3, 2, 2, 2, 754, 757, 3, 2, 2, 2, 755, 757, 5, 86, 44,
	2, 756, 750, 3, 2, 2, 2, 756, 755, 3, 2, 2, 2, 757, 85, 3, 2, 2, 2, 758,
	771, 5, 88, 45, 2, 759, 767, 5, 88, 45, 2, 760, 762, 7, 64, 2, 2, 761,
	763, 7, 76, 2, 2, 762, 761, 3, 2, 2, 2, 762, 763, 3, 2, 2, 2, 763, 764,
	3, 2, 2, 2, 764, 766, 5, 88, 45, 2, 765, 760, 3, 2, 2, 2, 766, 769, 3,
	2, 2, 2, 767, 765, 3, 2, 2, 2, 767, 768, 3, 2, 2, 2, 768, 771, 3, 2, 2,
	2, 769, 767, 3, 2, 2, 2, 770, 758, 3, 2, 2, 2, 770, 759, 3, 2, 2, 2, 771,
	87, 3, 2, 2, 2, 772, 804, 7, 22, 2, 2, 773, 804, 7, 71, 2, 2, 774, 804,
	5, 2, 2, 2, 775, 781, 5, 8, 5, 2, 776, 778, 7, 12, 2, 2, 777, 779, 5, 90,
	46, 2, 778, 777, 3, 2, 2, 2, 778, 779, 3, 2, 2, 2, 779, 780, 3, 2, 2, 2,
	780, 782, 7, 13, 2, 2, 781, 776, 3, 2, 2, 2, 781, 782, 3, 2, 2, 2, 782,
	804, 3, 2, 2, 2, 783, 784, 5, 8, 5, 2, 784, 788, 7, 12, 2, 2, 785, 786,
	5, 90, 46, 2, 786, 787, 7, 6, 2, 2, 787, 789, 3, 2, 2, 2, 788, 785, 3,
	2, 2, 2, 788, 789, 3, 2, 2, 2, 789, 792, 3, 2, 2, 2, 790, 791, 7, 64, 2,
	2, 791, 793, 7, 46, 2, 2, 792, 790, 3, 2, 2, 2, 792, 793, 3, 2, 2, 2, 793,
	794, 3, 2, 2, 2, 794, 795, 7, 22, 2, 2, 795, 796, 7, 23, 2, 2, 796, 797,
	7, 13, 2, 2, 797, 804, 3, 2, 2, 2, 798, 800, 7, 12, 2, 2, 799, 801, 5,
	90, 46, 2, 800, 799, 3, 2, 2, 2, 800, 801, 3, 2, 2, 2, 801, 802, 3, 2,
	2, 2, 802, 804, 7, 13, 2, 2, 803, 772, 3, 2, 2, 2, 803, 773, 3, 2, 2, 2,
	803, 774, 3, 2, 2, 2, 803, 775, 3, 2, 2, 2, 803, 783, 3, 2, 2, 2, 803,
	798, 3, 2, 2, 2, 804, 89, 3, 2, 2, 2, 805, 808, 5, 80, 41, 2, 806, 807,
	7, 6, 2, 2, 807, 809, 5, 90, 46, 2, 808, 806, 3, 2, 2, 2, 808, 809, 3,
	2, 2, 2, 809, 813, 3, 2, 2, 2, 810, 811, 7, 22, 2, 2, 811, 813, 7, 23,
	2, 2, 812, 805, 3, 2, 2, 2, 812, 810, 3, 2, 2, 2, 813, 91, 3, 2, 2, 2,
	814, 815, 7, 9, 2, 2, 815, 820, 5, 96, 49, 2, 816, 817, 7, 6, 2, 2, 817,
	819, 5, 96, 49, 2, 818, 816, 3, 2, 2, 2, 819, 822, 3, 2, 2, 2, 820, 818,
	3, 2, 2, 2, 820, 821, 3, 2, 2, 2, 821, 823, 3, 2, 2, 2, 822, 820, 3, 2,
	2, 2, 823, 824, 7, 10, 2, 2, 824, 93, 3, 2, 2, 2, 825, 826, 7, 9, 2, 2,
	826, 831, 5, 98, 50, 2, 827, 828, 7, 6, 2, 2, 828, 830, 5, 98, 50, 2, 829,
	827, 3, 2, 2, 2, 830, 833, 3, 2, 2, 2, 831, 829, 3, 2, 2, 2, 831, 832,
	3, 2, 2, 2, 832, 834, 3, 2, 2, 2, 833, 831, 3, 2, 2, 2, 834, 835, 7, 10,
	2, 2, 835, 95, 3, 2, 2, 2, 836, 838, 5, 130, 66, 2, 837, 836, 3, 2, 2,
	2, 838, 841, 3, 2, 2, 2, 839, 837, 3, 2, 2, 2, 839, 840, 3, 2, 2, 2, 840,
	843, 3, 2, 2, 2, 841, 839, 3, 2, 2, 2, 842, 844, 9, 6, 2, 2, 843, 842,
	3, 2, 2, 2, 843, 844, 3, 2, 2, 2, 844, 845, 3, 2, 2, 2, 845, 846, 5, 98,
	50, 2, 846, 97, 3, 2, 2, 2, 847, 849, 9, 7, 2, 2, 848, 850, 5, 92, 47,
	2, 849, 848, 3, 2, 2, 2, 849, 850, 3, 2, 2, 2, 850, 853, 3, 2, 2, 2, 851,
	852, 7, 47, 2, 2, 852, 854, 5, 12, 7, 2, 853, 851, 3, 2, 2, 2, 853, 854,
	3, 2, 2, 2, 854, 857, 3, 2, 2, 2, 855, 856, 7, 48, 2, 2, 856, 858, 5, 12,
	7, 2, 857, 855, 3, 2, 2, 2, 857, 858, 3, 2, 2, 2, 858, 863, 3, 2, 2, 2,
	859, 860, 7, 49, 2, 2, 860, 862, 5, 12, 7, 2, 861, 859, 3, 2, 2, 2, 862,
	865, 3, 2, 2, 2, 863, 861, 3, 2, 2, 2, 863, 864, 3, 2, 2, 2, 864, 870,
	3, 2, 2, 2, 865, 863, 3, 2, 2, 2, 866, 867, 7, 21, 2, 2, 867, 869, 5, 12,
	7, 2, 868, 866, 3, 2, 2, 2, 869, 872, 3, 2, 2, 2, 870, 868, 3, 2, 2, 2,
	870, 871, 3, 2, 2, 2, 871, 99, 3, 2, 2, 2, 872, 870, 3, 2, 2, 2, 873, 875,
	5, 102, 52, 2, 874, 873, 3, 2, 2, 2, 875, 878, 3, 2, 2, 2, 876, 874, 3,
	2, 2, 2, 876, 877, 3, 2, 2, 2, 877, 887, 3, 2, 2, 2, 878, 876, 3, 2, 2,
	2, 879, 881, 7, 76, 2, 2, 880, 879, 3, 2, 2, 2, 880, 881, 3, 2, 2, 2, 881,
	882, 3, 2, 2, 2, 882, 883, 7, 12, 2, 2, 883, 884, 7, 24, 2, 2, 884, 885,
	5, 104, 53, 2, 885, 886, 7, 13, 2, 2, 886, 888, 3, 2, 2, 2, 887, 880, 3,
	2, 2, 2, 887, 888, 3, 2, 2, 2, 888, 101, 3, 2, 2, 2, 889, 891, 7, 76, 2,
	2, 890, 889, 3, 2, 2, 2, 890, 891, 3, 2, 2, 2, 891, 892, 3, 2, 2, 2, 892,
	894, 7, 12, 2, 2, 893, 895, 5, 104, 53, 2, 894, 893, 3, 2, 2, 2, 894, 895,
	3, 2, 2, 2, 895, 896, 3, 2, 2, 2, 896, 897, 7, 13, 2, 2, 897, 103, 3, 2,
	2, 2, 898, 903, 5, 106, 54, 2, 899, 900, 7, 6, 2, 2, 900, 902, 5, 106,
	54, 2, 901, 899, 3, 2, 2, 2, 902, 905, 3, 2, 2, 2, 903, 901, 3, 2, 2, 2,
	903, 904, 3, 2, 2, 2, 904, 105, 3, 2, 2, 2, 905, 903, 3, 2, 2, 2, 906,
	908, 5, 130, 66, 2, 907, 906, 3, 2, 2, 2, 908, 911, 3, 2, 2, 2, 909, 907,
	3, 2, 2, 2, 909, 910, 3, 2, 2, 2, 910, 912, 3, 2, 2, 2, 911, 909, 3, 2,
	2, 2, 912, 915, 7, 64, 2, 2, 913, 914, 7, 21, 2, 2, 914, 916, 5, 108, 55,
	2, 915, 913, 3, 2, 2, 2, 915, 916, 3, 2, 2, 2, 916, 919, 3, 2, 2, 2, 917,
	918, 7, 36, 2, 2, 918, 920, 5, 40, 21, 2, 919, 917, 3, 2, 2, 2, 919, 920,
	3, 2, 2, 2, 920, 107, 3, 2, 2, 2, 921, 928, 5, 12, 7, 2, 922, 923, 7, 11,
	2, 2, 923, 928, 5, 12, 7, 2, 924, 925, 5, 12, 7, 2, 925, 926, 7, 23, 2,
	2, 926, 928, 3, 2, 2, 2, 927, 921, 3, 2, 2, 2, 927, 922, 3, 2, 2, 2, 927,
	924, 3, 2, 2, 2, 928, 109, 3, 2, 2, 2, 929, 931, 5, 112, 57, 2, 930, 929,
	3, 2, 2, 2, 931, 934, 3, 2, 2, 2, 932, 930, 3, 2, 2, 2, 932, 933, 3, 2,
	2, 2, 933, 943, 3, 2, 2, 2, 934, 932, 3, 2, 2, 2, 935, 937, 7, 76, 2, 2,
	936, 935, 3, 2, 2, 2, 936, 937, 3, 2, 2, 2, 937, 938, 3, 2, 2, 2, 938,
	939, 7, 12, 2, 2, 939, 940, 7, 24, 2, 2, 940, 941, 5, 114, 58, 2, 941,
	942, 7, 13, 2, 2, 942, 944, 3, 2, 2, 2, 943, 936, 3, 2, 2, 2, 943, 944,
	3, 2, 2, 2, 944, 111, 3, 2, 2, 2, 945, 947, 7, 76, 2, 2, 946, 945, 3, 2,
	2, 2, 946, 947, 3, 2, 2, 2, 947, 948, 3, 2, 2, 2, 948, 950, 7, 12, 2, 2,
	949, 951, 5, 114, 58, 2, 950, 949, 3, 2, 2, 2, 950, 951, 3, 2, 2, 2, 951,
	952, 3, 2, 2, 2, 952, 953, 7, 13, 2, 2, 953, 113, 3, 2, 2, 2, 954, 959,
	5, 116, 59, 2, 955, 956, 7, 6, 2, 2, 956, 958, 5, 116, 59, 2, 957, 955,
	3, 2, 2, 2, 958, 961, 3, 2, 2, 2, 959, 957, 3, 2, 2, 2, 959, 960, 3, 2,
	2, 2, 960, 115, 3, 2, 2, 2, 961, 959, 3, 2, 2, 2, 962, 964, 5, 130, 66,
	2, 963, 962, 3, 2, 2, 2, 964, 967, 3, 2, 2, 2, 965, 963, 3, 2, 2, 2, 965,
	966, 3, 2, 2, 2, 966, 971, 3, 2, 2, 2, 967, 965, 3, 2, 2, 2, 968, 970,
	5, 122, 62, 2, 969, 968, 3, 2, 2, 2, 970, 973, 3, 2, 2, 2, 971, 969, 3,
	2, 2, 2, 971, 972, 3, 2, 2, 2, 972, 975, 3, 2, 2, 2, 973, 971, 3, 2, 2,
	2, 974, 976, 9, 8, 2, 2, 975, 974, 3, 2, 2, 2, 975, 976, 3, 2, 2, 2, 976,
	977, 3, 2, 2, 2, 977, 978, 7, 64, 2, 2, 978, 979, 7, 21, 2, 2, 979, 982,
	5, 108, 55, 2, 980, 981, 7, 36, 2, 2, 981, 983, 5, 40, 21, 2, 982, 980,
	3, 2, 2, 2, 982, 983, 3, 2, 2, 2, 983, 117, 3, 2, 2, 2, 984, 985, 7, 12,
	2, 2, 985, 990, 5, 120, 61, 2, 986, 987, 7, 6, 2, 2, 987, 989, 5, 120,
	61, 2, 988, 986, 3, 2, 2, 2, 989, 992, 3, 2, 2, 2, 990, 988, 3, 2, 2, 2,
	990, 991, 3, 2, 2, 2, 991, 993, 3, 2, 2, 2, 992, 990, 3, 2, 2, 2, 993,
	994, 7, 13, 2, 2, 994, 119, 3, 2, 2, 2, 995, 998, 9, 7, 2, 2, 996, 997,
	7, 21, 2, 2, 997, 999, 5, 12, 7, 2, 998, 996, 3, 2, 2, 2, 998, 999, 3,
	2, 2, 2, 999, 121, 3, 2, 2, 2, 1000, 1004, 5, 124, 63, 2, 1001, 1004, 5,
	126, 64, 2, 1002, 1004, 7, 51, 2, 2, 1003, 1000, 3, 2, 2, 2, 1003, 1001,
	3, 2, 2, 2, 1003, 1002, 3, 2, 2, 2, 1004, 123, 3, 2, 2, 2, 1005, 1006,
	9, 9, 2, 2, 1006, 125, 3, 2, 2, 2, 1007, 1009, 9, 10, 2, 2, 1008, 1010,
	5, 128, 65, 2, 1009, 1008, 3, 2, 2, 2, 1009, 1010, 3, 2, 2, 2, 1010, 127,
	3, 2, 2, 2, 1011, 1012, 7, 9, 2, 2, 1012, 1013, 9, 11, 2, 2, 1013, 1014,
	7, 10, 2, 2, 1014, 129, 3, 2, 2, 2, 1015, 1016, 7, 46, 2, 2, 1016, 1020,
	5, 26, 14, 2, 1017, 1019, 5, 58, 30, 2, 1018, 1017, 3, 2, 2, 2, 1019, 1022,
	3, 2, 2, 2, 1020, 1018, 3, 2, 2, 2, 1020, 1021, 3, 2, 2, 2, 1021, 131,
	3, 2, 2, 2, 1022, 1020, 3, 2, 2, 2, 1023, 1024, 7, 46, 2, 2, 1024, 1025,
	5, 26, 14, 2, 1025, 1026, 5, 58, 30, 2, 1026, 133, 3, 2, 2, 2, 1027, 1029,
	7, 76, 2, 2, 1028, 1027, 3, 2, 2, 2, 1028, 1029, 3, 2, 2, 2, 1029, 1030,
	3, 2, 2, 2, 1030, 1032, 7, 15, 2, 2, 1031, 1033, 5, 138, 70, 2, 1032, 1031,
	3, 2, 2, 2, 1032, 1033, 3, 2, 2, 2, 1033, 1035, 3, 2, 2, 2, 1034, 1036,
	5, 136, 69, 2, 1035, 1034, 3, 2, 2, 2, 1036, 1037, 3, 2, 2, 2, 1037, 1035,
	3, 2, 2, 2, 1037, 1038, 3, 2, 2, 2, 1038, 1039, 3, 2, 2, 2, 1039, 1040,
	7, 16, 2, 2, 1040, 135, 3, 2, 2, 2, 1041, 1076, 5, 140, 71, 2, 1042, 1044,
	5, 130, 66, 2, 1043, 1045, 7, 76, 2, 2, 1044, 1043, 3, 2, 2, 2, 1044, 1045,
	3, 2, 2, 2, 1045, 1047, 3, 2, 2, 2, 1046, 1042, 3, 2, 2, 2, 1047, 1050,
	3, 2, 2, 2, 1048, 1046, 3, 2, 2, 2, 1048, 1049, 3, 2, 2, 2, 1049, 1054,
	3, 2, 2, 2, 1050, 1048, 3, 2, 2, 2, 1051, 1053, 5, 122, 62, 2, 1052, 1051,
	3, 2, 2, 2, 1053, 1056, 3, 2, 2, 2, 1054, 1052, 3, 2, 2, 2, 1054, 1055,
	3, 2, 2, 2, 1055, 1057, 3, 2, 2, 2, 1056, 1054, 3, 2, 2, 2, 1057, 1076,
	5, 162, 82, 2, 1058, 1060, 5, 130, 66, 2, 1059, 1061, 7, 76, 2, 2, 1060,
	1059, 3, 2, 2, 2, 1060, 1061, 3, 2, 2, 2, 1061, 1063, 3, 2, 2, 2, 1062,
	1058, 3, 2, 2, 2, 1063, 1066, 3, 2, 2, 2, 1064, 1062, 3, 2, 2, 2, 1064,
	1065, 3, 2, 2, 2, 1065, 1070, 3, 2, 2, 2, 1066, 1064, 3, 2, 2, 2, 1067,
	1069, 5, 122, 62, 2, 1068, 1067, 3, 2, 2, 2, 1069, 1072, 3, 2, 2, 2, 1070,
	1068, 3, 2, 2, 2, 1070, 1071, 3, 2, 2, 2, 1071, 1073, 3, 2, 2, 2, 1072,
	1070, 3, 2, 2, 2, 1073, 1076, 5, 148, 75, 2, 1074, 1076, 5, 40, 21, 2,
	1075, 1041, 3, 2, 2, 2, 1075, 1048, 3, 2, 2, 2, 1075, 1064, 3, 2, 2, 2,
	1075, 1074, 3, 2, 2, 2, 1076, 137, 3, 2, 2, 2, 1077, 1080, 7, 64, 2, 2,
	1078, 1079, 7, 21, 2, 2, 1079, 1081, 5, 12, 7, 2, 1080, 1078, 3, 2, 2,
	2, 1080, 1081, 3, 2, 2, 2, 1081, 1082, 3, 2, 2, 2, 1082, 1089, 7, 11, 2,
	2, 1083, 1084, 7, 7, 2, 2, 1084, 1085, 7, 21, 2, 2, 1085, 1086, 5, 12,
	7, 2, 1086, 1087, 7, 11, 2, 2, 1087, 1089, 3, 2, 2, 2, 1088, 1077, 3, 2,
	2, 2, 1088, 1083, 3, 2, 2, 2, 1089, 139, 3, 2, 2, 2, 1090, 1091, 7, 57,
	2, 2, 1091, 1096, 5, 142, 72, 2, 1092, 1093, 7, 6, 2, 2, 1093, 1095, 5,
	142, 72, 2, 1094, 1092, 3, 2, 2, 2, 1095, 1098, 3, 2, 2, 2, 1096, 1094,
	3, 2, 2, 2, 1096, 1097, 3, 2, 2, 2, 1097, 141, 3, 2, 2, 2, 1098, 1096,
	3, 2, 2, 2, 1099, 1106, 5, 8, 5, 2, 1100, 1104, 7, 5, 2, 2, 1101, 1105,
	7, 64, 2, 2, 1102, 1105, 7, 22, 2, 2, 1103, 1105, 5, 144, 73, 2, 1104,
	1101, 3, 2, 2, 2, 1104, 1102, 3, 2, 2, 2, 1104, 1103, 3, 2, 2, 2, 1105,
	1107, 3, 2, 2, 2, 1106, 1100, 3, 2, 2, 2, 1106, 1107, 3, 2, 2, 2, 1107,
	143, 3, 2, 2, 2, 1108, 1114, 7, 15, 2, 2, 1109, 1110, 5, 146, 74, 2, 1110,
	1111, 7, 6, 2, 2, 1111, 1113, 3, 2, 2, 2, 1112, 1109, 3, 2, 2, 2, 1113,
	1116, 3, 2, 2, 2, 1114, 1112, 3, 2, 2, 2, 1114, 1115, 3, 2, 2, 2, 1115,
	1119, 3, 2, 2, 2, 1116, 1114, 3, 2, 2, 2, 1117, 1120, 5, 146, 74, 2, 1118,
	1120, 7, 22, 2, 2, 1119, 1117, 3, 2, 2, 2, 1119, 1118, 3, 2, 2, 2, 1120,
	1121, 3, 2, 2, 2, 1121, 1122, 7, 16, 2, 2, 1122, 145, 3, 2, 2, 2, 1123,
	1126, 7, 64, 2, 2, 1124, 1125, 7, 11, 2, 2, 1125, 1127, 9, 7, 2, 2, 1126,
	1124, 3, 2, 2, 2, 1126, 1127, 3, 2, 2, 2, 1127, 147, 3, 2, 2, 2, 1128,
	1129, 7, 18, 2, 2, 1129, 1143, 5, 150, 76, 2, 1130, 1131, 7, 50, 2, 2,
	1131, 1143, 5, 152, 77, 2, 1132, 1133, 7, 58, 2, 2, 1133, 1143, 5, 154,
	78, 2, 1134, 1138, 7, 17, 2, 2, 1135, 1137, 7, 76, 2, 2, 1136, 1135, 3,
	2, 2, 2, 1137, 1140, 3, 2, 2, 2, 1138, 1136, 3, 2, 2, 2, 1138, 1139, 3,
	2, 2, 2, 1139, 1141, 3, 2, 2, 2, 1140, 1138, 3, 2, 2, 2, 1141, 1143, 5,
	158, 80, 2, 1142, 1128, 3, 2, 2, 2, 1142, 1130, 3, 2, 2, 2, 1142, 1132,
	3, 2, 2, 2, 1142, 1134, 3, 2, 2, 2, 1143, 149, 3, 2, 2, 2, 1144, 1145,
	5, 6, 4, 2, 1145, 1146, 7, 21, 2, 2, 1146, 1147, 5, 12, 7, 2, 1147, 151,
	3, 2, 2, 2, 1148, 1149, 5, 6, 4, 2, 1149, 1150, 7, 21, 2, 2, 1150, 1151,
	5, 12, 7, 2, 1151, 153, 3, 2, 2, 2, 1152, 1155, 5, 156, 79, 2, 1153, 1154,
	7, 21, 2, 2, 1154, 1156, 5, 12, 7, 2, 1155, 1153, 3, 2, 2, 2, 1155, 1156,
	3, 2, 2, 2, 1156, 155, 3, 2, 2, 2, 1157, 1159, 7, 64, 2, 2, 1158, 1160,
	5, 94, 48, 2, 1159, 1158, 3, 2, 2, 2, 1159, 1160, 3, 2, 2, 2, 1160, 1161,
	3, 2, 2, 2, 1161, 1162, 5, 100, 51, 2, 1162, 157, 3, 2, 2, 2, 1163, 1165,
	7, 64, 2, 2, 1164, 1166, 5, 92, 47, 2, 1165, 1164, 3, 2, 2, 2, 1165, 1166,
	3, 2, 2, 2, 1166, 1169, 3, 2, 2, 2, 1167, 1168, 7, 47, 2, 2, 1168, 1170,
	5, 12, 7, 2, 1169, 1167, 3, 2, 2, 2, 1169, 1170, 3, 2, 2, 2, 1170, 1173,
	3, 2, 2, 2, 1171, 1172, 7, 48, 2, 2, 1172, 1174, 5, 12, 7, 2, 1173, 1171,
	3, 2, 2, 2, 1173, 1174, 3, 2, 2, 2, 1174, 159, 3, 2, 2, 2, 1175, 1176,
	7, 18, 2, 2, 1176, 1180, 5, 164, 83, 2, 1177, 1178, 7, 50, 2, 2, 1178,
	1180, 5, 166, 84, 2, 1179, 1175, 3, 2, 2, 2, 1179, 1177, 3, 2, 2, 2, 1180,
	161, 3, 2, 2, 2, 1181, 1194, 5, 160, 81, 2, 1182, 1183, 7, 58, 2, 2, 1183,
	1194, 5, 168, 85, 2, 1184, 1188, 7, 17, 2, 2, 1185, 1187, 7, 76, 2, 2,
	1186, 1185, 3, 2, 2, 2, 1187, 1190, 3, 2, 2, 2, 1188, 1186, 3, 2, 2, 2,
	1188, 1189, 3, 2, 2, 2, 1189, 1191, 3, 2, 2, 2, 1190, 1188, 3, 2, 2, 2,
	1191, 1194, 5, 170, 86, 2, 1192, 1194, 5, 172, 87, 2, 1193, 1181, 3, 2,
	2, 2, 1193, 1182, 3, 2, 2, 2, 1193, 1184, 3, 2, 2, 2, 1193, 1192, 3, 2,
	2, 2, 1194, 163, 3, 2, 2, 2, 1195, 1200, 5, 84, 43, 2, 1196, 1197, 7, 6,
	2, 2, 1197, 1199, 5, 84, 43, 2, 1198, 1196, 3, 2, 2, 2, 1199, 1202, 3,
	2, 2, 2, 1200, 1198, 3, 2, 2, 2, 1200, 1201, 3, 2, 2, 2, 1201, 1205, 3,
	2, 2, 2, 1202, 1200, 3, 2, 2, 2, 1203, 1204, 7, 21, 2, 2, 1204, 1206, 5,
	12, 7, 2, 1205, 1203, 3, 2, 2, 2, 1205, 1206, 3, 2, 2, 2, 1206, 1207, 3,
	2, 2, 2, 1207, 1208, 7, 36, 2, 2, 1208, 1209, 5, 40, 21, 2, 1209, 165,
	3, 2, 2, 2, 1210, 1218, 5, 164, 83, 2, 1211, 1212, 5, 6, 4, 2, 1212, 1213,
	7, 21, 2, 2, 1213, 1214, 5, 12, 7, 2, 1214, 1215, 7, 36, 2, 2, 1215, 1216,
	7, 22, 2, 2, 1216, 1218, 3, 2, 2, 2, 1217, 1210, 3, 2, 2, 2, 1217, 1211,
	3, 2, 2, 2, 1218, 167, 3, 2, 2, 2, 1219, 1222, 5, 156, 79, 2, 1220, 1221,
	7, 21, 2, 2, 1221, 1223, 5, 12, 7, 2, 1222, 1220, 3, 2, 2, 2, 1222, 1223,
	3, 2, 2, 2, 1223, 1224, 3, 2, 2, 2, 1224, 1225, 7, 36, 2, 2, 1225, 1226,
	5, 40, 21, 2, 1226, 1247, 3, 2, 2, 2, 1227, 1229, 5, 156, 79, 2, 1228,
	1230, 7, 76, 2, 2, 1229, 1228, 3, 2, 2, 2, 1229, 1230, 3, 2, 2, 2, 1230,
	1231, 3, 2, 2, 2, 1231, 1232, 7, 15, 2, 2, 1232, 1233, 5, 64, 33, 2, 1233,
	1234, 7, 16, 2, 2, 1234, 1247, 3, 2, 2, 2, 1235, 1236, 7, 7, 2, 2, 1236,
	1237, 5, 102, 52, 2, 1237, 1244, 5, 100, 51, 2, 1238, 1239, 7, 36, 2, 2,
	1239, 1245, 5, 198, 100, 2, 1240, 1242, 7, 76, 2, 2, 1241, 1240, 3, 2,
	2, 2, 1241, 1242, 3, 2, 2, 2, 1242, 1243, 3, 2, 2, 2, 1243, 1245, 5, 200,
	101, 2, 1244, 1238, 3, 2, 2, 2, 1244, 1241, 3, 2, 2, 2, 1245, 1247, 3,
	2, 2, 2, 1246, 1219, 3, 2, 2, 2, 1246, 1227, 3, 2, 2, 2, 1246, 1235, 3,
	2, 2, 2, 1247, 169, 3, 2, 2, 2, 1248, 1250, 7, 64, 2, 2, 1249, 1251, 5,
	92, 47, 2, 1250, 1249, 3, 2, 2, 2, 1250, 1251, 3, 2, 2, 2, 1251, 1252,
	3, 2, 2, 2, 1252, 1253, 7, 36, 2, 2, 1253, 1254, 5, 12, 7, 2, 1254, 171,
	3, 2, 2, 2, 1255, 1257, 7, 44, 2, 2, 1256, 1255, 3, 2, 2, 2, 1256, 1257,
	3, 2, 2, 2, 1257, 1258, 3, 2, 2, 2, 1258, 1259, 7, 59, 2, 2, 1259, 1268,
	5, 174, 88, 2, 1260, 1262, 7, 44, 2, 2, 1261, 1260, 3, 2, 2, 2, 1261, 1262,
	3, 2, 2, 2, 1262, 1263, 3, 2, 2, 2, 1263, 1264, 7, 60, 2, 2, 1264, 1268,
	5, 178, 90, 2, 1265, 1266, 7, 61, 2, 2, 1266, 1268, 5, 176, 89, 2, 1267,
	1256, 3, 2, 2, 2, 1267, 1261, 3, 2, 2, 2, 1267, 1265, 3, 2, 2, 2, 1268,
	173, 3, 2, 2, 2, 1269, 1271, 7, 64, 2, 2, 1270, 1272, 5, 92, 47, 2, 1271,
	1270, 3, 2, 2, 2, 1271, 1272, 3, 2, 2, 2, 1272, 1276, 3, 2, 2, 2, 1273,
	1275, 5, 132, 67, 2, 1274, 1273, 3, 2, 2, 2, 1275, 1278, 3, 2, 2, 2, 1276,
	1274, 3, 2, 2, 2, 1276, 1277, 3, 2, 2, 2, 1277, 1280, 3, 2, 2, 2, 1278,
	1276, 3, 2, 2, 2, 1279, 1281, 5, 126, 64, 2, 1280, 1279, 3, 2, 2, 2, 1280,
	1281, 3, 2, 2, 2, 1281, 1282, 3, 2, 2, 2, 1282, 1283, 5, 110, 56, 2, 1283,
	1284, 5, 180, 91, 2, 1284, 175, 3, 2, 2, 2, 1285, 1287, 7, 64, 2, 2, 1286,
	1288, 5, 92, 47, 2, 1287, 1286, 3, 2, 2, 2, 1287, 1288, 3, 2, 2, 2, 1288,
	1289, 3, 2, 2, 2, 1289, 1290, 5, 182, 92, 2, 1290, 177, 3, 2, 2, 2, 1291,
	1292, 7, 64, 2, 2, 1292, 1293, 5, 180, 91, 2, 1293, 179, 3, 2, 2, 2, 1294,
	1295, 7, 62, 2, 2, 1295, 1303, 5, 184, 93, 2, 1296, 1298, 7, 62, 2, 2,
	1297, 1296, 3, 2, 2, 2, 1297, 1298, 3, 2, 2, 2, 1298, 1299, 3, 2, 2, 2,
	1299, 1301, 5, 134, 68, 2, 1300, 1297, 3, 2, 2, 2, 1300, 1301, 3, 2, 2,
	2, 1301, 1303, 3, 2, 2, 2, 1302, 1294, 3, 2, 2, 2, 1302, 1300, 3, 2, 2,
	2, 1303, 181, 3, 2, 2, 2, 1304, 1305, 7, 62, 2, 2, 1305, 1313, 5, 186,
	94, 2, 1306, 1308, 7, 62, 2, 2, 1307, 1306, 3, 2, 2, 2, 1307, 1308, 3,
	2, 2, 2, 1308, 1309, 3, 2, 2, 2, 1309, 1311, 5, 134, 68, 2, 1310, 1307,
	3, 2, 2, 2, 1310, 1311, 3, 2, 2, 2, 1311, 1313, 3, 2, 2, 2, 1312, 1304,
	3, 2, 2, 2, 1312, 1310, 3, 2, 2, 2, 1313, 183, 3, 2, 2, 2, 1314, 1316,
	5, 194, 98, 2, 1315, 1314, 3, 2, 2, 2, 1315, 1316, 3, 2, 2, 2, 1316, 1317,
	3, 2, 2, 2, 1317, 1319, 5, 188, 95, 2, 1318, 1320, 5, 134, 68, 2, 1319,
	1318, 3, 2, 2, 2, 1319, 1320, 3, 2, 2, 2, 1320, 185, 3, 2, 2, 2, 1321,
	1323, 5, 194, 98, 2, 1322, 1321, 3, 2, 2, 2, 1322, 1323, 3, 2, 2, 2, 1323,
	1324, 3, 2, 2, 2, 1324, 1326, 5, 190, 96, 2, 1325, 1327, 5, 134, 68, 2,
	1326, 1325, 3, 2, 2, 2, 1326, 1327, 3, 2, 2, 2, 1327, 187, 3, 2, 2, 2,
	1328, 1333, 5, 192, 97, 2, 1329, 1330, 7, 19, 2, 2, 1330, 1332, 5, 24,
	13, 2, 1331, 1329, 3, 2, 2, 2, 1332, 1335, 3, 2, 2, 2, 1333, 1331, 3, 2,
	2, 2, 1333, 1334, 3, 2, 2, 2, 1334, 189, 3, 2, 2, 2, 1335, 1333, 3, 2,
	2, 2, 1336, 1341, 5, 24, 13, 2, 1337, 1338, 7, 19, 2, 2, 1338, 1340, 5,
	24, 13, 2, 1339, 1337, 3, 2, 2, 2, 1340, 1343, 3, 2, 2, 2, 1341, 1339,
	3, 2, 2, 2, 1341, 1342, 3, 2, 2, 2, 1342, 191, 3, 2, 2, 2, 1343, 1341,
	3, 2, 2, 2, 1344, 1348, 5, 24, 13, 2, 1345, 1347, 5, 58, 30, 2, 1346, 1345,
	3, 2, 2, 2, 1347, 1350, 3, 2, 2, 2, 1348, 1346, 3, 2, 2, 2, 1348, 1349,
	3, 2, 2, 2, 1349, 193, 3, 2, 2, 2, 1350, 1348, 3, 2, 2, 2, 1351, 1353,
	7, 15, 2, 2, 1352, 1354, 5, 196, 99, 2, 1353, 1352, 3, 2, 2, 2, 1354, 1355,
	3, 2, 2, 2, 1355, 1353, 3, 2, 2, 2, 1355, 1356, 3, 2, 2, 2, 1356, 1357,
	3, 2, 2, 2, 1357, 1358, 7, 16, 2, 2, 1358, 1359, 7, 19, 2, 2, 1359, 195,
	3, 2, 2, 2, 1360, 1362, 5, 130, 66, 2, 1361, 1363, 7, 76, 2, 2, 1362, 1361,
	3, 2, 2, 2, 1362, 1363, 3, 2, 2, 2, 1363, 1365, 3, 2, 2, 2, 1364, 1360,
	3, 2, 2, 2, 1365, 1368, 3, 2, 2, 2, 1366, 1364, 3, 2, 2, 2, 1366, 1367,
	3, 2, 2, 2, 1367, 1372, 3, 2, 2, 2, 1368, 1366, 3, 2, 2, 2, 1369, 1371,
	5, 122, 62, 2, 1370, 1369, 3, 2, 2, 2, 1371, 1374, 3, 2, 2, 2, 1372, 1370,
	3, 2, 2, 2, 1372, 1373, 3, 2, 2, 2, 1373, 1375, 3, 2, 2, 2, 1374, 1372,
	3, 2, 2, 2, 1375, 1376, 5, 160, 81, 2, 1376, 197, 3, 2, 2, 2, 1377, 1380,
	5, 202, 102, 2, 1378, 1380, 5, 200, 101, 2, 1379, 1377, 3, 2, 2, 2, 1379,
	1378, 3, 2, 2, 2, 1380, 199, 3, 2, 2, 2, 1381, 1382, 7, 15, 2, 2, 1382,
	1386, 5, 202, 102, 2, 1383, 1385, 5, 66, 34, 2, 1384, 1383, 3, 2, 2, 2,
	1385, 1388, 3, 2, 2, 2, 1386, 1384, 3, 2, 2, 2, 1386, 1387, 3, 2, 2, 2,
	1387, 1389, 3, 2, 2, 2, 1388, 1386, 3, 2, 2, 2, 1389, 1390, 7, 16, 2, 2,
	1390, 201, 3, 2, 2, 2, 1391, 1393, 7, 7, 2, 2, 1392, 1394, 5, 58, 30, 2,
	1393, 1392, 3, 2, 2, 2, 1394, 1395, 3, 2, 2, 2, 1395, 1393, 3, 2, 2, 2,
	1395, 1396, 3, 2, 2, 2, 1396, 203, 3, 2, 2, 2, 1397, 1399, 5, 206, 104,
	2, 1398, 1397, 3, 2, 2, 2, 1399, 1400, 3, 2, 2, 2, 1400, 1398, 3, 2, 2,
	2, 1400, 1401, 3, 2, 2, 2, 1401, 205, 3, 2, 2, 2, 1402, 1404, 5, 130, 66,
	2, 1403, 1405, 7, 76, 2, 2, 1404, 1403, 3, 2, 2, 2, 1404, 1405, 3, 2, 2,
	2, 1405, 1407, 3, 2, 2, 2, 1406, 1402, 3, 2, 2, 2, 1407, 1410, 3, 2, 2,
	2, 1408, 1406, 3, 2, 2, 2, 1408, 1409, 3, 2, 2, 2, 1409, 1414, 3, 2, 2,
	2, 1410, 1408, 3, 2, 2, 2, 1411, 1413, 5, 122, 62, 2, 1412, 1411, 3, 2,
	2, 2, 1413, 1416, 3, 2, 2, 2, 1414, 1412, 3, 2, 2, 2, 1414, 1415, 3, 2,
	2, 2, 1415, 1417, 3, 2, 2, 2, 1416, 1414, 3, 2, 2, 2, 1417, 1422, 5, 172,
	87, 2, 1418, 1422, 5, 140, 71, 2, 1419, 1422, 5, 208, 105, 2, 1420, 1422,
	5, 210, 106, 2, 1421, 1408, 3, 2, 2, 2, 1421, 1418, 3, 2, 2, 2, 1421, 1419,
	3, 2, 2, 2, 1421, 1420, 3, 2, 2, 2, 1422, 207, 3, 2, 2, 2, 1423, 1424,
	7, 63, 2, 2, 1424, 1426, 5, 4, 3, 2, 1425, 1427, 7, 76, 2, 2, 1426, 1425,
	3, 2, 2, 2, 1426, 1427, 3, 2, 2, 2, 1427, 1428, 3, 2, 2, 2, 1428, 1429,
	7, 15, 2, 2, 1429, 1430, 5, 204, 103, 2, 1430, 1431, 7, 16, 2, 2, 1431,
	209, 3, 2, 2, 2, 1432, 1433, 7, 63, 2, 2, 1433, 1434, 7, 60, 2, 2, 1434,
	1435, 5, 178, 90, 2, 1435, 211, 3, 2, 2, 2, 1436, 1437, 7, 63, 2, 2, 1437,
	1439, 5, 4, 3, 2, 1438, 1436, 3, 2, 2, 2, 1439, 1442, 3, 2, 2, 2, 1440,
	1438, 3, 2, 2, 2, 1440, 1441, 3, 2, 2, 2, 1441, 1443, 3, 2, 2, 2, 1442,
	1440, 3, 2, 2, 2, 1443, 1444, 5, 204, 103, 2, 1444, 213, 3, 2, 2, 2, 210,
	215, 219, 227, 234, 242, 249, 254, 258, 260, 267, 280, 282, 291, 294, 297,
	304, 312, 319, 327, 331, 334, 340, 347, 353, 360, 362, 374, 378, 384, 391,
	401, 406, 410, 414, 419, 428, 434, 443, 452, 456, 474, 477, 485, 490, 492,
	496, 508, 516, 522, 529, 533, 541, 546, 550, 555, 557, 562, 565, 573, 583,
	587, 593, 598, 600, 608, 620, 623, 626, 631, 635, 637, 647, 652, 655, 661,
	665, 671, 677, 682, 687, 691, 695, 700, 705, 715, 717, 723, 728, 741, 748,
	753, 756, 762, 767, 770, 778, 781, 788, 792, 800, 803, 808, 812, 820, 831,
	839, 843, 849, 853, 857, 863, 870, 876, 880, 887, 890, 894, 903, 909, 915,
	919, 927, 932, 936, 943, 946, 950, 959, 965, 971, 975, 982, 990, 998, 1003,
	1009, 1020, 1028, 1032, 1037, 1044, 1048, 1054, 1060, 1064, 1070, 1075,
	1080, 1088, 1096, 1104, 1106, 1114, 1119, 1126, 1138, 1142, 1155, 1159,
	1165, 1169, 1173, 1179, 1188, 1193, 1200, 1205, 1217, 1222, 1229, 1241,
	1244, 1246, 1250, 1256, 1261, 1267, 1271, 1276, 1280, 1287, 1297, 1300,
	1302, 1307, 1310, 1312, 1315, 1319, 1322, 1326, 1333, 1341, 1348, 1355,
	1362, 1366, 1372, 1379, 1386, 1395, 1400, 1404, 1408, 1414, 1421, 1426,
	1440,
}
var literalNames = []string{
	"", "'-'", "'null'", "'.'", "','", "'this'", "'super'", "'['", "']'", "'=>'",
	"'('", "')'", "'forSome'", "'{'", "'}'", "'type'", "'val'", "'with'", "'#'",
	"':'", "'_'", "'*'", "'implicit'", "'if'", "'else'", "'while'", "'try'",
	"'catch'", "'finally'", "'do'", "'for'", "'yield'", "'throw'", "'return'",
	"'='", "'match'", "'+'", "'~'", "'!'", "'new'", "'lazy'", "'<-'", "'case'",
	"'|'", "'@'", "'>:'", "'<:'", "'<%'", "'var'", "'override'", "'abstract'",
	"'final'", "'sealed'", "'private'", "'protected'", "'import'", "'def'",
	"'class'", "'object'", "'trait'", "'extends'", "'package'",
}
var symbolicNames = []string{
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "Id", "BooleanLiteral", "CharacterLiteral",
	"SymbolLiteral", "IntegerLiteral", "StringLiteral", "FloatingPointLiteral",
	"Varid", "BoundVarid", "Paren", "Delim", "Semi", "NL", "NEWLINE", "WS",
	"COMMENT", "LINE_COMMENT",
}

var ruleNames = []string{
	"literal", "qualId", "ids", "stableId", "classQualifier", "type_", "functionArgTypes",
	"existentialClause", "existentialDcl", "infixType", "compoundType", "annotType",
	"simpleType", "typeArgs", "types", "refinement", "refineStat", "typePat",
	"ascription", "expr", "expr1", "prefixDef", "postfixExpr", "infixExpr",
	"prefixExpr", "simpleExpr", "simpleExpr1", "exprs", "argumentExprs", "args",
	"blockExpr", "block", "blockStat", "resultExpr", "enumerators", "generator",
	"caseClauses", "caseClause", "guard_", "pattern", "pattern1", "pattern2",
	"pattern3", "simplePattern", "patterns", "typeParamClause", "funTypeParamClause",
	"variantTypeParam", "typeParam", "paramClauses", "paramClause", "params",
	"param", "paramType", "classParamClauses", "classParamClause", "classParams",
	"classParam", "bindings", "binding", "modifier", "localModifier", "accessModifier",
	"accessQualifier", "annotation", "constrAnnotation", "templateBody", "templateStat",
	"selfType", "import_", "importExpr", "importSelectors", "importSelector",
	"dcl", "valDcl", "varDcl", "funDcl", "funSig", "typeDcl", "patVarDef",
	"def_", "patDef", "varDef", "funDef", "typeDef", "tmplDef", "classDef",
	"traitDef", "objectDef", "classTemplateOpt", "traitTemplateOpt", "classTemplate",
	"traitTemplate", "classParents", "traitParents", "constr", "earlyDefs",
	"earlyDef", "constrExpr", "constrBlock", "selfInvocation", "topStatSeq",
	"topStat", "packaging", "packageObject", "compilationUnit",
}

type ScalaParser struct {
	*antlr.BaseParser
}

// NewScalaParser produces a new parser instance for the optional input antlr.TokenStream.
//
// The *ScalaParser instance produced may be reused by calling the SetInputStream method.
// The initial parser configuration is expensive to construct, and the object is not thread-safe;
// however, if used within a Golang sync.Pool, the construction cost amortizes well and the
// objects can be used in a thread-safe manner.
func NewScalaParser(input antlr.TokenStream) *ScalaParser {
	this := new(ScalaParser)
	deserializer := antlr.NewATNDeserializer(nil)
	deserializedATN := deserializer.DeserializeFromUInt16(parserATN)
	decisionToDFA := make([]*antlr.DFA, len(deserializedATN.DecisionToState))
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "Scala.g4"

	return this
}

// ScalaParser tokens.
const (
	ScalaParserEOF                  = antlr.TokenEOF
	ScalaParserT__0                 = 1
	ScalaParserT__1                 = 2
	ScalaParserT__2                 = 3
	ScalaParserT__3                 = 4
	ScalaParserT__4                 = 5
	ScalaParserT__5                 = 6
	ScalaParserT__6                 = 7
	ScalaParserT__7                 = 8
	ScalaParserT__8                 = 9
	ScalaParserT__9                 = 10
	ScalaParserT__10                = 11
	ScalaParserT__11                = 12
	ScalaParserT__12                = 13
	ScalaParserT__13                = 14
	ScalaParserT__14                = 15
	ScalaParserT__15                = 16
	ScalaParserT__16                = 17
	ScalaParserT__17                = 18
	ScalaParserT__18                = 19
	ScalaParserT__19                = 20
	ScalaParserT__20                = 21
	ScalaParserT__21                = 22
	ScalaParserT__22                = 23
	ScalaParserT__23                = 24
	ScalaParserT__24                = 25
	ScalaParserT__25                = 26
	ScalaParserT__26                = 27
	ScalaParserT__27                = 28
	ScalaParserT__28                = 29
	ScalaParserT__29                = 30
	ScalaParserT__30                = 31
	ScalaParserT__31                = 32
	ScalaParserT__32                = 33
	ScalaParserT__33                = 34
	ScalaParserT__34                = 35
	ScalaParserT__35                = 36
	ScalaParserT__36                = 37
	ScalaParserT__37                = 38
	ScalaParserT__38                = 39
	ScalaParserT__39                = 40
	ScalaParserT__40                = 41
	ScalaParserT__41                = 42
	ScalaParserT__42                = 43
	ScalaParserT__43                = 44
	ScalaParserT__44                = 45
	ScalaParserT__45                = 46
	ScalaParserT__46                = 47
	ScalaParserT__47                = 48
	ScalaParserT__48                = 49
	ScalaParserT__49                = 50
	ScalaParserT__50                = 51
	ScalaParserT__51                = 52
	ScalaParserT__52                = 53
	ScalaParserT__53                = 54
	ScalaParserT__54                = 55
	ScalaParserT__55                = 56
	ScalaParserT__56                = 57
	ScalaParserT__57                = 58
	ScalaParserT__58                = 59
	ScalaParserT__59                = 60
	ScalaParserT__60                = 61
	ScalaParserId                   = 62
	ScalaParserBooleanLiteral       = 63
	ScalaParserCharacterLiteral     = 64
	ScalaParserSymbolLiteral        = 65
	ScalaParserIntegerLiteral       = 66
	ScalaParserStringLiteral        = 67
	ScalaParserFloatingPointLiteral = 68
	ScalaParserVarid                = 69
	ScalaParserBoundVarid           = 70
	ScalaParserParen                = 71
	ScalaParserDelim                = 72
	ScalaParserSemi                 = 73
	ScalaParserNL                   = 74
	ScalaParserNEWLINE              = 75
	ScalaParserWS                   = 76
	ScalaParserCOMMENT              = 77
	ScalaParserLINE_COMMENT         = 78
)

// ScalaParser rules.
const (
	ScalaParserRULE_literal            = 0
	ScalaParserRULE_qualId             = 1
	ScalaParserRULE_ids                = 2
	ScalaParserRULE_stableId           = 3
	ScalaParserRULE_classQualifier     = 4
	ScalaParserRULE_type_              = 5
	ScalaParserRULE_functionArgTypes   = 6
	ScalaParserRULE_existentialClause  = 7
	ScalaParserRULE_existentialDcl     = 8
	ScalaParserRULE_infixType          = 9
	ScalaParserRULE_compoundType       = 10
	ScalaParserRULE_annotType          = 11
	ScalaParserRULE_simpleType         = 12
	ScalaParserRULE_typeArgs           = 13
	ScalaParserRULE_types              = 14
	ScalaParserRULE_refinement         = 15
	ScalaParserRULE_refineStat         = 16
	ScalaParserRULE_typePat            = 17
	ScalaParserRULE_ascription         = 18
	ScalaParserRULE_expr               = 19
	ScalaParserRULE_expr1              = 20
	ScalaParserRULE_prefixDef          = 21
	ScalaParserRULE_postfixExpr        = 22
	ScalaParserRULE_infixExpr          = 23
	ScalaParserRULE_prefixExpr         = 24
	ScalaParserRULE_simpleExpr         = 25
	ScalaParserRULE_simpleExpr1        = 26
	ScalaParserRULE_exprs              = 27
	ScalaParserRULE_argumentExprs      = 28
	ScalaParserRULE_args               = 29
	ScalaParserRULE_blockExpr          = 30
	ScalaParserRULE_block              = 31
	ScalaParserRULE_blockStat          = 32
	ScalaParserRULE_resultExpr         = 33
	ScalaParserRULE_enumerators        = 34
	ScalaParserRULE_generator          = 35
	ScalaParserRULE_caseClauses        = 36
	ScalaParserRULE_caseClause         = 37
	ScalaParserRULE_guard_             = 38
	ScalaParserRULE_pattern            = 39
	ScalaParserRULE_pattern1           = 40
	ScalaParserRULE_pattern2           = 41
	ScalaParserRULE_pattern3           = 42
	ScalaParserRULE_simplePattern      = 43
	ScalaParserRULE_patterns           = 44
	ScalaParserRULE_typeParamClause    = 45
	ScalaParserRULE_funTypeParamClause = 46
	ScalaParserRULE_variantTypeParam   = 47
	ScalaParserRULE_typeParam          = 48
	ScalaParserRULE_paramClauses       = 49
	ScalaParserRULE_paramClause        = 50
	ScalaParserRULE_params             = 51
	ScalaParserRULE_param              = 52
	ScalaParserRULE_paramType          = 53
	ScalaParserRULE_classParamClauses  = 54
	ScalaParserRULE_classParamClause   = 55
	ScalaParserRULE_classParams        = 56
	ScalaParserRULE_classParam         = 57
	ScalaParserRULE_bindings           = 58
	ScalaParserRULE_binding            = 59
	ScalaParserRULE_modifier           = 60
	ScalaParserRULE_localModifier      = 61
	ScalaParserRULE_accessModifier     = 62
	ScalaParserRULE_accessQualifier    = 63
	ScalaParserRULE_annotation         = 64
	ScalaParserRULE_constrAnnotation   = 65
	ScalaParserRULE_templateBody       = 66
	ScalaParserRULE_templateStat       = 67
	ScalaParserRULE_selfType           = 68
	ScalaParserRULE_import_            = 69
	ScalaParserRULE_importExpr         = 70
	ScalaParserRULE_importSelectors    = 71
	ScalaParserRULE_importSelector     = 72
	ScalaParserRULE_dcl                = 73
	ScalaParserRULE_valDcl             = 74
	ScalaParserRULE_varDcl             = 75
	ScalaParserRULE_funDcl             = 76
	ScalaParserRULE_funSig             = 77
	ScalaParserRULE_typeDcl            = 78
	ScalaParserRULE_patVarDef          = 79
	ScalaParserRULE_def_               = 80
	ScalaParserRULE_patDef             = 81
	ScalaParserRULE_varDef             = 82
	ScalaParserRULE_funDef             = 83
	ScalaParserRULE_typeDef            = 84
	ScalaParserRULE_tmplDef            = 85
	ScalaParserRULE_classDef           = 86
	ScalaParserRULE_traitDef           = 87
	ScalaParserRULE_objectDef          = 88
	ScalaParserRULE_classTemplateOpt   = 89
	ScalaParserRULE_traitTemplateOpt   = 90
	ScalaParserRULE_classTemplate      = 91
	ScalaParserRULE_traitTemplate      = 92
	ScalaParserRULE_classParents       = 93
	ScalaParserRULE_traitParents       = 94
	ScalaParserRULE_constr             = 95
	ScalaParserRULE_earlyDefs          = 96
	ScalaParserRULE_earlyDef           = 97
	ScalaParserRULE_constrExpr         = 98
	ScalaParserRULE_constrBlock        = 99
	ScalaParserRULE_selfInvocation     = 100
	ScalaParserRULE_topStatSeq         = 101
	ScalaParserRULE_topStat            = 102
	ScalaParserRULE_packaging          = 103
	ScalaParserRULE_packageObject      = 104
	ScalaParserRULE_compilationUnit    = 105
)

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_literal
	return p
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) IntegerLiteral() antlr.TerminalNode {
	return s.GetToken(ScalaParserIntegerLiteral, 0)
}

func (s *LiteralContext) FloatingPointLiteral() antlr.TerminalNode {
	return s.GetToken(ScalaParserFloatingPointLiteral, 0)
}

func (s *LiteralContext) BooleanLiteral() antlr.TerminalNode {
	return s.GetToken(ScalaParserBooleanLiteral, 0)
}

func (s *LiteralContext) CharacterLiteral() antlr.TerminalNode {
	return s.GetToken(ScalaParserCharacterLiteral, 0)
}

func (s *LiteralContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(ScalaParserStringLiteral, 0)
}

func (s *LiteralContext) SymbolLiteral() antlr.TerminalNode {
	return s.GetToken(ScalaParserSymbolLiteral, 0)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterLiteral(s)
	}
}

func (s *LiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitLiteral(s)
	}
}

func (p *ScalaParser) Literal() (localctx ILiteralContext) {
	this := p
	_ = this

	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, ScalaParserRULE_literal)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(225)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 2, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(213)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ScalaParserT__0 {
			{
				p.SetState(212)
				p.Match(ScalaParserT__0)
			}

		}
		{
			p.SetState(215)
			p.Match(ScalaParserIntegerLiteral)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(217)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ScalaParserT__0 {
			{
				p.SetState(216)
				p.Match(ScalaParserT__0)
			}

		}
		{
			p.SetState(219)
			p.Match(ScalaParserFloatingPointLiteral)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(220)
			p.Match(ScalaParserBooleanLiteral)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(221)
			p.Match(ScalaParserCharacterLiteral)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(222)
			p.Match(ScalaParserStringLiteral)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(223)
			p.Match(ScalaParserSymbolLiteral)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(224)
			p.Match(ScalaParserT__1)
		}

	}

	return localctx
}

// IQualIdContext is an interface to support dynamic dispatch.
type IQualIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQualIdContext differentiates from other interfaces.
	IsQualIdContext()
}

type QualIdContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualIdContext() *QualIdContext {
	var p = new(QualIdContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_qualId
	return p
}

func (*QualIdContext) IsQualIdContext() {}

func NewQualIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualIdContext {
	var p = new(QualIdContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_qualId

	return p
}

func (s *QualIdContext) GetParser() antlr.Parser { return s.parser }

func (s *QualIdContext) AllId() []antlr.TerminalNode {
	return s.GetTokens(ScalaParserId)
}

func (s *QualIdContext) Id(i int) antlr.TerminalNode {
	return s.GetToken(ScalaParserId, i)
}

func (s *QualIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterQualId(s)
	}
}

func (s *QualIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitQualId(s)
	}
}

func (p *ScalaParser) QualId() (localctx IQualIdContext) {
	this := p
	_ = this

	localctx = NewQualIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, ScalaParserRULE_qualId)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(227)
		p.Match(ScalaParserId)
	}
	p.SetState(232)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ScalaParserT__2 {
		{
			p.SetState(228)
			p.Match(ScalaParserT__2)
		}
		{
			p.SetState(229)
			p.Match(ScalaParserId)
		}

		p.SetState(234)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IIdsContext is an interface to support dynamic dispatch.
type IIdsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdsContext differentiates from other interfaces.
	IsIdsContext()
}

type IdsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdsContext() *IdsContext {
	var p = new(IdsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_ids
	return p
}

func (*IdsContext) IsIdsContext() {}

func NewIdsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdsContext {
	var p = new(IdsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_ids

	return p
}

func (s *IdsContext) GetParser() antlr.Parser { return s.parser }

func (s *IdsContext) AllId() []antlr.TerminalNode {
	return s.GetTokens(ScalaParserId)
}

func (s *IdsContext) Id(i int) antlr.TerminalNode {
	return s.GetToken(ScalaParserId, i)
}

func (s *IdsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterIds(s)
	}
}

func (s *IdsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitIds(s)
	}
}

func (p *ScalaParser) Ids() (localctx IIdsContext) {
	this := p
	_ = this

	localctx = NewIdsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, ScalaParserRULE_ids)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(235)
		p.Match(ScalaParserId)
	}
	p.SetState(240)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ScalaParserT__3 {
		{
			p.SetState(236)
			p.Match(ScalaParserT__3)
		}
		{
			p.SetState(237)
			p.Match(ScalaParserId)
		}

		p.SetState(242)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IStableIdContext is an interface to support dynamic dispatch.
type IStableIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStableIdContext differentiates from other interfaces.
	IsStableIdContext()
}

type StableIdContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStableIdContext() *StableIdContext {
	var p = new(StableIdContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_stableId
	return p
}

func (*StableIdContext) IsStableIdContext() {}

func NewStableIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StableIdContext {
	var p = new(StableIdContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_stableId

	return p
}

func (s *StableIdContext) GetParser() antlr.Parser { return s.parser }

func (s *StableIdContext) AllId() []antlr.TerminalNode {
	return s.GetTokens(ScalaParserId)
}

func (s *StableIdContext) Id(i int) antlr.TerminalNode {
	return s.GetToken(ScalaParserId, i)
}

func (s *StableIdContext) ClassQualifier() IClassQualifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassQualifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassQualifierContext)
}

func (s *StableIdContext) StableId() IStableIdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStableIdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStableIdContext)
}

func (s *StableIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StableIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StableIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterStableId(s)
	}
}

func (s *StableIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitStableId(s)
	}
}

func (p *ScalaParser) StableId() (localctx IStableIdContext) {
	return p.stableId(0)
}

func (p *ScalaParser) stableId(_p int) (localctx IStableIdContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewStableIdContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IStableIdContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 6
	p.EnterRecursionRule(localctx, 6, ScalaParserRULE_stableId, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(258)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 8, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(244)
			p.Match(ScalaParserId)
		}

	case 2:
		p.SetState(247)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ScalaParserId {
			{
				p.SetState(245)
				p.Match(ScalaParserId)
			}
			{
				p.SetState(246)
				p.Match(ScalaParserT__2)
			}

		}
		p.SetState(256)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case ScalaParserT__4:
			{
				p.SetState(249)
				p.Match(ScalaParserT__4)
			}

		case ScalaParserT__5:
			{
				p.SetState(250)
				p.Match(ScalaParserT__5)
			}
			p.SetState(252)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == ScalaParserT__6 {
				{
					p.SetState(251)
					p.ClassQualifier()
				}

			}
			{
				p.SetState(254)
				p.Match(ScalaParserT__2)
			}
			{
				p.SetState(255)
				p.Match(ScalaParserId)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(265)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 9, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewStableIdContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, ScalaParserRULE_stableId)
			p.SetState(260)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
			}
			{
				p.SetState(261)
				p.Match(ScalaParserT__2)
			}
			{
				p.SetState(262)
				p.Match(ScalaParserId)
			}

		}
		p.SetState(267)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 9, p.GetParserRuleContext())
	}

	return localctx
}

// IClassQualifierContext is an interface to support dynamic dispatch.
type IClassQualifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassQualifierContext differentiates from other interfaces.
	IsClassQualifierContext()
}

type ClassQualifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassQualifierContext() *ClassQualifierContext {
	var p = new(ClassQualifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_classQualifier
	return p
}

func (*ClassQualifierContext) IsClassQualifierContext() {}

func NewClassQualifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassQualifierContext {
	var p = new(ClassQualifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_classQualifier

	return p
}

func (s *ClassQualifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassQualifierContext) Id() antlr.TerminalNode {
	return s.GetToken(ScalaParserId, 0)
}

func (s *ClassQualifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassQualifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassQualifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterClassQualifier(s)
	}
}

func (s *ClassQualifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitClassQualifier(s)
	}
}

func (p *ScalaParser) ClassQualifier() (localctx IClassQualifierContext) {
	this := p
	_ = this

	localctx = NewClassQualifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, ScalaParserRULE_classQualifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(268)
		p.Match(ScalaParserT__6)
	}
	{
		p.SetState(269)
		p.Match(ScalaParserId)
	}
	{
		p.SetState(270)
		p.Match(ScalaParserT__7)
	}

	return localctx
}

// IType_Context is an interface to support dynamic dispatch.
type IType_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsType_Context differentiates from other interfaces.
	IsType_Context()
}

type Type_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_Context() *Type_Context {
	var p = new(Type_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_type_
	return p
}

func (*Type_Context) IsType_Context() {}

func NewType_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_Context {
	var p = new(Type_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_type_

	return p
}

func (s *Type_Context) GetParser() antlr.Parser { return s.parser }

func (s *Type_Context) FunctionArgTypes() IFunctionArgTypesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionArgTypesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionArgTypesContext)
}

func (s *Type_Context) Type_() IType_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *Type_Context) InfixType() IInfixTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInfixTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInfixTypeContext)
}

func (s *Type_Context) ExistentialClause() IExistentialClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExistentialClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExistentialClauseContext)
}

func (s *Type_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterType_(s)
	}
}

func (s *Type_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitType_(s)
	}
}

func (p *ScalaParser) Type_() (localctx IType_Context) {
	this := p
	_ = this

	localctx = NewType_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, ScalaParserRULE_type_)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(280)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 11, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(272)
			p.FunctionArgTypes()
		}
		{
			p.SetState(273)
			p.Match(ScalaParserT__8)
		}
		{
			p.SetState(274)
			p.Type_()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(276)
			p.InfixType()
		}
		p.SetState(278)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ScalaParserT__11 {
			{
				p.SetState(277)
				p.ExistentialClause()
			}

		}

	}

	return localctx
}

// IFunctionArgTypesContext is an interface to support dynamic dispatch.
type IFunctionArgTypesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionArgTypesContext differentiates from other interfaces.
	IsFunctionArgTypesContext()
}

type FunctionArgTypesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionArgTypesContext() *FunctionArgTypesContext {
	var p = new(FunctionArgTypesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_functionArgTypes
	return p
}

func (*FunctionArgTypesContext) IsFunctionArgTypesContext() {}

func NewFunctionArgTypesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionArgTypesContext {
	var p = new(FunctionArgTypesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_functionArgTypes

	return p
}

func (s *FunctionArgTypesContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionArgTypesContext) InfixType() IInfixTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInfixTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInfixTypeContext)
}

func (s *FunctionArgTypesContext) AllParamType() []IParamTypeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IParamTypeContext)(nil)).Elem())
	var tst = make([]IParamTypeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IParamTypeContext)
		}
	}

	return tst
}

func (s *FunctionArgTypesContext) ParamType(i int) IParamTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParamTypeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IParamTypeContext)
}

func (s *FunctionArgTypesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionArgTypesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionArgTypesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterFunctionArgTypes(s)
	}
}

func (s *FunctionArgTypesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitFunctionArgTypes(s)
	}
}

func (p *ScalaParser) FunctionArgTypes() (localctx IFunctionArgTypesContext) {
	this := p
	_ = this

	localctx = NewFunctionArgTypesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, ScalaParserRULE_functionArgTypes)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(295)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 14, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(282)
			p.InfixType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(283)
			p.Match(ScalaParserT__9)
		}
		p.SetState(292)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ScalaParserT__4)|(1<<ScalaParserT__5)|(1<<ScalaParserT__8)|(1<<ScalaParserT__9)|(1<<ScalaParserT__12))) != 0) || _la == ScalaParserId || _la == ScalaParserNL {
			{
				p.SetState(284)
				p.ParamType()
			}
			p.SetState(289)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == ScalaParserT__3 {
				{
					p.SetState(285)
					p.Match(ScalaParserT__3)
				}
				{
					p.SetState(286)
					p.ParamType()
				}

				p.SetState(291)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(294)
			p.Match(ScalaParserT__10)
		}

	}

	return localctx
}

// IExistentialClauseContext is an interface to support dynamic dispatch.
type IExistentialClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExistentialClauseContext differentiates from other interfaces.
	IsExistentialClauseContext()
}

type ExistentialClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExistentialClauseContext() *ExistentialClauseContext {
	var p = new(ExistentialClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_existentialClause
	return p
}

func (*ExistentialClauseContext) IsExistentialClauseContext() {}

func NewExistentialClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExistentialClauseContext {
	var p = new(ExistentialClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_existentialClause

	return p
}

func (s *ExistentialClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ExistentialClauseContext) AllExistentialDcl() []IExistentialDclContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExistentialDclContext)(nil)).Elem())
	var tst = make([]IExistentialDclContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExistentialDclContext)
		}
	}

	return tst
}

func (s *ExistentialClauseContext) ExistentialDcl(i int) IExistentialDclContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExistentialDclContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExistentialDclContext)
}

func (s *ExistentialClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExistentialClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExistentialClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterExistentialClause(s)
	}
}

func (s *ExistentialClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitExistentialClause(s)
	}
}

func (p *ScalaParser) ExistentialClause() (localctx IExistentialClauseContext) {
	this := p
	_ = this

	localctx = NewExistentialClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, ScalaParserRULE_existentialClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(297)
		p.Match(ScalaParserT__11)
	}
	{
		p.SetState(298)
		p.Match(ScalaParserT__12)
	}
	p.SetState(300)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == ScalaParserT__14 || _la == ScalaParserT__15 {
		{
			p.SetState(299)
			p.ExistentialDcl()
		}

		p.SetState(302)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(304)
		p.Match(ScalaParserT__13)
	}

	return localctx
}

// IExistentialDclContext is an interface to support dynamic dispatch.
type IExistentialDclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExistentialDclContext differentiates from other interfaces.
	IsExistentialDclContext()
}

type ExistentialDclContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExistentialDclContext() *ExistentialDclContext {
	var p = new(ExistentialDclContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_existentialDcl
	return p
}

func (*ExistentialDclContext) IsExistentialDclContext() {}

func NewExistentialDclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExistentialDclContext {
	var p = new(ExistentialDclContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_existentialDcl

	return p
}

func (s *ExistentialDclContext) GetParser() antlr.Parser { return s.parser }

func (s *ExistentialDclContext) TypeDcl() ITypeDclContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeDclContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeDclContext)
}

func (s *ExistentialDclContext) ValDcl() IValDclContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValDclContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValDclContext)
}

func (s *ExistentialDclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExistentialDclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExistentialDclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterExistentialDcl(s)
	}
}

func (s *ExistentialDclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitExistentialDcl(s)
	}
}

func (p *ScalaParser) ExistentialDcl() (localctx IExistentialDclContext) {
	this := p
	_ = this

	localctx = NewExistentialDclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, ScalaParserRULE_existentialDcl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(310)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ScalaParserT__14:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(306)
			p.Match(ScalaParserT__14)
		}
		{
			p.SetState(307)
			p.TypeDcl()
		}

	case ScalaParserT__15:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(308)
			p.Match(ScalaParserT__15)
		}
		{
			p.SetState(309)
			p.ValDcl()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IInfixTypeContext is an interface to support dynamic dispatch.
type IInfixTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInfixTypeContext differentiates from other interfaces.
	IsInfixTypeContext()
}

type InfixTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInfixTypeContext() *InfixTypeContext {
	var p = new(InfixTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_infixType
	return p
}

func (*InfixTypeContext) IsInfixTypeContext() {}

func NewInfixTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InfixTypeContext {
	var p = new(InfixTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_infixType

	return p
}

func (s *InfixTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *InfixTypeContext) AllCompoundType() []ICompoundTypeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICompoundTypeContext)(nil)).Elem())
	var tst = make([]ICompoundTypeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICompoundTypeContext)
		}
	}

	return tst
}

func (s *InfixTypeContext) CompoundType(i int) ICompoundTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompoundTypeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICompoundTypeContext)
}

func (s *InfixTypeContext) AllId() []antlr.TerminalNode {
	return s.GetTokens(ScalaParserId)
}

func (s *InfixTypeContext) Id(i int) antlr.TerminalNode {
	return s.GetToken(ScalaParserId, i)
}

func (s *InfixTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InfixTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InfixTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterInfixType(s)
	}
}

func (s *InfixTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitInfixType(s)
	}
}

func (p *ScalaParser) InfixType() (localctx IInfixTypeContext) {
	this := p
	_ = this

	localctx = NewInfixTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, ScalaParserRULE_infixType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(312)
		p.CompoundType()
	}
	p.SetState(317)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 17, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(313)
				p.Match(ScalaParserId)
			}
			{
				p.SetState(314)
				p.CompoundType()
			}

		}
		p.SetState(319)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 17, p.GetParserRuleContext())
	}

	return localctx
}

// ICompoundTypeContext is an interface to support dynamic dispatch.
type ICompoundTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCompoundTypeContext differentiates from other interfaces.
	IsCompoundTypeContext()
}

type CompoundTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompoundTypeContext() *CompoundTypeContext {
	var p = new(CompoundTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_compoundType
	return p
}

func (*CompoundTypeContext) IsCompoundTypeContext() {}

func NewCompoundTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompoundTypeContext {
	var p = new(CompoundTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_compoundType

	return p
}

func (s *CompoundTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *CompoundTypeContext) AllAnnotType() []IAnnotTypeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotTypeContext)(nil)).Elem())
	var tst = make([]IAnnotTypeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotTypeContext)
		}
	}

	return tst
}

func (s *CompoundTypeContext) AnnotType(i int) IAnnotTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotTypeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotTypeContext)
}

func (s *CompoundTypeContext) Refinement() IRefinementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRefinementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRefinementContext)
}

func (s *CompoundTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompoundTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompoundTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterCompoundType(s)
	}
}

func (s *CompoundTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitCompoundType(s)
	}
}

func (p *ScalaParser) CompoundType() (localctx ICompoundTypeContext) {
	this := p
	_ = this

	localctx = NewCompoundTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, ScalaParserRULE_compoundType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(332)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ScalaParserT__4, ScalaParserT__5, ScalaParserT__9, ScalaParserId:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(320)
			p.AnnotType()
		}
		p.SetState(325)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == ScalaParserT__16 {
			{
				p.SetState(321)
				p.Match(ScalaParserT__16)
			}
			{
				p.SetState(322)
				p.AnnotType()
			}

			p.SetState(327)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(329)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 19, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(328)
				p.Refinement()
			}

		}

	case ScalaParserT__12, ScalaParserNL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(331)
			p.Refinement()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAnnotTypeContext is an interface to support dynamic dispatch.
type IAnnotTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnnotTypeContext differentiates from other interfaces.
	IsAnnotTypeContext()
}

type AnnotTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotTypeContext() *AnnotTypeContext {
	var p = new(AnnotTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_annotType
	return p
}

func (*AnnotTypeContext) IsAnnotTypeContext() {}

func NewAnnotTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotTypeContext {
	var p = new(AnnotTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_annotType

	return p
}

func (s *AnnotTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotTypeContext) SimpleType() ISimpleTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimpleTypeContext)
}

func (s *AnnotTypeContext) AllAnnotation() []IAnnotationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotationContext)(nil)).Elem())
	var tst = make([]IAnnotationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotationContext)
		}
	}

	return tst
}

func (s *AnnotTypeContext) Annotation(i int) IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *AnnotTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterAnnotType(s)
	}
}

func (s *AnnotTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitAnnotType(s)
	}
}

func (p *ScalaParser) AnnotType() (localctx IAnnotTypeContext) {
	this := p
	_ = this

	localctx = NewAnnotTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, ScalaParserRULE_annotType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(334)
		p.simpleType(0)
	}
	p.SetState(338)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 21, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(335)
				p.Annotation()
			}

		}
		p.SetState(340)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 21, p.GetParserRuleContext())
	}

	return localctx
}

// ISimpleTypeContext is an interface to support dynamic dispatch.
type ISimpleTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimpleTypeContext differentiates from other interfaces.
	IsSimpleTypeContext()
}

type SimpleTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleTypeContext() *SimpleTypeContext {
	var p = new(SimpleTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_simpleType
	return p
}

func (*SimpleTypeContext) IsSimpleTypeContext() {}

func NewSimpleTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleTypeContext {
	var p = new(SimpleTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_simpleType

	return p
}

func (s *SimpleTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleTypeContext) StableId() IStableIdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStableIdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStableIdContext)
}

func (s *SimpleTypeContext) Types() ITypesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypesContext)
}

func (s *SimpleTypeContext) SimpleType() ISimpleTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimpleTypeContext)
}

func (s *SimpleTypeContext) TypeArgs() ITypeArgsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeArgsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeArgsContext)
}

func (s *SimpleTypeContext) Id() antlr.TerminalNode {
	return s.GetToken(ScalaParserId, 0)
}

func (s *SimpleTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterSimpleType(s)
	}
}

func (s *SimpleTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitSimpleType(s)
	}
}

func (p *ScalaParser) SimpleType() (localctx ISimpleTypeContext) {
	return p.simpleType(0)
}

func (p *ScalaParser) simpleType(_p int) (localctx ISimpleTypeContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewSimpleTypeContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ISimpleTypeContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 24
	p.EnterRecursionRule(localctx, 24, ScalaParserRULE_simpleType, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(351)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ScalaParserT__4, ScalaParserT__5, ScalaParserId:
		{
			p.SetState(342)
			p.stableId(0)
		}
		p.SetState(345)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 22, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(343)
				p.Match(ScalaParserT__2)
			}
			{
				p.SetState(344)
				p.Match(ScalaParserT__14)
			}

		}

	case ScalaParserT__9:
		{
			p.SetState(347)
			p.Match(ScalaParserT__9)
		}
		{
			p.SetState(348)
			p.Types()
		}
		{
			p.SetState(349)
			p.Match(ScalaParserT__10)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(360)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 25, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(358)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 24, p.GetParserRuleContext()) {
			case 1:
				localctx = NewSimpleTypeContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, ScalaParserRULE_simpleType)
				p.SetState(353)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
				}
				{
					p.SetState(354)
					p.TypeArgs()
				}

			case 2:
				localctx = NewSimpleTypeContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, ScalaParserRULE_simpleType)
				p.SetState(355)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				}
				{
					p.SetState(356)
					p.Match(ScalaParserT__17)
				}
				{
					p.SetState(357)
					p.Match(ScalaParserId)
				}

			}

		}
		p.SetState(362)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 25, p.GetParserRuleContext())
	}

	return localctx
}

// ITypeArgsContext is an interface to support dynamic dispatch.
type ITypeArgsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeArgsContext differentiates from other interfaces.
	IsTypeArgsContext()
}

type TypeArgsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeArgsContext() *TypeArgsContext {
	var p = new(TypeArgsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_typeArgs
	return p
}

func (*TypeArgsContext) IsTypeArgsContext() {}

func NewTypeArgsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeArgsContext {
	var p = new(TypeArgsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_typeArgs

	return p
}

func (s *TypeArgsContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeArgsContext) Types() ITypesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypesContext)
}

func (s *TypeArgsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeArgsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeArgsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterTypeArgs(s)
	}
}

func (s *TypeArgsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitTypeArgs(s)
	}
}

func (p *ScalaParser) TypeArgs() (localctx ITypeArgsContext) {
	this := p
	_ = this

	localctx = NewTypeArgsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, ScalaParserRULE_typeArgs)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(363)
		p.Match(ScalaParserT__6)
	}
	{
		p.SetState(364)
		p.Types()
	}
	{
		p.SetState(365)
		p.Match(ScalaParserT__7)
	}

	return localctx
}

// ITypesContext is an interface to support dynamic dispatch.
type ITypesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypesContext differentiates from other interfaces.
	IsTypesContext()
}

type TypesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypesContext() *TypesContext {
	var p = new(TypesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_types
	return p
}

func (*TypesContext) IsTypesContext() {}

func NewTypesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypesContext {
	var p = new(TypesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_types

	return p
}

func (s *TypesContext) GetParser() antlr.Parser { return s.parser }

func (s *TypesContext) AllType_() []IType_Context {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IType_Context)(nil)).Elem())
	var tst = make([]IType_Context, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IType_Context)
		}
	}

	return tst
}

func (s *TypesContext) Type_(i int) IType_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_Context)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *TypesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterTypes(s)
	}
}

func (s *TypesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitTypes(s)
	}
}

func (p *ScalaParser) Types() (localctx ITypesContext) {
	this := p
	_ = this

	localctx = NewTypesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, ScalaParserRULE_types)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(367)
		p.Type_()
	}
	p.SetState(372)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ScalaParserT__3 {
		{
			p.SetState(368)
			p.Match(ScalaParserT__3)
		}
		{
			p.SetState(369)
			p.Type_()
		}

		p.SetState(374)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IRefinementContext is an interface to support dynamic dispatch.
type IRefinementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRefinementContext differentiates from other interfaces.
	IsRefinementContext()
}

type RefinementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRefinementContext() *RefinementContext {
	var p = new(RefinementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_refinement
	return p
}

func (*RefinementContext) IsRefinementContext() {}

func NewRefinementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RefinementContext {
	var p = new(RefinementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_refinement

	return p
}

func (s *RefinementContext) GetParser() antlr.Parser { return s.parser }

func (s *RefinementContext) NL() antlr.TerminalNode {
	return s.GetToken(ScalaParserNL, 0)
}

func (s *RefinementContext) AllRefineStat() []IRefineStatContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRefineStatContext)(nil)).Elem())
	var tst = make([]IRefineStatContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRefineStatContext)
		}
	}

	return tst
}

func (s *RefinementContext) RefineStat(i int) IRefineStatContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRefineStatContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRefineStatContext)
}

func (s *RefinementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RefinementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RefinementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterRefinement(s)
	}
}

func (s *RefinementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitRefinement(s)
	}
}

func (p *ScalaParser) Refinement() (localctx IRefinementContext) {
	this := p
	_ = this

	localctx = NewRefinementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, ScalaParserRULE_refinement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(376)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ScalaParserNL {
		{
			p.SetState(375)
			p.Match(ScalaParserNL)
		}

	}
	{
		p.SetState(378)
		p.Match(ScalaParserT__12)
	}
	p.SetState(380)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == ScalaParserT__14 || _la == ScalaParserT__15 || _la == ScalaParserT__47 || _la == ScalaParserT__55 {
		{
			p.SetState(379)
			p.RefineStat()
		}

		p.SetState(382)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(384)
		p.Match(ScalaParserT__13)
	}

	return localctx
}

// IRefineStatContext is an interface to support dynamic dispatch.
type IRefineStatContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRefineStatContext differentiates from other interfaces.
	IsRefineStatContext()
}

type RefineStatContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRefineStatContext() *RefineStatContext {
	var p = new(RefineStatContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_refineStat
	return p
}

func (*RefineStatContext) IsRefineStatContext() {}

func NewRefineStatContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RefineStatContext {
	var p = new(RefineStatContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_refineStat

	return p
}

func (s *RefineStatContext) GetParser() antlr.Parser { return s.parser }

func (s *RefineStatContext) Dcl() IDclContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDclContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDclContext)
}

func (s *RefineStatContext) TypeDef() ITypeDefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeDefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeDefContext)
}

func (s *RefineStatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RefineStatContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RefineStatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterRefineStat(s)
	}
}

func (s *RefineStatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitRefineStat(s)
	}
}

func (p *ScalaParser) RefineStat() (localctx IRefineStatContext) {
	this := p
	_ = this

	localctx = NewRefineStatContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, ScalaParserRULE_refineStat)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(389)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 29, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(386)
			p.Dcl()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(387)
			p.Match(ScalaParserT__14)
		}
		{
			p.SetState(388)
			p.TypeDef()
		}

	}

	return localctx
}

// ITypePatContext is an interface to support dynamic dispatch.
type ITypePatContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypePatContext differentiates from other interfaces.
	IsTypePatContext()
}

type TypePatContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypePatContext() *TypePatContext {
	var p = new(TypePatContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_typePat
	return p
}

func (*TypePatContext) IsTypePatContext() {}

func NewTypePatContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypePatContext {
	var p = new(TypePatContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_typePat

	return p
}

func (s *TypePatContext) GetParser() antlr.Parser { return s.parser }

func (s *TypePatContext) Type_() IType_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *TypePatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypePatContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypePatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterTypePat(s)
	}
}

func (s *TypePatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitTypePat(s)
	}
}

func (p *ScalaParser) TypePat() (localctx ITypePatContext) {
	this := p
	_ = this

	localctx = NewTypePatContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, ScalaParserRULE_typePat)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(391)
		p.Type_()
	}

	return localctx
}

// IAscriptionContext is an interface to support dynamic dispatch.
type IAscriptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAscriptionContext differentiates from other interfaces.
	IsAscriptionContext()
}

type AscriptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAscriptionContext() *AscriptionContext {
	var p = new(AscriptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_ascription
	return p
}

func (*AscriptionContext) IsAscriptionContext() {}

func NewAscriptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AscriptionContext {
	var p = new(AscriptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_ascription

	return p
}

func (s *AscriptionContext) GetParser() antlr.Parser { return s.parser }

func (s *AscriptionContext) InfixType() IInfixTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInfixTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInfixTypeContext)
}

func (s *AscriptionContext) AllAnnotation() []IAnnotationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotationContext)(nil)).Elem())
	var tst = make([]IAnnotationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotationContext)
		}
	}

	return tst
}

func (s *AscriptionContext) Annotation(i int) IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *AscriptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AscriptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AscriptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterAscription(s)
	}
}

func (s *AscriptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitAscription(s)
	}
}

func (p *ScalaParser) Ascription() (localctx IAscriptionContext) {
	this := p
	_ = this

	localctx = NewAscriptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, ScalaParserRULE_ascription)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(404)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 31, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(393)
			p.Match(ScalaParserT__18)
		}
		{
			p.SetState(394)
			p.InfixType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(395)
			p.Match(ScalaParserT__18)
		}
		p.SetState(397)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(396)
					p.Annotation()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(399)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 30, p.GetParserRuleContext())
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(401)
			p.Match(ScalaParserT__18)
		}
		{
			p.SetState(402)
			p.Match(ScalaParserT__19)
		}
		{
			p.SetState(403)
			p.Match(ScalaParserT__20)
		}

	}

	return localctx
}

// IExprContext is an interface to support dynamic dispatch.
type IExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExprContext differentiates from other interfaces.
	IsExprContext()
}

type ExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprContext() *ExprContext {
	var p = new(ExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_expr
	return p
}

func (*ExprContext) IsExprContext() {}

func NewExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprContext {
	var p = new(ExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_expr

	return p
}

func (s *ExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprContext) Bindings() IBindingsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBindingsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBindingsContext)
}

func (s *ExprContext) Id() antlr.TerminalNode {
	return s.GetToken(ScalaParserId, 0)
}

func (s *ExprContext) Expr1() IExpr1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr1Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr1Context)
}

func (s *ExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterExpr(s)
	}
}

func (s *ExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitExpr(s)
	}
}

func (p *ScalaParser) Expr() (localctx IExprContext) {
	this := p
	_ = this

	localctx = NewExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, ScalaParserRULE_expr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(417)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 34, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(412)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case ScalaParserT__9:
			{
				p.SetState(406)
				p.Bindings()
			}

		case ScalaParserT__21, ScalaParserId:
			p.SetState(408)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == ScalaParserT__21 {
				{
					p.SetState(407)
					p.Match(ScalaParserT__21)
				}

			}
			{
				p.SetState(410)
				p.Match(ScalaParserId)
			}

		case ScalaParserT__19:
			{
				p.SetState(411)
				p.Match(ScalaParserT__19)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(414)
			p.Match(ScalaParserT__8)
		}
		{
			p.SetState(415)
			p.Expr()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(416)
			p.Expr1()
		}

	}

	return localctx
}

// IExpr1Context is an interface to support dynamic dispatch.
type IExpr1Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr1Context differentiates from other interfaces.
	IsExpr1Context()
}

type Expr1Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr1Context() *Expr1Context {
	var p = new(Expr1Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_expr1
	return p
}

func (*Expr1Context) IsExpr1Context() {}

func NewExpr1Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr1Context {
	var p = new(Expr1Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_expr1

	return p
}

func (s *Expr1Context) GetParser() antlr.Parser { return s.parser }

func (s *Expr1Context) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *Expr1Context) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Expr1Context) AllNL() []antlr.TerminalNode {
	return s.GetTokens(ScalaParserNL)
}

func (s *Expr1Context) NL(i int) antlr.TerminalNode {
	return s.GetToken(ScalaParserNL, i)
}

func (s *Expr1Context) Enumerators() IEnumeratorsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumeratorsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnumeratorsContext)
}

func (s *Expr1Context) Id() antlr.TerminalNode {
	return s.GetToken(ScalaParserId, 0)
}

func (s *Expr1Context) SimpleExpr() ISimpleExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimpleExprContext)
}

func (s *Expr1Context) SimpleExpr1() ISimpleExpr1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleExpr1Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimpleExpr1Context)
}

func (s *Expr1Context) ArgumentExprs() IArgumentExprsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentExprsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgumentExprsContext)
}

func (s *Expr1Context) PostfixExpr() IPostfixExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPostfixExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPostfixExprContext)
}

func (s *Expr1Context) Ascription() IAscriptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAscriptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAscriptionContext)
}

func (s *Expr1Context) CaseClauses() ICaseClausesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICaseClausesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICaseClausesContext)
}

func (s *Expr1Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr1Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr1Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterExpr1(s)
	}
}

func (s *Expr1Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitExpr1(s)
	}
}

func (p *ScalaParser) Expr1() (localctx IExpr1Context) {
	this := p
	_ = this

	localctx = NewExpr1Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, ScalaParserRULE_expr1)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(514)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 47, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(419)
			p.Match(ScalaParserT__22)
		}
		{
			p.SetState(420)
			p.Match(ScalaParserT__9)
		}
		{
			p.SetState(421)
			p.Expr()
		}
		{
			p.SetState(422)
			p.Match(ScalaParserT__10)
		}
		p.SetState(426)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == ScalaParserNL {
			{
				p.SetState(423)
				p.Match(ScalaParserNL)
			}

			p.SetState(428)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(429)
			p.Expr()
		}
		p.SetState(432)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 36, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(430)
				p.Match(ScalaParserT__23)
			}
			{
				p.SetState(431)
				p.Expr()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(434)
			p.Match(ScalaParserT__24)
		}
		{
			p.SetState(435)
			p.Match(ScalaParserT__9)
		}
		{
			p.SetState(436)
			p.Expr()
		}
		{
			p.SetState(437)
			p.Match(ScalaParserT__10)
		}
		p.SetState(441)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == ScalaParserNL {
			{
				p.SetState(438)
				p.Match(ScalaParserNL)
			}

			p.SetState(443)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(444)
			p.Expr()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(446)
			p.Match(ScalaParserT__25)
		}
		{
			p.SetState(447)
			p.Expr()
		}
		p.SetState(450)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 38, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(448)
				p.Match(ScalaParserT__26)
			}
			{
				p.SetState(449)
				p.Expr()
			}

		}
		p.SetState(454)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 39, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(452)
				p.Match(ScalaParserT__27)
			}
			{
				p.SetState(453)
				p.Expr()
			}

		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(456)
			p.Match(ScalaParserT__28)
		}
		{
			p.SetState(457)
			p.Expr()
		}
		{
			p.SetState(458)
			p.Match(ScalaParserT__24)
		}
		{
			p.SetState(459)
			p.Match(ScalaParserT__9)
		}
		{
			p.SetState(460)
			p.Expr()
		}
		{
			p.SetState(461)
			p.Match(ScalaParserT__10)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(463)
			p.Match(ScalaParserT__29)
		}
		p.SetState(472)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case ScalaParserT__9:
			{
				p.SetState(464)
				p.Match(ScalaParserT__9)
			}
			{
				p.SetState(465)
				p.Enumerators()
			}
			{
				p.SetState(466)
				p.Match(ScalaParserT__10)
			}

		case ScalaParserT__12:
			{
				p.SetState(468)
				p.Match(ScalaParserT__12)
			}
			{
				p.SetState(469)
				p.Enumerators()
			}
			{
				p.SetState(470)
				p.Match(ScalaParserT__13)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		p.SetState(475)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ScalaParserT__30 {
			{
				p.SetState(474)
				p.Match(ScalaParserT__30)
			}

		}
		{
			p.SetState(477)
			p.Expr()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(479)
			p.Match(ScalaParserT__31)
		}
		{
			p.SetState(480)
			p.Expr()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(481)
			p.Match(ScalaParserT__32)
		}
		p.SetState(483)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 42, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(482)
				p.Expr()
			}

		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		p.SetState(494)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 45, p.GetParserRuleContext()) == 1 {
			p.SetState(490)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 44, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(485)
					p.SimpleExpr()
				}

			case 2:
				{
					p.SetState(486)
					p.simpleExpr1(0)
				}
				p.SetState(488)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == ScalaParserT__19 {
					{
						p.SetState(487)
						p.Match(ScalaParserT__19)
					}

				}

			}
			{
				p.SetState(492)
				p.Match(ScalaParserT__2)
			}

		}
		{
			p.SetState(496)
			p.Match(ScalaParserId)
		}
		{
			p.SetState(497)
			p.Match(ScalaParserT__33)
		}
		{
			p.SetState(498)
			p.Expr()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(499)
			p.simpleExpr1(0)
		}
		{
			p.SetState(500)
			p.ArgumentExprs()
		}
		{
			p.SetState(501)
			p.Match(ScalaParserT__33)
		}
		{
			p.SetState(502)
			p.Expr()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(504)
			p.PostfixExpr()
		}
		p.SetState(506)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ScalaParserT__18 {
			{
				p.SetState(505)
				p.Ascription()
			}

		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(508)
			p.PostfixExpr()
		}
		{
			p.SetState(509)
			p.Match(ScalaParserT__34)
		}
		{
			p.SetState(510)
			p.Match(ScalaParserT__12)
		}
		{
			p.SetState(511)
			p.CaseClauses()
		}
		{
			p.SetState(512)
			p.Match(ScalaParserT__13)
		}

	}

	return localctx
}

// IPrefixDefContext is an interface to support dynamic dispatch.
type IPrefixDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrefixDefContext differentiates from other interfaces.
	IsPrefixDefContext()
}

type PrefixDefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrefixDefContext() *PrefixDefContext {
	var p = new(PrefixDefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_prefixDef
	return p
}

func (*PrefixDefContext) IsPrefixDefContext() {}

func NewPrefixDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrefixDefContext {
	var p = new(PrefixDefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_prefixDef

	return p
}

func (s *PrefixDefContext) GetParser() antlr.Parser { return s.parser }
func (s *PrefixDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrefixDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrefixDefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterPrefixDef(s)
	}
}

func (s *PrefixDefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitPrefixDef(s)
	}
}

func (p *ScalaParser) PrefixDef() (localctx IPrefixDefContext) {
	this := p
	_ = this

	localctx = NewPrefixDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, ScalaParserRULE_prefixDef)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(516)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ScalaParserT__0 || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(ScalaParserT__35-36))|(1<<(ScalaParserT__36-36))|(1<<(ScalaParserT__37-36)))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IPostfixExprContext is an interface to support dynamic dispatch.
type IPostfixExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPostfixExprContext differentiates from other interfaces.
	IsPostfixExprContext()
}

type PostfixExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPostfixExprContext() *PostfixExprContext {
	var p = new(PostfixExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_postfixExpr
	return p
}

func (*PostfixExprContext) IsPostfixExprContext() {}

func NewPostfixExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PostfixExprContext {
	var p = new(PostfixExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_postfixExpr

	return p
}

func (s *PostfixExprContext) GetParser() antlr.Parser { return s.parser }

func (s *PostfixExprContext) InfixExpr() IInfixExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInfixExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInfixExprContext)
}

func (s *PostfixExprContext) Id() antlr.TerminalNode {
	return s.GetToken(ScalaParserId, 0)
}

func (s *PostfixExprContext) AllPrefixDef() []IPrefixDefContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPrefixDefContext)(nil)).Elem())
	var tst = make([]IPrefixDefContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPrefixDefContext)
		}
	}

	return tst
}

func (s *PostfixExprContext) PrefixDef(i int) IPrefixDefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrefixDefContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPrefixDefContext)
}

func (s *PostfixExprContext) AllSimpleExpr1() []ISimpleExpr1Context {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISimpleExpr1Context)(nil)).Elem())
	var tst = make([]ISimpleExpr1Context, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISimpleExpr1Context)
		}
	}

	return tst
}

func (s *PostfixExprContext) SimpleExpr1(i int) ISimpleExpr1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleExpr1Context)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISimpleExpr1Context)
}

func (s *PostfixExprContext) NL() antlr.TerminalNode {
	return s.GetToken(ScalaParserNL, 0)
}

func (s *PostfixExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostfixExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PostfixExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterPostfixExpr(s)
	}
}

func (s *PostfixExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitPostfixExpr(s)
	}
}

func (p *ScalaParser) PostfixExpr() (localctx IPostfixExprContext) {
	this := p
	_ = this

	localctx = NewPostfixExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, ScalaParserRULE_postfixExpr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(518)
		p.infixExpr(0)
	}
	p.SetState(520)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 48, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(519)
			p.Match(ScalaParserId)
		}

	}
	p.SetState(527)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 49, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(522)
				p.PrefixDef()
			}
			{
				p.SetState(523)
				p.simpleExpr1(0)
			}

		}
		p.SetState(529)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 49, p.GetParserRuleContext())
	}
	p.SetState(531)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ScalaParserNL {
		{
			p.SetState(530)
			p.Match(ScalaParserNL)
		}

	}

	return localctx
}

// IInfixExprContext is an interface to support dynamic dispatch.
type IInfixExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInfixExprContext differentiates from other interfaces.
	IsInfixExprContext()
}

type InfixExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInfixExprContext() *InfixExprContext {
	var p = new(InfixExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_infixExpr
	return p
}

func (*InfixExprContext) IsInfixExprContext() {}

func NewInfixExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InfixExprContext {
	var p = new(InfixExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_infixExpr

	return p
}

func (s *InfixExprContext) GetParser() antlr.Parser { return s.parser }

func (s *InfixExprContext) PrefixExpr() IPrefixExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrefixExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrefixExprContext)
}

func (s *InfixExprContext) AllInfixExpr() []IInfixExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInfixExprContext)(nil)).Elem())
	var tst = make([]IInfixExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInfixExprContext)
		}
	}

	return tst
}

func (s *InfixExprContext) InfixExpr(i int) IInfixExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInfixExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInfixExprContext)
}

func (s *InfixExprContext) Id() antlr.TerminalNode {
	return s.GetToken(ScalaParserId, 0)
}

func (s *InfixExprContext) NL() antlr.TerminalNode {
	return s.GetToken(ScalaParserNL, 0)
}

func (s *InfixExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InfixExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InfixExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterInfixExpr(s)
	}
}

func (s *InfixExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitInfixExpr(s)
	}
}

func (p *ScalaParser) InfixExpr() (localctx IInfixExprContext) {
	return p.infixExpr(0)
}

func (p *ScalaParser) infixExpr(_p int) (localctx IInfixExprContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewInfixExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IInfixExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 46
	p.EnterRecursionRule(localctx, 46, ScalaParserRULE_infixExpr, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(534)
		p.PrefixExpr()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(544)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 52, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewInfixExprContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, ScalaParserRULE_infixExpr)
			p.SetState(536)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(537)
				p.Match(ScalaParserId)
			}
			p.SetState(539)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == ScalaParserNL {
				{
					p.SetState(538)
					p.Match(ScalaParserNL)
				}

			}
			{
				p.SetState(541)
				p.infixExpr(2)
			}

		}
		p.SetState(546)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 52, p.GetParserRuleContext())
	}

	return localctx
}

// IPrefixExprContext is an interface to support dynamic dispatch.
type IPrefixExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrefixExprContext differentiates from other interfaces.
	IsPrefixExprContext()
}

type PrefixExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrefixExprContext() *PrefixExprContext {
	var p = new(PrefixExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_prefixExpr
	return p
}

func (*PrefixExprContext) IsPrefixExprContext() {}

func NewPrefixExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrefixExprContext {
	var p = new(PrefixExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_prefixExpr

	return p
}

func (s *PrefixExprContext) GetParser() antlr.Parser { return s.parser }

func (s *PrefixExprContext) SimpleExpr() ISimpleExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimpleExprContext)
}

func (s *PrefixExprContext) SimpleExpr1() ISimpleExpr1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleExpr1Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimpleExpr1Context)
}

func (s *PrefixExprContext) PrefixDef() IPrefixDefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrefixDefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrefixDefContext)
}

func (s *PrefixExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrefixExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrefixExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterPrefixExpr(s)
	}
}

func (s *PrefixExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitPrefixExpr(s)
	}
}

func (p *ScalaParser) PrefixExpr() (localctx IPrefixExprContext) {
	this := p
	_ = this

	localctx = NewPrefixExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, ScalaParserRULE_prefixExpr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(548)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 53, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(547)
			p.PrefixDef()
		}

	}
	p.SetState(555)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 55, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(550)
			p.SimpleExpr()
		}

	case 2:
		{
			p.SetState(551)
			p.simpleExpr1(0)
		}
		p.SetState(553)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 54, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(552)
				p.Match(ScalaParserT__19)
			}

		}

	}

	return localctx
}

// ISimpleExprContext is an interface to support dynamic dispatch.
type ISimpleExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimpleExprContext differentiates from other interfaces.
	IsSimpleExprContext()
}

type SimpleExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleExprContext() *SimpleExprContext {
	var p = new(SimpleExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_simpleExpr
	return p
}

func (*SimpleExprContext) IsSimpleExprContext() {}

func NewSimpleExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleExprContext {
	var p = new(SimpleExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_simpleExpr

	return p
}

func (s *SimpleExprContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleExprContext) ClassTemplate() IClassTemplateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassTemplateContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassTemplateContext)
}

func (s *SimpleExprContext) TemplateBody() ITemplateBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITemplateBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITemplateBodyContext)
}

func (s *SimpleExprContext) BlockExpr() IBlockExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockExprContext)
}

func (s *SimpleExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterSimpleExpr(s)
	}
}

func (s *SimpleExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitSimpleExpr(s)
	}
}

func (p *ScalaParser) SimpleExpr() (localctx ISimpleExprContext) {
	this := p
	_ = this

	localctx = NewSimpleExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, ScalaParserRULE_simpleExpr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(563)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ScalaParserT__38:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(557)
			p.Match(ScalaParserT__38)
		}
		p.SetState(560)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 56, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(558)
				p.ClassTemplate()
			}

		case 2:
			{
				p.SetState(559)
				p.TemplateBody()
			}

		}

	case ScalaParserT__12:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(562)
			p.BlockExpr()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISimpleExpr1Context is an interface to support dynamic dispatch.
type ISimpleExpr1Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimpleExpr1Context differentiates from other interfaces.
	IsSimpleExpr1Context()
}

type SimpleExpr1Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleExpr1Context() *SimpleExpr1Context {
	var p = new(SimpleExpr1Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_simpleExpr1
	return p
}

func (*SimpleExpr1Context) IsSimpleExpr1Context() {}

func NewSimpleExpr1Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleExpr1Context {
	var p = new(SimpleExpr1Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_simpleExpr1

	return p
}

func (s *SimpleExpr1Context) GetParser() antlr.Parser { return s.parser }

func (s *SimpleExpr1Context) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *SimpleExpr1Context) StableId() IStableIdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStableIdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStableIdContext)
}

func (s *SimpleExpr1Context) Exprs() IExprsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprsContext)
}

func (s *SimpleExpr1Context) SimpleExpr() ISimpleExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimpleExprContext)
}

func (s *SimpleExpr1Context) Id() antlr.TerminalNode {
	return s.GetToken(ScalaParserId, 0)
}

func (s *SimpleExpr1Context) TypeArgs() ITypeArgsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeArgsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeArgsContext)
}

func (s *SimpleExpr1Context) SimpleExpr1() ISimpleExpr1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleExpr1Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimpleExpr1Context)
}

func (s *SimpleExpr1Context) ArgumentExprs() IArgumentExprsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentExprsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgumentExprsContext)
}

func (s *SimpleExpr1Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleExpr1Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleExpr1Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterSimpleExpr1(s)
	}
}

func (s *SimpleExpr1Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitSimpleExpr1(s)
	}
}

func (p *ScalaParser) SimpleExpr1() (localctx ISimpleExpr1Context) {
	return p.simpleExpr1(0)
}

func (p *ScalaParser) simpleExpr1(_p int) (localctx ISimpleExpr1Context) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewSimpleExpr1Context(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ISimpleExpr1Context = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 52
	p.EnterRecursionRule(localctx, 52, ScalaParserRULE_simpleExpr1, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(581)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 59, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(566)
			p.Literal()
		}

	case 2:
		{
			p.SetState(567)
			p.stableId(0)
		}

	case 3:
		{
			p.SetState(568)
			p.Match(ScalaParserT__19)
		}

	case 4:
		{
			p.SetState(569)
			p.Match(ScalaParserT__9)
		}
		p.SetState(571)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ScalaParserT__0)|(1<<ScalaParserT__1)|(1<<ScalaParserT__4)|(1<<ScalaParserT__5)|(1<<ScalaParserT__9)|(1<<ScalaParserT__12)|(1<<ScalaParserT__19)|(1<<ScalaParserT__21)|(1<<ScalaParserT__22)|(1<<ScalaParserT__24)|(1<<ScalaParserT__25)|(1<<ScalaParserT__28)|(1<<ScalaParserT__29))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(ScalaParserT__31-32))|(1<<(ScalaParserT__32-32))|(1<<(ScalaParserT__35-32))|(1<<(ScalaParserT__36-32))|(1<<(ScalaParserT__37-32))|(1<<(ScalaParserT__38-32))|(1<<(ScalaParserId-32))|(1<<(ScalaParserBooleanLiteral-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(ScalaParserCharacterLiteral-64))|(1<<(ScalaParserSymbolLiteral-64))|(1<<(ScalaParserIntegerLiteral-64))|(1<<(ScalaParserStringLiteral-64))|(1<<(ScalaParserFloatingPointLiteral-64)))) != 0) {
			{
				p.SetState(570)
				p.Exprs()
			}

		}
		{
			p.SetState(573)
			p.Match(ScalaParserT__10)
		}

	case 5:
		{
			p.SetState(574)
			p.SimpleExpr()
		}
		{
			p.SetState(575)
			p.Match(ScalaParserT__2)
		}
		{
			p.SetState(576)
			p.Match(ScalaParserId)
		}

	case 6:
		{
			p.SetState(578)
			p.SimpleExpr()
		}
		{
			p.SetState(579)
			p.TypeArgs()
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(598)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 63, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(596)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 62, p.GetParserRuleContext()) {
			case 1:
				localctx = NewSimpleExpr1Context(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, ScalaParserRULE_simpleExpr1)
				p.SetState(583)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
				}
				p.SetState(585)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == ScalaParserT__19 {
					{
						p.SetState(584)
						p.Match(ScalaParserT__19)
					}

				}
				{
					p.SetState(587)
					p.Match(ScalaParserT__2)
				}
				{
					p.SetState(588)
					p.Match(ScalaParserId)
				}

			case 2:
				localctx = NewSimpleExpr1Context(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, ScalaParserRULE_simpleExpr1)
				p.SetState(589)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				p.SetState(591)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == ScalaParserT__19 {
					{
						p.SetState(590)
						p.Match(ScalaParserT__19)
					}

				}
				{
					p.SetState(593)
					p.TypeArgs()
				}

			case 3:
				localctx = NewSimpleExpr1Context(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, ScalaParserRULE_simpleExpr1)
				p.SetState(594)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				}
				{
					p.SetState(595)
					p.ArgumentExprs()
				}

			}

		}
		p.SetState(600)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 63, p.GetParserRuleContext())
	}

	return localctx
}

// IExprsContext is an interface to support dynamic dispatch.
type IExprsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExprsContext differentiates from other interfaces.
	IsExprsContext()
}

type ExprsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprsContext() *ExprsContext {
	var p = new(ExprsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_exprs
	return p
}

func (*ExprsContext) IsExprsContext() {}

func NewExprsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprsContext {
	var p = new(ExprsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_exprs

	return p
}

func (s *ExprsContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprsContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *ExprsContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExprsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterExprs(s)
	}
}

func (s *ExprsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitExprs(s)
	}
}

func (p *ScalaParser) Exprs() (localctx IExprsContext) {
	this := p
	_ = this

	localctx = NewExprsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, ScalaParserRULE_exprs)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(601)
		p.Expr()
	}
	p.SetState(606)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 64, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(602)
				p.Match(ScalaParserT__3)
			}
			{
				p.SetState(603)
				p.Expr()
			}

		}
		p.SetState(608)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 64, p.GetParserRuleContext())
	}

	return localctx
}

// IArgumentExprsContext is an interface to support dynamic dispatch.
type IArgumentExprsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArgumentExprsContext differentiates from other interfaces.
	IsArgumentExprsContext()
}

type ArgumentExprsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentExprsContext() *ArgumentExprsContext {
	var p = new(ArgumentExprsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_argumentExprs
	return p
}

func (*ArgumentExprsContext) IsArgumentExprsContext() {}

func NewArgumentExprsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentExprsContext {
	var p = new(ArgumentExprsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_argumentExprs

	return p
}

func (s *ArgumentExprsContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentExprsContext) Args() IArgsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgsContext)
}

func (s *ArgumentExprsContext) BlockExpr() IBlockExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockExprContext)
}

func (s *ArgumentExprsContext) NL() antlr.TerminalNode {
	return s.GetToken(ScalaParserNL, 0)
}

func (s *ArgumentExprsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentExprsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentExprsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterArgumentExprs(s)
	}
}

func (s *ArgumentExprsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitArgumentExprs(s)
	}
}

func (p *ScalaParser) ArgumentExprs() (localctx IArgumentExprsContext) {
	this := p
	_ = this

	localctx = NewArgumentExprsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, ScalaParserRULE_argumentExprs)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(621)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 66, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(609)
			p.Match(ScalaParserT__9)
		}
		{
			p.SetState(610)
			p.Args()
		}
		{
			p.SetState(611)
			p.Match(ScalaParserT__10)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(613)
			p.Match(ScalaParserT__12)
		}
		{
			p.SetState(614)
			p.Args()
		}
		{
			p.SetState(615)
			p.Match(ScalaParserT__13)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(618)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ScalaParserNL {
			{
				p.SetState(617)
				p.Match(ScalaParserNL)
			}

		}
		{
			p.SetState(620)
			p.BlockExpr()
		}

	}

	return localctx
}

// IArgsContext is an interface to support dynamic dispatch.
type IArgsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArgsContext differentiates from other interfaces.
	IsArgsContext()
}

type ArgsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgsContext() *ArgsContext {
	var p = new(ArgsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_args
	return p
}

func (*ArgsContext) IsArgsContext() {}

func NewArgsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgsContext {
	var p = new(ArgsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_args

	return p
}

func (s *ArgsContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgsContext) Exprs() IExprsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprsContext)
}

func (s *ArgsContext) PostfixExpr() IPostfixExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPostfixExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPostfixExprContext)
}

func (s *ArgsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterArgs(s)
	}
}

func (s *ArgsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitArgs(s)
	}
}

func (p *ScalaParser) Args() (localctx IArgsContext) {
	this := p
	_ = this

	localctx = NewArgsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, ScalaParserRULE_args)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(635)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 70, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(624)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ScalaParserT__0)|(1<<ScalaParserT__1)|(1<<ScalaParserT__4)|(1<<ScalaParserT__5)|(1<<ScalaParserT__9)|(1<<ScalaParserT__12)|(1<<ScalaParserT__19)|(1<<ScalaParserT__21)|(1<<ScalaParserT__22)|(1<<ScalaParserT__24)|(1<<ScalaParserT__25)|(1<<ScalaParserT__28)|(1<<ScalaParserT__29))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(ScalaParserT__31-32))|(1<<(ScalaParserT__32-32))|(1<<(ScalaParserT__35-32))|(1<<(ScalaParserT__36-32))|(1<<(ScalaParserT__37-32))|(1<<(ScalaParserT__38-32))|(1<<(ScalaParserId-32))|(1<<(ScalaParserBooleanLiteral-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(ScalaParserCharacterLiteral-64))|(1<<(ScalaParserSymbolLiteral-64))|(1<<(ScalaParserIntegerLiteral-64))|(1<<(ScalaParserStringLiteral-64))|(1<<(ScalaParserFloatingPointLiteral-64)))) != 0) {
			{
				p.SetState(623)
				p.Exprs()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(629)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 68, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(626)
				p.Exprs()
			}
			{
				p.SetState(627)
				p.Match(ScalaParserT__3)
			}

		}
		{
			p.SetState(631)
			p.PostfixExpr()
		}
		p.SetState(633)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ScalaParserT__18)|(1<<ScalaParserT__19)|(1<<ScalaParserT__20))) != 0 {
			{
				p.SetState(632)
				_la = p.GetTokenStream().LA(1)

				if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ScalaParserT__18)|(1<<ScalaParserT__19)|(1<<ScalaParserT__20))) != 0) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}

	}

	return localctx
}

// IBlockExprContext is an interface to support dynamic dispatch.
type IBlockExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlockExprContext differentiates from other interfaces.
	IsBlockExprContext()
}

type BlockExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockExprContext() *BlockExprContext {
	var p = new(BlockExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_blockExpr
	return p
}

func (*BlockExprContext) IsBlockExprContext() {}

func NewBlockExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockExprContext {
	var p = new(BlockExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_blockExpr

	return p
}

func (s *BlockExprContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockExprContext) CaseClauses() ICaseClausesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICaseClausesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICaseClausesContext)
}

func (s *BlockExprContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *BlockExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterBlockExpr(s)
	}
}

func (s *BlockExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitBlockExpr(s)
	}
}

func (p *ScalaParser) BlockExpr() (localctx IBlockExprContext) {
	this := p
	_ = this

	localctx = NewBlockExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, ScalaParserRULE_blockExpr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(645)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 71, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(637)
			p.Match(ScalaParserT__12)
		}
		{
			p.SetState(638)
			p.CaseClauses()
		}
		{
			p.SetState(639)
			p.Match(ScalaParserT__13)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(641)
			p.Match(ScalaParserT__12)
		}
		{
			p.SetState(642)
			p.Block()
		}
		{
			p.SetState(643)
			p.Match(ScalaParserT__13)
		}

	}

	return localctx
}

// IBlockContext is an interface to support dynamic dispatch.
type IBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlockContext differentiates from other interfaces.
	IsBlockContext()
}

type BlockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockContext() *BlockContext {
	var p = new(BlockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_block
	return p
}

func (*BlockContext) IsBlockContext() {}

func NewBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockContext {
	var p = new(BlockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_block

	return p
}

func (s *BlockContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockContext) AllBlockStat() []IBlockStatContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBlockStatContext)(nil)).Elem())
	var tst = make([]IBlockStatContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBlockStatContext)
		}
	}

	return tst
}

func (s *BlockContext) BlockStat(i int) IBlockStatContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockStatContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBlockStatContext)
}

func (s *BlockContext) ResultExpr() IResultExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IResultExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IResultExprContext)
}

func (s *BlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterBlock(s)
	}
}

func (s *BlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitBlock(s)
	}
}

func (p *ScalaParser) Block() (localctx IBlockContext) {
	this := p
	_ = this

	localctx = NewBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, ScalaParserRULE_block)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(648)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(647)
				p.BlockStat()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(650)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 72, p.GetParserRuleContext())
	}
	p.SetState(653)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ScalaParserT__0)|(1<<ScalaParserT__1)|(1<<ScalaParserT__4)|(1<<ScalaParserT__5)|(1<<ScalaParserT__9)|(1<<ScalaParserT__12)|(1<<ScalaParserT__19)|(1<<ScalaParserT__21)|(1<<ScalaParserT__22)|(1<<ScalaParserT__24)|(1<<ScalaParserT__25)|(1<<ScalaParserT__28)|(1<<ScalaParserT__29))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(ScalaParserT__31-32))|(1<<(ScalaParserT__32-32))|(1<<(ScalaParserT__35-32))|(1<<(ScalaParserT__36-32))|(1<<(ScalaParserT__37-32))|(1<<(ScalaParserT__38-32))|(1<<(ScalaParserId-32))|(1<<(ScalaParserBooleanLiteral-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(ScalaParserCharacterLiteral-64))|(1<<(ScalaParserSymbolLiteral-64))|(1<<(ScalaParserIntegerLiteral-64))|(1<<(ScalaParserStringLiteral-64))|(1<<(ScalaParserFloatingPointLiteral-64)))) != 0) {
		{
			p.SetState(652)
			p.ResultExpr()
		}

	}

	return localctx
}

// IBlockStatContext is an interface to support dynamic dispatch.
type IBlockStatContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlockStatContext differentiates from other interfaces.
	IsBlockStatContext()
}

type BlockStatContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockStatContext() *BlockStatContext {
	var p = new(BlockStatContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_blockStat
	return p
}

func (*BlockStatContext) IsBlockStatContext() {}

func NewBlockStatContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockStatContext {
	var p = new(BlockStatContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_blockStat

	return p
}

func (s *BlockStatContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockStatContext) Import_() IImport_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImport_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImport_Context)
}

func (s *BlockStatContext) Def_() IDef_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDef_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDef_Context)
}

func (s *BlockStatContext) AllAnnotation() []IAnnotationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotationContext)(nil)).Elem())
	var tst = make([]IAnnotationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotationContext)
		}
	}

	return tst
}

func (s *BlockStatContext) Annotation(i int) IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *BlockStatContext) TmplDef() ITmplDefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITmplDefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITmplDefContext)
}

func (s *BlockStatContext) AllLocalModifier() []ILocalModifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILocalModifierContext)(nil)).Elem())
	var tst = make([]ILocalModifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILocalModifierContext)
		}
	}

	return tst
}

func (s *BlockStatContext) LocalModifier(i int) ILocalModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILocalModifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILocalModifierContext)
}

func (s *BlockStatContext) Expr1() IExpr1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr1Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr1Context)
}

func (s *BlockStatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockStatContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockStatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterBlockStat(s)
	}
}

func (s *BlockStatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitBlockStat(s)
	}
}

func (p *ScalaParser) BlockStat() (localctx IBlockStatContext) {
	this := p
	_ = this

	localctx = NewBlockStatContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, ScalaParserRULE_blockStat)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(680)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 78, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(655)
			p.Import_()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(659)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == ScalaParserT__43 {
			{
				p.SetState(656)
				p.Annotation()
			}

			p.SetState(661)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(663)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ScalaParserT__21 || _la == ScalaParserT__39 {
			{
				p.SetState(662)
				_la = p.GetTokenStream().LA(1)

				if !(_la == ScalaParserT__21 || _la == ScalaParserT__39) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(665)
			p.Def_()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(669)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == ScalaParserT__43 {
			{
				p.SetState(666)
				p.Annotation()
			}

			p.SetState(671)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(675)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ((_la-22)&-(0x1f+1)) == 0 && ((1<<uint((_la-22)))&((1<<(ScalaParserT__21-22))|(1<<(ScalaParserT__39-22))|(1<<(ScalaParserT__49-22))|(1<<(ScalaParserT__50-22))|(1<<(ScalaParserT__51-22)))) != 0 {
			{
				p.SetState(672)
				p.LocalModifier()
			}

			p.SetState(677)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(678)
			p.TmplDef()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(679)
			p.Expr1()
		}

	}

	return localctx
}

// IResultExprContext is an interface to support dynamic dispatch.
type IResultExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsResultExprContext differentiates from other interfaces.
	IsResultExprContext()
}

type ResultExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResultExprContext() *ResultExprContext {
	var p = new(ResultExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_resultExpr
	return p
}

func (*ResultExprContext) IsResultExprContext() {}

func NewResultExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResultExprContext {
	var p = new(ResultExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_resultExpr

	return p
}

func (s *ResultExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ResultExprContext) Expr1() IExpr1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr1Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr1Context)
}

func (s *ResultExprContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *ResultExprContext) Bindings() IBindingsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBindingsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBindingsContext)
}

func (s *ResultExprContext) CompoundType() ICompoundTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompoundTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICompoundTypeContext)
}

func (s *ResultExprContext) Id() antlr.TerminalNode {
	return s.GetToken(ScalaParserId, 0)
}

func (s *ResultExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResultExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResultExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterResultExpr(s)
	}
}

func (s *ResultExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitResultExpr(s)
	}
}

func (p *ScalaParser) ResultExpr() (localctx IResultExprContext) {
	this := p
	_ = this

	localctx = NewResultExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, ScalaParserRULE_resultExpr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(698)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 82, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(682)
			p.Expr1()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(693)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case ScalaParserT__9:
			{
				p.SetState(683)
				p.Bindings()
			}

		case ScalaParserT__19, ScalaParserT__21, ScalaParserId:
			p.SetState(689)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case ScalaParserT__21, ScalaParserId:
				p.SetState(685)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == ScalaParserT__21 {
					{
						p.SetState(684)
						p.Match(ScalaParserT__21)
					}

				}
				{
					p.SetState(687)
					p.Match(ScalaParserId)
				}

			case ScalaParserT__19:
				{
					p.SetState(688)
					p.Match(ScalaParserT__19)
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}
			{
				p.SetState(691)
				p.Match(ScalaParserT__18)
			}
			{
				p.SetState(692)
				p.CompoundType()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(695)
			p.Match(ScalaParserT__8)
		}
		{
			p.SetState(696)
			p.Block()
		}

	}

	return localctx
}

// IEnumeratorsContext is an interface to support dynamic dispatch.
type IEnumeratorsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumeratorsContext differentiates from other interfaces.
	IsEnumeratorsContext()
}

type EnumeratorsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumeratorsContext() *EnumeratorsContext {
	var p = new(EnumeratorsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_enumerators
	return p
}

func (*EnumeratorsContext) IsEnumeratorsContext() {}

func NewEnumeratorsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumeratorsContext {
	var p = new(EnumeratorsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_enumerators

	return p
}

func (s *EnumeratorsContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumeratorsContext) AllGenerator() []IGeneratorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IGeneratorContext)(nil)).Elem())
	var tst = make([]IGeneratorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IGeneratorContext)
		}
	}

	return tst
}

func (s *EnumeratorsContext) Generator(i int) IGeneratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGeneratorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IGeneratorContext)
}

func (s *EnumeratorsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumeratorsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumeratorsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterEnumerators(s)
	}
}

func (s *EnumeratorsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitEnumerators(s)
	}
}

func (p *ScalaParser) Enumerators() (localctx IEnumeratorsContext) {
	this := p
	_ = this

	localctx = NewEnumeratorsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, ScalaParserRULE_enumerators)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(701)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ScalaParserT__0)|(1<<ScalaParserT__1)|(1<<ScalaParserT__4)|(1<<ScalaParserT__5)|(1<<ScalaParserT__9)|(1<<ScalaParserT__19))) != 0) || (((_la-62)&-(0x1f+1)) == 0 && ((1<<uint((_la-62)))&((1<<(ScalaParserId-62))|(1<<(ScalaParserBooleanLiteral-62))|(1<<(ScalaParserCharacterLiteral-62))|(1<<(ScalaParserSymbolLiteral-62))|(1<<(ScalaParserIntegerLiteral-62))|(1<<(ScalaParserStringLiteral-62))|(1<<(ScalaParserFloatingPointLiteral-62))|(1<<(ScalaParserVarid-62))|(1<<(ScalaParserBoundVarid-62)))) != 0) {
		{
			p.SetState(700)
			p.Generator()
		}

		p.SetState(703)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IGeneratorContext is an interface to support dynamic dispatch.
type IGeneratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGeneratorContext differentiates from other interfaces.
	IsGeneratorContext()
}

type GeneratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGeneratorContext() *GeneratorContext {
	var p = new(GeneratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_generator
	return p
}

func (*GeneratorContext) IsGeneratorContext() {}

func NewGeneratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GeneratorContext {
	var p = new(GeneratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_generator

	return p
}

func (s *GeneratorContext) GetParser() antlr.Parser { return s.parser }

func (s *GeneratorContext) AllPattern1() []IPattern1Context {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPattern1Context)(nil)).Elem())
	var tst = make([]IPattern1Context, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPattern1Context)
		}
	}

	return tst
}

func (s *GeneratorContext) Pattern1(i int) IPattern1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPattern1Context)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPattern1Context)
}

func (s *GeneratorContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *GeneratorContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *GeneratorContext) AllGuard_() []IGuard_Context {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IGuard_Context)(nil)).Elem())
	var tst = make([]IGuard_Context, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IGuard_Context)
		}
	}

	return tst
}

func (s *GeneratorContext) Guard_(i int) IGuard_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGuard_Context)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IGuard_Context)
}

func (s *GeneratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GeneratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GeneratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterGenerator(s)
	}
}

func (s *GeneratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitGenerator(s)
	}
}

func (p *ScalaParser) Generator() (localctx IGeneratorContext) {
	this := p
	_ = this

	localctx = NewGeneratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, ScalaParserRULE_generator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(705)
		p.Pattern1()
	}
	{
		p.SetState(706)
		p.Match(ScalaParserT__40)
	}
	{
		p.SetState(707)
		p.Expr()
	}
	p.SetState(715)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 85, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(713)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case ScalaParserT__22:
				{
					p.SetState(708)
					p.Guard_()
				}

			case ScalaParserT__0, ScalaParserT__1, ScalaParserT__4, ScalaParserT__5, ScalaParserT__9, ScalaParserT__19, ScalaParserId, ScalaParserBooleanLiteral, ScalaParserCharacterLiteral, ScalaParserSymbolLiteral, ScalaParserIntegerLiteral, ScalaParserStringLiteral, ScalaParserFloatingPointLiteral, ScalaParserVarid, ScalaParserBoundVarid:
				{
					p.SetState(709)
					p.Pattern1()
				}
				{
					p.SetState(710)
					p.Match(ScalaParserT__33)
				}
				{
					p.SetState(711)
					p.Expr()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		}
		p.SetState(717)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 85, p.GetParserRuleContext())
	}

	return localctx
}

// ICaseClausesContext is an interface to support dynamic dispatch.
type ICaseClausesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCaseClausesContext differentiates from other interfaces.
	IsCaseClausesContext()
}

type CaseClausesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseClausesContext() *CaseClausesContext {
	var p = new(CaseClausesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_caseClauses
	return p
}

func (*CaseClausesContext) IsCaseClausesContext() {}

func NewCaseClausesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseClausesContext {
	var p = new(CaseClausesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_caseClauses

	return p
}

func (s *CaseClausesContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseClausesContext) AllCaseClause() []ICaseClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICaseClauseContext)(nil)).Elem())
	var tst = make([]ICaseClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICaseClauseContext)
		}
	}

	return tst
}

func (s *CaseClausesContext) CaseClause(i int) ICaseClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICaseClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICaseClauseContext)
}

func (s *CaseClausesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseClausesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseClausesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterCaseClauses(s)
	}
}

func (s *CaseClausesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitCaseClauses(s)
	}
}

func (p *ScalaParser) CaseClauses() (localctx ICaseClausesContext) {
	this := p
	_ = this

	localctx = NewCaseClausesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, ScalaParserRULE_caseClauses)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(719)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == ScalaParserT__41 {
		{
			p.SetState(718)
			p.CaseClause()
		}

		p.SetState(721)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ICaseClauseContext is an interface to support dynamic dispatch.
type ICaseClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCaseClauseContext differentiates from other interfaces.
	IsCaseClauseContext()
}

type CaseClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseClauseContext() *CaseClauseContext {
	var p = new(CaseClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_caseClause
	return p
}

func (*CaseClauseContext) IsCaseClauseContext() {}

func NewCaseClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseClauseContext {
	var p = new(CaseClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_caseClause

	return p
}

func (s *CaseClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseClauseContext) Pattern() IPatternContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPatternContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPatternContext)
}

func (s *CaseClauseContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *CaseClauseContext) Guard_() IGuard_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGuard_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGuard_Context)
}

func (s *CaseClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterCaseClause(s)
	}
}

func (s *CaseClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitCaseClause(s)
	}
}

func (p *ScalaParser) CaseClause() (localctx ICaseClauseContext) {
	this := p
	_ = this

	localctx = NewCaseClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, ScalaParserRULE_caseClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(723)
		p.Match(ScalaParserT__41)
	}
	{
		p.SetState(724)
		p.Pattern()
	}
	p.SetState(726)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ScalaParserT__22 {
		{
			p.SetState(725)
			p.Guard_()
		}

	}
	{
		p.SetState(728)
		p.Match(ScalaParserT__8)
	}
	{
		p.SetState(729)
		p.Block()
	}

	return localctx
}

// IGuard_Context is an interface to support dynamic dispatch.
type IGuard_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGuard_Context differentiates from other interfaces.
	IsGuard_Context()
}

type Guard_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGuard_Context() *Guard_Context {
	var p = new(Guard_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_guard_
	return p
}

func (*Guard_Context) IsGuard_Context() {}

func NewGuard_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Guard_Context {
	var p = new(Guard_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_guard_

	return p
}

func (s *Guard_Context) GetParser() antlr.Parser { return s.parser }

func (s *Guard_Context) PostfixExpr() IPostfixExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPostfixExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPostfixExprContext)
}

func (s *Guard_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Guard_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Guard_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterGuard_(s)
	}
}

func (s *Guard_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitGuard_(s)
	}
}

func (p *ScalaParser) Guard_() (localctx IGuard_Context) {
	this := p
	_ = this

	localctx = NewGuard_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, ScalaParserRULE_guard_)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(731)
		p.Match(ScalaParserT__22)
	}
	{
		p.SetState(732)
		p.PostfixExpr()
	}

	return localctx
}

// IPatternContext is an interface to support dynamic dispatch.
type IPatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPatternContext differentiates from other interfaces.
	IsPatternContext()
}

type PatternContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPatternContext() *PatternContext {
	var p = new(PatternContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_pattern
	return p
}

func (*PatternContext) IsPatternContext() {}

func NewPatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PatternContext {
	var p = new(PatternContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_pattern

	return p
}

func (s *PatternContext) GetParser() antlr.Parser { return s.parser }

func (s *PatternContext) AllPattern1() []IPattern1Context {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPattern1Context)(nil)).Elem())
	var tst = make([]IPattern1Context, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPattern1Context)
		}
	}

	return tst
}

func (s *PatternContext) Pattern1(i int) IPattern1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPattern1Context)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPattern1Context)
}

func (s *PatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PatternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterPattern(s)
	}
}

func (s *PatternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitPattern(s)
	}
}

func (p *ScalaParser) Pattern() (localctx IPatternContext) {
	this := p
	_ = this

	localctx = NewPatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, ScalaParserRULE_pattern)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(734)
		p.Pattern1()
	}
	p.SetState(739)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ScalaParserT__42 {
		{
			p.SetState(735)
			p.Match(ScalaParserT__42)
		}
		{
			p.SetState(736)
			p.Pattern1()
		}

		p.SetState(741)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IPattern1Context is an interface to support dynamic dispatch.
type IPattern1Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPattern1Context differentiates from other interfaces.
	IsPattern1Context()
}

type Pattern1Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPattern1Context() *Pattern1Context {
	var p = new(Pattern1Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_pattern1
	return p
}

func (*Pattern1Context) IsPattern1Context() {}

func NewPattern1Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pattern1Context {
	var p = new(Pattern1Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_pattern1

	return p
}

func (s *Pattern1Context) GetParser() antlr.Parser { return s.parser }

func (s *Pattern1Context) TypePat() ITypePatContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypePatContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypePatContext)
}

func (s *Pattern1Context) BoundVarid() antlr.TerminalNode {
	return s.GetToken(ScalaParserBoundVarid, 0)
}

func (s *Pattern1Context) Id() antlr.TerminalNode {
	return s.GetToken(ScalaParserId, 0)
}

func (s *Pattern1Context) Pattern2() IPattern2Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPattern2Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPattern2Context)
}

func (s *Pattern1Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pattern1Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pattern1Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterPattern1(s)
	}
}

func (s *Pattern1Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitPattern1(s)
	}
}

func (p *ScalaParser) Pattern1() (localctx IPattern1Context) {
	this := p
	_ = this

	localctx = NewPattern1Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, ScalaParserRULE_pattern1)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(746)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 89, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(742)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ScalaParserT__19 || _la == ScalaParserId || _la == ScalaParserBoundVarid) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(743)
			p.Match(ScalaParserT__18)
		}
		{
			p.SetState(744)
			p.TypePat()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(745)
			p.Pattern2()
		}

	}

	return localctx
}

// IPattern2Context is an interface to support dynamic dispatch.
type IPattern2Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPattern2Context differentiates from other interfaces.
	IsPattern2Context()
}

type Pattern2Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPattern2Context() *Pattern2Context {
	var p = new(Pattern2Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_pattern2
	return p
}

func (*Pattern2Context) IsPattern2Context() {}

func NewPattern2Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pattern2Context {
	var p = new(Pattern2Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_pattern2

	return p
}

func (s *Pattern2Context) GetParser() antlr.Parser { return s.parser }

func (s *Pattern2Context) Id() antlr.TerminalNode {
	return s.GetToken(ScalaParserId, 0)
}

func (s *Pattern2Context) Pattern3() IPattern3Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPattern3Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPattern3Context)
}

func (s *Pattern2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pattern2Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pattern2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterPattern2(s)
	}
}

func (s *Pattern2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitPattern2(s)
	}
}

func (p *ScalaParser) Pattern2() (localctx IPattern2Context) {
	this := p
	_ = this

	localctx = NewPattern2Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, ScalaParserRULE_pattern2)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(754)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 91, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(748)
			p.Match(ScalaParserId)
		}
		p.SetState(751)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ScalaParserT__43 {
			{
				p.SetState(749)
				p.Match(ScalaParserT__43)
			}
			{
				p.SetState(750)
				p.Pattern3()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(753)
			p.Pattern3()
		}

	}

	return localctx
}

// IPattern3Context is an interface to support dynamic dispatch.
type IPattern3Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPattern3Context differentiates from other interfaces.
	IsPattern3Context()
}

type Pattern3Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPattern3Context() *Pattern3Context {
	var p = new(Pattern3Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_pattern3
	return p
}

func (*Pattern3Context) IsPattern3Context() {}

func NewPattern3Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pattern3Context {
	var p = new(Pattern3Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_pattern3

	return p
}

func (s *Pattern3Context) GetParser() antlr.Parser { return s.parser }

func (s *Pattern3Context) AllSimplePattern() []ISimplePatternContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISimplePatternContext)(nil)).Elem())
	var tst = make([]ISimplePatternContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISimplePatternContext)
		}
	}

	return tst
}

func (s *Pattern3Context) SimplePattern(i int) ISimplePatternContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimplePatternContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISimplePatternContext)
}

func (s *Pattern3Context) AllId() []antlr.TerminalNode {
	return s.GetTokens(ScalaParserId)
}

func (s *Pattern3Context) Id(i int) antlr.TerminalNode {
	return s.GetToken(ScalaParserId, i)
}

func (s *Pattern3Context) AllNL() []antlr.TerminalNode {
	return s.GetTokens(ScalaParserNL)
}

func (s *Pattern3Context) NL(i int) antlr.TerminalNode {
	return s.GetToken(ScalaParserNL, i)
}

func (s *Pattern3Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pattern3Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pattern3Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterPattern3(s)
	}
}

func (s *Pattern3Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitPattern3(s)
	}
}

func (p *ScalaParser) Pattern3() (localctx IPattern3Context) {
	this := p
	_ = this

	localctx = NewPattern3Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, ScalaParserRULE_pattern3)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(768)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 94, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(756)
			p.SimplePattern()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(757)
			p.SimplePattern()
		}
		p.SetState(765)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == ScalaParserId {
			{
				p.SetState(758)
				p.Match(ScalaParserId)
			}
			p.SetState(760)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == ScalaParserNL {
				{
					p.SetState(759)
					p.Match(ScalaParserNL)
				}

			}
			{
				p.SetState(762)
				p.SimplePattern()
			}

			p.SetState(767)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// ISimplePatternContext is an interface to support dynamic dispatch.
type ISimplePatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimplePatternContext differentiates from other interfaces.
	IsSimplePatternContext()
}

type SimplePatternContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimplePatternContext() *SimplePatternContext {
	var p = new(SimplePatternContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_simplePattern
	return p
}

func (*SimplePatternContext) IsSimplePatternContext() {}

func NewSimplePatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimplePatternContext {
	var p = new(SimplePatternContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_simplePattern

	return p
}

func (s *SimplePatternContext) GetParser() antlr.Parser { return s.parser }

func (s *SimplePatternContext) Varid() antlr.TerminalNode {
	return s.GetToken(ScalaParserVarid, 0)
}

func (s *SimplePatternContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *SimplePatternContext) StableId() IStableIdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStableIdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStableIdContext)
}

func (s *SimplePatternContext) Patterns() IPatternsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPatternsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPatternsContext)
}

func (s *SimplePatternContext) Id() antlr.TerminalNode {
	return s.GetToken(ScalaParserId, 0)
}

func (s *SimplePatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimplePatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimplePatternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterSimplePattern(s)
	}
}

func (s *SimplePatternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitSimplePattern(s)
	}
}

func (p *ScalaParser) SimplePattern() (localctx ISimplePatternContext) {
	this := p
	_ = this

	localctx = NewSimplePatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, ScalaParserRULE_simplePattern)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(801)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 100, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(770)
			p.Match(ScalaParserT__19)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(771)
			p.Match(ScalaParserVarid)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(772)
			p.Literal()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(773)
			p.stableId(0)
		}
		p.SetState(779)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ScalaParserT__9 {
			{
				p.SetState(774)
				p.Match(ScalaParserT__9)
			}
			p.SetState(776)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ScalaParserT__0)|(1<<ScalaParserT__1)|(1<<ScalaParserT__4)|(1<<ScalaParserT__5)|(1<<ScalaParserT__9)|(1<<ScalaParserT__19))) != 0) || (((_la-62)&-(0x1f+1)) == 0 && ((1<<uint((_la-62)))&((1<<(ScalaParserId-62))|(1<<(ScalaParserBooleanLiteral-62))|(1<<(ScalaParserCharacterLiteral-62))|(1<<(ScalaParserSymbolLiteral-62))|(1<<(ScalaParserIntegerLiteral-62))|(1<<(ScalaParserStringLiteral-62))|(1<<(ScalaParserFloatingPointLiteral-62))|(1<<(ScalaParserVarid-62))|(1<<(ScalaParserBoundVarid-62)))) != 0) {
				{
					p.SetState(775)
					p.Patterns()
				}

			}
			{
				p.SetState(778)
				p.Match(ScalaParserT__10)
			}

		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(781)
			p.stableId(0)
		}
		{
			p.SetState(782)
			p.Match(ScalaParserT__9)
		}
		p.SetState(786)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 97, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(783)
				p.Patterns()
			}
			{
				p.SetState(784)
				p.Match(ScalaParserT__3)
			}

		}
		p.SetState(790)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ScalaParserId {
			{
				p.SetState(788)
				p.Match(ScalaParserId)
			}
			{
				p.SetState(789)
				p.Match(ScalaParserT__43)
			}

		}
		{
			p.SetState(792)
			p.Match(ScalaParserT__19)
		}
		{
			p.SetState(793)
			p.Match(ScalaParserT__20)
		}
		{
			p.SetState(794)
			p.Match(ScalaParserT__10)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(796)
			p.Match(ScalaParserT__9)
		}
		p.SetState(798)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ScalaParserT__0)|(1<<ScalaParserT__1)|(1<<ScalaParserT__4)|(1<<ScalaParserT__5)|(1<<ScalaParserT__9)|(1<<ScalaParserT__19))) != 0) || (((_la-62)&-(0x1f+1)) == 0 && ((1<<uint((_la-62)))&((1<<(ScalaParserId-62))|(1<<(ScalaParserBooleanLiteral-62))|(1<<(ScalaParserCharacterLiteral-62))|(1<<(ScalaParserSymbolLiteral-62))|(1<<(ScalaParserIntegerLiteral-62))|(1<<(ScalaParserStringLiteral-62))|(1<<(ScalaParserFloatingPointLiteral-62))|(1<<(ScalaParserVarid-62))|(1<<(ScalaParserBoundVarid-62)))) != 0) {
			{
				p.SetState(797)
				p.Patterns()
			}

		}
		{
			p.SetState(800)
			p.Match(ScalaParserT__10)
		}

	}

	return localctx
}

// IPatternsContext is an interface to support dynamic dispatch.
type IPatternsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPatternsContext differentiates from other interfaces.
	IsPatternsContext()
}

type PatternsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPatternsContext() *PatternsContext {
	var p = new(PatternsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_patterns
	return p
}

func (*PatternsContext) IsPatternsContext() {}

func NewPatternsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PatternsContext {
	var p = new(PatternsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_patterns

	return p
}

func (s *PatternsContext) GetParser() antlr.Parser { return s.parser }

func (s *PatternsContext) Pattern() IPatternContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPatternContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPatternContext)
}

func (s *PatternsContext) Patterns() IPatternsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPatternsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPatternsContext)
}

func (s *PatternsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PatternsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PatternsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterPatterns(s)
	}
}

func (s *PatternsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitPatterns(s)
	}
}

func (p *ScalaParser) Patterns() (localctx IPatternsContext) {
	this := p
	_ = this

	localctx = NewPatternsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, ScalaParserRULE_patterns)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(810)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 102, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(803)
			p.Pattern()
		}
		p.SetState(806)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 101, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(804)
				p.Match(ScalaParserT__3)
			}
			{
				p.SetState(805)
				p.Patterns()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(808)
			p.Match(ScalaParserT__19)
		}
		{
			p.SetState(809)
			p.Match(ScalaParserT__20)
		}

	}

	return localctx
}

// ITypeParamClauseContext is an interface to support dynamic dispatch.
type ITypeParamClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeParamClauseContext differentiates from other interfaces.
	IsTypeParamClauseContext()
}

type TypeParamClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeParamClauseContext() *TypeParamClauseContext {
	var p = new(TypeParamClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_typeParamClause
	return p
}

func (*TypeParamClauseContext) IsTypeParamClauseContext() {}

func NewTypeParamClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeParamClauseContext {
	var p = new(TypeParamClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_typeParamClause

	return p
}

func (s *TypeParamClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeParamClauseContext) AllVariantTypeParam() []IVariantTypeParamContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariantTypeParamContext)(nil)).Elem())
	var tst = make([]IVariantTypeParamContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariantTypeParamContext)
		}
	}

	return tst
}

func (s *TypeParamClauseContext) VariantTypeParam(i int) IVariantTypeParamContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariantTypeParamContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariantTypeParamContext)
}

func (s *TypeParamClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeParamClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeParamClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterTypeParamClause(s)
	}
}

func (s *TypeParamClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitTypeParamClause(s)
	}
}

func (p *ScalaParser) TypeParamClause() (localctx ITypeParamClauseContext) {
	this := p
	_ = this

	localctx = NewTypeParamClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, ScalaParserRULE_typeParamClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(812)
		p.Match(ScalaParserT__6)
	}
	{
		p.SetState(813)
		p.VariantTypeParam()
	}
	p.SetState(818)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ScalaParserT__3 {
		{
			p.SetState(814)
			p.Match(ScalaParserT__3)
		}
		{
			p.SetState(815)
			p.VariantTypeParam()
		}

		p.SetState(820)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(821)
		p.Match(ScalaParserT__7)
	}

	return localctx
}

// IFunTypeParamClauseContext is an interface to support dynamic dispatch.
type IFunTypeParamClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunTypeParamClauseContext differentiates from other interfaces.
	IsFunTypeParamClauseContext()
}

type FunTypeParamClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunTypeParamClauseContext() *FunTypeParamClauseContext {
	var p = new(FunTypeParamClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_funTypeParamClause
	return p
}

func (*FunTypeParamClauseContext) IsFunTypeParamClauseContext() {}

func NewFunTypeParamClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunTypeParamClauseContext {
	var p = new(FunTypeParamClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_funTypeParamClause

	return p
}

func (s *FunTypeParamClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *FunTypeParamClauseContext) AllTypeParam() []ITypeParamContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITypeParamContext)(nil)).Elem())
	var tst = make([]ITypeParamContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITypeParamContext)
		}
	}

	return tst
}

func (s *FunTypeParamClauseContext) TypeParam(i int) ITypeParamContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeParamContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITypeParamContext)
}

func (s *FunTypeParamClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunTypeParamClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunTypeParamClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterFunTypeParamClause(s)
	}
}

func (s *FunTypeParamClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitFunTypeParamClause(s)
	}
}

func (p *ScalaParser) FunTypeParamClause() (localctx IFunTypeParamClauseContext) {
	this := p
	_ = this

	localctx = NewFunTypeParamClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, ScalaParserRULE_funTypeParamClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(823)
		p.Match(ScalaParserT__6)
	}
	{
		p.SetState(824)
		p.TypeParam()
	}
	p.SetState(829)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ScalaParserT__3 {
		{
			p.SetState(825)
			p.Match(ScalaParserT__3)
		}
		{
			p.SetState(826)
			p.TypeParam()
		}

		p.SetState(831)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(832)
		p.Match(ScalaParserT__7)
	}

	return localctx
}

// IVariantTypeParamContext is an interface to support dynamic dispatch.
type IVariantTypeParamContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariantTypeParamContext differentiates from other interfaces.
	IsVariantTypeParamContext()
}

type VariantTypeParamContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariantTypeParamContext() *VariantTypeParamContext {
	var p = new(VariantTypeParamContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_variantTypeParam
	return p
}

func (*VariantTypeParamContext) IsVariantTypeParamContext() {}

func NewVariantTypeParamContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariantTypeParamContext {
	var p = new(VariantTypeParamContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_variantTypeParam

	return p
}

func (s *VariantTypeParamContext) GetParser() antlr.Parser { return s.parser }

func (s *VariantTypeParamContext) TypeParam() ITypeParamContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeParamContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeParamContext)
}

func (s *VariantTypeParamContext) AllAnnotation() []IAnnotationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotationContext)(nil)).Elem())
	var tst = make([]IAnnotationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotationContext)
		}
	}

	return tst
}

func (s *VariantTypeParamContext) Annotation(i int) IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *VariantTypeParamContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariantTypeParamContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariantTypeParamContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterVariantTypeParam(s)
	}
}

func (s *VariantTypeParamContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitVariantTypeParam(s)
	}
}

func (p *ScalaParser) VariantTypeParam() (localctx IVariantTypeParamContext) {
	this := p
	_ = this

	localctx = NewVariantTypeParamContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, ScalaParserRULE_variantTypeParam)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(837)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ScalaParserT__43 {
		{
			p.SetState(834)
			p.Annotation()
		}

		p.SetState(839)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(841)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ScalaParserT__0 || _la == ScalaParserT__35 {
		{
			p.SetState(840)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ScalaParserT__0 || _la == ScalaParserT__35) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(843)
		p.TypeParam()
	}

	return localctx
}

// ITypeParamContext is an interface to support dynamic dispatch.
type ITypeParamContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeParamContext differentiates from other interfaces.
	IsTypeParamContext()
}

type TypeParamContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeParamContext() *TypeParamContext {
	var p = new(TypeParamContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_typeParam
	return p
}

func (*TypeParamContext) IsTypeParamContext() {}

func NewTypeParamContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeParamContext {
	var p = new(TypeParamContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_typeParam

	return p
}

func (s *TypeParamContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeParamContext) Id() antlr.TerminalNode {
	return s.GetToken(ScalaParserId, 0)
}

func (s *TypeParamContext) TypeParamClause() ITypeParamClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeParamClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeParamClauseContext)
}

func (s *TypeParamContext) AllType_() []IType_Context {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IType_Context)(nil)).Elem())
	var tst = make([]IType_Context, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IType_Context)
		}
	}

	return tst
}

func (s *TypeParamContext) Type_(i int) IType_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_Context)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *TypeParamContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeParamContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeParamContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterTypeParam(s)
	}
}

func (s *TypeParamContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitTypeParam(s)
	}
}

func (p *ScalaParser) TypeParam() (localctx ITypeParamContext) {
	this := p
	_ = this

	localctx = NewTypeParamContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, ScalaParserRULE_typeParam)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(845)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ScalaParserT__19 || _la == ScalaParserId) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(847)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ScalaParserT__6 {
		{
			p.SetState(846)
			p.TypeParamClause()
		}

	}
	p.SetState(851)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ScalaParserT__44 {
		{
			p.SetState(849)
			p.Match(ScalaParserT__44)
		}
		{
			p.SetState(850)
			p.Type_()
		}

	}
	p.SetState(855)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ScalaParserT__45 {
		{
			p.SetState(853)
			p.Match(ScalaParserT__45)
		}
		{
			p.SetState(854)
			p.Type_()
		}

	}
	p.SetState(861)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ScalaParserT__46 {
		{
			p.SetState(857)
			p.Match(ScalaParserT__46)
		}
		{
			p.SetState(858)
			p.Type_()
		}

		p.SetState(863)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(868)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ScalaParserT__18 {
		{
			p.SetState(864)
			p.Match(ScalaParserT__18)
		}
		{
			p.SetState(865)
			p.Type_()
		}

		p.SetState(870)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IParamClausesContext is an interface to support dynamic dispatch.
type IParamClausesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParamClausesContext differentiates from other interfaces.
	IsParamClausesContext()
}

type ParamClausesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParamClausesContext() *ParamClausesContext {
	var p = new(ParamClausesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_paramClauses
	return p
}

func (*ParamClausesContext) IsParamClausesContext() {}

func NewParamClausesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParamClausesContext {
	var p = new(ParamClausesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_paramClauses

	return p
}

func (s *ParamClausesContext) GetParser() antlr.Parser { return s.parser }

func (s *ParamClausesContext) AllParamClause() []IParamClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IParamClauseContext)(nil)).Elem())
	var tst = make([]IParamClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IParamClauseContext)
		}
	}

	return tst
}

func (s *ParamClausesContext) ParamClause(i int) IParamClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParamClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IParamClauseContext)
}

func (s *ParamClausesContext) Params() IParamsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParamsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParamsContext)
}

func (s *ParamClausesContext) NL() antlr.TerminalNode {
	return s.GetToken(ScalaParserNL, 0)
}

func (s *ParamClausesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParamClausesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParamClausesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterParamClauses(s)
	}
}

func (s *ParamClausesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitParamClauses(s)
	}
}

func (p *ScalaParser) ParamClauses() (localctx IParamClausesContext) {
	this := p
	_ = this

	localctx = NewParamClausesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, ScalaParserRULE_paramClauses)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(874)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 112, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(871)
				p.ParamClause()
			}

		}
		p.SetState(876)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 112, p.GetParserRuleContext())
	}
	p.SetState(885)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 114, p.GetParserRuleContext()) == 1 {
		p.SetState(878)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ScalaParserNL {
			{
				p.SetState(877)
				p.Match(ScalaParserNL)
			}

		}
		{
			p.SetState(880)
			p.Match(ScalaParserT__9)
		}
		{
			p.SetState(881)
			p.Match(ScalaParserT__21)
		}
		{
			p.SetState(882)
			p.Params()
		}
		{
			p.SetState(883)
			p.Match(ScalaParserT__10)
		}

	}

	return localctx
}

// IParamClauseContext is an interface to support dynamic dispatch.
type IParamClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParamClauseContext differentiates from other interfaces.
	IsParamClauseContext()
}

type ParamClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParamClauseContext() *ParamClauseContext {
	var p = new(ParamClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_paramClause
	return p
}

func (*ParamClauseContext) IsParamClauseContext() {}

func NewParamClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParamClauseContext {
	var p = new(ParamClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_paramClause

	return p
}

func (s *ParamClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ParamClauseContext) NL() antlr.TerminalNode {
	return s.GetToken(ScalaParserNL, 0)
}

func (s *ParamClauseContext) Params() IParamsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParamsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParamsContext)
}

func (s *ParamClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParamClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParamClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterParamClause(s)
	}
}

func (s *ParamClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitParamClause(s)
	}
}

func (p *ScalaParser) ParamClause() (localctx IParamClauseContext) {
	this := p
	_ = this

	localctx = NewParamClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, ScalaParserRULE_paramClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(888)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ScalaParserNL {
		{
			p.SetState(887)
			p.Match(ScalaParserNL)
		}

	}
	{
		p.SetState(890)
		p.Match(ScalaParserT__9)
	}
	p.SetState(892)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ScalaParserT__43 || _la == ScalaParserId {
		{
			p.SetState(891)
			p.Params()
		}

	}
	{
		p.SetState(894)
		p.Match(ScalaParserT__10)
	}

	return localctx
}

// IParamsContext is an interface to support dynamic dispatch.
type IParamsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParamsContext differentiates from other interfaces.
	IsParamsContext()
}

type ParamsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParamsContext() *ParamsContext {
	var p = new(ParamsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_params
	return p
}

func (*ParamsContext) IsParamsContext() {}

func NewParamsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParamsContext {
	var p = new(ParamsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_params

	return p
}

func (s *ParamsContext) GetParser() antlr.Parser { return s.parser }

func (s *ParamsContext) AllParam() []IParamContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IParamContext)(nil)).Elem())
	var tst = make([]IParamContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IParamContext)
		}
	}

	return tst
}

func (s *ParamsContext) Param(i int) IParamContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParamContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IParamContext)
}

func (s *ParamsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParamsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParamsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterParams(s)
	}
}

func (s *ParamsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitParams(s)
	}
}

func (p *ScalaParser) Params() (localctx IParamsContext) {
	this := p
	_ = this

	localctx = NewParamsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, ScalaParserRULE_params)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(896)
		p.Param()
	}
	p.SetState(901)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ScalaParserT__3 {
		{
			p.SetState(897)
			p.Match(ScalaParserT__3)
		}
		{
			p.SetState(898)
			p.Param()
		}

		p.SetState(903)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IParamContext is an interface to support dynamic dispatch.
type IParamContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParamContext differentiates from other interfaces.
	IsParamContext()
}

type ParamContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParamContext() *ParamContext {
	var p = new(ParamContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_param
	return p
}

func (*ParamContext) IsParamContext() {}

func NewParamContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParamContext {
	var p = new(ParamContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_param

	return p
}

func (s *ParamContext) GetParser() antlr.Parser { return s.parser }

func (s *ParamContext) Id() antlr.TerminalNode {
	return s.GetToken(ScalaParserId, 0)
}

func (s *ParamContext) AllAnnotation() []IAnnotationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotationContext)(nil)).Elem())
	var tst = make([]IAnnotationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotationContext)
		}
	}

	return tst
}

func (s *ParamContext) Annotation(i int) IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *ParamContext) ParamType() IParamTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParamTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParamTypeContext)
}

func (s *ParamContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ParamContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParamContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParamContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterParam(s)
	}
}

func (s *ParamContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitParam(s)
	}
}

func (p *ScalaParser) Param() (localctx IParamContext) {
	this := p
	_ = this

	localctx = NewParamContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, ScalaParserRULE_param)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(907)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ScalaParserT__43 {
		{
			p.SetState(904)
			p.Annotation()
		}

		p.SetState(909)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(910)
		p.Match(ScalaParserId)
	}
	p.SetState(913)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ScalaParserT__18 {
		{
			p.SetState(911)
			p.Match(ScalaParserT__18)
		}
		{
			p.SetState(912)
			p.ParamType()
		}

	}
	p.SetState(917)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ScalaParserT__33 {
		{
			p.SetState(915)
			p.Match(ScalaParserT__33)
		}
		{
			p.SetState(916)
			p.Expr()
		}

	}

	return localctx
}

// IParamTypeContext is an interface to support dynamic dispatch.
type IParamTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParamTypeContext differentiates from other interfaces.
	IsParamTypeContext()
}

type ParamTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParamTypeContext() *ParamTypeContext {
	var p = new(ParamTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_paramType
	return p
}

func (*ParamTypeContext) IsParamTypeContext() {}

func NewParamTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParamTypeContext {
	var p = new(ParamTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_paramType

	return p
}

func (s *ParamTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ParamTypeContext) Type_() IType_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *ParamTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParamTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParamTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterParamType(s)
	}
}

func (s *ParamTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitParamType(s)
	}
}

func (p *ScalaParser) ParamType() (localctx IParamTypeContext) {
	this := p
	_ = this

	localctx = NewParamTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, ScalaParserRULE_paramType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(925)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 121, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(919)
			p.Type_()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(920)
			p.Match(ScalaParserT__8)
		}
		{
			p.SetState(921)
			p.Type_()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(922)
			p.Type_()
		}
		{
			p.SetState(923)
			p.Match(ScalaParserT__20)
		}

	}

	return localctx
}

// IClassParamClausesContext is an interface to support dynamic dispatch.
type IClassParamClausesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassParamClausesContext differentiates from other interfaces.
	IsClassParamClausesContext()
}

type ClassParamClausesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassParamClausesContext() *ClassParamClausesContext {
	var p = new(ClassParamClausesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_classParamClauses
	return p
}

func (*ClassParamClausesContext) IsClassParamClausesContext() {}

func NewClassParamClausesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassParamClausesContext {
	var p = new(ClassParamClausesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_classParamClauses

	return p
}

func (s *ClassParamClausesContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassParamClausesContext) AllClassParamClause() []IClassParamClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IClassParamClauseContext)(nil)).Elem())
	var tst = make([]IClassParamClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IClassParamClauseContext)
		}
	}

	return tst
}

func (s *ClassParamClausesContext) ClassParamClause(i int) IClassParamClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassParamClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IClassParamClauseContext)
}

func (s *ClassParamClausesContext) ClassParams() IClassParamsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassParamsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassParamsContext)
}

func (s *ClassParamClausesContext) NL() antlr.TerminalNode {
	return s.GetToken(ScalaParserNL, 0)
}

func (s *ClassParamClausesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassParamClausesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassParamClausesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterClassParamClauses(s)
	}
}

func (s *ClassParamClausesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitClassParamClauses(s)
	}
}

func (p *ScalaParser) ClassParamClauses() (localctx IClassParamClausesContext) {
	this := p
	_ = this

	localctx = NewClassParamClausesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, ScalaParserRULE_classParamClauses)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(930)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 122, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(927)
				p.ClassParamClause()
			}

		}
		p.SetState(932)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 122, p.GetParserRuleContext())
	}
	p.SetState(941)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 124, p.GetParserRuleContext()) == 1 {
		p.SetState(934)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ScalaParserNL {
			{
				p.SetState(933)
				p.Match(ScalaParserNL)
			}

		}
		{
			p.SetState(936)
			p.Match(ScalaParserT__9)
		}
		{
			p.SetState(937)
			p.Match(ScalaParserT__21)
		}
		{
			p.SetState(938)
			p.ClassParams()
		}
		{
			p.SetState(939)
			p.Match(ScalaParserT__10)
		}

	}

	return localctx
}

// IClassParamClauseContext is an interface to support dynamic dispatch.
type IClassParamClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassParamClauseContext differentiates from other interfaces.
	IsClassParamClauseContext()
}

type ClassParamClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassParamClauseContext() *ClassParamClauseContext {
	var p = new(ClassParamClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_classParamClause
	return p
}

func (*ClassParamClauseContext) IsClassParamClauseContext() {}

func NewClassParamClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassParamClauseContext {
	var p = new(ClassParamClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_classParamClause

	return p
}

func (s *ClassParamClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassParamClauseContext) NL() antlr.TerminalNode {
	return s.GetToken(ScalaParserNL, 0)
}

func (s *ClassParamClauseContext) ClassParams() IClassParamsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassParamsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassParamsContext)
}

func (s *ClassParamClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassParamClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassParamClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterClassParamClause(s)
	}
}

func (s *ClassParamClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitClassParamClause(s)
	}
}

func (p *ScalaParser) ClassParamClause() (localctx IClassParamClauseContext) {
	this := p
	_ = this

	localctx = NewClassParamClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, ScalaParserRULE_classParamClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(944)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ScalaParserNL {
		{
			p.SetState(943)
			p.Match(ScalaParserNL)
		}

	}
	{
		p.SetState(946)
		p.Match(ScalaParserT__9)
	}
	p.SetState(948)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ScalaParserT__15 || _la == ScalaParserT__21 || (((_la-40)&-(0x1f+1)) == 0 && ((1<<uint((_la-40)))&((1<<(ScalaParserT__39-40))|(1<<(ScalaParserT__43-40))|(1<<(ScalaParserT__47-40))|(1<<(ScalaParserT__48-40))|(1<<(ScalaParserT__49-40))|(1<<(ScalaParserT__50-40))|(1<<(ScalaParserT__51-40))|(1<<(ScalaParserT__52-40))|(1<<(ScalaParserT__53-40))|(1<<(ScalaParserId-40)))) != 0) {
		{
			p.SetState(947)
			p.ClassParams()
		}

	}
	{
		p.SetState(950)
		p.Match(ScalaParserT__10)
	}

	return localctx
}

// IClassParamsContext is an interface to support dynamic dispatch.
type IClassParamsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassParamsContext differentiates from other interfaces.
	IsClassParamsContext()
}

type ClassParamsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassParamsContext() *ClassParamsContext {
	var p = new(ClassParamsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_classParams
	return p
}

func (*ClassParamsContext) IsClassParamsContext() {}

func NewClassParamsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassParamsContext {
	var p = new(ClassParamsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_classParams

	return p
}

func (s *ClassParamsContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassParamsContext) AllClassParam() []IClassParamContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IClassParamContext)(nil)).Elem())
	var tst = make([]IClassParamContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IClassParamContext)
		}
	}

	return tst
}

func (s *ClassParamsContext) ClassParam(i int) IClassParamContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassParamContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IClassParamContext)
}

func (s *ClassParamsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassParamsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassParamsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterClassParams(s)
	}
}

func (s *ClassParamsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitClassParams(s)
	}
}

func (p *ScalaParser) ClassParams() (localctx IClassParamsContext) {
	this := p
	_ = this

	localctx = NewClassParamsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, ScalaParserRULE_classParams)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(952)
		p.ClassParam()
	}
	p.SetState(957)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ScalaParserT__3 {
		{
			p.SetState(953)
			p.Match(ScalaParserT__3)
		}
		{
			p.SetState(954)
			p.ClassParam()
		}

		p.SetState(959)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IClassParamContext is an interface to support dynamic dispatch.
type IClassParamContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassParamContext differentiates from other interfaces.
	IsClassParamContext()
}

type ClassParamContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassParamContext() *ClassParamContext {
	var p = new(ClassParamContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_classParam
	return p
}

func (*ClassParamContext) IsClassParamContext() {}

func NewClassParamContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassParamContext {
	var p = new(ClassParamContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_classParam

	return p
}

func (s *ClassParamContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassParamContext) Id() antlr.TerminalNode {
	return s.GetToken(ScalaParserId, 0)
}

func (s *ClassParamContext) ParamType() IParamTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParamTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParamTypeContext)
}

func (s *ClassParamContext) AllAnnotation() []IAnnotationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotationContext)(nil)).Elem())
	var tst = make([]IAnnotationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotationContext)
		}
	}

	return tst
}

func (s *ClassParamContext) Annotation(i int) IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *ClassParamContext) AllModifier() []IModifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IModifierContext)(nil)).Elem())
	var tst = make([]IModifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IModifierContext)
		}
	}

	return tst
}

func (s *ClassParamContext) Modifier(i int) IModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IModifierContext)
}

func (s *ClassParamContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ClassParamContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassParamContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassParamContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterClassParam(s)
	}
}

func (s *ClassParamContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitClassParam(s)
	}
}

func (p *ScalaParser) ClassParam() (localctx IClassParamContext) {
	this := p
	_ = this

	localctx = NewClassParamContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, ScalaParserRULE_classParam)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(963)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ScalaParserT__43 {
		{
			p.SetState(960)
			p.Annotation()
		}

		p.SetState(965)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(969)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ScalaParserT__21 || (((_la-40)&-(0x1f+1)) == 0 && ((1<<uint((_la-40)))&((1<<(ScalaParserT__39-40))|(1<<(ScalaParserT__48-40))|(1<<(ScalaParserT__49-40))|(1<<(ScalaParserT__50-40))|(1<<(ScalaParserT__51-40))|(1<<(ScalaParserT__52-40))|(1<<(ScalaParserT__53-40)))) != 0) {
		{
			p.SetState(966)
			p.Modifier()
		}

		p.SetState(971)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(973)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ScalaParserT__15 || _la == ScalaParserT__47 {
		{
			p.SetState(972)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ScalaParserT__15 || _la == ScalaParserT__47) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(975)
		p.Match(ScalaParserId)
	}
	{
		p.SetState(976)
		p.Match(ScalaParserT__18)
	}
	{
		p.SetState(977)
		p.ParamType()
	}
	p.SetState(980)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ScalaParserT__33 {
		{
			p.SetState(978)
			p.Match(ScalaParserT__33)
		}
		{
			p.SetState(979)
			p.Expr()
		}

	}

	return localctx
}

// IBindingsContext is an interface to support dynamic dispatch.
type IBindingsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBindingsContext differentiates from other interfaces.
	IsBindingsContext()
}

type BindingsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBindingsContext() *BindingsContext {
	var p = new(BindingsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_bindings
	return p
}

func (*BindingsContext) IsBindingsContext() {}

func NewBindingsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BindingsContext {
	var p = new(BindingsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_bindings

	return p
}

func (s *BindingsContext) GetParser() antlr.Parser { return s.parser }

func (s *BindingsContext) AllBinding() []IBindingContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBindingContext)(nil)).Elem())
	var tst = make([]IBindingContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBindingContext)
		}
	}

	return tst
}

func (s *BindingsContext) Binding(i int) IBindingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBindingContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBindingContext)
}

func (s *BindingsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BindingsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BindingsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterBindings(s)
	}
}

func (s *BindingsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitBindings(s)
	}
}

func (p *ScalaParser) Bindings() (localctx IBindingsContext) {
	this := p
	_ = this

	localctx = NewBindingsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, ScalaParserRULE_bindings)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(982)
		p.Match(ScalaParserT__9)
	}
	{
		p.SetState(983)
		p.Binding()
	}
	p.SetState(988)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ScalaParserT__3 {
		{
			p.SetState(984)
			p.Match(ScalaParserT__3)
		}
		{
			p.SetState(985)
			p.Binding()
		}

		p.SetState(990)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(991)
		p.Match(ScalaParserT__10)
	}

	return localctx
}

// IBindingContext is an interface to support dynamic dispatch.
type IBindingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBindingContext differentiates from other interfaces.
	IsBindingContext()
}

type BindingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBindingContext() *BindingContext {
	var p = new(BindingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_binding
	return p
}

func (*BindingContext) IsBindingContext() {}

func NewBindingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BindingContext {
	var p = new(BindingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_binding

	return p
}

func (s *BindingContext) GetParser() antlr.Parser { return s.parser }

func (s *BindingContext) Id() antlr.TerminalNode {
	return s.GetToken(ScalaParserId, 0)
}

func (s *BindingContext) Type_() IType_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *BindingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BindingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BindingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterBinding(s)
	}
}

func (s *BindingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitBinding(s)
	}
}

func (p *ScalaParser) Binding() (localctx IBindingContext) {
	this := p
	_ = this

	localctx = NewBindingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, ScalaParserRULE_binding)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(993)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ScalaParserT__19 || _la == ScalaParserId) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(996)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ScalaParserT__18 {
		{
			p.SetState(994)
			p.Match(ScalaParserT__18)
		}
		{
			p.SetState(995)
			p.Type_()
		}

	}

	return localctx
}

// IModifierContext is an interface to support dynamic dispatch.
type IModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModifierContext differentiates from other interfaces.
	IsModifierContext()
}

type ModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifierContext() *ModifierContext {
	var p = new(ModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_modifier
	return p
}

func (*ModifierContext) IsModifierContext() {}

func NewModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifierContext {
	var p = new(ModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_modifier

	return p
}

func (s *ModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifierContext) LocalModifier() ILocalModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILocalModifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILocalModifierContext)
}

func (s *ModifierContext) AccessModifier() IAccessModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAccessModifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAccessModifierContext)
}

func (s *ModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterModifier(s)
	}
}

func (s *ModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitModifier(s)
	}
}

func (p *ScalaParser) Modifier() (localctx IModifierContext) {
	this := p
	_ = this

	localctx = NewModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, ScalaParserRULE_modifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1001)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ScalaParserT__21, ScalaParserT__39, ScalaParserT__49, ScalaParserT__50, ScalaParserT__51:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(998)
			p.LocalModifier()
		}

	case ScalaParserT__52, ScalaParserT__53:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(999)
			p.AccessModifier()
		}

	case ScalaParserT__48:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1000)
			p.Match(ScalaParserT__48)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ILocalModifierContext is an interface to support dynamic dispatch.
type ILocalModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLocalModifierContext differentiates from other interfaces.
	IsLocalModifierContext()
}

type LocalModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLocalModifierContext() *LocalModifierContext {
	var p = new(LocalModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_localModifier
	return p
}

func (*LocalModifierContext) IsLocalModifierContext() {}

func NewLocalModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LocalModifierContext {
	var p = new(LocalModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_localModifier

	return p
}

func (s *LocalModifierContext) GetParser() antlr.Parser { return s.parser }
func (s *LocalModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LocalModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LocalModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterLocalModifier(s)
	}
}

func (s *LocalModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitLocalModifier(s)
	}
}

func (p *ScalaParser) LocalModifier() (localctx ILocalModifierContext) {
	this := p
	_ = this

	localctx = NewLocalModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, ScalaParserRULE_localModifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1003)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-22)&-(0x1f+1)) == 0 && ((1<<uint((_la-22)))&((1<<(ScalaParserT__21-22))|(1<<(ScalaParserT__39-22))|(1<<(ScalaParserT__49-22))|(1<<(ScalaParserT__50-22))|(1<<(ScalaParserT__51-22)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IAccessModifierContext is an interface to support dynamic dispatch.
type IAccessModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAccessModifierContext differentiates from other interfaces.
	IsAccessModifierContext()
}

type AccessModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAccessModifierContext() *AccessModifierContext {
	var p = new(AccessModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_accessModifier
	return p
}

func (*AccessModifierContext) IsAccessModifierContext() {}

func NewAccessModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AccessModifierContext {
	var p = new(AccessModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_accessModifier

	return p
}

func (s *AccessModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *AccessModifierContext) AccessQualifier() IAccessQualifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAccessQualifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAccessQualifierContext)
}

func (s *AccessModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AccessModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AccessModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterAccessModifier(s)
	}
}

func (s *AccessModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitAccessModifier(s)
	}
}

func (p *ScalaParser) AccessModifier() (localctx IAccessModifierContext) {
	this := p
	_ = this

	localctx = NewAccessModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, ScalaParserRULE_accessModifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1005)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ScalaParserT__52 || _la == ScalaParserT__53) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(1007)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ScalaParserT__6 {
		{
			p.SetState(1006)
			p.AccessQualifier()
		}

	}

	return localctx
}

// IAccessQualifierContext is an interface to support dynamic dispatch.
type IAccessQualifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAccessQualifierContext differentiates from other interfaces.
	IsAccessQualifierContext()
}

type AccessQualifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAccessQualifierContext() *AccessQualifierContext {
	var p = new(AccessQualifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_accessQualifier
	return p
}

func (*AccessQualifierContext) IsAccessQualifierContext() {}

func NewAccessQualifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AccessQualifierContext {
	var p = new(AccessQualifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_accessQualifier

	return p
}

func (s *AccessQualifierContext) GetParser() antlr.Parser { return s.parser }

func (s *AccessQualifierContext) Id() antlr.TerminalNode {
	return s.GetToken(ScalaParserId, 0)
}

func (s *AccessQualifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AccessQualifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AccessQualifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterAccessQualifier(s)
	}
}

func (s *AccessQualifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitAccessQualifier(s)
	}
}

func (p *ScalaParser) AccessQualifier() (localctx IAccessQualifierContext) {
	this := p
	_ = this

	localctx = NewAccessQualifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, ScalaParserRULE_accessQualifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1009)
		p.Match(ScalaParserT__6)
	}
	{
		p.SetState(1010)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ScalaParserT__4 || _la == ScalaParserId) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1011)
		p.Match(ScalaParserT__7)
	}

	return localctx
}

// IAnnotationContext is an interface to support dynamic dispatch.
type IAnnotationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnnotationContext differentiates from other interfaces.
	IsAnnotationContext()
}

type AnnotationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationContext() *AnnotationContext {
	var p = new(AnnotationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_annotation
	return p
}

func (*AnnotationContext) IsAnnotationContext() {}

func NewAnnotationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationContext {
	var p = new(AnnotationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_annotation

	return p
}

func (s *AnnotationContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationContext) SimpleType() ISimpleTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimpleTypeContext)
}

func (s *AnnotationContext) AllArgumentExprs() []IArgumentExprsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IArgumentExprsContext)(nil)).Elem())
	var tst = make([]IArgumentExprsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IArgumentExprsContext)
		}
	}

	return tst
}

func (s *AnnotationContext) ArgumentExprs(i int) IArgumentExprsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentExprsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IArgumentExprsContext)
}

func (s *AnnotationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterAnnotation(s)
	}
}

func (s *AnnotationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitAnnotation(s)
	}
}

func (p *ScalaParser) Annotation() (localctx IAnnotationContext) {
	this := p
	_ = this

	localctx = NewAnnotationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, ScalaParserRULE_annotation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1013)
		p.Match(ScalaParserT__43)
	}
	{
		p.SetState(1014)
		p.simpleType(0)
	}
	p.SetState(1018)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 136, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1015)
				p.ArgumentExprs()
			}

		}
		p.SetState(1020)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 136, p.GetParserRuleContext())
	}

	return localctx
}

// IConstrAnnotationContext is an interface to support dynamic dispatch.
type IConstrAnnotationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstrAnnotationContext differentiates from other interfaces.
	IsConstrAnnotationContext()
}

type ConstrAnnotationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstrAnnotationContext() *ConstrAnnotationContext {
	var p = new(ConstrAnnotationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_constrAnnotation
	return p
}

func (*ConstrAnnotationContext) IsConstrAnnotationContext() {}

func NewConstrAnnotationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstrAnnotationContext {
	var p = new(ConstrAnnotationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_constrAnnotation

	return p
}

func (s *ConstrAnnotationContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstrAnnotationContext) SimpleType() ISimpleTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimpleTypeContext)
}

func (s *ConstrAnnotationContext) ArgumentExprs() IArgumentExprsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentExprsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgumentExprsContext)
}

func (s *ConstrAnnotationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstrAnnotationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstrAnnotationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterConstrAnnotation(s)
	}
}

func (s *ConstrAnnotationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitConstrAnnotation(s)
	}
}

func (p *ScalaParser) ConstrAnnotation() (localctx IConstrAnnotationContext) {
	this := p
	_ = this

	localctx = NewConstrAnnotationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, ScalaParserRULE_constrAnnotation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1021)
		p.Match(ScalaParserT__43)
	}
	{
		p.SetState(1022)
		p.simpleType(0)
	}
	{
		p.SetState(1023)
		p.ArgumentExprs()
	}

	return localctx
}

// ITemplateBodyContext is an interface to support dynamic dispatch.
type ITemplateBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTemplateBodyContext differentiates from other interfaces.
	IsTemplateBodyContext()
}

type TemplateBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTemplateBodyContext() *TemplateBodyContext {
	var p = new(TemplateBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_templateBody
	return p
}

func (*TemplateBodyContext) IsTemplateBodyContext() {}

func NewTemplateBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TemplateBodyContext {
	var p = new(TemplateBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_templateBody

	return p
}

func (s *TemplateBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *TemplateBodyContext) NL() antlr.TerminalNode {
	return s.GetToken(ScalaParserNL, 0)
}

func (s *TemplateBodyContext) SelfType() ISelfTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelfTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelfTypeContext)
}

func (s *TemplateBodyContext) AllTemplateStat() []ITemplateStatContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITemplateStatContext)(nil)).Elem())
	var tst = make([]ITemplateStatContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITemplateStatContext)
		}
	}

	return tst
}

func (s *TemplateBodyContext) TemplateStat(i int) ITemplateStatContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITemplateStatContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITemplateStatContext)
}

func (s *TemplateBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TemplateBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TemplateBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterTemplateBody(s)
	}
}

func (s *TemplateBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitTemplateBody(s)
	}
}

func (p *ScalaParser) TemplateBody() (localctx ITemplateBodyContext) {
	this := p
	_ = this

	localctx = NewTemplateBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, ScalaParserRULE_templateBody)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1026)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ScalaParserNL {
		{
			p.SetState(1025)
			p.Match(ScalaParserNL)
		}

	}
	{
		p.SetState(1028)
		p.Match(ScalaParserT__12)
	}
	p.SetState(1030)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 138, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1029)
			p.SelfType()
		}

	}
	p.SetState(1033)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ScalaParserT__0)|(1<<ScalaParserT__1)|(1<<ScalaParserT__4)|(1<<ScalaParserT__5)|(1<<ScalaParserT__9)|(1<<ScalaParserT__12)|(1<<ScalaParserT__14)|(1<<ScalaParserT__15)|(1<<ScalaParserT__19)|(1<<ScalaParserT__21)|(1<<ScalaParserT__22)|(1<<ScalaParserT__24)|(1<<ScalaParserT__25)|(1<<ScalaParserT__28)|(1<<ScalaParserT__29))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(ScalaParserT__31-32))|(1<<(ScalaParserT__32-32))|(1<<(ScalaParserT__35-32))|(1<<(ScalaParserT__36-32))|(1<<(ScalaParserT__37-32))|(1<<(ScalaParserT__38-32))|(1<<(ScalaParserT__39-32))|(1<<(ScalaParserT__41-32))|(1<<(ScalaParserT__43-32))|(1<<(ScalaParserT__47-32))|(1<<(ScalaParserT__48-32))|(1<<(ScalaParserT__49-32))|(1<<(ScalaParserT__50-32))|(1<<(ScalaParserT__51-32))|(1<<(ScalaParserT__52-32))|(1<<(ScalaParserT__53-32))|(1<<(ScalaParserT__54-32))|(1<<(ScalaParserT__55-32))|(1<<(ScalaParserT__56-32))|(1<<(ScalaParserT__57-32))|(1<<(ScalaParserT__58-32))|(1<<(ScalaParserId-32))|(1<<(ScalaParserBooleanLiteral-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(ScalaParserCharacterLiteral-64))|(1<<(ScalaParserSymbolLiteral-64))|(1<<(ScalaParserIntegerLiteral-64))|(1<<(ScalaParserStringLiteral-64))|(1<<(ScalaParserFloatingPointLiteral-64)))) != 0) {
		{
			p.SetState(1032)
			p.TemplateStat()
		}

		p.SetState(1035)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1037)
		p.Match(ScalaParserT__13)
	}

	return localctx
}

// ITemplateStatContext is an interface to support dynamic dispatch.
type ITemplateStatContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTemplateStatContext differentiates from other interfaces.
	IsTemplateStatContext()
}

type TemplateStatContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTemplateStatContext() *TemplateStatContext {
	var p = new(TemplateStatContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_templateStat
	return p
}

func (*TemplateStatContext) IsTemplateStatContext() {}

func NewTemplateStatContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TemplateStatContext {
	var p = new(TemplateStatContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_templateStat

	return p
}

func (s *TemplateStatContext) GetParser() antlr.Parser { return s.parser }

func (s *TemplateStatContext) Import_() IImport_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImport_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImport_Context)
}

func (s *TemplateStatContext) Def_() IDef_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDef_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDef_Context)
}

func (s *TemplateStatContext) AllAnnotation() []IAnnotationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotationContext)(nil)).Elem())
	var tst = make([]IAnnotationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotationContext)
		}
	}

	return tst
}

func (s *TemplateStatContext) Annotation(i int) IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *TemplateStatContext) AllModifier() []IModifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IModifierContext)(nil)).Elem())
	var tst = make([]IModifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IModifierContext)
		}
	}

	return tst
}

func (s *TemplateStatContext) Modifier(i int) IModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IModifierContext)
}

func (s *TemplateStatContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(ScalaParserNL)
}

func (s *TemplateStatContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(ScalaParserNL, i)
}

func (s *TemplateStatContext) Dcl() IDclContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDclContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDclContext)
}

func (s *TemplateStatContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *TemplateStatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TemplateStatContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TemplateStatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterTemplateStat(s)
	}
}

func (s *TemplateStatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitTemplateStat(s)
	}
}

func (p *ScalaParser) TemplateStat() (localctx ITemplateStatContext) {
	this := p
	_ = this

	localctx = NewTemplateStatContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, ScalaParserRULE_templateStat)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1073)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 146, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1039)
			p.Import_()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1046)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == ScalaParserT__43 {
			{
				p.SetState(1040)
				p.Annotation()
			}
			p.SetState(1042)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == ScalaParserNL {
				{
					p.SetState(1041)
					p.Match(ScalaParserNL)
				}

			}

			p.SetState(1048)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(1052)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == ScalaParserT__21 || (((_la-40)&-(0x1f+1)) == 0 && ((1<<uint((_la-40)))&((1<<(ScalaParserT__39-40))|(1<<(ScalaParserT__48-40))|(1<<(ScalaParserT__49-40))|(1<<(ScalaParserT__50-40))|(1<<(ScalaParserT__51-40))|(1<<(ScalaParserT__52-40))|(1<<(ScalaParserT__53-40)))) != 0) {
			{
				p.SetState(1049)
				p.Modifier()
			}

			p.SetState(1054)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1055)
			p.Def_()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(1062)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == ScalaParserT__43 {
			{
				p.SetState(1056)
				p.Annotation()
			}
			p.SetState(1058)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == ScalaParserNL {
				{
					p.SetState(1057)
					p.Match(ScalaParserNL)
				}

			}

			p.SetState(1064)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(1068)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == ScalaParserT__21 || (((_la-40)&-(0x1f+1)) == 0 && ((1<<uint((_la-40)))&((1<<(ScalaParserT__39-40))|(1<<(ScalaParserT__48-40))|(1<<(ScalaParserT__49-40))|(1<<(ScalaParserT__50-40))|(1<<(ScalaParserT__51-40))|(1<<(ScalaParserT__52-40))|(1<<(ScalaParserT__53-40)))) != 0) {
			{
				p.SetState(1065)
				p.Modifier()
			}

			p.SetState(1070)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1071)
			p.Dcl()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1072)
			p.Expr()
		}

	}

	return localctx
}

// ISelfTypeContext is an interface to support dynamic dispatch.
type ISelfTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelfTypeContext differentiates from other interfaces.
	IsSelfTypeContext()
}

type SelfTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelfTypeContext() *SelfTypeContext {
	var p = new(SelfTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_selfType
	return p
}

func (*SelfTypeContext) IsSelfTypeContext() {}

func NewSelfTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelfTypeContext {
	var p = new(SelfTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_selfType

	return p
}

func (s *SelfTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *SelfTypeContext) Id() antlr.TerminalNode {
	return s.GetToken(ScalaParserId, 0)
}

func (s *SelfTypeContext) Type_() IType_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *SelfTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelfTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelfTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterSelfType(s)
	}
}

func (s *SelfTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitSelfType(s)
	}
}

func (p *ScalaParser) SelfType() (localctx ISelfTypeContext) {
	this := p
	_ = this

	localctx = NewSelfTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, ScalaParserRULE_selfType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1086)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ScalaParserId:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1075)
			p.Match(ScalaParserId)
		}
		p.SetState(1078)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ScalaParserT__18 {
			{
				p.SetState(1076)
				p.Match(ScalaParserT__18)
			}
			{
				p.SetState(1077)
				p.Type_()
			}

		}
		{
			p.SetState(1080)
			p.Match(ScalaParserT__8)
		}

	case ScalaParserT__4:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1081)
			p.Match(ScalaParserT__4)
		}
		{
			p.SetState(1082)
			p.Match(ScalaParserT__18)
		}
		{
			p.SetState(1083)
			p.Type_()
		}
		{
			p.SetState(1084)
			p.Match(ScalaParserT__8)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IImport_Context is an interface to support dynamic dispatch.
type IImport_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImport_Context differentiates from other interfaces.
	IsImport_Context()
}

type Import_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImport_Context() *Import_Context {
	var p = new(Import_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_import_
	return p
}

func (*Import_Context) IsImport_Context() {}

func NewImport_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Import_Context {
	var p = new(Import_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_import_

	return p
}

func (s *Import_Context) GetParser() antlr.Parser { return s.parser }

func (s *Import_Context) AllImportExpr() []IImportExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IImportExprContext)(nil)).Elem())
	var tst = make([]IImportExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IImportExprContext)
		}
	}

	return tst
}

func (s *Import_Context) ImportExpr(i int) IImportExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImportExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IImportExprContext)
}

func (s *Import_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Import_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Import_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterImport_(s)
	}
}

func (s *Import_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitImport_(s)
	}
}

func (p *ScalaParser) Import_() (localctx IImport_Context) {
	this := p
	_ = this

	localctx = NewImport_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, ScalaParserRULE_import_)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1088)
		p.Match(ScalaParserT__54)
	}
	{
		p.SetState(1089)
		p.ImportExpr()
	}
	p.SetState(1094)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ScalaParserT__3 {
		{
			p.SetState(1090)
			p.Match(ScalaParserT__3)
		}
		{
			p.SetState(1091)
			p.ImportExpr()
		}

		p.SetState(1096)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IImportExprContext is an interface to support dynamic dispatch.
type IImportExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImportExprContext differentiates from other interfaces.
	IsImportExprContext()
}

type ImportExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportExprContext() *ImportExprContext {
	var p = new(ImportExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_importExpr
	return p
}

func (*ImportExprContext) IsImportExprContext() {}

func NewImportExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportExprContext {
	var p = new(ImportExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_importExpr

	return p
}

func (s *ImportExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportExprContext) StableId() IStableIdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStableIdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStableIdContext)
}

func (s *ImportExprContext) Id() antlr.TerminalNode {
	return s.GetToken(ScalaParserId, 0)
}

func (s *ImportExprContext) ImportSelectors() IImportSelectorsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImportSelectorsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImportSelectorsContext)
}

func (s *ImportExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterImportExpr(s)
	}
}

func (s *ImportExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitImportExpr(s)
	}
}

func (p *ScalaParser) ImportExpr() (localctx IImportExprContext) {
	this := p
	_ = this

	localctx = NewImportExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, ScalaParserRULE_importExpr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1097)
		p.stableId(0)
	}
	p.SetState(1104)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ScalaParserT__2 {
		{
			p.SetState(1098)
			p.Match(ScalaParserT__2)
		}
		p.SetState(1102)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case ScalaParserId:
			{
				p.SetState(1099)
				p.Match(ScalaParserId)
			}

		case ScalaParserT__19:
			{
				p.SetState(1100)
				p.Match(ScalaParserT__19)
			}

		case ScalaParserT__12:
			{
				p.SetState(1101)
				p.ImportSelectors()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	}

	return localctx
}

// IImportSelectorsContext is an interface to support dynamic dispatch.
type IImportSelectorsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImportSelectorsContext differentiates from other interfaces.
	IsImportSelectorsContext()
}

type ImportSelectorsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportSelectorsContext() *ImportSelectorsContext {
	var p = new(ImportSelectorsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_importSelectors
	return p
}

func (*ImportSelectorsContext) IsImportSelectorsContext() {}

func NewImportSelectorsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportSelectorsContext {
	var p = new(ImportSelectorsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_importSelectors

	return p
}

func (s *ImportSelectorsContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportSelectorsContext) AllImportSelector() []IImportSelectorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IImportSelectorContext)(nil)).Elem())
	var tst = make([]IImportSelectorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IImportSelectorContext)
		}
	}

	return tst
}

func (s *ImportSelectorsContext) ImportSelector(i int) IImportSelectorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImportSelectorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IImportSelectorContext)
}

func (s *ImportSelectorsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportSelectorsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportSelectorsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterImportSelectors(s)
	}
}

func (s *ImportSelectorsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitImportSelectors(s)
	}
}

func (p *ScalaParser) ImportSelectors() (localctx IImportSelectorsContext) {
	this := p
	_ = this

	localctx = NewImportSelectorsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, ScalaParserRULE_importSelectors)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1106)
		p.Match(ScalaParserT__12)
	}
	p.SetState(1112)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 152, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1107)
				p.ImportSelector()
			}
			{
				p.SetState(1108)
				p.Match(ScalaParserT__3)
			}

		}
		p.SetState(1114)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 152, p.GetParserRuleContext())
	}
	p.SetState(1117)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ScalaParserId:
		{
			p.SetState(1115)
			p.ImportSelector()
		}

	case ScalaParserT__19:
		{
			p.SetState(1116)
			p.Match(ScalaParserT__19)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(1119)
		p.Match(ScalaParserT__13)
	}

	return localctx
}

// IImportSelectorContext is an interface to support dynamic dispatch.
type IImportSelectorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImportSelectorContext differentiates from other interfaces.
	IsImportSelectorContext()
}

type ImportSelectorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportSelectorContext() *ImportSelectorContext {
	var p = new(ImportSelectorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_importSelector
	return p
}

func (*ImportSelectorContext) IsImportSelectorContext() {}

func NewImportSelectorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportSelectorContext {
	var p = new(ImportSelectorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_importSelector

	return p
}

func (s *ImportSelectorContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportSelectorContext) AllId() []antlr.TerminalNode {
	return s.GetTokens(ScalaParserId)
}

func (s *ImportSelectorContext) Id(i int) antlr.TerminalNode {
	return s.GetToken(ScalaParserId, i)
}

func (s *ImportSelectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportSelectorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportSelectorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterImportSelector(s)
	}
}

func (s *ImportSelectorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitImportSelector(s)
	}
}

func (p *ScalaParser) ImportSelector() (localctx IImportSelectorContext) {
	this := p
	_ = this

	localctx = NewImportSelectorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, ScalaParserRULE_importSelector)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1121)
		p.Match(ScalaParserId)
	}
	p.SetState(1124)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ScalaParserT__8 {
		{
			p.SetState(1122)
			p.Match(ScalaParserT__8)
		}
		{
			p.SetState(1123)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ScalaParserT__19 || _la == ScalaParserId) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

	return localctx
}

// IDclContext is an interface to support dynamic dispatch.
type IDclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDclContext differentiates from other interfaces.
	IsDclContext()
}

type DclContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDclContext() *DclContext {
	var p = new(DclContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_dcl
	return p
}

func (*DclContext) IsDclContext() {}

func NewDclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DclContext {
	var p = new(DclContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_dcl

	return p
}

func (s *DclContext) GetParser() antlr.Parser { return s.parser }

func (s *DclContext) ValDcl() IValDclContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValDclContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValDclContext)
}

func (s *DclContext) VarDcl() IVarDclContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVarDclContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVarDclContext)
}

func (s *DclContext) FunDcl() IFunDclContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunDclContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunDclContext)
}

func (s *DclContext) TypeDcl() ITypeDclContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeDclContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeDclContext)
}

func (s *DclContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(ScalaParserNL)
}

func (s *DclContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(ScalaParserNL, i)
}

func (s *DclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterDcl(s)
	}
}

func (s *DclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitDcl(s)
	}
}

func (p *ScalaParser) Dcl() (localctx IDclContext) {
	this := p
	_ = this

	localctx = NewDclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, ScalaParserRULE_dcl)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1140)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ScalaParserT__15:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1126)
			p.Match(ScalaParserT__15)
		}
		{
			p.SetState(1127)
			p.ValDcl()
		}

	case ScalaParserT__47:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1128)
			p.Match(ScalaParserT__47)
		}
		{
			p.SetState(1129)
			p.VarDcl()
		}

	case ScalaParserT__55:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1130)
			p.Match(ScalaParserT__55)
		}
		{
			p.SetState(1131)
			p.FunDcl()
		}

	case ScalaParserT__14:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1132)
			p.Match(ScalaParserT__14)
		}
		p.SetState(1136)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == ScalaParserNL {
			{
				p.SetState(1133)
				p.Match(ScalaParserNL)
			}

			p.SetState(1138)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1139)
			p.TypeDcl()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IValDclContext is an interface to support dynamic dispatch.
type IValDclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsValDclContext differentiates from other interfaces.
	IsValDclContext()
}

type ValDclContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValDclContext() *ValDclContext {
	var p = new(ValDclContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_valDcl
	return p
}

func (*ValDclContext) IsValDclContext() {}

func NewValDclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValDclContext {
	var p = new(ValDclContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_valDcl

	return p
}

func (s *ValDclContext) GetParser() antlr.Parser { return s.parser }

func (s *ValDclContext) Ids() IIdsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdsContext)
}

func (s *ValDclContext) Type_() IType_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *ValDclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValDclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValDclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterValDcl(s)
	}
}

func (s *ValDclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitValDcl(s)
	}
}

func (p *ScalaParser) ValDcl() (localctx IValDclContext) {
	this := p
	_ = this

	localctx = NewValDclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, ScalaParserRULE_valDcl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1142)
		p.Ids()
	}
	{
		p.SetState(1143)
		p.Match(ScalaParserT__18)
	}
	{
		p.SetState(1144)
		p.Type_()
	}

	return localctx
}

// IVarDclContext is an interface to support dynamic dispatch.
type IVarDclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVarDclContext differentiates from other interfaces.
	IsVarDclContext()
}

type VarDclContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVarDclContext() *VarDclContext {
	var p = new(VarDclContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_varDcl
	return p
}

func (*VarDclContext) IsVarDclContext() {}

func NewVarDclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VarDclContext {
	var p = new(VarDclContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_varDcl

	return p
}

func (s *VarDclContext) GetParser() antlr.Parser { return s.parser }

func (s *VarDclContext) Ids() IIdsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdsContext)
}

func (s *VarDclContext) Type_() IType_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *VarDclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VarDclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VarDclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterVarDcl(s)
	}
}

func (s *VarDclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitVarDcl(s)
	}
}

func (p *ScalaParser) VarDcl() (localctx IVarDclContext) {
	this := p
	_ = this

	localctx = NewVarDclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, ScalaParserRULE_varDcl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1146)
		p.Ids()
	}
	{
		p.SetState(1147)
		p.Match(ScalaParserT__18)
	}
	{
		p.SetState(1148)
		p.Type_()
	}

	return localctx
}

// IFunDclContext is an interface to support dynamic dispatch.
type IFunDclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunDclContext differentiates from other interfaces.
	IsFunDclContext()
}

type FunDclContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunDclContext() *FunDclContext {
	var p = new(FunDclContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_funDcl
	return p
}

func (*FunDclContext) IsFunDclContext() {}

func NewFunDclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunDclContext {
	var p = new(FunDclContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_funDcl

	return p
}

func (s *FunDclContext) GetParser() antlr.Parser { return s.parser }

func (s *FunDclContext) FunSig() IFunSigContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunSigContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunSigContext)
}

func (s *FunDclContext) Type_() IType_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *FunDclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunDclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunDclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterFunDcl(s)
	}
}

func (s *FunDclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitFunDcl(s)
	}
}

func (p *ScalaParser) FunDcl() (localctx IFunDclContext) {
	this := p
	_ = this

	localctx = NewFunDclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, ScalaParserRULE_funDcl)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1150)
		p.FunSig()
	}
	p.SetState(1153)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ScalaParserT__18 {
		{
			p.SetState(1151)
			p.Match(ScalaParserT__18)
		}
		{
			p.SetState(1152)
			p.Type_()
		}

	}

	return localctx
}

// IFunSigContext is an interface to support dynamic dispatch.
type IFunSigContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunSigContext differentiates from other interfaces.
	IsFunSigContext()
}

type FunSigContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunSigContext() *FunSigContext {
	var p = new(FunSigContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_funSig
	return p
}

func (*FunSigContext) IsFunSigContext() {}

func NewFunSigContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunSigContext {
	var p = new(FunSigContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_funSig

	return p
}

func (s *FunSigContext) GetParser() antlr.Parser { return s.parser }

func (s *FunSigContext) Id() antlr.TerminalNode {
	return s.GetToken(ScalaParserId, 0)
}

func (s *FunSigContext) ParamClauses() IParamClausesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParamClausesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParamClausesContext)
}

func (s *FunSigContext) FunTypeParamClause() IFunTypeParamClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunTypeParamClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunTypeParamClauseContext)
}

func (s *FunSigContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunSigContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunSigContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterFunSig(s)
	}
}

func (s *FunSigContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitFunSig(s)
	}
}

func (p *ScalaParser) FunSig() (localctx IFunSigContext) {
	this := p
	_ = this

	localctx = NewFunSigContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, ScalaParserRULE_funSig)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1155)
		p.Match(ScalaParserId)
	}
	p.SetState(1157)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ScalaParserT__6 {
		{
			p.SetState(1156)
			p.FunTypeParamClause()
		}

	}
	{
		p.SetState(1159)
		p.ParamClauses()
	}

	return localctx
}

// ITypeDclContext is an interface to support dynamic dispatch.
type ITypeDclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeDclContext differentiates from other interfaces.
	IsTypeDclContext()
}

type TypeDclContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeDclContext() *TypeDclContext {
	var p = new(TypeDclContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_typeDcl
	return p
}

func (*TypeDclContext) IsTypeDclContext() {}

func NewTypeDclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeDclContext {
	var p = new(TypeDclContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_typeDcl

	return p
}

func (s *TypeDclContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeDclContext) Id() antlr.TerminalNode {
	return s.GetToken(ScalaParserId, 0)
}

func (s *TypeDclContext) TypeParamClause() ITypeParamClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeParamClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeParamClauseContext)
}

func (s *TypeDclContext) AllType_() []IType_Context {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IType_Context)(nil)).Elem())
	var tst = make([]IType_Context, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IType_Context)
		}
	}

	return tst
}

func (s *TypeDclContext) Type_(i int) IType_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_Context)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *TypeDclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeDclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeDclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterTypeDcl(s)
	}
}

func (s *TypeDclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitTypeDcl(s)
	}
}

func (p *ScalaParser) TypeDcl() (localctx ITypeDclContext) {
	this := p
	_ = this

	localctx = NewTypeDclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, ScalaParserRULE_typeDcl)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1161)
		p.Match(ScalaParserId)
	}
	p.SetState(1163)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ScalaParserT__6 {
		{
			p.SetState(1162)
			p.TypeParamClause()
		}

	}
	p.SetState(1167)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ScalaParserT__44 {
		{
			p.SetState(1165)
			p.Match(ScalaParserT__44)
		}
		{
			p.SetState(1166)
			p.Type_()
		}

	}
	p.SetState(1171)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ScalaParserT__45 {
		{
			p.SetState(1169)
			p.Match(ScalaParserT__45)
		}
		{
			p.SetState(1170)
			p.Type_()
		}

	}

	return localctx
}

// IPatVarDefContext is an interface to support dynamic dispatch.
type IPatVarDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPatVarDefContext differentiates from other interfaces.
	IsPatVarDefContext()
}

type PatVarDefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPatVarDefContext() *PatVarDefContext {
	var p = new(PatVarDefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_patVarDef
	return p
}

func (*PatVarDefContext) IsPatVarDefContext() {}

func NewPatVarDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PatVarDefContext {
	var p = new(PatVarDefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_patVarDef

	return p
}

func (s *PatVarDefContext) GetParser() antlr.Parser { return s.parser }

func (s *PatVarDefContext) PatDef() IPatDefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPatDefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPatDefContext)
}

func (s *PatVarDefContext) VarDef() IVarDefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVarDefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVarDefContext)
}

func (s *PatVarDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PatVarDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PatVarDefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterPatVarDef(s)
	}
}

func (s *PatVarDefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitPatVarDef(s)
	}
}

func (p *ScalaParser) PatVarDef() (localctx IPatVarDefContext) {
	this := p
	_ = this

	localctx = NewPatVarDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, ScalaParserRULE_patVarDef)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1177)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ScalaParserT__15:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1173)
			p.Match(ScalaParserT__15)
		}
		{
			p.SetState(1174)
			p.PatDef()
		}

	case ScalaParserT__47:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1175)
			p.Match(ScalaParserT__47)
		}
		{
			p.SetState(1176)
			p.VarDef()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDef_Context is an interface to support dynamic dispatch.
type IDef_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDef_Context differentiates from other interfaces.
	IsDef_Context()
}

type Def_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDef_Context() *Def_Context {
	var p = new(Def_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_def_
	return p
}

func (*Def_Context) IsDef_Context() {}

func NewDef_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Def_Context {
	var p = new(Def_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_def_

	return p
}

func (s *Def_Context) GetParser() antlr.Parser { return s.parser }

func (s *Def_Context) PatVarDef() IPatVarDefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPatVarDefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPatVarDefContext)
}

func (s *Def_Context) FunDef() IFunDefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunDefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunDefContext)
}

func (s *Def_Context) TypeDef() ITypeDefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeDefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeDefContext)
}

func (s *Def_Context) AllNL() []antlr.TerminalNode {
	return s.GetTokens(ScalaParserNL)
}

func (s *Def_Context) NL(i int) antlr.TerminalNode {
	return s.GetToken(ScalaParserNL, i)
}

func (s *Def_Context) TmplDef() ITmplDefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITmplDefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITmplDefContext)
}

func (s *Def_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Def_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Def_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterDef_(s)
	}
}

func (s *Def_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitDef_(s)
	}
}

func (p *ScalaParser) Def_() (localctx IDef_Context) {
	this := p
	_ = this

	localctx = NewDef_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, ScalaParserRULE_def_)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1191)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ScalaParserT__15, ScalaParserT__47:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1179)
			p.PatVarDef()
		}

	case ScalaParserT__55:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1180)
			p.Match(ScalaParserT__55)
		}
		{
			p.SetState(1181)
			p.FunDef()
		}

	case ScalaParserT__14:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1182)
			p.Match(ScalaParserT__14)
		}
		p.SetState(1186)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == ScalaParserNL {
			{
				p.SetState(1183)
				p.Match(ScalaParserNL)
			}

			p.SetState(1188)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1189)
			p.TypeDef()
		}

	case ScalaParserT__41, ScalaParserT__56, ScalaParserT__57, ScalaParserT__58:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1190)
			p.TmplDef()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPatDefContext is an interface to support dynamic dispatch.
type IPatDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPatDefContext differentiates from other interfaces.
	IsPatDefContext()
}

type PatDefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPatDefContext() *PatDefContext {
	var p = new(PatDefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_patDef
	return p
}

func (*PatDefContext) IsPatDefContext() {}

func NewPatDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PatDefContext {
	var p = new(PatDefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_patDef

	return p
}

func (s *PatDefContext) GetParser() antlr.Parser { return s.parser }

func (s *PatDefContext) AllPattern2() []IPattern2Context {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPattern2Context)(nil)).Elem())
	var tst = make([]IPattern2Context, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPattern2Context)
		}
	}

	return tst
}

func (s *PatDefContext) Pattern2(i int) IPattern2Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPattern2Context)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPattern2Context)
}

func (s *PatDefContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *PatDefContext) Type_() IType_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *PatDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PatDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PatDefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterPatDef(s)
	}
}

func (s *PatDefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitPatDef(s)
	}
}

func (p *ScalaParser) PatDef() (localctx IPatDefContext) {
	this := p
	_ = this

	localctx = NewPatDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, ScalaParserRULE_patDef)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1193)
		p.Pattern2()
	}
	p.SetState(1198)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ScalaParserT__3 {
		{
			p.SetState(1194)
			p.Match(ScalaParserT__3)
		}
		{
			p.SetState(1195)
			p.Pattern2()
		}

		p.SetState(1200)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1203)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ScalaParserT__18 {
		{
			p.SetState(1201)
			p.Match(ScalaParserT__18)
		}
		{
			p.SetState(1202)
			p.Type_()
		}

	}
	{
		p.SetState(1205)
		p.Match(ScalaParserT__33)
	}
	{
		p.SetState(1206)
		p.Expr()
	}

	return localctx
}

// IVarDefContext is an interface to support dynamic dispatch.
type IVarDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVarDefContext differentiates from other interfaces.
	IsVarDefContext()
}

type VarDefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVarDefContext() *VarDefContext {
	var p = new(VarDefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_varDef
	return p
}

func (*VarDefContext) IsVarDefContext() {}

func NewVarDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VarDefContext {
	var p = new(VarDefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_varDef

	return p
}

func (s *VarDefContext) GetParser() antlr.Parser { return s.parser }

func (s *VarDefContext) PatDef() IPatDefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPatDefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPatDefContext)
}

func (s *VarDefContext) Ids() IIdsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdsContext)
}

func (s *VarDefContext) Type_() IType_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *VarDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VarDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VarDefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterVarDef(s)
	}
}

func (s *VarDefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitVarDef(s)
	}
}

func (p *ScalaParser) VarDef() (localctx IVarDefContext) {
	this := p
	_ = this

	localctx = NewVarDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, ScalaParserRULE_varDef)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1215)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 167, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1208)
			p.PatDef()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1209)
			p.Ids()
		}
		{
			p.SetState(1210)
			p.Match(ScalaParserT__18)
		}
		{
			p.SetState(1211)
			p.Type_()
		}
		{
			p.SetState(1212)
			p.Match(ScalaParserT__33)
		}
		{
			p.SetState(1213)
			p.Match(ScalaParserT__19)
		}

	}

	return localctx
}

// IFunDefContext is an interface to support dynamic dispatch.
type IFunDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunDefContext differentiates from other interfaces.
	IsFunDefContext()
}

type FunDefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunDefContext() *FunDefContext {
	var p = new(FunDefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_funDef
	return p
}

func (*FunDefContext) IsFunDefContext() {}

func NewFunDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunDefContext {
	var p = new(FunDefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_funDef

	return p
}

func (s *FunDefContext) GetParser() antlr.Parser { return s.parser }

func (s *FunDefContext) FunSig() IFunSigContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunSigContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunSigContext)
}

func (s *FunDefContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *FunDefContext) Type_() IType_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *FunDefContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *FunDefContext) NL() antlr.TerminalNode {
	return s.GetToken(ScalaParserNL, 0)
}

func (s *FunDefContext) ParamClause() IParamClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParamClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParamClauseContext)
}

func (s *FunDefContext) ParamClauses() IParamClausesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParamClausesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParamClausesContext)
}

func (s *FunDefContext) ConstrExpr() IConstrExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstrExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstrExprContext)
}

func (s *FunDefContext) ConstrBlock() IConstrBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstrBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstrBlockContext)
}

func (s *FunDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunDefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterFunDef(s)
	}
}

func (s *FunDefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitFunDef(s)
	}
}

func (p *ScalaParser) FunDef() (localctx IFunDefContext) {
	this := p
	_ = this

	localctx = NewFunDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, ScalaParserRULE_funDef)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1244)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 172, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1217)
			p.FunSig()
		}
		p.SetState(1220)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ScalaParserT__18 {
			{
				p.SetState(1218)
				p.Match(ScalaParserT__18)
			}
			{
				p.SetState(1219)
				p.Type_()
			}

		}
		{
			p.SetState(1222)
			p.Match(ScalaParserT__33)
		}
		{
			p.SetState(1223)
			p.Expr()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1225)
			p.FunSig()
		}
		p.SetState(1227)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ScalaParserNL {
			{
				p.SetState(1226)
				p.Match(ScalaParserNL)
			}

		}
		{
			p.SetState(1229)
			p.Match(ScalaParserT__12)
		}
		{
			p.SetState(1230)
			p.Block()
		}
		{
			p.SetState(1231)
			p.Match(ScalaParserT__13)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1233)
			p.Match(ScalaParserT__4)
		}
		{
			p.SetState(1234)
			p.ParamClause()
		}
		{
			p.SetState(1235)
			p.ParamClauses()
		}
		p.SetState(1242)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case ScalaParserT__33:
			{
				p.SetState(1236)
				p.Match(ScalaParserT__33)
			}
			{
				p.SetState(1237)
				p.ConstrExpr()
			}

		case ScalaParserT__12, ScalaParserNL:
			p.SetState(1239)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == ScalaParserNL {
				{
					p.SetState(1238)
					p.Match(ScalaParserNL)
				}

			}
			{
				p.SetState(1241)
				p.ConstrBlock()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	}

	return localctx
}

// ITypeDefContext is an interface to support dynamic dispatch.
type ITypeDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeDefContext differentiates from other interfaces.
	IsTypeDefContext()
}

type TypeDefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeDefContext() *TypeDefContext {
	var p = new(TypeDefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_typeDef
	return p
}

func (*TypeDefContext) IsTypeDefContext() {}

func NewTypeDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeDefContext {
	var p = new(TypeDefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_typeDef

	return p
}

func (s *TypeDefContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeDefContext) Id() antlr.TerminalNode {
	return s.GetToken(ScalaParserId, 0)
}

func (s *TypeDefContext) Type_() IType_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *TypeDefContext) TypeParamClause() ITypeParamClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeParamClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeParamClauseContext)
}

func (s *TypeDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeDefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterTypeDef(s)
	}
}

func (s *TypeDefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitTypeDef(s)
	}
}

func (p *ScalaParser) TypeDef() (localctx ITypeDefContext) {
	this := p
	_ = this

	localctx = NewTypeDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, ScalaParserRULE_typeDef)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1246)
		p.Match(ScalaParserId)
	}
	p.SetState(1248)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ScalaParserT__6 {
		{
			p.SetState(1247)
			p.TypeParamClause()
		}

	}
	{
		p.SetState(1250)
		p.Match(ScalaParserT__33)
	}
	{
		p.SetState(1251)
		p.Type_()
	}

	return localctx
}

// ITmplDefContext is an interface to support dynamic dispatch.
type ITmplDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTmplDefContext differentiates from other interfaces.
	IsTmplDefContext()
}

type TmplDefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTmplDefContext() *TmplDefContext {
	var p = new(TmplDefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_tmplDef
	return p
}

func (*TmplDefContext) IsTmplDefContext() {}

func NewTmplDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TmplDefContext {
	var p = new(TmplDefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_tmplDef

	return p
}

func (s *TmplDefContext) GetParser() antlr.Parser { return s.parser }

func (s *TmplDefContext) ClassDef() IClassDefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassDefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassDefContext)
}

func (s *TmplDefContext) ObjectDef() IObjectDefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectDefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectDefContext)
}

func (s *TmplDefContext) TraitDef() ITraitDefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITraitDefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITraitDefContext)
}

func (s *TmplDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TmplDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TmplDefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterTmplDef(s)
	}
}

func (s *TmplDefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitTmplDef(s)
	}
}

func (p *ScalaParser) TmplDef() (localctx ITmplDefContext) {
	this := p
	_ = this

	localctx = NewTmplDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, ScalaParserRULE_tmplDef)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1265)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 176, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1254)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ScalaParserT__41 {
			{
				p.SetState(1253)
				p.Match(ScalaParserT__41)
			}

		}
		{
			p.SetState(1256)
			p.Match(ScalaParserT__56)
		}
		{
			p.SetState(1257)
			p.ClassDef()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1259)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ScalaParserT__41 {
			{
				p.SetState(1258)
				p.Match(ScalaParserT__41)
			}

		}
		{
			p.SetState(1261)
			p.Match(ScalaParserT__57)
		}
		{
			p.SetState(1262)
			p.ObjectDef()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1263)
			p.Match(ScalaParserT__58)
		}
		{
			p.SetState(1264)
			p.TraitDef()
		}

	}

	return localctx
}

// IClassDefContext is an interface to support dynamic dispatch.
type IClassDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassDefContext differentiates from other interfaces.
	IsClassDefContext()
}

type ClassDefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassDefContext() *ClassDefContext {
	var p = new(ClassDefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_classDef
	return p
}

func (*ClassDefContext) IsClassDefContext() {}

func NewClassDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassDefContext {
	var p = new(ClassDefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_classDef

	return p
}

func (s *ClassDefContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassDefContext) Id() antlr.TerminalNode {
	return s.GetToken(ScalaParserId, 0)
}

func (s *ClassDefContext) ClassParamClauses() IClassParamClausesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassParamClausesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassParamClausesContext)
}

func (s *ClassDefContext) ClassTemplateOpt() IClassTemplateOptContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassTemplateOptContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassTemplateOptContext)
}

func (s *ClassDefContext) TypeParamClause() ITypeParamClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeParamClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeParamClauseContext)
}

func (s *ClassDefContext) AllConstrAnnotation() []IConstrAnnotationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConstrAnnotationContext)(nil)).Elem())
	var tst = make([]IConstrAnnotationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConstrAnnotationContext)
		}
	}

	return tst
}

func (s *ClassDefContext) ConstrAnnotation(i int) IConstrAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstrAnnotationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConstrAnnotationContext)
}

func (s *ClassDefContext) AccessModifier() IAccessModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAccessModifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAccessModifierContext)
}

func (s *ClassDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassDefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterClassDef(s)
	}
}

func (s *ClassDefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitClassDef(s)
	}
}

func (p *ScalaParser) ClassDef() (localctx IClassDefContext) {
	this := p
	_ = this

	localctx = NewClassDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, ScalaParserRULE_classDef)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1267)
		p.Match(ScalaParserId)
	}
	p.SetState(1269)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ScalaParserT__6 {
		{
			p.SetState(1268)
			p.TypeParamClause()
		}

	}
	p.SetState(1274)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 178, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1271)
				p.ConstrAnnotation()
			}

		}
		p.SetState(1276)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 178, p.GetParserRuleContext())
	}
	p.SetState(1278)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 179, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1277)
			p.AccessModifier()
		}

	}
	{
		p.SetState(1280)
		p.ClassParamClauses()
	}
	{
		p.SetState(1281)
		p.ClassTemplateOpt()
	}

	return localctx
}

// ITraitDefContext is an interface to support dynamic dispatch.
type ITraitDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTraitDefContext differentiates from other interfaces.
	IsTraitDefContext()
}

type TraitDefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTraitDefContext() *TraitDefContext {
	var p = new(TraitDefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_traitDef
	return p
}

func (*TraitDefContext) IsTraitDefContext() {}

func NewTraitDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TraitDefContext {
	var p = new(TraitDefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_traitDef

	return p
}

func (s *TraitDefContext) GetParser() antlr.Parser { return s.parser }

func (s *TraitDefContext) Id() antlr.TerminalNode {
	return s.GetToken(ScalaParserId, 0)
}

func (s *TraitDefContext) TraitTemplateOpt() ITraitTemplateOptContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITraitTemplateOptContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITraitTemplateOptContext)
}

func (s *TraitDefContext) TypeParamClause() ITypeParamClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeParamClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeParamClauseContext)
}

func (s *TraitDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TraitDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TraitDefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterTraitDef(s)
	}
}

func (s *TraitDefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitTraitDef(s)
	}
}

func (p *ScalaParser) TraitDef() (localctx ITraitDefContext) {
	this := p
	_ = this

	localctx = NewTraitDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, ScalaParserRULE_traitDef)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1283)
		p.Match(ScalaParserId)
	}
	p.SetState(1285)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ScalaParserT__6 {
		{
			p.SetState(1284)
			p.TypeParamClause()
		}

	}
	{
		p.SetState(1287)
		p.TraitTemplateOpt()
	}

	return localctx
}

// IObjectDefContext is an interface to support dynamic dispatch.
type IObjectDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObjectDefContext differentiates from other interfaces.
	IsObjectDefContext()
}

type ObjectDefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectDefContext() *ObjectDefContext {
	var p = new(ObjectDefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_objectDef
	return p
}

func (*ObjectDefContext) IsObjectDefContext() {}

func NewObjectDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectDefContext {
	var p = new(ObjectDefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_objectDef

	return p
}

func (s *ObjectDefContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectDefContext) Id() antlr.TerminalNode {
	return s.GetToken(ScalaParserId, 0)
}

func (s *ObjectDefContext) ClassTemplateOpt() IClassTemplateOptContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassTemplateOptContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassTemplateOptContext)
}

func (s *ObjectDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectDefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterObjectDef(s)
	}
}

func (s *ObjectDefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitObjectDef(s)
	}
}

func (p *ScalaParser) ObjectDef() (localctx IObjectDefContext) {
	this := p
	_ = this

	localctx = NewObjectDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, ScalaParserRULE_objectDef)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1289)
		p.Match(ScalaParserId)
	}
	{
		p.SetState(1290)
		p.ClassTemplateOpt()
	}

	return localctx
}

// IClassTemplateOptContext is an interface to support dynamic dispatch.
type IClassTemplateOptContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassTemplateOptContext differentiates from other interfaces.
	IsClassTemplateOptContext()
}

type ClassTemplateOptContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassTemplateOptContext() *ClassTemplateOptContext {
	var p = new(ClassTemplateOptContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_classTemplateOpt
	return p
}

func (*ClassTemplateOptContext) IsClassTemplateOptContext() {}

func NewClassTemplateOptContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassTemplateOptContext {
	var p = new(ClassTemplateOptContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_classTemplateOpt

	return p
}

func (s *ClassTemplateOptContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassTemplateOptContext) ClassTemplate() IClassTemplateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassTemplateContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassTemplateContext)
}

func (s *ClassTemplateOptContext) TemplateBody() ITemplateBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITemplateBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITemplateBodyContext)
}

func (s *ClassTemplateOptContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassTemplateOptContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassTemplateOptContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterClassTemplateOpt(s)
	}
}

func (s *ClassTemplateOptContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitClassTemplateOpt(s)
	}
}

func (p *ScalaParser) ClassTemplateOpt() (localctx IClassTemplateOptContext) {
	this := p
	_ = this

	localctx = NewClassTemplateOptContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, ScalaParserRULE_classTemplateOpt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1300)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 183, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1292)
			p.Match(ScalaParserT__59)
		}
		{
			p.SetState(1293)
			p.ClassTemplate()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1298)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 182, p.GetParserRuleContext()) == 1 {
			p.SetState(1295)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == ScalaParserT__59 {
				{
					p.SetState(1294)
					p.Match(ScalaParserT__59)
				}

			}
			{
				p.SetState(1297)
				p.TemplateBody()
			}

		}

	}

	return localctx
}

// ITraitTemplateOptContext is an interface to support dynamic dispatch.
type ITraitTemplateOptContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTraitTemplateOptContext differentiates from other interfaces.
	IsTraitTemplateOptContext()
}

type TraitTemplateOptContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTraitTemplateOptContext() *TraitTemplateOptContext {
	var p = new(TraitTemplateOptContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_traitTemplateOpt
	return p
}

func (*TraitTemplateOptContext) IsTraitTemplateOptContext() {}

func NewTraitTemplateOptContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TraitTemplateOptContext {
	var p = new(TraitTemplateOptContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_traitTemplateOpt

	return p
}

func (s *TraitTemplateOptContext) GetParser() antlr.Parser { return s.parser }

func (s *TraitTemplateOptContext) TraitTemplate() ITraitTemplateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITraitTemplateContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITraitTemplateContext)
}

func (s *TraitTemplateOptContext) TemplateBody() ITemplateBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITemplateBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITemplateBodyContext)
}

func (s *TraitTemplateOptContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TraitTemplateOptContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TraitTemplateOptContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterTraitTemplateOpt(s)
	}
}

func (s *TraitTemplateOptContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitTraitTemplateOpt(s)
	}
}

func (p *ScalaParser) TraitTemplateOpt() (localctx ITraitTemplateOptContext) {
	this := p
	_ = this

	localctx = NewTraitTemplateOptContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, ScalaParserRULE_traitTemplateOpt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1310)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 186, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1302)
			p.Match(ScalaParserT__59)
		}
		{
			p.SetState(1303)
			p.TraitTemplate()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1308)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 185, p.GetParserRuleContext()) == 1 {
			p.SetState(1305)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == ScalaParserT__59 {
				{
					p.SetState(1304)
					p.Match(ScalaParserT__59)
				}

			}
			{
				p.SetState(1307)
				p.TemplateBody()
			}

		}

	}

	return localctx
}

// IClassTemplateContext is an interface to support dynamic dispatch.
type IClassTemplateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassTemplateContext differentiates from other interfaces.
	IsClassTemplateContext()
}

type ClassTemplateContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassTemplateContext() *ClassTemplateContext {
	var p = new(ClassTemplateContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_classTemplate
	return p
}

func (*ClassTemplateContext) IsClassTemplateContext() {}

func NewClassTemplateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassTemplateContext {
	var p = new(ClassTemplateContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_classTemplate

	return p
}

func (s *ClassTemplateContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassTemplateContext) ClassParents() IClassParentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassParentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassParentsContext)
}

func (s *ClassTemplateContext) EarlyDefs() IEarlyDefsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEarlyDefsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEarlyDefsContext)
}

func (s *ClassTemplateContext) TemplateBody() ITemplateBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITemplateBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITemplateBodyContext)
}

func (s *ClassTemplateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassTemplateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassTemplateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterClassTemplate(s)
	}
}

func (s *ClassTemplateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitClassTemplate(s)
	}
}

func (p *ScalaParser) ClassTemplate() (localctx IClassTemplateContext) {
	this := p
	_ = this

	localctx = NewClassTemplateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, ScalaParserRULE_classTemplate)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1313)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ScalaParserT__12 {
		{
			p.SetState(1312)
			p.EarlyDefs()
		}

	}
	{
		p.SetState(1315)
		p.ClassParents()
	}
	p.SetState(1317)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 188, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1316)
			p.TemplateBody()
		}

	}

	return localctx
}

// ITraitTemplateContext is an interface to support dynamic dispatch.
type ITraitTemplateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTraitTemplateContext differentiates from other interfaces.
	IsTraitTemplateContext()
}

type TraitTemplateContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTraitTemplateContext() *TraitTemplateContext {
	var p = new(TraitTemplateContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_traitTemplate
	return p
}

func (*TraitTemplateContext) IsTraitTemplateContext() {}

func NewTraitTemplateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TraitTemplateContext {
	var p = new(TraitTemplateContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_traitTemplate

	return p
}

func (s *TraitTemplateContext) GetParser() antlr.Parser { return s.parser }

func (s *TraitTemplateContext) TraitParents() ITraitParentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITraitParentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITraitParentsContext)
}

func (s *TraitTemplateContext) EarlyDefs() IEarlyDefsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEarlyDefsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEarlyDefsContext)
}

func (s *TraitTemplateContext) TemplateBody() ITemplateBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITemplateBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITemplateBodyContext)
}

func (s *TraitTemplateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TraitTemplateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TraitTemplateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterTraitTemplate(s)
	}
}

func (s *TraitTemplateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitTraitTemplate(s)
	}
}

func (p *ScalaParser) TraitTemplate() (localctx ITraitTemplateContext) {
	this := p
	_ = this

	localctx = NewTraitTemplateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, ScalaParserRULE_traitTemplate)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1320)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ScalaParserT__12 {
		{
			p.SetState(1319)
			p.EarlyDefs()
		}

	}
	{
		p.SetState(1322)
		p.TraitParents()
	}
	p.SetState(1324)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 190, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1323)
			p.TemplateBody()
		}

	}

	return localctx
}

// IClassParentsContext is an interface to support dynamic dispatch.
type IClassParentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassParentsContext differentiates from other interfaces.
	IsClassParentsContext()
}

type ClassParentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassParentsContext() *ClassParentsContext {
	var p = new(ClassParentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_classParents
	return p
}

func (*ClassParentsContext) IsClassParentsContext() {}

func NewClassParentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassParentsContext {
	var p = new(ClassParentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_classParents

	return p
}

func (s *ClassParentsContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassParentsContext) Constr() IConstrContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstrContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstrContext)
}

func (s *ClassParentsContext) AllAnnotType() []IAnnotTypeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotTypeContext)(nil)).Elem())
	var tst = make([]IAnnotTypeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotTypeContext)
		}
	}

	return tst
}

func (s *ClassParentsContext) AnnotType(i int) IAnnotTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotTypeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotTypeContext)
}

func (s *ClassParentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassParentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassParentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterClassParents(s)
	}
}

func (s *ClassParentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitClassParents(s)
	}
}

func (p *ScalaParser) ClassParents() (localctx IClassParentsContext) {
	this := p
	_ = this

	localctx = NewClassParentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, ScalaParserRULE_classParents)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1326)
		p.Constr()
	}
	p.SetState(1331)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 191, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1327)
				p.Match(ScalaParserT__16)
			}
			{
				p.SetState(1328)
				p.AnnotType()
			}

		}
		p.SetState(1333)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 191, p.GetParserRuleContext())
	}

	return localctx
}

// ITraitParentsContext is an interface to support dynamic dispatch.
type ITraitParentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTraitParentsContext differentiates from other interfaces.
	IsTraitParentsContext()
}

type TraitParentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTraitParentsContext() *TraitParentsContext {
	var p = new(TraitParentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_traitParents
	return p
}

func (*TraitParentsContext) IsTraitParentsContext() {}

func NewTraitParentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TraitParentsContext {
	var p = new(TraitParentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_traitParents

	return p
}

func (s *TraitParentsContext) GetParser() antlr.Parser { return s.parser }

func (s *TraitParentsContext) AllAnnotType() []IAnnotTypeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotTypeContext)(nil)).Elem())
	var tst = make([]IAnnotTypeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotTypeContext)
		}
	}

	return tst
}

func (s *TraitParentsContext) AnnotType(i int) IAnnotTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotTypeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotTypeContext)
}

func (s *TraitParentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TraitParentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TraitParentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterTraitParents(s)
	}
}

func (s *TraitParentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitTraitParents(s)
	}
}

func (p *ScalaParser) TraitParents() (localctx ITraitParentsContext) {
	this := p
	_ = this

	localctx = NewTraitParentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, ScalaParserRULE_traitParents)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1334)
		p.AnnotType()
	}
	p.SetState(1339)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ScalaParserT__16 {
		{
			p.SetState(1335)
			p.Match(ScalaParserT__16)
		}
		{
			p.SetState(1336)
			p.AnnotType()
		}

		p.SetState(1341)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IConstrContext is an interface to support dynamic dispatch.
type IConstrContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstrContext differentiates from other interfaces.
	IsConstrContext()
}

type ConstrContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstrContext() *ConstrContext {
	var p = new(ConstrContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_constr
	return p
}

func (*ConstrContext) IsConstrContext() {}

func NewConstrContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstrContext {
	var p = new(ConstrContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_constr

	return p
}

func (s *ConstrContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstrContext) AnnotType() IAnnotTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotTypeContext)
}

func (s *ConstrContext) AllArgumentExprs() []IArgumentExprsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IArgumentExprsContext)(nil)).Elem())
	var tst = make([]IArgumentExprsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IArgumentExprsContext)
		}
	}

	return tst
}

func (s *ConstrContext) ArgumentExprs(i int) IArgumentExprsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentExprsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IArgumentExprsContext)
}

func (s *ConstrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstrContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterConstr(s)
	}
}

func (s *ConstrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitConstr(s)
	}
}

func (p *ScalaParser) Constr() (localctx IConstrContext) {
	this := p
	_ = this

	localctx = NewConstrContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, ScalaParserRULE_constr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1342)
		p.AnnotType()
	}
	p.SetState(1346)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 193, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1343)
				p.ArgumentExprs()
			}

		}
		p.SetState(1348)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 193, p.GetParserRuleContext())
	}

	return localctx
}

// IEarlyDefsContext is an interface to support dynamic dispatch.
type IEarlyDefsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEarlyDefsContext differentiates from other interfaces.
	IsEarlyDefsContext()
}

type EarlyDefsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEarlyDefsContext() *EarlyDefsContext {
	var p = new(EarlyDefsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_earlyDefs
	return p
}

func (*EarlyDefsContext) IsEarlyDefsContext() {}

func NewEarlyDefsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EarlyDefsContext {
	var p = new(EarlyDefsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_earlyDefs

	return p
}

func (s *EarlyDefsContext) GetParser() antlr.Parser { return s.parser }

func (s *EarlyDefsContext) AllEarlyDef() []IEarlyDefContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEarlyDefContext)(nil)).Elem())
	var tst = make([]IEarlyDefContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEarlyDefContext)
		}
	}

	return tst
}

func (s *EarlyDefsContext) EarlyDef(i int) IEarlyDefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEarlyDefContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEarlyDefContext)
}

func (s *EarlyDefsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EarlyDefsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EarlyDefsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterEarlyDefs(s)
	}
}

func (s *EarlyDefsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitEarlyDefs(s)
	}
}

func (p *ScalaParser) EarlyDefs() (localctx IEarlyDefsContext) {
	this := p
	_ = this

	localctx = NewEarlyDefsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, ScalaParserRULE_earlyDefs)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1349)
		p.Match(ScalaParserT__12)
	}
	p.SetState(1351)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == ScalaParserT__15 || _la == ScalaParserT__21 || (((_la-40)&-(0x1f+1)) == 0 && ((1<<uint((_la-40)))&((1<<(ScalaParserT__39-40))|(1<<(ScalaParserT__43-40))|(1<<(ScalaParserT__47-40))|(1<<(ScalaParserT__48-40))|(1<<(ScalaParserT__49-40))|(1<<(ScalaParserT__50-40))|(1<<(ScalaParserT__51-40))|(1<<(ScalaParserT__52-40))|(1<<(ScalaParserT__53-40)))) != 0) {
		{
			p.SetState(1350)
			p.EarlyDef()
		}

		p.SetState(1353)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1355)
		p.Match(ScalaParserT__13)
	}
	{
		p.SetState(1356)
		p.Match(ScalaParserT__16)
	}

	return localctx
}

// IEarlyDefContext is an interface to support dynamic dispatch.
type IEarlyDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEarlyDefContext differentiates from other interfaces.
	IsEarlyDefContext()
}

type EarlyDefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEarlyDefContext() *EarlyDefContext {
	var p = new(EarlyDefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_earlyDef
	return p
}

func (*EarlyDefContext) IsEarlyDefContext() {}

func NewEarlyDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EarlyDefContext {
	var p = new(EarlyDefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_earlyDef

	return p
}

func (s *EarlyDefContext) GetParser() antlr.Parser { return s.parser }

func (s *EarlyDefContext) PatVarDef() IPatVarDefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPatVarDefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPatVarDefContext)
}

func (s *EarlyDefContext) AllAnnotation() []IAnnotationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotationContext)(nil)).Elem())
	var tst = make([]IAnnotationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotationContext)
		}
	}

	return tst
}

func (s *EarlyDefContext) Annotation(i int) IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *EarlyDefContext) AllModifier() []IModifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IModifierContext)(nil)).Elem())
	var tst = make([]IModifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IModifierContext)
		}
	}

	return tst
}

func (s *EarlyDefContext) Modifier(i int) IModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IModifierContext)
}

func (s *EarlyDefContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(ScalaParserNL)
}

func (s *EarlyDefContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(ScalaParserNL, i)
}

func (s *EarlyDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EarlyDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EarlyDefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterEarlyDef(s)
	}
}

func (s *EarlyDefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitEarlyDef(s)
	}
}

func (p *ScalaParser) EarlyDef() (localctx IEarlyDefContext) {
	this := p
	_ = this

	localctx = NewEarlyDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, ScalaParserRULE_earlyDef)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1364)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ScalaParserT__43 {
		{
			p.SetState(1358)
			p.Annotation()
		}
		p.SetState(1360)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ScalaParserNL {
			{
				p.SetState(1359)
				p.Match(ScalaParserNL)
			}

		}

		p.SetState(1366)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1370)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ScalaParserT__21 || (((_la-40)&-(0x1f+1)) == 0 && ((1<<uint((_la-40)))&((1<<(ScalaParserT__39-40))|(1<<(ScalaParserT__48-40))|(1<<(ScalaParserT__49-40))|(1<<(ScalaParserT__50-40))|(1<<(ScalaParserT__51-40))|(1<<(ScalaParserT__52-40))|(1<<(ScalaParserT__53-40)))) != 0) {
		{
			p.SetState(1367)
			p.Modifier()
		}

		p.SetState(1372)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1373)
		p.PatVarDef()
	}

	return localctx
}

// IConstrExprContext is an interface to support dynamic dispatch.
type IConstrExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstrExprContext differentiates from other interfaces.
	IsConstrExprContext()
}

type ConstrExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstrExprContext() *ConstrExprContext {
	var p = new(ConstrExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_constrExpr
	return p
}

func (*ConstrExprContext) IsConstrExprContext() {}

func NewConstrExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstrExprContext {
	var p = new(ConstrExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_constrExpr

	return p
}

func (s *ConstrExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstrExprContext) SelfInvocation() ISelfInvocationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelfInvocationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelfInvocationContext)
}

func (s *ConstrExprContext) ConstrBlock() IConstrBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstrBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstrBlockContext)
}

func (s *ConstrExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstrExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstrExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterConstrExpr(s)
	}
}

func (s *ConstrExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitConstrExpr(s)
	}
}

func (p *ScalaParser) ConstrExpr() (localctx IConstrExprContext) {
	this := p
	_ = this

	localctx = NewConstrExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, ScalaParserRULE_constrExpr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1377)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ScalaParserT__4:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1375)
			p.SelfInvocation()
		}

	case ScalaParserT__12:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1376)
			p.ConstrBlock()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IConstrBlockContext is an interface to support dynamic dispatch.
type IConstrBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstrBlockContext differentiates from other interfaces.
	IsConstrBlockContext()
}

type ConstrBlockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstrBlockContext() *ConstrBlockContext {
	var p = new(ConstrBlockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_constrBlock
	return p
}

func (*ConstrBlockContext) IsConstrBlockContext() {}

func NewConstrBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstrBlockContext {
	var p = new(ConstrBlockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_constrBlock

	return p
}

func (s *ConstrBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstrBlockContext) SelfInvocation() ISelfInvocationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelfInvocationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelfInvocationContext)
}

func (s *ConstrBlockContext) AllBlockStat() []IBlockStatContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBlockStatContext)(nil)).Elem())
	var tst = make([]IBlockStatContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBlockStatContext)
		}
	}

	return tst
}

func (s *ConstrBlockContext) BlockStat(i int) IBlockStatContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockStatContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBlockStatContext)
}

func (s *ConstrBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstrBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstrBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterConstrBlock(s)
	}
}

func (s *ConstrBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitConstrBlock(s)
	}
}

func (p *ScalaParser) ConstrBlock() (localctx IConstrBlockContext) {
	this := p
	_ = this

	localctx = NewConstrBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, ScalaParserRULE_constrBlock)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1379)
		p.Match(ScalaParserT__12)
	}
	{
		p.SetState(1380)
		p.SelfInvocation()
	}
	p.SetState(1384)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ScalaParserT__0)|(1<<ScalaParserT__1)|(1<<ScalaParserT__4)|(1<<ScalaParserT__5)|(1<<ScalaParserT__9)|(1<<ScalaParserT__12)|(1<<ScalaParserT__14)|(1<<ScalaParserT__15)|(1<<ScalaParserT__19)|(1<<ScalaParserT__21)|(1<<ScalaParserT__22)|(1<<ScalaParserT__24)|(1<<ScalaParserT__25)|(1<<ScalaParserT__28)|(1<<ScalaParserT__29))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(ScalaParserT__31-32))|(1<<(ScalaParserT__32-32))|(1<<(ScalaParserT__35-32))|(1<<(ScalaParserT__36-32))|(1<<(ScalaParserT__37-32))|(1<<(ScalaParserT__38-32))|(1<<(ScalaParserT__39-32))|(1<<(ScalaParserT__41-32))|(1<<(ScalaParserT__43-32))|(1<<(ScalaParserT__47-32))|(1<<(ScalaParserT__49-32))|(1<<(ScalaParserT__50-32))|(1<<(ScalaParserT__51-32))|(1<<(ScalaParserT__54-32))|(1<<(ScalaParserT__55-32))|(1<<(ScalaParserT__56-32))|(1<<(ScalaParserT__57-32))|(1<<(ScalaParserT__58-32))|(1<<(ScalaParserId-32))|(1<<(ScalaParserBooleanLiteral-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(ScalaParserCharacterLiteral-64))|(1<<(ScalaParserSymbolLiteral-64))|(1<<(ScalaParserIntegerLiteral-64))|(1<<(ScalaParserStringLiteral-64))|(1<<(ScalaParserFloatingPointLiteral-64)))) != 0) {
		{
			p.SetState(1381)
			p.BlockStat()
		}

		p.SetState(1386)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1387)
		p.Match(ScalaParserT__13)
	}

	return localctx
}

// ISelfInvocationContext is an interface to support dynamic dispatch.
type ISelfInvocationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelfInvocationContext differentiates from other interfaces.
	IsSelfInvocationContext()
}

type SelfInvocationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelfInvocationContext() *SelfInvocationContext {
	var p = new(SelfInvocationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_selfInvocation
	return p
}

func (*SelfInvocationContext) IsSelfInvocationContext() {}

func NewSelfInvocationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelfInvocationContext {
	var p = new(SelfInvocationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_selfInvocation

	return p
}

func (s *SelfInvocationContext) GetParser() antlr.Parser { return s.parser }

func (s *SelfInvocationContext) AllArgumentExprs() []IArgumentExprsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IArgumentExprsContext)(nil)).Elem())
	var tst = make([]IArgumentExprsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IArgumentExprsContext)
		}
	}

	return tst
}

func (s *SelfInvocationContext) ArgumentExprs(i int) IArgumentExprsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentExprsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IArgumentExprsContext)
}

func (s *SelfInvocationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelfInvocationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelfInvocationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterSelfInvocation(s)
	}
}

func (s *SelfInvocationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitSelfInvocation(s)
	}
}

func (p *ScalaParser) SelfInvocation() (localctx ISelfInvocationContext) {
	this := p
	_ = this

	localctx = NewSelfInvocationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, ScalaParserRULE_selfInvocation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1389)
		p.Match(ScalaParserT__4)
	}
	p.SetState(1391)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1390)
				p.ArgumentExprs()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(1393)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 200, p.GetParserRuleContext())
	}

	return localctx
}

// ITopStatSeqContext is an interface to support dynamic dispatch.
type ITopStatSeqContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTopStatSeqContext differentiates from other interfaces.
	IsTopStatSeqContext()
}

type TopStatSeqContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTopStatSeqContext() *TopStatSeqContext {
	var p = new(TopStatSeqContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_topStatSeq
	return p
}

func (*TopStatSeqContext) IsTopStatSeqContext() {}

func NewTopStatSeqContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TopStatSeqContext {
	var p = new(TopStatSeqContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_topStatSeq

	return p
}

func (s *TopStatSeqContext) GetParser() antlr.Parser { return s.parser }

func (s *TopStatSeqContext) AllTopStat() []ITopStatContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITopStatContext)(nil)).Elem())
	var tst = make([]ITopStatContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITopStatContext)
		}
	}

	return tst
}

func (s *TopStatSeqContext) TopStat(i int) ITopStatContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITopStatContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITopStatContext)
}

func (s *TopStatSeqContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TopStatSeqContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TopStatSeqContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterTopStatSeq(s)
	}
}

func (s *TopStatSeqContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitTopStatSeq(s)
	}
}

func (p *ScalaParser) TopStatSeq() (localctx ITopStatSeqContext) {
	this := p
	_ = this

	localctx = NewTopStatSeqContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, ScalaParserRULE_topStatSeq)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1396)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == ScalaParserT__21 || (((_la-40)&-(0x1f+1)) == 0 && ((1<<uint((_la-40)))&((1<<(ScalaParserT__39-40))|(1<<(ScalaParserT__41-40))|(1<<(ScalaParserT__43-40))|(1<<(ScalaParserT__48-40))|(1<<(ScalaParserT__49-40))|(1<<(ScalaParserT__50-40))|(1<<(ScalaParserT__51-40))|(1<<(ScalaParserT__52-40))|(1<<(ScalaParserT__53-40))|(1<<(ScalaParserT__54-40))|(1<<(ScalaParserT__56-40))|(1<<(ScalaParserT__57-40))|(1<<(ScalaParserT__58-40))|(1<<(ScalaParserT__60-40)))) != 0) {
		{
			p.SetState(1395)
			p.TopStat()
		}

		p.SetState(1398)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ITopStatContext is an interface to support dynamic dispatch.
type ITopStatContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTopStatContext differentiates from other interfaces.
	IsTopStatContext()
}

type TopStatContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTopStatContext() *TopStatContext {
	var p = new(TopStatContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_topStat
	return p
}

func (*TopStatContext) IsTopStatContext() {}

func NewTopStatContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TopStatContext {
	var p = new(TopStatContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_topStat

	return p
}

func (s *TopStatContext) GetParser() antlr.Parser { return s.parser }

func (s *TopStatContext) TmplDef() ITmplDefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITmplDefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITmplDefContext)
}

func (s *TopStatContext) AllAnnotation() []IAnnotationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotationContext)(nil)).Elem())
	var tst = make([]IAnnotationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotationContext)
		}
	}

	return tst
}

func (s *TopStatContext) Annotation(i int) IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *TopStatContext) AllModifier() []IModifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IModifierContext)(nil)).Elem())
	var tst = make([]IModifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IModifierContext)
		}
	}

	return tst
}

func (s *TopStatContext) Modifier(i int) IModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IModifierContext)
}

func (s *TopStatContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(ScalaParserNL)
}

func (s *TopStatContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(ScalaParserNL, i)
}

func (s *TopStatContext) Import_() IImport_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImport_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImport_Context)
}

func (s *TopStatContext) Packaging() IPackagingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackagingContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPackagingContext)
}

func (s *TopStatContext) PackageObject() IPackageObjectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackageObjectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPackageObjectContext)
}

func (s *TopStatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TopStatContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TopStatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterTopStat(s)
	}
}

func (s *TopStatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitTopStat(s)
	}
}

func (p *ScalaParser) TopStat() (localctx ITopStatContext) {
	this := p
	_ = this

	localctx = NewTopStatContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, ScalaParserRULE_topStat)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1419)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 205, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1406)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == ScalaParserT__43 {
			{
				p.SetState(1400)
				p.Annotation()
			}
			p.SetState(1402)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == ScalaParserNL {
				{
					p.SetState(1401)
					p.Match(ScalaParserNL)
				}

			}

			p.SetState(1408)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(1412)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == ScalaParserT__21 || (((_la-40)&-(0x1f+1)) == 0 && ((1<<uint((_la-40)))&((1<<(ScalaParserT__39-40))|(1<<(ScalaParserT__48-40))|(1<<(ScalaParserT__49-40))|(1<<(ScalaParserT__50-40))|(1<<(ScalaParserT__51-40))|(1<<(ScalaParserT__52-40))|(1<<(ScalaParserT__53-40)))) != 0) {
			{
				p.SetState(1409)
				p.Modifier()
			}

			p.SetState(1414)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1415)
			p.TmplDef()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1416)
			p.Import_()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1417)
			p.Packaging()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1418)
			p.PackageObject()
		}

	}

	return localctx
}

// IPackagingContext is an interface to support dynamic dispatch.
type IPackagingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPackagingContext differentiates from other interfaces.
	IsPackagingContext()
}

type PackagingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackagingContext() *PackagingContext {
	var p = new(PackagingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_packaging
	return p
}

func (*PackagingContext) IsPackagingContext() {}

func NewPackagingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PackagingContext {
	var p = new(PackagingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_packaging

	return p
}

func (s *PackagingContext) GetParser() antlr.Parser { return s.parser }

func (s *PackagingContext) QualId() IQualIdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualIdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualIdContext)
}

func (s *PackagingContext) TopStatSeq() ITopStatSeqContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITopStatSeqContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITopStatSeqContext)
}

func (s *PackagingContext) NL() antlr.TerminalNode {
	return s.GetToken(ScalaParserNL, 0)
}

func (s *PackagingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PackagingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PackagingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterPackaging(s)
	}
}

func (s *PackagingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitPackaging(s)
	}
}

func (p *ScalaParser) Packaging() (localctx IPackagingContext) {
	this := p
	_ = this

	localctx = NewPackagingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, ScalaParserRULE_packaging)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1421)
		p.Match(ScalaParserT__60)
	}
	{
		p.SetState(1422)
		p.QualId()
	}
	p.SetState(1424)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ScalaParserNL {
		{
			p.SetState(1423)
			p.Match(ScalaParserNL)
		}

	}
	{
		p.SetState(1426)
		p.Match(ScalaParserT__12)
	}
	{
		p.SetState(1427)
		p.TopStatSeq()
	}
	{
		p.SetState(1428)
		p.Match(ScalaParserT__13)
	}

	return localctx
}

// IPackageObjectContext is an interface to support dynamic dispatch.
type IPackageObjectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPackageObjectContext differentiates from other interfaces.
	IsPackageObjectContext()
}

type PackageObjectContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackageObjectContext() *PackageObjectContext {
	var p = new(PackageObjectContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_packageObject
	return p
}

func (*PackageObjectContext) IsPackageObjectContext() {}

func NewPackageObjectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PackageObjectContext {
	var p = new(PackageObjectContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_packageObject

	return p
}

func (s *PackageObjectContext) GetParser() antlr.Parser { return s.parser }

func (s *PackageObjectContext) ObjectDef() IObjectDefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectDefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectDefContext)
}

func (s *PackageObjectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PackageObjectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PackageObjectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterPackageObject(s)
	}
}

func (s *PackageObjectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitPackageObject(s)
	}
}

func (p *ScalaParser) PackageObject() (localctx IPackageObjectContext) {
	this := p
	_ = this

	localctx = NewPackageObjectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, ScalaParserRULE_packageObject)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1430)
		p.Match(ScalaParserT__60)
	}
	{
		p.SetState(1431)
		p.Match(ScalaParserT__57)
	}
	{
		p.SetState(1432)
		p.ObjectDef()
	}

	return localctx
}

// ICompilationUnitContext is an interface to support dynamic dispatch.
type ICompilationUnitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCompilationUnitContext differentiates from other interfaces.
	IsCompilationUnitContext()
}

type CompilationUnitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompilationUnitContext() *CompilationUnitContext {
	var p = new(CompilationUnitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ScalaParserRULE_compilationUnit
	return p
}

func (*CompilationUnitContext) IsCompilationUnitContext() {}

func NewCompilationUnitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompilationUnitContext {
	var p = new(CompilationUnitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ScalaParserRULE_compilationUnit

	return p
}

func (s *CompilationUnitContext) GetParser() antlr.Parser { return s.parser }

func (s *CompilationUnitContext) TopStatSeq() ITopStatSeqContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITopStatSeqContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITopStatSeqContext)
}

func (s *CompilationUnitContext) AllQualId() []IQualIdContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IQualIdContext)(nil)).Elem())
	var tst = make([]IQualIdContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IQualIdContext)
		}
	}

	return tst
}

func (s *CompilationUnitContext) QualId(i int) IQualIdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualIdContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IQualIdContext)
}

func (s *CompilationUnitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompilationUnitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompilationUnitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.EnterCompilationUnit(s)
	}
}

func (s *CompilationUnitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ScalaListener); ok {
		listenerT.ExitCompilationUnit(s)
	}
}

func (p *ScalaParser) CompilationUnit() (localctx ICompilationUnitContext) {
	this := p
	_ = this

	localctx = NewCompilationUnitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, ScalaParserRULE_compilationUnit)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1438)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 207, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1434)
				p.Match(ScalaParserT__60)
			}
			{
				p.SetState(1435)
				p.QualId()
			}

		}
		p.SetState(1440)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 207, p.GetParserRuleContext())
	}
	{
		p.SetState(1441)
		p.TopStatSeq()
	}

	return localctx
}

func (p *ScalaParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 3:
		var t *StableIdContext = nil
		if localctx != nil {
			t = localctx.(*StableIdContext)
		}
		return p.StableId_Sempred(t, predIndex)

	case 12:
		var t *SimpleTypeContext = nil
		if localctx != nil {
			t = localctx.(*SimpleTypeContext)
		}
		return p.SimpleType_Sempred(t, predIndex)

	case 23:
		var t *InfixExprContext = nil
		if localctx != nil {
			t = localctx.(*InfixExprContext)
		}
		return p.InfixExpr_Sempred(t, predIndex)

	case 26:
		var t *SimpleExpr1Context = nil
		if localctx != nil {
			t = localctx.(*SimpleExpr1Context)
		}
		return p.SimpleExpr1_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *ScalaParser) StableId_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *ScalaParser) SimpleType_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 1:
		return p.Precpred(p.GetParserRuleContext(), 4)

	case 2:
		return p.Precpred(p.GetParserRuleContext(), 3)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *ScalaParser) InfixExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 3:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *ScalaParser) SimpleExpr1_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 4:
		return p.Precpred(p.GetParserRuleContext(), 4)

	case 5:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 6:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
