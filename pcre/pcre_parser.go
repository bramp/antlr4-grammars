// Code generated from PCRE.g4 by ANTLR 4.9.3. DO NOT EDIT.

package pcre // PCRE
import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 127, 931,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 3, 2, 3,
	2, 3, 2, 3, 3, 3, 3, 3, 3, 7, 3, 83, 10, 3, 12, 3, 14, 3, 86, 11, 3, 3,
	4, 7, 4, 89, 10, 4, 12, 4, 14, 4, 92, 11, 4, 3, 5, 3, 5, 5, 5, 96, 10,
	5, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3,
	6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3,
	6, 5, 6, 122, 10, 6, 3, 7, 3, 7, 3, 7, 5, 7, 127, 10, 7, 3, 8, 3, 8, 3,
	8, 3, 8, 3, 8, 6, 8, 134, 10, 8, 13, 8, 14, 8, 135, 3, 8, 3, 8, 3, 8, 3,
	8, 3, 8, 3, 8, 7, 8, 144, 10, 8, 12, 8, 14, 8, 147, 11, 8, 3, 8, 3, 8,
	3, 8, 3, 8, 6, 8, 153, 10, 8, 13, 8, 14, 8, 154, 3, 8, 3, 8, 3, 8, 3, 8,
	3, 8, 3, 8, 6, 8, 163, 10, 8, 13, 8, 14, 8, 164, 3, 8, 3, 8, 3, 8, 3, 8,
	3, 8, 7, 8, 172, 10, 8, 12, 8, 14, 8, 175, 11, 8, 3, 8, 3, 8, 3, 8, 6,
	8, 180, 10, 8, 13, 8, 14, 8, 181, 3, 8, 3, 8, 5, 8, 186, 10, 8, 3, 9, 3,
	9, 3, 9, 3, 9, 3, 9, 3, 9, 3, 9, 3, 9, 3, 9, 3, 9, 3, 9, 3, 9, 3, 9, 3,
	9, 3, 9, 3, 9, 3, 9, 3, 9, 3, 9, 3, 9, 3, 9, 3, 9, 3, 9, 3, 9, 3, 9, 3,
	9, 3, 9, 3, 9, 3, 9, 3, 9, 3, 9, 3, 9, 3, 9, 3, 9, 3, 9, 3, 9, 3, 9, 3,
	9, 3, 9, 3, 9, 3, 9, 5, 9, 229, 10, 9, 3, 10, 3, 10, 3, 10, 5, 10, 234,
	10, 10, 3, 11, 3, 11, 3, 11, 3, 11, 3, 11, 3, 11, 3, 11, 3, 11, 3, 11,
	3, 11, 3, 11, 3, 11, 3, 11, 3, 11, 3, 11, 3, 11, 3, 11, 3, 11, 3, 11, 3,
	11, 3, 11, 3, 11, 3, 11, 3, 11, 3, 11, 3, 11, 3, 11, 3, 11, 3, 11, 5, 11,
	265, 10, 11, 3, 12, 3, 12, 3, 12, 3, 12, 3, 12, 3, 12, 3, 12, 3, 12, 3,
	12, 3, 12, 3, 12, 3, 12, 3, 12, 3, 12, 3, 12, 3, 12, 3, 12, 3, 12, 3, 12,
	3, 12, 3, 12, 3, 12, 3, 12, 3, 12, 3, 12, 5, 12, 292, 10, 12, 3, 13, 3,
	13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14,
	3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3,
	14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14,
	3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3,
	14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14,
	3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 5, 14, 354, 10, 14, 3, 15, 6,
	15, 357, 10, 15, 13, 15, 14, 15, 358, 3, 16, 3, 16, 3, 17, 3, 17, 3, 17,
	3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3,
	17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17,
	3, 17, 3, 17, 5, 17, 389, 10, 17, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 3,
	18, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18,
	3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 3,
	18, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18,
	3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 3,
	18, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18,
	3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 3,
	18, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 5, 18,
	469, 10, 18, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 5,
	19, 479, 10, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19,
	3, 19, 3, 19, 3, 19, 5, 19, 492, 10, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3,
	19, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 5, 19, 505, 10, 19, 3, 19,
	3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3,
	19, 5, 19, 519, 10, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19,
	3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 5, 19, 533, 10, 19, 3, 19, 3, 19, 3,
	19, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 5, 19, 546,
	10, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19,
	3, 19, 5, 19, 558, 10, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3,
	19, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 5, 19, 572, 10, 19, 3, 19, 3, 19,
	3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3,
	19, 3, 19, 3, 19, 5, 19, 589, 10, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19,
	3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 5,
	19, 606, 10, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19,
	3, 19, 3, 19, 5, 19, 618, 10, 19, 3, 19, 3, 19, 5, 19, 622, 10, 19, 3,
	20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20,
	3, 20, 3, 20, 3, 20, 3, 20, 5, 20, 639, 10, 20, 3, 20, 3, 20, 3, 20, 3,
	20, 3, 20, 3, 20, 3, 20, 5, 20, 648, 10, 20, 3, 20, 3, 20, 3, 20, 3, 20,
	3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3,
	20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20,
	3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3,
	20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20,
	3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3,
	20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20,
	3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 5, 20, 724, 10, 20, 3,
	21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21,
	3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3,
	21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21,
	3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3,
	21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21,
	3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 5, 21, 787, 10,
	21, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22,
	5, 22, 799, 10, 22, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3,
	23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23,
	3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 5, 23, 827, 10,
	23, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24, 5, 24, 836, 10, 24,
	3, 25, 3, 25, 3, 26, 3, 26, 5, 26, 842, 10, 26, 3, 27, 3, 27, 3, 27, 3,
	27, 3, 27, 3, 27, 3, 27, 3, 27, 3, 27, 3, 27, 3, 27, 3, 27, 5, 27, 856,
	10, 27, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28,
	3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3,
	28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 5, 28, 884, 10, 28, 3, 29,
	3, 29, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 5,
	30, 897, 10, 30, 3, 31, 3, 31, 3, 32, 6, 32, 902, 10, 32, 13, 32, 14, 32,
	903, 3, 33, 3, 33, 3, 34, 3, 34, 3, 35, 3, 35, 5, 35, 912, 10, 35, 3, 35,
	3, 35, 3, 35, 7, 35, 917, 10, 35, 12, 35, 14, 35, 920, 11, 35, 3, 36, 6,
	36, 923, 10, 36, 13, 36, 14, 36, 924, 3, 37, 3, 37, 3, 38, 3, 38, 3, 38,
	2, 2, 39, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34,
	36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70,
	72, 74, 2, 9, 8, 2, 73, 73, 77, 77, 83, 83, 88, 88, 100, 100, 111, 111,
	5, 2, 6, 6, 16, 29, 35, 36, 4, 2, 117, 119, 126, 126, 4, 2, 117, 123, 126,
	126, 3, 2, 117, 126, 3, 2, 55, 55, 3, 2, 65, 116, 2, 1063, 2, 76, 3, 2,
	2, 2, 4, 79, 3, 2, 2, 2, 6, 90, 3, 2, 2, 2, 8, 93, 3, 2, 2, 2, 10, 121,
	3, 2, 2, 2, 12, 126, 3, 2, 2, 2, 14, 185, 3, 2, 2, 2, 16, 228, 3, 2, 2,
	2, 18, 233, 3, 2, 2, 2, 20, 264, 3, 2, 2, 2, 22, 291, 3, 2, 2, 2, 24, 293,
	3, 2, 2, 2, 26, 353, 3, 2, 2, 2, 28, 356, 3, 2, 2, 2, 30, 360, 3, 2, 2,
	2, 32, 388, 3, 2, 2, 2, 34, 468, 3, 2, 2, 2, 36, 621, 3, 2, 2, 2, 38, 723,
	3, 2, 2, 2, 40, 786, 3, 2, 2, 2, 42, 798, 3, 2, 2, 2, 44, 826, 3, 2, 2,
	2, 46, 835, 3, 2, 2, 2, 48, 837, 3, 2, 2, 2, 50, 841, 3, 2, 2, 2, 52, 855,
	3, 2, 2, 2, 54, 883, 3, 2, 2, 2, 56, 885, 3, 2, 2, 2, 58, 896, 3, 2, 2,
	2, 60, 898, 3, 2, 2, 2, 62, 901, 3, 2, 2, 2, 64, 905, 3, 2, 2, 2, 66, 907,
	3, 2, 2, 2, 68, 911, 3, 2, 2, 2, 70, 922, 3, 2, 2, 2, 72, 926, 3, 2, 2,
	2, 74, 928, 3, 2, 2, 2, 76, 77, 5, 4, 3, 2, 77, 78, 7, 2, 2, 3, 78, 3,
	3, 2, 2, 2, 79, 84, 5, 6, 4, 2, 80, 81, 7, 53, 2, 2, 81, 83, 5, 6, 4, 2,
	82, 80, 3, 2, 2, 2, 83, 86, 3, 2, 2, 2, 84, 82, 3, 2, 2, 2, 84, 85, 3,
	2, 2, 2, 85, 5, 3, 2, 2, 2, 86, 84, 3, 2, 2, 2, 87, 89, 5, 8, 5, 2, 88,
	87, 3, 2, 2, 2, 89, 92, 3, 2, 2, 2, 90, 88, 3, 2, 2, 2, 90, 91, 3, 2, 2,
	2, 91, 7, 3, 2, 2, 2, 92, 90, 3, 2, 2, 2, 93, 95, 5, 44, 23, 2, 94, 96,
	5, 10, 6, 2, 95, 94, 3, 2, 2, 2, 95, 96, 3, 2, 2, 2, 96, 9, 3, 2, 2, 2,
	97, 98, 7, 37, 2, 2, 98, 122, 5, 12, 7, 2, 99, 100, 7, 38, 2, 2, 100, 122,
	5, 12, 7, 2, 101, 102, 7, 39, 2, 2, 102, 122, 5, 12, 7, 2, 103, 104, 7,
	40, 2, 2, 104, 105, 5, 56, 29, 2, 105, 106, 7, 41, 2, 2, 106, 107, 5, 12,
	7, 2, 107, 122, 3, 2, 2, 2, 108, 109, 7, 40, 2, 2, 109, 110, 5, 56, 29,
	2, 110, 111, 7, 42, 2, 2, 111, 112, 7, 41, 2, 2, 112, 113, 5, 12, 7, 2,
	113, 122, 3, 2, 2, 2, 114, 115, 7, 40, 2, 2, 115, 116, 5, 56, 29, 2, 116,
	117, 7, 42, 2, 2, 117, 118, 5, 56, 29, 2, 118, 119, 7, 41, 2, 2, 119, 120,
	5, 12, 7, 2, 120, 122, 3, 2, 2, 2, 121, 97, 3, 2, 2, 2, 121, 99, 3, 2,
	2, 2, 121, 101, 3, 2, 2, 2, 121, 103, 3, 2, 2, 2, 121, 108, 3, 2, 2, 2,
	121, 114, 3, 2, 2, 2, 122, 11, 3, 2, 2, 2, 123, 127, 7, 38, 2, 2, 124,
	127, 7, 37, 2, 2, 125, 127, 3, 2, 2, 2, 126, 123, 3, 2, 2, 2, 126, 124,
	3, 2, 2, 2, 126, 125, 3, 2, 2, 2, 127, 13, 3, 2, 2, 2, 128, 129, 7, 31,
	2, 2, 129, 130, 7, 33, 2, 2, 130, 131, 7, 32, 2, 2, 131, 133, 7, 34, 2,
	2, 132, 134, 5, 46, 24, 2, 133, 132, 3, 2, 2, 2, 134, 135, 3, 2, 2, 2,
	135, 133, 3, 2, 2, 2, 135, 136, 3, 2, 2, 2, 136, 137, 3, 2, 2, 2, 137,
	138, 7, 32, 2, 2, 138, 186, 3, 2, 2, 2, 139, 140, 7, 31, 2, 2, 140, 141,
	7, 33, 2, 2, 141, 145, 7, 32, 2, 2, 142, 144, 5, 46, 24, 2, 143, 142, 3,
	2, 2, 2, 144, 147, 3, 2, 2, 2, 145, 143, 3, 2, 2, 2, 145, 146, 3, 2, 2,
	2, 146, 148, 3, 2, 2, 2, 147, 145, 3, 2, 2, 2, 148, 186, 7, 32, 2, 2, 149,
	150, 7, 31, 2, 2, 150, 152, 7, 33, 2, 2, 151, 153, 5, 46, 24, 2, 152, 151,
	3, 2, 2, 2, 153, 154, 3, 2, 2, 2, 154, 152, 3, 2, 2, 2, 154, 155, 3, 2,
	2, 2, 155, 156, 3, 2, 2, 2, 156, 157, 7, 32, 2, 2, 157, 186, 3, 2, 2, 2,
	158, 159, 7, 31, 2, 2, 159, 160, 7, 32, 2, 2, 160, 162, 7, 34, 2, 2, 161,
	163, 5, 46, 24, 2, 162, 161, 3, 2, 2, 2, 163, 164, 3, 2, 2, 2, 164, 162,
	3, 2, 2, 2, 164, 165, 3, 2, 2, 2, 165, 166, 3, 2, 2, 2, 166, 167, 7, 32,
	2, 2, 167, 186, 3, 2, 2, 2, 168, 169, 7, 31, 2, 2, 169, 173, 7, 32, 2,
	2, 170, 172, 5, 46, 24, 2, 171, 170, 3, 2, 2, 2, 172, 175, 3, 2, 2, 2,
	173, 171, 3, 2, 2, 2, 173, 174, 3, 2, 2, 2, 174, 176, 3, 2, 2, 2, 175,
	173, 3, 2, 2, 2, 176, 186, 7, 32, 2, 2, 177, 179, 7, 31, 2, 2, 178, 180,
	5, 46, 24, 2, 179, 178, 3, 2, 2, 2, 180, 181, 3, 2, 2, 2, 181, 179, 3,
	2, 2, 2, 181, 182, 3, 2, 2, 2, 182, 183, 3, 2, 2, 2, 183, 184, 7, 32, 2,
	2, 184, 186, 3, 2, 2, 2, 185, 128, 3, 2, 2, 2, 185, 139, 3, 2, 2, 2, 185,
	149, 3, 2, 2, 2, 185, 158, 3, 2, 2, 2, 185, 168, 3, 2, 2, 2, 185, 177,
	3, 2, 2, 2, 186, 15, 3, 2, 2, 2, 187, 229, 5, 18, 10, 2, 188, 189, 7, 51,
	2, 2, 189, 229, 5, 56, 29, 2, 190, 191, 7, 51, 2, 2, 191, 192, 7, 40, 2,
	2, 192, 193, 5, 56, 29, 2, 193, 194, 7, 41, 2, 2, 194, 229, 3, 2, 2, 2,
	195, 196, 7, 51, 2, 2, 196, 197, 7, 40, 2, 2, 197, 198, 7, 34, 2, 2, 198,
	199, 5, 56, 29, 2, 199, 200, 7, 41, 2, 2, 200, 229, 3, 2, 2, 2, 201, 202,
	7, 52, 2, 2, 202, 203, 7, 56, 2, 2, 203, 204, 5, 66, 34, 2, 204, 205, 7,
	57, 2, 2, 205, 229, 3, 2, 2, 2, 206, 207, 7, 52, 2, 2, 207, 208, 7, 58,
	2, 2, 208, 209, 5, 66, 34, 2, 209, 210, 7, 58, 2, 2, 210, 229, 3, 2, 2,
	2, 211, 212, 7, 51, 2, 2, 212, 213, 7, 40, 2, 2, 213, 214, 5, 66, 34, 2,
	214, 215, 7, 41, 2, 2, 215, 229, 3, 2, 2, 2, 216, 217, 7, 52, 2, 2, 217,
	218, 7, 40, 2, 2, 218, 219, 5, 66, 34, 2, 219, 220, 7, 41, 2, 2, 220, 229,
	3, 2, 2, 2, 221, 222, 7, 54, 2, 2, 222, 223, 7, 37, 2, 2, 223, 224, 7,
	106, 2, 2, 224, 225, 7, 62, 2, 2, 225, 226, 5, 66, 34, 2, 226, 227, 7,
	55, 2, 2, 227, 229, 3, 2, 2, 2, 228, 187, 3, 2, 2, 2, 228, 188, 3, 2, 2,
	2, 228, 190, 3, 2, 2, 2, 228, 195, 3, 2, 2, 2, 228, 201, 3, 2, 2, 2, 228,
	206, 3, 2, 2, 2, 228, 211, 3, 2, 2, 2, 228, 216, 3, 2, 2, 2, 228, 221,
	3, 2, 2, 2, 229, 17, 3, 2, 2, 2, 230, 234, 5, 58, 30, 2, 231, 232, 7, 12,
	2, 2, 232, 234, 5, 64, 33, 2, 233, 230, 3, 2, 2, 2, 233, 231, 3, 2, 2,
	2, 234, 19, 3, 2, 2, 2, 235, 236, 7, 54, 2, 2, 236, 237, 7, 37, 2, 2, 237,
	238, 7, 56, 2, 2, 238, 239, 5, 66, 34, 2, 239, 240, 7, 57, 2, 2, 240, 241,
	5, 4, 3, 2, 241, 242, 7, 55, 2, 2, 242, 265, 3, 2, 2, 2, 243, 244, 7, 54,
	2, 2, 244, 245, 7, 37, 2, 2, 245, 246, 7, 58, 2, 2, 246, 247, 5, 66, 34,
	2, 247, 248, 7, 58, 2, 2, 248, 249, 5, 4, 3, 2, 249, 250, 7, 55, 2, 2,
	250, 265, 3, 2, 2, 2, 251, 252, 7, 54, 2, 2, 252, 253, 7, 37, 2, 2, 253,
	254, 7, 106, 2, 2, 254, 255, 7, 56, 2, 2, 255, 256, 5, 66, 34, 2, 256,
	257, 7, 57, 2, 2, 257, 258, 5, 4, 3, 2, 258, 259, 7, 55, 2, 2, 259, 265,
	3, 2, 2, 2, 260, 261, 7, 54, 2, 2, 261, 262, 5, 4, 3, 2, 262, 263, 7, 55,
	2, 2, 263, 265, 3, 2, 2, 2, 264, 235, 3, 2, 2, 2, 264, 243, 3, 2, 2, 2,
	264, 251, 3, 2, 2, 2, 264, 260, 3, 2, 2, 2, 265, 21, 3, 2, 2, 2, 266, 267,
	7, 54, 2, 2, 267, 268, 7, 37, 2, 2, 268, 269, 7, 60, 2, 2, 269, 270, 5,
	4, 3, 2, 270, 271, 7, 55, 2, 2, 271, 292, 3, 2, 2, 2, 272, 273, 7, 54,
	2, 2, 273, 274, 7, 37, 2, 2, 274, 275, 7, 53, 2, 2, 275, 276, 5, 4, 3,
	2, 276, 277, 7, 55, 2, 2, 277, 292, 3, 2, 2, 2, 278, 279, 7, 54, 2, 2,
	279, 280, 7, 37, 2, 2, 280, 281, 7, 57, 2, 2, 281, 282, 5, 4, 3, 2, 282,
	283, 7, 55, 2, 2, 283, 292, 3, 2, 2, 2, 284, 285, 7, 54, 2, 2, 285, 286,
	7, 37, 2, 2, 286, 287, 5, 28, 15, 2, 287, 288, 7, 60, 2, 2, 288, 289, 5,
	4, 3, 2, 289, 290, 7, 55, 2, 2, 290, 292, 3, 2, 2, 2, 291, 266, 3, 2, 2,
	2, 291, 272, 3, 2, 2, 2, 291, 278, 3, 2, 2, 2, 291, 284, 3, 2, 2, 2, 292,
	23, 3, 2, 2, 2, 293, 294, 7, 54, 2, 2, 294, 295, 7, 37, 2, 2, 295, 296,
	7, 61, 2, 2, 296, 297, 5, 70, 36, 2, 297, 298, 7, 55, 2, 2, 298, 25, 3,
	2, 2, 2, 299, 300, 7, 54, 2, 2, 300, 301, 7, 37, 2, 2, 301, 302, 5, 28,
	15, 2, 302, 303, 7, 34, 2, 2, 303, 304, 5, 28, 15, 2, 304, 305, 7, 55,
	2, 2, 305, 354, 3, 2, 2, 2, 306, 307, 7, 54, 2, 2, 307, 308, 7, 37, 2,
	2, 308, 309, 5, 28, 15, 2, 309, 310, 7, 55, 2, 2, 310, 354, 3, 2, 2, 2,
	311, 312, 7, 54, 2, 2, 312, 313, 7, 37, 2, 2, 313, 314, 7, 34, 2, 2, 314,
	315, 5, 28, 15, 2, 315, 316, 7, 55, 2, 2, 316, 354, 3, 2, 2, 2, 317, 318,
	7, 54, 2, 2, 318, 319, 7, 39, 2, 2, 319, 320, 7, 104, 2, 2, 320, 321, 7,
	105, 2, 2, 321, 322, 7, 59, 2, 2, 322, 323, 7, 109, 2, 2, 323, 324, 7,
	110, 2, 2, 324, 325, 7, 91, 2, 2, 325, 326, 7, 108, 2, 2, 326, 327, 7,
	110, 2, 2, 327, 328, 7, 59, 2, 2, 328, 329, 7, 105, 2, 2, 329, 330, 7,
	106, 2, 2, 330, 331, 7, 110, 2, 2, 331, 354, 7, 55, 2, 2, 332, 333, 7,
	54, 2, 2, 333, 334, 7, 39, 2, 2, 334, 335, 7, 111, 2, 2, 335, 336, 7, 110,
	2, 2, 336, 337, 7, 96, 2, 2, 337, 338, 7, 124, 2, 2, 338, 354, 7, 55, 2,
	2, 339, 340, 7, 54, 2, 2, 340, 341, 7, 39, 2, 2, 341, 342, 7, 111, 2, 2,
	342, 343, 7, 110, 2, 2, 343, 344, 7, 96, 2, 2, 344, 345, 7, 117, 2, 2,
	345, 346, 7, 122, 2, 2, 346, 354, 7, 55, 2, 2, 347, 348, 7, 54, 2, 2, 348,
	349, 7, 39, 2, 2, 349, 350, 7, 111, 2, 2, 350, 351, 7, 93, 2, 2, 351, 352,
	7, 106, 2, 2, 352, 354, 7, 55, 2, 2, 353, 299, 3, 2, 2, 2, 353, 306, 3,
	2, 2, 2, 353, 311, 3, 2, 2, 2, 353, 317, 3, 2, 2, 2, 353, 332, 3, 2, 2,
	2, 353, 339, 3, 2, 2, 2, 353, 347, 3, 2, 2, 2, 354, 27, 3, 2, 2, 2, 355,
	357, 5, 30, 16, 2, 356, 355, 3, 2, 2, 2, 357, 358, 3, 2, 2, 2, 358, 356,
	3, 2, 2, 2, 358, 359, 3, 2, 2, 2, 359, 29, 3, 2, 2, 2, 360, 361, 9, 2,
	2, 2, 361, 31, 3, 2, 2, 2, 362, 363, 7, 54, 2, 2, 363, 364, 7, 37, 2, 2,
	364, 365, 7, 62, 2, 2, 365, 366, 5, 4, 3, 2, 366, 367, 7, 55, 2, 2, 367,
	389, 3, 2, 2, 2, 368, 369, 7, 54, 2, 2, 369, 370, 7, 37, 2, 2, 370, 371,
	7, 63, 2, 2, 371, 372, 5, 4, 3, 2, 372, 373, 7, 55, 2, 2, 373, 389, 3,
	2, 2, 2, 374, 375, 7, 54, 2, 2, 375, 376, 7, 37, 2, 2, 376, 377, 7, 56,
	2, 2, 377, 378, 7, 62, 2, 2, 378, 379, 5, 4, 3, 2, 379, 380, 7, 55, 2,
	2, 380, 389, 3, 2, 2, 2, 381, 382, 7, 54, 2, 2, 382, 383, 7, 37, 2, 2,
	383, 384, 7, 56, 2, 2, 384, 385, 7, 63, 2, 2, 385, 386, 5, 4, 3, 2, 386,
	387, 7, 55, 2, 2, 387, 389, 3, 2, 2, 2, 388, 362, 3, 2, 2, 2, 388, 368,
	3, 2, 2, 2, 388, 374, 3, 2, 2, 2, 388, 381, 3, 2, 2, 2, 389, 33, 3, 2,
	2, 2, 390, 391, 7, 54, 2, 2, 391, 392, 7, 37, 2, 2, 392, 393, 7, 108, 2,
	2, 393, 469, 7, 55, 2, 2, 394, 395, 7, 54, 2, 2, 395, 396, 7, 37, 2, 2,
	396, 397, 5, 56, 29, 2, 397, 398, 7, 55, 2, 2, 398, 469, 3, 2, 2, 2, 399,
	400, 7, 54, 2, 2, 400, 401, 7, 37, 2, 2, 401, 402, 7, 38, 2, 2, 402, 403,
	5, 56, 29, 2, 403, 404, 7, 55, 2, 2, 404, 469, 3, 2, 2, 2, 405, 406, 7,
	54, 2, 2, 406, 407, 7, 37, 2, 2, 407, 408, 7, 34, 2, 2, 408, 409, 5, 56,
	29, 2, 409, 410, 7, 55, 2, 2, 410, 469, 3, 2, 2, 2, 411, 412, 7, 54, 2,
	2, 412, 413, 7, 37, 2, 2, 413, 414, 7, 64, 2, 2, 414, 415, 5, 66, 34, 2,
	415, 416, 7, 55, 2, 2, 416, 469, 3, 2, 2, 2, 417, 418, 7, 54, 2, 2, 418,
	419, 7, 37, 2, 2, 419, 420, 7, 106, 2, 2, 420, 421, 7, 57, 2, 2, 421, 422,
	5, 66, 34, 2, 422, 423, 7, 55, 2, 2, 423, 469, 3, 2, 2, 2, 424, 425, 7,
	51, 2, 2, 425, 426, 7, 56, 2, 2, 426, 427, 5, 66, 34, 2, 427, 428, 7, 57,
	2, 2, 428, 469, 3, 2, 2, 2, 429, 430, 7, 51, 2, 2, 430, 431, 7, 58, 2,
	2, 431, 432, 5, 66, 34, 2, 432, 433, 7, 58, 2, 2, 433, 469, 3, 2, 2, 2,
	434, 435, 7, 51, 2, 2, 435, 436, 7, 56, 2, 2, 436, 437, 5, 56, 29, 2, 437,
	438, 7, 57, 2, 2, 438, 469, 3, 2, 2, 2, 439, 440, 7, 51, 2, 2, 440, 441,
	7, 58, 2, 2, 441, 442, 5, 56, 29, 2, 442, 443, 7, 58, 2, 2, 443, 469, 3,
	2, 2, 2, 444, 445, 7, 51, 2, 2, 445, 446, 7, 56, 2, 2, 446, 447, 7, 38,
	2, 2, 447, 448, 5, 56, 29, 2, 448, 449, 7, 57, 2, 2, 449, 469, 3, 2, 2,
	2, 450, 451, 7, 51, 2, 2, 451, 452, 7, 58, 2, 2, 452, 453, 7, 38, 2, 2,
	453, 454, 5, 56, 29, 2, 454, 455, 7, 58, 2, 2, 455, 469, 3, 2, 2, 2, 456,
	457, 7, 51, 2, 2, 457, 458, 7, 56, 2, 2, 458, 459, 7, 34, 2, 2, 459, 460,
	5, 56, 29, 2, 460, 461, 7, 57, 2, 2, 461, 469, 3, 2, 2, 2, 462, 463, 7,
	51, 2, 2, 463, 464, 7, 58, 2, 2, 464, 465, 7, 34, 2, 2, 465, 466, 5, 56,
	29, 2, 466, 467, 7, 58, 2, 2, 467, 469, 3, 2, 2, 2, 468, 390, 3, 2, 2,
	2, 468, 394, 3, 2, 2, 2, 468, 399, 3, 2, 2, 2, 468, 405, 3, 2, 2, 2, 468,
	411, 3, 2, 2, 2, 468, 417, 3, 2, 2, 2, 468, 424, 3, 2, 2, 2, 468, 429,
	3, 2, 2, 2, 468, 434, 3, 2, 2, 2, 468, 439, 3, 2, 2, 2, 468, 444, 3, 2,
	2, 2, 468, 450, 3, 2, 2, 2, 468, 456, 3, 2, 2, 2, 468, 462, 3, 2, 2, 2,
	469, 35, 3, 2, 2, 2, 470, 471, 7, 54, 2, 2, 471, 472, 7, 37, 2, 2, 472,
	473, 7, 54, 2, 2, 473, 474, 5, 56, 29, 2, 474, 475, 7, 55, 2, 2, 475, 478,
	5, 4, 3, 2, 476, 477, 7, 53, 2, 2, 477, 479, 5, 4, 3, 2, 478, 476, 3, 2,
	2, 2, 478, 479, 3, 2, 2, 2, 479, 480, 3, 2, 2, 2, 480, 481, 7, 55, 2, 2,
	481, 622, 3, 2, 2, 2, 482, 483, 7, 54, 2, 2, 483, 484, 7, 37, 2, 2, 484,
	485, 7, 54, 2, 2, 485, 486, 7, 38, 2, 2, 486, 487, 5, 56, 29, 2, 487, 488,
	7, 55, 2, 2, 488, 491, 5, 4, 3, 2, 489, 490, 7, 53, 2, 2, 490, 492, 5,
	4, 3, 2, 491, 489, 3, 2, 2, 2, 491, 492, 3, 2, 2, 2, 492, 493, 3, 2, 2,
	2, 493, 494, 7, 55, 2, 2, 494, 622, 3, 2, 2, 2, 495, 496, 7, 54, 2, 2,
	496, 497, 7, 37, 2, 2, 497, 498, 7, 54, 2, 2, 498, 499, 7, 34, 2, 2, 499,
	500, 5, 56, 29, 2, 500, 501, 7, 55, 2, 2, 501, 504, 5, 4, 3, 2, 502, 503,
	7, 53, 2, 2, 503, 505, 5, 4, 3, 2, 504, 502, 3, 2, 2, 2, 504, 505, 3, 2,
	2, 2, 505, 506, 3, 2, 2, 2, 506, 507, 7, 55, 2, 2, 507, 622, 3, 2, 2, 2,
	508, 509, 7, 54, 2, 2, 509, 510, 7, 37, 2, 2, 510, 511, 7, 54, 2, 2, 511,
	512, 7, 56, 2, 2, 512, 513, 5, 66, 34, 2, 513, 514, 7, 57, 2, 2, 514, 515,
	7, 55, 2, 2, 515, 518, 5, 4, 3, 2, 516, 517, 7, 53, 2, 2, 517, 519, 5,
	4, 3, 2, 518, 516, 3, 2, 2, 2, 518, 519, 3, 2, 2, 2, 519, 520, 3, 2, 2,
	2, 520, 521, 7, 55, 2, 2, 521, 622, 3, 2, 2, 2, 522, 523, 7, 54, 2, 2,
	523, 524, 7, 37, 2, 2, 524, 525, 7, 54, 2, 2, 525, 526, 7, 58, 2, 2, 526,
	527, 5, 66, 34, 2, 527, 528, 7, 58, 2, 2, 528, 529, 7, 55, 2, 2, 529, 532,
	5, 4, 3, 2, 530, 531, 7, 53, 2, 2, 531, 533, 5, 4, 3, 2, 532, 530, 3, 2,
	2, 2, 532, 533, 3, 2, 2, 2, 533, 534, 3, 2, 2, 2, 534, 535, 7, 55, 2, 2,
	535, 622, 3, 2, 2, 2, 536, 537, 7, 54, 2, 2, 537, 538, 7, 37, 2, 2, 538,
	539, 7, 54, 2, 2, 539, 540, 7, 108, 2, 2, 540, 541, 5, 56, 29, 2, 541,
	542, 7, 55, 2, 2, 542, 545, 5, 4, 3, 2, 543, 544, 7, 53, 2, 2, 544, 546,
	5, 4, 3, 2, 545, 543, 3, 2, 2, 2, 545, 546, 3, 2, 2, 2, 546, 547, 3, 2,
	2, 2, 547, 548, 7, 55, 2, 2, 548, 622, 3, 2, 2, 2, 549, 550, 7, 54, 2,
	2, 550, 551, 7, 37, 2, 2, 551, 552, 7, 54, 2, 2, 552, 553, 7, 108, 2, 2,
	553, 554, 7, 55, 2, 2, 554, 557, 5, 4, 3, 2, 555, 556, 7, 53, 2, 2, 556,
	558, 5, 4, 3, 2, 557, 555, 3, 2, 2, 2, 557, 558, 3, 2, 2, 2, 558, 559,
	3, 2, 2, 2, 559, 560, 7, 55, 2, 2, 560, 622, 3, 2, 2, 2, 561, 562, 7, 54,
	2, 2, 562, 563, 7, 37, 2, 2, 563, 564, 7, 54, 2, 2, 564, 565, 7, 108, 2,
	2, 565, 566, 7, 64, 2, 2, 566, 567, 5, 66, 34, 2, 567, 568, 7, 55, 2, 2,
	568, 571, 5, 4, 3, 2, 569, 570, 7, 53, 2, 2, 570, 572, 5, 4, 3, 2, 571,
	569, 3, 2, 2, 2, 571, 572, 3, 2, 2, 2, 572, 573, 3, 2, 2, 2, 573, 574,
	7, 55, 2, 2, 574, 622, 3, 2, 2, 2, 575, 576, 7, 54, 2, 2, 576, 577, 7,
	37, 2, 2, 577, 578, 7, 54, 2, 2, 578, 579, 7, 94, 2, 2, 579, 580, 7, 95,
	2, 2, 580, 581, 7, 96, 2, 2, 581, 582, 7, 99, 2, 2, 582, 583, 7, 104, 2,
	2, 583, 584, 7, 95, 2, 2, 584, 585, 7, 55, 2, 2, 585, 588, 5, 4, 3, 2,
	586, 587, 7, 53, 2, 2, 587, 589, 5, 4, 3, 2, 588, 586, 3, 2, 2, 2, 588,
	589, 3, 2, 2, 2, 589, 590, 3, 2, 2, 2, 590, 591, 7, 55, 2, 2, 591, 622,
	3, 2, 2, 2, 592, 593, 7, 54, 2, 2, 593, 594, 7, 37, 2, 2, 594, 595, 7,
	54, 2, 2, 595, 596, 7, 65, 2, 2, 596, 597, 7, 83, 2, 2, 597, 598, 7, 83,
	2, 2, 598, 599, 7, 69, 2, 2, 599, 600, 7, 82, 2, 2, 600, 601, 7, 84, 2,
	2, 601, 602, 7, 55, 2, 2, 602, 605, 5, 4, 3, 2, 603, 604, 7, 53, 2, 2,
	604, 606, 5, 4, 3, 2, 605, 603, 3, 2, 2, 2, 605, 606, 3, 2, 2, 2, 606,
	607, 3, 2, 2, 2, 607, 608, 7, 55, 2, 2, 608, 622, 3, 2, 2, 2, 609, 610,
	7, 54, 2, 2, 610, 611, 7, 37, 2, 2, 611, 612, 7, 54, 2, 2, 612, 613, 5,
	66, 34, 2, 613, 614, 7, 55, 2, 2, 614, 617, 5, 4, 3, 2, 615, 616, 7, 53,
	2, 2, 616, 618, 5, 4, 3, 2, 617, 615, 3, 2, 2, 2, 617, 618, 3, 2, 2, 2,
	618, 619, 3, 2, 2, 2, 619, 620, 7, 55, 2, 2, 620, 622, 3, 2, 2, 2, 621,
	470, 3, 2, 2, 2, 621, 482, 3, 2, 2, 2, 621, 495, 3, 2, 2, 2, 621, 508,
	3, 2, 2, 2, 621, 522, 3, 2, 2, 2, 621, 536, 3, 2, 2, 2, 621, 549, 3, 2,
	2, 2, 621, 561, 3, 2, 2, 2, 621, 575, 3, 2, 2, 2, 621, 592, 3, 2, 2, 2,
	621, 609, 3, 2, 2, 2, 622, 37, 3, 2, 2, 2, 623, 624, 7, 54, 2, 2, 624,
	625, 7, 39, 2, 2, 625, 626, 7, 91, 2, 2, 626, 627, 7, 93, 2, 2, 627, 628,
	7, 93, 2, 2, 628, 629, 7, 95, 2, 2, 629, 630, 7, 106, 2, 2, 630, 631, 7,
	110, 2, 2, 631, 724, 7, 55, 2, 2, 632, 633, 7, 54, 2, 2, 633, 634, 7, 39,
	2, 2, 634, 638, 7, 96, 2, 2, 635, 636, 7, 91, 2, 2, 636, 637, 7, 99, 2,
	2, 637, 639, 7, 102, 2, 2, 638, 635, 3, 2, 2, 2, 638, 639, 3, 2, 2, 2,
	639, 640, 3, 2, 2, 2, 640, 724, 7, 55, 2, 2, 641, 642, 7, 54, 2, 2, 642,
	647, 7, 39, 2, 2, 643, 644, 7, 103, 2, 2, 644, 645, 7, 91, 2, 2, 645, 646,
	7, 108, 2, 2, 646, 648, 7, 101, 2, 2, 647, 643, 3, 2, 2, 2, 647, 648, 3,
	2, 2, 2, 648, 649, 3, 2, 2, 2, 649, 650, 7, 60, 2, 2, 650, 651, 7, 104,
	2, 2, 651, 652, 7, 91, 2, 2, 652, 653, 7, 103, 2, 2, 653, 654, 7, 95, 2,
	2, 654, 724, 7, 55, 2, 2, 655, 656, 7, 54, 2, 2, 656, 657, 7, 39, 2, 2,
	657, 658, 7, 93, 2, 2, 658, 659, 7, 105, 2, 2, 659, 660, 7, 103, 2, 2,
	660, 661, 7, 103, 2, 2, 661, 662, 7, 99, 2, 2, 662, 663, 7, 110, 2, 2,
	663, 724, 7, 55, 2, 2, 664, 665, 7, 54, 2, 2, 665, 666, 7, 39, 2, 2, 666,
	667, 7, 106, 2, 2, 667, 668, 7, 108, 2, 2, 668, 669, 7, 111, 2, 2, 669,
	670, 7, 104, 2, 2, 670, 671, 7, 95, 2, 2, 671, 724, 7, 55, 2, 2, 672, 673,
	7, 54, 2, 2, 673, 674, 7, 39, 2, 2, 674, 675, 7, 106, 2, 2, 675, 676, 7,
	108, 2, 2, 676, 677, 7, 111, 2, 2, 677, 678, 7, 104, 2, 2, 678, 679, 7,
	95, 2, 2, 679, 680, 7, 60, 2, 2, 680, 681, 7, 104, 2, 2, 681, 682, 7, 91,
	2, 2, 682, 683, 7, 103, 2, 2, 683, 684, 7, 95, 2, 2, 684, 724, 7, 55, 2,
	2, 685, 686, 7, 54, 2, 2, 686, 687, 7, 39, 2, 2, 687, 688, 7, 109, 2, 2,
	688, 689, 7, 101, 2, 2, 689, 690, 7, 99, 2, 2, 690, 691, 7, 106, 2, 2,
	691, 724, 7, 55, 2, 2, 692, 693, 7, 54, 2, 2, 693, 694, 7, 39, 2, 2, 694,
	695, 7, 109, 2, 2, 695, 696, 7, 101, 2, 2, 696, 697, 7, 99, 2, 2, 697,
	698, 7, 106, 2, 2, 698, 699, 7, 60, 2, 2, 699, 700, 7, 104, 2, 2, 700,
	701, 7, 91, 2, 2, 701, 702, 7, 103, 2, 2, 702, 703, 7, 95, 2, 2, 703, 724,
	7, 55, 2, 2, 704, 705, 7, 54, 2, 2, 705, 706, 7, 39, 2, 2, 706, 707, 7,
	110, 2, 2, 707, 708, 7, 98, 2, 2, 708, 709, 7, 95, 2, 2, 709, 710, 7, 104,
	2, 2, 710, 724, 7, 55, 2, 2, 711, 712, 7, 54, 2, 2, 712, 713, 7, 39, 2,
	2, 713, 714, 7, 110, 2, 2, 714, 715, 7, 98, 2, 2, 715, 716, 7, 95, 2, 2,
	716, 717, 7, 104, 2, 2, 717, 718, 7, 60, 2, 2, 718, 719, 7, 104, 2, 2,
	719, 720, 7, 91, 2, 2, 720, 721, 7, 103, 2, 2, 721, 722, 7, 95, 2, 2, 722,
	724, 7, 55, 2, 2, 723, 623, 3, 2, 2, 2, 723, 632, 3, 2, 2, 2, 723, 641,
	3, 2, 2, 2, 723, 655, 3, 2, 2, 2, 723, 664, 3, 2, 2, 2, 723, 672, 3, 2,
	2, 2, 723, 685, 3, 2, 2, 2, 723, 692, 3, 2, 2, 2, 723, 704, 3, 2, 2, 2,
	723, 711, 3, 2, 2, 2, 724, 39, 3, 2, 2, 2, 725, 726, 7, 54, 2, 2, 726,
	727, 7, 39, 2, 2, 727, 728, 7, 93, 2, 2, 728, 729, 7, 108, 2, 2, 729, 787,
	7, 55, 2, 2, 730, 731, 7, 54, 2, 2, 731, 732, 7, 39, 2, 2, 732, 733, 7,
	102, 2, 2, 733, 734, 7, 96, 2, 2, 734, 787, 7, 55, 2, 2, 735, 736, 7, 54,
	2, 2, 736, 737, 7, 39, 2, 2, 737, 738, 7, 93, 2, 2, 738, 739, 7, 108, 2,
	2, 739, 740, 7, 102, 2, 2, 740, 741, 7, 96, 2, 2, 741, 787, 7, 55, 2, 2,
	742, 743, 7, 54, 2, 2, 743, 744, 7, 39, 2, 2, 744, 745, 7, 91, 2, 2, 745,
	746, 7, 104, 2, 2, 746, 747, 7, 115, 2, 2, 747, 748, 7, 93, 2, 2, 748,
	749, 7, 108, 2, 2, 749, 750, 7, 102, 2, 2, 750, 751, 7, 96, 2, 2, 751,
	787, 7, 55, 2, 2, 752, 753, 7, 54, 2, 2, 753, 754, 7, 39, 2, 2, 754, 755,
	7, 91, 2, 2, 755, 756, 7, 104, 2, 2, 756, 757, 7, 115, 2, 2, 757, 787,
	7, 55, 2, 2, 758, 759, 7, 54, 2, 2, 759, 760, 7, 39, 2, 2, 760, 761, 7,
	92, 2, 2, 761, 762, 7, 109, 2, 2, 762, 763, 7, 108, 2, 2, 763, 764, 7,
	59, 2, 2, 764, 765, 7, 91, 2, 2, 765, 766, 7, 104, 2, 2, 766, 767, 7, 115,
	2, 2, 767, 768, 7, 93, 2, 2, 768, 769, 7, 108, 2, 2, 769, 770, 7, 102,
	2, 2, 770, 771, 7, 96, 2, 2, 771, 787, 7, 55, 2, 2, 772, 773, 7, 54, 2,
	2, 773, 774, 7, 39, 2, 2, 774, 775, 7, 92, 2, 2, 775, 776, 7, 109, 2, 2,
	776, 777, 7, 108, 2, 2, 777, 778, 7, 59, 2, 2, 778, 779, 7, 111, 2, 2,
	779, 780, 7, 104, 2, 2, 780, 781, 7, 99, 2, 2, 781, 782, 7, 93, 2, 2, 782,
	783, 7, 105, 2, 2, 783, 784, 7, 94, 2, 2, 784, 785, 7, 95, 2, 2, 785, 787,
	7, 55, 2, 2, 786, 725, 3, 2, 2, 2, 786, 730, 3, 2, 2, 2, 786, 735, 3, 2,
	2, 2, 786, 742, 3, 2, 2, 2, 786, 752, 3, 2, 2, 2, 786, 758, 3, 2, 2, 2,
	786, 772, 3, 2, 2, 2, 787, 41, 3, 2, 2, 2, 788, 789, 7, 54, 2, 2, 789,
	790, 7, 37, 2, 2, 790, 791, 7, 93, 2, 2, 791, 799, 7, 55, 2, 2, 792, 793,
	7, 54, 2, 2, 793, 794, 7, 37, 2, 2, 794, 795, 7, 93, 2, 2, 795, 796, 5,
	56, 29, 2, 796, 797, 7, 55, 2, 2, 797, 799, 3, 2, 2, 2, 798, 788, 3, 2,
	2, 2, 798, 792, 3, 2, 2, 2, 799, 43, 3, 2, 2, 2, 800, 827, 5, 34, 18, 2,
	801, 827, 5, 48, 25, 2, 802, 827, 5, 50, 26, 2, 803, 827, 5, 14, 8, 2,
	804, 827, 5, 20, 11, 2, 805, 827, 5, 22, 12, 2, 806, 827, 5, 24, 13, 2,
	807, 827, 5, 26, 14, 2, 808, 827, 5, 32, 17, 2, 809, 827, 5, 16, 9, 2,
	810, 827, 5, 36, 19, 2, 811, 827, 5, 38, 20, 2, 812, 827, 5, 40, 21, 2,
	813, 827, 5, 42, 22, 2, 814, 827, 7, 14, 2, 2, 815, 827, 7, 33, 2, 2, 816,
	827, 7, 45, 2, 2, 817, 827, 7, 43, 2, 2, 818, 827, 7, 44, 2, 2, 819, 827,
	7, 46, 2, 2, 820, 827, 7, 47, 2, 2, 821, 827, 7, 48, 2, 2, 822, 827, 7,
	49, 2, 2, 823, 827, 7, 50, 2, 2, 824, 827, 7, 15, 2, 2, 825, 827, 7, 30,
	2, 2, 826, 800, 3, 2, 2, 2, 826, 801, 3, 2, 2, 2, 826, 802, 3, 2, 2, 2,
	826, 803, 3, 2, 2, 2, 826, 804, 3, 2, 2, 2, 826, 805, 3, 2, 2, 2, 826,
	806, 3, 2, 2, 2, 826, 807, 3, 2, 2, 2, 826, 808, 3, 2, 2, 2, 826, 809,
	3, 2, 2, 2, 826, 810, 3, 2, 2, 2, 826, 811, 3, 2, 2, 2, 826, 812, 3, 2,
	2, 2, 826, 813, 3, 2, 2, 2, 826, 814, 3, 2, 2, 2, 826, 815, 3, 2, 2, 2,
	826, 816, 3, 2, 2, 2, 826, 817, 3, 2, 2, 2, 826, 818, 3, 2, 2, 2, 826,
	819, 3, 2, 2, 2, 826, 820, 3, 2, 2, 2, 826, 821, 3, 2, 2, 2, 826, 822,
	3, 2, 2, 2, 826, 823, 3, 2, 2, 2, 826, 824, 3, 2, 2, 2, 826, 825, 3, 2,
	2, 2, 827, 45, 3, 2, 2, 2, 828, 829, 5, 52, 27, 2, 829, 830, 7, 34, 2,
	2, 830, 831, 5, 52, 27, 2, 831, 836, 3, 2, 2, 2, 832, 836, 5, 48, 25, 2,
	833, 836, 5, 52, 27, 2, 834, 836, 5, 18, 10, 2, 835, 828, 3, 2, 2, 2, 835,
	832, 3, 2, 2, 2, 835, 833, 3, 2, 2, 2, 835, 834, 3, 2, 2, 2, 836, 47, 3,
	2, 2, 2, 837, 838, 9, 3, 2, 2, 838, 49, 3, 2, 2, 2, 839, 842, 5, 54, 28,
	2, 840, 842, 7, 32, 2, 2, 841, 839, 3, 2, 2, 2, 841, 840, 3, 2, 2, 2, 842,
	51, 3, 2, 2, 2, 843, 856, 5, 54, 28, 2, 844, 856, 7, 14, 2, 2, 845, 856,
	7, 31, 2, 2, 846, 856, 7, 33, 2, 2, 847, 856, 7, 37, 2, 2, 848, 856, 7,
	38, 2, 2, 849, 856, 7, 39, 2, 2, 850, 856, 7, 43, 2, 2, 851, 856, 7, 46,
	2, 2, 852, 856, 7, 53, 2, 2, 853, 856, 7, 54, 2, 2, 854, 856, 7, 55, 2,
	2, 855, 843, 3, 2, 2, 2, 855, 844, 3, 2, 2, 2, 855, 845, 3, 2, 2, 2, 855,
	846, 3, 2, 2, 2, 855, 847, 3, 2, 2, 2, 855, 848, 3, 2, 2, 2, 855, 849,
	3, 2, 2, 2, 855, 850, 3, 2, 2, 2, 855, 851, 3, 2, 2, 2, 855, 852, 3, 2,
	2, 2, 855, 853, 3, 2, 2, 2, 855, 854, 3, 2, 2, 2, 856, 53, 3, 2, 2, 2,
	857, 884, 5, 58, 30, 2, 858, 884, 5, 74, 38, 2, 859, 884, 5, 64, 33, 2,
	860, 884, 7, 5, 2, 2, 861, 884, 7, 7, 2, 2, 862, 884, 7, 8, 2, 2, 863,
	884, 7, 9, 2, 2, 864, 884, 7, 10, 2, 2, 865, 884, 7, 11, 2, 2, 866, 884,
	7, 13, 2, 2, 867, 884, 7, 3, 2, 2, 868, 884, 7, 4, 2, 2, 869, 884, 7, 40,
	2, 2, 870, 884, 7, 41, 2, 2, 871, 884, 7, 42, 2, 2, 872, 884, 7, 34, 2,
	2, 873, 884, 7, 56, 2, 2, 874, 884, 7, 57, 2, 2, 875, 884, 7, 58, 2, 2,
	876, 884, 7, 59, 2, 2, 877, 884, 7, 60, 2, 2, 878, 884, 7, 61, 2, 2, 879,
	884, 7, 62, 2, 2, 880, 884, 7, 63, 2, 2, 881, 884, 7, 64, 2, 2, 882, 884,
	7, 127, 2, 2, 883, 857, 3, 2, 2, 2, 883, 858, 3, 2, 2, 2, 883, 859, 3,
	2, 2, 2, 883, 860, 3, 2, 2, 2, 883, 861, 3, 2, 2, 2, 883, 862, 3, 2, 2,
	2, 883, 863, 3, 2, 2, 2, 883, 864, 3, 2, 2, 2, 883, 865, 3, 2, 2, 2, 883,
	866, 3, 2, 2, 2, 883, 867, 3, 2, 2, 2, 883, 868, 3, 2, 2, 2, 883, 869,
	3, 2, 2, 2, 883, 870, 3, 2, 2, 2, 883, 871, 3, 2, 2, 2, 883, 872, 3, 2,
	2, 2, 883, 873, 3, 2, 2, 2, 883, 874, 3, 2, 2, 2, 883, 875, 3, 2, 2, 2,
	883, 876, 3, 2, 2, 2, 883, 877, 3, 2, 2, 2, 883, 878, 3, 2, 2, 2, 883,
	879, 3, 2, 2, 2, 883, 880, 3, 2, 2, 2, 883, 881, 3, 2, 2, 2, 883, 882,
	3, 2, 2, 2, 884, 55, 3, 2, 2, 2, 885, 886, 5, 62, 32, 2, 886, 57, 3, 2,
	2, 2, 887, 888, 7, 12, 2, 2, 888, 889, 9, 4, 2, 2, 889, 890, 5, 60, 31,
	2, 890, 891, 5, 60, 31, 2, 891, 897, 3, 2, 2, 2, 892, 893, 7, 12, 2, 2,
	893, 894, 5, 60, 31, 2, 894, 895, 5, 60, 31, 2, 895, 897, 3, 2, 2, 2, 896,
	887, 3, 2, 2, 2, 896, 892, 3, 2, 2, 2, 897, 59, 3, 2, 2, 2, 898, 899, 9,
	5, 2, 2, 899, 61, 3, 2, 2, 2, 900, 902, 5, 64, 33, 2, 901, 900, 3, 2, 2,
	2, 902, 903, 3, 2, 2, 2, 903, 901, 3, 2, 2, 2, 903, 904, 3, 2, 2, 2, 904,
	63, 3, 2, 2, 2, 905, 906, 9, 6, 2, 2, 906, 65, 3, 2, 2, 2, 907, 908, 5,
	68, 35, 2, 908, 67, 3, 2, 2, 2, 909, 912, 5, 74, 38, 2, 910, 912, 7, 59,
	2, 2, 911, 909, 3, 2, 2, 2, 911, 910, 3, 2, 2, 2, 912, 918, 3, 2, 2, 2,
	913, 917, 5, 74, 38, 2, 914, 917, 7, 59, 2, 2, 915, 917, 5, 64, 33, 2,
	916, 913, 3, 2, 2, 2, 916, 914, 3, 2, 2, 2, 916, 915, 3, 2, 2, 2, 917,
	920, 3, 2, 2, 2, 918, 916, 3, 2, 2, 2, 918, 919, 3, 2, 2, 2, 919, 69, 3,
	2, 2, 2, 920, 918, 3, 2, 2, 2, 921, 923, 5, 72, 37, 2, 922, 921, 3, 2,
	2, 2, 923, 924, 3, 2, 2, 2, 924, 922, 3, 2, 2, 2, 924, 925, 3, 2, 2, 2,
	925, 71, 3, 2, 2, 2, 926, 927, 10, 7, 2, 2, 927, 73, 3, 2, 2, 2, 928, 929,
	9, 8, 2, 2, 929, 75, 3, 2, 2, 2, 50, 84, 90, 95, 121, 126, 135, 145, 154,
	164, 173, 181, 185, 228, 233, 264, 291, 353, 358, 388, 468, 478, 491, 504,
	518, 532, 545, 557, 571, 588, 605, 617, 621, 638, 647, 723, 786, 798, 826,
	835, 841, 855, 883, 896, 903, 911, 916, 918, 924,
}
var literalNames = []string{
	"", "", "", "'\\a'", "'\\c'", "'\\e'", "'\\f'", "'\\n'", "'\\r'", "'\\t'",
	"'\\'", "", "'.'", "'\\C'", "'\\d'", "'\\D'", "'\\h'", "'\\H'", "'\\N'",
	"", "", "'\\R'", "'\\s'", "'\\S'", "'\\v'", "'\\V'", "'\\w'", "'\\W'",
	"'\\X'", "'['", "']'", "'^'", "'-'", "", "", "'?'", "'+'", "'*'", "'{'",
	"'}'", "','", "'\\b'", "'\\B'", "'\\A'", "'$'", "'\\Z'", "'\\z'", "'\\G'",
	"'\\K'", "'\\g'", "'\\k'", "'|'", "'('", "')'", "'<'", "'>'", "'''", "'_'",
	"':'", "'#'", "'='", "'!'", "'&'", "'a'", "'b'", "'c'", "'d'", "'e'", "'f'",
	"'g'", "'h'", "'i'", "'j'", "'k'", "'l'", "'m'", "'n'", "'o'", "'p'", "'q'",
	"'r'", "'s'", "'t'", "'u'", "'v'", "'w'", "'x'", "'y'", "'z'", "'A'", "'B'",
	"'C'", "'D'", "'E'", "'F'", "'G'", "'H'", "'I'", "'J'", "'K'", "'L'", "'M'",
	"'N'", "'O'", "'P'", "'Q'", "'R'", "'S'", "'T'", "'U'", "'V'", "'W'", "'X'",
	"'Y'", "'Z'", "'1'", "'2'", "'3'", "'4'", "'5'", "'6'", "'7'", "'8'", "'9'",
	"'0'",
}
var symbolicNames = []string{
	"", "Quoted", "BlockQuoted", "BellChar", "ControlChar", "EscapeChar", "FormFeed",
	"NewLine", "CarriageReturn", "Tab", "Backslash", "HexChar", "Dot", "OneDataUnit",
	"DecimalDigit", "NotDecimalDigit", "HorizontalWhiteSpace", "NotHorizontalWhiteSpace",
	"NotNewLine", "CharWithProperty", "CharWithoutProperty", "NewLineSequence",
	"WhiteSpace", "NotWhiteSpace", "VerticalWhiteSpace", "NotVerticalWhiteSpace",
	"WordChar", "NotWordChar", "ExtendedUnicodeChar", "CharacterClassStart",
	"CharacterClassEnd", "Caret", "Hyphen", "POSIXNamedSet", "POSIXNegatedNamedSet",
	"QuestionMark", "Plus", "Star", "OpenBrace", "CloseBrace", "Comma", "WordBoundary",
	"NonWordBoundary", "StartOfSubject", "EndOfSubjectOrLine", "EndOfSubjectOrLineEndOfSubject",
	"EndOfSubject", "PreviousMatchInSubject", "ResetStartMatch", "SubroutineOrNamedReferenceStartG",
	"NamedReferenceStartK", "Pipe", "OpenParen", "CloseParen", "LessThan",
	"GreaterThan", "SingleQuote", "Underscore", "Colon", "Hash", "Equals",
	"Exclamation", "Ampersand", "ALC", "BLC", "CLC", "DLC", "ELC", "FLC", "GLC",
	"HLC", "ILC", "JLC", "KLC", "LLC", "MLC", "NLC", "OLC", "PLC", "QLC", "RLC",
	"SLC", "TLC", "ULC", "VLC", "WLC", "XLC", "YLC", "ZLC", "AUC", "BUC", "CUC",
	"DUC", "EUC", "FUC", "GUC", "HUC", "IUC", "JUC", "KUC", "LUC", "MUC", "NUC",
	"OUC", "PUC", "QUC", "RUC", "SUC", "TUC", "UUC", "VUC", "WUC", "XUC", "YUC",
	"ZUC", "D1", "D2", "D3", "D4", "D5", "D6", "D7", "D8", "D9", "D0", "OtherChar",
}

var ruleNames = []string{
	"parse", "alternation", "expr", "element", "quantifier", "quantifier_type",
	"character_class", "backreference", "backreference_or_octal", "capture",
	"non_capture", "comment", "option", "option_flags", "option_flag", "look_around",
	"subroutine_reference", "conditional", "backtrack_control", "newline_convention",
	"callout", "atom", "cc_atom", "shared_atom", "literal", "cc_literal", "shared_literal",
	"number", "octal_char", "octal_digit", "digits", "digit", "name", "alpha_nums",
	"non_close_parens", "non_close_paren", "letter",
}

type PCREParser struct {
	*antlr.BaseParser
}

// NewPCREParser produces a new parser instance for the optional input antlr.TokenStream.
//
// The *PCREParser instance produced may be reused by calling the SetInputStream method.
// The initial parser configuration is expensive to construct, and the object is not thread-safe;
// however, if used within a Golang sync.Pool, the construction cost amortizes well and the
// objects can be used in a thread-safe manner.
func NewPCREParser(input antlr.TokenStream) *PCREParser {
	this := new(PCREParser)
	deserializer := antlr.NewATNDeserializer(nil)
	deserializedATN := deserializer.DeserializeFromUInt16(parserATN)
	decisionToDFA := make([]*antlr.DFA, len(deserializedATN.DecisionToState))
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "PCRE.g4"

	return this
}

// PCREParser tokens.
const (
	PCREParserEOF                              = antlr.TokenEOF
	PCREParserQuoted                           = 1
	PCREParserBlockQuoted                      = 2
	PCREParserBellChar                         = 3
	PCREParserControlChar                      = 4
	PCREParserEscapeChar                       = 5
	PCREParserFormFeed                         = 6
	PCREParserNewLine                          = 7
	PCREParserCarriageReturn                   = 8
	PCREParserTab                              = 9
	PCREParserBackslash                        = 10
	PCREParserHexChar                          = 11
	PCREParserDot                              = 12
	PCREParserOneDataUnit                      = 13
	PCREParserDecimalDigit                     = 14
	PCREParserNotDecimalDigit                  = 15
	PCREParserHorizontalWhiteSpace             = 16
	PCREParserNotHorizontalWhiteSpace          = 17
	PCREParserNotNewLine                       = 18
	PCREParserCharWithProperty                 = 19
	PCREParserCharWithoutProperty              = 20
	PCREParserNewLineSequence                  = 21
	PCREParserWhiteSpace                       = 22
	PCREParserNotWhiteSpace                    = 23
	PCREParserVerticalWhiteSpace               = 24
	PCREParserNotVerticalWhiteSpace            = 25
	PCREParserWordChar                         = 26
	PCREParserNotWordChar                      = 27
	PCREParserExtendedUnicodeChar              = 28
	PCREParserCharacterClassStart              = 29
	PCREParserCharacterClassEnd                = 30
	PCREParserCaret                            = 31
	PCREParserHyphen                           = 32
	PCREParserPOSIXNamedSet                    = 33
	PCREParserPOSIXNegatedNamedSet             = 34
	PCREParserQuestionMark                     = 35
	PCREParserPlus                             = 36
	PCREParserStar                             = 37
	PCREParserOpenBrace                        = 38
	PCREParserCloseBrace                       = 39
	PCREParserComma                            = 40
	PCREParserWordBoundary                     = 41
	PCREParserNonWordBoundary                  = 42
	PCREParserStartOfSubject                   = 43
	PCREParserEndOfSubjectOrLine               = 44
	PCREParserEndOfSubjectOrLineEndOfSubject   = 45
	PCREParserEndOfSubject                     = 46
	PCREParserPreviousMatchInSubject           = 47
	PCREParserResetStartMatch                  = 48
	PCREParserSubroutineOrNamedReferenceStartG = 49
	PCREParserNamedReferenceStartK             = 50
	PCREParserPipe                             = 51
	PCREParserOpenParen                        = 52
	PCREParserCloseParen                       = 53
	PCREParserLessThan                         = 54
	PCREParserGreaterThan                      = 55
	PCREParserSingleQuote                      = 56
	PCREParserUnderscore                       = 57
	PCREParserColon                            = 58
	PCREParserHash                             = 59
	PCREParserEquals                           = 60
	PCREParserExclamation                      = 61
	PCREParserAmpersand                        = 62
	PCREParserALC                              = 63
	PCREParserBLC                              = 64
	PCREParserCLC                              = 65
	PCREParserDLC                              = 66
	PCREParserELC                              = 67
	PCREParserFLC                              = 68
	PCREParserGLC                              = 69
	PCREParserHLC                              = 70
	PCREParserILC                              = 71
	PCREParserJLC                              = 72
	PCREParserKLC                              = 73
	PCREParserLLC                              = 74
	PCREParserMLC                              = 75
	PCREParserNLC                              = 76
	PCREParserOLC                              = 77
	PCREParserPLC                              = 78
	PCREParserQLC                              = 79
	PCREParserRLC                              = 80
	PCREParserSLC                              = 81
	PCREParserTLC                              = 82
	PCREParserULC                              = 83
	PCREParserVLC                              = 84
	PCREParserWLC                              = 85
	PCREParserXLC                              = 86
	PCREParserYLC                              = 87
	PCREParserZLC                              = 88
	PCREParserAUC                              = 89
	PCREParserBUC                              = 90
	PCREParserCUC                              = 91
	PCREParserDUC                              = 92
	PCREParserEUC                              = 93
	PCREParserFUC                              = 94
	PCREParserGUC                              = 95
	PCREParserHUC                              = 96
	PCREParserIUC                              = 97
	PCREParserJUC                              = 98
	PCREParserKUC                              = 99
	PCREParserLUC                              = 100
	PCREParserMUC                              = 101
	PCREParserNUC                              = 102
	PCREParserOUC                              = 103
	PCREParserPUC                              = 104
	PCREParserQUC                              = 105
	PCREParserRUC                              = 106
	PCREParserSUC                              = 107
	PCREParserTUC                              = 108
	PCREParserUUC                              = 109
	PCREParserVUC                              = 110
	PCREParserWUC                              = 111
	PCREParserXUC                              = 112
	PCREParserYUC                              = 113
	PCREParserZUC                              = 114
	PCREParserD1                               = 115
	PCREParserD2                               = 116
	PCREParserD3                               = 117
	PCREParserD4                               = 118
	PCREParserD5                               = 119
	PCREParserD6                               = 120
	PCREParserD7                               = 121
	PCREParserD8                               = 122
	PCREParserD9                               = 123
	PCREParserD0                               = 124
	PCREParserOtherChar                        = 125
)

// PCREParser rules.
const (
	PCREParserRULE_parse                  = 0
	PCREParserRULE_alternation            = 1
	PCREParserRULE_expr                   = 2
	PCREParserRULE_element                = 3
	PCREParserRULE_quantifier             = 4
	PCREParserRULE_quantifier_type        = 5
	PCREParserRULE_character_class        = 6
	PCREParserRULE_backreference          = 7
	PCREParserRULE_backreference_or_octal = 8
	PCREParserRULE_capture                = 9
	PCREParserRULE_non_capture            = 10
	PCREParserRULE_comment                = 11
	PCREParserRULE_option                 = 12
	PCREParserRULE_option_flags           = 13
	PCREParserRULE_option_flag            = 14
	PCREParserRULE_look_around            = 15
	PCREParserRULE_subroutine_reference   = 16
	PCREParserRULE_conditional            = 17
	PCREParserRULE_backtrack_control      = 18
	PCREParserRULE_newline_convention     = 19
	PCREParserRULE_callout                = 20
	PCREParserRULE_atom                   = 21
	PCREParserRULE_cc_atom                = 22
	PCREParserRULE_shared_atom            = 23
	PCREParserRULE_literal                = 24
	PCREParserRULE_cc_literal             = 25
	PCREParserRULE_shared_literal         = 26
	PCREParserRULE_number                 = 27
	PCREParserRULE_octal_char             = 28
	PCREParserRULE_octal_digit            = 29
	PCREParserRULE_digits                 = 30
	PCREParserRULE_digit                  = 31
	PCREParserRULE_name                   = 32
	PCREParserRULE_alpha_nums             = 33
	PCREParserRULE_non_close_parens       = 34
	PCREParserRULE_non_close_paren        = 35
	PCREParserRULE_letter                 = 36
)

// IParseContext is an interface to support dynamic dispatch.
type IParseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParseContext differentiates from other interfaces.
	IsParseContext()
}

type ParseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParseContext() *ParseContext {
	var p = new(ParseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PCREParserRULE_parse
	return p
}

func (*ParseContext) IsParseContext() {}

func NewParseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParseContext {
	var p = new(ParseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_parse

	return p
}

func (s *ParseContext) GetParser() antlr.Parser { return s.parser }

func (s *ParseContext) Alternation() IAlternationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlternationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlternationContext)
}

func (s *ParseContext) EOF() antlr.TerminalNode {
	return s.GetToken(PCREParserEOF, 0)
}

func (s *ParseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterParse(s)
	}
}

func (s *ParseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitParse(s)
	}
}

func (p *PCREParser) Parse() (localctx IParseContext) {
	this := p
	_ = this

	localctx = NewParseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, PCREParserRULE_parse)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(74)
		p.Alternation()
	}
	{
		p.SetState(75)
		p.Match(PCREParserEOF)
	}

	return localctx
}

// IAlternationContext is an interface to support dynamic dispatch.
type IAlternationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlternationContext differentiates from other interfaces.
	IsAlternationContext()
}

type AlternationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlternationContext() *AlternationContext {
	var p = new(AlternationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PCREParserRULE_alternation
	return p
}

func (*AlternationContext) IsAlternationContext() {}

func NewAlternationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlternationContext {
	var p = new(AlternationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_alternation

	return p
}

func (s *AlternationContext) GetParser() antlr.Parser { return s.parser }

func (s *AlternationContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *AlternationContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *AlternationContext) AllPipe() []antlr.TerminalNode {
	return s.GetTokens(PCREParserPipe)
}

func (s *AlternationContext) Pipe(i int) antlr.TerminalNode {
	return s.GetToken(PCREParserPipe, i)
}

func (s *AlternationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlternationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlternationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterAlternation(s)
	}
}

func (s *AlternationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitAlternation(s)
	}
}

func (p *PCREParser) Alternation() (localctx IAlternationContext) {
	this := p
	_ = this

	localctx = NewAlternationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, PCREParserRULE_alternation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(77)
		p.Expr()
	}
	p.SetState(82)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 0, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(78)
				p.Match(PCREParserPipe)
			}
			{
				p.SetState(79)
				p.Expr()
			}

		}
		p.SetState(84)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 0, p.GetParserRuleContext())
	}

	return localctx
}

// IExprContext is an interface to support dynamic dispatch.
type IExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExprContext differentiates from other interfaces.
	IsExprContext()
}

type ExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprContext() *ExprContext {
	var p = new(ExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PCREParserRULE_expr
	return p
}

func (*ExprContext) IsExprContext() {}

func NewExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprContext {
	var p = new(ExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_expr

	return p
}

func (s *ExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprContext) AllElement() []IElementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IElementContext)(nil)).Elem())
	var tst = make([]IElementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IElementContext)
		}
	}

	return tst
}

func (s *ExprContext) Element(i int) IElementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IElementContext)
}

func (s *ExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterExpr(s)
	}
}

func (s *ExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitExpr(s)
	}
}

func (p *PCREParser) Expr() (localctx IExprContext) {
	this := p
	_ = this

	localctx = NewExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, PCREParserRULE_expr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(88)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PCREParserQuoted)|(1<<PCREParserBlockQuoted)|(1<<PCREParserBellChar)|(1<<PCREParserControlChar)|(1<<PCREParserEscapeChar)|(1<<PCREParserFormFeed)|(1<<PCREParserNewLine)|(1<<PCREParserCarriageReturn)|(1<<PCREParserTab)|(1<<PCREParserBackslash)|(1<<PCREParserHexChar)|(1<<PCREParserDot)|(1<<PCREParserOneDataUnit)|(1<<PCREParserDecimalDigit)|(1<<PCREParserNotDecimalDigit)|(1<<PCREParserHorizontalWhiteSpace)|(1<<PCREParserNotHorizontalWhiteSpace)|(1<<PCREParserNotNewLine)|(1<<PCREParserCharWithProperty)|(1<<PCREParserCharWithoutProperty)|(1<<PCREParserNewLineSequence)|(1<<PCREParserWhiteSpace)|(1<<PCREParserNotWhiteSpace)|(1<<PCREParserVerticalWhiteSpace)|(1<<PCREParserNotVerticalWhiteSpace)|(1<<PCREParserWordChar)|(1<<PCREParserNotWordChar)|(1<<PCREParserExtendedUnicodeChar)|(1<<PCREParserCharacterClassStart)|(1<<PCREParserCharacterClassEnd)|(1<<PCREParserCaret))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(PCREParserHyphen-32))|(1<<(PCREParserPOSIXNamedSet-32))|(1<<(PCREParserPOSIXNegatedNamedSet-32))|(1<<(PCREParserOpenBrace-32))|(1<<(PCREParserCloseBrace-32))|(1<<(PCREParserComma-32))|(1<<(PCREParserWordBoundary-32))|(1<<(PCREParserNonWordBoundary-32))|(1<<(PCREParserStartOfSubject-32))|(1<<(PCREParserEndOfSubjectOrLine-32))|(1<<(PCREParserEndOfSubjectOrLineEndOfSubject-32))|(1<<(PCREParserEndOfSubject-32))|(1<<(PCREParserPreviousMatchInSubject-32))|(1<<(PCREParserResetStartMatch-32))|(1<<(PCREParserSubroutineOrNamedReferenceStartG-32))|(1<<(PCREParserNamedReferenceStartK-32))|(1<<(PCREParserOpenParen-32))|(1<<(PCREParserLessThan-32))|(1<<(PCREParserGreaterThan-32))|(1<<(PCREParserSingleQuote-32))|(1<<(PCREParserUnderscore-32))|(1<<(PCREParserColon-32))|(1<<(PCREParserHash-32))|(1<<(PCREParserEquals-32))|(1<<(PCREParserExclamation-32))|(1<<(PCREParserAmpersand-32))|(1<<(PCREParserALC-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(PCREParserBLC-64))|(1<<(PCREParserCLC-64))|(1<<(PCREParserDLC-64))|(1<<(PCREParserELC-64))|(1<<(PCREParserFLC-64))|(1<<(PCREParserGLC-64))|(1<<(PCREParserHLC-64))|(1<<(PCREParserILC-64))|(1<<(PCREParserJLC-64))|(1<<(PCREParserKLC-64))|(1<<(PCREParserLLC-64))|(1<<(PCREParserMLC-64))|(1<<(PCREParserNLC-64))|(1<<(PCREParserOLC-64))|(1<<(PCREParserPLC-64))|(1<<(PCREParserQLC-64))|(1<<(PCREParserRLC-64))|(1<<(PCREParserSLC-64))|(1<<(PCREParserTLC-64))|(1<<(PCREParserULC-64))|(1<<(PCREParserVLC-64))|(1<<(PCREParserWLC-64))|(1<<(PCREParserXLC-64))|(1<<(PCREParserYLC-64))|(1<<(PCREParserZLC-64))|(1<<(PCREParserAUC-64))|(1<<(PCREParserBUC-64))|(1<<(PCREParserCUC-64))|(1<<(PCREParserDUC-64))|(1<<(PCREParserEUC-64))|(1<<(PCREParserFUC-64))|(1<<(PCREParserGUC-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(PCREParserHUC-96))|(1<<(PCREParserIUC-96))|(1<<(PCREParserJUC-96))|(1<<(PCREParserKUC-96))|(1<<(PCREParserLUC-96))|(1<<(PCREParserMUC-96))|(1<<(PCREParserNUC-96))|(1<<(PCREParserOUC-96))|(1<<(PCREParserPUC-96))|(1<<(PCREParserQUC-96))|(1<<(PCREParserRUC-96))|(1<<(PCREParserSUC-96))|(1<<(PCREParserTUC-96))|(1<<(PCREParserUUC-96))|(1<<(PCREParserVUC-96))|(1<<(PCREParserWUC-96))|(1<<(PCREParserXUC-96))|(1<<(PCREParserYUC-96))|(1<<(PCREParserZUC-96))|(1<<(PCREParserD1-96))|(1<<(PCREParserD2-96))|(1<<(PCREParserD3-96))|(1<<(PCREParserD4-96))|(1<<(PCREParserD5-96))|(1<<(PCREParserD6-96))|(1<<(PCREParserD7-96))|(1<<(PCREParserD8-96))|(1<<(PCREParserD9-96))|(1<<(PCREParserD0-96))|(1<<(PCREParserOtherChar-96)))) != 0) {
		{
			p.SetState(85)
			p.Element()
		}

		p.SetState(90)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IElementContext is an interface to support dynamic dispatch.
type IElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElementContext differentiates from other interfaces.
	IsElementContext()
}

type ElementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementContext() *ElementContext {
	var p = new(ElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PCREParserRULE_element
	return p
}

func (*ElementContext) IsElementContext() {}

func NewElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementContext {
	var p = new(ElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_element

	return p
}

func (s *ElementContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementContext) Atom() IAtomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtomContext)
}

func (s *ElementContext) Quantifier() IQuantifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuantifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQuantifierContext)
}

func (s *ElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterElement(s)
	}
}

func (s *ElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitElement(s)
	}
}

func (p *PCREParser) Element() (localctx IElementContext) {
	this := p
	_ = this

	localctx = NewElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, PCREParserRULE_element)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(91)
		p.Atom()
	}
	p.SetState(93)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 2, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(92)
			p.Quantifier()
		}

	}

	return localctx
}

// IQuantifierContext is an interface to support dynamic dispatch.
type IQuantifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQuantifierContext differentiates from other interfaces.
	IsQuantifierContext()
}

type QuantifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuantifierContext() *QuantifierContext {
	var p = new(QuantifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PCREParserRULE_quantifier
	return p
}

func (*QuantifierContext) IsQuantifierContext() {}

func NewQuantifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuantifierContext {
	var p = new(QuantifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_quantifier

	return p
}

func (s *QuantifierContext) GetParser() antlr.Parser { return s.parser }

func (s *QuantifierContext) QuestionMark() antlr.TerminalNode {
	return s.GetToken(PCREParserQuestionMark, 0)
}

func (s *QuantifierContext) Quantifier_type() IQuantifier_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuantifier_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQuantifier_typeContext)
}

func (s *QuantifierContext) Plus() antlr.TerminalNode {
	return s.GetToken(PCREParserPlus, 0)
}

func (s *QuantifierContext) Star() antlr.TerminalNode {
	return s.GetToken(PCREParserStar, 0)
}

func (s *QuantifierContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(PCREParserOpenBrace, 0)
}

func (s *QuantifierContext) AllNumber() []INumberContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INumberContext)(nil)).Elem())
	var tst = make([]INumberContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INumberContext)
		}
	}

	return tst
}

func (s *QuantifierContext) Number(i int) INumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumberContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *QuantifierContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(PCREParserCloseBrace, 0)
}

func (s *QuantifierContext) Comma() antlr.TerminalNode {
	return s.GetToken(PCREParserComma, 0)
}

func (s *QuantifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuantifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QuantifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterQuantifier(s)
	}
}

func (s *QuantifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitQuantifier(s)
	}
}

func (p *PCREParser) Quantifier() (localctx IQuantifierContext) {
	this := p
	_ = this

	localctx = NewQuantifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, PCREParserRULE_quantifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(119)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 3, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(95)
			p.Match(PCREParserQuestionMark)
		}
		{
			p.SetState(96)
			p.Quantifier_type()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(97)
			p.Match(PCREParserPlus)
		}
		{
			p.SetState(98)
			p.Quantifier_type()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(99)
			p.Match(PCREParserStar)
		}
		{
			p.SetState(100)
			p.Quantifier_type()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(101)
			p.Match(PCREParserOpenBrace)
		}
		{
			p.SetState(102)
			p.Number()
		}
		{
			p.SetState(103)
			p.Match(PCREParserCloseBrace)
		}
		{
			p.SetState(104)
			p.Quantifier_type()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(106)
			p.Match(PCREParserOpenBrace)
		}
		{
			p.SetState(107)
			p.Number()
		}
		{
			p.SetState(108)
			p.Match(PCREParserComma)
		}
		{
			p.SetState(109)
			p.Match(PCREParserCloseBrace)
		}
		{
			p.SetState(110)
			p.Quantifier_type()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(112)
			p.Match(PCREParserOpenBrace)
		}
		{
			p.SetState(113)
			p.Number()
		}
		{
			p.SetState(114)
			p.Match(PCREParserComma)
		}
		{
			p.SetState(115)
			p.Number()
		}
		{
			p.SetState(116)
			p.Match(PCREParserCloseBrace)
		}
		{
			p.SetState(117)
			p.Quantifier_type()
		}

	}

	return localctx
}

// IQuantifier_typeContext is an interface to support dynamic dispatch.
type IQuantifier_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQuantifier_typeContext differentiates from other interfaces.
	IsQuantifier_typeContext()
}

type Quantifier_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuantifier_typeContext() *Quantifier_typeContext {
	var p = new(Quantifier_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PCREParserRULE_quantifier_type
	return p
}

func (*Quantifier_typeContext) IsQuantifier_typeContext() {}

func NewQuantifier_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Quantifier_typeContext {
	var p = new(Quantifier_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_quantifier_type

	return p
}

func (s *Quantifier_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Quantifier_typeContext) Plus() antlr.TerminalNode {
	return s.GetToken(PCREParserPlus, 0)
}

func (s *Quantifier_typeContext) QuestionMark() antlr.TerminalNode {
	return s.GetToken(PCREParserQuestionMark, 0)
}

func (s *Quantifier_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Quantifier_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Quantifier_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterQuantifier_type(s)
	}
}

func (s *Quantifier_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitQuantifier_type(s)
	}
}

func (p *PCREParser) Quantifier_type() (localctx IQuantifier_typeContext) {
	this := p
	_ = this

	localctx = NewQuantifier_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, PCREParserRULE_quantifier_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(124)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PCREParserPlus:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(121)
			p.Match(PCREParserPlus)
		}

	case PCREParserQuestionMark:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(122)
			p.Match(PCREParserQuestionMark)
		}

	case PCREParserEOF, PCREParserQuoted, PCREParserBlockQuoted, PCREParserBellChar, PCREParserControlChar, PCREParserEscapeChar, PCREParserFormFeed, PCREParserNewLine, PCREParserCarriageReturn, PCREParserTab, PCREParserBackslash, PCREParserHexChar, PCREParserDot, PCREParserOneDataUnit, PCREParserDecimalDigit, PCREParserNotDecimalDigit, PCREParserHorizontalWhiteSpace, PCREParserNotHorizontalWhiteSpace, PCREParserNotNewLine, PCREParserCharWithProperty, PCREParserCharWithoutProperty, PCREParserNewLineSequence, PCREParserWhiteSpace, PCREParserNotWhiteSpace, PCREParserVerticalWhiteSpace, PCREParserNotVerticalWhiteSpace, PCREParserWordChar, PCREParserNotWordChar, PCREParserExtendedUnicodeChar, PCREParserCharacterClassStart, PCREParserCharacterClassEnd, PCREParserCaret, PCREParserHyphen, PCREParserPOSIXNamedSet, PCREParserPOSIXNegatedNamedSet, PCREParserOpenBrace, PCREParserCloseBrace, PCREParserComma, PCREParserWordBoundary, PCREParserNonWordBoundary, PCREParserStartOfSubject, PCREParserEndOfSubjectOrLine, PCREParserEndOfSubjectOrLineEndOfSubject, PCREParserEndOfSubject, PCREParserPreviousMatchInSubject, PCREParserResetStartMatch, PCREParserSubroutineOrNamedReferenceStartG, PCREParserNamedReferenceStartK, PCREParserPipe, PCREParserOpenParen, PCREParserCloseParen, PCREParserLessThan, PCREParserGreaterThan, PCREParserSingleQuote, PCREParserUnderscore, PCREParserColon, PCREParserHash, PCREParserEquals, PCREParserExclamation, PCREParserAmpersand, PCREParserALC, PCREParserBLC, PCREParserCLC, PCREParserDLC, PCREParserELC, PCREParserFLC, PCREParserGLC, PCREParserHLC, PCREParserILC, PCREParserJLC, PCREParserKLC, PCREParserLLC, PCREParserMLC, PCREParserNLC, PCREParserOLC, PCREParserPLC, PCREParserQLC, PCREParserRLC, PCREParserSLC, PCREParserTLC, PCREParserULC, PCREParserVLC, PCREParserWLC, PCREParserXLC, PCREParserYLC, PCREParserZLC, PCREParserAUC, PCREParserBUC, PCREParserCUC, PCREParserDUC, PCREParserEUC, PCREParserFUC, PCREParserGUC, PCREParserHUC, PCREParserIUC, PCREParserJUC, PCREParserKUC, PCREParserLUC, PCREParserMUC, PCREParserNUC, PCREParserOUC, PCREParserPUC, PCREParserQUC, PCREParserRUC, PCREParserSUC, PCREParserTUC, PCREParserUUC, PCREParserVUC, PCREParserWUC, PCREParserXUC, PCREParserYUC, PCREParserZUC, PCREParserD1, PCREParserD2, PCREParserD3, PCREParserD4, PCREParserD5, PCREParserD6, PCREParserD7, PCREParserD8, PCREParserD9, PCREParserD0, PCREParserOtherChar:
		p.EnterOuterAlt(localctx, 3)

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICharacter_classContext is an interface to support dynamic dispatch.
type ICharacter_classContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCharacter_classContext differentiates from other interfaces.
	IsCharacter_classContext()
}

type Character_classContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharacter_classContext() *Character_classContext {
	var p = new(Character_classContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PCREParserRULE_character_class
	return p
}

func (*Character_classContext) IsCharacter_classContext() {}

func NewCharacter_classContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Character_classContext {
	var p = new(Character_classContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_character_class

	return p
}

func (s *Character_classContext) GetParser() antlr.Parser { return s.parser }

func (s *Character_classContext) CharacterClassStart() antlr.TerminalNode {
	return s.GetToken(PCREParserCharacterClassStart, 0)
}

func (s *Character_classContext) Caret() antlr.TerminalNode {
	return s.GetToken(PCREParserCaret, 0)
}

func (s *Character_classContext) AllCharacterClassEnd() []antlr.TerminalNode {
	return s.GetTokens(PCREParserCharacterClassEnd)
}

func (s *Character_classContext) CharacterClassEnd(i int) antlr.TerminalNode {
	return s.GetToken(PCREParserCharacterClassEnd, i)
}

func (s *Character_classContext) Hyphen() antlr.TerminalNode {
	return s.GetToken(PCREParserHyphen, 0)
}

func (s *Character_classContext) AllCc_atom() []ICc_atomContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICc_atomContext)(nil)).Elem())
	var tst = make([]ICc_atomContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICc_atomContext)
		}
	}

	return tst
}

func (s *Character_classContext) Cc_atom(i int) ICc_atomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICc_atomContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICc_atomContext)
}

func (s *Character_classContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Character_classContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Character_classContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterCharacter_class(s)
	}
}

func (s *Character_classContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitCharacter_class(s)
	}
}

func (p *PCREParser) Character_class() (localctx ICharacter_classContext) {
	this := p
	_ = this

	localctx = NewCharacter_classContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, PCREParserRULE_character_class)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(183)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 11, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(126)
			p.Match(PCREParserCharacterClassStart)
		}
		{
			p.SetState(127)
			p.Match(PCREParserCaret)
		}
		{
			p.SetState(128)
			p.Match(PCREParserCharacterClassEnd)
		}
		{
			p.SetState(129)
			p.Match(PCREParserHyphen)
		}
		p.SetState(131)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PCREParserQuoted)|(1<<PCREParserBlockQuoted)|(1<<PCREParserBellChar)|(1<<PCREParserControlChar)|(1<<PCREParserEscapeChar)|(1<<PCREParserFormFeed)|(1<<PCREParserNewLine)|(1<<PCREParserCarriageReturn)|(1<<PCREParserTab)|(1<<PCREParserBackslash)|(1<<PCREParserHexChar)|(1<<PCREParserDot)|(1<<PCREParserDecimalDigit)|(1<<PCREParserNotDecimalDigit)|(1<<PCREParserHorizontalWhiteSpace)|(1<<PCREParserNotHorizontalWhiteSpace)|(1<<PCREParserNotNewLine)|(1<<PCREParserCharWithProperty)|(1<<PCREParserCharWithoutProperty)|(1<<PCREParserNewLineSequence)|(1<<PCREParserWhiteSpace)|(1<<PCREParserNotWhiteSpace)|(1<<PCREParserVerticalWhiteSpace)|(1<<PCREParserNotVerticalWhiteSpace)|(1<<PCREParserWordChar)|(1<<PCREParserNotWordChar)|(1<<PCREParserCharacterClassStart)|(1<<PCREParserCaret))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(PCREParserHyphen-32))|(1<<(PCREParserPOSIXNamedSet-32))|(1<<(PCREParserPOSIXNegatedNamedSet-32))|(1<<(PCREParserQuestionMark-32))|(1<<(PCREParserPlus-32))|(1<<(PCREParserStar-32))|(1<<(PCREParserOpenBrace-32))|(1<<(PCREParserCloseBrace-32))|(1<<(PCREParserComma-32))|(1<<(PCREParserWordBoundary-32))|(1<<(PCREParserEndOfSubjectOrLine-32))|(1<<(PCREParserPipe-32))|(1<<(PCREParserOpenParen-32))|(1<<(PCREParserCloseParen-32))|(1<<(PCREParserLessThan-32))|(1<<(PCREParserGreaterThan-32))|(1<<(PCREParserSingleQuote-32))|(1<<(PCREParserUnderscore-32))|(1<<(PCREParserColon-32))|(1<<(PCREParserHash-32))|(1<<(PCREParserEquals-32))|(1<<(PCREParserExclamation-32))|(1<<(PCREParserAmpersand-32))|(1<<(PCREParserALC-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(PCREParserBLC-64))|(1<<(PCREParserCLC-64))|(1<<(PCREParserDLC-64))|(1<<(PCREParserELC-64))|(1<<(PCREParserFLC-64))|(1<<(PCREParserGLC-64))|(1<<(PCREParserHLC-64))|(1<<(PCREParserILC-64))|(1<<(PCREParserJLC-64))|(1<<(PCREParserKLC-64))|(1<<(PCREParserLLC-64))|(1<<(PCREParserMLC-64))|(1<<(PCREParserNLC-64))|(1<<(PCREParserOLC-64))|(1<<(PCREParserPLC-64))|(1<<(PCREParserQLC-64))|(1<<(PCREParserRLC-64))|(1<<(PCREParserSLC-64))|(1<<(PCREParserTLC-64))|(1<<(PCREParserULC-64))|(1<<(PCREParserVLC-64))|(1<<(PCREParserWLC-64))|(1<<(PCREParserXLC-64))|(1<<(PCREParserYLC-64))|(1<<(PCREParserZLC-64))|(1<<(PCREParserAUC-64))|(1<<(PCREParserBUC-64))|(1<<(PCREParserCUC-64))|(1<<(PCREParserDUC-64))|(1<<(PCREParserEUC-64))|(1<<(PCREParserFUC-64))|(1<<(PCREParserGUC-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(PCREParserHUC-96))|(1<<(PCREParserIUC-96))|(1<<(PCREParserJUC-96))|(1<<(PCREParserKUC-96))|(1<<(PCREParserLUC-96))|(1<<(PCREParserMUC-96))|(1<<(PCREParserNUC-96))|(1<<(PCREParserOUC-96))|(1<<(PCREParserPUC-96))|(1<<(PCREParserQUC-96))|(1<<(PCREParserRUC-96))|(1<<(PCREParserSUC-96))|(1<<(PCREParserTUC-96))|(1<<(PCREParserUUC-96))|(1<<(PCREParserVUC-96))|(1<<(PCREParserWUC-96))|(1<<(PCREParserXUC-96))|(1<<(PCREParserYUC-96))|(1<<(PCREParserZUC-96))|(1<<(PCREParserD1-96))|(1<<(PCREParserD2-96))|(1<<(PCREParserD3-96))|(1<<(PCREParserD4-96))|(1<<(PCREParserD5-96))|(1<<(PCREParserD6-96))|(1<<(PCREParserD7-96))|(1<<(PCREParserD8-96))|(1<<(PCREParserD9-96))|(1<<(PCREParserD0-96))|(1<<(PCREParserOtherChar-96)))) != 0) {
			{
				p.SetState(130)
				p.Cc_atom()
			}

			p.SetState(133)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(135)
			p.Match(PCREParserCharacterClassEnd)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(137)
			p.Match(PCREParserCharacterClassStart)
		}
		{
			p.SetState(138)
			p.Match(PCREParserCaret)
		}
		{
			p.SetState(139)
			p.Match(PCREParserCharacterClassEnd)
		}
		p.SetState(143)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PCREParserQuoted)|(1<<PCREParserBlockQuoted)|(1<<PCREParserBellChar)|(1<<PCREParserControlChar)|(1<<PCREParserEscapeChar)|(1<<PCREParserFormFeed)|(1<<PCREParserNewLine)|(1<<PCREParserCarriageReturn)|(1<<PCREParserTab)|(1<<PCREParserBackslash)|(1<<PCREParserHexChar)|(1<<PCREParserDot)|(1<<PCREParserDecimalDigit)|(1<<PCREParserNotDecimalDigit)|(1<<PCREParserHorizontalWhiteSpace)|(1<<PCREParserNotHorizontalWhiteSpace)|(1<<PCREParserNotNewLine)|(1<<PCREParserCharWithProperty)|(1<<PCREParserCharWithoutProperty)|(1<<PCREParserNewLineSequence)|(1<<PCREParserWhiteSpace)|(1<<PCREParserNotWhiteSpace)|(1<<PCREParserVerticalWhiteSpace)|(1<<PCREParserNotVerticalWhiteSpace)|(1<<PCREParserWordChar)|(1<<PCREParserNotWordChar)|(1<<PCREParserCharacterClassStart)|(1<<PCREParserCaret))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(PCREParserHyphen-32))|(1<<(PCREParserPOSIXNamedSet-32))|(1<<(PCREParserPOSIXNegatedNamedSet-32))|(1<<(PCREParserQuestionMark-32))|(1<<(PCREParserPlus-32))|(1<<(PCREParserStar-32))|(1<<(PCREParserOpenBrace-32))|(1<<(PCREParserCloseBrace-32))|(1<<(PCREParserComma-32))|(1<<(PCREParserWordBoundary-32))|(1<<(PCREParserEndOfSubjectOrLine-32))|(1<<(PCREParserPipe-32))|(1<<(PCREParserOpenParen-32))|(1<<(PCREParserCloseParen-32))|(1<<(PCREParserLessThan-32))|(1<<(PCREParserGreaterThan-32))|(1<<(PCREParserSingleQuote-32))|(1<<(PCREParserUnderscore-32))|(1<<(PCREParserColon-32))|(1<<(PCREParserHash-32))|(1<<(PCREParserEquals-32))|(1<<(PCREParserExclamation-32))|(1<<(PCREParserAmpersand-32))|(1<<(PCREParserALC-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(PCREParserBLC-64))|(1<<(PCREParserCLC-64))|(1<<(PCREParserDLC-64))|(1<<(PCREParserELC-64))|(1<<(PCREParserFLC-64))|(1<<(PCREParserGLC-64))|(1<<(PCREParserHLC-64))|(1<<(PCREParserILC-64))|(1<<(PCREParserJLC-64))|(1<<(PCREParserKLC-64))|(1<<(PCREParserLLC-64))|(1<<(PCREParserMLC-64))|(1<<(PCREParserNLC-64))|(1<<(PCREParserOLC-64))|(1<<(PCREParserPLC-64))|(1<<(PCREParserQLC-64))|(1<<(PCREParserRLC-64))|(1<<(PCREParserSLC-64))|(1<<(PCREParserTLC-64))|(1<<(PCREParserULC-64))|(1<<(PCREParserVLC-64))|(1<<(PCREParserWLC-64))|(1<<(PCREParserXLC-64))|(1<<(PCREParserYLC-64))|(1<<(PCREParserZLC-64))|(1<<(PCREParserAUC-64))|(1<<(PCREParserBUC-64))|(1<<(PCREParserCUC-64))|(1<<(PCREParserDUC-64))|(1<<(PCREParserEUC-64))|(1<<(PCREParserFUC-64))|(1<<(PCREParserGUC-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(PCREParserHUC-96))|(1<<(PCREParserIUC-96))|(1<<(PCREParserJUC-96))|(1<<(PCREParserKUC-96))|(1<<(PCREParserLUC-96))|(1<<(PCREParserMUC-96))|(1<<(PCREParserNUC-96))|(1<<(PCREParserOUC-96))|(1<<(PCREParserPUC-96))|(1<<(PCREParserQUC-96))|(1<<(PCREParserRUC-96))|(1<<(PCREParserSUC-96))|(1<<(PCREParserTUC-96))|(1<<(PCREParserUUC-96))|(1<<(PCREParserVUC-96))|(1<<(PCREParserWUC-96))|(1<<(PCREParserXUC-96))|(1<<(PCREParserYUC-96))|(1<<(PCREParserZUC-96))|(1<<(PCREParserD1-96))|(1<<(PCREParserD2-96))|(1<<(PCREParserD3-96))|(1<<(PCREParserD4-96))|(1<<(PCREParserD5-96))|(1<<(PCREParserD6-96))|(1<<(PCREParserD7-96))|(1<<(PCREParserD8-96))|(1<<(PCREParserD9-96))|(1<<(PCREParserD0-96))|(1<<(PCREParserOtherChar-96)))) != 0) {
			{
				p.SetState(140)
				p.Cc_atom()
			}

			p.SetState(145)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(146)
			p.Match(PCREParserCharacterClassEnd)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(147)
			p.Match(PCREParserCharacterClassStart)
		}
		{
			p.SetState(148)
			p.Match(PCREParserCaret)
		}
		p.SetState(150)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PCREParserQuoted)|(1<<PCREParserBlockQuoted)|(1<<PCREParserBellChar)|(1<<PCREParserControlChar)|(1<<PCREParserEscapeChar)|(1<<PCREParserFormFeed)|(1<<PCREParserNewLine)|(1<<PCREParserCarriageReturn)|(1<<PCREParserTab)|(1<<PCREParserBackslash)|(1<<PCREParserHexChar)|(1<<PCREParserDot)|(1<<PCREParserDecimalDigit)|(1<<PCREParserNotDecimalDigit)|(1<<PCREParserHorizontalWhiteSpace)|(1<<PCREParserNotHorizontalWhiteSpace)|(1<<PCREParserNotNewLine)|(1<<PCREParserCharWithProperty)|(1<<PCREParserCharWithoutProperty)|(1<<PCREParserNewLineSequence)|(1<<PCREParserWhiteSpace)|(1<<PCREParserNotWhiteSpace)|(1<<PCREParserVerticalWhiteSpace)|(1<<PCREParserNotVerticalWhiteSpace)|(1<<PCREParserWordChar)|(1<<PCREParserNotWordChar)|(1<<PCREParserCharacterClassStart)|(1<<PCREParserCaret))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(PCREParserHyphen-32))|(1<<(PCREParserPOSIXNamedSet-32))|(1<<(PCREParserPOSIXNegatedNamedSet-32))|(1<<(PCREParserQuestionMark-32))|(1<<(PCREParserPlus-32))|(1<<(PCREParserStar-32))|(1<<(PCREParserOpenBrace-32))|(1<<(PCREParserCloseBrace-32))|(1<<(PCREParserComma-32))|(1<<(PCREParserWordBoundary-32))|(1<<(PCREParserEndOfSubjectOrLine-32))|(1<<(PCREParserPipe-32))|(1<<(PCREParserOpenParen-32))|(1<<(PCREParserCloseParen-32))|(1<<(PCREParserLessThan-32))|(1<<(PCREParserGreaterThan-32))|(1<<(PCREParserSingleQuote-32))|(1<<(PCREParserUnderscore-32))|(1<<(PCREParserColon-32))|(1<<(PCREParserHash-32))|(1<<(PCREParserEquals-32))|(1<<(PCREParserExclamation-32))|(1<<(PCREParserAmpersand-32))|(1<<(PCREParserALC-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(PCREParserBLC-64))|(1<<(PCREParserCLC-64))|(1<<(PCREParserDLC-64))|(1<<(PCREParserELC-64))|(1<<(PCREParserFLC-64))|(1<<(PCREParserGLC-64))|(1<<(PCREParserHLC-64))|(1<<(PCREParserILC-64))|(1<<(PCREParserJLC-64))|(1<<(PCREParserKLC-64))|(1<<(PCREParserLLC-64))|(1<<(PCREParserMLC-64))|(1<<(PCREParserNLC-64))|(1<<(PCREParserOLC-64))|(1<<(PCREParserPLC-64))|(1<<(PCREParserQLC-64))|(1<<(PCREParserRLC-64))|(1<<(PCREParserSLC-64))|(1<<(PCREParserTLC-64))|(1<<(PCREParserULC-64))|(1<<(PCREParserVLC-64))|(1<<(PCREParserWLC-64))|(1<<(PCREParserXLC-64))|(1<<(PCREParserYLC-64))|(1<<(PCREParserZLC-64))|(1<<(PCREParserAUC-64))|(1<<(PCREParserBUC-64))|(1<<(PCREParserCUC-64))|(1<<(PCREParserDUC-64))|(1<<(PCREParserEUC-64))|(1<<(PCREParserFUC-64))|(1<<(PCREParserGUC-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(PCREParserHUC-96))|(1<<(PCREParserIUC-96))|(1<<(PCREParserJUC-96))|(1<<(PCREParserKUC-96))|(1<<(PCREParserLUC-96))|(1<<(PCREParserMUC-96))|(1<<(PCREParserNUC-96))|(1<<(PCREParserOUC-96))|(1<<(PCREParserPUC-96))|(1<<(PCREParserQUC-96))|(1<<(PCREParserRUC-96))|(1<<(PCREParserSUC-96))|(1<<(PCREParserTUC-96))|(1<<(PCREParserUUC-96))|(1<<(PCREParserVUC-96))|(1<<(PCREParserWUC-96))|(1<<(PCREParserXUC-96))|(1<<(PCREParserYUC-96))|(1<<(PCREParserZUC-96))|(1<<(PCREParserD1-96))|(1<<(PCREParserD2-96))|(1<<(PCREParserD3-96))|(1<<(PCREParserD4-96))|(1<<(PCREParserD5-96))|(1<<(PCREParserD6-96))|(1<<(PCREParserD7-96))|(1<<(PCREParserD8-96))|(1<<(PCREParserD9-96))|(1<<(PCREParserD0-96))|(1<<(PCREParserOtherChar-96)))) != 0) {
			{
				p.SetState(149)
				p.Cc_atom()
			}

			p.SetState(152)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(154)
			p.Match(PCREParserCharacterClassEnd)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(156)
			p.Match(PCREParserCharacterClassStart)
		}
		{
			p.SetState(157)
			p.Match(PCREParserCharacterClassEnd)
		}
		{
			p.SetState(158)
			p.Match(PCREParserHyphen)
		}
		p.SetState(160)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PCREParserQuoted)|(1<<PCREParserBlockQuoted)|(1<<PCREParserBellChar)|(1<<PCREParserControlChar)|(1<<PCREParserEscapeChar)|(1<<PCREParserFormFeed)|(1<<PCREParserNewLine)|(1<<PCREParserCarriageReturn)|(1<<PCREParserTab)|(1<<PCREParserBackslash)|(1<<PCREParserHexChar)|(1<<PCREParserDot)|(1<<PCREParserDecimalDigit)|(1<<PCREParserNotDecimalDigit)|(1<<PCREParserHorizontalWhiteSpace)|(1<<PCREParserNotHorizontalWhiteSpace)|(1<<PCREParserNotNewLine)|(1<<PCREParserCharWithProperty)|(1<<PCREParserCharWithoutProperty)|(1<<PCREParserNewLineSequence)|(1<<PCREParserWhiteSpace)|(1<<PCREParserNotWhiteSpace)|(1<<PCREParserVerticalWhiteSpace)|(1<<PCREParserNotVerticalWhiteSpace)|(1<<PCREParserWordChar)|(1<<PCREParserNotWordChar)|(1<<PCREParserCharacterClassStart)|(1<<PCREParserCaret))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(PCREParserHyphen-32))|(1<<(PCREParserPOSIXNamedSet-32))|(1<<(PCREParserPOSIXNegatedNamedSet-32))|(1<<(PCREParserQuestionMark-32))|(1<<(PCREParserPlus-32))|(1<<(PCREParserStar-32))|(1<<(PCREParserOpenBrace-32))|(1<<(PCREParserCloseBrace-32))|(1<<(PCREParserComma-32))|(1<<(PCREParserWordBoundary-32))|(1<<(PCREParserEndOfSubjectOrLine-32))|(1<<(PCREParserPipe-32))|(1<<(PCREParserOpenParen-32))|(1<<(PCREParserCloseParen-32))|(1<<(PCREParserLessThan-32))|(1<<(PCREParserGreaterThan-32))|(1<<(PCREParserSingleQuote-32))|(1<<(PCREParserUnderscore-32))|(1<<(PCREParserColon-32))|(1<<(PCREParserHash-32))|(1<<(PCREParserEquals-32))|(1<<(PCREParserExclamation-32))|(1<<(PCREParserAmpersand-32))|(1<<(PCREParserALC-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(PCREParserBLC-64))|(1<<(PCREParserCLC-64))|(1<<(PCREParserDLC-64))|(1<<(PCREParserELC-64))|(1<<(PCREParserFLC-64))|(1<<(PCREParserGLC-64))|(1<<(PCREParserHLC-64))|(1<<(PCREParserILC-64))|(1<<(PCREParserJLC-64))|(1<<(PCREParserKLC-64))|(1<<(PCREParserLLC-64))|(1<<(PCREParserMLC-64))|(1<<(PCREParserNLC-64))|(1<<(PCREParserOLC-64))|(1<<(PCREParserPLC-64))|(1<<(PCREParserQLC-64))|(1<<(PCREParserRLC-64))|(1<<(PCREParserSLC-64))|(1<<(PCREParserTLC-64))|(1<<(PCREParserULC-64))|(1<<(PCREParserVLC-64))|(1<<(PCREParserWLC-64))|(1<<(PCREParserXLC-64))|(1<<(PCREParserYLC-64))|(1<<(PCREParserZLC-64))|(1<<(PCREParserAUC-64))|(1<<(PCREParserBUC-64))|(1<<(PCREParserCUC-64))|(1<<(PCREParserDUC-64))|(1<<(PCREParserEUC-64))|(1<<(PCREParserFUC-64))|(1<<(PCREParserGUC-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(PCREParserHUC-96))|(1<<(PCREParserIUC-96))|(1<<(PCREParserJUC-96))|(1<<(PCREParserKUC-96))|(1<<(PCREParserLUC-96))|(1<<(PCREParserMUC-96))|(1<<(PCREParserNUC-96))|(1<<(PCREParserOUC-96))|(1<<(PCREParserPUC-96))|(1<<(PCREParserQUC-96))|(1<<(PCREParserRUC-96))|(1<<(PCREParserSUC-96))|(1<<(PCREParserTUC-96))|(1<<(PCREParserUUC-96))|(1<<(PCREParserVUC-96))|(1<<(PCREParserWUC-96))|(1<<(PCREParserXUC-96))|(1<<(PCREParserYUC-96))|(1<<(PCREParserZUC-96))|(1<<(PCREParserD1-96))|(1<<(PCREParserD2-96))|(1<<(PCREParserD3-96))|(1<<(PCREParserD4-96))|(1<<(PCREParserD5-96))|(1<<(PCREParserD6-96))|(1<<(PCREParserD7-96))|(1<<(PCREParserD8-96))|(1<<(PCREParserD9-96))|(1<<(PCREParserD0-96))|(1<<(PCREParserOtherChar-96)))) != 0) {
			{
				p.SetState(159)
				p.Cc_atom()
			}

			p.SetState(162)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(164)
			p.Match(PCREParserCharacterClassEnd)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(166)
			p.Match(PCREParserCharacterClassStart)
		}
		{
			p.SetState(167)
			p.Match(PCREParserCharacterClassEnd)
		}
		p.SetState(171)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PCREParserQuoted)|(1<<PCREParserBlockQuoted)|(1<<PCREParserBellChar)|(1<<PCREParserControlChar)|(1<<PCREParserEscapeChar)|(1<<PCREParserFormFeed)|(1<<PCREParserNewLine)|(1<<PCREParserCarriageReturn)|(1<<PCREParserTab)|(1<<PCREParserBackslash)|(1<<PCREParserHexChar)|(1<<PCREParserDot)|(1<<PCREParserDecimalDigit)|(1<<PCREParserNotDecimalDigit)|(1<<PCREParserHorizontalWhiteSpace)|(1<<PCREParserNotHorizontalWhiteSpace)|(1<<PCREParserNotNewLine)|(1<<PCREParserCharWithProperty)|(1<<PCREParserCharWithoutProperty)|(1<<PCREParserNewLineSequence)|(1<<PCREParserWhiteSpace)|(1<<PCREParserNotWhiteSpace)|(1<<PCREParserVerticalWhiteSpace)|(1<<PCREParserNotVerticalWhiteSpace)|(1<<PCREParserWordChar)|(1<<PCREParserNotWordChar)|(1<<PCREParserCharacterClassStart)|(1<<PCREParserCaret))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(PCREParserHyphen-32))|(1<<(PCREParserPOSIXNamedSet-32))|(1<<(PCREParserPOSIXNegatedNamedSet-32))|(1<<(PCREParserQuestionMark-32))|(1<<(PCREParserPlus-32))|(1<<(PCREParserStar-32))|(1<<(PCREParserOpenBrace-32))|(1<<(PCREParserCloseBrace-32))|(1<<(PCREParserComma-32))|(1<<(PCREParserWordBoundary-32))|(1<<(PCREParserEndOfSubjectOrLine-32))|(1<<(PCREParserPipe-32))|(1<<(PCREParserOpenParen-32))|(1<<(PCREParserCloseParen-32))|(1<<(PCREParserLessThan-32))|(1<<(PCREParserGreaterThan-32))|(1<<(PCREParserSingleQuote-32))|(1<<(PCREParserUnderscore-32))|(1<<(PCREParserColon-32))|(1<<(PCREParserHash-32))|(1<<(PCREParserEquals-32))|(1<<(PCREParserExclamation-32))|(1<<(PCREParserAmpersand-32))|(1<<(PCREParserALC-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(PCREParserBLC-64))|(1<<(PCREParserCLC-64))|(1<<(PCREParserDLC-64))|(1<<(PCREParserELC-64))|(1<<(PCREParserFLC-64))|(1<<(PCREParserGLC-64))|(1<<(PCREParserHLC-64))|(1<<(PCREParserILC-64))|(1<<(PCREParserJLC-64))|(1<<(PCREParserKLC-64))|(1<<(PCREParserLLC-64))|(1<<(PCREParserMLC-64))|(1<<(PCREParserNLC-64))|(1<<(PCREParserOLC-64))|(1<<(PCREParserPLC-64))|(1<<(PCREParserQLC-64))|(1<<(PCREParserRLC-64))|(1<<(PCREParserSLC-64))|(1<<(PCREParserTLC-64))|(1<<(PCREParserULC-64))|(1<<(PCREParserVLC-64))|(1<<(PCREParserWLC-64))|(1<<(PCREParserXLC-64))|(1<<(PCREParserYLC-64))|(1<<(PCREParserZLC-64))|(1<<(PCREParserAUC-64))|(1<<(PCREParserBUC-64))|(1<<(PCREParserCUC-64))|(1<<(PCREParserDUC-64))|(1<<(PCREParserEUC-64))|(1<<(PCREParserFUC-64))|(1<<(PCREParserGUC-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(PCREParserHUC-96))|(1<<(PCREParserIUC-96))|(1<<(PCREParserJUC-96))|(1<<(PCREParserKUC-96))|(1<<(PCREParserLUC-96))|(1<<(PCREParserMUC-96))|(1<<(PCREParserNUC-96))|(1<<(PCREParserOUC-96))|(1<<(PCREParserPUC-96))|(1<<(PCREParserQUC-96))|(1<<(PCREParserRUC-96))|(1<<(PCREParserSUC-96))|(1<<(PCREParserTUC-96))|(1<<(PCREParserUUC-96))|(1<<(PCREParserVUC-96))|(1<<(PCREParserWUC-96))|(1<<(PCREParserXUC-96))|(1<<(PCREParserYUC-96))|(1<<(PCREParserZUC-96))|(1<<(PCREParserD1-96))|(1<<(PCREParserD2-96))|(1<<(PCREParserD3-96))|(1<<(PCREParserD4-96))|(1<<(PCREParserD5-96))|(1<<(PCREParserD6-96))|(1<<(PCREParserD7-96))|(1<<(PCREParserD8-96))|(1<<(PCREParserD9-96))|(1<<(PCREParserD0-96))|(1<<(PCREParserOtherChar-96)))) != 0) {
			{
				p.SetState(168)
				p.Cc_atom()
			}

			p.SetState(173)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(174)
			p.Match(PCREParserCharacterClassEnd)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(175)
			p.Match(PCREParserCharacterClassStart)
		}
		p.SetState(177)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PCREParserQuoted)|(1<<PCREParserBlockQuoted)|(1<<PCREParserBellChar)|(1<<PCREParserControlChar)|(1<<PCREParserEscapeChar)|(1<<PCREParserFormFeed)|(1<<PCREParserNewLine)|(1<<PCREParserCarriageReturn)|(1<<PCREParserTab)|(1<<PCREParserBackslash)|(1<<PCREParserHexChar)|(1<<PCREParserDot)|(1<<PCREParserDecimalDigit)|(1<<PCREParserNotDecimalDigit)|(1<<PCREParserHorizontalWhiteSpace)|(1<<PCREParserNotHorizontalWhiteSpace)|(1<<PCREParserNotNewLine)|(1<<PCREParserCharWithProperty)|(1<<PCREParserCharWithoutProperty)|(1<<PCREParserNewLineSequence)|(1<<PCREParserWhiteSpace)|(1<<PCREParserNotWhiteSpace)|(1<<PCREParserVerticalWhiteSpace)|(1<<PCREParserNotVerticalWhiteSpace)|(1<<PCREParserWordChar)|(1<<PCREParserNotWordChar)|(1<<PCREParserCharacterClassStart)|(1<<PCREParserCaret))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(PCREParserHyphen-32))|(1<<(PCREParserPOSIXNamedSet-32))|(1<<(PCREParserPOSIXNegatedNamedSet-32))|(1<<(PCREParserQuestionMark-32))|(1<<(PCREParserPlus-32))|(1<<(PCREParserStar-32))|(1<<(PCREParserOpenBrace-32))|(1<<(PCREParserCloseBrace-32))|(1<<(PCREParserComma-32))|(1<<(PCREParserWordBoundary-32))|(1<<(PCREParserEndOfSubjectOrLine-32))|(1<<(PCREParserPipe-32))|(1<<(PCREParserOpenParen-32))|(1<<(PCREParserCloseParen-32))|(1<<(PCREParserLessThan-32))|(1<<(PCREParserGreaterThan-32))|(1<<(PCREParserSingleQuote-32))|(1<<(PCREParserUnderscore-32))|(1<<(PCREParserColon-32))|(1<<(PCREParserHash-32))|(1<<(PCREParserEquals-32))|(1<<(PCREParserExclamation-32))|(1<<(PCREParserAmpersand-32))|(1<<(PCREParserALC-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(PCREParserBLC-64))|(1<<(PCREParserCLC-64))|(1<<(PCREParserDLC-64))|(1<<(PCREParserELC-64))|(1<<(PCREParserFLC-64))|(1<<(PCREParserGLC-64))|(1<<(PCREParserHLC-64))|(1<<(PCREParserILC-64))|(1<<(PCREParserJLC-64))|(1<<(PCREParserKLC-64))|(1<<(PCREParserLLC-64))|(1<<(PCREParserMLC-64))|(1<<(PCREParserNLC-64))|(1<<(PCREParserOLC-64))|(1<<(PCREParserPLC-64))|(1<<(PCREParserQLC-64))|(1<<(PCREParserRLC-64))|(1<<(PCREParserSLC-64))|(1<<(PCREParserTLC-64))|(1<<(PCREParserULC-64))|(1<<(PCREParserVLC-64))|(1<<(PCREParserWLC-64))|(1<<(PCREParserXLC-64))|(1<<(PCREParserYLC-64))|(1<<(PCREParserZLC-64))|(1<<(PCREParserAUC-64))|(1<<(PCREParserBUC-64))|(1<<(PCREParserCUC-64))|(1<<(PCREParserDUC-64))|(1<<(PCREParserEUC-64))|(1<<(PCREParserFUC-64))|(1<<(PCREParserGUC-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(PCREParserHUC-96))|(1<<(PCREParserIUC-96))|(1<<(PCREParserJUC-96))|(1<<(PCREParserKUC-96))|(1<<(PCREParserLUC-96))|(1<<(PCREParserMUC-96))|(1<<(PCREParserNUC-96))|(1<<(PCREParserOUC-96))|(1<<(PCREParserPUC-96))|(1<<(PCREParserQUC-96))|(1<<(PCREParserRUC-96))|(1<<(PCREParserSUC-96))|(1<<(PCREParserTUC-96))|(1<<(PCREParserUUC-96))|(1<<(PCREParserVUC-96))|(1<<(PCREParserWUC-96))|(1<<(PCREParserXUC-96))|(1<<(PCREParserYUC-96))|(1<<(PCREParserZUC-96))|(1<<(PCREParserD1-96))|(1<<(PCREParserD2-96))|(1<<(PCREParserD3-96))|(1<<(PCREParserD4-96))|(1<<(PCREParserD5-96))|(1<<(PCREParserD6-96))|(1<<(PCREParserD7-96))|(1<<(PCREParserD8-96))|(1<<(PCREParserD9-96))|(1<<(PCREParserD0-96))|(1<<(PCREParserOtherChar-96)))) != 0) {
			{
				p.SetState(176)
				p.Cc_atom()
			}

			p.SetState(179)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(181)
			p.Match(PCREParserCharacterClassEnd)
		}

	}

	return localctx
}

// IBackreferenceContext is an interface to support dynamic dispatch.
type IBackreferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBackreferenceContext differentiates from other interfaces.
	IsBackreferenceContext()
}

type BackreferenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBackreferenceContext() *BackreferenceContext {
	var p = new(BackreferenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PCREParserRULE_backreference
	return p
}

func (*BackreferenceContext) IsBackreferenceContext() {}

func NewBackreferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BackreferenceContext {
	var p = new(BackreferenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_backreference

	return p
}

func (s *BackreferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *BackreferenceContext) Backreference_or_octal() IBackreference_or_octalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBackreference_or_octalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBackreference_or_octalContext)
}

func (s *BackreferenceContext) SubroutineOrNamedReferenceStartG() antlr.TerminalNode {
	return s.GetToken(PCREParserSubroutineOrNamedReferenceStartG, 0)
}

func (s *BackreferenceContext) Number() INumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *BackreferenceContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(PCREParserOpenBrace, 0)
}

func (s *BackreferenceContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(PCREParserCloseBrace, 0)
}

func (s *BackreferenceContext) Hyphen() antlr.TerminalNode {
	return s.GetToken(PCREParserHyphen, 0)
}

func (s *BackreferenceContext) NamedReferenceStartK() antlr.TerminalNode {
	return s.GetToken(PCREParserNamedReferenceStartK, 0)
}

func (s *BackreferenceContext) LessThan() antlr.TerminalNode {
	return s.GetToken(PCREParserLessThan, 0)
}

func (s *BackreferenceContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *BackreferenceContext) GreaterThan() antlr.TerminalNode {
	return s.GetToken(PCREParserGreaterThan, 0)
}

func (s *BackreferenceContext) AllSingleQuote() []antlr.TerminalNode {
	return s.GetTokens(PCREParserSingleQuote)
}

func (s *BackreferenceContext) SingleQuote(i int) antlr.TerminalNode {
	return s.GetToken(PCREParserSingleQuote, i)
}

func (s *BackreferenceContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(PCREParserOpenParen, 0)
}

func (s *BackreferenceContext) QuestionMark() antlr.TerminalNode {
	return s.GetToken(PCREParserQuestionMark, 0)
}

func (s *BackreferenceContext) PUC() antlr.TerminalNode {
	return s.GetToken(PCREParserPUC, 0)
}

func (s *BackreferenceContext) Equals() antlr.TerminalNode {
	return s.GetToken(PCREParserEquals, 0)
}

func (s *BackreferenceContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(PCREParserCloseParen, 0)
}

func (s *BackreferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BackreferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BackreferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterBackreference(s)
	}
}

func (s *BackreferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitBackreference(s)
	}
}

func (p *PCREParser) Backreference() (localctx IBackreferenceContext) {
	this := p
	_ = this

	localctx = NewBackreferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, PCREParserRULE_backreference)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(226)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 12, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(185)
			p.Backreference_or_octal()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(186)
			p.Match(PCREParserSubroutineOrNamedReferenceStartG)
		}
		{
			p.SetState(187)
			p.Number()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(188)
			p.Match(PCREParserSubroutineOrNamedReferenceStartG)
		}
		{
			p.SetState(189)
			p.Match(PCREParserOpenBrace)
		}
		{
			p.SetState(190)
			p.Number()
		}
		{
			p.SetState(191)
			p.Match(PCREParserCloseBrace)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(193)
			p.Match(PCREParserSubroutineOrNamedReferenceStartG)
		}
		{
			p.SetState(194)
			p.Match(PCREParserOpenBrace)
		}
		{
			p.SetState(195)
			p.Match(PCREParserHyphen)
		}
		{
			p.SetState(196)
			p.Number()
		}
		{
			p.SetState(197)
			p.Match(PCREParserCloseBrace)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(199)
			p.Match(PCREParserNamedReferenceStartK)
		}
		{
			p.SetState(200)
			p.Match(PCREParserLessThan)
		}
		{
			p.SetState(201)
			p.Name()
		}
		{
			p.SetState(202)
			p.Match(PCREParserGreaterThan)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(204)
			p.Match(PCREParserNamedReferenceStartK)
		}
		{
			p.SetState(205)
			p.Match(PCREParserSingleQuote)
		}
		{
			p.SetState(206)
			p.Name()
		}
		{
			p.SetState(207)
			p.Match(PCREParserSingleQuote)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(209)
			p.Match(PCREParserSubroutineOrNamedReferenceStartG)
		}
		{
			p.SetState(210)
			p.Match(PCREParserOpenBrace)
		}
		{
			p.SetState(211)
			p.Name()
		}
		{
			p.SetState(212)
			p.Match(PCREParserCloseBrace)
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(214)
			p.Match(PCREParserNamedReferenceStartK)
		}
		{
			p.SetState(215)
			p.Match(PCREParserOpenBrace)
		}
		{
			p.SetState(216)
			p.Name()
		}
		{
			p.SetState(217)
			p.Match(PCREParserCloseBrace)
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(219)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(220)
			p.Match(PCREParserQuestionMark)
		}
		{
			p.SetState(221)
			p.Match(PCREParserPUC)
		}
		{
			p.SetState(222)
			p.Match(PCREParserEquals)
		}
		{
			p.SetState(223)
			p.Name()
		}
		{
			p.SetState(224)
			p.Match(PCREParserCloseParen)
		}

	}

	return localctx
}

// IBackreference_or_octalContext is an interface to support dynamic dispatch.
type IBackreference_or_octalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBackreference_or_octalContext differentiates from other interfaces.
	IsBackreference_or_octalContext()
}

type Backreference_or_octalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBackreference_or_octalContext() *Backreference_or_octalContext {
	var p = new(Backreference_or_octalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PCREParserRULE_backreference_or_octal
	return p
}

func (*Backreference_or_octalContext) IsBackreference_or_octalContext() {}

func NewBackreference_or_octalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Backreference_or_octalContext {
	var p = new(Backreference_or_octalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_backreference_or_octal

	return p
}

func (s *Backreference_or_octalContext) GetParser() antlr.Parser { return s.parser }

func (s *Backreference_or_octalContext) Octal_char() IOctal_charContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOctal_charContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOctal_charContext)
}

func (s *Backreference_or_octalContext) Backslash() antlr.TerminalNode {
	return s.GetToken(PCREParserBackslash, 0)
}

func (s *Backreference_or_octalContext) Digit() IDigitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDigitContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDigitContext)
}

func (s *Backreference_or_octalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Backreference_or_octalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Backreference_or_octalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterBackreference_or_octal(s)
	}
}

func (s *Backreference_or_octalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitBackreference_or_octal(s)
	}
}

func (p *PCREParser) Backreference_or_octal() (localctx IBackreference_or_octalContext) {
	this := p
	_ = this

	localctx = NewBackreference_or_octalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, PCREParserRULE_backreference_or_octal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(231)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 13, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(228)
			p.Octal_char()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(229)
			p.Match(PCREParserBackslash)
		}
		{
			p.SetState(230)
			p.Digit()
		}

	}

	return localctx
}

// ICaptureContext is an interface to support dynamic dispatch.
type ICaptureContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCaptureContext differentiates from other interfaces.
	IsCaptureContext()
}

type CaptureContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaptureContext() *CaptureContext {
	var p = new(CaptureContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PCREParserRULE_capture
	return p
}

func (*CaptureContext) IsCaptureContext() {}

func NewCaptureContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaptureContext {
	var p = new(CaptureContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_capture

	return p
}

func (s *CaptureContext) GetParser() antlr.Parser { return s.parser }

func (s *CaptureContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(PCREParserOpenParen, 0)
}

func (s *CaptureContext) QuestionMark() antlr.TerminalNode {
	return s.GetToken(PCREParserQuestionMark, 0)
}

func (s *CaptureContext) LessThan() antlr.TerminalNode {
	return s.GetToken(PCREParserLessThan, 0)
}

func (s *CaptureContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *CaptureContext) GreaterThan() antlr.TerminalNode {
	return s.GetToken(PCREParserGreaterThan, 0)
}

func (s *CaptureContext) Alternation() IAlternationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlternationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlternationContext)
}

func (s *CaptureContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(PCREParserCloseParen, 0)
}

func (s *CaptureContext) AllSingleQuote() []antlr.TerminalNode {
	return s.GetTokens(PCREParserSingleQuote)
}

func (s *CaptureContext) SingleQuote(i int) antlr.TerminalNode {
	return s.GetToken(PCREParserSingleQuote, i)
}

func (s *CaptureContext) PUC() antlr.TerminalNode {
	return s.GetToken(PCREParserPUC, 0)
}

func (s *CaptureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaptureContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaptureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterCapture(s)
	}
}

func (s *CaptureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitCapture(s)
	}
}

func (p *PCREParser) Capture() (localctx ICaptureContext) {
	this := p
	_ = this

	localctx = NewCaptureContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, PCREParserRULE_capture)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(262)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 14, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(233)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(234)
			p.Match(PCREParserQuestionMark)
		}
		{
			p.SetState(235)
			p.Match(PCREParserLessThan)
		}
		{
			p.SetState(236)
			p.Name()
		}
		{
			p.SetState(237)
			p.Match(PCREParserGreaterThan)
		}
		{
			p.SetState(238)
			p.Alternation()
		}
		{
			p.SetState(239)
			p.Match(PCREParserCloseParen)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(241)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(242)
			p.Match(PCREParserQuestionMark)
		}
		{
			p.SetState(243)
			p.Match(PCREParserSingleQuote)
		}
		{
			p.SetState(244)
			p.Name()
		}
		{
			p.SetState(245)
			p.Match(PCREParserSingleQuote)
		}
		{
			p.SetState(246)
			p.Alternation()
		}
		{
			p.SetState(247)
			p.Match(PCREParserCloseParen)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(249)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(250)
			p.Match(PCREParserQuestionMark)
		}
		{
			p.SetState(251)
			p.Match(PCREParserPUC)
		}
		{
			p.SetState(252)
			p.Match(PCREParserLessThan)
		}
		{
			p.SetState(253)
			p.Name()
		}
		{
			p.SetState(254)
			p.Match(PCREParserGreaterThan)
		}
		{
			p.SetState(255)
			p.Alternation()
		}
		{
			p.SetState(256)
			p.Match(PCREParserCloseParen)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(258)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(259)
			p.Alternation()
		}
		{
			p.SetState(260)
			p.Match(PCREParserCloseParen)
		}

	}

	return localctx
}

// INon_captureContext is an interface to support dynamic dispatch.
type INon_captureContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNon_captureContext differentiates from other interfaces.
	IsNon_captureContext()
}

type Non_captureContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNon_captureContext() *Non_captureContext {
	var p = new(Non_captureContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PCREParserRULE_non_capture
	return p
}

func (*Non_captureContext) IsNon_captureContext() {}

func NewNon_captureContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Non_captureContext {
	var p = new(Non_captureContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_non_capture

	return p
}

func (s *Non_captureContext) GetParser() antlr.Parser { return s.parser }

func (s *Non_captureContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(PCREParserOpenParen, 0)
}

func (s *Non_captureContext) QuestionMark() antlr.TerminalNode {
	return s.GetToken(PCREParserQuestionMark, 0)
}

func (s *Non_captureContext) Colon() antlr.TerminalNode {
	return s.GetToken(PCREParserColon, 0)
}

func (s *Non_captureContext) Alternation() IAlternationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlternationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlternationContext)
}

func (s *Non_captureContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(PCREParserCloseParen, 0)
}

func (s *Non_captureContext) Pipe() antlr.TerminalNode {
	return s.GetToken(PCREParserPipe, 0)
}

func (s *Non_captureContext) GreaterThan() antlr.TerminalNode {
	return s.GetToken(PCREParserGreaterThan, 0)
}

func (s *Non_captureContext) Option_flags() IOption_flagsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOption_flagsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOption_flagsContext)
}

func (s *Non_captureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Non_captureContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Non_captureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterNon_capture(s)
	}
}

func (s *Non_captureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitNon_capture(s)
	}
}

func (p *PCREParser) Non_capture() (localctx INon_captureContext) {
	this := p
	_ = this

	localctx = NewNon_captureContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, PCREParserRULE_non_capture)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(289)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 15, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(264)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(265)
			p.Match(PCREParserQuestionMark)
		}
		{
			p.SetState(266)
			p.Match(PCREParserColon)
		}
		{
			p.SetState(267)
			p.Alternation()
		}
		{
			p.SetState(268)
			p.Match(PCREParserCloseParen)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(270)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(271)
			p.Match(PCREParserQuestionMark)
		}
		{
			p.SetState(272)
			p.Match(PCREParserPipe)
		}
		{
			p.SetState(273)
			p.Alternation()
		}
		{
			p.SetState(274)
			p.Match(PCREParserCloseParen)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(276)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(277)
			p.Match(PCREParserQuestionMark)
		}
		{
			p.SetState(278)
			p.Match(PCREParserGreaterThan)
		}
		{
			p.SetState(279)
			p.Alternation()
		}
		{
			p.SetState(280)
			p.Match(PCREParserCloseParen)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(282)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(283)
			p.Match(PCREParserQuestionMark)
		}
		{
			p.SetState(284)
			p.Option_flags()
		}
		{
			p.SetState(285)
			p.Match(PCREParserColon)
		}
		{
			p.SetState(286)
			p.Alternation()
		}
		{
			p.SetState(287)
			p.Match(PCREParserCloseParen)
		}

	}

	return localctx
}

// ICommentContext is an interface to support dynamic dispatch.
type ICommentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCommentContext differentiates from other interfaces.
	IsCommentContext()
}

type CommentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommentContext() *CommentContext {
	var p = new(CommentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PCREParserRULE_comment
	return p
}

func (*CommentContext) IsCommentContext() {}

func NewCommentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommentContext {
	var p = new(CommentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_comment

	return p
}

func (s *CommentContext) GetParser() antlr.Parser { return s.parser }

func (s *CommentContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(PCREParserOpenParen, 0)
}

func (s *CommentContext) QuestionMark() antlr.TerminalNode {
	return s.GetToken(PCREParserQuestionMark, 0)
}

func (s *CommentContext) Hash() antlr.TerminalNode {
	return s.GetToken(PCREParserHash, 0)
}

func (s *CommentContext) Non_close_parens() INon_close_parensContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INon_close_parensContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INon_close_parensContext)
}

func (s *CommentContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(PCREParserCloseParen, 0)
}

func (s *CommentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterComment(s)
	}
}

func (s *CommentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitComment(s)
	}
}

func (p *PCREParser) Comment() (localctx ICommentContext) {
	this := p
	_ = this

	localctx = NewCommentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, PCREParserRULE_comment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(291)
		p.Match(PCREParserOpenParen)
	}
	{
		p.SetState(292)
		p.Match(PCREParserQuestionMark)
	}
	{
		p.SetState(293)
		p.Match(PCREParserHash)
	}
	{
		p.SetState(294)
		p.Non_close_parens()
	}
	{
		p.SetState(295)
		p.Match(PCREParserCloseParen)
	}

	return localctx
}

// IOptionContext is an interface to support dynamic dispatch.
type IOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOptionContext differentiates from other interfaces.
	IsOptionContext()
}

type OptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptionContext() *OptionContext {
	var p = new(OptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PCREParserRULE_option
	return p
}

func (*OptionContext) IsOptionContext() {}

func NewOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptionContext {
	var p = new(OptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_option

	return p
}

func (s *OptionContext) GetParser() antlr.Parser { return s.parser }

func (s *OptionContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(PCREParserOpenParen, 0)
}

func (s *OptionContext) QuestionMark() antlr.TerminalNode {
	return s.GetToken(PCREParserQuestionMark, 0)
}

func (s *OptionContext) AllOption_flags() []IOption_flagsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOption_flagsContext)(nil)).Elem())
	var tst = make([]IOption_flagsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOption_flagsContext)
		}
	}

	return tst
}

func (s *OptionContext) Option_flags(i int) IOption_flagsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOption_flagsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOption_flagsContext)
}

func (s *OptionContext) Hyphen() antlr.TerminalNode {
	return s.GetToken(PCREParserHyphen, 0)
}

func (s *OptionContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(PCREParserCloseParen, 0)
}

func (s *OptionContext) Star() antlr.TerminalNode {
	return s.GetToken(PCREParserStar, 0)
}

func (s *OptionContext) NUC() antlr.TerminalNode {
	return s.GetToken(PCREParserNUC, 0)
}

func (s *OptionContext) AllOUC() []antlr.TerminalNode {
	return s.GetTokens(PCREParserOUC)
}

func (s *OptionContext) OUC(i int) antlr.TerminalNode {
	return s.GetToken(PCREParserOUC, i)
}

func (s *OptionContext) AllUnderscore() []antlr.TerminalNode {
	return s.GetTokens(PCREParserUnderscore)
}

func (s *OptionContext) Underscore(i int) antlr.TerminalNode {
	return s.GetToken(PCREParserUnderscore, i)
}

func (s *OptionContext) SUC() antlr.TerminalNode {
	return s.GetToken(PCREParserSUC, 0)
}

func (s *OptionContext) AllTUC() []antlr.TerminalNode {
	return s.GetTokens(PCREParserTUC)
}

func (s *OptionContext) TUC(i int) antlr.TerminalNode {
	return s.GetToken(PCREParserTUC, i)
}

func (s *OptionContext) AUC() antlr.TerminalNode {
	return s.GetToken(PCREParserAUC, 0)
}

func (s *OptionContext) RUC() antlr.TerminalNode {
	return s.GetToken(PCREParserRUC, 0)
}

func (s *OptionContext) PUC() antlr.TerminalNode {
	return s.GetToken(PCREParserPUC, 0)
}

func (s *OptionContext) UUC() antlr.TerminalNode {
	return s.GetToken(PCREParserUUC, 0)
}

func (s *OptionContext) FUC() antlr.TerminalNode {
	return s.GetToken(PCREParserFUC, 0)
}

func (s *OptionContext) D8() antlr.TerminalNode {
	return s.GetToken(PCREParserD8, 0)
}

func (s *OptionContext) D1() antlr.TerminalNode {
	return s.GetToken(PCREParserD1, 0)
}

func (s *OptionContext) D6() antlr.TerminalNode {
	return s.GetToken(PCREParserD6, 0)
}

func (s *OptionContext) CUC() antlr.TerminalNode {
	return s.GetToken(PCREParserCUC, 0)
}

func (s *OptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterOption(s)
	}
}

func (s *OptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitOption(s)
	}
}

func (p *PCREParser) Option() (localctx IOptionContext) {
	this := p
	_ = this

	localctx = NewOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, PCREParserRULE_option)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(351)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 16, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(297)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(298)
			p.Match(PCREParserQuestionMark)
		}
		{
			p.SetState(299)
			p.Option_flags()
		}
		{
			p.SetState(300)
			p.Match(PCREParserHyphen)
		}
		{
			p.SetState(301)
			p.Option_flags()
		}
		{
			p.SetState(302)
			p.Match(PCREParserCloseParen)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(304)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(305)
			p.Match(PCREParserQuestionMark)
		}
		{
			p.SetState(306)
			p.Option_flags()
		}
		{
			p.SetState(307)
			p.Match(PCREParserCloseParen)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(309)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(310)
			p.Match(PCREParserQuestionMark)
		}
		{
			p.SetState(311)
			p.Match(PCREParserHyphen)
		}
		{
			p.SetState(312)
			p.Option_flags()
		}
		{
			p.SetState(313)
			p.Match(PCREParserCloseParen)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(315)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(316)
			p.Match(PCREParserStar)
		}
		{
			p.SetState(317)
			p.Match(PCREParserNUC)
		}
		{
			p.SetState(318)
			p.Match(PCREParserOUC)
		}
		{
			p.SetState(319)
			p.Match(PCREParserUnderscore)
		}
		{
			p.SetState(320)
			p.Match(PCREParserSUC)
		}
		{
			p.SetState(321)
			p.Match(PCREParserTUC)
		}
		{
			p.SetState(322)
			p.Match(PCREParserAUC)
		}
		{
			p.SetState(323)
			p.Match(PCREParserRUC)
		}
		{
			p.SetState(324)
			p.Match(PCREParserTUC)
		}
		{
			p.SetState(325)
			p.Match(PCREParserUnderscore)
		}
		{
			p.SetState(326)
			p.Match(PCREParserOUC)
		}
		{
			p.SetState(327)
			p.Match(PCREParserPUC)
		}
		{
			p.SetState(328)
			p.Match(PCREParserTUC)
		}
		{
			p.SetState(329)
			p.Match(PCREParserCloseParen)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(330)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(331)
			p.Match(PCREParserStar)
		}
		{
			p.SetState(332)
			p.Match(PCREParserUUC)
		}
		{
			p.SetState(333)
			p.Match(PCREParserTUC)
		}
		{
			p.SetState(334)
			p.Match(PCREParserFUC)
		}
		{
			p.SetState(335)
			p.Match(PCREParserD8)
		}
		{
			p.SetState(336)
			p.Match(PCREParserCloseParen)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(337)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(338)
			p.Match(PCREParserStar)
		}
		{
			p.SetState(339)
			p.Match(PCREParserUUC)
		}
		{
			p.SetState(340)
			p.Match(PCREParserTUC)
		}
		{
			p.SetState(341)
			p.Match(PCREParserFUC)
		}
		{
			p.SetState(342)
			p.Match(PCREParserD1)
		}
		{
			p.SetState(343)
			p.Match(PCREParserD6)
		}
		{
			p.SetState(344)
			p.Match(PCREParserCloseParen)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(345)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(346)
			p.Match(PCREParserStar)
		}
		{
			p.SetState(347)
			p.Match(PCREParserUUC)
		}
		{
			p.SetState(348)
			p.Match(PCREParserCUC)
		}
		{
			p.SetState(349)
			p.Match(PCREParserPUC)
		}
		{
			p.SetState(350)
			p.Match(PCREParserCloseParen)
		}

	}

	return localctx
}

// IOption_flagsContext is an interface to support dynamic dispatch.
type IOption_flagsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOption_flagsContext differentiates from other interfaces.
	IsOption_flagsContext()
}

type Option_flagsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOption_flagsContext() *Option_flagsContext {
	var p = new(Option_flagsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PCREParserRULE_option_flags
	return p
}

func (*Option_flagsContext) IsOption_flagsContext() {}

func NewOption_flagsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Option_flagsContext {
	var p = new(Option_flagsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_option_flags

	return p
}

func (s *Option_flagsContext) GetParser() antlr.Parser { return s.parser }

func (s *Option_flagsContext) AllOption_flag() []IOption_flagContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOption_flagContext)(nil)).Elem())
	var tst = make([]IOption_flagContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOption_flagContext)
		}
	}

	return tst
}

func (s *Option_flagsContext) Option_flag(i int) IOption_flagContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOption_flagContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOption_flagContext)
}

func (s *Option_flagsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Option_flagsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Option_flagsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterOption_flags(s)
	}
}

func (s *Option_flagsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitOption_flags(s)
	}
}

func (p *PCREParser) Option_flags() (localctx IOption_flagsContext) {
	this := p
	_ = this

	localctx = NewOption_flagsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, PCREParserRULE_option_flags)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(354)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la-71)&-(0x1f+1)) == 0 && ((1<<uint((_la-71)))&((1<<(PCREParserILC-71))|(1<<(PCREParserMLC-71))|(1<<(PCREParserSLC-71))|(1<<(PCREParserXLC-71))|(1<<(PCREParserJUC-71)))) != 0) || _la == PCREParserUUC {
		{
			p.SetState(353)
			p.Option_flag()
		}

		p.SetState(356)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IOption_flagContext is an interface to support dynamic dispatch.
type IOption_flagContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOption_flagContext differentiates from other interfaces.
	IsOption_flagContext()
}

type Option_flagContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOption_flagContext() *Option_flagContext {
	var p = new(Option_flagContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PCREParserRULE_option_flag
	return p
}

func (*Option_flagContext) IsOption_flagContext() {}

func NewOption_flagContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Option_flagContext {
	var p = new(Option_flagContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_option_flag

	return p
}

func (s *Option_flagContext) GetParser() antlr.Parser { return s.parser }

func (s *Option_flagContext) ILC() antlr.TerminalNode {
	return s.GetToken(PCREParserILC, 0)
}

func (s *Option_flagContext) JUC() antlr.TerminalNode {
	return s.GetToken(PCREParserJUC, 0)
}

func (s *Option_flagContext) MLC() antlr.TerminalNode {
	return s.GetToken(PCREParserMLC, 0)
}

func (s *Option_flagContext) SLC() antlr.TerminalNode {
	return s.GetToken(PCREParserSLC, 0)
}

func (s *Option_flagContext) UUC() antlr.TerminalNode {
	return s.GetToken(PCREParserUUC, 0)
}

func (s *Option_flagContext) XLC() antlr.TerminalNode {
	return s.GetToken(PCREParserXLC, 0)
}

func (s *Option_flagContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Option_flagContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Option_flagContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterOption_flag(s)
	}
}

func (s *Option_flagContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitOption_flag(s)
	}
}

func (p *PCREParser) Option_flag() (localctx IOption_flagContext) {
	this := p
	_ = this

	localctx = NewOption_flagContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, PCREParserRULE_option_flag)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(358)
		_la = p.GetTokenStream().LA(1)

		if !((((_la-71)&-(0x1f+1)) == 0 && ((1<<uint((_la-71)))&((1<<(PCREParserILC-71))|(1<<(PCREParserMLC-71))|(1<<(PCREParserSLC-71))|(1<<(PCREParserXLC-71))|(1<<(PCREParserJUC-71)))) != 0) || _la == PCREParserUUC) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ILook_aroundContext is an interface to support dynamic dispatch.
type ILook_aroundContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLook_aroundContext differentiates from other interfaces.
	IsLook_aroundContext()
}

type Look_aroundContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLook_aroundContext() *Look_aroundContext {
	var p = new(Look_aroundContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PCREParserRULE_look_around
	return p
}

func (*Look_aroundContext) IsLook_aroundContext() {}

func NewLook_aroundContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Look_aroundContext {
	var p = new(Look_aroundContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_look_around

	return p
}

func (s *Look_aroundContext) GetParser() antlr.Parser { return s.parser }

func (s *Look_aroundContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(PCREParserOpenParen, 0)
}

func (s *Look_aroundContext) QuestionMark() antlr.TerminalNode {
	return s.GetToken(PCREParserQuestionMark, 0)
}

func (s *Look_aroundContext) Equals() antlr.TerminalNode {
	return s.GetToken(PCREParserEquals, 0)
}

func (s *Look_aroundContext) Alternation() IAlternationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlternationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlternationContext)
}

func (s *Look_aroundContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(PCREParserCloseParen, 0)
}

func (s *Look_aroundContext) Exclamation() antlr.TerminalNode {
	return s.GetToken(PCREParserExclamation, 0)
}

func (s *Look_aroundContext) LessThan() antlr.TerminalNode {
	return s.GetToken(PCREParserLessThan, 0)
}

func (s *Look_aroundContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Look_aroundContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Look_aroundContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterLook_around(s)
	}
}

func (s *Look_aroundContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitLook_around(s)
	}
}

func (p *PCREParser) Look_around() (localctx ILook_aroundContext) {
	this := p
	_ = this

	localctx = NewLook_aroundContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, PCREParserRULE_look_around)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(386)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 18, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(360)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(361)
			p.Match(PCREParserQuestionMark)
		}
		{
			p.SetState(362)
			p.Match(PCREParserEquals)
		}
		{
			p.SetState(363)
			p.Alternation()
		}
		{
			p.SetState(364)
			p.Match(PCREParserCloseParen)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(366)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(367)
			p.Match(PCREParserQuestionMark)
		}
		{
			p.SetState(368)
			p.Match(PCREParserExclamation)
		}
		{
			p.SetState(369)
			p.Alternation()
		}
		{
			p.SetState(370)
			p.Match(PCREParserCloseParen)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(372)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(373)
			p.Match(PCREParserQuestionMark)
		}
		{
			p.SetState(374)
			p.Match(PCREParserLessThan)
		}
		{
			p.SetState(375)
			p.Match(PCREParserEquals)
		}
		{
			p.SetState(376)
			p.Alternation()
		}
		{
			p.SetState(377)
			p.Match(PCREParserCloseParen)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(379)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(380)
			p.Match(PCREParserQuestionMark)
		}
		{
			p.SetState(381)
			p.Match(PCREParserLessThan)
		}
		{
			p.SetState(382)
			p.Match(PCREParserExclamation)
		}
		{
			p.SetState(383)
			p.Alternation()
		}
		{
			p.SetState(384)
			p.Match(PCREParserCloseParen)
		}

	}

	return localctx
}

// ISubroutine_referenceContext is an interface to support dynamic dispatch.
type ISubroutine_referenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubroutine_referenceContext differentiates from other interfaces.
	IsSubroutine_referenceContext()
}

type Subroutine_referenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubroutine_referenceContext() *Subroutine_referenceContext {
	var p = new(Subroutine_referenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PCREParserRULE_subroutine_reference
	return p
}

func (*Subroutine_referenceContext) IsSubroutine_referenceContext() {}

func NewSubroutine_referenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Subroutine_referenceContext {
	var p = new(Subroutine_referenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_subroutine_reference

	return p
}

func (s *Subroutine_referenceContext) GetParser() antlr.Parser { return s.parser }

func (s *Subroutine_referenceContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(PCREParserOpenParen, 0)
}

func (s *Subroutine_referenceContext) QuestionMark() antlr.TerminalNode {
	return s.GetToken(PCREParserQuestionMark, 0)
}

func (s *Subroutine_referenceContext) RUC() antlr.TerminalNode {
	return s.GetToken(PCREParserRUC, 0)
}

func (s *Subroutine_referenceContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(PCREParserCloseParen, 0)
}

func (s *Subroutine_referenceContext) Number() INumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *Subroutine_referenceContext) Plus() antlr.TerminalNode {
	return s.GetToken(PCREParserPlus, 0)
}

func (s *Subroutine_referenceContext) Hyphen() antlr.TerminalNode {
	return s.GetToken(PCREParserHyphen, 0)
}

func (s *Subroutine_referenceContext) Ampersand() antlr.TerminalNode {
	return s.GetToken(PCREParserAmpersand, 0)
}

func (s *Subroutine_referenceContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Subroutine_referenceContext) PUC() antlr.TerminalNode {
	return s.GetToken(PCREParserPUC, 0)
}

func (s *Subroutine_referenceContext) GreaterThan() antlr.TerminalNode {
	return s.GetToken(PCREParserGreaterThan, 0)
}

func (s *Subroutine_referenceContext) SubroutineOrNamedReferenceStartG() antlr.TerminalNode {
	return s.GetToken(PCREParserSubroutineOrNamedReferenceStartG, 0)
}

func (s *Subroutine_referenceContext) LessThan() antlr.TerminalNode {
	return s.GetToken(PCREParserLessThan, 0)
}

func (s *Subroutine_referenceContext) AllSingleQuote() []antlr.TerminalNode {
	return s.GetTokens(PCREParserSingleQuote)
}

func (s *Subroutine_referenceContext) SingleQuote(i int) antlr.TerminalNode {
	return s.GetToken(PCREParserSingleQuote, i)
}

func (s *Subroutine_referenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Subroutine_referenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Subroutine_referenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterSubroutine_reference(s)
	}
}

func (s *Subroutine_referenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitSubroutine_reference(s)
	}
}

func (p *PCREParser) Subroutine_reference() (localctx ISubroutine_referenceContext) {
	this := p
	_ = this

	localctx = NewSubroutine_referenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, PCREParserRULE_subroutine_reference)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(466)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 19, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(388)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(389)
			p.Match(PCREParserQuestionMark)
		}
		{
			p.SetState(390)
			p.Match(PCREParserRUC)
		}
		{
			p.SetState(391)
			p.Match(PCREParserCloseParen)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(392)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(393)
			p.Match(PCREParserQuestionMark)
		}
		{
			p.SetState(394)
			p.Number()
		}
		{
			p.SetState(395)
			p.Match(PCREParserCloseParen)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(397)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(398)
			p.Match(PCREParserQuestionMark)
		}
		{
			p.SetState(399)
			p.Match(PCREParserPlus)
		}
		{
			p.SetState(400)
			p.Number()
		}
		{
			p.SetState(401)
			p.Match(PCREParserCloseParen)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(403)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(404)
			p.Match(PCREParserQuestionMark)
		}
		{
			p.SetState(405)
			p.Match(PCREParserHyphen)
		}
		{
			p.SetState(406)
			p.Number()
		}
		{
			p.SetState(407)
			p.Match(PCREParserCloseParen)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(409)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(410)
			p.Match(PCREParserQuestionMark)
		}
		{
			p.SetState(411)
			p.Match(PCREParserAmpersand)
		}
		{
			p.SetState(412)
			p.Name()
		}
		{
			p.SetState(413)
			p.Match(PCREParserCloseParen)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(415)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(416)
			p.Match(PCREParserQuestionMark)
		}
		{
			p.SetState(417)
			p.Match(PCREParserPUC)
		}
		{
			p.SetState(418)
			p.Match(PCREParserGreaterThan)
		}
		{
			p.SetState(419)
			p.Name()
		}
		{
			p.SetState(420)
			p.Match(PCREParserCloseParen)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(422)
			p.Match(PCREParserSubroutineOrNamedReferenceStartG)
		}
		{
			p.SetState(423)
			p.Match(PCREParserLessThan)
		}
		{
			p.SetState(424)
			p.Name()
		}
		{
			p.SetState(425)
			p.Match(PCREParserGreaterThan)
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(427)
			p.Match(PCREParserSubroutineOrNamedReferenceStartG)
		}
		{
			p.SetState(428)
			p.Match(PCREParserSingleQuote)
		}
		{
			p.SetState(429)
			p.Name()
		}
		{
			p.SetState(430)
			p.Match(PCREParserSingleQuote)
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(432)
			p.Match(PCREParserSubroutineOrNamedReferenceStartG)
		}
		{
			p.SetState(433)
			p.Match(PCREParserLessThan)
		}
		{
			p.SetState(434)
			p.Number()
		}
		{
			p.SetState(435)
			p.Match(PCREParserGreaterThan)
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(437)
			p.Match(PCREParserSubroutineOrNamedReferenceStartG)
		}
		{
			p.SetState(438)
			p.Match(PCREParserSingleQuote)
		}
		{
			p.SetState(439)
			p.Number()
		}
		{
			p.SetState(440)
			p.Match(PCREParserSingleQuote)
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(442)
			p.Match(PCREParserSubroutineOrNamedReferenceStartG)
		}
		{
			p.SetState(443)
			p.Match(PCREParserLessThan)
		}
		{
			p.SetState(444)
			p.Match(PCREParserPlus)
		}
		{
			p.SetState(445)
			p.Number()
		}
		{
			p.SetState(446)
			p.Match(PCREParserGreaterThan)
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(448)
			p.Match(PCREParserSubroutineOrNamedReferenceStartG)
		}
		{
			p.SetState(449)
			p.Match(PCREParserSingleQuote)
		}
		{
			p.SetState(450)
			p.Match(PCREParserPlus)
		}
		{
			p.SetState(451)
			p.Number()
		}
		{
			p.SetState(452)
			p.Match(PCREParserSingleQuote)
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(454)
			p.Match(PCREParserSubroutineOrNamedReferenceStartG)
		}
		{
			p.SetState(455)
			p.Match(PCREParserLessThan)
		}
		{
			p.SetState(456)
			p.Match(PCREParserHyphen)
		}
		{
			p.SetState(457)
			p.Number()
		}
		{
			p.SetState(458)
			p.Match(PCREParserGreaterThan)
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(460)
			p.Match(PCREParserSubroutineOrNamedReferenceStartG)
		}
		{
			p.SetState(461)
			p.Match(PCREParserSingleQuote)
		}
		{
			p.SetState(462)
			p.Match(PCREParserHyphen)
		}
		{
			p.SetState(463)
			p.Number()
		}
		{
			p.SetState(464)
			p.Match(PCREParserSingleQuote)
		}

	}

	return localctx
}

// IConditionalContext is an interface to support dynamic dispatch.
type IConditionalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConditionalContext differentiates from other interfaces.
	IsConditionalContext()
}

type ConditionalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditionalContext() *ConditionalContext {
	var p = new(ConditionalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PCREParserRULE_conditional
	return p
}

func (*ConditionalContext) IsConditionalContext() {}

func NewConditionalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConditionalContext {
	var p = new(ConditionalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_conditional

	return p
}

func (s *ConditionalContext) GetParser() antlr.Parser { return s.parser }

func (s *ConditionalContext) AllOpenParen() []antlr.TerminalNode {
	return s.GetTokens(PCREParserOpenParen)
}

func (s *ConditionalContext) OpenParen(i int) antlr.TerminalNode {
	return s.GetToken(PCREParserOpenParen, i)
}

func (s *ConditionalContext) QuestionMark() antlr.TerminalNode {
	return s.GetToken(PCREParserQuestionMark, 0)
}

func (s *ConditionalContext) Number() INumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *ConditionalContext) AllCloseParen() []antlr.TerminalNode {
	return s.GetTokens(PCREParserCloseParen)
}

func (s *ConditionalContext) CloseParen(i int) antlr.TerminalNode {
	return s.GetToken(PCREParserCloseParen, i)
}

func (s *ConditionalContext) AllAlternation() []IAlternationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAlternationContext)(nil)).Elem())
	var tst = make([]IAlternationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAlternationContext)
		}
	}

	return tst
}

func (s *ConditionalContext) Alternation(i int) IAlternationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlternationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAlternationContext)
}

func (s *ConditionalContext) Pipe() antlr.TerminalNode {
	return s.GetToken(PCREParserPipe, 0)
}

func (s *ConditionalContext) Plus() antlr.TerminalNode {
	return s.GetToken(PCREParserPlus, 0)
}

func (s *ConditionalContext) Hyphen() antlr.TerminalNode {
	return s.GetToken(PCREParserHyphen, 0)
}

func (s *ConditionalContext) LessThan() antlr.TerminalNode {
	return s.GetToken(PCREParserLessThan, 0)
}

func (s *ConditionalContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *ConditionalContext) GreaterThan() antlr.TerminalNode {
	return s.GetToken(PCREParserGreaterThan, 0)
}

func (s *ConditionalContext) AllSingleQuote() []antlr.TerminalNode {
	return s.GetTokens(PCREParserSingleQuote)
}

func (s *ConditionalContext) SingleQuote(i int) antlr.TerminalNode {
	return s.GetToken(PCREParserSingleQuote, i)
}

func (s *ConditionalContext) RUC() antlr.TerminalNode {
	return s.GetToken(PCREParserRUC, 0)
}

func (s *ConditionalContext) Ampersand() antlr.TerminalNode {
	return s.GetToken(PCREParserAmpersand, 0)
}

func (s *ConditionalContext) DUC() antlr.TerminalNode {
	return s.GetToken(PCREParserDUC, 0)
}

func (s *ConditionalContext) AllEUC() []antlr.TerminalNode {
	return s.GetTokens(PCREParserEUC)
}

func (s *ConditionalContext) EUC(i int) antlr.TerminalNode {
	return s.GetToken(PCREParserEUC, i)
}

func (s *ConditionalContext) FUC() antlr.TerminalNode {
	return s.GetToken(PCREParserFUC, 0)
}

func (s *ConditionalContext) IUC() antlr.TerminalNode {
	return s.GetToken(PCREParserIUC, 0)
}

func (s *ConditionalContext) NUC() antlr.TerminalNode {
	return s.GetToken(PCREParserNUC, 0)
}

func (s *ConditionalContext) ALC() antlr.TerminalNode {
	return s.GetToken(PCREParserALC, 0)
}

func (s *ConditionalContext) AllSLC() []antlr.TerminalNode {
	return s.GetTokens(PCREParserSLC)
}

func (s *ConditionalContext) SLC(i int) antlr.TerminalNode {
	return s.GetToken(PCREParserSLC, i)
}

func (s *ConditionalContext) ELC() antlr.TerminalNode {
	return s.GetToken(PCREParserELC, 0)
}

func (s *ConditionalContext) RLC() antlr.TerminalNode {
	return s.GetToken(PCREParserRLC, 0)
}

func (s *ConditionalContext) TLC() antlr.TerminalNode {
	return s.GetToken(PCREParserTLC, 0)
}

func (s *ConditionalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConditionalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConditionalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterConditional(s)
	}
}

func (s *ConditionalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitConditional(s)
	}
}

func (p *PCREParser) Conditional() (localctx IConditionalContext) {
	this := p
	_ = this

	localctx = NewConditionalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, PCREParserRULE_conditional)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(619)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 31, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(468)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(469)
			p.Match(PCREParserQuestionMark)
		}
		{
			p.SetState(470)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(471)
			p.Number()
		}
		{
			p.SetState(472)
			p.Match(PCREParserCloseParen)
		}
		{
			p.SetState(473)
			p.Alternation()
		}
		p.SetState(476)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PCREParserPipe {
			{
				p.SetState(474)
				p.Match(PCREParserPipe)
			}
			{
				p.SetState(475)
				p.Alternation()
			}

		}
		{
			p.SetState(478)
			p.Match(PCREParserCloseParen)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(480)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(481)
			p.Match(PCREParserQuestionMark)
		}
		{
			p.SetState(482)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(483)
			p.Match(PCREParserPlus)
		}
		{
			p.SetState(484)
			p.Number()
		}
		{
			p.SetState(485)
			p.Match(PCREParserCloseParen)
		}
		{
			p.SetState(486)
			p.Alternation()
		}
		p.SetState(489)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PCREParserPipe {
			{
				p.SetState(487)
				p.Match(PCREParserPipe)
			}
			{
				p.SetState(488)
				p.Alternation()
			}

		}
		{
			p.SetState(491)
			p.Match(PCREParserCloseParen)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(493)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(494)
			p.Match(PCREParserQuestionMark)
		}
		{
			p.SetState(495)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(496)
			p.Match(PCREParserHyphen)
		}
		{
			p.SetState(497)
			p.Number()
		}
		{
			p.SetState(498)
			p.Match(PCREParserCloseParen)
		}
		{
			p.SetState(499)
			p.Alternation()
		}
		p.SetState(502)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PCREParserPipe {
			{
				p.SetState(500)
				p.Match(PCREParserPipe)
			}
			{
				p.SetState(501)
				p.Alternation()
			}

		}
		{
			p.SetState(504)
			p.Match(PCREParserCloseParen)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(506)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(507)
			p.Match(PCREParserQuestionMark)
		}
		{
			p.SetState(508)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(509)
			p.Match(PCREParserLessThan)
		}
		{
			p.SetState(510)
			p.Name()
		}
		{
			p.SetState(511)
			p.Match(PCREParserGreaterThan)
		}
		{
			p.SetState(512)
			p.Match(PCREParserCloseParen)
		}
		{
			p.SetState(513)
			p.Alternation()
		}
		p.SetState(516)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PCREParserPipe {
			{
				p.SetState(514)
				p.Match(PCREParserPipe)
			}
			{
				p.SetState(515)
				p.Alternation()
			}

		}
		{
			p.SetState(518)
			p.Match(PCREParserCloseParen)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(520)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(521)
			p.Match(PCREParserQuestionMark)
		}
		{
			p.SetState(522)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(523)
			p.Match(PCREParserSingleQuote)
		}
		{
			p.SetState(524)
			p.Name()
		}
		{
			p.SetState(525)
			p.Match(PCREParserSingleQuote)
		}
		{
			p.SetState(526)
			p.Match(PCREParserCloseParen)
		}
		{
			p.SetState(527)
			p.Alternation()
		}
		p.SetState(530)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PCREParserPipe {
			{
				p.SetState(528)
				p.Match(PCREParserPipe)
			}
			{
				p.SetState(529)
				p.Alternation()
			}

		}
		{
			p.SetState(532)
			p.Match(PCREParserCloseParen)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(534)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(535)
			p.Match(PCREParserQuestionMark)
		}
		{
			p.SetState(536)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(537)
			p.Match(PCREParserRUC)
		}
		{
			p.SetState(538)
			p.Number()
		}
		{
			p.SetState(539)
			p.Match(PCREParserCloseParen)
		}
		{
			p.SetState(540)
			p.Alternation()
		}
		p.SetState(543)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PCREParserPipe {
			{
				p.SetState(541)
				p.Match(PCREParserPipe)
			}
			{
				p.SetState(542)
				p.Alternation()
			}

		}
		{
			p.SetState(545)
			p.Match(PCREParserCloseParen)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(547)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(548)
			p.Match(PCREParserQuestionMark)
		}
		{
			p.SetState(549)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(550)
			p.Match(PCREParserRUC)
		}
		{
			p.SetState(551)
			p.Match(PCREParserCloseParen)
		}
		{
			p.SetState(552)
			p.Alternation()
		}
		p.SetState(555)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PCREParserPipe {
			{
				p.SetState(553)
				p.Match(PCREParserPipe)
			}
			{
				p.SetState(554)
				p.Alternation()
			}

		}
		{
			p.SetState(557)
			p.Match(PCREParserCloseParen)
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(559)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(560)
			p.Match(PCREParserQuestionMark)
		}
		{
			p.SetState(561)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(562)
			p.Match(PCREParserRUC)
		}
		{
			p.SetState(563)
			p.Match(PCREParserAmpersand)
		}
		{
			p.SetState(564)
			p.Name()
		}
		{
			p.SetState(565)
			p.Match(PCREParserCloseParen)
		}
		{
			p.SetState(566)
			p.Alternation()
		}
		p.SetState(569)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PCREParserPipe {
			{
				p.SetState(567)
				p.Match(PCREParserPipe)
			}
			{
				p.SetState(568)
				p.Alternation()
			}

		}
		{
			p.SetState(571)
			p.Match(PCREParserCloseParen)
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(573)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(574)
			p.Match(PCREParserQuestionMark)
		}
		{
			p.SetState(575)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(576)
			p.Match(PCREParserDUC)
		}
		{
			p.SetState(577)
			p.Match(PCREParserEUC)
		}
		{
			p.SetState(578)
			p.Match(PCREParserFUC)
		}
		{
			p.SetState(579)
			p.Match(PCREParserIUC)
		}
		{
			p.SetState(580)
			p.Match(PCREParserNUC)
		}
		{
			p.SetState(581)
			p.Match(PCREParserEUC)
		}
		{
			p.SetState(582)
			p.Match(PCREParserCloseParen)
		}
		{
			p.SetState(583)
			p.Alternation()
		}
		p.SetState(586)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PCREParserPipe {
			{
				p.SetState(584)
				p.Match(PCREParserPipe)
			}
			{
				p.SetState(585)
				p.Alternation()
			}

		}
		{
			p.SetState(588)
			p.Match(PCREParserCloseParen)
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(590)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(591)
			p.Match(PCREParserQuestionMark)
		}
		{
			p.SetState(592)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(593)
			p.Match(PCREParserALC)
		}
		{
			p.SetState(594)
			p.Match(PCREParserSLC)
		}
		{
			p.SetState(595)
			p.Match(PCREParserSLC)
		}
		{
			p.SetState(596)
			p.Match(PCREParserELC)
		}
		{
			p.SetState(597)
			p.Match(PCREParserRLC)
		}
		{
			p.SetState(598)
			p.Match(PCREParserTLC)
		}
		{
			p.SetState(599)
			p.Match(PCREParserCloseParen)
		}
		{
			p.SetState(600)
			p.Alternation()
		}
		p.SetState(603)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PCREParserPipe {
			{
				p.SetState(601)
				p.Match(PCREParserPipe)
			}
			{
				p.SetState(602)
				p.Alternation()
			}

		}
		{
			p.SetState(605)
			p.Match(PCREParserCloseParen)
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(607)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(608)
			p.Match(PCREParserQuestionMark)
		}
		{
			p.SetState(609)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(610)
			p.Name()
		}
		{
			p.SetState(611)
			p.Match(PCREParserCloseParen)
		}
		{
			p.SetState(612)
			p.Alternation()
		}
		p.SetState(615)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PCREParserPipe {
			{
				p.SetState(613)
				p.Match(PCREParserPipe)
			}
			{
				p.SetState(614)
				p.Alternation()
			}

		}
		{
			p.SetState(617)
			p.Match(PCREParserCloseParen)
		}

	}

	return localctx
}

// IBacktrack_controlContext is an interface to support dynamic dispatch.
type IBacktrack_controlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBacktrack_controlContext differentiates from other interfaces.
	IsBacktrack_controlContext()
}

type Backtrack_controlContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBacktrack_controlContext() *Backtrack_controlContext {
	var p = new(Backtrack_controlContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PCREParserRULE_backtrack_control
	return p
}

func (*Backtrack_controlContext) IsBacktrack_controlContext() {}

func NewBacktrack_controlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Backtrack_controlContext {
	var p = new(Backtrack_controlContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_backtrack_control

	return p
}

func (s *Backtrack_controlContext) GetParser() antlr.Parser { return s.parser }

func (s *Backtrack_controlContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(PCREParserOpenParen, 0)
}

func (s *Backtrack_controlContext) Star() antlr.TerminalNode {
	return s.GetToken(PCREParserStar, 0)
}

func (s *Backtrack_controlContext) AllAUC() []antlr.TerminalNode {
	return s.GetTokens(PCREParserAUC)
}

func (s *Backtrack_controlContext) AUC(i int) antlr.TerminalNode {
	return s.GetToken(PCREParserAUC, i)
}

func (s *Backtrack_controlContext) AllCUC() []antlr.TerminalNode {
	return s.GetTokens(PCREParserCUC)
}

func (s *Backtrack_controlContext) CUC(i int) antlr.TerminalNode {
	return s.GetToken(PCREParserCUC, i)
}

func (s *Backtrack_controlContext) AllEUC() []antlr.TerminalNode {
	return s.GetTokens(PCREParserEUC)
}

func (s *Backtrack_controlContext) EUC(i int) antlr.TerminalNode {
	return s.GetToken(PCREParserEUC, i)
}

func (s *Backtrack_controlContext) PUC() antlr.TerminalNode {
	return s.GetToken(PCREParserPUC, 0)
}

func (s *Backtrack_controlContext) TUC() antlr.TerminalNode {
	return s.GetToken(PCREParserTUC, 0)
}

func (s *Backtrack_controlContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(PCREParserCloseParen, 0)
}

func (s *Backtrack_controlContext) FUC() antlr.TerminalNode {
	return s.GetToken(PCREParserFUC, 0)
}

func (s *Backtrack_controlContext) IUC() antlr.TerminalNode {
	return s.GetToken(PCREParserIUC, 0)
}

func (s *Backtrack_controlContext) LUC() antlr.TerminalNode {
	return s.GetToken(PCREParserLUC, 0)
}

func (s *Backtrack_controlContext) Colon() antlr.TerminalNode {
	return s.GetToken(PCREParserColon, 0)
}

func (s *Backtrack_controlContext) AllNUC() []antlr.TerminalNode {
	return s.GetTokens(PCREParserNUC)
}

func (s *Backtrack_controlContext) NUC(i int) antlr.TerminalNode {
	return s.GetToken(PCREParserNUC, i)
}

func (s *Backtrack_controlContext) AllMUC() []antlr.TerminalNode {
	return s.GetTokens(PCREParserMUC)
}

func (s *Backtrack_controlContext) MUC(i int) antlr.TerminalNode {
	return s.GetToken(PCREParserMUC, i)
}

func (s *Backtrack_controlContext) RUC() antlr.TerminalNode {
	return s.GetToken(PCREParserRUC, 0)
}

func (s *Backtrack_controlContext) KUC() antlr.TerminalNode {
	return s.GetToken(PCREParserKUC, 0)
}

func (s *Backtrack_controlContext) OUC() antlr.TerminalNode {
	return s.GetToken(PCREParserOUC, 0)
}

func (s *Backtrack_controlContext) UUC() antlr.TerminalNode {
	return s.GetToken(PCREParserUUC, 0)
}

func (s *Backtrack_controlContext) SUC() antlr.TerminalNode {
	return s.GetToken(PCREParserSUC, 0)
}

func (s *Backtrack_controlContext) HUC() antlr.TerminalNode {
	return s.GetToken(PCREParserHUC, 0)
}

func (s *Backtrack_controlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Backtrack_controlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Backtrack_controlContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterBacktrack_control(s)
	}
}

func (s *Backtrack_controlContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitBacktrack_control(s)
	}
}

func (p *PCREParser) Backtrack_control() (localctx IBacktrack_controlContext) {
	this := p
	_ = this

	localctx = NewBacktrack_controlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, PCREParserRULE_backtrack_control)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(721)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 34, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(621)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(622)
			p.Match(PCREParserStar)
		}
		{
			p.SetState(623)
			p.Match(PCREParserAUC)
		}
		{
			p.SetState(624)
			p.Match(PCREParserCUC)
		}
		{
			p.SetState(625)
			p.Match(PCREParserCUC)
		}
		{
			p.SetState(626)
			p.Match(PCREParserEUC)
		}
		{
			p.SetState(627)
			p.Match(PCREParserPUC)
		}
		{
			p.SetState(628)
			p.Match(PCREParserTUC)
		}
		{
			p.SetState(629)
			p.Match(PCREParserCloseParen)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(630)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(631)
			p.Match(PCREParserStar)
		}
		{
			p.SetState(632)
			p.Match(PCREParserFUC)
		}
		p.SetState(636)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PCREParserAUC {
			{
				p.SetState(633)
				p.Match(PCREParserAUC)
			}
			{
				p.SetState(634)
				p.Match(PCREParserIUC)
			}
			{
				p.SetState(635)
				p.Match(PCREParserLUC)
			}

		}
		{
			p.SetState(638)
			p.Match(PCREParserCloseParen)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(639)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(640)
			p.Match(PCREParserStar)
		}
		p.SetState(645)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PCREParserMUC {
			{
				p.SetState(641)
				p.Match(PCREParserMUC)
			}
			{
				p.SetState(642)
				p.Match(PCREParserAUC)
			}
			{
				p.SetState(643)
				p.Match(PCREParserRUC)
			}
			{
				p.SetState(644)
				p.Match(PCREParserKUC)
			}

		}
		{
			p.SetState(647)
			p.Match(PCREParserColon)
		}
		{
			p.SetState(648)
			p.Match(PCREParserNUC)
		}
		{
			p.SetState(649)
			p.Match(PCREParserAUC)
		}
		{
			p.SetState(650)
			p.Match(PCREParserMUC)
		}
		{
			p.SetState(651)
			p.Match(PCREParserEUC)
		}
		{
			p.SetState(652)
			p.Match(PCREParserCloseParen)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(653)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(654)
			p.Match(PCREParserStar)
		}
		{
			p.SetState(655)
			p.Match(PCREParserCUC)
		}
		{
			p.SetState(656)
			p.Match(PCREParserOUC)
		}
		{
			p.SetState(657)
			p.Match(PCREParserMUC)
		}
		{
			p.SetState(658)
			p.Match(PCREParserMUC)
		}
		{
			p.SetState(659)
			p.Match(PCREParserIUC)
		}
		{
			p.SetState(660)
			p.Match(PCREParserTUC)
		}
		{
			p.SetState(661)
			p.Match(PCREParserCloseParen)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(662)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(663)
			p.Match(PCREParserStar)
		}
		{
			p.SetState(664)
			p.Match(PCREParserPUC)
		}
		{
			p.SetState(665)
			p.Match(PCREParserRUC)
		}
		{
			p.SetState(666)
			p.Match(PCREParserUUC)
		}
		{
			p.SetState(667)
			p.Match(PCREParserNUC)
		}
		{
			p.SetState(668)
			p.Match(PCREParserEUC)
		}
		{
			p.SetState(669)
			p.Match(PCREParserCloseParen)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(670)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(671)
			p.Match(PCREParserStar)
		}
		{
			p.SetState(672)
			p.Match(PCREParserPUC)
		}
		{
			p.SetState(673)
			p.Match(PCREParserRUC)
		}
		{
			p.SetState(674)
			p.Match(PCREParserUUC)
		}
		{
			p.SetState(675)
			p.Match(PCREParserNUC)
		}
		{
			p.SetState(676)
			p.Match(PCREParserEUC)
		}
		{
			p.SetState(677)
			p.Match(PCREParserColon)
		}
		{
			p.SetState(678)
			p.Match(PCREParserNUC)
		}
		{
			p.SetState(679)
			p.Match(PCREParserAUC)
		}
		{
			p.SetState(680)
			p.Match(PCREParserMUC)
		}
		{
			p.SetState(681)
			p.Match(PCREParserEUC)
		}
		{
			p.SetState(682)
			p.Match(PCREParserCloseParen)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(683)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(684)
			p.Match(PCREParserStar)
		}
		{
			p.SetState(685)
			p.Match(PCREParserSUC)
		}
		{
			p.SetState(686)
			p.Match(PCREParserKUC)
		}
		{
			p.SetState(687)
			p.Match(PCREParserIUC)
		}
		{
			p.SetState(688)
			p.Match(PCREParserPUC)
		}
		{
			p.SetState(689)
			p.Match(PCREParserCloseParen)
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(690)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(691)
			p.Match(PCREParserStar)
		}
		{
			p.SetState(692)
			p.Match(PCREParserSUC)
		}
		{
			p.SetState(693)
			p.Match(PCREParserKUC)
		}
		{
			p.SetState(694)
			p.Match(PCREParserIUC)
		}
		{
			p.SetState(695)
			p.Match(PCREParserPUC)
		}
		{
			p.SetState(696)
			p.Match(PCREParserColon)
		}
		{
			p.SetState(697)
			p.Match(PCREParserNUC)
		}
		{
			p.SetState(698)
			p.Match(PCREParserAUC)
		}
		{
			p.SetState(699)
			p.Match(PCREParserMUC)
		}
		{
			p.SetState(700)
			p.Match(PCREParserEUC)
		}
		{
			p.SetState(701)
			p.Match(PCREParserCloseParen)
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(702)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(703)
			p.Match(PCREParserStar)
		}
		{
			p.SetState(704)
			p.Match(PCREParserTUC)
		}
		{
			p.SetState(705)
			p.Match(PCREParserHUC)
		}
		{
			p.SetState(706)
			p.Match(PCREParserEUC)
		}
		{
			p.SetState(707)
			p.Match(PCREParserNUC)
		}
		{
			p.SetState(708)
			p.Match(PCREParserCloseParen)
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(709)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(710)
			p.Match(PCREParserStar)
		}
		{
			p.SetState(711)
			p.Match(PCREParserTUC)
		}
		{
			p.SetState(712)
			p.Match(PCREParserHUC)
		}
		{
			p.SetState(713)
			p.Match(PCREParserEUC)
		}
		{
			p.SetState(714)
			p.Match(PCREParserNUC)
		}
		{
			p.SetState(715)
			p.Match(PCREParserColon)
		}
		{
			p.SetState(716)
			p.Match(PCREParserNUC)
		}
		{
			p.SetState(717)
			p.Match(PCREParserAUC)
		}
		{
			p.SetState(718)
			p.Match(PCREParserMUC)
		}
		{
			p.SetState(719)
			p.Match(PCREParserEUC)
		}
		{
			p.SetState(720)
			p.Match(PCREParserCloseParen)
		}

	}

	return localctx
}

// INewline_conventionContext is an interface to support dynamic dispatch.
type INewline_conventionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNewline_conventionContext differentiates from other interfaces.
	IsNewline_conventionContext()
}

type Newline_conventionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNewline_conventionContext() *Newline_conventionContext {
	var p = new(Newline_conventionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PCREParserRULE_newline_convention
	return p
}

func (*Newline_conventionContext) IsNewline_conventionContext() {}

func NewNewline_conventionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Newline_conventionContext {
	var p = new(Newline_conventionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_newline_convention

	return p
}

func (s *Newline_conventionContext) GetParser() antlr.Parser { return s.parser }

func (s *Newline_conventionContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(PCREParserOpenParen, 0)
}

func (s *Newline_conventionContext) Star() antlr.TerminalNode {
	return s.GetToken(PCREParserStar, 0)
}

func (s *Newline_conventionContext) CUC() antlr.TerminalNode {
	return s.GetToken(PCREParserCUC, 0)
}

func (s *Newline_conventionContext) AllRUC() []antlr.TerminalNode {
	return s.GetTokens(PCREParserRUC)
}

func (s *Newline_conventionContext) RUC(i int) antlr.TerminalNode {
	return s.GetToken(PCREParserRUC, i)
}

func (s *Newline_conventionContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(PCREParserCloseParen, 0)
}

func (s *Newline_conventionContext) LUC() antlr.TerminalNode {
	return s.GetToken(PCREParserLUC, 0)
}

func (s *Newline_conventionContext) FUC() antlr.TerminalNode {
	return s.GetToken(PCREParserFUC, 0)
}

func (s *Newline_conventionContext) AUC() antlr.TerminalNode {
	return s.GetToken(PCREParserAUC, 0)
}

func (s *Newline_conventionContext) NUC() antlr.TerminalNode {
	return s.GetToken(PCREParserNUC, 0)
}

func (s *Newline_conventionContext) YUC() antlr.TerminalNode {
	return s.GetToken(PCREParserYUC, 0)
}

func (s *Newline_conventionContext) BUC() antlr.TerminalNode {
	return s.GetToken(PCREParserBUC, 0)
}

func (s *Newline_conventionContext) SUC() antlr.TerminalNode {
	return s.GetToken(PCREParserSUC, 0)
}

func (s *Newline_conventionContext) Underscore() antlr.TerminalNode {
	return s.GetToken(PCREParserUnderscore, 0)
}

func (s *Newline_conventionContext) UUC() antlr.TerminalNode {
	return s.GetToken(PCREParserUUC, 0)
}

func (s *Newline_conventionContext) IUC() antlr.TerminalNode {
	return s.GetToken(PCREParserIUC, 0)
}

func (s *Newline_conventionContext) OUC() antlr.TerminalNode {
	return s.GetToken(PCREParserOUC, 0)
}

func (s *Newline_conventionContext) DUC() antlr.TerminalNode {
	return s.GetToken(PCREParserDUC, 0)
}

func (s *Newline_conventionContext) EUC() antlr.TerminalNode {
	return s.GetToken(PCREParserEUC, 0)
}

func (s *Newline_conventionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Newline_conventionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Newline_conventionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterNewline_convention(s)
	}
}

func (s *Newline_conventionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitNewline_convention(s)
	}
}

func (p *PCREParser) Newline_convention() (localctx INewline_conventionContext) {
	this := p
	_ = this

	localctx = NewNewline_conventionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, PCREParserRULE_newline_convention)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(784)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 35, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(723)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(724)
			p.Match(PCREParserStar)
		}
		{
			p.SetState(725)
			p.Match(PCREParserCUC)
		}
		{
			p.SetState(726)
			p.Match(PCREParserRUC)
		}
		{
			p.SetState(727)
			p.Match(PCREParserCloseParen)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(728)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(729)
			p.Match(PCREParserStar)
		}
		{
			p.SetState(730)
			p.Match(PCREParserLUC)
		}
		{
			p.SetState(731)
			p.Match(PCREParserFUC)
		}
		{
			p.SetState(732)
			p.Match(PCREParserCloseParen)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(733)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(734)
			p.Match(PCREParserStar)
		}
		{
			p.SetState(735)
			p.Match(PCREParserCUC)
		}
		{
			p.SetState(736)
			p.Match(PCREParserRUC)
		}
		{
			p.SetState(737)
			p.Match(PCREParserLUC)
		}
		{
			p.SetState(738)
			p.Match(PCREParserFUC)
		}
		{
			p.SetState(739)
			p.Match(PCREParserCloseParen)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(740)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(741)
			p.Match(PCREParserStar)
		}
		{
			p.SetState(742)
			p.Match(PCREParserAUC)
		}
		{
			p.SetState(743)
			p.Match(PCREParserNUC)
		}
		{
			p.SetState(744)
			p.Match(PCREParserYUC)
		}
		{
			p.SetState(745)
			p.Match(PCREParserCUC)
		}
		{
			p.SetState(746)
			p.Match(PCREParserRUC)
		}
		{
			p.SetState(747)
			p.Match(PCREParserLUC)
		}
		{
			p.SetState(748)
			p.Match(PCREParserFUC)
		}
		{
			p.SetState(749)
			p.Match(PCREParserCloseParen)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(750)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(751)
			p.Match(PCREParserStar)
		}
		{
			p.SetState(752)
			p.Match(PCREParserAUC)
		}
		{
			p.SetState(753)
			p.Match(PCREParserNUC)
		}
		{
			p.SetState(754)
			p.Match(PCREParserYUC)
		}
		{
			p.SetState(755)
			p.Match(PCREParserCloseParen)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(756)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(757)
			p.Match(PCREParserStar)
		}
		{
			p.SetState(758)
			p.Match(PCREParserBUC)
		}
		{
			p.SetState(759)
			p.Match(PCREParserSUC)
		}
		{
			p.SetState(760)
			p.Match(PCREParserRUC)
		}
		{
			p.SetState(761)
			p.Match(PCREParserUnderscore)
		}
		{
			p.SetState(762)
			p.Match(PCREParserAUC)
		}
		{
			p.SetState(763)
			p.Match(PCREParserNUC)
		}
		{
			p.SetState(764)
			p.Match(PCREParserYUC)
		}
		{
			p.SetState(765)
			p.Match(PCREParserCUC)
		}
		{
			p.SetState(766)
			p.Match(PCREParserRUC)
		}
		{
			p.SetState(767)
			p.Match(PCREParserLUC)
		}
		{
			p.SetState(768)
			p.Match(PCREParserFUC)
		}
		{
			p.SetState(769)
			p.Match(PCREParserCloseParen)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(770)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(771)
			p.Match(PCREParserStar)
		}
		{
			p.SetState(772)
			p.Match(PCREParserBUC)
		}
		{
			p.SetState(773)
			p.Match(PCREParserSUC)
		}
		{
			p.SetState(774)
			p.Match(PCREParserRUC)
		}
		{
			p.SetState(775)
			p.Match(PCREParserUnderscore)
		}
		{
			p.SetState(776)
			p.Match(PCREParserUUC)
		}
		{
			p.SetState(777)
			p.Match(PCREParserNUC)
		}
		{
			p.SetState(778)
			p.Match(PCREParserIUC)
		}
		{
			p.SetState(779)
			p.Match(PCREParserCUC)
		}
		{
			p.SetState(780)
			p.Match(PCREParserOUC)
		}
		{
			p.SetState(781)
			p.Match(PCREParserDUC)
		}
		{
			p.SetState(782)
			p.Match(PCREParserEUC)
		}
		{
			p.SetState(783)
			p.Match(PCREParserCloseParen)
		}

	}

	return localctx
}

// ICalloutContext is an interface to support dynamic dispatch.
type ICalloutContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCalloutContext differentiates from other interfaces.
	IsCalloutContext()
}

type CalloutContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCalloutContext() *CalloutContext {
	var p = new(CalloutContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PCREParserRULE_callout
	return p
}

func (*CalloutContext) IsCalloutContext() {}

func NewCalloutContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CalloutContext {
	var p = new(CalloutContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_callout

	return p
}

func (s *CalloutContext) GetParser() antlr.Parser { return s.parser }

func (s *CalloutContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(PCREParserOpenParen, 0)
}

func (s *CalloutContext) QuestionMark() antlr.TerminalNode {
	return s.GetToken(PCREParserQuestionMark, 0)
}

func (s *CalloutContext) CUC() antlr.TerminalNode {
	return s.GetToken(PCREParserCUC, 0)
}

func (s *CalloutContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(PCREParserCloseParen, 0)
}

func (s *CalloutContext) Number() INumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *CalloutContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CalloutContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CalloutContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterCallout(s)
	}
}

func (s *CalloutContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitCallout(s)
	}
}

func (p *PCREParser) Callout() (localctx ICalloutContext) {
	this := p
	_ = this

	localctx = NewCalloutContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, PCREParserRULE_callout)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(796)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 36, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(786)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(787)
			p.Match(PCREParserQuestionMark)
		}
		{
			p.SetState(788)
			p.Match(PCREParserCUC)
		}
		{
			p.SetState(789)
			p.Match(PCREParserCloseParen)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(790)
			p.Match(PCREParserOpenParen)
		}
		{
			p.SetState(791)
			p.Match(PCREParserQuestionMark)
		}
		{
			p.SetState(792)
			p.Match(PCREParserCUC)
		}
		{
			p.SetState(793)
			p.Number()
		}
		{
			p.SetState(794)
			p.Match(PCREParserCloseParen)
		}

	}

	return localctx
}

// IAtomContext is an interface to support dynamic dispatch.
type IAtomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtomContext differentiates from other interfaces.
	IsAtomContext()
}

type AtomContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtomContext() *AtomContext {
	var p = new(AtomContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PCREParserRULE_atom
	return p
}

func (*AtomContext) IsAtomContext() {}

func NewAtomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtomContext {
	var p = new(AtomContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_atom

	return p
}

func (s *AtomContext) GetParser() antlr.Parser { return s.parser }

func (s *AtomContext) Subroutine_reference() ISubroutine_referenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubroutine_referenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubroutine_referenceContext)
}

func (s *AtomContext) Shared_atom() IShared_atomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IShared_atomContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IShared_atomContext)
}

func (s *AtomContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *AtomContext) Character_class() ICharacter_classContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICharacter_classContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICharacter_classContext)
}

func (s *AtomContext) Capture() ICaptureContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICaptureContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICaptureContext)
}

func (s *AtomContext) Non_capture() INon_captureContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INon_captureContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INon_captureContext)
}

func (s *AtomContext) Comment() ICommentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICommentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *AtomContext) Option() IOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOptionContext)
}

func (s *AtomContext) Look_around() ILook_aroundContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILook_aroundContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILook_aroundContext)
}

func (s *AtomContext) Backreference() IBackreferenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBackreferenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBackreferenceContext)
}

func (s *AtomContext) Conditional() IConditionalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditionalContext)
}

func (s *AtomContext) Backtrack_control() IBacktrack_controlContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBacktrack_controlContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBacktrack_controlContext)
}

func (s *AtomContext) Newline_convention() INewline_conventionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INewline_conventionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INewline_conventionContext)
}

func (s *AtomContext) Callout() ICalloutContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICalloutContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICalloutContext)
}

func (s *AtomContext) Dot() antlr.TerminalNode {
	return s.GetToken(PCREParserDot, 0)
}

func (s *AtomContext) Caret() antlr.TerminalNode {
	return s.GetToken(PCREParserCaret, 0)
}

func (s *AtomContext) StartOfSubject() antlr.TerminalNode {
	return s.GetToken(PCREParserStartOfSubject, 0)
}

func (s *AtomContext) WordBoundary() antlr.TerminalNode {
	return s.GetToken(PCREParserWordBoundary, 0)
}

func (s *AtomContext) NonWordBoundary() antlr.TerminalNode {
	return s.GetToken(PCREParserNonWordBoundary, 0)
}

func (s *AtomContext) EndOfSubjectOrLine() antlr.TerminalNode {
	return s.GetToken(PCREParserEndOfSubjectOrLine, 0)
}

func (s *AtomContext) EndOfSubjectOrLineEndOfSubject() antlr.TerminalNode {
	return s.GetToken(PCREParserEndOfSubjectOrLineEndOfSubject, 0)
}

func (s *AtomContext) EndOfSubject() antlr.TerminalNode {
	return s.GetToken(PCREParserEndOfSubject, 0)
}

func (s *AtomContext) PreviousMatchInSubject() antlr.TerminalNode {
	return s.GetToken(PCREParserPreviousMatchInSubject, 0)
}

func (s *AtomContext) ResetStartMatch() antlr.TerminalNode {
	return s.GetToken(PCREParserResetStartMatch, 0)
}

func (s *AtomContext) OneDataUnit() antlr.TerminalNode {
	return s.GetToken(PCREParserOneDataUnit, 0)
}

func (s *AtomContext) ExtendedUnicodeChar() antlr.TerminalNode {
	return s.GetToken(PCREParserExtendedUnicodeChar, 0)
}

func (s *AtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterAtom(s)
	}
}

func (s *AtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitAtom(s)
	}
}

func (p *PCREParser) Atom() (localctx IAtomContext) {
	this := p
	_ = this

	localctx = NewAtomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, PCREParserRULE_atom)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(824)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 37, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(798)
			p.Subroutine_reference()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(799)
			p.Shared_atom()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(800)
			p.Literal()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(801)
			p.Character_class()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(802)
			p.Capture()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(803)
			p.Non_capture()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(804)
			p.Comment()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(805)
			p.Option()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(806)
			p.Look_around()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(807)
			p.Backreference()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(808)
			p.Conditional()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(809)
			p.Backtrack_control()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(810)
			p.Newline_convention()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(811)
			p.Callout()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(812)
			p.Match(PCREParserDot)
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(813)
			p.Match(PCREParserCaret)
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(814)
			p.Match(PCREParserStartOfSubject)
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(815)
			p.Match(PCREParserWordBoundary)
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(816)
			p.Match(PCREParserNonWordBoundary)
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(817)
			p.Match(PCREParserEndOfSubjectOrLine)
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(818)
			p.Match(PCREParserEndOfSubjectOrLineEndOfSubject)
		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(819)
			p.Match(PCREParserEndOfSubject)
		}

	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(820)
			p.Match(PCREParserPreviousMatchInSubject)
		}

	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(821)
			p.Match(PCREParserResetStartMatch)
		}

	case 25:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(822)
			p.Match(PCREParserOneDataUnit)
		}

	case 26:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(823)
			p.Match(PCREParserExtendedUnicodeChar)
		}

	}

	return localctx
}

// ICc_atomContext is an interface to support dynamic dispatch.
type ICc_atomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCc_atomContext differentiates from other interfaces.
	IsCc_atomContext()
}

type Cc_atomContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCc_atomContext() *Cc_atomContext {
	var p = new(Cc_atomContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PCREParserRULE_cc_atom
	return p
}

func (*Cc_atomContext) IsCc_atomContext() {}

func NewCc_atomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cc_atomContext {
	var p = new(Cc_atomContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_cc_atom

	return p
}

func (s *Cc_atomContext) GetParser() antlr.Parser { return s.parser }

func (s *Cc_atomContext) AllCc_literal() []ICc_literalContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICc_literalContext)(nil)).Elem())
	var tst = make([]ICc_literalContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICc_literalContext)
		}
	}

	return tst
}

func (s *Cc_atomContext) Cc_literal(i int) ICc_literalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICc_literalContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICc_literalContext)
}

func (s *Cc_atomContext) Hyphen() antlr.TerminalNode {
	return s.GetToken(PCREParserHyphen, 0)
}

func (s *Cc_atomContext) Shared_atom() IShared_atomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IShared_atomContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IShared_atomContext)
}

func (s *Cc_atomContext) Backreference_or_octal() IBackreference_or_octalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBackreference_or_octalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBackreference_or_octalContext)
}

func (s *Cc_atomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cc_atomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cc_atomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterCc_atom(s)
	}
}

func (s *Cc_atomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitCc_atom(s)
	}
}

func (p *PCREParser) Cc_atom() (localctx ICc_atomContext) {
	this := p
	_ = this

	localctx = NewCc_atomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, PCREParserRULE_cc_atom)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(833)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 38, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(826)
			p.Cc_literal()
		}
		{
			p.SetState(827)
			p.Match(PCREParserHyphen)
		}
		{
			p.SetState(828)
			p.Cc_literal()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(830)
			p.Shared_atom()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(831)
			p.Cc_literal()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(832)
			p.Backreference_or_octal()
		}

	}

	return localctx
}

// IShared_atomContext is an interface to support dynamic dispatch.
type IShared_atomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsShared_atomContext differentiates from other interfaces.
	IsShared_atomContext()
}

type Shared_atomContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShared_atomContext() *Shared_atomContext {
	var p = new(Shared_atomContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PCREParserRULE_shared_atom
	return p
}

func (*Shared_atomContext) IsShared_atomContext() {}

func NewShared_atomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Shared_atomContext {
	var p = new(Shared_atomContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_shared_atom

	return p
}

func (s *Shared_atomContext) GetParser() antlr.Parser { return s.parser }

func (s *Shared_atomContext) POSIXNamedSet() antlr.TerminalNode {
	return s.GetToken(PCREParserPOSIXNamedSet, 0)
}

func (s *Shared_atomContext) POSIXNegatedNamedSet() antlr.TerminalNode {
	return s.GetToken(PCREParserPOSIXNegatedNamedSet, 0)
}

func (s *Shared_atomContext) ControlChar() antlr.TerminalNode {
	return s.GetToken(PCREParserControlChar, 0)
}

func (s *Shared_atomContext) DecimalDigit() antlr.TerminalNode {
	return s.GetToken(PCREParserDecimalDigit, 0)
}

func (s *Shared_atomContext) NotDecimalDigit() antlr.TerminalNode {
	return s.GetToken(PCREParserNotDecimalDigit, 0)
}

func (s *Shared_atomContext) HorizontalWhiteSpace() antlr.TerminalNode {
	return s.GetToken(PCREParserHorizontalWhiteSpace, 0)
}

func (s *Shared_atomContext) NotHorizontalWhiteSpace() antlr.TerminalNode {
	return s.GetToken(PCREParserNotHorizontalWhiteSpace, 0)
}

func (s *Shared_atomContext) NotNewLine() antlr.TerminalNode {
	return s.GetToken(PCREParserNotNewLine, 0)
}

func (s *Shared_atomContext) CharWithProperty() antlr.TerminalNode {
	return s.GetToken(PCREParserCharWithProperty, 0)
}

func (s *Shared_atomContext) CharWithoutProperty() antlr.TerminalNode {
	return s.GetToken(PCREParserCharWithoutProperty, 0)
}

func (s *Shared_atomContext) NewLineSequence() antlr.TerminalNode {
	return s.GetToken(PCREParserNewLineSequence, 0)
}

func (s *Shared_atomContext) WhiteSpace() antlr.TerminalNode {
	return s.GetToken(PCREParserWhiteSpace, 0)
}

func (s *Shared_atomContext) NotWhiteSpace() antlr.TerminalNode {
	return s.GetToken(PCREParserNotWhiteSpace, 0)
}

func (s *Shared_atomContext) VerticalWhiteSpace() antlr.TerminalNode {
	return s.GetToken(PCREParserVerticalWhiteSpace, 0)
}

func (s *Shared_atomContext) NotVerticalWhiteSpace() antlr.TerminalNode {
	return s.GetToken(PCREParserNotVerticalWhiteSpace, 0)
}

func (s *Shared_atomContext) WordChar() antlr.TerminalNode {
	return s.GetToken(PCREParserWordChar, 0)
}

func (s *Shared_atomContext) NotWordChar() antlr.TerminalNode {
	return s.GetToken(PCREParserNotWordChar, 0)
}

func (s *Shared_atomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Shared_atomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Shared_atomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterShared_atom(s)
	}
}

func (s *Shared_atomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitShared_atom(s)
	}
}

func (p *PCREParser) Shared_atom() (localctx IShared_atomContext) {
	this := p
	_ = this

	localctx = NewShared_atomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, PCREParserRULE_shared_atom)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(835)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-4)&-(0x1f+1)) == 0 && ((1<<uint((_la-4)))&((1<<(PCREParserControlChar-4))|(1<<(PCREParserDecimalDigit-4))|(1<<(PCREParserNotDecimalDigit-4))|(1<<(PCREParserHorizontalWhiteSpace-4))|(1<<(PCREParserNotHorizontalWhiteSpace-4))|(1<<(PCREParserNotNewLine-4))|(1<<(PCREParserCharWithProperty-4))|(1<<(PCREParserCharWithoutProperty-4))|(1<<(PCREParserNewLineSequence-4))|(1<<(PCREParserWhiteSpace-4))|(1<<(PCREParserNotWhiteSpace-4))|(1<<(PCREParserVerticalWhiteSpace-4))|(1<<(PCREParserNotVerticalWhiteSpace-4))|(1<<(PCREParserWordChar-4))|(1<<(PCREParserNotWordChar-4))|(1<<(PCREParserPOSIXNamedSet-4))|(1<<(PCREParserPOSIXNegatedNamedSet-4)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PCREParserRULE_literal
	return p
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) Shared_literal() IShared_literalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IShared_literalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IShared_literalContext)
}

func (s *LiteralContext) CharacterClassEnd() antlr.TerminalNode {
	return s.GetToken(PCREParserCharacterClassEnd, 0)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterLiteral(s)
	}
}

func (s *LiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitLiteral(s)
	}
}

func (p *PCREParser) Literal() (localctx ILiteralContext) {
	this := p
	_ = this

	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, PCREParserRULE_literal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(839)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PCREParserQuoted, PCREParserBlockQuoted, PCREParserBellChar, PCREParserEscapeChar, PCREParserFormFeed, PCREParserNewLine, PCREParserCarriageReturn, PCREParserTab, PCREParserBackslash, PCREParserHexChar, PCREParserHyphen, PCREParserOpenBrace, PCREParserCloseBrace, PCREParserComma, PCREParserLessThan, PCREParserGreaterThan, PCREParserSingleQuote, PCREParserUnderscore, PCREParserColon, PCREParserHash, PCREParserEquals, PCREParserExclamation, PCREParserAmpersand, PCREParserALC, PCREParserBLC, PCREParserCLC, PCREParserDLC, PCREParserELC, PCREParserFLC, PCREParserGLC, PCREParserHLC, PCREParserILC, PCREParserJLC, PCREParserKLC, PCREParserLLC, PCREParserMLC, PCREParserNLC, PCREParserOLC, PCREParserPLC, PCREParserQLC, PCREParserRLC, PCREParserSLC, PCREParserTLC, PCREParserULC, PCREParserVLC, PCREParserWLC, PCREParserXLC, PCREParserYLC, PCREParserZLC, PCREParserAUC, PCREParserBUC, PCREParserCUC, PCREParserDUC, PCREParserEUC, PCREParserFUC, PCREParserGUC, PCREParserHUC, PCREParserIUC, PCREParserJUC, PCREParserKUC, PCREParserLUC, PCREParserMUC, PCREParserNUC, PCREParserOUC, PCREParserPUC, PCREParserQUC, PCREParserRUC, PCREParserSUC, PCREParserTUC, PCREParserUUC, PCREParserVUC, PCREParserWUC, PCREParserXUC, PCREParserYUC, PCREParserZUC, PCREParserD1, PCREParserD2, PCREParserD3, PCREParserD4, PCREParserD5, PCREParserD6, PCREParserD7, PCREParserD8, PCREParserD9, PCREParserD0, PCREParserOtherChar:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(837)
			p.Shared_literal()
		}

	case PCREParserCharacterClassEnd:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(838)
			p.Match(PCREParserCharacterClassEnd)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICc_literalContext is an interface to support dynamic dispatch.
type ICc_literalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCc_literalContext differentiates from other interfaces.
	IsCc_literalContext()
}

type Cc_literalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCc_literalContext() *Cc_literalContext {
	var p = new(Cc_literalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PCREParserRULE_cc_literal
	return p
}

func (*Cc_literalContext) IsCc_literalContext() {}

func NewCc_literalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cc_literalContext {
	var p = new(Cc_literalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_cc_literal

	return p
}

func (s *Cc_literalContext) GetParser() antlr.Parser { return s.parser }

func (s *Cc_literalContext) Shared_literal() IShared_literalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IShared_literalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IShared_literalContext)
}

func (s *Cc_literalContext) Dot() antlr.TerminalNode {
	return s.GetToken(PCREParserDot, 0)
}

func (s *Cc_literalContext) CharacterClassStart() antlr.TerminalNode {
	return s.GetToken(PCREParserCharacterClassStart, 0)
}

func (s *Cc_literalContext) Caret() antlr.TerminalNode {
	return s.GetToken(PCREParserCaret, 0)
}

func (s *Cc_literalContext) QuestionMark() antlr.TerminalNode {
	return s.GetToken(PCREParserQuestionMark, 0)
}

func (s *Cc_literalContext) Plus() antlr.TerminalNode {
	return s.GetToken(PCREParserPlus, 0)
}

func (s *Cc_literalContext) Star() antlr.TerminalNode {
	return s.GetToken(PCREParserStar, 0)
}

func (s *Cc_literalContext) WordBoundary() antlr.TerminalNode {
	return s.GetToken(PCREParserWordBoundary, 0)
}

func (s *Cc_literalContext) EndOfSubjectOrLine() antlr.TerminalNode {
	return s.GetToken(PCREParserEndOfSubjectOrLine, 0)
}

func (s *Cc_literalContext) Pipe() antlr.TerminalNode {
	return s.GetToken(PCREParserPipe, 0)
}

func (s *Cc_literalContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(PCREParserOpenParen, 0)
}

func (s *Cc_literalContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(PCREParserCloseParen, 0)
}

func (s *Cc_literalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cc_literalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cc_literalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterCc_literal(s)
	}
}

func (s *Cc_literalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitCc_literal(s)
	}
}

func (p *PCREParser) Cc_literal() (localctx ICc_literalContext) {
	this := p
	_ = this

	localctx = NewCc_literalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, PCREParserRULE_cc_literal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(853)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PCREParserQuoted, PCREParserBlockQuoted, PCREParserBellChar, PCREParserEscapeChar, PCREParserFormFeed, PCREParserNewLine, PCREParserCarriageReturn, PCREParserTab, PCREParserBackslash, PCREParserHexChar, PCREParserHyphen, PCREParserOpenBrace, PCREParserCloseBrace, PCREParserComma, PCREParserLessThan, PCREParserGreaterThan, PCREParserSingleQuote, PCREParserUnderscore, PCREParserColon, PCREParserHash, PCREParserEquals, PCREParserExclamation, PCREParserAmpersand, PCREParserALC, PCREParserBLC, PCREParserCLC, PCREParserDLC, PCREParserELC, PCREParserFLC, PCREParserGLC, PCREParserHLC, PCREParserILC, PCREParserJLC, PCREParserKLC, PCREParserLLC, PCREParserMLC, PCREParserNLC, PCREParserOLC, PCREParserPLC, PCREParserQLC, PCREParserRLC, PCREParserSLC, PCREParserTLC, PCREParserULC, PCREParserVLC, PCREParserWLC, PCREParserXLC, PCREParserYLC, PCREParserZLC, PCREParserAUC, PCREParserBUC, PCREParserCUC, PCREParserDUC, PCREParserEUC, PCREParserFUC, PCREParserGUC, PCREParserHUC, PCREParserIUC, PCREParserJUC, PCREParserKUC, PCREParserLUC, PCREParserMUC, PCREParserNUC, PCREParserOUC, PCREParserPUC, PCREParserQUC, PCREParserRUC, PCREParserSUC, PCREParserTUC, PCREParserUUC, PCREParserVUC, PCREParserWUC, PCREParserXUC, PCREParserYUC, PCREParserZUC, PCREParserD1, PCREParserD2, PCREParserD3, PCREParserD4, PCREParserD5, PCREParserD6, PCREParserD7, PCREParserD8, PCREParserD9, PCREParserD0, PCREParserOtherChar:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(841)
			p.Shared_literal()
		}

	case PCREParserDot:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(842)
			p.Match(PCREParserDot)
		}

	case PCREParserCharacterClassStart:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(843)
			p.Match(PCREParserCharacterClassStart)
		}

	case PCREParserCaret:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(844)
			p.Match(PCREParserCaret)
		}

	case PCREParserQuestionMark:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(845)
			p.Match(PCREParserQuestionMark)
		}

	case PCREParserPlus:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(846)
			p.Match(PCREParserPlus)
		}

	case PCREParserStar:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(847)
			p.Match(PCREParserStar)
		}

	case PCREParserWordBoundary:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(848)
			p.Match(PCREParserWordBoundary)
		}

	case PCREParserEndOfSubjectOrLine:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(849)
			p.Match(PCREParserEndOfSubjectOrLine)
		}

	case PCREParserPipe:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(850)
			p.Match(PCREParserPipe)
		}

	case PCREParserOpenParen:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(851)
			p.Match(PCREParserOpenParen)
		}

	case PCREParserCloseParen:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(852)
			p.Match(PCREParserCloseParen)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IShared_literalContext is an interface to support dynamic dispatch.
type IShared_literalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsShared_literalContext differentiates from other interfaces.
	IsShared_literalContext()
}

type Shared_literalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShared_literalContext() *Shared_literalContext {
	var p = new(Shared_literalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PCREParserRULE_shared_literal
	return p
}

func (*Shared_literalContext) IsShared_literalContext() {}

func NewShared_literalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Shared_literalContext {
	var p = new(Shared_literalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_shared_literal

	return p
}

func (s *Shared_literalContext) GetParser() antlr.Parser { return s.parser }

func (s *Shared_literalContext) Octal_char() IOctal_charContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOctal_charContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOctal_charContext)
}

func (s *Shared_literalContext) Letter() ILetterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILetterContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILetterContext)
}

func (s *Shared_literalContext) Digit() IDigitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDigitContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDigitContext)
}

func (s *Shared_literalContext) BellChar() antlr.TerminalNode {
	return s.GetToken(PCREParserBellChar, 0)
}

func (s *Shared_literalContext) EscapeChar() antlr.TerminalNode {
	return s.GetToken(PCREParserEscapeChar, 0)
}

func (s *Shared_literalContext) FormFeed() antlr.TerminalNode {
	return s.GetToken(PCREParserFormFeed, 0)
}

func (s *Shared_literalContext) NewLine() antlr.TerminalNode {
	return s.GetToken(PCREParserNewLine, 0)
}

func (s *Shared_literalContext) CarriageReturn() antlr.TerminalNode {
	return s.GetToken(PCREParserCarriageReturn, 0)
}

func (s *Shared_literalContext) Tab() antlr.TerminalNode {
	return s.GetToken(PCREParserTab, 0)
}

func (s *Shared_literalContext) HexChar() antlr.TerminalNode {
	return s.GetToken(PCREParserHexChar, 0)
}

func (s *Shared_literalContext) Quoted() antlr.TerminalNode {
	return s.GetToken(PCREParserQuoted, 0)
}

func (s *Shared_literalContext) BlockQuoted() antlr.TerminalNode {
	return s.GetToken(PCREParserBlockQuoted, 0)
}

func (s *Shared_literalContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(PCREParserOpenBrace, 0)
}

func (s *Shared_literalContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(PCREParserCloseBrace, 0)
}

func (s *Shared_literalContext) Comma() antlr.TerminalNode {
	return s.GetToken(PCREParserComma, 0)
}

func (s *Shared_literalContext) Hyphen() antlr.TerminalNode {
	return s.GetToken(PCREParserHyphen, 0)
}

func (s *Shared_literalContext) LessThan() antlr.TerminalNode {
	return s.GetToken(PCREParserLessThan, 0)
}

func (s *Shared_literalContext) GreaterThan() antlr.TerminalNode {
	return s.GetToken(PCREParserGreaterThan, 0)
}

func (s *Shared_literalContext) SingleQuote() antlr.TerminalNode {
	return s.GetToken(PCREParserSingleQuote, 0)
}

func (s *Shared_literalContext) Underscore() antlr.TerminalNode {
	return s.GetToken(PCREParserUnderscore, 0)
}

func (s *Shared_literalContext) Colon() antlr.TerminalNode {
	return s.GetToken(PCREParserColon, 0)
}

func (s *Shared_literalContext) Hash() antlr.TerminalNode {
	return s.GetToken(PCREParserHash, 0)
}

func (s *Shared_literalContext) Equals() antlr.TerminalNode {
	return s.GetToken(PCREParserEquals, 0)
}

func (s *Shared_literalContext) Exclamation() antlr.TerminalNode {
	return s.GetToken(PCREParserExclamation, 0)
}

func (s *Shared_literalContext) Ampersand() antlr.TerminalNode {
	return s.GetToken(PCREParserAmpersand, 0)
}

func (s *Shared_literalContext) OtherChar() antlr.TerminalNode {
	return s.GetToken(PCREParserOtherChar, 0)
}

func (s *Shared_literalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Shared_literalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Shared_literalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterShared_literal(s)
	}
}

func (s *Shared_literalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitShared_literal(s)
	}
}

func (p *PCREParser) Shared_literal() (localctx IShared_literalContext) {
	this := p
	_ = this

	localctx = NewShared_literalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, PCREParserRULE_shared_literal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(881)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PCREParserBackslash:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(855)
			p.Octal_char()
		}

	case PCREParserALC, PCREParserBLC, PCREParserCLC, PCREParserDLC, PCREParserELC, PCREParserFLC, PCREParserGLC, PCREParserHLC, PCREParserILC, PCREParserJLC, PCREParserKLC, PCREParserLLC, PCREParserMLC, PCREParserNLC, PCREParserOLC, PCREParserPLC, PCREParserQLC, PCREParserRLC, PCREParserSLC, PCREParserTLC, PCREParserULC, PCREParserVLC, PCREParserWLC, PCREParserXLC, PCREParserYLC, PCREParserZLC, PCREParserAUC, PCREParserBUC, PCREParserCUC, PCREParserDUC, PCREParserEUC, PCREParserFUC, PCREParserGUC, PCREParserHUC, PCREParserIUC, PCREParserJUC, PCREParserKUC, PCREParserLUC, PCREParserMUC, PCREParserNUC, PCREParserOUC, PCREParserPUC, PCREParserQUC, PCREParserRUC, PCREParserSUC, PCREParserTUC, PCREParserUUC, PCREParserVUC, PCREParserWUC, PCREParserXUC, PCREParserYUC, PCREParserZUC:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(856)
			p.Letter()
		}

	case PCREParserD1, PCREParserD2, PCREParserD3, PCREParserD4, PCREParserD5, PCREParserD6, PCREParserD7, PCREParserD8, PCREParserD9, PCREParserD0:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(857)
			p.Digit()
		}

	case PCREParserBellChar:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(858)
			p.Match(PCREParserBellChar)
		}

	case PCREParserEscapeChar:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(859)
			p.Match(PCREParserEscapeChar)
		}

	case PCREParserFormFeed:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(860)
			p.Match(PCREParserFormFeed)
		}

	case PCREParserNewLine:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(861)
			p.Match(PCREParserNewLine)
		}

	case PCREParserCarriageReturn:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(862)
			p.Match(PCREParserCarriageReturn)
		}

	case PCREParserTab:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(863)
			p.Match(PCREParserTab)
		}

	case PCREParserHexChar:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(864)
			p.Match(PCREParserHexChar)
		}

	case PCREParserQuoted:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(865)
			p.Match(PCREParserQuoted)
		}

	case PCREParserBlockQuoted:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(866)
			p.Match(PCREParserBlockQuoted)
		}

	case PCREParserOpenBrace:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(867)
			p.Match(PCREParserOpenBrace)
		}

	case PCREParserCloseBrace:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(868)
			p.Match(PCREParserCloseBrace)
		}

	case PCREParserComma:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(869)
			p.Match(PCREParserComma)
		}

	case PCREParserHyphen:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(870)
			p.Match(PCREParserHyphen)
		}

	case PCREParserLessThan:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(871)
			p.Match(PCREParserLessThan)
		}

	case PCREParserGreaterThan:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(872)
			p.Match(PCREParserGreaterThan)
		}

	case PCREParserSingleQuote:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(873)
			p.Match(PCREParserSingleQuote)
		}

	case PCREParserUnderscore:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(874)
			p.Match(PCREParserUnderscore)
		}

	case PCREParserColon:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(875)
			p.Match(PCREParserColon)
		}

	case PCREParserHash:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(876)
			p.Match(PCREParserHash)
		}

	case PCREParserEquals:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(877)
			p.Match(PCREParserEquals)
		}

	case PCREParserExclamation:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(878)
			p.Match(PCREParserExclamation)
		}

	case PCREParserAmpersand:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(879)
			p.Match(PCREParserAmpersand)
		}

	case PCREParserOtherChar:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(880)
			p.Match(PCREParserOtherChar)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// INumberContext is an interface to support dynamic dispatch.
type INumberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNumberContext differentiates from other interfaces.
	IsNumberContext()
}

type NumberContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumberContext() *NumberContext {
	var p = new(NumberContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PCREParserRULE_number
	return p
}

func (*NumberContext) IsNumberContext() {}

func NewNumberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumberContext {
	var p = new(NumberContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_number

	return p
}

func (s *NumberContext) GetParser() antlr.Parser { return s.parser }

func (s *NumberContext) Digits() IDigitsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDigitsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDigitsContext)
}

func (s *NumberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NumberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterNumber(s)
	}
}

func (s *NumberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitNumber(s)
	}
}

func (p *PCREParser) Number() (localctx INumberContext) {
	this := p
	_ = this

	localctx = NewNumberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, PCREParserRULE_number)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(883)
		p.Digits()
	}

	return localctx
}

// IOctal_charContext is an interface to support dynamic dispatch.
type IOctal_charContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOctal_charContext differentiates from other interfaces.
	IsOctal_charContext()
}

type Octal_charContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOctal_charContext() *Octal_charContext {
	var p = new(Octal_charContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PCREParserRULE_octal_char
	return p
}

func (*Octal_charContext) IsOctal_charContext() {}

func NewOctal_charContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Octal_charContext {
	var p = new(Octal_charContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_octal_char

	return p
}

func (s *Octal_charContext) GetParser() antlr.Parser { return s.parser }

func (s *Octal_charContext) Backslash() antlr.TerminalNode {
	return s.GetToken(PCREParserBackslash, 0)
}

func (s *Octal_charContext) AllOctal_digit() []IOctal_digitContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOctal_digitContext)(nil)).Elem())
	var tst = make([]IOctal_digitContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOctal_digitContext)
		}
	}

	return tst
}

func (s *Octal_charContext) Octal_digit(i int) IOctal_digitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOctal_digitContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOctal_digitContext)
}

func (s *Octal_charContext) D0() antlr.TerminalNode {
	return s.GetToken(PCREParserD0, 0)
}

func (s *Octal_charContext) D1() antlr.TerminalNode {
	return s.GetToken(PCREParserD1, 0)
}

func (s *Octal_charContext) D2() antlr.TerminalNode {
	return s.GetToken(PCREParserD2, 0)
}

func (s *Octal_charContext) D3() antlr.TerminalNode {
	return s.GetToken(PCREParserD3, 0)
}

func (s *Octal_charContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Octal_charContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Octal_charContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterOctal_char(s)
	}
}

func (s *Octal_charContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitOctal_char(s)
	}
}

func (p *PCREParser) Octal_char() (localctx IOctal_charContext) {
	this := p
	_ = this

	localctx = NewOctal_charContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, PCREParserRULE_octal_char)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(894)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 42, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(885)
			p.Match(PCREParserBackslash)
		}
		{
			p.SetState(886)
			_la = p.GetTokenStream().LA(1)

			if !(((_la-115)&-(0x1f+1)) == 0 && ((1<<uint((_la-115)))&((1<<(PCREParserD1-115))|(1<<(PCREParserD2-115))|(1<<(PCREParserD3-115))|(1<<(PCREParserD0-115)))) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(887)
			p.Octal_digit()
		}
		{
			p.SetState(888)
			p.Octal_digit()
		}

	case 2:
		{
			p.SetState(890)
			p.Match(PCREParserBackslash)
		}
		{
			p.SetState(891)
			p.Octal_digit()
		}
		{
			p.SetState(892)
			p.Octal_digit()
		}

	}

	return localctx
}

// IOctal_digitContext is an interface to support dynamic dispatch.
type IOctal_digitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOctal_digitContext differentiates from other interfaces.
	IsOctal_digitContext()
}

type Octal_digitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOctal_digitContext() *Octal_digitContext {
	var p = new(Octal_digitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PCREParserRULE_octal_digit
	return p
}

func (*Octal_digitContext) IsOctal_digitContext() {}

func NewOctal_digitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Octal_digitContext {
	var p = new(Octal_digitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_octal_digit

	return p
}

func (s *Octal_digitContext) GetParser() antlr.Parser { return s.parser }

func (s *Octal_digitContext) D0() antlr.TerminalNode {
	return s.GetToken(PCREParserD0, 0)
}

func (s *Octal_digitContext) D1() antlr.TerminalNode {
	return s.GetToken(PCREParserD1, 0)
}

func (s *Octal_digitContext) D2() antlr.TerminalNode {
	return s.GetToken(PCREParserD2, 0)
}

func (s *Octal_digitContext) D3() antlr.TerminalNode {
	return s.GetToken(PCREParserD3, 0)
}

func (s *Octal_digitContext) D4() antlr.TerminalNode {
	return s.GetToken(PCREParserD4, 0)
}

func (s *Octal_digitContext) D5() antlr.TerminalNode {
	return s.GetToken(PCREParserD5, 0)
}

func (s *Octal_digitContext) D6() antlr.TerminalNode {
	return s.GetToken(PCREParserD6, 0)
}

func (s *Octal_digitContext) D7() antlr.TerminalNode {
	return s.GetToken(PCREParserD7, 0)
}

func (s *Octal_digitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Octal_digitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Octal_digitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterOctal_digit(s)
	}
}

func (s *Octal_digitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitOctal_digit(s)
	}
}

func (p *PCREParser) Octal_digit() (localctx IOctal_digitContext) {
	this := p
	_ = this

	localctx = NewOctal_digitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, PCREParserRULE_octal_digit)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(896)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-115)&-(0x1f+1)) == 0 && ((1<<uint((_la-115)))&((1<<(PCREParserD1-115))|(1<<(PCREParserD2-115))|(1<<(PCREParserD3-115))|(1<<(PCREParserD4-115))|(1<<(PCREParserD5-115))|(1<<(PCREParserD6-115))|(1<<(PCREParserD7-115))|(1<<(PCREParserD0-115)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IDigitsContext is an interface to support dynamic dispatch.
type IDigitsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDigitsContext differentiates from other interfaces.
	IsDigitsContext()
}

type DigitsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDigitsContext() *DigitsContext {
	var p = new(DigitsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PCREParserRULE_digits
	return p
}

func (*DigitsContext) IsDigitsContext() {}

func NewDigitsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DigitsContext {
	var p = new(DigitsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_digits

	return p
}

func (s *DigitsContext) GetParser() antlr.Parser { return s.parser }

func (s *DigitsContext) AllDigit() []IDigitContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDigitContext)(nil)).Elem())
	var tst = make([]IDigitContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDigitContext)
		}
	}

	return tst
}

func (s *DigitsContext) Digit(i int) IDigitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDigitContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDigitContext)
}

func (s *DigitsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DigitsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DigitsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterDigits(s)
	}
}

func (s *DigitsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitDigits(s)
	}
}

func (p *PCREParser) Digits() (localctx IDigitsContext) {
	this := p
	_ = this

	localctx = NewDigitsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, PCREParserRULE_digits)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(899)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(898)
				p.Digit()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(901)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 43, p.GetParserRuleContext())
	}

	return localctx
}

// IDigitContext is an interface to support dynamic dispatch.
type IDigitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDigitContext differentiates from other interfaces.
	IsDigitContext()
}

type DigitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDigitContext() *DigitContext {
	var p = new(DigitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PCREParserRULE_digit
	return p
}

func (*DigitContext) IsDigitContext() {}

func NewDigitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DigitContext {
	var p = new(DigitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_digit

	return p
}

func (s *DigitContext) GetParser() antlr.Parser { return s.parser }

func (s *DigitContext) D0() antlr.TerminalNode {
	return s.GetToken(PCREParserD0, 0)
}

func (s *DigitContext) D1() antlr.TerminalNode {
	return s.GetToken(PCREParserD1, 0)
}

func (s *DigitContext) D2() antlr.TerminalNode {
	return s.GetToken(PCREParserD2, 0)
}

func (s *DigitContext) D3() antlr.TerminalNode {
	return s.GetToken(PCREParserD3, 0)
}

func (s *DigitContext) D4() antlr.TerminalNode {
	return s.GetToken(PCREParserD4, 0)
}

func (s *DigitContext) D5() antlr.TerminalNode {
	return s.GetToken(PCREParserD5, 0)
}

func (s *DigitContext) D6() antlr.TerminalNode {
	return s.GetToken(PCREParserD6, 0)
}

func (s *DigitContext) D7() antlr.TerminalNode {
	return s.GetToken(PCREParserD7, 0)
}

func (s *DigitContext) D8() antlr.TerminalNode {
	return s.GetToken(PCREParserD8, 0)
}

func (s *DigitContext) D9() antlr.TerminalNode {
	return s.GetToken(PCREParserD9, 0)
}

func (s *DigitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DigitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DigitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterDigit(s)
	}
}

func (s *DigitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitDigit(s)
	}
}

func (p *PCREParser) Digit() (localctx IDigitContext) {
	this := p
	_ = this

	localctx = NewDigitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, PCREParserRULE_digit)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(903)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-115)&-(0x1f+1)) == 0 && ((1<<uint((_la-115)))&((1<<(PCREParserD1-115))|(1<<(PCREParserD2-115))|(1<<(PCREParserD3-115))|(1<<(PCREParserD4-115))|(1<<(PCREParserD5-115))|(1<<(PCREParserD6-115))|(1<<(PCREParserD7-115))|(1<<(PCREParserD8-115))|(1<<(PCREParserD9-115))|(1<<(PCREParserD0-115)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// INameContext is an interface to support dynamic dispatch.
type INameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNameContext differentiates from other interfaces.
	IsNameContext()
}

type NameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNameContext() *NameContext {
	var p = new(NameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PCREParserRULE_name
	return p
}

func (*NameContext) IsNameContext() {}

func NewNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NameContext {
	var p = new(NameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_name

	return p
}

func (s *NameContext) GetParser() antlr.Parser { return s.parser }

func (s *NameContext) Alpha_nums() IAlpha_numsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlpha_numsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlpha_numsContext)
}

func (s *NameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterName(s)
	}
}

func (s *NameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitName(s)
	}
}

func (p *PCREParser) Name() (localctx INameContext) {
	this := p
	_ = this

	localctx = NewNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, PCREParserRULE_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(905)
		p.Alpha_nums()
	}

	return localctx
}

// IAlpha_numsContext is an interface to support dynamic dispatch.
type IAlpha_numsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlpha_numsContext differentiates from other interfaces.
	IsAlpha_numsContext()
}

type Alpha_numsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlpha_numsContext() *Alpha_numsContext {
	var p = new(Alpha_numsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PCREParserRULE_alpha_nums
	return p
}

func (*Alpha_numsContext) IsAlpha_numsContext() {}

func NewAlpha_numsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alpha_numsContext {
	var p = new(Alpha_numsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_alpha_nums

	return p
}

func (s *Alpha_numsContext) GetParser() antlr.Parser { return s.parser }

func (s *Alpha_numsContext) AllLetter() []ILetterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILetterContext)(nil)).Elem())
	var tst = make([]ILetterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILetterContext)
		}
	}

	return tst
}

func (s *Alpha_numsContext) Letter(i int) ILetterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILetterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILetterContext)
}

func (s *Alpha_numsContext) AllUnderscore() []antlr.TerminalNode {
	return s.GetTokens(PCREParserUnderscore)
}

func (s *Alpha_numsContext) Underscore(i int) antlr.TerminalNode {
	return s.GetToken(PCREParserUnderscore, i)
}

func (s *Alpha_numsContext) AllDigit() []IDigitContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDigitContext)(nil)).Elem())
	var tst = make([]IDigitContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDigitContext)
		}
	}

	return tst
}

func (s *Alpha_numsContext) Digit(i int) IDigitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDigitContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDigitContext)
}

func (s *Alpha_numsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alpha_numsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alpha_numsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterAlpha_nums(s)
	}
}

func (s *Alpha_numsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitAlpha_nums(s)
	}
}

func (p *PCREParser) Alpha_nums() (localctx IAlpha_numsContext) {
	this := p
	_ = this

	localctx = NewAlpha_numsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, PCREParserRULE_alpha_nums)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(909)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PCREParserALC, PCREParserBLC, PCREParserCLC, PCREParserDLC, PCREParserELC, PCREParserFLC, PCREParserGLC, PCREParserHLC, PCREParserILC, PCREParserJLC, PCREParserKLC, PCREParserLLC, PCREParserMLC, PCREParserNLC, PCREParserOLC, PCREParserPLC, PCREParserQLC, PCREParserRLC, PCREParserSLC, PCREParserTLC, PCREParserULC, PCREParserVLC, PCREParserWLC, PCREParserXLC, PCREParserYLC, PCREParserZLC, PCREParserAUC, PCREParserBUC, PCREParserCUC, PCREParserDUC, PCREParserEUC, PCREParserFUC, PCREParserGUC, PCREParserHUC, PCREParserIUC, PCREParserJUC, PCREParserKUC, PCREParserLUC, PCREParserMUC, PCREParserNUC, PCREParserOUC, PCREParserPUC, PCREParserQUC, PCREParserRUC, PCREParserSUC, PCREParserTUC, PCREParserUUC, PCREParserVUC, PCREParserWUC, PCREParserXUC, PCREParserYUC, PCREParserZUC:
		{
			p.SetState(907)
			p.Letter()
		}

	case PCREParserUnderscore:
		{
			p.SetState(908)
			p.Match(PCREParserUnderscore)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(916)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la-57)&-(0x1f+1)) == 0 && ((1<<uint((_la-57)))&((1<<(PCREParserUnderscore-57))|(1<<(PCREParserALC-57))|(1<<(PCREParserBLC-57))|(1<<(PCREParserCLC-57))|(1<<(PCREParserDLC-57))|(1<<(PCREParserELC-57))|(1<<(PCREParserFLC-57))|(1<<(PCREParserGLC-57))|(1<<(PCREParserHLC-57))|(1<<(PCREParserILC-57))|(1<<(PCREParserJLC-57))|(1<<(PCREParserKLC-57))|(1<<(PCREParserLLC-57))|(1<<(PCREParserMLC-57))|(1<<(PCREParserNLC-57))|(1<<(PCREParserOLC-57))|(1<<(PCREParserPLC-57))|(1<<(PCREParserQLC-57))|(1<<(PCREParserRLC-57))|(1<<(PCREParserSLC-57))|(1<<(PCREParserTLC-57))|(1<<(PCREParserULC-57))|(1<<(PCREParserVLC-57))|(1<<(PCREParserWLC-57))|(1<<(PCREParserXLC-57))|(1<<(PCREParserYLC-57))|(1<<(PCREParserZLC-57)))) != 0) || (((_la-89)&-(0x1f+1)) == 0 && ((1<<uint((_la-89)))&((1<<(PCREParserAUC-89))|(1<<(PCREParserBUC-89))|(1<<(PCREParserCUC-89))|(1<<(PCREParserDUC-89))|(1<<(PCREParserEUC-89))|(1<<(PCREParserFUC-89))|(1<<(PCREParserGUC-89))|(1<<(PCREParserHUC-89))|(1<<(PCREParserIUC-89))|(1<<(PCREParserJUC-89))|(1<<(PCREParserKUC-89))|(1<<(PCREParserLUC-89))|(1<<(PCREParserMUC-89))|(1<<(PCREParserNUC-89))|(1<<(PCREParserOUC-89))|(1<<(PCREParserPUC-89))|(1<<(PCREParserQUC-89))|(1<<(PCREParserRUC-89))|(1<<(PCREParserSUC-89))|(1<<(PCREParserTUC-89))|(1<<(PCREParserUUC-89))|(1<<(PCREParserVUC-89))|(1<<(PCREParserWUC-89))|(1<<(PCREParserXUC-89))|(1<<(PCREParserYUC-89))|(1<<(PCREParserZUC-89))|(1<<(PCREParserD1-89))|(1<<(PCREParserD2-89))|(1<<(PCREParserD3-89))|(1<<(PCREParserD4-89))|(1<<(PCREParserD5-89))|(1<<(PCREParserD6-89)))) != 0) || (((_la-121)&-(0x1f+1)) == 0 && ((1<<uint((_la-121)))&((1<<(PCREParserD7-121))|(1<<(PCREParserD8-121))|(1<<(PCREParserD9-121))|(1<<(PCREParserD0-121)))) != 0) {
		p.SetState(914)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case PCREParserALC, PCREParserBLC, PCREParserCLC, PCREParserDLC, PCREParserELC, PCREParserFLC, PCREParserGLC, PCREParserHLC, PCREParserILC, PCREParserJLC, PCREParserKLC, PCREParserLLC, PCREParserMLC, PCREParserNLC, PCREParserOLC, PCREParserPLC, PCREParserQLC, PCREParserRLC, PCREParserSLC, PCREParserTLC, PCREParserULC, PCREParserVLC, PCREParserWLC, PCREParserXLC, PCREParserYLC, PCREParserZLC, PCREParserAUC, PCREParserBUC, PCREParserCUC, PCREParserDUC, PCREParserEUC, PCREParserFUC, PCREParserGUC, PCREParserHUC, PCREParserIUC, PCREParserJUC, PCREParserKUC, PCREParserLUC, PCREParserMUC, PCREParserNUC, PCREParserOUC, PCREParserPUC, PCREParserQUC, PCREParserRUC, PCREParserSUC, PCREParserTUC, PCREParserUUC, PCREParserVUC, PCREParserWUC, PCREParserXUC, PCREParserYUC, PCREParserZUC:
			{
				p.SetState(911)
				p.Letter()
			}

		case PCREParserUnderscore:
			{
				p.SetState(912)
				p.Match(PCREParserUnderscore)
			}

		case PCREParserD1, PCREParserD2, PCREParserD3, PCREParserD4, PCREParserD5, PCREParserD6, PCREParserD7, PCREParserD8, PCREParserD9, PCREParserD0:
			{
				p.SetState(913)
				p.Digit()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(918)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// INon_close_parensContext is an interface to support dynamic dispatch.
type INon_close_parensContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNon_close_parensContext differentiates from other interfaces.
	IsNon_close_parensContext()
}

type Non_close_parensContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNon_close_parensContext() *Non_close_parensContext {
	var p = new(Non_close_parensContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PCREParserRULE_non_close_parens
	return p
}

func (*Non_close_parensContext) IsNon_close_parensContext() {}

func NewNon_close_parensContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Non_close_parensContext {
	var p = new(Non_close_parensContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_non_close_parens

	return p
}

func (s *Non_close_parensContext) GetParser() antlr.Parser { return s.parser }

func (s *Non_close_parensContext) AllNon_close_paren() []INon_close_parenContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INon_close_parenContext)(nil)).Elem())
	var tst = make([]INon_close_parenContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INon_close_parenContext)
		}
	}

	return tst
}

func (s *Non_close_parensContext) Non_close_paren(i int) INon_close_parenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INon_close_parenContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INon_close_parenContext)
}

func (s *Non_close_parensContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Non_close_parensContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Non_close_parensContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterNon_close_parens(s)
	}
}

func (s *Non_close_parensContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitNon_close_parens(s)
	}
}

func (p *PCREParser) Non_close_parens() (localctx INon_close_parensContext) {
	this := p
	_ = this

	localctx = NewNon_close_parensContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, PCREParserRULE_non_close_parens)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(920)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PCREParserQuoted)|(1<<PCREParserBlockQuoted)|(1<<PCREParserBellChar)|(1<<PCREParserControlChar)|(1<<PCREParserEscapeChar)|(1<<PCREParserFormFeed)|(1<<PCREParserNewLine)|(1<<PCREParserCarriageReturn)|(1<<PCREParserTab)|(1<<PCREParserBackslash)|(1<<PCREParserHexChar)|(1<<PCREParserDot)|(1<<PCREParserOneDataUnit)|(1<<PCREParserDecimalDigit)|(1<<PCREParserNotDecimalDigit)|(1<<PCREParserHorizontalWhiteSpace)|(1<<PCREParserNotHorizontalWhiteSpace)|(1<<PCREParserNotNewLine)|(1<<PCREParserCharWithProperty)|(1<<PCREParserCharWithoutProperty)|(1<<PCREParserNewLineSequence)|(1<<PCREParserWhiteSpace)|(1<<PCREParserNotWhiteSpace)|(1<<PCREParserVerticalWhiteSpace)|(1<<PCREParserNotVerticalWhiteSpace)|(1<<PCREParserWordChar)|(1<<PCREParserNotWordChar)|(1<<PCREParserExtendedUnicodeChar)|(1<<PCREParserCharacterClassStart)|(1<<PCREParserCharacterClassEnd)|(1<<PCREParserCaret))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(PCREParserHyphen-32))|(1<<(PCREParserPOSIXNamedSet-32))|(1<<(PCREParserPOSIXNegatedNamedSet-32))|(1<<(PCREParserQuestionMark-32))|(1<<(PCREParserPlus-32))|(1<<(PCREParserStar-32))|(1<<(PCREParserOpenBrace-32))|(1<<(PCREParserCloseBrace-32))|(1<<(PCREParserComma-32))|(1<<(PCREParserWordBoundary-32))|(1<<(PCREParserNonWordBoundary-32))|(1<<(PCREParserStartOfSubject-32))|(1<<(PCREParserEndOfSubjectOrLine-32))|(1<<(PCREParserEndOfSubjectOrLineEndOfSubject-32))|(1<<(PCREParserEndOfSubject-32))|(1<<(PCREParserPreviousMatchInSubject-32))|(1<<(PCREParserResetStartMatch-32))|(1<<(PCREParserSubroutineOrNamedReferenceStartG-32))|(1<<(PCREParserNamedReferenceStartK-32))|(1<<(PCREParserPipe-32))|(1<<(PCREParserOpenParen-32))|(1<<(PCREParserLessThan-32))|(1<<(PCREParserGreaterThan-32))|(1<<(PCREParserSingleQuote-32))|(1<<(PCREParserUnderscore-32))|(1<<(PCREParserColon-32))|(1<<(PCREParserHash-32))|(1<<(PCREParserEquals-32))|(1<<(PCREParserExclamation-32))|(1<<(PCREParserAmpersand-32))|(1<<(PCREParserALC-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(PCREParserBLC-64))|(1<<(PCREParserCLC-64))|(1<<(PCREParserDLC-64))|(1<<(PCREParserELC-64))|(1<<(PCREParserFLC-64))|(1<<(PCREParserGLC-64))|(1<<(PCREParserHLC-64))|(1<<(PCREParserILC-64))|(1<<(PCREParserJLC-64))|(1<<(PCREParserKLC-64))|(1<<(PCREParserLLC-64))|(1<<(PCREParserMLC-64))|(1<<(PCREParserNLC-64))|(1<<(PCREParserOLC-64))|(1<<(PCREParserPLC-64))|(1<<(PCREParserQLC-64))|(1<<(PCREParserRLC-64))|(1<<(PCREParserSLC-64))|(1<<(PCREParserTLC-64))|(1<<(PCREParserULC-64))|(1<<(PCREParserVLC-64))|(1<<(PCREParserWLC-64))|(1<<(PCREParserXLC-64))|(1<<(PCREParserYLC-64))|(1<<(PCREParserZLC-64))|(1<<(PCREParserAUC-64))|(1<<(PCREParserBUC-64))|(1<<(PCREParserCUC-64))|(1<<(PCREParserDUC-64))|(1<<(PCREParserEUC-64))|(1<<(PCREParserFUC-64))|(1<<(PCREParserGUC-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(PCREParserHUC-96))|(1<<(PCREParserIUC-96))|(1<<(PCREParserJUC-96))|(1<<(PCREParserKUC-96))|(1<<(PCREParserLUC-96))|(1<<(PCREParserMUC-96))|(1<<(PCREParserNUC-96))|(1<<(PCREParserOUC-96))|(1<<(PCREParserPUC-96))|(1<<(PCREParserQUC-96))|(1<<(PCREParserRUC-96))|(1<<(PCREParserSUC-96))|(1<<(PCREParserTUC-96))|(1<<(PCREParserUUC-96))|(1<<(PCREParserVUC-96))|(1<<(PCREParserWUC-96))|(1<<(PCREParserXUC-96))|(1<<(PCREParserYUC-96))|(1<<(PCREParserZUC-96))|(1<<(PCREParserD1-96))|(1<<(PCREParserD2-96))|(1<<(PCREParserD3-96))|(1<<(PCREParserD4-96))|(1<<(PCREParserD5-96))|(1<<(PCREParserD6-96))|(1<<(PCREParserD7-96))|(1<<(PCREParserD8-96))|(1<<(PCREParserD9-96))|(1<<(PCREParserD0-96))|(1<<(PCREParserOtherChar-96)))) != 0) {
		{
			p.SetState(919)
			p.Non_close_paren()
		}

		p.SetState(922)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// INon_close_parenContext is an interface to support dynamic dispatch.
type INon_close_parenContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNon_close_parenContext differentiates from other interfaces.
	IsNon_close_parenContext()
}

type Non_close_parenContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNon_close_parenContext() *Non_close_parenContext {
	var p = new(Non_close_parenContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PCREParserRULE_non_close_paren
	return p
}

func (*Non_close_parenContext) IsNon_close_parenContext() {}

func NewNon_close_parenContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Non_close_parenContext {
	var p = new(Non_close_parenContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_non_close_paren

	return p
}

func (s *Non_close_parenContext) GetParser() antlr.Parser { return s.parser }

func (s *Non_close_parenContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(PCREParserCloseParen, 0)
}

func (s *Non_close_parenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Non_close_parenContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Non_close_parenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterNon_close_paren(s)
	}
}

func (s *Non_close_parenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitNon_close_paren(s)
	}
}

func (p *PCREParser) Non_close_paren() (localctx INon_close_parenContext) {
	this := p
	_ = this

	localctx = NewNon_close_parenContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, PCREParserRULE_non_close_paren)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(924)
		_la = p.GetTokenStream().LA(1)

		if _la <= 0 || _la == PCREParserCloseParen {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ILetterContext is an interface to support dynamic dispatch.
type ILetterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLetterContext differentiates from other interfaces.
	IsLetterContext()
}

type LetterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLetterContext() *LetterContext {
	var p = new(LetterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PCREParserRULE_letter
	return p
}

func (*LetterContext) IsLetterContext() {}

func NewLetterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LetterContext {
	var p = new(LetterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_letter

	return p
}

func (s *LetterContext) GetParser() antlr.Parser { return s.parser }

func (s *LetterContext) ALC() antlr.TerminalNode {
	return s.GetToken(PCREParserALC, 0)
}

func (s *LetterContext) BLC() antlr.TerminalNode {
	return s.GetToken(PCREParserBLC, 0)
}

func (s *LetterContext) CLC() antlr.TerminalNode {
	return s.GetToken(PCREParserCLC, 0)
}

func (s *LetterContext) DLC() antlr.TerminalNode {
	return s.GetToken(PCREParserDLC, 0)
}

func (s *LetterContext) ELC() antlr.TerminalNode {
	return s.GetToken(PCREParserELC, 0)
}

func (s *LetterContext) FLC() antlr.TerminalNode {
	return s.GetToken(PCREParserFLC, 0)
}

func (s *LetterContext) GLC() antlr.TerminalNode {
	return s.GetToken(PCREParserGLC, 0)
}

func (s *LetterContext) HLC() antlr.TerminalNode {
	return s.GetToken(PCREParserHLC, 0)
}

func (s *LetterContext) ILC() antlr.TerminalNode {
	return s.GetToken(PCREParserILC, 0)
}

func (s *LetterContext) JLC() antlr.TerminalNode {
	return s.GetToken(PCREParserJLC, 0)
}

func (s *LetterContext) KLC() antlr.TerminalNode {
	return s.GetToken(PCREParserKLC, 0)
}

func (s *LetterContext) LLC() antlr.TerminalNode {
	return s.GetToken(PCREParserLLC, 0)
}

func (s *LetterContext) MLC() antlr.TerminalNode {
	return s.GetToken(PCREParserMLC, 0)
}

func (s *LetterContext) NLC() antlr.TerminalNode {
	return s.GetToken(PCREParserNLC, 0)
}

func (s *LetterContext) OLC() antlr.TerminalNode {
	return s.GetToken(PCREParserOLC, 0)
}

func (s *LetterContext) PLC() antlr.TerminalNode {
	return s.GetToken(PCREParserPLC, 0)
}

func (s *LetterContext) QLC() antlr.TerminalNode {
	return s.GetToken(PCREParserQLC, 0)
}

func (s *LetterContext) RLC() antlr.TerminalNode {
	return s.GetToken(PCREParserRLC, 0)
}

func (s *LetterContext) SLC() antlr.TerminalNode {
	return s.GetToken(PCREParserSLC, 0)
}

func (s *LetterContext) TLC() antlr.TerminalNode {
	return s.GetToken(PCREParserTLC, 0)
}

func (s *LetterContext) ULC() antlr.TerminalNode {
	return s.GetToken(PCREParserULC, 0)
}

func (s *LetterContext) VLC() antlr.TerminalNode {
	return s.GetToken(PCREParserVLC, 0)
}

func (s *LetterContext) WLC() antlr.TerminalNode {
	return s.GetToken(PCREParserWLC, 0)
}

func (s *LetterContext) XLC() antlr.TerminalNode {
	return s.GetToken(PCREParserXLC, 0)
}

func (s *LetterContext) YLC() antlr.TerminalNode {
	return s.GetToken(PCREParserYLC, 0)
}

func (s *LetterContext) ZLC() antlr.TerminalNode {
	return s.GetToken(PCREParserZLC, 0)
}

func (s *LetterContext) AUC() antlr.TerminalNode {
	return s.GetToken(PCREParserAUC, 0)
}

func (s *LetterContext) BUC() antlr.TerminalNode {
	return s.GetToken(PCREParserBUC, 0)
}

func (s *LetterContext) CUC() antlr.TerminalNode {
	return s.GetToken(PCREParserCUC, 0)
}

func (s *LetterContext) DUC() antlr.TerminalNode {
	return s.GetToken(PCREParserDUC, 0)
}

func (s *LetterContext) EUC() antlr.TerminalNode {
	return s.GetToken(PCREParserEUC, 0)
}

func (s *LetterContext) FUC() antlr.TerminalNode {
	return s.GetToken(PCREParserFUC, 0)
}

func (s *LetterContext) GUC() antlr.TerminalNode {
	return s.GetToken(PCREParserGUC, 0)
}

func (s *LetterContext) HUC() antlr.TerminalNode {
	return s.GetToken(PCREParserHUC, 0)
}

func (s *LetterContext) IUC() antlr.TerminalNode {
	return s.GetToken(PCREParserIUC, 0)
}

func (s *LetterContext) JUC() antlr.TerminalNode {
	return s.GetToken(PCREParserJUC, 0)
}

func (s *LetterContext) KUC() antlr.TerminalNode {
	return s.GetToken(PCREParserKUC, 0)
}

func (s *LetterContext) LUC() antlr.TerminalNode {
	return s.GetToken(PCREParserLUC, 0)
}

func (s *LetterContext) MUC() antlr.TerminalNode {
	return s.GetToken(PCREParserMUC, 0)
}

func (s *LetterContext) NUC() antlr.TerminalNode {
	return s.GetToken(PCREParserNUC, 0)
}

func (s *LetterContext) OUC() antlr.TerminalNode {
	return s.GetToken(PCREParserOUC, 0)
}

func (s *LetterContext) PUC() antlr.TerminalNode {
	return s.GetToken(PCREParserPUC, 0)
}

func (s *LetterContext) QUC() antlr.TerminalNode {
	return s.GetToken(PCREParserQUC, 0)
}

func (s *LetterContext) RUC() antlr.TerminalNode {
	return s.GetToken(PCREParserRUC, 0)
}

func (s *LetterContext) SUC() antlr.TerminalNode {
	return s.GetToken(PCREParserSUC, 0)
}

func (s *LetterContext) TUC() antlr.TerminalNode {
	return s.GetToken(PCREParserTUC, 0)
}

func (s *LetterContext) UUC() antlr.TerminalNode {
	return s.GetToken(PCREParserUUC, 0)
}

func (s *LetterContext) VUC() antlr.TerminalNode {
	return s.GetToken(PCREParserVUC, 0)
}

func (s *LetterContext) WUC() antlr.TerminalNode {
	return s.GetToken(PCREParserWUC, 0)
}

func (s *LetterContext) XUC() antlr.TerminalNode {
	return s.GetToken(PCREParserXUC, 0)
}

func (s *LetterContext) YUC() antlr.TerminalNode {
	return s.GetToken(PCREParserYUC, 0)
}

func (s *LetterContext) ZUC() antlr.TerminalNode {
	return s.GetToken(PCREParserZUC, 0)
}

func (s *LetterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LetterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterLetter(s)
	}
}

func (s *LetterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitLetter(s)
	}
}

func (p *PCREParser) Letter() (localctx ILetterContext) {
	this := p
	_ = this

	localctx = NewLetterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, PCREParserRULE_letter)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(926)
		_la = p.GetTokenStream().LA(1)

		if !((((_la-63)&-(0x1f+1)) == 0 && ((1<<uint((_la-63)))&((1<<(PCREParserALC-63))|(1<<(PCREParserBLC-63))|(1<<(PCREParserCLC-63))|(1<<(PCREParserDLC-63))|(1<<(PCREParserELC-63))|(1<<(PCREParserFLC-63))|(1<<(PCREParserGLC-63))|(1<<(PCREParserHLC-63))|(1<<(PCREParserILC-63))|(1<<(PCREParserJLC-63))|(1<<(PCREParserKLC-63))|(1<<(PCREParserLLC-63))|(1<<(PCREParserMLC-63))|(1<<(PCREParserNLC-63))|(1<<(PCREParserOLC-63))|(1<<(PCREParserPLC-63))|(1<<(PCREParserQLC-63))|(1<<(PCREParserRLC-63))|(1<<(PCREParserSLC-63))|(1<<(PCREParserTLC-63))|(1<<(PCREParserULC-63))|(1<<(PCREParserVLC-63))|(1<<(PCREParserWLC-63))|(1<<(PCREParserXLC-63))|(1<<(PCREParserYLC-63))|(1<<(PCREParserZLC-63))|(1<<(PCREParserAUC-63))|(1<<(PCREParserBUC-63))|(1<<(PCREParserCUC-63))|(1<<(PCREParserDUC-63))|(1<<(PCREParserEUC-63))|(1<<(PCREParserFUC-63)))) != 0) || (((_la-95)&-(0x1f+1)) == 0 && ((1<<uint((_la-95)))&((1<<(PCREParserGUC-95))|(1<<(PCREParserHUC-95))|(1<<(PCREParserIUC-95))|(1<<(PCREParserJUC-95))|(1<<(PCREParserKUC-95))|(1<<(PCREParserLUC-95))|(1<<(PCREParserMUC-95))|(1<<(PCREParserNUC-95))|(1<<(PCREParserOUC-95))|(1<<(PCREParserPUC-95))|(1<<(PCREParserQUC-95))|(1<<(PCREParserRUC-95))|(1<<(PCREParserSUC-95))|(1<<(PCREParserTUC-95))|(1<<(PCREParserUUC-95))|(1<<(PCREParserVUC-95))|(1<<(PCREParserWUC-95))|(1<<(PCREParserXUC-95))|(1<<(PCREParserYUC-95))|(1<<(PCREParserZUC-95)))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}
