// Code generated from Pddl.g4 by ANTLR 4.9.3. DO NOT EDIT.

package pddl // Pddl
import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 115, 936,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4,
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55,
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9,
	60, 4, 61, 9, 61, 4, 62, 9, 62, 4, 63, 9, 63, 4, 64, 9, 64, 4, 65, 9, 65,
	4, 66, 9, 66, 4, 67, 9, 67, 4, 68, 9, 68, 4, 69, 9, 69, 4, 70, 9, 70, 4,
	71, 9, 71, 3, 2, 3, 2, 5, 2, 145, 10, 2, 3, 3, 3, 3, 3, 3, 3, 3, 5, 3,
	151, 10, 3, 3, 3, 5, 3, 154, 10, 3, 3, 3, 5, 3, 157, 10, 3, 3, 3, 5, 3,
	160, 10, 3, 3, 3, 5, 3, 163, 10, 3, 3, 3, 5, 3, 166, 10, 3, 3, 3, 7, 3,
	169, 10, 3, 12, 3, 14, 3, 172, 11, 3, 3, 3, 3, 3, 3, 4, 3, 4, 3, 4, 3,
	4, 3, 4, 3, 5, 3, 5, 3, 5, 6, 5, 184, 10, 5, 13, 5, 14, 5, 185, 3, 5, 3,
	5, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 7, 7, 7, 196, 10, 7, 12, 7, 14, 7,
	199, 11, 7, 3, 7, 6, 7, 202, 10, 7, 13, 7, 14, 7, 203, 3, 7, 7, 7, 207,
	10, 7, 12, 7, 14, 7, 210, 11, 7, 5, 7, 212, 10, 7, 3, 8, 6, 8, 215, 10,
	8, 13, 8, 14, 8, 216, 3, 8, 3, 8, 3, 8, 3, 9, 3, 9, 3, 9, 6, 9, 225, 10,
	9, 13, 9, 14, 9, 226, 3, 9, 3, 9, 3, 9, 5, 9, 232, 10, 9, 3, 10, 3, 10,
	3, 11, 3, 11, 3, 11, 3, 11, 3, 11, 3, 12, 6, 12, 242, 10, 12, 13, 12, 14,
	12, 243, 3, 12, 3, 12, 5, 12, 248, 10, 12, 7, 12, 250, 10, 12, 12, 12,
	14, 12, 253, 11, 12, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 14, 3, 14, 3,
	15, 3, 15, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 17, 3, 17, 3, 17, 6, 17,
	272, 10, 17, 13, 17, 14, 17, 273, 3, 17, 3, 17, 3, 18, 3, 18, 3, 18, 3,
	18, 3, 18, 3, 19, 3, 19, 3, 20, 7, 20, 286, 10, 20, 12, 20, 14, 20, 289,
	11, 20, 3, 20, 6, 20, 292, 10, 20, 13, 20, 14, 20, 293, 3, 20, 7, 20, 297,
	10, 20, 12, 20, 14, 20, 300, 11, 20, 5, 20, 302, 10, 20, 3, 21, 6, 21,
	305, 10, 21, 13, 21, 14, 21, 306, 3, 21, 3, 21, 3, 21, 3, 22, 3, 22, 3,
	22, 3, 22, 3, 22, 3, 23, 3, 23, 3, 23, 5, 23, 320, 10, 23, 3, 24, 3, 24,
	3, 24, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24, 3, 25, 3, 25, 3,
	26, 3, 26, 3, 26, 3, 26, 5, 26, 338, 10, 26, 5, 26, 340, 10, 26, 3, 26,
	3, 26, 3, 26, 3, 26, 5, 26, 346, 10, 26, 5, 26, 348, 10, 26, 3, 27, 3,
	27, 3, 27, 3, 27, 7, 27, 354, 10, 27, 12, 27, 14, 27, 357, 11, 27, 3, 27,
	3, 27, 3, 27, 3, 27, 7, 27, 363, 10, 27, 12, 27, 14, 27, 366, 11, 27, 3,
	27, 3, 27, 3, 27, 3, 27, 3, 27, 3, 27, 3, 27, 3, 27, 3, 27, 3, 27, 3, 27,
	3, 27, 3, 27, 3, 27, 3, 27, 3, 27, 3, 27, 3, 27, 3, 27, 3, 27, 3, 27, 3,
	27, 3, 27, 3, 27, 3, 27, 3, 27, 3, 27, 3, 27, 3, 27, 5, 27, 397, 10, 27,
	3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 29, 3, 29, 3, 29, 7, 29, 408,
	10, 29, 12, 29, 14, 29, 411, 11, 29, 3, 29, 3, 29, 3, 30, 3, 30, 3, 31,
	3, 31, 3, 31, 3, 31, 3, 31, 3, 31, 3, 31, 3, 31, 3, 31, 3, 31, 3, 32, 3,
	32, 3, 32, 3, 32, 3, 32, 3, 32, 5, 32, 433, 10, 32, 3, 32, 3, 32, 3, 32,
	3, 32, 5, 32, 439, 10, 32, 5, 32, 441, 10, 32, 3, 33, 3, 33, 3, 33, 3,
	33, 7, 33, 447, 10, 33, 12, 33, 14, 33, 450, 11, 33, 3, 33, 3, 33, 3, 33,
	3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 5, 33, 461, 10, 33, 3, 34, 3,
	34, 3, 34, 3, 34, 5, 34, 467, 10, 34, 3, 34, 3, 34, 3, 34, 5, 34, 472,
	10, 34, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35,
	3, 35, 3, 35, 3, 35, 5, 35, 486, 10, 35, 3, 36, 3, 36, 3, 37, 3, 37, 3,
	38, 3, 38, 3, 38, 3, 38, 3, 38, 3, 38, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39,
	3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 5, 39, 511, 10,
	39, 3, 40, 3, 40, 3, 41, 3, 41, 3, 41, 7, 41, 518, 10, 41, 12, 41, 14,
	41, 521, 11, 41, 3, 41, 3, 41, 3, 41, 5, 41, 526, 10, 41, 3, 42, 3, 42,
	3, 42, 7, 42, 531, 10, 42, 12, 42, 14, 42, 534, 11, 42, 3, 42, 3, 42, 5,
	42, 538, 10, 42, 3, 43, 3, 43, 3, 43, 3, 43, 3, 43, 3, 43, 3, 43, 3, 43,
	3, 43, 3, 43, 3, 43, 3, 43, 3, 43, 3, 43, 3, 43, 5, 43, 555, 10, 43, 3,
	44, 3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 3, 44,
	3, 44, 5, 44, 569, 10, 44, 3, 45, 3, 45, 3, 45, 7, 45, 574, 10, 45, 12,
	45, 14, 45, 577, 11, 45, 3, 45, 3, 45, 5, 45, 581, 10, 45, 3, 46, 3, 46,
	3, 47, 3, 47, 3, 48, 3, 48, 3, 49, 3, 49, 3, 49, 6, 49, 592, 10, 49, 13,
	49, 14, 49, 593, 3, 49, 3, 49, 3, 49, 3, 49, 3, 49, 5, 49, 601, 10, 49,
	3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3,
	50, 3, 50, 5, 50, 615, 10, 50, 3, 51, 3, 51, 3, 52, 3, 52, 5, 52, 621,
	10, 52, 3, 53, 3, 53, 3, 53, 7, 53, 626, 10, 53, 12, 53, 14, 53, 629, 11,
	53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53,
	3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3,
	53, 3, 53, 5, 53, 653, 10, 53, 3, 54, 3, 54, 3, 54, 3, 54, 3, 54, 3, 54,
	3, 54, 3, 54, 3, 54, 3, 54, 3, 54, 3, 54, 3, 54, 3, 54, 3, 54, 3, 54, 3,
	54, 3, 54, 5, 54, 673, 10, 54, 3, 55, 3, 55, 3, 55, 3, 55, 3, 55, 3, 55,
	3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 5, 56, 688, 10, 56, 3,
	56, 3, 56, 3, 56, 3, 56, 5, 56, 694, 10, 56, 3, 57, 3, 57, 3, 57, 3, 57,
	3, 57, 5, 57, 701, 10, 57, 3, 57, 5, 57, 704, 10, 57, 3, 57, 3, 57, 3,
	57, 5, 57, 709, 10, 57, 3, 57, 5, 57, 712, 10, 57, 3, 58, 3, 58, 3, 58,
	3, 58, 3, 58, 3, 59, 3, 59, 3, 59, 3, 59, 3, 59, 3, 60, 3, 60, 3, 60, 3,
	60, 3, 60, 3, 61, 3, 61, 3, 61, 7, 61, 732, 10, 61, 12, 61, 14, 61, 735,
	11, 61, 3, 61, 3, 61, 3, 62, 3, 62, 3, 62, 3, 62, 3, 62, 3, 62, 3, 62,
	3, 62, 3, 62, 3, 62, 3, 62, 3, 62, 3, 62, 5, 62, 752, 10, 62, 3, 63, 3,
	63, 3, 63, 3, 63, 3, 63, 3, 63, 5, 63, 760, 10, 63, 3, 64, 3, 64, 3, 64,
	7, 64, 765, 10, 64, 12, 64, 14, 64, 768, 11, 64, 3, 64, 3, 64, 3, 65, 3,
	65, 3, 65, 3, 65, 3, 65, 3, 66, 3, 66, 3, 66, 3, 66, 3, 66, 3, 67, 3, 67,
	3, 67, 7, 67, 785, 10, 67, 12, 67, 14, 67, 788, 11, 67, 3, 67, 3, 67, 3,
	67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 5, 67,
	802, 10, 67, 3, 67, 3, 67, 3, 67, 3, 67, 5, 67, 808, 10, 67, 3, 68, 3,
	68, 3, 68, 3, 68, 3, 68, 3, 68, 3, 69, 3, 69, 3, 70, 3, 70, 3, 70, 3, 70,
	3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 6, 70, 828, 10, 70, 13, 70, 14,
	70, 829, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70,
	3, 70, 3, 70, 7, 70, 843, 10, 70, 12, 70, 14, 70, 846, 11, 70, 3, 70, 3,
	70, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 5, 70, 856, 10, 70, 3, 71,
	3, 71, 3, 71, 7, 71, 861, 10, 71, 12, 71, 14, 71, 864, 11, 71, 3, 71, 3,
	71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71,
	3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3,
	71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71,
	3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3,
	71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71,
	3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3,
	71, 3, 71, 3, 71, 3, 71, 5, 71, 934, 10, 71, 3, 71, 2, 2, 72, 2, 4, 6,
	8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42,
	44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78,
	80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112,
	114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 2,
	10, 3, 2, 111, 112, 3, 2, 32, 33, 4, 2, 9, 9, 37, 39, 3, 2, 40, 44, 3,
	2, 45, 49, 3, 2, 42, 44, 3, 2, 57, 58, 4, 2, 37, 37, 39, 39, 2, 979, 2,
	144, 3, 2, 2, 2, 4, 146, 3, 2, 2, 2, 6, 175, 3, 2, 2, 2, 8, 180, 3, 2,
	2, 2, 10, 189, 3, 2, 2, 2, 12, 211, 3, 2, 2, 2, 14, 214, 3, 2, 2, 2, 16,
	231, 3, 2, 2, 2, 18, 233, 3, 2, 2, 2, 20, 235, 3, 2, 2, 2, 22, 251, 3,
	2, 2, 2, 24, 254, 3, 2, 2, 2, 26, 259, 3, 2, 2, 2, 28, 261, 3, 2, 2, 2,
	30, 263, 3, 2, 2, 2, 32, 268, 3, 2, 2, 2, 34, 277, 3, 2, 2, 2, 36, 282,
	3, 2, 2, 2, 38, 301, 3, 2, 2, 2, 40, 304, 3, 2, 2, 2, 42, 311, 3, 2, 2,
	2, 44, 319, 3, 2, 2, 2, 46, 321, 3, 2, 2, 2, 48, 331, 3, 2, 2, 2, 50, 339,
	3, 2, 2, 2, 52, 396, 3, 2, 2, 2, 54, 398, 3, 2, 2, 2, 56, 404, 3, 2, 2,
	2, 58, 414, 3, 2, 2, 2, 60, 416, 3, 2, 2, 2, 62, 440, 3, 2, 2, 2, 64, 460,
	3, 2, 2, 2, 66, 471, 3, 2, 2, 2, 68, 485, 3, 2, 2, 2, 70, 487, 3, 2, 2,
	2, 72, 489, 3, 2, 2, 2, 74, 491, 3, 2, 2, 2, 76, 510, 3, 2, 2, 2, 78, 512,
	3, 2, 2, 2, 80, 525, 3, 2, 2, 2, 82, 537, 3, 2, 2, 2, 84, 554, 3, 2, 2,
	2, 86, 568, 3, 2, 2, 2, 88, 580, 3, 2, 2, 2, 90, 582, 3, 2, 2, 2, 92, 584,
	3, 2, 2, 2, 94, 586, 3, 2, 2, 2, 96, 600, 3, 2, 2, 2, 98, 614, 3, 2, 2,
	2, 100, 616, 3, 2, 2, 2, 102, 620, 3, 2, 2, 2, 104, 652, 3, 2, 2, 2, 106,
	672, 3, 2, 2, 2, 108, 674, 3, 2, 2, 2, 110, 693, 3, 2, 2, 2, 112, 695,
	3, 2, 2, 2, 114, 713, 3, 2, 2, 2, 116, 718, 3, 2, 2, 2, 118, 723, 3, 2,
	2, 2, 120, 728, 3, 2, 2, 2, 122, 751, 3, 2, 2, 2, 124, 759, 3, 2, 2, 2,
	126, 761, 3, 2, 2, 2, 128, 771, 3, 2, 2, 2, 130, 776, 3, 2, 2, 2, 132,
	807, 3, 2, 2, 2, 134, 809, 3, 2, 2, 2, 136, 815, 3, 2, 2, 2, 138, 855,
	3, 2, 2, 2, 140, 933, 3, 2, 2, 2, 142, 145, 5, 4, 3, 2, 143, 145, 5, 112,
	57, 2, 144, 142, 3, 2, 2, 2, 144, 143, 3, 2, 2, 2, 145, 3, 3, 2, 2, 2,
	146, 147, 7, 3, 2, 2, 147, 148, 7, 4, 2, 2, 148, 150, 5, 6, 4, 2, 149,
	151, 5, 8, 5, 2, 150, 149, 3, 2, 2, 2, 150, 151, 3, 2, 2, 2, 151, 153,
	3, 2, 2, 2, 152, 154, 5, 10, 6, 2, 153, 152, 3, 2, 2, 2, 153, 154, 3, 2,
	2, 2, 154, 156, 3, 2, 2, 2, 155, 157, 5, 30, 16, 2, 156, 155, 3, 2, 2,
	2, 156, 157, 3, 2, 2, 2, 157, 159, 3, 2, 2, 2, 158, 160, 5, 32, 17, 2,
	159, 158, 3, 2, 2, 2, 159, 160, 3, 2, 2, 2, 160, 162, 3, 2, 2, 2, 161,
	163, 5, 20, 11, 2, 162, 161, 3, 2, 2, 2, 162, 163, 3, 2, 2, 2, 163, 165,
	3, 2, 2, 2, 164, 166, 5, 42, 22, 2, 165, 164, 3, 2, 2, 2, 165, 166, 3,
	2, 2, 2, 166, 170, 3, 2, 2, 2, 167, 169, 5, 44, 23, 2, 168, 167, 3, 2,
	2, 2, 169, 172, 3, 2, 2, 2, 170, 168, 3, 2, 2, 2, 170, 171, 3, 2, 2, 2,
	171, 173, 3, 2, 2, 2, 172, 170, 3, 2, 2, 2, 173, 174, 7, 5, 2, 2, 174,
	5, 3, 2, 2, 2, 175, 176, 7, 3, 2, 2, 176, 177, 7, 6, 2, 2, 177, 178, 7,
	111, 2, 2, 178, 179, 7, 5, 2, 2, 179, 7, 3, 2, 2, 2, 180, 181, 7, 3, 2,
	2, 181, 183, 7, 7, 2, 2, 182, 184, 7, 70, 2, 2, 183, 182, 3, 2, 2, 2, 184,
	185, 3, 2, 2, 2, 185, 183, 3, 2, 2, 2, 185, 186, 3, 2, 2, 2, 186, 187,
	3, 2, 2, 2, 187, 188, 7, 5, 2, 2, 188, 9, 3, 2, 2, 2, 189, 190, 7, 3, 2,
	2, 190, 191, 7, 8, 2, 2, 191, 192, 5, 12, 7, 2, 192, 193, 7, 5, 2, 2, 193,
	11, 3, 2, 2, 2, 194, 196, 7, 111, 2, 2, 195, 194, 3, 2, 2, 2, 196, 199,
	3, 2, 2, 2, 197, 195, 3, 2, 2, 2, 197, 198, 3, 2, 2, 2, 198, 212, 3, 2,
	2, 2, 199, 197, 3, 2, 2, 2, 200, 202, 5, 14, 8, 2, 201, 200, 3, 2, 2, 2,
	202, 203, 3, 2, 2, 2, 203, 201, 3, 2, 2, 2, 203, 204, 3, 2, 2, 2, 204,
	208, 3, 2, 2, 2, 205, 207, 7, 111, 2, 2, 206, 205, 3, 2, 2, 2, 207, 210,
	3, 2, 2, 2, 208, 206, 3, 2, 2, 2, 208, 209, 3, 2, 2, 2, 209, 212, 3, 2,
	2, 2, 210, 208, 3, 2, 2, 2, 211, 197, 3, 2, 2, 2, 211, 201, 3, 2, 2, 2,
	212, 13, 3, 2, 2, 2, 213, 215, 7, 111, 2, 2, 214, 213, 3, 2, 2, 2, 215,
	216, 3, 2, 2, 2, 216, 214, 3, 2, 2, 2, 216, 217, 3, 2, 2, 2, 217, 218,
	3, 2, 2, 2, 218, 219, 7, 9, 2, 2, 219, 220, 5, 16, 9, 2, 220, 15, 3, 2,
	2, 2, 221, 222, 7, 3, 2, 2, 222, 224, 7, 10, 2, 2, 223, 225, 5, 18, 10,
	2, 224, 223, 3, 2, 2, 2, 225, 226, 3, 2, 2, 2, 226, 224, 3, 2, 2, 2, 226,
	227, 3, 2, 2, 2, 227, 228, 3, 2, 2, 2, 228, 229, 7, 5, 2, 2, 229, 232,
	3, 2, 2, 2, 230, 232, 5, 18, 10, 2, 231, 221, 3, 2, 2, 2, 231, 230, 3,
	2, 2, 2, 232, 17, 3, 2, 2, 2, 233, 234, 7, 111, 2, 2, 234, 19, 3, 2, 2,
	2, 235, 236, 7, 3, 2, 2, 236, 237, 7, 11, 2, 2, 237, 238, 5, 22, 12, 2,
	238, 239, 7, 5, 2, 2, 239, 21, 3, 2, 2, 2, 240, 242, 5, 24, 13, 2, 241,
	240, 3, 2, 2, 2, 242, 243, 3, 2, 2, 2, 243, 241, 3, 2, 2, 2, 243, 244,
	3, 2, 2, 2, 244, 247, 3, 2, 2, 2, 245, 246, 7, 9, 2, 2, 246, 248, 5, 28,
	15, 2, 247, 245, 3, 2, 2, 2, 247, 248, 3, 2, 2, 2, 248, 250, 3, 2, 2, 2,
	249, 241, 3, 2, 2, 2, 250, 253, 3, 2, 2, 2, 251, 249, 3, 2, 2, 2, 251,
	252, 3, 2, 2, 2, 252, 23, 3, 2, 2, 2, 253, 251, 3, 2, 2, 2, 254, 255, 7,
	3, 2, 2, 255, 256, 5, 26, 14, 2, 256, 257, 5, 38, 20, 2, 257, 258, 7, 5,
	2, 2, 258, 25, 3, 2, 2, 2, 259, 260, 7, 111, 2, 2, 260, 27, 3, 2, 2, 2,
	261, 262, 7, 12, 2, 2, 262, 29, 3, 2, 2, 2, 263, 264, 7, 3, 2, 2, 264,
	265, 7, 13, 2, 2, 265, 266, 5, 12, 7, 2, 266, 267, 7, 5, 2, 2, 267, 31,
	3, 2, 2, 2, 268, 269, 7, 3, 2, 2, 269, 271, 7, 14, 2, 2, 270, 272, 5, 34,
	18, 2, 271, 270, 3, 2, 2, 2, 272, 273, 3, 2, 2, 2, 273, 271, 3, 2, 2, 2,
	273, 274, 3, 2, 2, 2, 274, 275, 3, 2, 2, 2, 275, 276, 7, 5, 2, 2, 276,
	33, 3, 2, 2, 2, 277, 278, 7, 3, 2, 2, 278, 279, 5, 36, 19, 2, 279, 280,
	5, 38, 20, 2, 280, 281, 7, 5, 2, 2, 281, 35, 3, 2, 2, 2, 282, 283, 7, 111,
	2, 2, 283, 37, 3, 2, 2, 2, 284, 286, 7, 112, 2, 2, 285, 284, 3, 2, 2, 2,
	286, 289, 3, 2, 2, 2, 287, 285, 3, 2, 2, 2, 287, 288, 3, 2, 2, 2, 288,
	302, 3, 2, 2, 2, 289, 287, 3, 2, 2, 2, 290, 292, 5, 40, 21, 2, 291, 290,
	3, 2, 2, 2, 292, 293, 3, 2, 2, 2, 293, 291, 3, 2, 2, 2, 293, 294, 3, 2,
	2, 2, 294, 298, 3, 2, 2, 2, 295, 297, 7, 112, 2, 2, 296, 295, 3, 2, 2,
	2, 297, 300, 3, 2, 2, 2, 298, 296, 3, 2, 2, 2, 298, 299, 3, 2, 2, 2, 299,
	302, 3, 2, 2, 2, 300, 298, 3, 2, 2, 2, 301, 287, 3, 2, 2, 2, 301, 291,
	3, 2, 2, 2, 302, 39, 3, 2, 2, 2, 303, 305, 7, 112, 2, 2, 304, 303, 3, 2,
	2, 2, 305, 306, 3, 2, 2, 2, 306, 304, 3, 2, 2, 2, 306, 307, 3, 2, 2, 2,
	307, 308, 3, 2, 2, 2, 308, 309, 7, 9, 2, 2, 309, 310, 5, 16, 9, 2, 310,
	41, 3, 2, 2, 2, 311, 312, 7, 3, 2, 2, 312, 313, 7, 15, 2, 2, 313, 314,
	5, 140, 71, 2, 314, 315, 7, 5, 2, 2, 315, 43, 3, 2, 2, 2, 316, 320, 5,
	46, 24, 2, 317, 320, 5, 60, 31, 2, 318, 320, 5, 74, 38, 2, 319, 316, 3,
	2, 2, 2, 319, 317, 3, 2, 2, 2, 319, 318, 3, 2, 2, 2, 320, 45, 3, 2, 2,
	2, 321, 322, 7, 3, 2, 2, 322, 323, 7, 16, 2, 2, 323, 324, 5, 48, 25, 2,
	324, 325, 7, 17, 2, 2, 325, 326, 7, 3, 2, 2, 326, 327, 5, 38, 20, 2, 327,
	328, 7, 5, 2, 2, 328, 329, 5, 50, 26, 2, 329, 330, 7, 5, 2, 2, 330, 47,
	3, 2, 2, 2, 331, 332, 7, 111, 2, 2, 332, 49, 3, 2, 2, 2, 333, 337, 7, 18,
	2, 2, 334, 335, 7, 3, 2, 2, 335, 338, 7, 5, 2, 2, 336, 338, 5, 52, 27,
	2, 337, 334, 3, 2, 2, 2, 337, 336, 3, 2, 2, 2, 338, 340, 3, 2, 2, 2, 339,
	333, 3, 2, 2, 2, 339, 340, 3, 2, 2, 2, 340, 347, 3, 2, 2, 2, 341, 345,
	7, 19, 2, 2, 342, 343, 7, 3, 2, 2, 343, 346, 7, 5, 2, 2, 344, 346, 5, 82,
	42, 2, 345, 342, 3, 2, 2, 2, 345, 344, 3, 2, 2, 2, 346, 348, 3, 2, 2, 2,
	347, 341, 3, 2, 2, 2, 347, 348, 3, 2, 2, 2, 348, 51, 3, 2, 2, 2, 349, 397,
	5, 56, 29, 2, 350, 351, 7, 3, 2, 2, 351, 355, 7, 20, 2, 2, 352, 354, 5,
	52, 27, 2, 353, 352, 3, 2, 2, 2, 354, 357, 3, 2, 2, 2, 355, 353, 3, 2,
	2, 2, 355, 356, 3, 2, 2, 2, 356, 358, 3, 2, 2, 2, 357, 355, 3, 2, 2, 2,
	358, 397, 7, 5, 2, 2, 359, 360, 7, 3, 2, 2, 360, 364, 7, 21, 2, 2, 361,
	363, 5, 52, 27, 2, 362, 361, 3, 2, 2, 2, 363, 366, 3, 2, 2, 2, 364, 362,
	3, 2, 2, 2, 364, 365, 3, 2, 2, 2, 365, 367, 3, 2, 2, 2, 366, 364, 3, 2,
	2, 2, 367, 397, 7, 5, 2, 2, 368, 369, 7, 3, 2, 2, 369, 370, 7, 22, 2, 2,
	370, 371, 5, 52, 27, 2, 371, 372, 7, 5, 2, 2, 372, 397, 3, 2, 2, 2, 373,
	374, 7, 3, 2, 2, 374, 375, 7, 23, 2, 2, 375, 376, 5, 52, 27, 2, 376, 377,
	5, 52, 27, 2, 377, 378, 7, 5, 2, 2, 378, 397, 3, 2, 2, 2, 379, 380, 7,
	3, 2, 2, 380, 381, 7, 24, 2, 2, 381, 382, 7, 3, 2, 2, 382, 383, 5, 38,
	20, 2, 383, 384, 7, 5, 2, 2, 384, 385, 5, 52, 27, 2, 385, 386, 7, 5, 2,
	2, 386, 397, 3, 2, 2, 2, 387, 388, 7, 3, 2, 2, 388, 389, 7, 25, 2, 2, 389,
	390, 7, 3, 2, 2, 390, 391, 5, 38, 20, 2, 391, 392, 7, 5, 2, 2, 392, 393,
	5, 52, 27, 2, 393, 394, 7, 5, 2, 2, 394, 397, 3, 2, 2, 2, 395, 397, 5,
	54, 28, 2, 396, 349, 3, 2, 2, 2, 396, 350, 3, 2, 2, 2, 396, 359, 3, 2,
	2, 2, 396, 368, 3, 2, 2, 2, 396, 373, 3, 2, 2, 2, 396, 379, 3, 2, 2, 2,
	396, 387, 3, 2, 2, 2, 396, 395, 3, 2, 2, 2, 397, 53, 3, 2, 2, 2, 398, 399,
	7, 3, 2, 2, 399, 400, 5, 92, 47, 2, 400, 401, 5, 76, 39, 2, 401, 402, 5,
	76, 39, 2, 402, 403, 7, 5, 2, 2, 403, 55, 3, 2, 2, 2, 404, 405, 7, 3, 2,
	2, 405, 409, 5, 36, 19, 2, 406, 408, 5, 58, 30, 2, 407, 406, 3, 2, 2, 2,
	408, 411, 3, 2, 2, 2, 409, 407, 3, 2, 2, 2, 409, 410, 3, 2, 2, 2, 410,
	412, 3, 2, 2, 2, 411, 409, 3, 2, 2, 2, 412, 413, 7, 5, 2, 2, 413, 57, 3,
	2, 2, 2, 414, 415, 9, 2, 2, 2, 415, 59, 3, 2, 2, 2, 416, 417, 7, 3, 2,
	2, 417, 418, 7, 26, 2, 2, 418, 419, 5, 48, 25, 2, 419, 420, 7, 17, 2, 2,
	420, 421, 7, 3, 2, 2, 421, 422, 5, 38, 20, 2, 422, 423, 7, 5, 2, 2, 423,
	424, 5, 62, 32, 2, 424, 425, 7, 5, 2, 2, 425, 61, 3, 2, 2, 2, 426, 427,
	7, 27, 2, 2, 427, 441, 5, 96, 49, 2, 428, 432, 7, 28, 2, 2, 429, 430, 7,
	3, 2, 2, 430, 433, 7, 5, 2, 2, 431, 433, 5, 64, 33, 2, 432, 429, 3, 2,
	2, 2, 432, 431, 3, 2, 2, 2, 433, 441, 3, 2, 2, 2, 434, 438, 7, 19, 2, 2,
	435, 436, 7, 3, 2, 2, 436, 439, 7, 5, 2, 2, 437, 439, 5, 104, 53, 2, 438,
	435, 3, 2, 2, 2, 438, 437, 3, 2, 2, 2, 439, 441, 3, 2, 2, 2, 440, 426,
	3, 2, 2, 2, 440, 428, 3, 2, 2, 2, 440, 434, 3, 2, 2, 2, 441, 63, 3, 2,
	2, 2, 442, 461, 5, 66, 34, 2, 443, 444, 7, 3, 2, 2, 444, 448, 7, 20, 2,
	2, 445, 447, 5, 64, 33, 2, 446, 445, 3, 2, 2, 2, 447, 450, 3, 2, 2, 2,
	448, 446, 3, 2, 2, 2, 448, 449, 3, 2, 2, 2, 449, 451, 3, 2, 2, 2, 450,
	448, 3, 2, 2, 2, 451, 461, 7, 5, 2, 2, 452, 453, 7, 3, 2, 2, 453, 454,
	7, 25, 2, 2, 454, 455, 7, 3, 2, 2, 455, 456, 5, 38, 20, 2, 456, 457, 7,
	5, 2, 2, 457, 458, 5, 64, 33, 2, 458, 459, 7, 5, 2, 2, 459, 461, 3, 2,
	2, 2, 460, 442, 3, 2, 2, 2, 460, 443, 3, 2, 2, 2, 460, 452, 3, 2, 2, 2,
	461, 65, 3, 2, 2, 2, 462, 472, 5, 68, 35, 2, 463, 464, 7, 3, 2, 2, 464,
	466, 7, 29, 2, 2, 465, 467, 7, 111, 2, 2, 466, 465, 3, 2, 2, 2, 466, 467,
	3, 2, 2, 2, 467, 468, 3, 2, 2, 2, 468, 469, 5, 68, 35, 2, 469, 470, 7,
	5, 2, 2, 470, 472, 3, 2, 2, 2, 471, 462, 3, 2, 2, 2, 471, 463, 3, 2, 2,
	2, 472, 67, 3, 2, 2, 2, 473, 474, 7, 3, 2, 2, 474, 475, 7, 30, 2, 2, 475,
	476, 5, 70, 36, 2, 476, 477, 5, 52, 27, 2, 477, 478, 7, 5, 2, 2, 478, 486,
	3, 2, 2, 2, 479, 480, 7, 3, 2, 2, 480, 481, 7, 31, 2, 2, 481, 482, 5, 72,
	37, 2, 482, 483, 5, 52, 27, 2, 483, 484, 7, 5, 2, 2, 484, 486, 3, 2, 2,
	2, 485, 473, 3, 2, 2, 2, 485, 479, 3, 2, 2, 2, 486, 69, 3, 2, 2, 2, 487,
	488, 9, 3, 2, 2, 488, 71, 3, 2, 2, 2, 489, 490, 7, 34, 2, 2, 490, 73, 3,
	2, 2, 2, 491, 492, 7, 3, 2, 2, 492, 493, 7, 35, 2, 2, 493, 494, 5, 38,
	20, 2, 494, 495, 5, 52, 27, 2, 495, 496, 7, 5, 2, 2, 496, 75, 3, 2, 2,
	2, 497, 511, 7, 113, 2, 2, 498, 499, 7, 3, 2, 2, 499, 500, 5, 90, 46, 2,
	500, 501, 5, 76, 39, 2, 501, 502, 5, 78, 40, 2, 502, 503, 7, 5, 2, 2, 503,
	511, 3, 2, 2, 2, 504, 505, 7, 3, 2, 2, 505, 506, 7, 9, 2, 2, 506, 507,
	5, 76, 39, 2, 507, 508, 7, 5, 2, 2, 508, 511, 3, 2, 2, 2, 509, 511, 5,
	80, 41, 2, 510, 497, 3, 2, 2, 2, 510, 498, 3, 2, 2, 2, 510, 504, 3, 2,
	2, 2, 510, 509, 3, 2, 2, 2, 511, 77, 3, 2, 2, 2, 512, 513, 5, 76, 39, 2,
	513, 79, 3, 2, 2, 2, 514, 515, 7, 3, 2, 2, 515, 519, 5, 26, 14, 2, 516,
	518, 5, 58, 30, 2, 517, 516, 3, 2, 2, 2, 518, 521, 3, 2, 2, 2, 519, 517,
	3, 2, 2, 2, 519, 520, 3, 2, 2, 2, 520, 522, 3, 2, 2, 2, 521, 519, 3, 2,
	2, 2, 522, 523, 7, 5, 2, 2, 523, 526, 3, 2, 2, 2, 524, 526, 5, 26, 14,
	2, 525, 514, 3, 2, 2, 2, 525, 524, 3, 2, 2, 2, 526, 81, 3, 2, 2, 2, 527,
	528, 7, 3, 2, 2, 528, 532, 7, 20, 2, 2, 529, 531, 5, 84, 43, 2, 530, 529,
	3, 2, 2, 2, 531, 534, 3, 2, 2, 2, 532, 530, 3, 2, 2, 2, 532, 533, 3, 2,
	2, 2, 533, 535, 3, 2, 2, 2, 534, 532, 3, 2, 2, 2, 535, 538, 7, 5, 2, 2,
	536, 538, 5, 84, 43, 2, 537, 527, 3, 2, 2, 2, 537, 536, 3, 2, 2, 2, 538,
	83, 3, 2, 2, 2, 539, 540, 7, 3, 2, 2, 540, 541, 7, 25, 2, 2, 541, 542,
	7, 3, 2, 2, 542, 543, 5, 38, 20, 2, 543, 544, 7, 5, 2, 2, 544, 545, 5,
	82, 42, 2, 545, 546, 7, 5, 2, 2, 546, 555, 3, 2, 2, 2, 547, 548, 7, 3,
	2, 2, 548, 549, 7, 36, 2, 2, 549, 550, 5, 52, 27, 2, 550, 551, 5, 88, 45,
	2, 551, 552, 7, 5, 2, 2, 552, 555, 3, 2, 2, 2, 553, 555, 5, 86, 44, 2,
	554, 539, 3, 2, 2, 2, 554, 547, 3, 2, 2, 2, 554, 553, 3, 2, 2, 2, 555,
	85, 3, 2, 2, 2, 556, 557, 7, 3, 2, 2, 557, 558, 5, 94, 48, 2, 558, 559,
	5, 80, 41, 2, 559, 560, 5, 76, 39, 2, 560, 561, 7, 5, 2, 2, 561, 569, 3,
	2, 2, 2, 562, 563, 7, 3, 2, 2, 563, 564, 7, 22, 2, 2, 564, 565, 5, 56,
	29, 2, 565, 566, 7, 5, 2, 2, 566, 569, 3, 2, 2, 2, 567, 569, 5, 56, 29,
	2, 568, 556, 3, 2, 2, 2, 568, 562, 3, 2, 2, 2, 568, 567, 3, 2, 2, 2, 569,
	87, 3, 2, 2, 2, 570, 571, 7, 3, 2, 2, 571, 575, 7, 20, 2, 2, 572, 574,
	5, 86, 44, 2, 573, 572, 3, 2, 2, 2, 574, 577, 3, 2, 2, 2, 575, 573, 3,
	2, 2, 2, 575, 576, 3, 2, 2, 2, 576, 578, 3, 2, 2, 2, 577, 575, 3, 2, 2,
	2, 578, 581, 7, 5, 2, 2, 579, 581, 5, 86, 44, 2, 580, 570, 3, 2, 2, 2,
	580, 579, 3, 2, 2, 2, 581, 89, 3, 2, 2, 2, 582, 583, 9, 4, 2, 2, 583, 91,
	3, 2, 2, 2, 584, 585, 9, 5, 2, 2, 585, 93, 3, 2, 2, 2, 586, 587, 9, 6,
	2, 2, 587, 95, 3, 2, 2, 2, 588, 589, 7, 3, 2, 2, 589, 591, 7, 20, 2, 2,
	590, 592, 5, 98, 50, 2, 591, 590, 3, 2, 2, 2, 592, 593, 3, 2, 2, 2, 593,
	591, 3, 2, 2, 2, 593, 594, 3, 2, 2, 2, 594, 595, 3, 2, 2, 2, 595, 596,
	7, 5, 2, 2, 596, 601, 3, 2, 2, 2, 597, 598, 7, 3, 2, 2, 598, 601, 7, 5,
	2, 2, 599, 601, 5, 98, 50, 2, 600, 588, 3, 2, 2, 2, 600, 597, 3, 2, 2,
	2, 600, 599, 3, 2, 2, 2, 601, 97, 3, 2, 2, 2, 602, 603, 7, 3, 2, 2, 603,
	604, 5, 100, 51, 2, 604, 605, 7, 50, 2, 2, 605, 606, 5, 102, 52, 2, 606,
	607, 7, 5, 2, 2, 607, 615, 3, 2, 2, 2, 608, 609, 7, 3, 2, 2, 609, 610,
	7, 30, 2, 2, 610, 611, 5, 70, 36, 2, 611, 612, 5, 98, 50, 2, 612, 613,
	7, 5, 2, 2, 613, 615, 3, 2, 2, 2, 614, 602, 3, 2, 2, 2, 614, 608, 3, 2,
	2, 2, 615, 99, 3, 2, 2, 2, 616, 617, 9, 7, 2, 2, 617, 101, 3, 2, 2, 2,
	618, 621, 7, 113, 2, 2, 619, 621, 5, 76, 39, 2, 620, 618, 3, 2, 2, 2, 620,
	619, 3, 2, 2, 2, 621, 103, 3, 2, 2, 2, 622, 623, 7, 3, 2, 2, 623, 627,
	7, 20, 2, 2, 624, 626, 5, 104, 53, 2, 625, 624, 3, 2, 2, 2, 626, 629, 3,
	2, 2, 2, 627, 625, 3, 2, 2, 2, 627, 628, 3, 2, 2, 2, 628, 630, 3, 2, 2,
	2, 629, 627, 3, 2, 2, 2, 630, 653, 7, 5, 2, 2, 631, 653, 5, 106, 54, 2,
	632, 633, 7, 3, 2, 2, 633, 634, 7, 25, 2, 2, 634, 635, 7, 3, 2, 2, 635,
	636, 5, 38, 20, 2, 636, 637, 7, 5, 2, 2, 637, 638, 5, 104, 53, 2, 638,
	639, 7, 5, 2, 2, 639, 653, 3, 2, 2, 2, 640, 641, 7, 3, 2, 2, 641, 642,
	7, 36, 2, 2, 642, 643, 5, 64, 33, 2, 643, 644, 5, 106, 54, 2, 644, 645,
	7, 5, 2, 2, 645, 653, 3, 2, 2, 2, 646, 647, 7, 3, 2, 2, 647, 648, 5, 94,
	48, 2, 648, 649, 5, 80, 41, 2, 649, 650, 5, 110, 56, 2, 650, 651, 7, 5,
	2, 2, 651, 653, 3, 2, 2, 2, 652, 622, 3, 2, 2, 2, 652, 631, 3, 2, 2, 2,
	652, 632, 3, 2, 2, 2, 652, 640, 3, 2, 2, 2, 652, 646, 3, 2, 2, 2, 653,
	105, 3, 2, 2, 2, 654, 655, 7, 3, 2, 2, 655, 656, 7, 30, 2, 2, 656, 657,
	5, 70, 36, 2, 657, 658, 5, 104, 53, 2, 658, 659, 7, 5, 2, 2, 659, 673,
	3, 2, 2, 2, 660, 661, 7, 3, 2, 2, 661, 662, 7, 30, 2, 2, 662, 663, 5, 70,
	36, 2, 663, 664, 5, 108, 55, 2, 664, 665, 7, 5, 2, 2, 665, 673, 3, 2, 2,
	2, 666, 667, 7, 3, 2, 2, 667, 668, 5, 94, 48, 2, 668, 669, 5, 80, 41, 2,
	669, 670, 5, 76, 39, 2, 670, 671, 7, 5, 2, 2, 671, 673, 3, 2, 2, 2, 672,
	654, 3, 2, 2, 2, 672, 660, 3, 2, 2, 2, 672, 666, 3, 2, 2, 2, 673, 107,
	3, 2, 2, 2, 674, 675, 7, 3, 2, 2, 675, 676, 5, 94, 48, 2, 676, 677, 5,
	80, 41, 2, 677, 678, 5, 110, 56, 2, 678, 679, 7, 5, 2, 2, 679, 109, 3,
	2, 2, 2, 680, 687, 7, 3, 2, 2, 681, 682, 5, 90, 46, 2, 682, 683, 5, 110,
	56, 2, 683, 684, 5, 110, 56, 2, 684, 688, 3, 2, 2, 2, 685, 686, 7, 9, 2,
	2, 686, 688, 5, 110, 56, 2, 687, 681, 3, 2, 2, 2, 687, 685, 3, 2, 2, 2,
	688, 689, 3, 2, 2, 2, 689, 690, 7, 5, 2, 2, 690, 694, 3, 2, 2, 2, 691,
	694, 7, 50, 2, 2, 692, 694, 5, 76, 39, 2, 693, 680, 3, 2, 2, 2, 693, 691,
	3, 2, 2, 2, 693, 692, 3, 2, 2, 2, 694, 111, 3, 2, 2, 2, 695, 696, 7, 3,
	2, 2, 696, 697, 7, 4, 2, 2, 697, 698, 5, 114, 58, 2, 698, 700, 5, 116,
	59, 2, 699, 701, 5, 8, 5, 2, 700, 699, 3, 2, 2, 2, 700, 701, 3, 2, 2, 2,
	701, 703, 3, 2, 2, 2, 702, 704, 5, 118, 60, 2, 703, 702, 3, 2, 2, 2, 703,
	704, 3, 2, 2, 2, 704, 705, 3, 2, 2, 2, 705, 706, 5, 120, 61, 2, 706, 708,
	5, 128, 65, 2, 707, 709, 5, 130, 66, 2, 708, 707, 3, 2, 2, 2, 708, 709,
	3, 2, 2, 2, 709, 711, 3, 2, 2, 2, 710, 712, 5, 134, 68, 2, 711, 710, 3,
	2, 2, 2, 711, 712, 3, 2, 2, 2, 712, 113, 3, 2, 2, 2, 713, 714, 7, 3, 2,
	2, 714, 715, 7, 51, 2, 2, 715, 716, 7, 111, 2, 2, 716, 717, 7, 5, 2, 2,
	717, 115, 3, 2, 2, 2, 718, 719, 7, 3, 2, 2, 719, 720, 7, 52, 2, 2, 720,
	721, 7, 111, 2, 2, 721, 722, 7, 5, 2, 2, 722, 117, 3, 2, 2, 2, 723, 724,
	7, 3, 2, 2, 724, 725, 7, 53, 2, 2, 725, 726, 5, 12, 7, 2, 726, 727, 7,
	5, 2, 2, 727, 119, 3, 2, 2, 2, 728, 729, 7, 3, 2, 2, 729, 733, 7, 54, 2,
	2, 730, 732, 5, 122, 62, 2, 731, 730, 3, 2, 2, 2, 732, 735, 3, 2, 2, 2,
	733, 731, 3, 2, 2, 2, 733, 734, 3, 2, 2, 2, 734, 736, 3, 2, 2, 2, 735,
	733, 3, 2, 2, 2, 736, 737, 7, 5, 2, 2, 737, 121, 3, 2, 2, 2, 738, 752,
	5, 124, 63, 2, 739, 740, 7, 3, 2, 2, 740, 741, 7, 42, 2, 2, 741, 742, 5,
	80, 41, 2, 742, 743, 7, 113, 2, 2, 743, 744, 7, 5, 2, 2, 744, 752, 3, 2,
	2, 2, 745, 746, 7, 3, 2, 2, 746, 747, 7, 30, 2, 2, 747, 748, 7, 113, 2,
	2, 748, 749, 5, 124, 63, 2, 749, 750, 7, 5, 2, 2, 750, 752, 3, 2, 2, 2,
	751, 738, 3, 2, 2, 2, 751, 739, 3, 2, 2, 2, 751, 745, 3, 2, 2, 2, 752,
	123, 3, 2, 2, 2, 753, 760, 5, 126, 64, 2, 754, 755, 7, 3, 2, 2, 755, 756,
	7, 22, 2, 2, 756, 757, 5, 126, 64, 2, 757, 758, 7, 5, 2, 2, 758, 760, 3,
	2, 2, 2, 759, 753, 3, 2, 2, 2, 759, 754, 3, 2, 2, 2, 760, 125, 3, 2, 2,
	2, 761, 762, 7, 3, 2, 2, 762, 766, 5, 36, 19, 2, 763, 765, 7, 111, 2, 2,
	764, 763, 3, 2, 2, 2, 765, 768, 3, 2, 2, 2, 766, 764, 3, 2, 2, 2, 766,
	767, 3, 2, 2, 2, 767, 769, 3, 2, 2, 2, 768, 766, 3, 2, 2, 2, 769, 770,
	7, 5, 2, 2, 770, 127, 3, 2, 2, 2, 771, 772, 7, 3, 2, 2, 772, 773, 7, 55,
	2, 2, 773, 774, 5, 52, 27, 2, 774, 775, 7, 5, 2, 2, 775, 129, 3, 2, 2,
	2, 776, 777, 7, 3, 2, 2, 777, 778, 7, 15, 2, 2, 778, 779, 5, 132, 67, 2,
	779, 780, 7, 5, 2, 2, 780, 131, 3, 2, 2, 2, 781, 782, 7, 3, 2, 2, 782,
	786, 7, 20, 2, 2, 783, 785, 5, 132, 67, 2, 784, 783, 3, 2, 2, 2, 785, 788,
	3, 2, 2, 2, 786, 784, 3, 2, 2, 2, 786, 787, 3, 2, 2, 2, 787, 789, 3, 2,
	2, 2, 788, 786, 3, 2, 2, 2, 789, 808, 7, 5, 2, 2, 790, 791, 7, 3, 2, 2,
	791, 792, 7, 25, 2, 2, 792, 793, 7, 3, 2, 2, 793, 794, 5, 38, 20, 2, 794,
	795, 7, 5, 2, 2, 795, 796, 5, 132, 67, 2, 796, 797, 7, 5, 2, 2, 797, 808,
	3, 2, 2, 2, 798, 799, 7, 3, 2, 2, 799, 801, 7, 29, 2, 2, 800, 802, 7, 111,
	2, 2, 801, 800, 3, 2, 2, 2, 801, 802, 3, 2, 2, 2, 802, 803, 3, 2, 2, 2,
	803, 804, 5, 140, 71, 2, 804, 805, 7, 5, 2, 2, 805, 808, 3, 2, 2, 2, 806,
	808, 5, 140, 71, 2, 807, 781, 3, 2, 2, 2, 807, 790, 3, 2, 2, 2, 807, 798,
	3, 2, 2, 2, 807, 806, 3, 2, 2, 2, 808, 133, 3, 2, 2, 2, 809, 810, 7, 3,
	2, 2, 810, 811, 7, 56, 2, 2, 811, 812, 5, 136, 69, 2, 812, 813, 5, 138,
	70, 2, 813, 814, 7, 5, 2, 2, 814, 135, 3, 2, 2, 2, 815, 816, 9, 8, 2, 2,
	816, 137, 3, 2, 2, 2, 817, 818, 7, 3, 2, 2, 818, 819, 5, 90, 46, 2, 819,
	820, 5, 138, 70, 2, 820, 821, 5, 138, 70, 2, 821, 822, 7, 5, 2, 2, 822,
	856, 3, 2, 2, 2, 823, 824, 7, 3, 2, 2, 824, 825, 9, 9, 2, 2, 825, 827,
	5, 138, 70, 2, 826, 828, 5, 138, 70, 2, 827, 826, 3, 2, 2, 2, 828, 829,
	3, 2, 2, 2, 829, 827, 3, 2, 2, 2, 829, 830, 3, 2, 2, 2, 830, 831, 3, 2,
	2, 2, 831, 832, 7, 5, 2, 2, 832, 856, 3, 2, 2, 2, 833, 834, 7, 3, 2, 2,
	834, 835, 7, 9, 2, 2, 835, 836, 5, 138, 70, 2, 836, 837, 7, 5, 2, 2, 837,
	856, 3, 2, 2, 2, 838, 856, 7, 113, 2, 2, 839, 840, 7, 3, 2, 2, 840, 844,
	5, 26, 14, 2, 841, 843, 7, 111, 2, 2, 842, 841, 3, 2, 2, 2, 843, 846, 3,
	2, 2, 2, 844, 842, 3, 2, 2, 2, 844, 845, 3, 2, 2, 2, 845, 847, 3, 2, 2,
	2, 846, 844, 3, 2, 2, 2, 847, 848, 7, 5, 2, 2, 848, 856, 3, 2, 2, 2, 849,
	856, 5, 26, 14, 2, 850, 856, 7, 59, 2, 2, 851, 852, 7, 3, 2, 2, 852, 853,
	7, 60, 2, 2, 853, 854, 7, 111, 2, 2, 854, 856, 7, 5, 2, 2, 855, 817, 3,
	2, 2, 2, 855, 823, 3, 2, 2, 2, 855, 833, 3, 2, 2, 2, 855, 838, 3, 2, 2,
	2, 855, 839, 3, 2, 2, 2, 855, 849, 3, 2, 2, 2, 855, 850, 3, 2, 2, 2, 855,
	851, 3, 2, 2, 2, 856, 139, 3, 2, 2, 2, 857, 858, 7, 3, 2, 2, 858, 862,
	7, 20, 2, 2, 859, 861, 5, 140, 71, 2, 860, 859, 3, 2, 2, 2, 861, 864, 3,
	2, 2, 2, 862, 860, 3, 2, 2, 2, 862, 863, 3, 2, 2, 2, 863, 865, 3, 2, 2,
	2, 864, 862, 3, 2, 2, 2, 865, 934, 7, 5, 2, 2, 866, 867, 7, 3, 2, 2, 867,
	868, 7, 25, 2, 2, 868, 869, 7, 3, 2, 2, 869, 870, 5, 38, 20, 2, 870, 871,
	7, 5, 2, 2, 871, 872, 5, 140, 71, 2, 872, 873, 7, 5, 2, 2, 873, 934, 3,
	2, 2, 2, 874, 875, 7, 3, 2, 2, 875, 876, 7, 30, 2, 2, 876, 877, 7, 33,
	2, 2, 877, 878, 5, 52, 27, 2, 878, 879, 7, 5, 2, 2, 879, 934, 3, 2, 2,
	2, 880, 881, 7, 3, 2, 2, 881, 882, 7, 61, 2, 2, 882, 883, 5, 52, 27, 2,
	883, 884, 7, 5, 2, 2, 884, 934, 3, 2, 2, 2, 885, 886, 7, 3, 2, 2, 886,
	887, 7, 62, 2, 2, 887, 888, 5, 52, 27, 2, 888, 889, 7, 5, 2, 2, 889, 934,
	3, 2, 2, 2, 890, 891, 7, 3, 2, 2, 891, 892, 7, 63, 2, 2, 892, 893, 7, 113,
	2, 2, 893, 894, 5, 52, 27, 2, 894, 895, 7, 5, 2, 2, 895, 934, 3, 2, 2,
	2, 896, 897, 7, 3, 2, 2, 897, 898, 7, 64, 2, 2, 898, 899, 5, 52, 27, 2,
	899, 900, 7, 5, 2, 2, 900, 934, 3, 2, 2, 2, 901, 902, 7, 3, 2, 2, 902,
	903, 7, 65, 2, 2, 903, 904, 5, 52, 27, 2, 904, 905, 5, 52, 27, 2, 905,
	906, 7, 5, 2, 2, 906, 934, 3, 2, 2, 2, 907, 908, 7, 3, 2, 2, 908, 909,
	7, 66, 2, 2, 909, 910, 5, 52, 27, 2, 910, 911, 5, 52, 27, 2, 911, 912,
	7, 5, 2, 2, 912, 934, 3, 2, 2, 2, 913, 914, 7, 3, 2, 2, 914, 915, 7, 67,
	2, 2, 915, 916, 7, 113, 2, 2, 916, 917, 5, 52, 27, 2, 917, 918, 5, 52,
	27, 2, 918, 919, 7, 5, 2, 2, 919, 934, 3, 2, 2, 2, 920, 921, 7, 3, 2, 2,
	921, 922, 7, 68, 2, 2, 922, 923, 7, 113, 2, 2, 923, 924, 7, 113, 2, 2,
	924, 925, 5, 52, 27, 2, 925, 926, 7, 5, 2, 2, 926, 934, 3, 2, 2, 2, 927,
	928, 7, 3, 2, 2, 928, 929, 7, 69, 2, 2, 929, 930, 7, 113, 2, 2, 930, 931,
	5, 52, 27, 2, 931, 932, 7, 5, 2, 2, 932, 934, 3, 2, 2, 2, 933, 857, 3,
	2, 2, 2, 933, 866, 3, 2, 2, 2, 933, 874, 3, 2, 2, 2, 933, 880, 3, 2, 2,
	2, 933, 885, 3, 2, 2, 2, 933, 890, 3, 2, 2, 2, 933, 896, 3, 2, 2, 2, 933,
	901, 3, 2, 2, 2, 933, 907, 3, 2, 2, 2, 933, 913, 3, 2, 2, 2, 933, 920,
	3, 2, 2, 2, 933, 927, 3, 2, 2, 2, 934, 141, 3, 2, 2, 2, 78, 144, 150, 153,
	156, 159, 162, 165, 170, 185, 197, 203, 208, 211, 216, 226, 231, 243, 247,
	251, 273, 287, 293, 298, 301, 306, 319, 337, 339, 345, 347, 355, 364, 396,
	409, 432, 438, 440, 448, 460, 466, 471, 485, 510, 519, 525, 532, 537, 554,
	568, 575, 580, 593, 600, 614, 620, 627, 652, 672, 687, 693, 700, 703, 708,
	711, 733, 751, 759, 766, 786, 801, 807, 829, 844, 855, 862, 933,
}
var literalNames = []string{
	"", "'('", "'define'", "')'", "'domain'", "':requirements'", "':types'",
	"'-'", "'either'", "':functions'", "'number'", "':constants'", "':predicates'",
	"':constraints'", "':action'", "':parameters'", "':precondition'", "':effect'",
	"'and'", "'or'", "'not'", "'imply'", "'exists'", "'forall'", "':durative-action'",
	"':duration'", "':condition'", "'preference'", "'at'", "'over'", "'start'",
	"'end'", "'all'", "':derived'", "'when'", "'*'", "'+'", "'/'", "'>'", "'<'",
	"'='", "'>='", "'<='", "'assign'", "'scale-up'", "'scale-down'", "'increase'",
	"'decrease'", "'?duration'", "'problem'", "':domain'", "':objects'", "':init'",
	"':goal'", "':metric'", "'minimize'", "'maximize'", "'total-time'", "'is-violated'",
	"'always'", "'sometime'", "'within'", "'at-most-once'", "'sometime-after'",
	"'sometime-before'", "'always-within'", "'hold-during'", "'hold-after'",
	"", "'DOMAIN'", "'DOMAIN_NAME'", "'REQUIREMENTS'", "'TYPES'", "'EITHER_TYPE'",
	"'CONSTANTS'", "'FUNCTIONS'", "'PREDICATES'", "'ACTION'", "'DURATIVE_ACTION'",
	"'PROBLEM'", "'PROBLEM_NAME'", "'PROBLEM_DOMAIN'", "'OBJECTS'", "'INIT'",
	"'FUNC_HEAD'", "'PRECONDITION'", "'EFFECT'", "'AND_GD'", "'OR_GD'", "'NOT_GD'",
	"'IMPLY_GD'", "'EXISTS_GD'", "'FORALL_GD'", "'COMPARISON_GD'", "'AND_EFFECT'",
	"'FORALL_EFFECT'", "'WHEN_EFFECT'", "'ASSIGN_EFFECT'", "'NOT_EFFECT'",
	"'PRED_HEAD'", "'GOAL'", "'BINARY_OP'", "'UNARY_MINUS'", "'INIT_EQ'", "'INIT_AT'",
	"'NOT_PRED_INIT'", "'PRED_INST'", "'PROBLEM_CONSTRAINT'", "'PROBLEM_METRIC'",
}
var symbolicNames = []string{
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "REQUIRE_KEY",
	"DOMAIN", "DOMAIN_NAME", "REQUIREMENTS", "TYPES", "EITHER_TYPE", "CONSTANTS",
	"FUNCTIONS", "PREDICATES", "ACTION", "DURATIVE_ACTION", "PROBLEM", "PROBLEM_NAME",
	"PROBLEM_DOMAIN", "OBJECTS", "INIT", "FUNC_HEAD", "PRECONDITION", "EFFECT",
	"AND_GD", "OR_GD", "NOT_GD", "IMPLY_GD", "EXISTS_GD", "FORALL_GD", "COMPARISON_GD",
	"AND_EFFECT", "FORALL_EFFECT", "WHEN_EFFECT", "ASSIGN_EFFECT", "NOT_EFFECT",
	"PRED_HEAD", "GOAL", "BINARY_OP", "UNARY_MINUS", "INIT_EQ", "INIT_AT",
	"NOT_PRED_INIT", "PRED_INST", "PROBLEM_CONSTRAINT", "PROBLEM_METRIC", "NAME",
	"VARIABLE", "NUMBER", "LINE_COMMENT", "WHITESPACE",
}

var ruleNames = []string{
	"pddlDoc", "domain", "domainName", "requireDef", "typesDef", "typedNameList",
	"singleTypeNameList", "type_", "primType", "functionsDef", "functionList",
	"atomicFunctionSkeleton", "functionSymbol", "functionType", "constantsDef",
	"predicatesDef", "atomicFormulaSkeleton", "predicate", "typedVariableList",
	"singleTypeVarList", "constraints", "structureDef", "actionDef", "actionSymbol",
	"actionDefBody", "goalDesc", "fComp", "atomicTermFormula", "term", "durativeActionDef",
	"daDefBody", "daGD", "prefTimedGD", "timedGD", "timeSpecifier", "interval",
	"derivedDef", "fExp", "fExp2", "fHead", "effect", "cEffect", "pEffect",
	"condEffect", "binaryOp", "binaryComp", "assignOp", "durationConstraint",
	"simpleDurationConstraint", "durOp", "durValue", "daEffect", "timedEffect",
	"fAssignDA", "fExpDA", "problem", "problemDecl", "problemDomain", "objectDecl",
	"init_", "initEl", "nameLiteral", "atomicNameFormula", "goal", "probConstraints",
	"prefConGD", "metricSpec", "optimization", "metricFExp", "conGD",
}

type PddlParser struct {
	*antlr.BaseParser
}

// NewPddlParser produces a new parser instance for the optional input antlr.TokenStream.
//
// The *PddlParser instance produced may be reused by calling the SetInputStream method.
// The initial parser configuration is expensive to construct, and the object is not thread-safe;
// however, if used within a Golang sync.Pool, the construction cost amortizes well and the
// objects can be used in a thread-safe manner.
func NewPddlParser(input antlr.TokenStream) *PddlParser {
	this := new(PddlParser)
	deserializer := antlr.NewATNDeserializer(nil)
	deserializedATN := deserializer.DeserializeFromUInt16(parserATN)
	decisionToDFA := make([]*antlr.DFA, len(deserializedATN.DecisionToState))
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "Pddl.g4"

	return this
}

// PddlParser tokens.
const (
	PddlParserEOF                = antlr.TokenEOF
	PddlParserT__0               = 1
	PddlParserT__1               = 2
	PddlParserT__2               = 3
	PddlParserT__3               = 4
	PddlParserT__4               = 5
	PddlParserT__5               = 6
	PddlParserT__6               = 7
	PddlParserT__7               = 8
	PddlParserT__8               = 9
	PddlParserT__9               = 10
	PddlParserT__10              = 11
	PddlParserT__11              = 12
	PddlParserT__12              = 13
	PddlParserT__13              = 14
	PddlParserT__14              = 15
	PddlParserT__15              = 16
	PddlParserT__16              = 17
	PddlParserT__17              = 18
	PddlParserT__18              = 19
	PddlParserT__19              = 20
	PddlParserT__20              = 21
	PddlParserT__21              = 22
	PddlParserT__22              = 23
	PddlParserT__23              = 24
	PddlParserT__24              = 25
	PddlParserT__25              = 26
	PddlParserT__26              = 27
	PddlParserT__27              = 28
	PddlParserT__28              = 29
	PddlParserT__29              = 30
	PddlParserT__30              = 31
	PddlParserT__31              = 32
	PddlParserT__32              = 33
	PddlParserT__33              = 34
	PddlParserT__34              = 35
	PddlParserT__35              = 36
	PddlParserT__36              = 37
	PddlParserT__37              = 38
	PddlParserT__38              = 39
	PddlParserT__39              = 40
	PddlParserT__40              = 41
	PddlParserT__41              = 42
	PddlParserT__42              = 43
	PddlParserT__43              = 44
	PddlParserT__44              = 45
	PddlParserT__45              = 46
	PddlParserT__46              = 47
	PddlParserT__47              = 48
	PddlParserT__48              = 49
	PddlParserT__49              = 50
	PddlParserT__50              = 51
	PddlParserT__51              = 52
	PddlParserT__52              = 53
	PddlParserT__53              = 54
	PddlParserT__54              = 55
	PddlParserT__55              = 56
	PddlParserT__56              = 57
	PddlParserT__57              = 58
	PddlParserT__58              = 59
	PddlParserT__59              = 60
	PddlParserT__60              = 61
	PddlParserT__61              = 62
	PddlParserT__62              = 63
	PddlParserT__63              = 64
	PddlParserT__64              = 65
	PddlParserT__65              = 66
	PddlParserT__66              = 67
	PddlParserREQUIRE_KEY        = 68
	PddlParserDOMAIN             = 69
	PddlParserDOMAIN_NAME        = 70
	PddlParserREQUIREMENTS       = 71
	PddlParserTYPES              = 72
	PddlParserEITHER_TYPE        = 73
	PddlParserCONSTANTS          = 74
	PddlParserFUNCTIONS          = 75
	PddlParserPREDICATES         = 76
	PddlParserACTION             = 77
	PddlParserDURATIVE_ACTION    = 78
	PddlParserPROBLEM            = 79
	PddlParserPROBLEM_NAME       = 80
	PddlParserPROBLEM_DOMAIN     = 81
	PddlParserOBJECTS            = 82
	PddlParserINIT               = 83
	PddlParserFUNC_HEAD          = 84
	PddlParserPRECONDITION       = 85
	PddlParserEFFECT             = 86
	PddlParserAND_GD             = 87
	PddlParserOR_GD              = 88
	PddlParserNOT_GD             = 89
	PddlParserIMPLY_GD           = 90
	PddlParserEXISTS_GD          = 91
	PddlParserFORALL_GD          = 92
	PddlParserCOMPARISON_GD      = 93
	PddlParserAND_EFFECT         = 94
	PddlParserFORALL_EFFECT      = 95
	PddlParserWHEN_EFFECT        = 96
	PddlParserASSIGN_EFFECT      = 97
	PddlParserNOT_EFFECT         = 98
	PddlParserPRED_HEAD          = 99
	PddlParserGOAL               = 100
	PddlParserBINARY_OP          = 101
	PddlParserUNARY_MINUS        = 102
	PddlParserINIT_EQ            = 103
	PddlParserINIT_AT            = 104
	PddlParserNOT_PRED_INIT      = 105
	PddlParserPRED_INST          = 106
	PddlParserPROBLEM_CONSTRAINT = 107
	PddlParserPROBLEM_METRIC     = 108
	PddlParserNAME               = 109
	PddlParserVARIABLE           = 110
	PddlParserNUMBER             = 111
	PddlParserLINE_COMMENT       = 112
	PddlParserWHITESPACE         = 113
)

// PddlParser rules.
const (
	PddlParserRULE_pddlDoc                  = 0
	PddlParserRULE_domain                   = 1
	PddlParserRULE_domainName               = 2
	PddlParserRULE_requireDef               = 3
	PddlParserRULE_typesDef                 = 4
	PddlParserRULE_typedNameList            = 5
	PddlParserRULE_singleTypeNameList       = 6
	PddlParserRULE_type_                    = 7
	PddlParserRULE_primType                 = 8
	PddlParserRULE_functionsDef             = 9
	PddlParserRULE_functionList             = 10
	PddlParserRULE_atomicFunctionSkeleton   = 11
	PddlParserRULE_functionSymbol           = 12
	PddlParserRULE_functionType             = 13
	PddlParserRULE_constantsDef             = 14
	PddlParserRULE_predicatesDef            = 15
	PddlParserRULE_atomicFormulaSkeleton    = 16
	PddlParserRULE_predicate                = 17
	PddlParserRULE_typedVariableList        = 18
	PddlParserRULE_singleTypeVarList        = 19
	PddlParserRULE_constraints              = 20
	PddlParserRULE_structureDef             = 21
	PddlParserRULE_actionDef                = 22
	PddlParserRULE_actionSymbol             = 23
	PddlParserRULE_actionDefBody            = 24
	PddlParserRULE_goalDesc                 = 25
	PddlParserRULE_fComp                    = 26
	PddlParserRULE_atomicTermFormula        = 27
	PddlParserRULE_term                     = 28
	PddlParserRULE_durativeActionDef        = 29
	PddlParserRULE_daDefBody                = 30
	PddlParserRULE_daGD                     = 31
	PddlParserRULE_prefTimedGD              = 32
	PddlParserRULE_timedGD                  = 33
	PddlParserRULE_timeSpecifier            = 34
	PddlParserRULE_interval                 = 35
	PddlParserRULE_derivedDef               = 36
	PddlParserRULE_fExp                     = 37
	PddlParserRULE_fExp2                    = 38
	PddlParserRULE_fHead                    = 39
	PddlParserRULE_effect                   = 40
	PddlParserRULE_cEffect                  = 41
	PddlParserRULE_pEffect                  = 42
	PddlParserRULE_condEffect               = 43
	PddlParserRULE_binaryOp                 = 44
	PddlParserRULE_binaryComp               = 45
	PddlParserRULE_assignOp                 = 46
	PddlParserRULE_durationConstraint       = 47
	PddlParserRULE_simpleDurationConstraint = 48
	PddlParserRULE_durOp                    = 49
	PddlParserRULE_durValue                 = 50
	PddlParserRULE_daEffect                 = 51
	PddlParserRULE_timedEffect              = 52
	PddlParserRULE_fAssignDA                = 53
	PddlParserRULE_fExpDA                   = 54
	PddlParserRULE_problem                  = 55
	PddlParserRULE_problemDecl              = 56
	PddlParserRULE_problemDomain            = 57
	PddlParserRULE_objectDecl               = 58
	PddlParserRULE_init_                    = 59
	PddlParserRULE_initEl                   = 60
	PddlParserRULE_nameLiteral              = 61
	PddlParserRULE_atomicNameFormula        = 62
	PddlParserRULE_goal                     = 63
	PddlParserRULE_probConstraints          = 64
	PddlParserRULE_prefConGD                = 65
	PddlParserRULE_metricSpec               = 66
	PddlParserRULE_optimization             = 67
	PddlParserRULE_metricFExp               = 68
	PddlParserRULE_conGD                    = 69
)

// IPddlDocContext is an interface to support dynamic dispatch.
type IPddlDocContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPddlDocContext differentiates from other interfaces.
	IsPddlDocContext()
}

type PddlDocContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPddlDocContext() *PddlDocContext {
	var p = new(PddlDocContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PddlParserRULE_pddlDoc
	return p
}

func (*PddlDocContext) IsPddlDocContext() {}

func NewPddlDocContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PddlDocContext {
	var p = new(PddlDocContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PddlParserRULE_pddlDoc

	return p
}

func (s *PddlDocContext) GetParser() antlr.Parser { return s.parser }

func (s *PddlDocContext) Domain() IDomainContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDomainContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDomainContext)
}

func (s *PddlDocContext) Problem() IProblemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProblemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProblemContext)
}

func (s *PddlDocContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PddlDocContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PddlDocContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.EnterPddlDoc(s)
	}
}

func (s *PddlDocContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.ExitPddlDoc(s)
	}
}

func (p *PddlParser) PddlDoc() (localctx IPddlDocContext) {
	this := p
	_ = this

	localctx = NewPddlDocContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, PddlParserRULE_pddlDoc)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(142)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 0, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(140)
			p.Domain()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(141)
			p.Problem()
		}

	}

	return localctx
}

// IDomainContext is an interface to support dynamic dispatch.
type IDomainContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDomainContext differentiates from other interfaces.
	IsDomainContext()
}

type DomainContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDomainContext() *DomainContext {
	var p = new(DomainContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PddlParserRULE_domain
	return p
}

func (*DomainContext) IsDomainContext() {}

func NewDomainContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DomainContext {
	var p = new(DomainContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PddlParserRULE_domain

	return p
}

func (s *DomainContext) GetParser() antlr.Parser { return s.parser }

func (s *DomainContext) DomainName() IDomainNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDomainNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDomainNameContext)
}

func (s *DomainContext) RequireDef() IRequireDefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRequireDefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRequireDefContext)
}

func (s *DomainContext) TypesDef() ITypesDefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypesDefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypesDefContext)
}

func (s *DomainContext) ConstantsDef() IConstantsDefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstantsDefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstantsDefContext)
}

func (s *DomainContext) PredicatesDef() IPredicatesDefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPredicatesDefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPredicatesDefContext)
}

func (s *DomainContext) FunctionsDef() IFunctionsDefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionsDefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionsDefContext)
}

func (s *DomainContext) Constraints() IConstraintsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstraintsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstraintsContext)
}

func (s *DomainContext) AllStructureDef() []IStructureDefContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStructureDefContext)(nil)).Elem())
	var tst = make([]IStructureDefContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStructureDefContext)
		}
	}

	return tst
}

func (s *DomainContext) StructureDef(i int) IStructureDefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStructureDefContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStructureDefContext)
}

func (s *DomainContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DomainContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DomainContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.EnterDomain(s)
	}
}

func (s *DomainContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.ExitDomain(s)
	}
}

func (p *PddlParser) Domain() (localctx IDomainContext) {
	this := p
	_ = this

	localctx = NewDomainContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, PddlParserRULE_domain)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(144)
		p.Match(PddlParserT__0)
	}
	{
		p.SetState(145)
		p.Match(PddlParserT__1)
	}
	{
		p.SetState(146)
		p.DomainName()
	}
	p.SetState(148)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(147)
			p.RequireDef()
		}

	}
	p.SetState(151)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 2, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(150)
			p.TypesDef()
		}

	}
	p.SetState(154)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 3, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(153)
			p.ConstantsDef()
		}

	}
	p.SetState(157)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 4, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(156)
			p.PredicatesDef()
		}

	}
	p.SetState(160)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 5, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(159)
			p.FunctionsDef()
		}

	}
	p.SetState(163)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 6, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(162)
			p.Constraints()
		}

	}
	p.SetState(168)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PddlParserT__0 {
		{
			p.SetState(165)
			p.StructureDef()
		}

		p.SetState(170)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(171)
		p.Match(PddlParserT__2)
	}

	return localctx
}

// IDomainNameContext is an interface to support dynamic dispatch.
type IDomainNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDomainNameContext differentiates from other interfaces.
	IsDomainNameContext()
}

type DomainNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDomainNameContext() *DomainNameContext {
	var p = new(DomainNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PddlParserRULE_domainName
	return p
}

func (*DomainNameContext) IsDomainNameContext() {}

func NewDomainNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DomainNameContext {
	var p = new(DomainNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PddlParserRULE_domainName

	return p
}

func (s *DomainNameContext) GetParser() antlr.Parser { return s.parser }

func (s *DomainNameContext) NAME() antlr.TerminalNode {
	return s.GetToken(PddlParserNAME, 0)
}

func (s *DomainNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DomainNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DomainNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.EnterDomainName(s)
	}
}

func (s *DomainNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.ExitDomainName(s)
	}
}

func (p *PddlParser) DomainName() (localctx IDomainNameContext) {
	this := p
	_ = this

	localctx = NewDomainNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, PddlParserRULE_domainName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(173)
		p.Match(PddlParserT__0)
	}
	{
		p.SetState(174)
		p.Match(PddlParserT__3)
	}
	{
		p.SetState(175)
		p.Match(PddlParserNAME)
	}
	{
		p.SetState(176)
		p.Match(PddlParserT__2)
	}

	return localctx
}

// IRequireDefContext is an interface to support dynamic dispatch.
type IRequireDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRequireDefContext differentiates from other interfaces.
	IsRequireDefContext()
}

type RequireDefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRequireDefContext() *RequireDefContext {
	var p = new(RequireDefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PddlParserRULE_requireDef
	return p
}

func (*RequireDefContext) IsRequireDefContext() {}

func NewRequireDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RequireDefContext {
	var p = new(RequireDefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PddlParserRULE_requireDef

	return p
}

func (s *RequireDefContext) GetParser() antlr.Parser { return s.parser }

func (s *RequireDefContext) AllREQUIRE_KEY() []antlr.TerminalNode {
	return s.GetTokens(PddlParserREQUIRE_KEY)
}

func (s *RequireDefContext) REQUIRE_KEY(i int) antlr.TerminalNode {
	return s.GetToken(PddlParserREQUIRE_KEY, i)
}

func (s *RequireDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RequireDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RequireDefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.EnterRequireDef(s)
	}
}

func (s *RequireDefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.ExitRequireDef(s)
	}
}

func (p *PddlParser) RequireDef() (localctx IRequireDefContext) {
	this := p
	_ = this

	localctx = NewRequireDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, PddlParserRULE_requireDef)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(178)
		p.Match(PddlParserT__0)
	}
	{
		p.SetState(179)
		p.Match(PddlParserT__4)
	}
	p.SetState(181)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == PddlParserREQUIRE_KEY {
		{
			p.SetState(180)
			p.Match(PddlParserREQUIRE_KEY)
		}

		p.SetState(183)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(185)
		p.Match(PddlParserT__2)
	}

	return localctx
}

// ITypesDefContext is an interface to support dynamic dispatch.
type ITypesDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypesDefContext differentiates from other interfaces.
	IsTypesDefContext()
}

type TypesDefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypesDefContext() *TypesDefContext {
	var p = new(TypesDefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PddlParserRULE_typesDef
	return p
}

func (*TypesDefContext) IsTypesDefContext() {}

func NewTypesDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypesDefContext {
	var p = new(TypesDefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PddlParserRULE_typesDef

	return p
}

func (s *TypesDefContext) GetParser() antlr.Parser { return s.parser }

func (s *TypesDefContext) TypedNameList() ITypedNameListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypedNameListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypedNameListContext)
}

func (s *TypesDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypesDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypesDefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.EnterTypesDef(s)
	}
}

func (s *TypesDefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.ExitTypesDef(s)
	}
}

func (p *PddlParser) TypesDef() (localctx ITypesDefContext) {
	this := p
	_ = this

	localctx = NewTypesDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, PddlParserRULE_typesDef)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(187)
		p.Match(PddlParserT__0)
	}
	{
		p.SetState(188)
		p.Match(PddlParserT__5)
	}
	{
		p.SetState(189)
		p.TypedNameList()
	}
	{
		p.SetState(190)
		p.Match(PddlParserT__2)
	}

	return localctx
}

// ITypedNameListContext is an interface to support dynamic dispatch.
type ITypedNameListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypedNameListContext differentiates from other interfaces.
	IsTypedNameListContext()
}

type TypedNameListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypedNameListContext() *TypedNameListContext {
	var p = new(TypedNameListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PddlParserRULE_typedNameList
	return p
}

func (*TypedNameListContext) IsTypedNameListContext() {}

func NewTypedNameListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypedNameListContext {
	var p = new(TypedNameListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PddlParserRULE_typedNameList

	return p
}

func (s *TypedNameListContext) GetParser() antlr.Parser { return s.parser }

func (s *TypedNameListContext) AllNAME() []antlr.TerminalNode {
	return s.GetTokens(PddlParserNAME)
}

func (s *TypedNameListContext) NAME(i int) antlr.TerminalNode {
	return s.GetToken(PddlParserNAME, i)
}

func (s *TypedNameListContext) AllSingleTypeNameList() []ISingleTypeNameListContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISingleTypeNameListContext)(nil)).Elem())
	var tst = make([]ISingleTypeNameListContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISingleTypeNameListContext)
		}
	}

	return tst
}

func (s *TypedNameListContext) SingleTypeNameList(i int) ISingleTypeNameListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleTypeNameListContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISingleTypeNameListContext)
}

func (s *TypedNameListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypedNameListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypedNameListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.EnterTypedNameList(s)
	}
}

func (s *TypedNameListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.ExitTypedNameList(s)
	}
}

func (p *PddlParser) TypedNameList() (localctx ITypedNameListContext) {
	this := p
	_ = this

	localctx = NewTypedNameListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, PddlParserRULE_typedNameList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(209)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 12, p.GetParserRuleContext()) {
	case 1:
		p.SetState(195)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PddlParserNAME {
			{
				p.SetState(192)
				p.Match(PddlParserNAME)
			}

			p.SetState(197)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		p.SetState(199)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(198)
					p.SingleTypeNameList()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(201)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 10, p.GetParserRuleContext())
		}
		p.SetState(206)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PddlParserNAME {
			{
				p.SetState(203)
				p.Match(PddlParserNAME)
			}

			p.SetState(208)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// ISingleTypeNameListContext is an interface to support dynamic dispatch.
type ISingleTypeNameListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetT returns the t rule contexts.
	GetT() IType_Context

	// SetT sets the t rule contexts.
	SetT(IType_Context)

	// IsSingleTypeNameListContext differentiates from other interfaces.
	IsSingleTypeNameListContext()
}

type SingleTypeNameListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	t      IType_Context
}

func NewEmptySingleTypeNameListContext() *SingleTypeNameListContext {
	var p = new(SingleTypeNameListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PddlParserRULE_singleTypeNameList
	return p
}

func (*SingleTypeNameListContext) IsSingleTypeNameListContext() {}

func NewSingleTypeNameListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleTypeNameListContext {
	var p = new(SingleTypeNameListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PddlParserRULE_singleTypeNameList

	return p
}

func (s *SingleTypeNameListContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleTypeNameListContext) GetT() IType_Context { return s.t }

func (s *SingleTypeNameListContext) SetT(v IType_Context) { s.t = v }

func (s *SingleTypeNameListContext) Type_() IType_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *SingleTypeNameListContext) AllNAME() []antlr.TerminalNode {
	return s.GetTokens(PddlParserNAME)
}

func (s *SingleTypeNameListContext) NAME(i int) antlr.TerminalNode {
	return s.GetToken(PddlParserNAME, i)
}

func (s *SingleTypeNameListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleTypeNameListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleTypeNameListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.EnterSingleTypeNameList(s)
	}
}

func (s *SingleTypeNameListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.ExitSingleTypeNameList(s)
	}
}

func (p *PddlParser) SingleTypeNameList() (localctx ISingleTypeNameListContext) {
	this := p
	_ = this

	localctx = NewSingleTypeNameListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, PddlParserRULE_singleTypeNameList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(212)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == PddlParserNAME {
		{
			p.SetState(211)
			p.Match(PddlParserNAME)
		}

		p.SetState(214)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(216)
		p.Match(PddlParserT__6)
	}
	{
		p.SetState(217)

		var _x = p.Type_()

		localctx.(*SingleTypeNameListContext).t = _x
	}

	return localctx
}

// IType_Context is an interface to support dynamic dispatch.
type IType_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsType_Context differentiates from other interfaces.
	IsType_Context()
}

type Type_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_Context() *Type_Context {
	var p = new(Type_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PddlParserRULE_type_
	return p
}

func (*Type_Context) IsType_Context() {}

func NewType_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_Context {
	var p = new(Type_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PddlParserRULE_type_

	return p
}

func (s *Type_Context) GetParser() antlr.Parser { return s.parser }

func (s *Type_Context) AllPrimType() []IPrimTypeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPrimTypeContext)(nil)).Elem())
	var tst = make([]IPrimTypeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPrimTypeContext)
		}
	}

	return tst
}

func (s *Type_Context) PrimType(i int) IPrimTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimTypeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPrimTypeContext)
}

func (s *Type_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.EnterType_(s)
	}
}

func (s *Type_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.ExitType_(s)
	}
}

func (p *PddlParser) Type_() (localctx IType_Context) {
	this := p
	_ = this

	localctx = NewType_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, PddlParserRULE_type_)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(229)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PddlParserT__0:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(219)
			p.Match(PddlParserT__0)
		}
		{
			p.SetState(220)
			p.Match(PddlParserT__7)
		}
		p.SetState(222)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == PddlParserNAME {
			{
				p.SetState(221)
				p.PrimType()
			}

			p.SetState(224)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(226)
			p.Match(PddlParserT__2)
		}

	case PddlParserNAME:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(228)
			p.PrimType()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPrimTypeContext is an interface to support dynamic dispatch.
type IPrimTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimTypeContext differentiates from other interfaces.
	IsPrimTypeContext()
}

type PrimTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimTypeContext() *PrimTypeContext {
	var p = new(PrimTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PddlParserRULE_primType
	return p
}

func (*PrimTypeContext) IsPrimTypeContext() {}

func NewPrimTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimTypeContext {
	var p = new(PrimTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PddlParserRULE_primType

	return p
}

func (s *PrimTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimTypeContext) NAME() antlr.TerminalNode {
	return s.GetToken(PddlParserNAME, 0)
}

func (s *PrimTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.EnterPrimType(s)
	}
}

func (s *PrimTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.ExitPrimType(s)
	}
}

func (p *PddlParser) PrimType() (localctx IPrimTypeContext) {
	this := p
	_ = this

	localctx = NewPrimTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, PddlParserRULE_primType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(231)
		p.Match(PddlParserNAME)
	}

	return localctx
}

// IFunctionsDefContext is an interface to support dynamic dispatch.
type IFunctionsDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionsDefContext differentiates from other interfaces.
	IsFunctionsDefContext()
}

type FunctionsDefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionsDefContext() *FunctionsDefContext {
	var p = new(FunctionsDefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PddlParserRULE_functionsDef
	return p
}

func (*FunctionsDefContext) IsFunctionsDefContext() {}

func NewFunctionsDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionsDefContext {
	var p = new(FunctionsDefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PddlParserRULE_functionsDef

	return p
}

func (s *FunctionsDefContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionsDefContext) FunctionList() IFunctionListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionListContext)
}

func (s *FunctionsDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionsDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionsDefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.EnterFunctionsDef(s)
	}
}

func (s *FunctionsDefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.ExitFunctionsDef(s)
	}
}

func (p *PddlParser) FunctionsDef() (localctx IFunctionsDefContext) {
	this := p
	_ = this

	localctx = NewFunctionsDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, PddlParserRULE_functionsDef)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(233)
		p.Match(PddlParserT__0)
	}
	{
		p.SetState(234)
		p.Match(PddlParserT__8)
	}
	{
		p.SetState(235)
		p.FunctionList()
	}
	{
		p.SetState(236)
		p.Match(PddlParserT__2)
	}

	return localctx
}

// IFunctionListContext is an interface to support dynamic dispatch.
type IFunctionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionListContext differentiates from other interfaces.
	IsFunctionListContext()
}

type FunctionListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionListContext() *FunctionListContext {
	var p = new(FunctionListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PddlParserRULE_functionList
	return p
}

func (*FunctionListContext) IsFunctionListContext() {}

func NewFunctionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionListContext {
	var p = new(FunctionListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PddlParserRULE_functionList

	return p
}

func (s *FunctionListContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionListContext) AllAtomicFunctionSkeleton() []IAtomicFunctionSkeletonContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAtomicFunctionSkeletonContext)(nil)).Elem())
	var tst = make([]IAtomicFunctionSkeletonContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAtomicFunctionSkeletonContext)
		}
	}

	return tst
}

func (s *FunctionListContext) AtomicFunctionSkeleton(i int) IAtomicFunctionSkeletonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomicFunctionSkeletonContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAtomicFunctionSkeletonContext)
}

func (s *FunctionListContext) AllFunctionType() []IFunctionTypeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFunctionTypeContext)(nil)).Elem())
	var tst = make([]IFunctionTypeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFunctionTypeContext)
		}
	}

	return tst
}

func (s *FunctionListContext) FunctionType(i int) IFunctionTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionTypeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFunctionTypeContext)
}

func (s *FunctionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.EnterFunctionList(s)
	}
}

func (s *FunctionListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.ExitFunctionList(s)
	}
}

func (p *PddlParser) FunctionList() (localctx IFunctionListContext) {
	this := p
	_ = this

	localctx = NewFunctionListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, PddlParserRULE_functionList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(249)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PddlParserT__0 {
		p.SetState(239)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(238)
					p.AtomicFunctionSkeleton()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(241)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 16, p.GetParserRuleContext())
		}
		p.SetState(245)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PddlParserT__6 {
			{
				p.SetState(243)
				p.Match(PddlParserT__6)
			}
			{
				p.SetState(244)
				p.FunctionType()
			}

		}

		p.SetState(251)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IAtomicFunctionSkeletonContext is an interface to support dynamic dispatch.
type IAtomicFunctionSkeletonContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtomicFunctionSkeletonContext differentiates from other interfaces.
	IsAtomicFunctionSkeletonContext()
}

type AtomicFunctionSkeletonContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtomicFunctionSkeletonContext() *AtomicFunctionSkeletonContext {
	var p = new(AtomicFunctionSkeletonContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PddlParserRULE_atomicFunctionSkeleton
	return p
}

func (*AtomicFunctionSkeletonContext) IsAtomicFunctionSkeletonContext() {}

func NewAtomicFunctionSkeletonContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtomicFunctionSkeletonContext {
	var p = new(AtomicFunctionSkeletonContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PddlParserRULE_atomicFunctionSkeleton

	return p
}

func (s *AtomicFunctionSkeletonContext) GetParser() antlr.Parser { return s.parser }

func (s *AtomicFunctionSkeletonContext) FunctionSymbol() IFunctionSymbolContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionSymbolContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionSymbolContext)
}

func (s *AtomicFunctionSkeletonContext) TypedVariableList() ITypedVariableListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypedVariableListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypedVariableListContext)
}

func (s *AtomicFunctionSkeletonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtomicFunctionSkeletonContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AtomicFunctionSkeletonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.EnterAtomicFunctionSkeleton(s)
	}
}

func (s *AtomicFunctionSkeletonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.ExitAtomicFunctionSkeleton(s)
	}
}

func (p *PddlParser) AtomicFunctionSkeleton() (localctx IAtomicFunctionSkeletonContext) {
	this := p
	_ = this

	localctx = NewAtomicFunctionSkeletonContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, PddlParserRULE_atomicFunctionSkeleton)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(252)
		p.Match(PddlParserT__0)
	}
	{
		p.SetState(253)
		p.FunctionSymbol()
	}
	{
		p.SetState(254)
		p.TypedVariableList()
	}
	{
		p.SetState(255)
		p.Match(PddlParserT__2)
	}

	return localctx
}

// IFunctionSymbolContext is an interface to support dynamic dispatch.
type IFunctionSymbolContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionSymbolContext differentiates from other interfaces.
	IsFunctionSymbolContext()
}

type FunctionSymbolContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionSymbolContext() *FunctionSymbolContext {
	var p = new(FunctionSymbolContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PddlParserRULE_functionSymbol
	return p
}

func (*FunctionSymbolContext) IsFunctionSymbolContext() {}

func NewFunctionSymbolContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionSymbolContext {
	var p = new(FunctionSymbolContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PddlParserRULE_functionSymbol

	return p
}

func (s *FunctionSymbolContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionSymbolContext) NAME() antlr.TerminalNode {
	return s.GetToken(PddlParserNAME, 0)
}

func (s *FunctionSymbolContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionSymbolContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionSymbolContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.EnterFunctionSymbol(s)
	}
}

func (s *FunctionSymbolContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.ExitFunctionSymbol(s)
	}
}

func (p *PddlParser) FunctionSymbol() (localctx IFunctionSymbolContext) {
	this := p
	_ = this

	localctx = NewFunctionSymbolContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, PddlParserRULE_functionSymbol)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(257)
		p.Match(PddlParserNAME)
	}

	return localctx
}

// IFunctionTypeContext is an interface to support dynamic dispatch.
type IFunctionTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionTypeContext differentiates from other interfaces.
	IsFunctionTypeContext()
}

type FunctionTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionTypeContext() *FunctionTypeContext {
	var p = new(FunctionTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PddlParserRULE_functionType
	return p
}

func (*FunctionTypeContext) IsFunctionTypeContext() {}

func NewFunctionTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionTypeContext {
	var p = new(FunctionTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PddlParserRULE_functionType

	return p
}

func (s *FunctionTypeContext) GetParser() antlr.Parser { return s.parser }
func (s *FunctionTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.EnterFunctionType(s)
	}
}

func (s *FunctionTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.ExitFunctionType(s)
	}
}

func (p *PddlParser) FunctionType() (localctx IFunctionTypeContext) {
	this := p
	_ = this

	localctx = NewFunctionTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, PddlParserRULE_functionType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(259)
		p.Match(PddlParserT__9)
	}

	return localctx
}

// IConstantsDefContext is an interface to support dynamic dispatch.
type IConstantsDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstantsDefContext differentiates from other interfaces.
	IsConstantsDefContext()
}

type ConstantsDefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstantsDefContext() *ConstantsDefContext {
	var p = new(ConstantsDefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PddlParserRULE_constantsDef
	return p
}

func (*ConstantsDefContext) IsConstantsDefContext() {}

func NewConstantsDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantsDefContext {
	var p = new(ConstantsDefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PddlParserRULE_constantsDef

	return p
}

func (s *ConstantsDefContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantsDefContext) TypedNameList() ITypedNameListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypedNameListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypedNameListContext)
}

func (s *ConstantsDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantsDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstantsDefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.EnterConstantsDef(s)
	}
}

func (s *ConstantsDefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.ExitConstantsDef(s)
	}
}

func (p *PddlParser) ConstantsDef() (localctx IConstantsDefContext) {
	this := p
	_ = this

	localctx = NewConstantsDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, PddlParserRULE_constantsDef)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(261)
		p.Match(PddlParserT__0)
	}
	{
		p.SetState(262)
		p.Match(PddlParserT__10)
	}
	{
		p.SetState(263)
		p.TypedNameList()
	}
	{
		p.SetState(264)
		p.Match(PddlParserT__2)
	}

	return localctx
}

// IPredicatesDefContext is an interface to support dynamic dispatch.
type IPredicatesDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPredicatesDefContext differentiates from other interfaces.
	IsPredicatesDefContext()
}

type PredicatesDefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPredicatesDefContext() *PredicatesDefContext {
	var p = new(PredicatesDefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PddlParserRULE_predicatesDef
	return p
}

func (*PredicatesDefContext) IsPredicatesDefContext() {}

func NewPredicatesDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PredicatesDefContext {
	var p = new(PredicatesDefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PddlParserRULE_predicatesDef

	return p
}

func (s *PredicatesDefContext) GetParser() antlr.Parser { return s.parser }

func (s *PredicatesDefContext) AllAtomicFormulaSkeleton() []IAtomicFormulaSkeletonContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAtomicFormulaSkeletonContext)(nil)).Elem())
	var tst = make([]IAtomicFormulaSkeletonContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAtomicFormulaSkeletonContext)
		}
	}

	return tst
}

func (s *PredicatesDefContext) AtomicFormulaSkeleton(i int) IAtomicFormulaSkeletonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomicFormulaSkeletonContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAtomicFormulaSkeletonContext)
}

func (s *PredicatesDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicatesDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PredicatesDefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.EnterPredicatesDef(s)
	}
}

func (s *PredicatesDefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.ExitPredicatesDef(s)
	}
}

func (p *PddlParser) PredicatesDef() (localctx IPredicatesDefContext) {
	this := p
	_ = this

	localctx = NewPredicatesDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, PddlParserRULE_predicatesDef)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(266)
		p.Match(PddlParserT__0)
	}
	{
		p.SetState(267)
		p.Match(PddlParserT__11)
	}
	p.SetState(269)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == PddlParserT__0 {
		{
			p.SetState(268)
			p.AtomicFormulaSkeleton()
		}

		p.SetState(271)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(273)
		p.Match(PddlParserT__2)
	}

	return localctx
}

// IAtomicFormulaSkeletonContext is an interface to support dynamic dispatch.
type IAtomicFormulaSkeletonContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtomicFormulaSkeletonContext differentiates from other interfaces.
	IsAtomicFormulaSkeletonContext()
}

type AtomicFormulaSkeletonContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtomicFormulaSkeletonContext() *AtomicFormulaSkeletonContext {
	var p = new(AtomicFormulaSkeletonContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PddlParserRULE_atomicFormulaSkeleton
	return p
}

func (*AtomicFormulaSkeletonContext) IsAtomicFormulaSkeletonContext() {}

func NewAtomicFormulaSkeletonContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtomicFormulaSkeletonContext {
	var p = new(AtomicFormulaSkeletonContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PddlParserRULE_atomicFormulaSkeleton

	return p
}

func (s *AtomicFormulaSkeletonContext) GetParser() antlr.Parser { return s.parser }

func (s *AtomicFormulaSkeletonContext) Predicate() IPredicateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPredicateContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *AtomicFormulaSkeletonContext) TypedVariableList() ITypedVariableListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypedVariableListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypedVariableListContext)
}

func (s *AtomicFormulaSkeletonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtomicFormulaSkeletonContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AtomicFormulaSkeletonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.EnterAtomicFormulaSkeleton(s)
	}
}

func (s *AtomicFormulaSkeletonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.ExitAtomicFormulaSkeleton(s)
	}
}

func (p *PddlParser) AtomicFormulaSkeleton() (localctx IAtomicFormulaSkeletonContext) {
	this := p
	_ = this

	localctx = NewAtomicFormulaSkeletonContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, PddlParserRULE_atomicFormulaSkeleton)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(275)
		p.Match(PddlParserT__0)
	}
	{
		p.SetState(276)
		p.Predicate()
	}
	{
		p.SetState(277)
		p.TypedVariableList()
	}
	{
		p.SetState(278)
		p.Match(PddlParserT__2)
	}

	return localctx
}

// IPredicateContext is an interface to support dynamic dispatch.
type IPredicateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPredicateContext differentiates from other interfaces.
	IsPredicateContext()
}

type PredicateContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPredicateContext() *PredicateContext {
	var p = new(PredicateContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PddlParserRULE_predicate
	return p
}

func (*PredicateContext) IsPredicateContext() {}

func NewPredicateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PredicateContext {
	var p = new(PredicateContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PddlParserRULE_predicate

	return p
}

func (s *PredicateContext) GetParser() antlr.Parser { return s.parser }

func (s *PredicateContext) NAME() antlr.TerminalNode {
	return s.GetToken(PddlParserNAME, 0)
}

func (s *PredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.EnterPredicate(s)
	}
}

func (s *PredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.ExitPredicate(s)
	}
}

func (p *PddlParser) Predicate() (localctx IPredicateContext) {
	this := p
	_ = this

	localctx = NewPredicateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, PddlParserRULE_predicate)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(280)
		p.Match(PddlParserNAME)
	}

	return localctx
}

// ITypedVariableListContext is an interface to support dynamic dispatch.
type ITypedVariableListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypedVariableListContext differentiates from other interfaces.
	IsTypedVariableListContext()
}

type TypedVariableListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypedVariableListContext() *TypedVariableListContext {
	var p = new(TypedVariableListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PddlParserRULE_typedVariableList
	return p
}

func (*TypedVariableListContext) IsTypedVariableListContext() {}

func NewTypedVariableListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypedVariableListContext {
	var p = new(TypedVariableListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PddlParserRULE_typedVariableList

	return p
}

func (s *TypedVariableListContext) GetParser() antlr.Parser { return s.parser }

func (s *TypedVariableListContext) AllVARIABLE() []antlr.TerminalNode {
	return s.GetTokens(PddlParserVARIABLE)
}

func (s *TypedVariableListContext) VARIABLE(i int) antlr.TerminalNode {
	return s.GetToken(PddlParserVARIABLE, i)
}

func (s *TypedVariableListContext) AllSingleTypeVarList() []ISingleTypeVarListContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISingleTypeVarListContext)(nil)).Elem())
	var tst = make([]ISingleTypeVarListContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISingleTypeVarListContext)
		}
	}

	return tst
}

func (s *TypedVariableListContext) SingleTypeVarList(i int) ISingleTypeVarListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleTypeVarListContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISingleTypeVarListContext)
}

func (s *TypedVariableListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypedVariableListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypedVariableListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.EnterTypedVariableList(s)
	}
}

func (s *TypedVariableListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.ExitTypedVariableList(s)
	}
}

func (p *PddlParser) TypedVariableList() (localctx ITypedVariableListContext) {
	this := p
	_ = this

	localctx = NewTypedVariableListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, PddlParserRULE_typedVariableList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(299)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 23, p.GetParserRuleContext()) {
	case 1:
		p.SetState(285)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PddlParserVARIABLE {
			{
				p.SetState(282)
				p.Match(PddlParserVARIABLE)
			}

			p.SetState(287)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		p.SetState(289)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(288)
					p.SingleTypeVarList()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(291)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 21, p.GetParserRuleContext())
		}
		p.SetState(296)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PddlParserVARIABLE {
			{
				p.SetState(293)
				p.Match(PddlParserVARIABLE)
			}

			p.SetState(298)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// ISingleTypeVarListContext is an interface to support dynamic dispatch.
type ISingleTypeVarListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetT returns the t rule contexts.
	GetT() IType_Context

	// SetT sets the t rule contexts.
	SetT(IType_Context)

	// IsSingleTypeVarListContext differentiates from other interfaces.
	IsSingleTypeVarListContext()
}

type SingleTypeVarListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	t      IType_Context
}

func NewEmptySingleTypeVarListContext() *SingleTypeVarListContext {
	var p = new(SingleTypeVarListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PddlParserRULE_singleTypeVarList
	return p
}

func (*SingleTypeVarListContext) IsSingleTypeVarListContext() {}

func NewSingleTypeVarListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleTypeVarListContext {
	var p = new(SingleTypeVarListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PddlParserRULE_singleTypeVarList

	return p
}

func (s *SingleTypeVarListContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleTypeVarListContext) GetT() IType_Context { return s.t }

func (s *SingleTypeVarListContext) SetT(v IType_Context) { s.t = v }

func (s *SingleTypeVarListContext) Type_() IType_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *SingleTypeVarListContext) AllVARIABLE() []antlr.TerminalNode {
	return s.GetTokens(PddlParserVARIABLE)
}

func (s *SingleTypeVarListContext) VARIABLE(i int) antlr.TerminalNode {
	return s.GetToken(PddlParserVARIABLE, i)
}

func (s *SingleTypeVarListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleTypeVarListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleTypeVarListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.EnterSingleTypeVarList(s)
	}
}

func (s *SingleTypeVarListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.ExitSingleTypeVarList(s)
	}
}

func (p *PddlParser) SingleTypeVarList() (localctx ISingleTypeVarListContext) {
	this := p
	_ = this

	localctx = NewSingleTypeVarListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, PddlParserRULE_singleTypeVarList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(302)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == PddlParserVARIABLE {
		{
			p.SetState(301)
			p.Match(PddlParserVARIABLE)
		}

		p.SetState(304)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(306)
		p.Match(PddlParserT__6)
	}
	{
		p.SetState(307)

		var _x = p.Type_()

		localctx.(*SingleTypeVarListContext).t = _x
	}

	return localctx
}

// IConstraintsContext is an interface to support dynamic dispatch.
type IConstraintsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstraintsContext differentiates from other interfaces.
	IsConstraintsContext()
}

type ConstraintsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstraintsContext() *ConstraintsContext {
	var p = new(ConstraintsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PddlParserRULE_constraints
	return p
}

func (*ConstraintsContext) IsConstraintsContext() {}

func NewConstraintsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstraintsContext {
	var p = new(ConstraintsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PddlParserRULE_constraints

	return p
}

func (s *ConstraintsContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstraintsContext) ConGD() IConGDContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConGDContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConGDContext)
}

func (s *ConstraintsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstraintsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstraintsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.EnterConstraints(s)
	}
}

func (s *ConstraintsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.ExitConstraints(s)
	}
}

func (p *PddlParser) Constraints() (localctx IConstraintsContext) {
	this := p
	_ = this

	localctx = NewConstraintsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, PddlParserRULE_constraints)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(309)
		p.Match(PddlParserT__0)
	}
	{
		p.SetState(310)
		p.Match(PddlParserT__12)
	}
	{
		p.SetState(311)
		p.ConGD()
	}
	{
		p.SetState(312)
		p.Match(PddlParserT__2)
	}

	return localctx
}

// IStructureDefContext is an interface to support dynamic dispatch.
type IStructureDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStructureDefContext differentiates from other interfaces.
	IsStructureDefContext()
}

type StructureDefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStructureDefContext() *StructureDefContext {
	var p = new(StructureDefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PddlParserRULE_structureDef
	return p
}

func (*StructureDefContext) IsStructureDefContext() {}

func NewStructureDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StructureDefContext {
	var p = new(StructureDefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PddlParserRULE_structureDef

	return p
}

func (s *StructureDefContext) GetParser() antlr.Parser { return s.parser }

func (s *StructureDefContext) ActionDef() IActionDefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IActionDefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IActionDefContext)
}

func (s *StructureDefContext) DurativeActionDef() IDurativeActionDefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDurativeActionDefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDurativeActionDefContext)
}

func (s *StructureDefContext) DerivedDef() IDerivedDefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDerivedDefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDerivedDefContext)
}

func (s *StructureDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructureDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StructureDefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.EnterStructureDef(s)
	}
}

func (s *StructureDefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.ExitStructureDef(s)
	}
}

func (p *PddlParser) StructureDef() (localctx IStructureDefContext) {
	this := p
	_ = this

	localctx = NewStructureDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, PddlParserRULE_structureDef)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(317)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 25, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(314)
			p.ActionDef()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(315)
			p.DurativeActionDef()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(316)
			p.DerivedDef()
		}

	}

	return localctx
}

// IActionDefContext is an interface to support dynamic dispatch.
type IActionDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsActionDefContext differentiates from other interfaces.
	IsActionDefContext()
}

type ActionDefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyActionDefContext() *ActionDefContext {
	var p = new(ActionDefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PddlParserRULE_actionDef
	return p
}

func (*ActionDefContext) IsActionDefContext() {}

func NewActionDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ActionDefContext {
	var p = new(ActionDefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PddlParserRULE_actionDef

	return p
}

func (s *ActionDefContext) GetParser() antlr.Parser { return s.parser }

func (s *ActionDefContext) ActionSymbol() IActionSymbolContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IActionSymbolContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IActionSymbolContext)
}

func (s *ActionDefContext) TypedVariableList() ITypedVariableListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypedVariableListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypedVariableListContext)
}

func (s *ActionDefContext) ActionDefBody() IActionDefBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IActionDefBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IActionDefBodyContext)
}

func (s *ActionDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ActionDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ActionDefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.EnterActionDef(s)
	}
}

func (s *ActionDefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.ExitActionDef(s)
	}
}

func (p *PddlParser) ActionDef() (localctx IActionDefContext) {
	this := p
	_ = this

	localctx = NewActionDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, PddlParserRULE_actionDef)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(319)
		p.Match(PddlParserT__0)
	}
	{
		p.SetState(320)
		p.Match(PddlParserT__13)
	}
	{
		p.SetState(321)
		p.ActionSymbol()
	}
	{
		p.SetState(322)
		p.Match(PddlParserT__14)
	}
	{
		p.SetState(323)
		p.Match(PddlParserT__0)
	}
	{
		p.SetState(324)
		p.TypedVariableList()
	}
	{
		p.SetState(325)
		p.Match(PddlParserT__2)
	}
	{
		p.SetState(326)
		p.ActionDefBody()
	}
	{
		p.SetState(327)
		p.Match(PddlParserT__2)
	}

	return localctx
}

// IActionSymbolContext is an interface to support dynamic dispatch.
type IActionSymbolContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsActionSymbolContext differentiates from other interfaces.
	IsActionSymbolContext()
}

type ActionSymbolContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyActionSymbolContext() *ActionSymbolContext {
	var p = new(ActionSymbolContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PddlParserRULE_actionSymbol
	return p
}

func (*ActionSymbolContext) IsActionSymbolContext() {}

func NewActionSymbolContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ActionSymbolContext {
	var p = new(ActionSymbolContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PddlParserRULE_actionSymbol

	return p
}

func (s *ActionSymbolContext) GetParser() antlr.Parser { return s.parser }

func (s *ActionSymbolContext) NAME() antlr.TerminalNode {
	return s.GetToken(PddlParserNAME, 0)
}

func (s *ActionSymbolContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ActionSymbolContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ActionSymbolContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.EnterActionSymbol(s)
	}
}

func (s *ActionSymbolContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.ExitActionSymbol(s)
	}
}

func (p *PddlParser) ActionSymbol() (localctx IActionSymbolContext) {
	this := p
	_ = this

	localctx = NewActionSymbolContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, PddlParserRULE_actionSymbol)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(329)
		p.Match(PddlParserNAME)
	}

	return localctx
}

// IActionDefBodyContext is an interface to support dynamic dispatch.
type IActionDefBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsActionDefBodyContext differentiates from other interfaces.
	IsActionDefBodyContext()
}

type ActionDefBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyActionDefBodyContext() *ActionDefBodyContext {
	var p = new(ActionDefBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PddlParserRULE_actionDefBody
	return p
}

func (*ActionDefBodyContext) IsActionDefBodyContext() {}

func NewActionDefBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ActionDefBodyContext {
	var p = new(ActionDefBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PddlParserRULE_actionDefBody

	return p
}

func (s *ActionDefBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *ActionDefBodyContext) GoalDesc() IGoalDescContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGoalDescContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGoalDescContext)
}

func (s *ActionDefBodyContext) Effect() IEffectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEffectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEffectContext)
}

func (s *ActionDefBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ActionDefBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ActionDefBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.EnterActionDefBody(s)
	}
}

func (s *ActionDefBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.ExitActionDefBody(s)
	}
}

func (p *PddlParser) ActionDefBody() (localctx IActionDefBodyContext) {
	this := p
	_ = this

	localctx = NewActionDefBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, PddlParserRULE_actionDefBody)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(337)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PddlParserT__15 {
		{
			p.SetState(331)
			p.Match(PddlParserT__15)
		}
		p.SetState(335)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 26, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(332)
				p.Match(PddlParserT__0)
			}
			{
				p.SetState(333)
				p.Match(PddlParserT__2)
			}

		case 2:
			{
				p.SetState(334)
				p.GoalDesc()
			}

		}

	}
	p.SetState(345)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PddlParserT__16 {
		{
			p.SetState(339)
			p.Match(PddlParserT__16)
		}
		p.SetState(343)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 28, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(340)
				p.Match(PddlParserT__0)
			}
			{
				p.SetState(341)
				p.Match(PddlParserT__2)
			}

		case 2:
			{
				p.SetState(342)
				p.Effect()
			}

		}

	}

	return localctx
}

// IGoalDescContext is an interface to support dynamic dispatch.
type IGoalDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGoalDescContext differentiates from other interfaces.
	IsGoalDescContext()
}

type GoalDescContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGoalDescContext() *GoalDescContext {
	var p = new(GoalDescContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PddlParserRULE_goalDesc
	return p
}

func (*GoalDescContext) IsGoalDescContext() {}

func NewGoalDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GoalDescContext {
	var p = new(GoalDescContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PddlParserRULE_goalDesc

	return p
}

func (s *GoalDescContext) GetParser() antlr.Parser { return s.parser }

func (s *GoalDescContext) AtomicTermFormula() IAtomicTermFormulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomicTermFormulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtomicTermFormulaContext)
}

func (s *GoalDescContext) AllGoalDesc() []IGoalDescContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IGoalDescContext)(nil)).Elem())
	var tst = make([]IGoalDescContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IGoalDescContext)
		}
	}

	return tst
}

func (s *GoalDescContext) GoalDesc(i int) IGoalDescContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGoalDescContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IGoalDescContext)
}

func (s *GoalDescContext) TypedVariableList() ITypedVariableListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypedVariableListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypedVariableListContext)
}

func (s *GoalDescContext) FComp() IFCompContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFCompContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFCompContext)
}

func (s *GoalDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GoalDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GoalDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.EnterGoalDesc(s)
	}
}

func (s *GoalDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.ExitGoalDesc(s)
	}
}

func (p *PddlParser) GoalDesc() (localctx IGoalDescContext) {
	this := p
	_ = this

	localctx = NewGoalDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, PddlParserRULE_goalDesc)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(394)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 32, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(347)
			p.AtomicTermFormula()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(348)
			p.Match(PddlParserT__0)
		}
		{
			p.SetState(349)
			p.Match(PddlParserT__17)
		}
		p.SetState(353)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PddlParserT__0 {
			{
				p.SetState(350)
				p.GoalDesc()
			}

			p.SetState(355)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(356)
			p.Match(PddlParserT__2)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(357)
			p.Match(PddlParserT__0)
		}
		{
			p.SetState(358)
			p.Match(PddlParserT__18)
		}
		p.SetState(362)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PddlParserT__0 {
			{
				p.SetState(359)
				p.GoalDesc()
			}

			p.SetState(364)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(365)
			p.Match(PddlParserT__2)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(366)
			p.Match(PddlParserT__0)
		}
		{
			p.SetState(367)
			p.Match(PddlParserT__19)
		}
		{
			p.SetState(368)
			p.GoalDesc()
		}
		{
			p.SetState(369)
			p.Match(PddlParserT__2)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(371)
			p.Match(PddlParserT__0)
		}
		{
			p.SetState(372)
			p.Match(PddlParserT__20)
		}
		{
			p.SetState(373)
			p.GoalDesc()
		}
		{
			p.SetState(374)
			p.GoalDesc()
		}
		{
			p.SetState(375)
			p.Match(PddlParserT__2)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(377)
			p.Match(PddlParserT__0)
		}
		{
			p.SetState(378)
			p.Match(PddlParserT__21)
		}
		{
			p.SetState(379)
			p.Match(PddlParserT__0)
		}
		{
			p.SetState(380)
			p.TypedVariableList()
		}
		{
			p.SetState(381)
			p.Match(PddlParserT__2)
		}
		{
			p.SetState(382)
			p.GoalDesc()
		}
		{
			p.SetState(383)
			p.Match(PddlParserT__2)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(385)
			p.Match(PddlParserT__0)
		}
		{
			p.SetState(386)
			p.Match(PddlParserT__22)
		}
		{
			p.SetState(387)
			p.Match(PddlParserT__0)
		}
		{
			p.SetState(388)
			p.TypedVariableList()
		}
		{
			p.SetState(389)
			p.Match(PddlParserT__2)
		}
		{
			p.SetState(390)
			p.GoalDesc()
		}
		{
			p.SetState(391)
			p.Match(PddlParserT__2)
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(393)
			p.FComp()
		}

	}

	return localctx
}

// IFCompContext is an interface to support dynamic dispatch.
type IFCompContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFCompContext differentiates from other interfaces.
	IsFCompContext()
}

type FCompContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFCompContext() *FCompContext {
	var p = new(FCompContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PddlParserRULE_fComp
	return p
}

func (*FCompContext) IsFCompContext() {}

func NewFCompContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FCompContext {
	var p = new(FCompContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PddlParserRULE_fComp

	return p
}

func (s *FCompContext) GetParser() antlr.Parser { return s.parser }

func (s *FCompContext) BinaryComp() IBinaryCompContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBinaryCompContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBinaryCompContext)
}

func (s *FCompContext) AllFExp() []IFExpContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFExpContext)(nil)).Elem())
	var tst = make([]IFExpContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFExpContext)
		}
	}

	return tst
}

func (s *FCompContext) FExp(i int) IFExpContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFExpContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFExpContext)
}

func (s *FCompContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FCompContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FCompContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.EnterFComp(s)
	}
}

func (s *FCompContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.ExitFComp(s)
	}
}

func (p *PddlParser) FComp() (localctx IFCompContext) {
	this := p
	_ = this

	localctx = NewFCompContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, PddlParserRULE_fComp)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(396)
		p.Match(PddlParserT__0)
	}
	{
		p.SetState(397)
		p.BinaryComp()
	}
	{
		p.SetState(398)
		p.FExp()
	}
	{
		p.SetState(399)
		p.FExp()
	}
	{
		p.SetState(400)
		p.Match(PddlParserT__2)
	}

	return localctx
}

// IAtomicTermFormulaContext is an interface to support dynamic dispatch.
type IAtomicTermFormulaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtomicTermFormulaContext differentiates from other interfaces.
	IsAtomicTermFormulaContext()
}

type AtomicTermFormulaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtomicTermFormulaContext() *AtomicTermFormulaContext {
	var p = new(AtomicTermFormulaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PddlParserRULE_atomicTermFormula
	return p
}

func (*AtomicTermFormulaContext) IsAtomicTermFormulaContext() {}

func NewAtomicTermFormulaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtomicTermFormulaContext {
	var p = new(AtomicTermFormulaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PddlParserRULE_atomicTermFormula

	return p
}

func (s *AtomicTermFormulaContext) GetParser() antlr.Parser { return s.parser }

func (s *AtomicTermFormulaContext) Predicate() IPredicateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPredicateContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *AtomicTermFormulaContext) AllTerm() []ITermContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITermContext)(nil)).Elem())
	var tst = make([]ITermContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITermContext)
		}
	}

	return tst
}

func (s *AtomicTermFormulaContext) Term(i int) ITermContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITermContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *AtomicTermFormulaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtomicTermFormulaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AtomicTermFormulaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.EnterAtomicTermFormula(s)
	}
}

func (s *AtomicTermFormulaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.ExitAtomicTermFormula(s)
	}
}

func (p *PddlParser) AtomicTermFormula() (localctx IAtomicTermFormulaContext) {
	this := p
	_ = this

	localctx = NewAtomicTermFormulaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, PddlParserRULE_atomicTermFormula)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(402)
		p.Match(PddlParserT__0)
	}
	{
		p.SetState(403)
		p.Predicate()
	}
	p.SetState(407)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PddlParserNAME || _la == PddlParserVARIABLE {
		{
			p.SetState(404)
			p.Term()
		}

		p.SetState(409)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(410)
		p.Match(PddlParserT__2)
	}

	return localctx
}

// ITermContext is an interface to support dynamic dispatch.
type ITermContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTermContext differentiates from other interfaces.
	IsTermContext()
}

type TermContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTermContext() *TermContext {
	var p = new(TermContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PddlParserRULE_term
	return p
}

func (*TermContext) IsTermContext() {}

func NewTermContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TermContext {
	var p = new(TermContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PddlParserRULE_term

	return p
}

func (s *TermContext) GetParser() antlr.Parser { return s.parser }

func (s *TermContext) NAME() antlr.TerminalNode {
	return s.GetToken(PddlParserNAME, 0)
}

func (s *TermContext) VARIABLE() antlr.TerminalNode {
	return s.GetToken(PddlParserVARIABLE, 0)
}

func (s *TermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TermContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.EnterTerm(s)
	}
}

func (s *TermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.ExitTerm(s)
	}
}

func (p *PddlParser) Term() (localctx ITermContext) {
	this := p
	_ = this

	localctx = NewTermContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, PddlParserRULE_term)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(412)
		_la = p.GetTokenStream().LA(1)

		if !(_la == PddlParserNAME || _la == PddlParserVARIABLE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IDurativeActionDefContext is an interface to support dynamic dispatch.
type IDurativeActionDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDurativeActionDefContext differentiates from other interfaces.
	IsDurativeActionDefContext()
}

type DurativeActionDefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDurativeActionDefContext() *DurativeActionDefContext {
	var p = new(DurativeActionDefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PddlParserRULE_durativeActionDef
	return p
}

func (*DurativeActionDefContext) IsDurativeActionDefContext() {}

func NewDurativeActionDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DurativeActionDefContext {
	var p = new(DurativeActionDefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PddlParserRULE_durativeActionDef

	return p
}

func (s *DurativeActionDefContext) GetParser() antlr.Parser { return s.parser }

func (s *DurativeActionDefContext) ActionSymbol() IActionSymbolContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IActionSymbolContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IActionSymbolContext)
}

func (s *DurativeActionDefContext) TypedVariableList() ITypedVariableListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypedVariableListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypedVariableListContext)
}

func (s *DurativeActionDefContext) DaDefBody() IDaDefBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDaDefBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDaDefBodyContext)
}

func (s *DurativeActionDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DurativeActionDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DurativeActionDefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.EnterDurativeActionDef(s)
	}
}

func (s *DurativeActionDefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.ExitDurativeActionDef(s)
	}
}

func (p *PddlParser) DurativeActionDef() (localctx IDurativeActionDefContext) {
	this := p
	_ = this

	localctx = NewDurativeActionDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, PddlParserRULE_durativeActionDef)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(414)
		p.Match(PddlParserT__0)
	}
	{
		p.SetState(415)
		p.Match(PddlParserT__23)
	}
	{
		p.SetState(416)
		p.ActionSymbol()
	}
	{
		p.SetState(417)
		p.Match(PddlParserT__14)
	}
	{
		p.SetState(418)
		p.Match(PddlParserT__0)
	}
	{
		p.SetState(419)
		p.TypedVariableList()
	}
	{
		p.SetState(420)
		p.Match(PddlParserT__2)
	}
	{
		p.SetState(421)
		p.DaDefBody()
	}
	{
		p.SetState(422)
		p.Match(PddlParserT__2)
	}

	return localctx
}

// IDaDefBodyContext is an interface to support dynamic dispatch.
type IDaDefBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDaDefBodyContext differentiates from other interfaces.
	IsDaDefBodyContext()
}

type DaDefBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDaDefBodyContext() *DaDefBodyContext {
	var p = new(DaDefBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PddlParserRULE_daDefBody
	return p
}

func (*DaDefBodyContext) IsDaDefBodyContext() {}

func NewDaDefBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DaDefBodyContext {
	var p = new(DaDefBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PddlParserRULE_daDefBody

	return p
}

func (s *DaDefBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *DaDefBodyContext) DurationConstraint() IDurationConstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDurationConstraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDurationConstraintContext)
}

func (s *DaDefBodyContext) DaGD() IDaGDContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDaGDContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDaGDContext)
}

func (s *DaDefBodyContext) DaEffect() IDaEffectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDaEffectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDaEffectContext)
}

func (s *DaDefBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DaDefBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DaDefBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.EnterDaDefBody(s)
	}
}

func (s *DaDefBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.ExitDaDefBody(s)
	}
}

func (p *PddlParser) DaDefBody() (localctx IDaDefBodyContext) {
	this := p
	_ = this

	localctx = NewDaDefBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, PddlParserRULE_daDefBody)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(438)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PddlParserT__24:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(424)
			p.Match(PddlParserT__24)
		}
		{
			p.SetState(425)
			p.DurationConstraint()
		}

	case PddlParserT__25:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(426)
			p.Match(PddlParserT__25)
		}
		p.SetState(430)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 34, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(427)
				p.Match(PddlParserT__0)
			}
			{
				p.SetState(428)
				p.Match(PddlParserT__2)
			}

		case 2:
			{
				p.SetState(429)
				p.DaGD()
			}

		}

	case PddlParserT__16:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(432)
			p.Match(PddlParserT__16)
		}
		p.SetState(436)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 35, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(433)
				p.Match(PddlParserT__0)
			}
			{
				p.SetState(434)
				p.Match(PddlParserT__2)
			}

		case 2:
			{
				p.SetState(435)
				p.DaEffect()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDaGDContext is an interface to support dynamic dispatch.
type IDaGDContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDaGDContext differentiates from other interfaces.
	IsDaGDContext()
}

type DaGDContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDaGDContext() *DaGDContext {
	var p = new(DaGDContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PddlParserRULE_daGD
	return p
}

func (*DaGDContext) IsDaGDContext() {}

func NewDaGDContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DaGDContext {
	var p = new(DaGDContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PddlParserRULE_daGD

	return p
}

func (s *DaGDContext) GetParser() antlr.Parser { return s.parser }

func (s *DaGDContext) PrefTimedGD() IPrefTimedGDContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrefTimedGDContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrefTimedGDContext)
}

func (s *DaGDContext) AllDaGD() []IDaGDContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDaGDContext)(nil)).Elem())
	var tst = make([]IDaGDContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDaGDContext)
		}
	}

	return tst
}

func (s *DaGDContext) DaGD(i int) IDaGDContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDaGDContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDaGDContext)
}

func (s *DaGDContext) TypedVariableList() ITypedVariableListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypedVariableListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypedVariableListContext)
}

func (s *DaGDContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DaGDContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DaGDContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.EnterDaGD(s)
	}
}

func (s *DaGDContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.ExitDaGD(s)
	}
}

func (p *PddlParser) DaGD() (localctx IDaGDContext) {
	this := p
	_ = this

	localctx = NewDaGDContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, PddlParserRULE_daGD)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(458)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 38, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(440)
			p.PrefTimedGD()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(441)
			p.Match(PddlParserT__0)
		}
		{
			p.SetState(442)
			p.Match(PddlParserT__17)
		}
		p.SetState(446)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PddlParserT__0 {
			{
				p.SetState(443)
				p.DaGD()
			}

			p.SetState(448)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(449)
			p.Match(PddlParserT__2)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(450)
			p.Match(PddlParserT__0)
		}
		{
			p.SetState(451)
			p.Match(PddlParserT__22)
		}
		{
			p.SetState(452)
			p.Match(PddlParserT__0)
		}
		{
			p.SetState(453)
			p.TypedVariableList()
		}
		{
			p.SetState(454)
			p.Match(PddlParserT__2)
		}
		{
			p.SetState(455)
			p.DaGD()
		}
		{
			p.SetState(456)
			p.Match(PddlParserT__2)
		}

	}

	return localctx
}

// IPrefTimedGDContext is an interface to support dynamic dispatch.
type IPrefTimedGDContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrefTimedGDContext differentiates from other interfaces.
	IsPrefTimedGDContext()
}

type PrefTimedGDContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrefTimedGDContext() *PrefTimedGDContext {
	var p = new(PrefTimedGDContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PddlParserRULE_prefTimedGD
	return p
}

func (*PrefTimedGDContext) IsPrefTimedGDContext() {}

func NewPrefTimedGDContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrefTimedGDContext {
	var p = new(PrefTimedGDContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PddlParserRULE_prefTimedGD

	return p
}

func (s *PrefTimedGDContext) GetParser() antlr.Parser { return s.parser }

func (s *PrefTimedGDContext) TimedGD() ITimedGDContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITimedGDContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITimedGDContext)
}

func (s *PrefTimedGDContext) NAME() antlr.TerminalNode {
	return s.GetToken(PddlParserNAME, 0)
}

func (s *PrefTimedGDContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrefTimedGDContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrefTimedGDContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.EnterPrefTimedGD(s)
	}
}

func (s *PrefTimedGDContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.ExitPrefTimedGD(s)
	}
}

func (p *PddlParser) PrefTimedGD() (localctx IPrefTimedGDContext) {
	this := p
	_ = this

	localctx = NewPrefTimedGDContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, PddlParserRULE_prefTimedGD)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(469)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 40, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(460)
			p.TimedGD()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(461)
			p.Match(PddlParserT__0)
		}
		{
			p.SetState(462)
			p.Match(PddlParserT__26)
		}
		p.SetState(464)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PddlParserNAME {
			{
				p.SetState(463)
				p.Match(PddlParserNAME)
			}

		}
		{
			p.SetState(466)
			p.TimedGD()
		}
		{
			p.SetState(467)
			p.Match(PddlParserT__2)
		}

	}

	return localctx
}

// ITimedGDContext is an interface to support dynamic dispatch.
type ITimedGDContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTimedGDContext differentiates from other interfaces.
	IsTimedGDContext()
}

type TimedGDContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTimedGDContext() *TimedGDContext {
	var p = new(TimedGDContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PddlParserRULE_timedGD
	return p
}

func (*TimedGDContext) IsTimedGDContext() {}

func NewTimedGDContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TimedGDContext {
	var p = new(TimedGDContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PddlParserRULE_timedGD

	return p
}

func (s *TimedGDContext) GetParser() antlr.Parser { return s.parser }

func (s *TimedGDContext) TimeSpecifier() ITimeSpecifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITimeSpecifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITimeSpecifierContext)
}

func (s *TimedGDContext) GoalDesc() IGoalDescContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGoalDescContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGoalDescContext)
}

func (s *TimedGDContext) Interval() IIntervalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntervalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntervalContext)
}

func (s *TimedGDContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimedGDContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TimedGDContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.EnterTimedGD(s)
	}
}

func (s *TimedGDContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.ExitTimedGD(s)
	}
}

func (p *PddlParser) TimedGD() (localctx ITimedGDContext) {
	this := p
	_ = this

	localctx = NewTimedGDContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, PddlParserRULE_timedGD)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(483)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 41, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(471)
			p.Match(PddlParserT__0)
		}
		{
			p.SetState(472)
			p.Match(PddlParserT__27)
		}
		{
			p.SetState(473)
			p.TimeSpecifier()
		}
		{
			p.SetState(474)
			p.GoalDesc()
		}
		{
			p.SetState(475)
			p.Match(PddlParserT__2)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(477)
			p.Match(PddlParserT__0)
		}
		{
			p.SetState(478)
			p.Match(PddlParserT__28)
		}
		{
			p.SetState(479)
			p.Interval()
		}
		{
			p.SetState(480)
			p.GoalDesc()
		}
		{
			p.SetState(481)
			p.Match(PddlParserT__2)
		}

	}

	return localctx
}

// ITimeSpecifierContext is an interface to support dynamic dispatch.
type ITimeSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTimeSpecifierContext differentiates from other interfaces.
	IsTimeSpecifierContext()
}

type TimeSpecifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTimeSpecifierContext() *TimeSpecifierContext {
	var p = new(TimeSpecifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PddlParserRULE_timeSpecifier
	return p
}

func (*TimeSpecifierContext) IsTimeSpecifierContext() {}

func NewTimeSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TimeSpecifierContext {
	var p = new(TimeSpecifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PddlParserRULE_timeSpecifier

	return p
}

func (s *TimeSpecifierContext) GetParser() antlr.Parser { return s.parser }
func (s *TimeSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimeSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TimeSpecifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.EnterTimeSpecifier(s)
	}
}

func (s *TimeSpecifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.ExitTimeSpecifier(s)
	}
}

func (p *PddlParser) TimeSpecifier() (localctx ITimeSpecifierContext) {
	this := p
	_ = this

	localctx = NewTimeSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, PddlParserRULE_timeSpecifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(485)
		_la = p.GetTokenStream().LA(1)

		if !(_la == PddlParserT__29 || _la == PddlParserT__30) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IIntervalContext is an interface to support dynamic dispatch.
type IIntervalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIntervalContext differentiates from other interfaces.
	IsIntervalContext()
}

type IntervalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntervalContext() *IntervalContext {
	var p = new(IntervalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PddlParserRULE_interval
	return p
}

func (*IntervalContext) IsIntervalContext() {}

func NewIntervalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntervalContext {
	var p = new(IntervalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PddlParserRULE_interval

	return p
}

func (s *IntervalContext) GetParser() antlr.Parser { return s.parser }
func (s *IntervalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntervalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.EnterInterval(s)
	}
}

func (s *IntervalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.ExitInterval(s)
	}
}

func (p *PddlParser) Interval() (localctx IIntervalContext) {
	this := p
	_ = this

	localctx = NewIntervalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, PddlParserRULE_interval)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(487)
		p.Match(PddlParserT__31)
	}

	return localctx
}

// IDerivedDefContext is an interface to support dynamic dispatch.
type IDerivedDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDerivedDefContext differentiates from other interfaces.
	IsDerivedDefContext()
}

type DerivedDefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDerivedDefContext() *DerivedDefContext {
	var p = new(DerivedDefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PddlParserRULE_derivedDef
	return p
}

func (*DerivedDefContext) IsDerivedDefContext() {}

func NewDerivedDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DerivedDefContext {
	var p = new(DerivedDefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PddlParserRULE_derivedDef

	return p
}

func (s *DerivedDefContext) GetParser() antlr.Parser { return s.parser }

func (s *DerivedDefContext) TypedVariableList() ITypedVariableListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypedVariableListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypedVariableListContext)
}

func (s *DerivedDefContext) GoalDesc() IGoalDescContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGoalDescContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGoalDescContext)
}

func (s *DerivedDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DerivedDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DerivedDefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.EnterDerivedDef(s)
	}
}

func (s *DerivedDefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.ExitDerivedDef(s)
	}
}

func (p *PddlParser) DerivedDef() (localctx IDerivedDefContext) {
	this := p
	_ = this

	localctx = NewDerivedDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, PddlParserRULE_derivedDef)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(489)
		p.Match(PddlParserT__0)
	}
	{
		p.SetState(490)
		p.Match(PddlParserT__32)
	}
	{
		p.SetState(491)
		p.TypedVariableList()
	}
	{
		p.SetState(492)
		p.GoalDesc()
	}
	{
		p.SetState(493)
		p.Match(PddlParserT__2)
	}

	return localctx
}

// IFExpContext is an interface to support dynamic dispatch.
type IFExpContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFExpContext differentiates from other interfaces.
	IsFExpContext()
}

type FExpContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFExpContext() *FExpContext {
	var p = new(FExpContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PddlParserRULE_fExp
	return p
}

func (*FExpContext) IsFExpContext() {}

func NewFExpContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FExpContext {
	var p = new(FExpContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PddlParserRULE_fExp

	return p
}

func (s *FExpContext) GetParser() antlr.Parser { return s.parser }

func (s *FExpContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(PddlParserNUMBER, 0)
}

func (s *FExpContext) BinaryOp() IBinaryOpContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBinaryOpContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBinaryOpContext)
}

func (s *FExpContext) FExp() IFExpContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFExpContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFExpContext)
}

func (s *FExpContext) FExp2() IFExp2Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFExp2Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFExp2Context)
}

func (s *FExpContext) FHead() IFHeadContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFHeadContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFHeadContext)
}

func (s *FExpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FExpContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FExpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.EnterFExp(s)
	}
}

func (s *FExpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.ExitFExp(s)
	}
}

func (p *PddlParser) FExp() (localctx IFExpContext) {
	this := p
	_ = this

	localctx = NewFExpContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, PddlParserRULE_fExp)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(508)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 42, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(495)
			p.Match(PddlParserNUMBER)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(496)
			p.Match(PddlParserT__0)
		}
		{
			p.SetState(497)
			p.BinaryOp()
		}
		{
			p.SetState(498)
			p.FExp()
		}
		{
			p.SetState(499)
			p.FExp2()
		}
		{
			p.SetState(500)
			p.Match(PddlParserT__2)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(502)
			p.Match(PddlParserT__0)
		}
		{
			p.SetState(503)
			p.Match(PddlParserT__6)
		}
		{
			p.SetState(504)
			p.FExp()
		}
		{
			p.SetState(505)
			p.Match(PddlParserT__2)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(507)
			p.FHead()
		}

	}

	return localctx
}

// IFExp2Context is an interface to support dynamic dispatch.
type IFExp2Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFExp2Context differentiates from other interfaces.
	IsFExp2Context()
}

type FExp2Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFExp2Context() *FExp2Context {
	var p = new(FExp2Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PddlParserRULE_fExp2
	return p
}

func (*FExp2Context) IsFExp2Context() {}

func NewFExp2Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FExp2Context {
	var p = new(FExp2Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PddlParserRULE_fExp2

	return p
}

func (s *FExp2Context) GetParser() antlr.Parser { return s.parser }

func (s *FExp2Context) FExp() IFExpContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFExpContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFExpContext)
}

func (s *FExp2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FExp2Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FExp2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.EnterFExp2(s)
	}
}

func (s *FExp2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.ExitFExp2(s)
	}
}

func (p *PddlParser) FExp2() (localctx IFExp2Context) {
	this := p
	_ = this

	localctx = NewFExp2Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, PddlParserRULE_fExp2)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(510)
		p.FExp()
	}

	return localctx
}

// IFHeadContext is an interface to support dynamic dispatch.
type IFHeadContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFHeadContext differentiates from other interfaces.
	IsFHeadContext()
}

type FHeadContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFHeadContext() *FHeadContext {
	var p = new(FHeadContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PddlParserRULE_fHead
	return p
}

func (*FHeadContext) IsFHeadContext() {}

func NewFHeadContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FHeadContext {
	var p = new(FHeadContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PddlParserRULE_fHead

	return p
}

func (s *FHeadContext) GetParser() antlr.Parser { return s.parser }

func (s *FHeadContext) FunctionSymbol() IFunctionSymbolContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionSymbolContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionSymbolContext)
}

func (s *FHeadContext) AllTerm() []ITermContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITermContext)(nil)).Elem())
	var tst = make([]ITermContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITermContext)
		}
	}

	return tst
}

func (s *FHeadContext) Term(i int) ITermContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITermContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *FHeadContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FHeadContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FHeadContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.EnterFHead(s)
	}
}

func (s *FHeadContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.ExitFHead(s)
	}
}

func (p *PddlParser) FHead() (localctx IFHeadContext) {
	this := p
	_ = this

	localctx = NewFHeadContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, PddlParserRULE_fHead)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(523)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PddlParserT__0:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(512)
			p.Match(PddlParserT__0)
		}
		{
			p.SetState(513)
			p.FunctionSymbol()
		}
		p.SetState(517)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PddlParserNAME || _la == PddlParserVARIABLE {
			{
				p.SetState(514)
				p.Term()
			}

			p.SetState(519)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(520)
			p.Match(PddlParserT__2)
		}

	case PddlParserNAME:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(522)
			p.FunctionSymbol()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IEffectContext is an interface to support dynamic dispatch.
type IEffectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEffectContext differentiates from other interfaces.
	IsEffectContext()
}

type EffectContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEffectContext() *EffectContext {
	var p = new(EffectContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PddlParserRULE_effect
	return p
}

func (*EffectContext) IsEffectContext() {}

func NewEffectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EffectContext {
	var p = new(EffectContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PddlParserRULE_effect

	return p
}

func (s *EffectContext) GetParser() antlr.Parser { return s.parser }

func (s *EffectContext) AllCEffect() []ICEffectContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICEffectContext)(nil)).Elem())
	var tst = make([]ICEffectContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICEffectContext)
		}
	}

	return tst
}

func (s *EffectContext) CEffect(i int) ICEffectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICEffectContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICEffectContext)
}

func (s *EffectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EffectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EffectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.EnterEffect(s)
	}
}

func (s *EffectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.ExitEffect(s)
	}
}

func (p *PddlParser) Effect() (localctx IEffectContext) {
	this := p
	_ = this

	localctx = NewEffectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, PddlParserRULE_effect)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(535)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 46, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(525)
			p.Match(PddlParserT__0)
		}
		{
			p.SetState(526)
			p.Match(PddlParserT__17)
		}
		p.SetState(530)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PddlParserT__0 {
			{
				p.SetState(527)
				p.CEffect()
			}

			p.SetState(532)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(533)
			p.Match(PddlParserT__2)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(534)
			p.CEffect()
		}

	}

	return localctx
}

// ICEffectContext is an interface to support dynamic dispatch.
type ICEffectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCEffectContext differentiates from other interfaces.
	IsCEffectContext()
}

type CEffectContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCEffectContext() *CEffectContext {
	var p = new(CEffectContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PddlParserRULE_cEffect
	return p
}

func (*CEffectContext) IsCEffectContext() {}

func NewCEffectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CEffectContext {
	var p = new(CEffectContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PddlParserRULE_cEffect

	return p
}

func (s *CEffectContext) GetParser() antlr.Parser { return s.parser }

func (s *CEffectContext) TypedVariableList() ITypedVariableListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypedVariableListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypedVariableListContext)
}

func (s *CEffectContext) Effect() IEffectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEffectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEffectContext)
}

func (s *CEffectContext) GoalDesc() IGoalDescContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGoalDescContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGoalDescContext)
}

func (s *CEffectContext) CondEffect() ICondEffectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICondEffectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICondEffectContext)
}

func (s *CEffectContext) PEffect() IPEffectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPEffectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPEffectContext)
}

func (s *CEffectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CEffectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CEffectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.EnterCEffect(s)
	}
}

func (s *CEffectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.ExitCEffect(s)
	}
}

func (p *PddlParser) CEffect() (localctx ICEffectContext) {
	this := p
	_ = this

	localctx = NewCEffectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, PddlParserRULE_cEffect)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(552)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 47, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(537)
			p.Match(PddlParserT__0)
		}
		{
			p.SetState(538)
			p.Match(PddlParserT__22)
		}
		{
			p.SetState(539)
			p.Match(PddlParserT__0)
		}
		{
			p.SetState(540)
			p.TypedVariableList()
		}
		{
			p.SetState(541)
			p.Match(PddlParserT__2)
		}
		{
			p.SetState(542)
			p.Effect()
		}
		{
			p.SetState(543)
			p.Match(PddlParserT__2)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(545)
			p.Match(PddlParserT__0)
		}
		{
			p.SetState(546)
			p.Match(PddlParserT__33)
		}
		{
			p.SetState(547)
			p.GoalDesc()
		}
		{
			p.SetState(548)
			p.CondEffect()
		}
		{
			p.SetState(549)
			p.Match(PddlParserT__2)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(551)
			p.PEffect()
		}

	}

	return localctx
}

// IPEffectContext is an interface to support dynamic dispatch.
type IPEffectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPEffectContext differentiates from other interfaces.
	IsPEffectContext()
}

type PEffectContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPEffectContext() *PEffectContext {
	var p = new(PEffectContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PddlParserRULE_pEffect
	return p
}

func (*PEffectContext) IsPEffectContext() {}

func NewPEffectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PEffectContext {
	var p = new(PEffectContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PddlParserRULE_pEffect

	return p
}

func (s *PEffectContext) GetParser() antlr.Parser { return s.parser }

func (s *PEffectContext) AssignOp() IAssignOpContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignOpContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignOpContext)
}

func (s *PEffectContext) FHead() IFHeadContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFHeadContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFHeadContext)
}

func (s *PEffectContext) FExp() IFExpContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFExpContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFExpContext)
}

func (s *PEffectContext) AtomicTermFormula() IAtomicTermFormulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomicTermFormulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtomicTermFormulaContext)
}

func (s *PEffectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PEffectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PEffectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.EnterPEffect(s)
	}
}

func (s *PEffectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.ExitPEffect(s)
	}
}

func (p *PddlParser) PEffect() (localctx IPEffectContext) {
	this := p
	_ = this

	localctx = NewPEffectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, PddlParserRULE_pEffect)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(566)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 48, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(554)
			p.Match(PddlParserT__0)
		}
		{
			p.SetState(555)
			p.AssignOp()
		}
		{
			p.SetState(556)
			p.FHead()
		}
		{
			p.SetState(557)
			p.FExp()
		}
		{
			p.SetState(558)
			p.Match(PddlParserT__2)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(560)
			p.Match(PddlParserT__0)
		}
		{
			p.SetState(561)
			p.Match(PddlParserT__19)
		}
		{
			p.SetState(562)
			p.AtomicTermFormula()
		}
		{
			p.SetState(563)
			p.Match(PddlParserT__2)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(565)
			p.AtomicTermFormula()
		}

	}

	return localctx
}

// ICondEffectContext is an interface to support dynamic dispatch.
type ICondEffectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCondEffectContext differentiates from other interfaces.
	IsCondEffectContext()
}

type CondEffectContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCondEffectContext() *CondEffectContext {
	var p = new(CondEffectContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PddlParserRULE_condEffect
	return p
}

func (*CondEffectContext) IsCondEffectContext() {}

func NewCondEffectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CondEffectContext {
	var p = new(CondEffectContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PddlParserRULE_condEffect

	return p
}

func (s *CondEffectContext) GetParser() antlr.Parser { return s.parser }

func (s *CondEffectContext) AllPEffect() []IPEffectContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPEffectContext)(nil)).Elem())
	var tst = make([]IPEffectContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPEffectContext)
		}
	}

	return tst
}

func (s *CondEffectContext) PEffect(i int) IPEffectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPEffectContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPEffectContext)
}

func (s *CondEffectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CondEffectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CondEffectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.EnterCondEffect(s)
	}
}

func (s *CondEffectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.ExitCondEffect(s)
	}
}

func (p *PddlParser) CondEffect() (localctx ICondEffectContext) {
	this := p
	_ = this

	localctx = NewCondEffectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, PddlParserRULE_condEffect)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(578)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 50, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(568)
			p.Match(PddlParserT__0)
		}
		{
			p.SetState(569)
			p.Match(PddlParserT__17)
		}
		p.SetState(573)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PddlParserT__0 {
			{
				p.SetState(570)
				p.PEffect()
			}

			p.SetState(575)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(576)
			p.Match(PddlParserT__2)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(577)
			p.PEffect()
		}

	}

	return localctx
}

// IBinaryOpContext is an interface to support dynamic dispatch.
type IBinaryOpContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBinaryOpContext differentiates from other interfaces.
	IsBinaryOpContext()
}

type BinaryOpContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBinaryOpContext() *BinaryOpContext {
	var p = new(BinaryOpContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PddlParserRULE_binaryOp
	return p
}

func (*BinaryOpContext) IsBinaryOpContext() {}

func NewBinaryOpContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BinaryOpContext {
	var p = new(BinaryOpContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PddlParserRULE_binaryOp

	return p
}

func (s *BinaryOpContext) GetParser() antlr.Parser { return s.parser }
func (s *BinaryOpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BinaryOpContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BinaryOpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.EnterBinaryOp(s)
	}
}

func (s *BinaryOpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.ExitBinaryOp(s)
	}
}

func (p *PddlParser) BinaryOp() (localctx IBinaryOpContext) {
	this := p
	_ = this

	localctx = NewBinaryOpContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, PddlParserRULE_binaryOp)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(580)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-7)&-(0x1f+1)) == 0 && ((1<<uint((_la-7)))&((1<<(PddlParserT__6-7))|(1<<(PddlParserT__34-7))|(1<<(PddlParserT__35-7))|(1<<(PddlParserT__36-7)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IBinaryCompContext is an interface to support dynamic dispatch.
type IBinaryCompContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBinaryCompContext differentiates from other interfaces.
	IsBinaryCompContext()
}

type BinaryCompContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBinaryCompContext() *BinaryCompContext {
	var p = new(BinaryCompContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PddlParserRULE_binaryComp
	return p
}

func (*BinaryCompContext) IsBinaryCompContext() {}

func NewBinaryCompContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BinaryCompContext {
	var p = new(BinaryCompContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PddlParserRULE_binaryComp

	return p
}

func (s *BinaryCompContext) GetParser() antlr.Parser { return s.parser }
func (s *BinaryCompContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BinaryCompContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BinaryCompContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.EnterBinaryComp(s)
	}
}

func (s *BinaryCompContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.ExitBinaryComp(s)
	}
}

func (p *PddlParser) BinaryComp() (localctx IBinaryCompContext) {
	this := p
	_ = this

	localctx = NewBinaryCompContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, PddlParserRULE_binaryComp)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(582)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-38)&-(0x1f+1)) == 0 && ((1<<uint((_la-38)))&((1<<(PddlParserT__37-38))|(1<<(PddlParserT__38-38))|(1<<(PddlParserT__39-38))|(1<<(PddlParserT__40-38))|(1<<(PddlParserT__41-38)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IAssignOpContext is an interface to support dynamic dispatch.
type IAssignOpContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignOpContext differentiates from other interfaces.
	IsAssignOpContext()
}

type AssignOpContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignOpContext() *AssignOpContext {
	var p = new(AssignOpContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PddlParserRULE_assignOp
	return p
}

func (*AssignOpContext) IsAssignOpContext() {}

func NewAssignOpContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignOpContext {
	var p = new(AssignOpContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PddlParserRULE_assignOp

	return p
}

func (s *AssignOpContext) GetParser() antlr.Parser { return s.parser }
func (s *AssignOpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignOpContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignOpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.EnterAssignOp(s)
	}
}

func (s *AssignOpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.ExitAssignOp(s)
	}
}

func (p *PddlParser) AssignOp() (localctx IAssignOpContext) {
	this := p
	_ = this

	localctx = NewAssignOpContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, PddlParserRULE_assignOp)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(584)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-43)&-(0x1f+1)) == 0 && ((1<<uint((_la-43)))&((1<<(PddlParserT__42-43))|(1<<(PddlParserT__43-43))|(1<<(PddlParserT__44-43))|(1<<(PddlParserT__45-43))|(1<<(PddlParserT__46-43)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IDurationConstraintContext is an interface to support dynamic dispatch.
type IDurationConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDurationConstraintContext differentiates from other interfaces.
	IsDurationConstraintContext()
}

type DurationConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDurationConstraintContext() *DurationConstraintContext {
	var p = new(DurationConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PddlParserRULE_durationConstraint
	return p
}

func (*DurationConstraintContext) IsDurationConstraintContext() {}

func NewDurationConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DurationConstraintContext {
	var p = new(DurationConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PddlParserRULE_durationConstraint

	return p
}

func (s *DurationConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *DurationConstraintContext) AllSimpleDurationConstraint() []ISimpleDurationConstraintContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISimpleDurationConstraintContext)(nil)).Elem())
	var tst = make([]ISimpleDurationConstraintContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISimpleDurationConstraintContext)
		}
	}

	return tst
}

func (s *DurationConstraintContext) SimpleDurationConstraint(i int) ISimpleDurationConstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleDurationConstraintContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISimpleDurationConstraintContext)
}

func (s *DurationConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DurationConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DurationConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.EnterDurationConstraint(s)
	}
}

func (s *DurationConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.ExitDurationConstraint(s)
	}
}

func (p *PddlParser) DurationConstraint() (localctx IDurationConstraintContext) {
	this := p
	_ = this

	localctx = NewDurationConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, PddlParserRULE_durationConstraint)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(598)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 52, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(586)
			p.Match(PddlParserT__0)
		}
		{
			p.SetState(587)
			p.Match(PddlParserT__17)
		}
		p.SetState(589)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == PddlParserT__0 {
			{
				p.SetState(588)
				p.SimpleDurationConstraint()
			}

			p.SetState(591)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(593)
			p.Match(PddlParserT__2)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(595)
			p.Match(PddlParserT__0)
		}
		{
			p.SetState(596)
			p.Match(PddlParserT__2)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(597)
			p.SimpleDurationConstraint()
		}

	}

	return localctx
}

// ISimpleDurationConstraintContext is an interface to support dynamic dispatch.
type ISimpleDurationConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimpleDurationConstraintContext differentiates from other interfaces.
	IsSimpleDurationConstraintContext()
}

type SimpleDurationConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleDurationConstraintContext() *SimpleDurationConstraintContext {
	var p = new(SimpleDurationConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PddlParserRULE_simpleDurationConstraint
	return p
}

func (*SimpleDurationConstraintContext) IsSimpleDurationConstraintContext() {}

func NewSimpleDurationConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleDurationConstraintContext {
	var p = new(SimpleDurationConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PddlParserRULE_simpleDurationConstraint

	return p
}

func (s *SimpleDurationConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleDurationConstraintContext) DurOp() IDurOpContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDurOpContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDurOpContext)
}

func (s *SimpleDurationConstraintContext) DurValue() IDurValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDurValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDurValueContext)
}

func (s *SimpleDurationConstraintContext) TimeSpecifier() ITimeSpecifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITimeSpecifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITimeSpecifierContext)
}

func (s *SimpleDurationConstraintContext) SimpleDurationConstraint() ISimpleDurationConstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleDurationConstraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimpleDurationConstraintContext)
}

func (s *SimpleDurationConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleDurationConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleDurationConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.EnterSimpleDurationConstraint(s)
	}
}

func (s *SimpleDurationConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.ExitSimpleDurationConstraint(s)
	}
}

func (p *PddlParser) SimpleDurationConstraint() (localctx ISimpleDurationConstraintContext) {
	this := p
	_ = this

	localctx = NewSimpleDurationConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, PddlParserRULE_simpleDurationConstraint)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(612)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 53, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(600)
			p.Match(PddlParserT__0)
		}
		{
			p.SetState(601)
			p.DurOp()
		}
		{
			p.SetState(602)
			p.Match(PddlParserT__47)
		}
		{
			p.SetState(603)
			p.DurValue()
		}
		{
			p.SetState(604)
			p.Match(PddlParserT__2)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(606)
			p.Match(PddlParserT__0)
		}
		{
			p.SetState(607)
			p.Match(PddlParserT__27)
		}
		{
			p.SetState(608)
			p.TimeSpecifier()
		}
		{
			p.SetState(609)
			p.SimpleDurationConstraint()
		}
		{
			p.SetState(610)
			p.Match(PddlParserT__2)
		}

	}

	return localctx
}

// IDurOpContext is an interface to support dynamic dispatch.
type IDurOpContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDurOpContext differentiates from other interfaces.
	IsDurOpContext()
}

type DurOpContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDurOpContext() *DurOpContext {
	var p = new(DurOpContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PddlParserRULE_durOp
	return p
}

func (*DurOpContext) IsDurOpContext() {}

func NewDurOpContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DurOpContext {
	var p = new(DurOpContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PddlParserRULE_durOp

	return p
}

func (s *DurOpContext) GetParser() antlr.Parser { return s.parser }
func (s *DurOpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DurOpContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DurOpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.EnterDurOp(s)
	}
}

func (s *DurOpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.ExitDurOp(s)
	}
}

func (p *PddlParser) DurOp() (localctx IDurOpContext) {
	this := p
	_ = this

	localctx = NewDurOpContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, PddlParserRULE_durOp)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(614)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-40)&-(0x1f+1)) == 0 && ((1<<uint((_la-40)))&((1<<(PddlParserT__39-40))|(1<<(PddlParserT__40-40))|(1<<(PddlParserT__41-40)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IDurValueContext is an interface to support dynamic dispatch.
type IDurValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDurValueContext differentiates from other interfaces.
	IsDurValueContext()
}

type DurValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDurValueContext() *DurValueContext {
	var p = new(DurValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PddlParserRULE_durValue
	return p
}

func (*DurValueContext) IsDurValueContext() {}

func NewDurValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DurValueContext {
	var p = new(DurValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PddlParserRULE_durValue

	return p
}

func (s *DurValueContext) GetParser() antlr.Parser { return s.parser }

func (s *DurValueContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(PddlParserNUMBER, 0)
}

func (s *DurValueContext) FExp() IFExpContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFExpContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFExpContext)
}

func (s *DurValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DurValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DurValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.EnterDurValue(s)
	}
}

func (s *DurValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.ExitDurValue(s)
	}
}

func (p *PddlParser) DurValue() (localctx IDurValueContext) {
	this := p
	_ = this

	localctx = NewDurValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, PddlParserRULE_durValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(618)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 54, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(616)
			p.Match(PddlParserNUMBER)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(617)
			p.FExp()
		}

	}

	return localctx
}

// IDaEffectContext is an interface to support dynamic dispatch.
type IDaEffectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDaEffectContext differentiates from other interfaces.
	IsDaEffectContext()
}

type DaEffectContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDaEffectContext() *DaEffectContext {
	var p = new(DaEffectContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PddlParserRULE_daEffect
	return p
}

func (*DaEffectContext) IsDaEffectContext() {}

func NewDaEffectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DaEffectContext {
	var p = new(DaEffectContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PddlParserRULE_daEffect

	return p
}

func (s *DaEffectContext) GetParser() antlr.Parser { return s.parser }

func (s *DaEffectContext) AllDaEffect() []IDaEffectContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDaEffectContext)(nil)).Elem())
	var tst = make([]IDaEffectContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDaEffectContext)
		}
	}

	return tst
}

func (s *DaEffectContext) DaEffect(i int) IDaEffectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDaEffectContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDaEffectContext)
}

func (s *DaEffectContext) TimedEffect() ITimedEffectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITimedEffectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITimedEffectContext)
}

func (s *DaEffectContext) TypedVariableList() ITypedVariableListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypedVariableListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypedVariableListContext)
}

func (s *DaEffectContext) DaGD() IDaGDContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDaGDContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDaGDContext)
}

func (s *DaEffectContext) AssignOp() IAssignOpContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignOpContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignOpContext)
}

func (s *DaEffectContext) FHead() IFHeadContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFHeadContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFHeadContext)
}

func (s *DaEffectContext) FExpDA() IFExpDAContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFExpDAContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFExpDAContext)
}

func (s *DaEffectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DaEffectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DaEffectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.EnterDaEffect(s)
	}
}

func (s *DaEffectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.ExitDaEffect(s)
	}
}

func (p *PddlParser) DaEffect() (localctx IDaEffectContext) {
	this := p
	_ = this

	localctx = NewDaEffectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, PddlParserRULE_daEffect)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(650)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 56, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(620)
			p.Match(PddlParserT__0)
		}
		{
			p.SetState(621)
			p.Match(PddlParserT__17)
		}
		p.SetState(625)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PddlParserT__0 {
			{
				p.SetState(622)
				p.DaEffect()
			}

			p.SetState(627)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(628)
			p.Match(PddlParserT__2)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(629)
			p.TimedEffect()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(630)
			p.Match(PddlParserT__0)
		}
		{
			p.SetState(631)
			p.Match(PddlParserT__22)
		}
		{
			p.SetState(632)
			p.Match(PddlParserT__0)
		}
		{
			p.SetState(633)
			p.TypedVariableList()
		}
		{
			p.SetState(634)
			p.Match(PddlParserT__2)
		}
		{
			p.SetState(635)
			p.DaEffect()
		}
		{
			p.SetState(636)
			p.Match(PddlParserT__2)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(638)
			p.Match(PddlParserT__0)
		}
		{
			p.SetState(639)
			p.Match(PddlParserT__33)
		}
		{
			p.SetState(640)
			p.DaGD()
		}
		{
			p.SetState(641)
			p.TimedEffect()
		}
		{
			p.SetState(642)
			p.Match(PddlParserT__2)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(644)
			p.Match(PddlParserT__0)
		}
		{
			p.SetState(645)
			p.AssignOp()
		}
		{
			p.SetState(646)
			p.FHead()
		}
		{
			p.SetState(647)
			p.FExpDA()
		}
		{
			p.SetState(648)
			p.Match(PddlParserT__2)
		}

	}

	return localctx
}

// ITimedEffectContext is an interface to support dynamic dispatch.
type ITimedEffectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTimedEffectContext differentiates from other interfaces.
	IsTimedEffectContext()
}

type TimedEffectContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTimedEffectContext() *TimedEffectContext {
	var p = new(TimedEffectContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PddlParserRULE_timedEffect
	return p
}

func (*TimedEffectContext) IsTimedEffectContext() {}

func NewTimedEffectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TimedEffectContext {
	var p = new(TimedEffectContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PddlParserRULE_timedEffect

	return p
}

func (s *TimedEffectContext) GetParser() antlr.Parser { return s.parser }

func (s *TimedEffectContext) TimeSpecifier() ITimeSpecifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITimeSpecifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITimeSpecifierContext)
}

func (s *TimedEffectContext) DaEffect() IDaEffectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDaEffectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDaEffectContext)
}

func (s *TimedEffectContext) FAssignDA() IFAssignDAContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFAssignDAContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFAssignDAContext)
}

func (s *TimedEffectContext) AssignOp() IAssignOpContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignOpContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignOpContext)
}

func (s *TimedEffectContext) FHead() IFHeadContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFHeadContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFHeadContext)
}

func (s *TimedEffectContext) FExp() IFExpContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFExpContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFExpContext)
}

func (s *TimedEffectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimedEffectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TimedEffectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.EnterTimedEffect(s)
	}
}

func (s *TimedEffectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.ExitTimedEffect(s)
	}
}

func (p *PddlParser) TimedEffect() (localctx ITimedEffectContext) {
	this := p
	_ = this

	localctx = NewTimedEffectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, PddlParserRULE_timedEffect)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(670)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 57, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(652)
			p.Match(PddlParserT__0)
		}
		{
			p.SetState(653)
			p.Match(PddlParserT__27)
		}
		{
			p.SetState(654)
			p.TimeSpecifier()
		}
		{
			p.SetState(655)
			p.DaEffect()
		}
		{
			p.SetState(656)
			p.Match(PddlParserT__2)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(658)
			p.Match(PddlParserT__0)
		}
		{
			p.SetState(659)
			p.Match(PddlParserT__27)
		}
		{
			p.SetState(660)
			p.TimeSpecifier()
		}
		{
			p.SetState(661)
			p.FAssignDA()
		}
		{
			p.SetState(662)
			p.Match(PddlParserT__2)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(664)
			p.Match(PddlParserT__0)
		}
		{
			p.SetState(665)
			p.AssignOp()
		}
		{
			p.SetState(666)
			p.FHead()
		}
		{
			p.SetState(667)
			p.FExp()
		}
		{
			p.SetState(668)
			p.Match(PddlParserT__2)
		}

	}

	return localctx
}

// IFAssignDAContext is an interface to support dynamic dispatch.
type IFAssignDAContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFAssignDAContext differentiates from other interfaces.
	IsFAssignDAContext()
}

type FAssignDAContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFAssignDAContext() *FAssignDAContext {
	var p = new(FAssignDAContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PddlParserRULE_fAssignDA
	return p
}

func (*FAssignDAContext) IsFAssignDAContext() {}

func NewFAssignDAContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FAssignDAContext {
	var p = new(FAssignDAContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PddlParserRULE_fAssignDA

	return p
}

func (s *FAssignDAContext) GetParser() antlr.Parser { return s.parser }

func (s *FAssignDAContext) AssignOp() IAssignOpContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignOpContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignOpContext)
}

func (s *FAssignDAContext) FHead() IFHeadContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFHeadContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFHeadContext)
}

func (s *FAssignDAContext) FExpDA() IFExpDAContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFExpDAContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFExpDAContext)
}

func (s *FAssignDAContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FAssignDAContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FAssignDAContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.EnterFAssignDA(s)
	}
}

func (s *FAssignDAContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.ExitFAssignDA(s)
	}
}

func (p *PddlParser) FAssignDA() (localctx IFAssignDAContext) {
	this := p
	_ = this

	localctx = NewFAssignDAContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, PddlParserRULE_fAssignDA)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(672)
		p.Match(PddlParserT__0)
	}
	{
		p.SetState(673)
		p.AssignOp()
	}
	{
		p.SetState(674)
		p.FHead()
	}
	{
		p.SetState(675)
		p.FExpDA()
	}
	{
		p.SetState(676)
		p.Match(PddlParserT__2)
	}

	return localctx
}

// IFExpDAContext is an interface to support dynamic dispatch.
type IFExpDAContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFExpDAContext differentiates from other interfaces.
	IsFExpDAContext()
}

type FExpDAContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFExpDAContext() *FExpDAContext {
	var p = new(FExpDAContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PddlParserRULE_fExpDA
	return p
}

func (*FExpDAContext) IsFExpDAContext() {}

func NewFExpDAContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FExpDAContext {
	var p = new(FExpDAContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PddlParserRULE_fExpDA

	return p
}

func (s *FExpDAContext) GetParser() antlr.Parser { return s.parser }

func (s *FExpDAContext) BinaryOp() IBinaryOpContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBinaryOpContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBinaryOpContext)
}

func (s *FExpDAContext) AllFExpDA() []IFExpDAContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFExpDAContext)(nil)).Elem())
	var tst = make([]IFExpDAContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFExpDAContext)
		}
	}

	return tst
}

func (s *FExpDAContext) FExpDA(i int) IFExpDAContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFExpDAContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFExpDAContext)
}

func (s *FExpDAContext) FExp() IFExpContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFExpContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFExpContext)
}

func (s *FExpDAContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FExpDAContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FExpDAContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.EnterFExpDA(s)
	}
}

func (s *FExpDAContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.ExitFExpDA(s)
	}
}

func (p *PddlParser) FExpDA() (localctx IFExpDAContext) {
	this := p
	_ = this

	localctx = NewFExpDAContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, PddlParserRULE_fExpDA)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(691)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 59, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(678)
			p.Match(PddlParserT__0)
		}
		p.SetState(685)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 58, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(679)
				p.BinaryOp()
			}
			{
				p.SetState(680)
				p.FExpDA()
			}
			{
				p.SetState(681)
				p.FExpDA()
			}

		case 2:
			{
				p.SetState(683)
				p.Match(PddlParserT__6)
			}
			{
				p.SetState(684)
				p.FExpDA()
			}

		}
		{
			p.SetState(687)
			p.Match(PddlParserT__2)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(689)
			p.Match(PddlParserT__47)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(690)
			p.FExp()
		}

	}

	return localctx
}

// IProblemContext is an interface to support dynamic dispatch.
type IProblemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProblemContext differentiates from other interfaces.
	IsProblemContext()
}

type ProblemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProblemContext() *ProblemContext {
	var p = new(ProblemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PddlParserRULE_problem
	return p
}

func (*ProblemContext) IsProblemContext() {}

func NewProblemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProblemContext {
	var p = new(ProblemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PddlParserRULE_problem

	return p
}

func (s *ProblemContext) GetParser() antlr.Parser { return s.parser }

func (s *ProblemContext) ProblemDecl() IProblemDeclContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProblemDeclContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProblemDeclContext)
}

func (s *ProblemContext) ProblemDomain() IProblemDomainContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProblemDomainContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProblemDomainContext)
}

func (s *ProblemContext) Init_() IInit_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInit_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInit_Context)
}

func (s *ProblemContext) Goal() IGoalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGoalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGoalContext)
}

func (s *ProblemContext) RequireDef() IRequireDefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRequireDefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRequireDefContext)
}

func (s *ProblemContext) ObjectDecl() IObjectDeclContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectDeclContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectDeclContext)
}

func (s *ProblemContext) ProbConstraints() IProbConstraintsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProbConstraintsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProbConstraintsContext)
}

func (s *ProblemContext) MetricSpec() IMetricSpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMetricSpecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMetricSpecContext)
}

func (s *ProblemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProblemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProblemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.EnterProblem(s)
	}
}

func (s *ProblemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.ExitProblem(s)
	}
}

func (p *PddlParser) Problem() (localctx IProblemContext) {
	this := p
	_ = this

	localctx = NewProblemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, PddlParserRULE_problem)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(693)
		p.Match(PddlParserT__0)
	}
	{
		p.SetState(694)
		p.Match(PddlParserT__1)
	}
	{
		p.SetState(695)
		p.ProblemDecl()
	}
	{
		p.SetState(696)
		p.ProblemDomain()
	}
	p.SetState(698)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 60, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(697)
			p.RequireDef()
		}

	}
	p.SetState(701)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 61, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(700)
			p.ObjectDecl()
		}

	}
	{
		p.SetState(703)
		p.Init_()
	}
	{
		p.SetState(704)
		p.Goal()
	}
	p.SetState(706)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 62, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(705)
			p.ProbConstraints()
		}

	}
	p.SetState(709)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PddlParserT__0 {
		{
			p.SetState(708)
			p.MetricSpec()
		}

	}

	return localctx
}

// IProblemDeclContext is an interface to support dynamic dispatch.
type IProblemDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProblemDeclContext differentiates from other interfaces.
	IsProblemDeclContext()
}

type ProblemDeclContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProblemDeclContext() *ProblemDeclContext {
	var p = new(ProblemDeclContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PddlParserRULE_problemDecl
	return p
}

func (*ProblemDeclContext) IsProblemDeclContext() {}

func NewProblemDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProblemDeclContext {
	var p = new(ProblemDeclContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PddlParserRULE_problemDecl

	return p
}

func (s *ProblemDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *ProblemDeclContext) NAME() antlr.TerminalNode {
	return s.GetToken(PddlParserNAME, 0)
}

func (s *ProblemDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProblemDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProblemDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.EnterProblemDecl(s)
	}
}

func (s *ProblemDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.ExitProblemDecl(s)
	}
}

func (p *PddlParser) ProblemDecl() (localctx IProblemDeclContext) {
	this := p
	_ = this

	localctx = NewProblemDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, PddlParserRULE_problemDecl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(711)
		p.Match(PddlParserT__0)
	}
	{
		p.SetState(712)
		p.Match(PddlParserT__48)
	}
	{
		p.SetState(713)
		p.Match(PddlParserNAME)
	}
	{
		p.SetState(714)
		p.Match(PddlParserT__2)
	}

	return localctx
}

// IProblemDomainContext is an interface to support dynamic dispatch.
type IProblemDomainContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProblemDomainContext differentiates from other interfaces.
	IsProblemDomainContext()
}

type ProblemDomainContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProblemDomainContext() *ProblemDomainContext {
	var p = new(ProblemDomainContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PddlParserRULE_problemDomain
	return p
}

func (*ProblemDomainContext) IsProblemDomainContext() {}

func NewProblemDomainContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProblemDomainContext {
	var p = new(ProblemDomainContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PddlParserRULE_problemDomain

	return p
}

func (s *ProblemDomainContext) GetParser() antlr.Parser { return s.parser }

func (s *ProblemDomainContext) NAME() antlr.TerminalNode {
	return s.GetToken(PddlParserNAME, 0)
}

func (s *ProblemDomainContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProblemDomainContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProblemDomainContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.EnterProblemDomain(s)
	}
}

func (s *ProblemDomainContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.ExitProblemDomain(s)
	}
}

func (p *PddlParser) ProblemDomain() (localctx IProblemDomainContext) {
	this := p
	_ = this

	localctx = NewProblemDomainContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, PddlParserRULE_problemDomain)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(716)
		p.Match(PddlParserT__0)
	}
	{
		p.SetState(717)
		p.Match(PddlParserT__49)
	}
	{
		p.SetState(718)
		p.Match(PddlParserNAME)
	}
	{
		p.SetState(719)
		p.Match(PddlParserT__2)
	}

	return localctx
}

// IObjectDeclContext is an interface to support dynamic dispatch.
type IObjectDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObjectDeclContext differentiates from other interfaces.
	IsObjectDeclContext()
}

type ObjectDeclContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectDeclContext() *ObjectDeclContext {
	var p = new(ObjectDeclContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PddlParserRULE_objectDecl
	return p
}

func (*ObjectDeclContext) IsObjectDeclContext() {}

func NewObjectDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectDeclContext {
	var p = new(ObjectDeclContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PddlParserRULE_objectDecl

	return p
}

func (s *ObjectDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectDeclContext) TypedNameList() ITypedNameListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypedNameListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypedNameListContext)
}

func (s *ObjectDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.EnterObjectDecl(s)
	}
}

func (s *ObjectDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.ExitObjectDecl(s)
	}
}

func (p *PddlParser) ObjectDecl() (localctx IObjectDeclContext) {
	this := p
	_ = this

	localctx = NewObjectDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, PddlParserRULE_objectDecl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(721)
		p.Match(PddlParserT__0)
	}
	{
		p.SetState(722)
		p.Match(PddlParserT__50)
	}
	{
		p.SetState(723)
		p.TypedNameList()
	}
	{
		p.SetState(724)
		p.Match(PddlParserT__2)
	}

	return localctx
}

// IInit_Context is an interface to support dynamic dispatch.
type IInit_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInit_Context differentiates from other interfaces.
	IsInit_Context()
}

type Init_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInit_Context() *Init_Context {
	var p = new(Init_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PddlParserRULE_init_
	return p
}

func (*Init_Context) IsInit_Context() {}

func NewInit_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Init_Context {
	var p = new(Init_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PddlParserRULE_init_

	return p
}

func (s *Init_Context) GetParser() antlr.Parser { return s.parser }

func (s *Init_Context) AllInitEl() []IInitElContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInitElContext)(nil)).Elem())
	var tst = make([]IInitElContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInitElContext)
		}
	}

	return tst
}

func (s *Init_Context) InitEl(i int) IInitElContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInitElContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInitElContext)
}

func (s *Init_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Init_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Init_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.EnterInit_(s)
	}
}

func (s *Init_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.ExitInit_(s)
	}
}

func (p *PddlParser) Init_() (localctx IInit_Context) {
	this := p
	_ = this

	localctx = NewInit_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, PddlParserRULE_init_)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(726)
		p.Match(PddlParserT__0)
	}
	{
		p.SetState(727)
		p.Match(PddlParserT__51)
	}
	p.SetState(731)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PddlParserT__0 {
		{
			p.SetState(728)
			p.InitEl()
		}

		p.SetState(733)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(734)
		p.Match(PddlParserT__2)
	}

	return localctx
}

// IInitElContext is an interface to support dynamic dispatch.
type IInitElContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInitElContext differentiates from other interfaces.
	IsInitElContext()
}

type InitElContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInitElContext() *InitElContext {
	var p = new(InitElContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PddlParserRULE_initEl
	return p
}

func (*InitElContext) IsInitElContext() {}

func NewInitElContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InitElContext {
	var p = new(InitElContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PddlParserRULE_initEl

	return p
}

func (s *InitElContext) GetParser() antlr.Parser { return s.parser }

func (s *InitElContext) NameLiteral() INameLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameLiteralContext)
}

func (s *InitElContext) FHead() IFHeadContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFHeadContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFHeadContext)
}

func (s *InitElContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(PddlParserNUMBER, 0)
}

func (s *InitElContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InitElContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InitElContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.EnterInitEl(s)
	}
}

func (s *InitElContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.ExitInitEl(s)
	}
}

func (p *PddlParser) InitEl() (localctx IInitElContext) {
	this := p
	_ = this

	localctx = NewInitElContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, PddlParserRULE_initEl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(749)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 65, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(736)
			p.NameLiteral()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(737)
			p.Match(PddlParserT__0)
		}
		{
			p.SetState(738)
			p.Match(PddlParserT__39)
		}
		{
			p.SetState(739)
			p.FHead()
		}
		{
			p.SetState(740)
			p.Match(PddlParserNUMBER)
		}
		{
			p.SetState(741)
			p.Match(PddlParserT__2)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(743)
			p.Match(PddlParserT__0)
		}
		{
			p.SetState(744)
			p.Match(PddlParserT__27)
		}
		{
			p.SetState(745)
			p.Match(PddlParserNUMBER)
		}
		{
			p.SetState(746)
			p.NameLiteral()
		}
		{
			p.SetState(747)
			p.Match(PddlParserT__2)
		}

	}

	return localctx
}

// INameLiteralContext is an interface to support dynamic dispatch.
type INameLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNameLiteralContext differentiates from other interfaces.
	IsNameLiteralContext()
}

type NameLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNameLiteralContext() *NameLiteralContext {
	var p = new(NameLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PddlParserRULE_nameLiteral
	return p
}

func (*NameLiteralContext) IsNameLiteralContext() {}

func NewNameLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NameLiteralContext {
	var p = new(NameLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PddlParserRULE_nameLiteral

	return p
}

func (s *NameLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *NameLiteralContext) AtomicNameFormula() IAtomicNameFormulaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomicNameFormulaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtomicNameFormulaContext)
}

func (s *NameLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NameLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NameLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.EnterNameLiteral(s)
	}
}

func (s *NameLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.ExitNameLiteral(s)
	}
}

func (p *PddlParser) NameLiteral() (localctx INameLiteralContext) {
	this := p
	_ = this

	localctx = NewNameLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, PddlParserRULE_nameLiteral)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(757)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 66, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(751)
			p.AtomicNameFormula()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(752)
			p.Match(PddlParserT__0)
		}
		{
			p.SetState(753)
			p.Match(PddlParserT__19)
		}
		{
			p.SetState(754)
			p.AtomicNameFormula()
		}
		{
			p.SetState(755)
			p.Match(PddlParserT__2)
		}

	}

	return localctx
}

// IAtomicNameFormulaContext is an interface to support dynamic dispatch.
type IAtomicNameFormulaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtomicNameFormulaContext differentiates from other interfaces.
	IsAtomicNameFormulaContext()
}

type AtomicNameFormulaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtomicNameFormulaContext() *AtomicNameFormulaContext {
	var p = new(AtomicNameFormulaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PddlParserRULE_atomicNameFormula
	return p
}

func (*AtomicNameFormulaContext) IsAtomicNameFormulaContext() {}

func NewAtomicNameFormulaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtomicNameFormulaContext {
	var p = new(AtomicNameFormulaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PddlParserRULE_atomicNameFormula

	return p
}

func (s *AtomicNameFormulaContext) GetParser() antlr.Parser { return s.parser }

func (s *AtomicNameFormulaContext) Predicate() IPredicateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPredicateContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *AtomicNameFormulaContext) AllNAME() []antlr.TerminalNode {
	return s.GetTokens(PddlParserNAME)
}

func (s *AtomicNameFormulaContext) NAME(i int) antlr.TerminalNode {
	return s.GetToken(PddlParserNAME, i)
}

func (s *AtomicNameFormulaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtomicNameFormulaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AtomicNameFormulaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.EnterAtomicNameFormula(s)
	}
}

func (s *AtomicNameFormulaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.ExitAtomicNameFormula(s)
	}
}

func (p *PddlParser) AtomicNameFormula() (localctx IAtomicNameFormulaContext) {
	this := p
	_ = this

	localctx = NewAtomicNameFormulaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, PddlParserRULE_atomicNameFormula)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(759)
		p.Match(PddlParserT__0)
	}
	{
		p.SetState(760)
		p.Predicate()
	}
	p.SetState(764)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PddlParserNAME {
		{
			p.SetState(761)
			p.Match(PddlParserNAME)
		}

		p.SetState(766)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(767)
		p.Match(PddlParserT__2)
	}

	return localctx
}

// IGoalContext is an interface to support dynamic dispatch.
type IGoalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGoalContext differentiates from other interfaces.
	IsGoalContext()
}

type GoalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGoalContext() *GoalContext {
	var p = new(GoalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PddlParserRULE_goal
	return p
}

func (*GoalContext) IsGoalContext() {}

func NewGoalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GoalContext {
	var p = new(GoalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PddlParserRULE_goal

	return p
}

func (s *GoalContext) GetParser() antlr.Parser { return s.parser }

func (s *GoalContext) GoalDesc() IGoalDescContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGoalDescContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGoalDescContext)
}

func (s *GoalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GoalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GoalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.EnterGoal(s)
	}
}

func (s *GoalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.ExitGoal(s)
	}
}

func (p *PddlParser) Goal() (localctx IGoalContext) {
	this := p
	_ = this

	localctx = NewGoalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, PddlParserRULE_goal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(769)
		p.Match(PddlParserT__0)
	}
	{
		p.SetState(770)
		p.Match(PddlParserT__52)
	}
	{
		p.SetState(771)
		p.GoalDesc()
	}
	{
		p.SetState(772)
		p.Match(PddlParserT__2)
	}

	return localctx
}

// IProbConstraintsContext is an interface to support dynamic dispatch.
type IProbConstraintsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProbConstraintsContext differentiates from other interfaces.
	IsProbConstraintsContext()
}

type ProbConstraintsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProbConstraintsContext() *ProbConstraintsContext {
	var p = new(ProbConstraintsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PddlParserRULE_probConstraints
	return p
}

func (*ProbConstraintsContext) IsProbConstraintsContext() {}

func NewProbConstraintsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProbConstraintsContext {
	var p = new(ProbConstraintsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PddlParserRULE_probConstraints

	return p
}

func (s *ProbConstraintsContext) GetParser() antlr.Parser { return s.parser }

func (s *ProbConstraintsContext) PrefConGD() IPrefConGDContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrefConGDContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrefConGDContext)
}

func (s *ProbConstraintsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProbConstraintsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProbConstraintsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.EnterProbConstraints(s)
	}
}

func (s *ProbConstraintsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.ExitProbConstraints(s)
	}
}

func (p *PddlParser) ProbConstraints() (localctx IProbConstraintsContext) {
	this := p
	_ = this

	localctx = NewProbConstraintsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, PddlParserRULE_probConstraints)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(774)
		p.Match(PddlParserT__0)
	}
	{
		p.SetState(775)
		p.Match(PddlParserT__12)
	}
	{
		p.SetState(776)
		p.PrefConGD()
	}
	{
		p.SetState(777)
		p.Match(PddlParserT__2)
	}

	return localctx
}

// IPrefConGDContext is an interface to support dynamic dispatch.
type IPrefConGDContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrefConGDContext differentiates from other interfaces.
	IsPrefConGDContext()
}

type PrefConGDContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrefConGDContext() *PrefConGDContext {
	var p = new(PrefConGDContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PddlParserRULE_prefConGD
	return p
}

func (*PrefConGDContext) IsPrefConGDContext() {}

func NewPrefConGDContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrefConGDContext {
	var p = new(PrefConGDContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PddlParserRULE_prefConGD

	return p
}

func (s *PrefConGDContext) GetParser() antlr.Parser { return s.parser }

func (s *PrefConGDContext) AllPrefConGD() []IPrefConGDContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPrefConGDContext)(nil)).Elem())
	var tst = make([]IPrefConGDContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPrefConGDContext)
		}
	}

	return tst
}

func (s *PrefConGDContext) PrefConGD(i int) IPrefConGDContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrefConGDContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPrefConGDContext)
}

func (s *PrefConGDContext) TypedVariableList() ITypedVariableListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypedVariableListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypedVariableListContext)
}

func (s *PrefConGDContext) ConGD() IConGDContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConGDContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConGDContext)
}

func (s *PrefConGDContext) NAME() antlr.TerminalNode {
	return s.GetToken(PddlParserNAME, 0)
}

func (s *PrefConGDContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrefConGDContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrefConGDContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.EnterPrefConGD(s)
	}
}

func (s *PrefConGDContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.ExitPrefConGD(s)
	}
}

func (p *PddlParser) PrefConGD() (localctx IPrefConGDContext) {
	this := p
	_ = this

	localctx = NewPrefConGDContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, PddlParserRULE_prefConGD)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(805)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 70, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(779)
			p.Match(PddlParserT__0)
		}
		{
			p.SetState(780)
			p.Match(PddlParserT__17)
		}
		p.SetState(784)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PddlParserT__0 {
			{
				p.SetState(781)
				p.PrefConGD()
			}

			p.SetState(786)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(787)
			p.Match(PddlParserT__2)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(788)
			p.Match(PddlParserT__0)
		}
		{
			p.SetState(789)
			p.Match(PddlParserT__22)
		}
		{
			p.SetState(790)
			p.Match(PddlParserT__0)
		}
		{
			p.SetState(791)
			p.TypedVariableList()
		}
		{
			p.SetState(792)
			p.Match(PddlParserT__2)
		}
		{
			p.SetState(793)
			p.PrefConGD()
		}
		{
			p.SetState(794)
			p.Match(PddlParserT__2)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(796)
			p.Match(PddlParserT__0)
		}
		{
			p.SetState(797)
			p.Match(PddlParserT__26)
		}
		p.SetState(799)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PddlParserNAME {
			{
				p.SetState(798)
				p.Match(PddlParserNAME)
			}

		}
		{
			p.SetState(801)
			p.ConGD()
		}
		{
			p.SetState(802)
			p.Match(PddlParserT__2)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(804)
			p.ConGD()
		}

	}

	return localctx
}

// IMetricSpecContext is an interface to support dynamic dispatch.
type IMetricSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMetricSpecContext differentiates from other interfaces.
	IsMetricSpecContext()
}

type MetricSpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMetricSpecContext() *MetricSpecContext {
	var p = new(MetricSpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PddlParserRULE_metricSpec
	return p
}

func (*MetricSpecContext) IsMetricSpecContext() {}

func NewMetricSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MetricSpecContext {
	var p = new(MetricSpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PddlParserRULE_metricSpec

	return p
}

func (s *MetricSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *MetricSpecContext) Optimization() IOptimizationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOptimizationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOptimizationContext)
}

func (s *MetricSpecContext) MetricFExp() IMetricFExpContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMetricFExpContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMetricFExpContext)
}

func (s *MetricSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MetricSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MetricSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.EnterMetricSpec(s)
	}
}

func (s *MetricSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.ExitMetricSpec(s)
	}
}

func (p *PddlParser) MetricSpec() (localctx IMetricSpecContext) {
	this := p
	_ = this

	localctx = NewMetricSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, PddlParserRULE_metricSpec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(807)
		p.Match(PddlParserT__0)
	}
	{
		p.SetState(808)
		p.Match(PddlParserT__53)
	}
	{
		p.SetState(809)
		p.Optimization()
	}
	{
		p.SetState(810)
		p.MetricFExp()
	}
	{
		p.SetState(811)
		p.Match(PddlParserT__2)
	}

	return localctx
}

// IOptimizationContext is an interface to support dynamic dispatch.
type IOptimizationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOptimizationContext differentiates from other interfaces.
	IsOptimizationContext()
}

type OptimizationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptimizationContext() *OptimizationContext {
	var p = new(OptimizationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PddlParserRULE_optimization
	return p
}

func (*OptimizationContext) IsOptimizationContext() {}

func NewOptimizationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptimizationContext {
	var p = new(OptimizationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PddlParserRULE_optimization

	return p
}

func (s *OptimizationContext) GetParser() antlr.Parser { return s.parser }
func (s *OptimizationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptimizationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptimizationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.EnterOptimization(s)
	}
}

func (s *OptimizationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.ExitOptimization(s)
	}
}

func (p *PddlParser) Optimization() (localctx IOptimizationContext) {
	this := p
	_ = this

	localctx = NewOptimizationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, PddlParserRULE_optimization)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(813)
		_la = p.GetTokenStream().LA(1)

		if !(_la == PddlParserT__54 || _la == PddlParserT__55) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IMetricFExpContext is an interface to support dynamic dispatch.
type IMetricFExpContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMetricFExpContext differentiates from other interfaces.
	IsMetricFExpContext()
}

type MetricFExpContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMetricFExpContext() *MetricFExpContext {
	var p = new(MetricFExpContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PddlParserRULE_metricFExp
	return p
}

func (*MetricFExpContext) IsMetricFExpContext() {}

func NewMetricFExpContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MetricFExpContext {
	var p = new(MetricFExpContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PddlParserRULE_metricFExp

	return p
}

func (s *MetricFExpContext) GetParser() antlr.Parser { return s.parser }

func (s *MetricFExpContext) BinaryOp() IBinaryOpContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBinaryOpContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBinaryOpContext)
}

func (s *MetricFExpContext) AllMetricFExp() []IMetricFExpContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMetricFExpContext)(nil)).Elem())
	var tst = make([]IMetricFExpContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMetricFExpContext)
		}
	}

	return tst
}

func (s *MetricFExpContext) MetricFExp(i int) IMetricFExpContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMetricFExpContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMetricFExpContext)
}

func (s *MetricFExpContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(PddlParserNUMBER, 0)
}

func (s *MetricFExpContext) FunctionSymbol() IFunctionSymbolContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionSymbolContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionSymbolContext)
}

func (s *MetricFExpContext) AllNAME() []antlr.TerminalNode {
	return s.GetTokens(PddlParserNAME)
}

func (s *MetricFExpContext) NAME(i int) antlr.TerminalNode {
	return s.GetToken(PddlParserNAME, i)
}

func (s *MetricFExpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MetricFExpContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MetricFExpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.EnterMetricFExp(s)
	}
}

func (s *MetricFExpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.ExitMetricFExp(s)
	}
}

func (p *PddlParser) MetricFExp() (localctx IMetricFExpContext) {
	this := p
	_ = this

	localctx = NewMetricFExpContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, PddlParserRULE_metricFExp)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(853)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 73, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(815)
			p.Match(PddlParserT__0)
		}
		{
			p.SetState(816)
			p.BinaryOp()
		}
		{
			p.SetState(817)
			p.MetricFExp()
		}
		{
			p.SetState(818)
			p.MetricFExp()
		}
		{
			p.SetState(819)
			p.Match(PddlParserT__2)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(821)
			p.Match(PddlParserT__0)
		}
		{
			p.SetState(822)
			_la = p.GetTokenStream().LA(1)

			if !(_la == PddlParserT__34 || _la == PddlParserT__36) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(823)
			p.MetricFExp()
		}
		p.SetState(825)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == PddlParserT__0 || _la == PddlParserT__56 || _la == PddlParserNAME || _la == PddlParserNUMBER {
			{
				p.SetState(824)
				p.MetricFExp()
			}

			p.SetState(827)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(829)
			p.Match(PddlParserT__2)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(831)
			p.Match(PddlParserT__0)
		}
		{
			p.SetState(832)
			p.Match(PddlParserT__6)
		}
		{
			p.SetState(833)
			p.MetricFExp()
		}
		{
			p.SetState(834)
			p.Match(PddlParserT__2)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(836)
			p.Match(PddlParserNUMBER)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(837)
			p.Match(PddlParserT__0)
		}
		{
			p.SetState(838)
			p.FunctionSymbol()
		}
		p.SetState(842)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PddlParserNAME {
			{
				p.SetState(839)
				p.Match(PddlParserNAME)
			}

			p.SetState(844)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(845)
			p.Match(PddlParserT__2)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(847)
			p.FunctionSymbol()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(848)
			p.Match(PddlParserT__56)
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(849)
			p.Match(PddlParserT__0)
		}
		{
			p.SetState(850)
			p.Match(PddlParserT__57)
		}
		{
			p.SetState(851)
			p.Match(PddlParserNAME)
		}
		{
			p.SetState(852)
			p.Match(PddlParserT__2)
		}

	}

	return localctx
}

// IConGDContext is an interface to support dynamic dispatch.
type IConGDContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConGDContext differentiates from other interfaces.
	IsConGDContext()
}

type ConGDContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConGDContext() *ConGDContext {
	var p = new(ConGDContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PddlParserRULE_conGD
	return p
}

func (*ConGDContext) IsConGDContext() {}

func NewConGDContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConGDContext {
	var p = new(ConGDContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PddlParserRULE_conGD

	return p
}

func (s *ConGDContext) GetParser() antlr.Parser { return s.parser }

func (s *ConGDContext) AllConGD() []IConGDContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConGDContext)(nil)).Elem())
	var tst = make([]IConGDContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConGDContext)
		}
	}

	return tst
}

func (s *ConGDContext) ConGD(i int) IConGDContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConGDContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConGDContext)
}

func (s *ConGDContext) TypedVariableList() ITypedVariableListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypedVariableListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypedVariableListContext)
}

func (s *ConGDContext) AllGoalDesc() []IGoalDescContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IGoalDescContext)(nil)).Elem())
	var tst = make([]IGoalDescContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IGoalDescContext)
		}
	}

	return tst
}

func (s *ConGDContext) GoalDesc(i int) IGoalDescContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGoalDescContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IGoalDescContext)
}

func (s *ConGDContext) AllNUMBER() []antlr.TerminalNode {
	return s.GetTokens(PddlParserNUMBER)
}

func (s *ConGDContext) NUMBER(i int) antlr.TerminalNode {
	return s.GetToken(PddlParserNUMBER, i)
}

func (s *ConGDContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConGDContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConGDContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.EnterConGD(s)
	}
}

func (s *ConGDContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PddlListener); ok {
		listenerT.ExitConGD(s)
	}
}

func (p *PddlParser) ConGD() (localctx IConGDContext) {
	this := p
	_ = this

	localctx = NewConGDContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, PddlParserRULE_conGD)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(931)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 75, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(855)
			p.Match(PddlParserT__0)
		}
		{
			p.SetState(856)
			p.Match(PddlParserT__17)
		}
		p.SetState(860)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PddlParserT__0 {
			{
				p.SetState(857)
				p.ConGD()
			}

			p.SetState(862)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(863)
			p.Match(PddlParserT__2)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(864)
			p.Match(PddlParserT__0)
		}
		{
			p.SetState(865)
			p.Match(PddlParserT__22)
		}
		{
			p.SetState(866)
			p.Match(PddlParserT__0)
		}
		{
			p.SetState(867)
			p.TypedVariableList()
		}
		{
			p.SetState(868)
			p.Match(PddlParserT__2)
		}
		{
			p.SetState(869)
			p.ConGD()
		}
		{
			p.SetState(870)
			p.Match(PddlParserT__2)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(872)
			p.Match(PddlParserT__0)
		}
		{
			p.SetState(873)
			p.Match(PddlParserT__27)
		}
		{
			p.SetState(874)
			p.Match(PddlParserT__30)
		}
		{
			p.SetState(875)
			p.GoalDesc()
		}
		{
			p.SetState(876)
			p.Match(PddlParserT__2)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(878)
			p.Match(PddlParserT__0)
		}
		{
			p.SetState(879)
			p.Match(PddlParserT__58)
		}
		{
			p.SetState(880)
			p.GoalDesc()
		}
		{
			p.SetState(881)
			p.Match(PddlParserT__2)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(883)
			p.Match(PddlParserT__0)
		}
		{
			p.SetState(884)
			p.Match(PddlParserT__59)
		}
		{
			p.SetState(885)
			p.GoalDesc()
		}
		{
			p.SetState(886)
			p.Match(PddlParserT__2)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(888)
			p.Match(PddlParserT__0)
		}
		{
			p.SetState(889)
			p.Match(PddlParserT__60)
		}
		{
			p.SetState(890)
			p.Match(PddlParserNUMBER)
		}
		{
			p.SetState(891)
			p.GoalDesc()
		}
		{
			p.SetState(892)
			p.Match(PddlParserT__2)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(894)
			p.Match(PddlParserT__0)
		}
		{
			p.SetState(895)
			p.Match(PddlParserT__61)
		}
		{
			p.SetState(896)
			p.GoalDesc()
		}
		{
			p.SetState(897)
			p.Match(PddlParserT__2)
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(899)
			p.Match(PddlParserT__0)
		}
		{
			p.SetState(900)
			p.Match(PddlParserT__62)
		}
		{
			p.SetState(901)
			p.GoalDesc()
		}
		{
			p.SetState(902)
			p.GoalDesc()
		}
		{
			p.SetState(903)
			p.Match(PddlParserT__2)
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(905)
			p.Match(PddlParserT__0)
		}
		{
			p.SetState(906)
			p.Match(PddlParserT__63)
		}
		{
			p.SetState(907)
			p.GoalDesc()
		}
		{
			p.SetState(908)
			p.GoalDesc()
		}
		{
			p.SetState(909)
			p.Match(PddlParserT__2)
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(911)
			p.Match(PddlParserT__0)
		}
		{
			p.SetState(912)
			p.Match(PddlParserT__64)
		}
		{
			p.SetState(913)
			p.Match(PddlParserNUMBER)
		}
		{
			p.SetState(914)
			p.GoalDesc()
		}
		{
			p.SetState(915)
			p.GoalDesc()
		}
		{
			p.SetState(916)
			p.Match(PddlParserT__2)
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(918)
			p.Match(PddlParserT__0)
		}
		{
			p.SetState(919)
			p.Match(PddlParserT__65)
		}
		{
			p.SetState(920)
			p.Match(PddlParserNUMBER)
		}
		{
			p.SetState(921)
			p.Match(PddlParserNUMBER)
		}
		{
			p.SetState(922)
			p.GoalDesc()
		}
		{
			p.SetState(923)
			p.Match(PddlParserT__2)
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(925)
			p.Match(PddlParserT__0)
		}
		{
			p.SetState(926)
			p.Match(PddlParserT__66)
		}
		{
			p.SetState(927)
			p.Match(PddlParserNUMBER)
		}
		{
			p.SetState(928)
			p.GoalDesc()
		}
		{
			p.SetState(929)
			p.Match(PddlParserT__2)
		}

	}

	return localctx
}
