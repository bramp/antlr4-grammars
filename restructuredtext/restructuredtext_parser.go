// Code generated from ReStructuredText.g4 by ANTLR 4.9.3. DO NOT EDIT.

package restructuredtext // ReStructuredText
import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 32, 810,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4,
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55,
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9,
	60, 3, 2, 3, 2, 6, 2, 123, 10, 2, 13, 2, 14, 2, 124, 3, 2, 3, 2, 3, 3,
	3, 3, 5, 3, 131, 10, 3, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 5, 4, 138, 10, 4,
	3, 5, 7, 5, 141, 10, 5, 12, 5, 14, 5, 144, 11, 5, 3, 5, 3, 5, 7, 5, 148,
	10, 5, 12, 5, 14, 5, 151, 11, 5, 3, 5, 3, 5, 5, 5, 155, 10, 5, 5, 5, 157,
	10, 5, 3, 6, 3, 6, 3, 6, 3, 7, 3, 7, 3, 7, 7, 7, 165, 10, 7, 12, 7, 14,
	7, 168, 11, 7, 3, 8, 6, 8, 171, 10, 8, 13, 8, 14, 8, 172, 3, 9, 3, 9, 3,
	10, 3, 10, 3, 10, 3, 10, 3, 10, 3, 10, 3, 11, 6, 11, 184, 10, 11, 13, 11,
	14, 11, 185, 3, 12, 3, 12, 3, 13, 3, 13, 5, 13, 192, 10, 13, 3, 13, 3,
	13, 5, 13, 196, 10, 13, 3, 13, 3, 13, 7, 13, 200, 10, 13, 12, 13, 14, 13,
	203, 11, 13, 3, 13, 7, 13, 206, 10, 13, 12, 13, 14, 13, 209, 11, 13, 3,
	14, 3, 14, 3, 14, 3, 14, 3, 14, 6, 14, 216, 10, 14, 13, 14, 14, 14, 217,
	3, 14, 5, 14, 221, 10, 14, 3, 14, 3, 14, 5, 14, 225, 10, 14, 3, 15, 3,
	15, 3, 15, 5, 15, 230, 10, 15, 3, 15, 7, 15, 233, 10, 15, 12, 15, 14, 15,
	236, 11, 15, 3, 16, 3, 16, 3, 16, 5, 16, 241, 10, 16, 3, 16, 7, 16, 244,
	10, 16, 12, 16, 14, 16, 247, 11, 16, 3, 16, 3, 16, 3, 16, 3, 16, 5, 16,
	253, 10, 16, 3, 16, 6, 16, 256, 10, 16, 13, 16, 14, 16, 257, 5, 16, 260,
	10, 16, 3, 17, 3, 17, 3, 17, 3, 17, 7, 17, 266, 10, 17, 12, 17, 14, 17,
	269, 11, 17, 3, 17, 5, 17, 272, 10, 17, 3, 18, 3, 18, 7, 18, 276, 10, 18,
	12, 18, 14, 18, 279, 11, 18, 3, 18, 3, 18, 7, 18, 283, 10, 18, 12, 18,
	14, 18, 286, 11, 18, 3, 18, 6, 18, 289, 10, 18, 13, 18, 14, 18, 290, 5,
	18, 293, 10, 18, 3, 19, 3, 19, 7, 19, 297, 10, 19, 12, 19, 14, 19, 300,
	11, 19, 3, 19, 3, 19, 6, 19, 304, 10, 19, 13, 19, 14, 19, 305, 3, 19, 3,
	19, 7, 19, 310, 10, 19, 12, 19, 14, 19, 313, 11, 19, 3, 20, 3, 20, 3, 21,
	3, 21, 3, 21, 6, 21, 320, 10, 21, 13, 21, 14, 21, 321, 3, 21, 3, 21, 7,
	21, 326, 10, 21, 12, 21, 14, 21, 329, 11, 21, 5, 21, 331, 10, 21, 3, 22,
	3, 22, 7, 22, 335, 10, 22, 12, 22, 14, 22, 338, 11, 22, 3, 23, 5, 23, 341,
	10, 23, 3, 23, 3, 23, 7, 23, 345, 10, 23, 12, 23, 14, 23, 348, 11, 23,
	3, 24, 3, 24, 5, 24, 352, 10, 24, 3, 25, 3, 25, 3, 25, 5, 25, 357, 10,
	25, 5, 25, 359, 10, 25, 3, 26, 3, 26, 3, 26, 3, 26, 5, 26, 365, 10, 26,
	3, 26, 3, 26, 3, 26, 3, 26, 5, 26, 371, 10, 26, 3, 27, 3, 27, 5, 27, 375,
	10, 27, 3, 27, 6, 27, 378, 10, 27, 13, 27, 14, 27, 379, 3, 27, 7, 27, 383,
	10, 27, 12, 27, 14, 27, 386, 11, 27, 3, 27, 6, 27, 389, 10, 27, 13, 27,
	14, 27, 390, 5, 27, 393, 10, 27, 3, 27, 5, 27, 396, 10, 27, 3, 28, 3, 28,
	5, 28, 400, 10, 28, 3, 28, 7, 28, 403, 10, 28, 12, 28, 14, 28, 406, 11,
	28, 3, 28, 3, 28, 3, 28, 5, 28, 411, 10, 28, 3, 28, 6, 28, 414, 10, 28,
	13, 28, 14, 28, 415, 3, 28, 3, 28, 5, 28, 420, 10, 28, 3, 29, 3, 29, 3,
	29, 3, 29, 5, 29, 426, 10, 29, 3, 29, 3, 29, 3, 29, 5, 29, 431, 10, 29,
	3, 29, 3, 29, 6, 29, 435, 10, 29, 13, 29, 14, 29, 436, 3, 29, 3, 29, 3,
	29, 7, 29, 442, 10, 29, 12, 29, 14, 29, 445, 11, 29, 5, 29, 447, 10, 29,
	3, 30, 3, 30, 7, 30, 451, 10, 30, 12, 30, 14, 30, 454, 11, 30, 3, 31, 6,
	31, 457, 10, 31, 13, 31, 14, 31, 458, 3, 32, 3, 32, 3, 32, 3, 32, 3, 32,
	3, 32, 3, 32, 3, 32, 5, 32, 469, 10, 32, 3, 33, 6, 33, 472, 10, 33, 13,
	33, 14, 33, 473, 3, 33, 7, 33, 477, 10, 33, 12, 33, 14, 33, 480, 11, 33,
	3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3,
	34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34,
	3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3,
	34, 3, 34, 3, 34, 3, 34, 5, 34, 517, 10, 34, 3, 35, 6, 35, 520, 10, 35,
	13, 35, 14, 35, 521, 3, 35, 7, 35, 525, 10, 35, 12, 35, 14, 35, 528, 11,
	35, 3, 36, 3, 36, 3, 36, 3, 36, 6, 36, 534, 10, 36, 13, 36, 14, 36, 535,
	3, 36, 5, 36, 539, 10, 36, 3, 37, 3, 37, 3, 37, 3, 37, 3, 37, 3, 37, 3,
	37, 3, 37, 3, 37, 3, 37, 3, 37, 3, 37, 3, 37, 3, 37, 5, 37, 555, 10, 37,
	3, 38, 3, 38, 3, 38, 3, 38, 3, 38, 3, 38, 3, 38, 3, 38, 5, 38, 565, 10,
	38, 3, 39, 3, 39, 5, 39, 569, 10, 39, 3, 40, 3, 40, 3, 40, 3, 40, 3, 41,
	3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3,
	41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 5, 41, 592, 10, 41, 3, 42, 3, 42,
	3, 42, 3, 42, 3, 42, 3, 42, 3, 42, 5, 42, 601, 10, 42, 3, 43, 6, 43, 604,
	10, 43, 13, 43, 14, 43, 605, 3, 43, 3, 43, 6, 43, 610, 10, 43, 13, 43,
	14, 43, 611, 3, 43, 3, 43, 3, 43, 3, 43, 7, 43, 618, 10, 43, 12, 43, 14,
	43, 621, 11, 43, 3, 43, 3, 43, 3, 43, 7, 43, 626, 10, 43, 12, 43, 14, 43,
	629, 11, 43, 3, 43, 7, 43, 632, 10, 43, 12, 43, 14, 43, 635, 11, 43, 3,
	43, 3, 43, 3, 43, 6, 43, 640, 10, 43, 13, 43, 14, 43, 641, 3, 43, 3, 43,
	3, 43, 7, 43, 647, 10, 43, 12, 43, 14, 43, 650, 11, 43, 3, 43, 3, 43, 3,
	43, 6, 43, 655, 10, 43, 13, 43, 14, 43, 656, 3, 43, 6, 43, 660, 10, 43,
	13, 43, 14, 43, 661, 3, 43, 3, 43, 6, 43, 666, 10, 43, 13, 43, 14, 43,
	667, 3, 43, 3, 43, 5, 43, 672, 10, 43, 3, 44, 7, 44, 675, 10, 44, 12, 44,
	14, 44, 678, 11, 44, 3, 44, 7, 44, 681, 10, 44, 12, 44, 14, 44, 684, 11,
	44, 3, 44, 7, 44, 687, 10, 44, 12, 44, 14, 44, 690, 11, 44, 3, 45, 3, 45,
	3, 46, 3, 46, 3, 47, 3, 47, 3, 47, 5, 47, 699, 10, 47, 3, 47, 3, 47, 5,
	47, 703, 10, 47, 3, 48, 3, 48, 7, 48, 707, 10, 48, 12, 48, 14, 48, 710,
	11, 48, 3, 48, 3, 48, 6, 48, 714, 10, 48, 13, 48, 14, 48, 715, 3, 48, 3,
	48, 3, 48, 3, 48, 6, 48, 722, 10, 48, 13, 48, 14, 48, 723, 3, 48, 3, 48,
	5, 48, 728, 10, 48, 3, 49, 6, 49, 731, 10, 49, 13, 49, 14, 49, 732, 3,
	50, 3, 50, 3, 51, 3, 51, 3, 51, 5, 51, 740, 10, 51, 3, 52, 6, 52, 743,
	10, 52, 13, 52, 14, 52, 744, 3, 52, 3, 52, 3, 53, 3, 53, 6, 53, 751, 10,
	53, 13, 53, 14, 53, 752, 3, 53, 3, 53, 3, 53, 3, 53, 3, 54, 3, 54, 6, 54,
	761, 10, 54, 13, 54, 14, 54, 762, 3, 55, 3, 55, 6, 55, 767, 10, 55, 13,
	55, 14, 55, 768, 3, 55, 3, 55, 3, 55, 3, 55, 3, 55, 3, 55, 3, 55, 3, 55,
	3, 56, 3, 56, 3, 56, 6, 56, 782, 10, 56, 13, 56, 14, 56, 783, 3, 56, 3,
	56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 5, 56,
	797, 10, 56, 3, 57, 6, 57, 800, 10, 57, 13, 57, 14, 57, 801, 3, 58, 3,
	58, 3, 59, 3, 59, 3, 60, 3, 60, 3, 60, 10, 124, 245, 346, 364, 379, 384,
	390, 404, 2, 61, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30,
	32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66,
	68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102,
	104, 106, 108, 110, 112, 114, 116, 118, 2, 14, 3, 2, 31, 31, 3, 2, 23,
	24, 4, 2, 23, 24, 29, 29, 3, 2, 29, 31, 3, 2, 29, 30, 5, 2, 19, 19, 29,
	29, 31, 31, 4, 2, 4, 4, 29, 31, 4, 2, 29, 29, 31, 31, 4, 2, 28, 28, 30,
	31, 4, 2, 28, 28, 31, 31, 5, 2, 14, 15, 28, 29, 31, 31, 4, 2, 16, 16, 22,
	24, 2, 923, 2, 122, 3, 2, 2, 2, 4, 130, 3, 2, 2, 2, 6, 137, 3, 2, 2, 2,
	8, 142, 3, 2, 2, 2, 10, 158, 3, 2, 2, 2, 12, 166, 3, 2, 2, 2, 14, 170,
	3, 2, 2, 2, 16, 174, 3, 2, 2, 2, 18, 176, 3, 2, 2, 2, 20, 183, 3, 2, 2,
	2, 22, 187, 3, 2, 2, 2, 24, 191, 3, 2, 2, 2, 26, 224, 3, 2, 2, 2, 28, 226,
	3, 2, 2, 2, 30, 259, 3, 2, 2, 2, 32, 271, 3, 2, 2, 2, 34, 273, 3, 2, 2,
	2, 36, 294, 3, 2, 2, 2, 38, 314, 3, 2, 2, 2, 40, 316, 3, 2, 2, 2, 42, 332,
	3, 2, 2, 2, 44, 340, 3, 2, 2, 2, 46, 351, 3, 2, 2, 2, 48, 353, 3, 2, 2,
	2, 50, 370, 3, 2, 2, 2, 52, 395, 3, 2, 2, 2, 54, 419, 3, 2, 2, 2, 56, 446,
	3, 2, 2, 2, 58, 448, 3, 2, 2, 2, 60, 456, 3, 2, 2, 2, 62, 468, 3, 2, 2,
	2, 64, 471, 3, 2, 2, 2, 66, 516, 3, 2, 2, 2, 68, 519, 3, 2, 2, 2, 70, 538,
	3, 2, 2, 2, 72, 554, 3, 2, 2, 2, 74, 564, 3, 2, 2, 2, 76, 568, 3, 2, 2,
	2, 78, 570, 3, 2, 2, 2, 80, 591, 3, 2, 2, 2, 82, 600, 3, 2, 2, 2, 84, 671,
	3, 2, 2, 2, 86, 676, 3, 2, 2, 2, 88, 691, 3, 2, 2, 2, 90, 693, 3, 2, 2,
	2, 92, 698, 3, 2, 2, 2, 94, 727, 3, 2, 2, 2, 96, 730, 3, 2, 2, 2, 98, 734,
	3, 2, 2, 2, 100, 739, 3, 2, 2, 2, 102, 742, 3, 2, 2, 2, 104, 748, 3, 2,
	2, 2, 106, 758, 3, 2, 2, 2, 108, 764, 3, 2, 2, 2, 110, 796, 3, 2, 2, 2,
	112, 799, 3, 2, 2, 2, 114, 803, 3, 2, 2, 2, 116, 805, 3, 2, 2, 2, 118,
	807, 3, 2, 2, 2, 120, 123, 5, 4, 3, 2, 121, 123, 5, 58, 30, 2, 122, 120,
	3, 2, 2, 2, 122, 121, 3, 2, 2, 2, 123, 124, 3, 2, 2, 2, 124, 125, 3, 2,
	2, 2, 124, 122, 3, 2, 2, 2, 125, 126, 3, 2, 2, 2, 126, 127, 7, 2, 2, 3,
	127, 3, 3, 2, 2, 2, 128, 131, 5, 24, 13, 2, 129, 131, 5, 6, 4, 2, 130,
	128, 3, 2, 2, 2, 130, 129, 3, 2, 2, 2, 131, 5, 3, 2, 2, 2, 132, 138, 5,
	32, 17, 2, 133, 138, 5, 40, 21, 2, 134, 138, 5, 22, 12, 2, 135, 138, 5,
	28, 15, 2, 136, 138, 5, 8, 5, 2, 137, 132, 3, 2, 2, 2, 137, 133, 3, 2,
	2, 2, 137, 134, 3, 2, 2, 2, 137, 135, 3, 2, 2, 2, 137, 136, 3, 2, 2, 2,
	138, 7, 3, 2, 2, 2, 139, 141, 7, 30, 2, 2, 140, 139, 3, 2, 2, 2, 141, 144,
	3, 2, 2, 2, 142, 140, 3, 2, 2, 2, 142, 143, 3, 2, 2, 2, 143, 145, 3, 2,
	2, 2, 144, 142, 3, 2, 2, 2, 145, 149, 7, 26, 2, 2, 146, 148, 7, 30, 2,
	2, 147, 146, 3, 2, 2, 2, 148, 151, 3, 2, 2, 2, 149, 147, 3, 2, 2, 2, 149,
	150, 3, 2, 2, 2, 150, 156, 3, 2, 2, 2, 151, 149, 3, 2, 2, 2, 152, 154,
	5, 16, 9, 2, 153, 155, 5, 10, 6, 2, 154, 153, 3, 2, 2, 2, 154, 155, 3,
	2, 2, 2, 155, 157, 3, 2, 2, 2, 156, 152, 3, 2, 2, 2, 156, 157, 3, 2, 2,
	2, 157, 9, 3, 2, 2, 2, 158, 159, 5, 14, 8, 2, 159, 160, 5, 12, 7, 2, 160,
	11, 3, 2, 2, 2, 161, 162, 5, 58, 30, 2, 162, 163, 5, 14, 8, 2, 163, 165,
	3, 2, 2, 2, 164, 161, 3, 2, 2, 2, 165, 168, 3, 2, 2, 2, 166, 164, 3, 2,
	2, 2, 166, 167, 3, 2, 2, 2, 167, 13, 3, 2, 2, 2, 168, 166, 3, 2, 2, 2,
	169, 171, 5, 18, 10, 2, 170, 169, 3, 2, 2, 2, 171, 172, 3, 2, 2, 2, 172,
	170, 3, 2, 2, 2, 172, 173, 3, 2, 2, 2, 173, 15, 3, 2, 2, 2, 174, 175, 5,
	20, 11, 2, 175, 17, 3, 2, 2, 2, 176, 177, 7, 31, 2, 2, 177, 178, 7, 30,
	2, 2, 178, 179, 7, 30, 2, 2, 179, 180, 7, 30, 2, 2, 180, 181, 5, 16, 9,
	2, 181, 19, 3, 2, 2, 2, 182, 184, 10, 2, 2, 2, 183, 182, 3, 2, 2, 2, 184,
	185, 3, 2, 2, 2, 185, 183, 3, 2, 2, 2, 185, 186, 3, 2, 2, 2, 186, 21, 3,
	2, 2, 2, 187, 188, 5, 46, 24, 2, 188, 23, 3, 2, 2, 2, 189, 190, 7, 31,
	2, 2, 190, 192, 7, 4, 2, 2, 191, 189, 3, 2, 2, 2, 191, 192, 3, 2, 2, 2,
	192, 193, 3, 2, 2, 2, 193, 195, 5, 26, 14, 2, 194, 196, 7, 31, 2, 2, 195,
	194, 3, 2, 2, 2, 195, 196, 3, 2, 2, 2, 196, 197, 3, 2, 2, 2, 197, 201,
	7, 4, 2, 2, 198, 200, 7, 31, 2, 2, 199, 198, 3, 2, 2, 2, 200, 203, 3, 2,
	2, 2, 201, 199, 3, 2, 2, 2, 201, 202, 3, 2, 2, 2, 202, 207, 3, 2, 2, 2,
	203, 201, 3, 2, 2, 2, 204, 206, 5, 6, 4, 2, 205, 204, 3, 2, 2, 2, 206,
	209, 3, 2, 2, 2, 207, 205, 3, 2, 2, 2, 207, 208, 3, 2, 2, 2, 208, 25, 3,
	2, 2, 2, 209, 207, 3, 2, 2, 2, 210, 211, 7, 31, 2, 2, 211, 225, 5, 70,
	36, 2, 212, 213, 7, 31, 2, 2, 213, 215, 5, 56, 29, 2, 214, 216, 7, 30,
	2, 2, 215, 214, 3, 2, 2, 2, 216, 217, 3, 2, 2, 2, 217, 215, 3, 2, 2, 2,
	217, 218, 3, 2, 2, 2, 218, 220, 3, 2, 2, 2, 219, 221, 5, 42, 22, 2, 220,
	219, 3, 2, 2, 2, 220, 221, 3, 2, 2, 2, 221, 225, 3, 2, 2, 2, 222, 225,
	5, 52, 27, 2, 223, 225, 5, 54, 28, 2, 224, 210, 3, 2, 2, 2, 224, 212, 3,
	2, 2, 2, 224, 222, 3, 2, 2, 2, 224, 223, 3, 2, 2, 2, 225, 27, 3, 2, 2,
	2, 226, 227, 7, 31, 2, 2, 227, 229, 5, 30, 16, 2, 228, 230, 7, 31, 2, 2,
	229, 228, 3, 2, 2, 2, 229, 230, 3, 2, 2, 2, 230, 234, 3, 2, 2, 2, 231,
	233, 5, 30, 16, 2, 232, 231, 3, 2, 2, 2, 233, 236, 3, 2, 2, 2, 234, 232,
	3, 2, 2, 2, 234, 235, 3, 2, 2, 2, 235, 29, 3, 2, 2, 2, 236, 234, 3, 2,
	2, 2, 237, 238, 7, 25, 2, 2, 238, 240, 7, 30, 2, 2, 239, 241, 5, 60, 31,
	2, 240, 239, 3, 2, 2, 2, 240, 241, 3, 2, 2, 2, 241, 245, 3, 2, 2, 2, 242,
	244, 5, 76, 39, 2, 243, 242, 3, 2, 2, 2, 244, 247, 3, 2, 2, 2, 245, 246,
	3, 2, 2, 2, 245, 243, 3, 2, 2, 2, 246, 248, 3, 2, 2, 2, 247, 245, 3, 2,
	2, 2, 248, 260, 5, 84, 43, 2, 249, 250, 7, 25, 2, 2, 250, 252, 7, 30, 2,
	2, 251, 253, 5, 60, 31, 2, 252, 251, 3, 2, 2, 2, 252, 253, 3, 2, 2, 2,
	253, 255, 3, 2, 2, 2, 254, 256, 5, 76, 39, 2, 255, 254, 3, 2, 2, 2, 256,
	257, 3, 2, 2, 2, 257, 255, 3, 2, 2, 2, 257, 258, 3, 2, 2, 2, 258, 260,
	3, 2, 2, 2, 259, 237, 3, 2, 2, 2, 259, 249, 3, 2, 2, 2, 260, 31, 3, 2,
	2, 2, 261, 272, 5, 34, 18, 2, 262, 272, 5, 36, 19, 2, 263, 267, 7, 31,
	2, 2, 264, 266, 7, 30, 2, 2, 265, 264, 3, 2, 2, 2, 266, 269, 3, 2, 2, 2,
	267, 265, 3, 2, 2, 2, 267, 268, 3, 2, 2, 2, 268, 270, 3, 2, 2, 2, 269,
	267, 3, 2, 2, 2, 270, 272, 9, 3, 2, 2, 271, 261, 3, 2, 2, 2, 271, 262,
	3, 2, 2, 2, 271, 263, 3, 2, 2, 2, 272, 33, 3, 2, 2, 2, 273, 277, 7, 31,
	2, 2, 274, 276, 7, 30, 2, 2, 275, 274, 3, 2, 2, 2, 276, 279, 3, 2, 2, 2,
	277, 275, 3, 2, 2, 2, 277, 278, 3, 2, 2, 2, 278, 280, 3, 2, 2, 2, 279,
	277, 3, 2, 2, 2, 280, 284, 5, 38, 20, 2, 281, 283, 7, 30, 2, 2, 282, 281,
	3, 2, 2, 2, 283, 286, 3, 2, 2, 2, 284, 282, 3, 2, 2, 2, 284, 285, 3, 2,
	2, 2, 285, 292, 3, 2, 2, 2, 286, 284, 3, 2, 2, 2, 287, 289, 5, 22, 12,
	2, 288, 287, 3, 2, 2, 2, 289, 290, 3, 2, 2, 2, 290, 288, 3, 2, 2, 2, 290,
	291, 3, 2, 2, 2, 291, 293, 3, 2, 2, 2, 292, 288, 3, 2, 2, 2, 292, 293,
	3, 2, 2, 2, 293, 35, 3, 2, 2, 2, 294, 298, 7, 31, 2, 2, 295, 297, 7, 30,
	2, 2, 296, 295, 3, 2, 2, 2, 297, 300, 3, 2, 2, 2, 298, 296, 3, 2, 2, 2,
	298, 299, 3, 2, 2, 2, 299, 301, 3, 2, 2, 2, 300, 298, 3, 2, 2, 2, 301,
	303, 5, 38, 20, 2, 302, 304, 7, 30, 2, 2, 303, 302, 3, 2, 2, 2, 304, 305,
	3, 2, 2, 2, 305, 303, 3, 2, 2, 2, 305, 306, 3, 2, 2, 2, 306, 307, 3, 2,
	2, 2, 307, 311, 5, 42, 22, 2, 308, 310, 5, 22, 12, 2, 309, 308, 3, 2, 2,
	2, 310, 313, 3, 2, 2, 2, 311, 309, 3, 2, 2, 2, 311, 312, 3, 2, 2, 2, 312,
	37, 3, 2, 2, 2, 313, 311, 3, 2, 2, 2, 314, 315, 9, 4, 2, 2, 315, 39, 3,
	2, 2, 2, 316, 317, 7, 31, 2, 2, 317, 319, 5, 56, 29, 2, 318, 320, 7, 30,
	2, 2, 319, 318, 3, 2, 2, 2, 320, 321, 3, 2, 2, 2, 321, 319, 3, 2, 2, 2,
	321, 322, 3, 2, 2, 2, 322, 330, 3, 2, 2, 2, 323, 327, 5, 42, 22, 2, 324,
	326, 5, 22, 12, 2, 325, 324, 3, 2, 2, 2, 326, 329, 3, 2, 2, 2, 327, 325,
	3, 2, 2, 2, 327, 328, 3, 2, 2, 2, 328, 331, 3, 2, 2, 2, 329, 327, 3, 2,
	2, 2, 330, 323, 3, 2, 2, 2, 330, 331, 3, 2, 2, 2, 331, 41, 3, 2, 2, 2,
	332, 336, 5, 44, 23, 2, 333, 335, 5, 46, 24, 2, 334, 333, 3, 2, 2, 2, 335,
	338, 3, 2, 2, 2, 336, 334, 3, 2, 2, 2, 336, 337, 3, 2, 2, 2, 337, 43, 3,
	2, 2, 2, 338, 336, 3, 2, 2, 2, 339, 341, 5, 60, 31, 2, 340, 339, 3, 2,
	2, 2, 340, 341, 3, 2, 2, 2, 341, 342, 3, 2, 2, 2, 342, 346, 5, 62, 32,
	2, 343, 345, 5, 76, 39, 2, 344, 343, 3, 2, 2, 2, 345, 348, 3, 2, 2, 2,
	346, 347, 3, 2, 2, 2, 346, 344, 3, 2, 2, 2, 347, 45, 3, 2, 2, 2, 348, 346,
	3, 2, 2, 2, 349, 352, 5, 50, 26, 2, 350, 352, 5, 48, 25, 2, 351, 349, 3,
	2, 2, 2, 351, 350, 3, 2, 2, 2, 352, 47, 3, 2, 2, 2, 353, 358, 5, 52, 27,
	2, 354, 359, 5, 50, 26, 2, 355, 357, 5, 48, 25, 2, 356, 355, 3, 2, 2, 2,
	356, 357, 3, 2, 2, 2, 357, 359, 3, 2, 2, 2, 358, 354, 3, 2, 2, 2, 358,
	356, 3, 2, 2, 2, 359, 49, 3, 2, 2, 2, 360, 371, 5, 54, 28, 2, 361, 362,
	5, 54, 28, 2, 362, 364, 5, 44, 23, 2, 363, 365, 5, 48, 25, 2, 364, 365,
	3, 2, 2, 2, 364, 363, 3, 2, 2, 2, 365, 371, 3, 2, 2, 2, 366, 367, 5, 54,
	28, 2, 367, 368, 5, 44, 23, 2, 368, 369, 5, 50, 26, 2, 369, 371, 3, 2,
	2, 2, 370, 360, 3, 2, 2, 2, 370, 361, 3, 2, 2, 2, 370, 366, 3, 2, 2, 2,
	371, 51, 3, 2, 2, 2, 372, 374, 7, 31, 2, 2, 373, 375, 5, 60, 31, 2, 374,
	373, 3, 2, 2, 2, 374, 375, 3, 2, 2, 2, 375, 377, 3, 2, 2, 2, 376, 378,
	5, 62, 32, 2, 377, 376, 3, 2, 2, 2, 378, 379, 3, 2, 2, 2, 379, 380, 3,
	2, 2, 2, 379, 377, 3, 2, 2, 2, 380, 392, 3, 2, 2, 2, 381, 383, 5, 76, 39,
	2, 382, 381, 3, 2, 2, 2, 383, 386, 3, 2, 2, 2, 384, 385, 3, 2, 2, 2, 384,
	382, 3, 2, 2, 2, 385, 388, 3, 2, 2, 2, 386, 384, 3, 2, 2, 2, 387, 389,
	5, 74, 38, 2, 388, 387, 3, 2, 2, 2, 389, 390, 3, 2, 2, 2, 390, 391, 3,
	2, 2, 2, 390, 388, 3, 2, 2, 2, 391, 393, 3, 2, 2, 2, 392, 384, 3, 2, 2,
	2, 392, 393, 3, 2, 2, 2, 393, 396, 3, 2, 2, 2, 394, 396, 5, 56, 29, 2,
	395, 372, 3, 2, 2, 2, 395, 394, 3, 2, 2, 2, 396, 53, 3, 2, 2, 2, 397, 399,
	7, 31, 2, 2, 398, 400, 5, 60, 31, 2, 399, 398, 3, 2, 2, 2, 399, 400, 3,
	2, 2, 2, 400, 404, 3, 2, 2, 2, 401, 403, 5, 62, 32, 2, 402, 401, 3, 2,
	2, 2, 403, 406, 3, 2, 2, 2, 404, 405, 3, 2, 2, 2, 404, 402, 3, 2, 2, 2,
	405, 407, 3, 2, 2, 2, 406, 404, 3, 2, 2, 2, 407, 420, 5, 84, 43, 2, 408,
	410, 7, 31, 2, 2, 409, 411, 5, 60, 31, 2, 410, 409, 3, 2, 2, 2, 410, 411,
	3, 2, 2, 2, 411, 413, 3, 2, 2, 2, 412, 414, 5, 82, 42, 2, 413, 412, 3,
	2, 2, 2, 414, 415, 3, 2, 2, 2, 415, 413, 3, 2, 2, 2, 415, 416, 3, 2, 2,
	2, 416, 417, 3, 2, 2, 2, 417, 418, 5, 84, 43, 2, 418, 420, 3, 2, 2, 2,
	419, 397, 3, 2, 2, 2, 419, 408, 3, 2, 2, 2, 420, 55, 3, 2, 2, 2, 421, 422,
	7, 8, 2, 2, 422, 447, 7, 19, 2, 2, 423, 425, 7, 31, 2, 2, 424, 426, 5,
	60, 31, 2, 425, 424, 3, 2, 2, 2, 425, 426, 3, 2, 2, 2, 426, 427, 3, 2,
	2, 2, 427, 447, 7, 8, 2, 2, 428, 430, 7, 31, 2, 2, 429, 431, 5, 60, 31,
	2, 430, 429, 3, 2, 2, 2, 430, 431, 3, 2, 2, 2, 431, 432, 3, 2, 2, 2, 432,
	434, 7, 4, 2, 2, 433, 435, 7, 30, 2, 2, 434, 433, 3, 2, 2, 2, 435, 436,
	3, 2, 2, 2, 436, 434, 3, 2, 2, 2, 436, 437, 3, 2, 2, 2, 437, 438, 3, 2,
	2, 2, 438, 439, 7, 4, 2, 2, 439, 443, 3, 2, 2, 2, 440, 442, 7, 30, 2, 2,
	441, 440, 3, 2, 2, 2, 442, 445, 3, 2, 2, 2, 443, 441, 3, 2, 2, 2, 443,
	444, 3, 2, 2, 2, 444, 447, 3, 2, 2, 2, 445, 443, 3, 2, 2, 2, 446, 421,
	3, 2, 2, 2, 446, 423, 3, 2, 2, 2, 446, 428, 3, 2, 2, 2, 447, 57, 3, 2,
	2, 2, 448, 452, 7, 31, 2, 2, 449, 451, 7, 30, 2, 2, 450, 449, 3, 2, 2,
	2, 451, 454, 3, 2, 2, 2, 452, 450, 3, 2, 2, 2, 452, 453, 3, 2, 2, 2, 453,
	59, 3, 2, 2, 2, 454, 452, 3, 2, 2, 2, 455, 457, 7, 30, 2, 2, 456, 455,
	3, 2, 2, 2, 457, 458, 3, 2, 2, 2, 458, 456, 3, 2, 2, 2, 458, 459, 3, 2,
	2, 2, 459, 61, 3, 2, 2, 2, 460, 469, 5, 102, 52, 2, 461, 469, 5, 104, 53,
	2, 462, 469, 5, 106, 54, 2, 463, 469, 5, 108, 55, 2, 464, 469, 5, 110,
	56, 2, 465, 469, 5, 92, 47, 2, 466, 469, 5, 78, 40, 2, 467, 469, 5, 64,
	33, 2, 468, 460, 3, 2, 2, 2, 468, 461, 3, 2, 2, 2, 468, 462, 3, 2, 2, 2,
	468, 463, 3, 2, 2, 2, 468, 464, 3, 2, 2, 2, 468, 465, 3, 2, 2, 2, 468,
	466, 3, 2, 2, 2, 468, 467, 3, 2, 2, 2, 469, 63, 3, 2, 2, 2, 470, 472, 5,
	66, 34, 2, 471, 470, 3, 2, 2, 2, 472, 473, 3, 2, 2, 2, 473, 471, 3, 2,
	2, 2, 473, 474, 3, 2, 2, 2, 474, 478, 3, 2, 2, 2, 475, 477, 5, 82, 42,
	2, 476, 475, 3, 2, 2, 2, 477, 480, 3, 2, 2, 2, 478, 476, 3, 2, 2, 2, 478,
	479, 3, 2, 2, 2, 479, 65, 3, 2, 2, 2, 480, 478, 3, 2, 2, 2, 481, 482, 7,
	24, 2, 2, 482, 517, 10, 5, 2, 2, 483, 484, 7, 23, 2, 2, 484, 517, 10, 6,
	2, 2, 485, 486, 7, 8, 2, 2, 486, 487, 7, 19, 2, 2, 487, 517, 10, 5, 2,
	2, 488, 489, 7, 8, 2, 2, 489, 517, 10, 7, 2, 2, 490, 491, 7, 7, 2, 2, 491,
	517, 7, 19, 2, 2, 492, 493, 7, 25, 2, 2, 493, 517, 10, 6, 2, 2, 494, 495,
	7, 27, 2, 2, 495, 517, 10, 6, 2, 2, 496, 497, 7, 7, 2, 2, 497, 517, 10,
	7, 2, 2, 498, 517, 7, 7, 2, 2, 499, 500, 5, 118, 60, 2, 500, 501, 5, 118,
	60, 2, 501, 517, 3, 2, 2, 2, 502, 517, 7, 6, 2, 2, 503, 517, 7, 10, 2,
	2, 504, 517, 7, 11, 2, 2, 505, 517, 7, 12, 2, 2, 506, 517, 7, 13, 2, 2,
	507, 517, 7, 20, 2, 2, 508, 517, 7, 21, 2, 2, 509, 517, 7, 17, 2, 2, 510,
	517, 7, 18, 2, 2, 511, 517, 7, 19, 2, 2, 512, 517, 7, 27, 2, 2, 513, 517,
	7, 14, 2, 2, 514, 517, 7, 15, 2, 2, 515, 517, 7, 32, 2, 2, 516, 481, 3,
	2, 2, 2, 516, 483, 3, 2, 2, 2, 516, 485, 3, 2, 2, 2, 516, 488, 3, 2, 2,
	2, 516, 490, 3, 2, 2, 2, 516, 492, 3, 2, 2, 2, 516, 494, 3, 2, 2, 2, 516,
	496, 3, 2, 2, 2, 516, 498, 3, 2, 2, 2, 516, 499, 3, 2, 2, 2, 516, 502,
	3, 2, 2, 2, 516, 503, 3, 2, 2, 2, 516, 504, 3, 2, 2, 2, 516, 505, 3, 2,
	2, 2, 516, 506, 3, 2, 2, 2, 516, 507, 3, 2, 2, 2, 516, 508, 3, 2, 2, 2,
	516, 509, 3, 2, 2, 2, 516, 510, 3, 2, 2, 2, 516, 511, 3, 2, 2, 2, 516,
	512, 3, 2, 2, 2, 516, 513, 3, 2, 2, 2, 516, 514, 3, 2, 2, 2, 516, 515,
	3, 2, 2, 2, 517, 67, 3, 2, 2, 2, 518, 520, 5, 70, 36, 2, 519, 518, 3, 2,
	2, 2, 520, 521, 3, 2, 2, 2, 521, 519, 3, 2, 2, 2, 521, 522, 3, 2, 2, 2,
	522, 526, 3, 2, 2, 2, 523, 525, 5, 82, 42, 2, 524, 523, 3, 2, 2, 2, 525,
	528, 3, 2, 2, 2, 526, 524, 3, 2, 2, 2, 526, 527, 3, 2, 2, 2, 527, 69, 3,
	2, 2, 2, 528, 526, 3, 2, 2, 2, 529, 539, 5, 72, 37, 2, 530, 539, 5, 66,
	34, 2, 531, 533, 5, 80, 41, 2, 532, 534, 5, 80, 41, 2, 533, 532, 3, 2,
	2, 2, 534, 535, 3, 2, 2, 2, 535, 533, 3, 2, 2, 2, 535, 536, 3, 2, 2, 2,
	536, 539, 3, 2, 2, 2, 537, 539, 7, 30, 2, 2, 538, 529, 3, 2, 2, 2, 538,
	530, 3, 2, 2, 2, 538, 531, 3, 2, 2, 2, 538, 537, 3, 2, 2, 2, 539, 71, 3,
	2, 2, 2, 540, 541, 7, 12, 2, 2, 541, 542, 7, 29, 2, 2, 542, 555, 7, 13,
	2, 2, 543, 544, 7, 10, 2, 2, 544, 545, 7, 29, 2, 2, 545, 555, 7, 11, 2,
	2, 546, 547, 7, 18, 2, 2, 547, 548, 7, 29, 2, 2, 548, 555, 7, 18, 2, 2,
	549, 550, 7, 18, 2, 2, 550, 551, 7, 17, 2, 2, 551, 552, 7, 29, 2, 2, 552,
	553, 7, 17, 2, 2, 553, 555, 7, 18, 2, 2, 554, 540, 3, 2, 2, 2, 554, 543,
	3, 2, 2, 2, 554, 546, 3, 2, 2, 2, 554, 549, 3, 2, 2, 2, 555, 73, 3, 2,
	2, 2, 556, 565, 5, 102, 52, 2, 557, 565, 5, 104, 53, 2, 558, 565, 5, 106,
	54, 2, 559, 565, 5, 108, 55, 2, 560, 565, 5, 110, 56, 2, 561, 565, 5, 92,
	47, 2, 562, 565, 5, 78, 40, 2, 563, 565, 5, 68, 35, 2, 564, 556, 3, 2,
	2, 2, 564, 557, 3, 2, 2, 2, 564, 558, 3, 2, 2, 2, 564, 559, 3, 2, 2, 2,
	564, 560, 3, 2, 2, 2, 564, 561, 3, 2, 2, 2, 564, 562, 3, 2, 2, 2, 564,
	563, 3, 2, 2, 2, 565, 75, 3, 2, 2, 2, 566, 569, 5, 84, 43, 2, 567, 569,
	5, 74, 38, 2, 568, 566, 3, 2, 2, 2, 568, 567, 3, 2, 2, 2, 569, 77, 3, 2,
	2, 2, 570, 571, 7, 15, 2, 2, 571, 572, 7, 30, 2, 2, 572, 573, 5, 44, 23,
	2, 573, 79, 3, 2, 2, 2, 574, 592, 7, 20, 2, 2, 575, 592, 7, 8, 2, 2, 576,
	592, 7, 7, 2, 2, 577, 592, 7, 30, 2, 2, 578, 592, 7, 10, 2, 2, 579, 592,
	7, 11, 2, 2, 580, 592, 7, 12, 2, 2, 581, 592, 7, 13, 2, 2, 582, 592, 7,
	21, 2, 2, 583, 592, 5, 118, 60, 2, 584, 592, 7, 14, 2, 2, 585, 592, 7,
	15, 2, 2, 586, 592, 7, 17, 2, 2, 587, 592, 7, 19, 2, 2, 588, 589, 7, 29,
	2, 2, 589, 592, 7, 30, 2, 2, 590, 592, 7, 32, 2, 2, 591, 574, 3, 2, 2,
	2, 591, 575, 3, 2, 2, 2, 591, 576, 3, 2, 2, 2, 591, 577, 3, 2, 2, 2, 591,
	578, 3, 2, 2, 2, 591, 579, 3, 2, 2, 2, 591, 580, 3, 2, 2, 2, 591, 581,
	3, 2, 2, 2, 591, 582, 3, 2, 2, 2, 591, 583, 3, 2, 2, 2, 591, 584, 3, 2,
	2, 2, 591, 585, 3, 2, 2, 2, 591, 586, 3, 2, 2, 2, 591, 587, 3, 2, 2, 2,
	591, 588, 3, 2, 2, 2, 591, 590, 3, 2, 2, 2, 592, 81, 3, 2, 2, 2, 593, 601,
	5, 80, 41, 2, 594, 601, 5, 72, 37, 2, 595, 601, 7, 25, 2, 2, 596, 601,
	7, 5, 2, 2, 597, 601, 7, 26, 2, 2, 598, 601, 7, 19, 2, 2, 599, 601, 7,
	9, 2, 2, 600, 593, 3, 2, 2, 2, 600, 594, 3, 2, 2, 2, 600, 595, 3, 2, 2,
	2, 600, 596, 3, 2, 2, 2, 600, 597, 3, 2, 2, 2, 600, 598, 3, 2, 2, 2, 600,
	599, 3, 2, 2, 2, 601, 83, 3, 2, 2, 2, 602, 604, 7, 29, 2, 2, 603, 602,
	3, 2, 2, 2, 604, 605, 3, 2, 2, 2, 605, 603, 3, 2, 2, 2, 605, 606, 3, 2,
	2, 2, 606, 607, 3, 2, 2, 2, 607, 672, 7, 31, 2, 2, 608, 610, 7, 29, 2,
	2, 609, 608, 3, 2, 2, 2, 610, 611, 3, 2, 2, 2, 611, 609, 3, 2, 2, 2, 611,
	612, 3, 2, 2, 2, 612, 613, 3, 2, 2, 2, 613, 614, 5, 88, 45, 2, 614, 627,
	5, 86, 44, 2, 615, 619, 7, 31, 2, 2, 616, 618, 7, 29, 2, 2, 617, 616, 3,
	2, 2, 2, 618, 621, 3, 2, 2, 2, 619, 617, 3, 2, 2, 2, 619, 620, 3, 2, 2,
	2, 620, 622, 3, 2, 2, 2, 621, 619, 3, 2, 2, 2, 622, 623, 5, 88, 45, 2,
	623, 624, 5, 86, 44, 2, 624, 626, 3, 2, 2, 2, 625, 615, 3, 2, 2, 2, 626,
	629, 3, 2, 2, 2, 627, 625, 3, 2, 2, 2, 627, 628, 3, 2, 2, 2, 628, 633,
	3, 2, 2, 2, 629, 627, 3, 2, 2, 2, 630, 632, 7, 29, 2, 2, 631, 630, 3, 2,
	2, 2, 632, 635, 3, 2, 2, 2, 633, 631, 3, 2, 2, 2, 633, 634, 3, 2, 2, 2,
	634, 636, 3, 2, 2, 2, 635, 633, 3, 2, 2, 2, 636, 637, 7, 31, 2, 2, 637,
	672, 3, 2, 2, 2, 638, 640, 7, 29, 2, 2, 639, 638, 3, 2, 2, 2, 640, 641,
	3, 2, 2, 2, 641, 639, 3, 2, 2, 2, 641, 642, 3, 2, 2, 2, 642, 643, 3, 2,
	2, 2, 643, 644, 5, 88, 45, 2, 644, 648, 5, 86, 44, 2, 645, 647, 7, 29,
	2, 2, 646, 645, 3, 2, 2, 2, 647, 650, 3, 2, 2, 2, 648, 646, 3, 2, 2, 2,
	648, 649, 3, 2, 2, 2, 649, 651, 3, 2, 2, 2, 650, 648, 3, 2, 2, 2, 651,
	652, 7, 31, 2, 2, 652, 672, 3, 2, 2, 2, 653, 655, 7, 29, 2, 2, 654, 653,
	3, 2, 2, 2, 655, 656, 3, 2, 2, 2, 656, 654, 3, 2, 2, 2, 656, 657, 3, 2,
	2, 2, 657, 659, 3, 2, 2, 2, 658, 660, 7, 30, 2, 2, 659, 658, 3, 2, 2, 2,
	660, 661, 3, 2, 2, 2, 661, 659, 3, 2, 2, 2, 661, 662, 3, 2, 2, 2, 662,
	663, 3, 2, 2, 2, 663, 665, 5, 86, 44, 2, 664, 666, 7, 29, 2, 2, 665, 664,
	3, 2, 2, 2, 666, 667, 3, 2, 2, 2, 667, 665, 3, 2, 2, 2, 667, 668, 3, 2,
	2, 2, 668, 669, 3, 2, 2, 2, 669, 670, 7, 31, 2, 2, 670, 672, 3, 2, 2, 2,
	671, 603, 3, 2, 2, 2, 671, 609, 3, 2, 2, 2, 671, 639, 3, 2, 2, 2, 671,
	654, 3, 2, 2, 2, 672, 85, 3, 2, 2, 2, 673, 675, 5, 90, 46, 2, 674, 673,
	3, 2, 2, 2, 675, 678, 3, 2, 2, 2, 676, 674, 3, 2, 2, 2, 676, 677, 3, 2,
	2, 2, 677, 688, 3, 2, 2, 2, 678, 676, 3, 2, 2, 2, 679, 681, 7, 29, 2, 2,
	680, 679, 3, 2, 2, 2, 681, 684, 3, 2, 2, 2, 682, 680, 3, 2, 2, 2, 682,
	683, 3, 2, 2, 2, 683, 685, 3, 2, 2, 2, 684, 682, 3, 2, 2, 2, 685, 687,
	5, 90, 46, 2, 686, 682, 3, 2, 2, 2, 687, 690, 3, 2, 2, 2, 688, 686, 3,
	2, 2, 2, 688, 689, 3, 2, 2, 2, 689, 87, 3, 2, 2, 2, 690, 688, 3, 2, 2,
	2, 691, 692, 10, 8, 2, 2, 692, 89, 3, 2, 2, 2, 693, 694, 10, 9, 2, 2, 694,
	91, 3, 2, 2, 2, 695, 696, 7, 21, 2, 2, 696, 697, 7, 7, 2, 2, 697, 699,
	7, 21, 2, 2, 698, 695, 3, 2, 2, 2, 698, 699, 3, 2, 2, 2, 699, 700, 3, 2,
	2, 2, 700, 702, 5, 94, 48, 2, 701, 703, 7, 27, 2, 2, 702, 701, 3, 2, 2,
	2, 702, 703, 3, 2, 2, 2, 703, 93, 3, 2, 2, 2, 704, 708, 7, 28, 2, 2, 705,
	707, 7, 28, 2, 2, 706, 705, 3, 2, 2, 2, 707, 710, 3, 2, 2, 2, 708, 706,
	3, 2, 2, 2, 708, 709, 3, 2, 2, 2, 709, 711, 3, 2, 2, 2, 710, 708, 3, 2,
	2, 2, 711, 713, 5, 96, 49, 2, 712, 714, 7, 28, 2, 2, 713, 712, 3, 2, 2,
	2, 714, 715, 3, 2, 2, 2, 715, 713, 3, 2, 2, 2, 715, 716, 3, 2, 2, 2, 716,
	728, 3, 2, 2, 2, 717, 718, 7, 28, 2, 2, 718, 719, 5, 98, 50, 2, 719, 721,
	5, 96, 49, 2, 720, 722, 7, 28, 2, 2, 721, 720, 3, 2, 2, 2, 722, 723, 3,
	2, 2, 2, 723, 721, 3, 2, 2, 2, 723, 724, 3, 2, 2, 2, 724, 728, 3, 2, 2,
	2, 725, 726, 7, 28, 2, 2, 726, 728, 7, 28, 2, 2, 727, 704, 3, 2, 2, 2,
	727, 717, 3, 2, 2, 2, 727, 725, 3, 2, 2, 2, 728, 95, 3, 2, 2, 2, 729, 731,
	5, 100, 51, 2, 730, 729, 3, 2, 2, 2, 731, 732, 3, 2, 2, 2, 732, 730, 3,
	2, 2, 2, 732, 733, 3, 2, 2, 2, 733, 97, 3, 2, 2, 2, 734, 735, 10, 10, 2,
	2, 735, 99, 3, 2, 2, 2, 736, 740, 10, 11, 2, 2, 737, 738, 7, 28, 2, 2,
	738, 740, 10, 11, 2, 2, 739, 736, 3, 2, 2, 2, 739, 737, 3, 2, 2, 2, 740,
	101, 3, 2, 2, 2, 741, 743, 7, 32, 2, 2, 742, 741, 3, 2, 2, 2, 743, 744,
	3, 2, 2, 2, 744, 742, 3, 2, 2, 2, 744, 745, 3, 2, 2, 2, 745, 746, 3, 2,
	2, 2, 746, 747, 7, 27, 2, 2, 747, 103, 3, 2, 2, 2, 748, 750, 7, 27, 2,
	2, 749, 751, 5, 116, 59, 2, 750, 749, 3, 2, 2, 2, 751, 752, 3, 2, 2, 2,
	752, 750, 3, 2, 2, 2, 752, 753, 3, 2, 2, 2, 753, 754, 3, 2, 2, 2, 754,
	755, 7, 21, 2, 2, 755, 756, 7, 30, 2, 2, 756, 757, 5, 112, 57, 2, 757,
	105, 3, 2, 2, 2, 758, 760, 7, 27, 2, 2, 759, 761, 7, 32, 2, 2, 760, 759,
	3, 2, 2, 2, 761, 762, 3, 2, 2, 2, 762, 760, 3, 2, 2, 2, 762, 763, 3, 2,
	2, 2, 763, 107, 3, 2, 2, 2, 764, 766, 7, 28, 2, 2, 765, 767, 5, 116, 59,
	2, 766, 765, 3, 2, 2, 2, 767, 768, 3, 2, 2, 2, 768, 766, 3, 2, 2, 2, 768,
	769, 3, 2, 2, 2, 769, 770, 3, 2, 2, 2, 770, 771, 7, 30, 2, 2, 771, 772,
	7, 14, 2, 2, 772, 773, 5, 112, 57, 2, 773, 774, 7, 15, 2, 2, 774, 775,
	7, 28, 2, 2, 775, 776, 7, 27, 2, 2, 776, 777, 7, 30, 2, 2, 777, 109, 3,
	2, 2, 2, 778, 779, 7, 3, 2, 2, 779, 781, 7, 28, 2, 2, 780, 782, 5, 116,
	59, 2, 781, 780, 3, 2, 2, 2, 782, 783, 3, 2, 2, 2, 783, 781, 3, 2, 2, 2,
	783, 784, 3, 2, 2, 2, 784, 785, 3, 2, 2, 2, 785, 786, 7, 30, 2, 2, 786,
	787, 7, 14, 2, 2, 787, 788, 5, 112, 57, 2, 788, 789, 7, 15, 2, 2, 789,
	790, 7, 28, 2, 2, 790, 797, 3, 2, 2, 2, 791, 792, 7, 3, 2, 2, 792, 793,
	7, 28, 2, 2, 793, 794, 5, 112, 57, 2, 794, 795, 7, 28, 2, 2, 795, 797,
	3, 2, 2, 2, 796, 778, 3, 2, 2, 2, 796, 791, 3, 2, 2, 2, 797, 111, 3, 2,
	2, 2, 798, 800, 5, 114, 58, 2, 799, 798, 3, 2, 2, 2, 800, 801, 3, 2, 2,
	2, 801, 799, 3, 2, 2, 2, 801, 802, 3, 2, 2, 2, 802, 113, 3, 2, 2, 2, 803,
	804, 10, 11, 2, 2, 804, 115, 3, 2, 2, 2, 805, 806, 10, 12, 2, 2, 806, 117,
	3, 2, 2, 2, 807, 808, 9, 13, 2, 2, 808, 119, 3, 2, 2, 2, 107, 122, 124,
	130, 137, 142, 149, 154, 156, 166, 172, 185, 191, 195, 201, 207, 217, 220,
	224, 229, 234, 240, 245, 252, 257, 259, 267, 271, 277, 284, 290, 292, 298,
	305, 311, 321, 327, 330, 336, 340, 346, 351, 356, 358, 364, 370, 374, 379,
	384, 390, 392, 395, 399, 404, 410, 415, 419, 425, 430, 436, 443, 446, 452,
	458, 468, 473, 478, 516, 521, 526, 535, 538, 554, 564, 568, 591, 600, 605,
	611, 619, 627, 633, 641, 648, 656, 661, 667, 671, 676, 682, 688, 698, 702,
	708, 715, 723, 727, 732, 739, 744, 752, 762, 768, 783, 796, 801,
}
var literalNames = []string{
	"", "':doc:'", "", "", "", "", "", "", "'['", "']'", "'('", "')'", "'<'",
	"'>'", "'^'", "'\"'", "'''", "'.'", "';'", "':'", "'='", "'+'", "'-'",
	"'|'", "", "'_'", "'`'", "'*'",
}
var symbolicNames = []string{
	"", "", "SectionSeparator", "Literal", "TimeStar", "Alphabet", "Numbers",
	"Quote", "SquareLeft", "SquareRight", "RoundLeft", "RoundRight", "AngleLeft",
	"AngleRight", "Hat", "QuotationDouble", "QuotationSingle", "Dot", "SemiColon",
	"Colon", "Equal", "Plus", "Minus", "Block", "Comment", "UnderScore", "BackTick",
	"Star", "Space", "LineBreak", "Any",
}

var ruleNames = []string{
	"parse", "element", "sectionElement", "comment", "commentParagraphs", "commentRest",
	"commentParagraph", "commentLineNoBreak", "commentLine", "commentLineAtoms",
	"paragraph", "section", "title", "lineBlock", "lineBlockLine", "listItemBullet",
	"bulletCrossLine", "bulletSimple", "bullet", "listItemEnumerated", "paragraphNoBreak",
	"lineNoBreak", "lines", "linesNormal", "linesStar", "lineNormal", "lineStar",
	"lineSpecial", "empty_line", "indentation", "spanLineStartNoStar", "textLineStart",
	"lineStart_fragment", "text", "textStart", "forcedText", "spanNoStar",
	"span", "quotedLiteral", "text_fragment_start", "text_fragment", "starText",
	"starAtoms", "starNoSpace", "starAtom", "backTickText", "body", "backTickAtoms",
	"backTickNoSpace", "backTickAtom", "reference", "referenceIn", "hyperlinkTarget",
	"hyperlink", "hyperlinkDoc", "url", "urlAtom", "hyperlinkAtom", "separator",
}

type ReStructuredTextParser struct {
	*antlr.BaseParser
}

// NewReStructuredTextParser produces a new parser instance for the optional input antlr.TokenStream.
//
// The *ReStructuredTextParser instance produced may be reused by calling the SetInputStream method.
// The initial parser configuration is expensive to construct, and the object is not thread-safe;
// however, if used within a Golang sync.Pool, the construction cost amortizes well and the
// objects can be used in a thread-safe manner.
func NewReStructuredTextParser(input antlr.TokenStream) *ReStructuredTextParser {
	this := new(ReStructuredTextParser)
	deserializer := antlr.NewATNDeserializer(nil)
	deserializedATN := deserializer.DeserializeFromUInt16(parserATN)
	decisionToDFA := make([]*antlr.DFA, len(deserializedATN.DecisionToState))
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "ReStructuredText.g4"

	return this
}

// ReStructuredTextParser tokens.
const (
	ReStructuredTextParserEOF              = antlr.TokenEOF
	ReStructuredTextParserT__0             = 1
	ReStructuredTextParserSectionSeparator = 2
	ReStructuredTextParserLiteral          = 3
	ReStructuredTextParserTimeStar         = 4
	ReStructuredTextParserAlphabet         = 5
	ReStructuredTextParserNumbers          = 6
	ReStructuredTextParserQuote            = 7
	ReStructuredTextParserSquareLeft       = 8
	ReStructuredTextParserSquareRight      = 9
	ReStructuredTextParserRoundLeft        = 10
	ReStructuredTextParserRoundRight       = 11
	ReStructuredTextParserAngleLeft        = 12
	ReStructuredTextParserAngleRight       = 13
	ReStructuredTextParserHat              = 14
	ReStructuredTextParserQuotationDouble  = 15
	ReStructuredTextParserQuotationSingle  = 16
	ReStructuredTextParserDot              = 17
	ReStructuredTextParserSemiColon        = 18
	ReStructuredTextParserColon            = 19
	ReStructuredTextParserEqual            = 20
	ReStructuredTextParserPlus             = 21
	ReStructuredTextParserMinus            = 22
	ReStructuredTextParserBlock            = 23
	ReStructuredTextParserComment          = 24
	ReStructuredTextParserUnderScore       = 25
	ReStructuredTextParserBackTick         = 26
	ReStructuredTextParserStar             = 27
	ReStructuredTextParserSpace            = 28
	ReStructuredTextParserLineBreak        = 29
	ReStructuredTextParserAny              = 30
)

// ReStructuredTextParser rules.
const (
	ReStructuredTextParserRULE_parse               = 0
	ReStructuredTextParserRULE_element             = 1
	ReStructuredTextParserRULE_sectionElement      = 2
	ReStructuredTextParserRULE_comment             = 3
	ReStructuredTextParserRULE_commentParagraphs   = 4
	ReStructuredTextParserRULE_commentRest         = 5
	ReStructuredTextParserRULE_commentParagraph    = 6
	ReStructuredTextParserRULE_commentLineNoBreak  = 7
	ReStructuredTextParserRULE_commentLine         = 8
	ReStructuredTextParserRULE_commentLineAtoms    = 9
	ReStructuredTextParserRULE_paragraph           = 10
	ReStructuredTextParserRULE_section             = 11
	ReStructuredTextParserRULE_title               = 12
	ReStructuredTextParserRULE_lineBlock           = 13
	ReStructuredTextParserRULE_lineBlockLine       = 14
	ReStructuredTextParserRULE_listItemBullet      = 15
	ReStructuredTextParserRULE_bulletCrossLine     = 16
	ReStructuredTextParserRULE_bulletSimple        = 17
	ReStructuredTextParserRULE_bullet              = 18
	ReStructuredTextParserRULE_listItemEnumerated  = 19
	ReStructuredTextParserRULE_paragraphNoBreak    = 20
	ReStructuredTextParserRULE_lineNoBreak         = 21
	ReStructuredTextParserRULE_lines               = 22
	ReStructuredTextParserRULE_linesNormal         = 23
	ReStructuredTextParserRULE_linesStar           = 24
	ReStructuredTextParserRULE_lineNormal          = 25
	ReStructuredTextParserRULE_lineStar            = 26
	ReStructuredTextParserRULE_lineSpecial         = 27
	ReStructuredTextParserRULE_empty_line          = 28
	ReStructuredTextParserRULE_indentation         = 29
	ReStructuredTextParserRULE_spanLineStartNoStar = 30
	ReStructuredTextParserRULE_textLineStart       = 31
	ReStructuredTextParserRULE_lineStart_fragment  = 32
	ReStructuredTextParserRULE_text                = 33
	ReStructuredTextParserRULE_textStart           = 34
	ReStructuredTextParserRULE_forcedText          = 35
	ReStructuredTextParserRULE_spanNoStar          = 36
	ReStructuredTextParserRULE_span                = 37
	ReStructuredTextParserRULE_quotedLiteral       = 38
	ReStructuredTextParserRULE_text_fragment_start = 39
	ReStructuredTextParserRULE_text_fragment       = 40
	ReStructuredTextParserRULE_starText            = 41
	ReStructuredTextParserRULE_starAtoms           = 42
	ReStructuredTextParserRULE_starNoSpace         = 43
	ReStructuredTextParserRULE_starAtom            = 44
	ReStructuredTextParserRULE_backTickText        = 45
	ReStructuredTextParserRULE_body                = 46
	ReStructuredTextParserRULE_backTickAtoms       = 47
	ReStructuredTextParserRULE_backTickNoSpace     = 48
	ReStructuredTextParserRULE_backTickAtom        = 49
	ReStructuredTextParserRULE_reference           = 50
	ReStructuredTextParserRULE_referenceIn         = 51
	ReStructuredTextParserRULE_hyperlinkTarget     = 52
	ReStructuredTextParserRULE_hyperlink           = 53
	ReStructuredTextParserRULE_hyperlinkDoc        = 54
	ReStructuredTextParserRULE_url                 = 55
	ReStructuredTextParserRULE_urlAtom             = 56
	ReStructuredTextParserRULE_hyperlinkAtom       = 57
	ReStructuredTextParserRULE_separator           = 58
)

// IParseContext is an interface to support dynamic dispatch.
type IParseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParseContext differentiates from other interfaces.
	IsParseContext()
}

type ParseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParseContext() *ParseContext {
	var p = new(ParseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ReStructuredTextParserRULE_parse
	return p
}

func (*ParseContext) IsParseContext() {}

func NewParseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParseContext {
	var p = new(ParseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ReStructuredTextParserRULE_parse

	return p
}

func (s *ParseContext) GetParser() antlr.Parser { return s.parser }

func (s *ParseContext) EOF() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserEOF, 0)
}

func (s *ParseContext) AllElement() []IElementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IElementContext)(nil)).Elem())
	var tst = make([]IElementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IElementContext)
		}
	}

	return tst
}

func (s *ParseContext) Element(i int) IElementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IElementContext)
}

func (s *ParseContext) AllEmpty_line() []IEmpty_lineContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEmpty_lineContext)(nil)).Elem())
	var tst = make([]IEmpty_lineContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEmpty_lineContext)
		}
	}

	return tst
}

func (s *ParseContext) Empty_line(i int) IEmpty_lineContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEmpty_lineContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEmpty_lineContext)
}

func (s *ParseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.EnterParse(s)
	}
}

func (s *ParseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.ExitParse(s)
	}
}

func (p *ReStructuredTextParser) Parse() (localctx IParseContext) {
	this := p
	_ = this

	localctx = NewParseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, ReStructuredTextParserRULE_parse)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(120)
	p.GetErrorHandler().Sync(p)
	_alt = 1 + 1
	for ok := true; ok; ok = _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1 + 1:
			p.SetState(120)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 0, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(118)
					p.Element()
				}

			case 2:
				{
					p.SetState(119)
					p.Empty_line()
				}

			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(122)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1, p.GetParserRuleContext())
	}
	{
		p.SetState(124)
		p.Match(ReStructuredTextParserEOF)
	}

	return localctx
}

// IElementContext is an interface to support dynamic dispatch.
type IElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElementContext differentiates from other interfaces.
	IsElementContext()
}

type ElementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementContext() *ElementContext {
	var p = new(ElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ReStructuredTextParserRULE_element
	return p
}

func (*ElementContext) IsElementContext() {}

func NewElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementContext {
	var p = new(ElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ReStructuredTextParserRULE_element

	return p
}

func (s *ElementContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementContext) Section() ISectionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISectionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISectionContext)
}

func (s *ElementContext) SectionElement() ISectionElementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISectionElementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISectionElementContext)
}

func (s *ElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.EnterElement(s)
	}
}

func (s *ElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.ExitElement(s)
	}
}

func (p *ReStructuredTextParser) Element() (localctx IElementContext) {
	this := p
	_ = this

	localctx = NewElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, ReStructuredTextParserRULE_element)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(128)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 2, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(126)
			p.Section()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(127)
			p.SectionElement()
		}

	}

	return localctx
}

// ISectionElementContext is an interface to support dynamic dispatch.
type ISectionElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSectionElementContext differentiates from other interfaces.
	IsSectionElementContext()
}

type SectionElementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySectionElementContext() *SectionElementContext {
	var p = new(SectionElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ReStructuredTextParserRULE_sectionElement
	return p
}

func (*SectionElementContext) IsSectionElementContext() {}

func NewSectionElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SectionElementContext {
	var p = new(SectionElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ReStructuredTextParserRULE_sectionElement

	return p
}

func (s *SectionElementContext) GetParser() antlr.Parser { return s.parser }

func (s *SectionElementContext) ListItemBullet() IListItemBulletContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IListItemBulletContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IListItemBulletContext)
}

func (s *SectionElementContext) ListItemEnumerated() IListItemEnumeratedContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IListItemEnumeratedContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IListItemEnumeratedContext)
}

func (s *SectionElementContext) Paragraph() IParagraphContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParagraphContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParagraphContext)
}

func (s *SectionElementContext) LineBlock() ILineBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILineBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILineBlockContext)
}

func (s *SectionElementContext) Comment() ICommentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICommentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *SectionElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SectionElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SectionElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.EnterSectionElement(s)
	}
}

func (s *SectionElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.ExitSectionElement(s)
	}
}

func (p *ReStructuredTextParser) SectionElement() (localctx ISectionElementContext) {
	this := p
	_ = this

	localctx = NewSectionElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, ReStructuredTextParserRULE_sectionElement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(135)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 3, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(130)
			p.ListItemBullet()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(131)
			p.ListItemEnumerated()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(132)
			p.Paragraph()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(133)
			p.LineBlock()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(134)
			p.Comment()
		}

	}

	return localctx
}

// ICommentContext is an interface to support dynamic dispatch.
type ICommentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCommentContext differentiates from other interfaces.
	IsCommentContext()
}

type CommentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommentContext() *CommentContext {
	var p = new(CommentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ReStructuredTextParserRULE_comment
	return p
}

func (*CommentContext) IsCommentContext() {}

func NewCommentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommentContext {
	var p = new(CommentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ReStructuredTextParserRULE_comment

	return p
}

func (s *CommentContext) GetParser() antlr.Parser { return s.parser }

func (s *CommentContext) Comment() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserComment, 0)
}

func (s *CommentContext) AllSpace() []antlr.TerminalNode {
	return s.GetTokens(ReStructuredTextParserSpace)
}

func (s *CommentContext) Space(i int) antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserSpace, i)
}

func (s *CommentContext) CommentLineNoBreak() ICommentLineNoBreakContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICommentLineNoBreakContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICommentLineNoBreakContext)
}

func (s *CommentContext) CommentParagraphs() ICommentParagraphsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICommentParagraphsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICommentParagraphsContext)
}

func (s *CommentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.EnterComment(s)
	}
}

func (s *CommentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.ExitComment(s)
	}
}

func (p *ReStructuredTextParser) Comment() (localctx ICommentContext) {
	this := p
	_ = this

	localctx = NewCommentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, ReStructuredTextParserRULE_comment)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(140)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ReStructuredTextParserSpace {
		{
			p.SetState(137)
			p.Match(ReStructuredTextParserSpace)
		}

		p.SetState(142)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(143)
		p.Match(ReStructuredTextParserComment)
	}
	p.SetState(147)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 5, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(144)
				p.Match(ReStructuredTextParserSpace)
			}

		}
		p.SetState(149)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 5, p.GetParserRuleContext())
	}
	p.SetState(154)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 7, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(150)
			p.CommentLineNoBreak()
		}
		p.SetState(152)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 6, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(151)
				p.CommentParagraphs()
			}

		}

	}

	return localctx
}

// ICommentParagraphsContext is an interface to support dynamic dispatch.
type ICommentParagraphsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetMain returns the main rule contexts.
	GetMain() ICommentParagraphContext

	// SetMain sets the main rule contexts.
	SetMain(ICommentParagraphContext)

	// IsCommentParagraphsContext differentiates from other interfaces.
	IsCommentParagraphsContext()
}

type CommentParagraphsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	main   ICommentParagraphContext
}

func NewEmptyCommentParagraphsContext() *CommentParagraphsContext {
	var p = new(CommentParagraphsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ReStructuredTextParserRULE_commentParagraphs
	return p
}

func (*CommentParagraphsContext) IsCommentParagraphsContext() {}

func NewCommentParagraphsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommentParagraphsContext {
	var p = new(CommentParagraphsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ReStructuredTextParserRULE_commentParagraphs

	return p
}

func (s *CommentParagraphsContext) GetParser() antlr.Parser { return s.parser }

func (s *CommentParagraphsContext) GetMain() ICommentParagraphContext { return s.main }

func (s *CommentParagraphsContext) SetMain(v ICommentParagraphContext) { s.main = v }

func (s *CommentParagraphsContext) CommentRest() ICommentRestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICommentRestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICommentRestContext)
}

func (s *CommentParagraphsContext) CommentParagraph() ICommentParagraphContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICommentParagraphContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICommentParagraphContext)
}

func (s *CommentParagraphsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommentParagraphsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommentParagraphsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.EnterCommentParagraphs(s)
	}
}

func (s *CommentParagraphsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.ExitCommentParagraphs(s)
	}
}

func (p *ReStructuredTextParser) CommentParagraphs() (localctx ICommentParagraphsContext) {
	this := p
	_ = this

	localctx = NewCommentParagraphsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, ReStructuredTextParserRULE_commentParagraphs)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(156)

		var _x = p.CommentParagraph()

		localctx.(*CommentParagraphsContext).main = _x
	}
	{
		p.SetState(157)
		p.CommentRest()
	}

	return localctx
}

// ICommentRestContext is an interface to support dynamic dispatch.
type ICommentRestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCommentRestContext differentiates from other interfaces.
	IsCommentRestContext()
}

type CommentRestContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommentRestContext() *CommentRestContext {
	var p = new(CommentRestContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ReStructuredTextParserRULE_commentRest
	return p
}

func (*CommentRestContext) IsCommentRestContext() {}

func NewCommentRestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommentRestContext {
	var p = new(CommentRestContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ReStructuredTextParserRULE_commentRest

	return p
}

func (s *CommentRestContext) GetParser() antlr.Parser { return s.parser }

func (s *CommentRestContext) AllEmpty_line() []IEmpty_lineContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEmpty_lineContext)(nil)).Elem())
	var tst = make([]IEmpty_lineContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEmpty_lineContext)
		}
	}

	return tst
}

func (s *CommentRestContext) Empty_line(i int) IEmpty_lineContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEmpty_lineContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEmpty_lineContext)
}

func (s *CommentRestContext) AllCommentParagraph() []ICommentParagraphContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICommentParagraphContext)(nil)).Elem())
	var tst = make([]ICommentParagraphContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICommentParagraphContext)
		}
	}

	return tst
}

func (s *CommentRestContext) CommentParagraph(i int) ICommentParagraphContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICommentParagraphContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICommentParagraphContext)
}

func (s *CommentRestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommentRestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommentRestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.EnterCommentRest(s)
	}
}

func (s *CommentRestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.ExitCommentRest(s)
	}
}

func (p *ReStructuredTextParser) CommentRest() (localctx ICommentRestContext) {
	this := p
	_ = this

	localctx = NewCommentRestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, ReStructuredTextParserRULE_commentRest)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(164)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 8, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(159)
				p.Empty_line()
			}
			{
				p.SetState(160)
				p.CommentParagraph()
			}

		}
		p.SetState(166)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 8, p.GetParserRuleContext())
	}

	return localctx
}

// ICommentParagraphContext is an interface to support dynamic dispatch.
type ICommentParagraphContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCommentParagraphContext differentiates from other interfaces.
	IsCommentParagraphContext()
}

type CommentParagraphContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommentParagraphContext() *CommentParagraphContext {
	var p = new(CommentParagraphContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ReStructuredTextParserRULE_commentParagraph
	return p
}

func (*CommentParagraphContext) IsCommentParagraphContext() {}

func NewCommentParagraphContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommentParagraphContext {
	var p = new(CommentParagraphContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ReStructuredTextParserRULE_commentParagraph

	return p
}

func (s *CommentParagraphContext) GetParser() antlr.Parser { return s.parser }

func (s *CommentParagraphContext) AllCommentLine() []ICommentLineContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICommentLineContext)(nil)).Elem())
	var tst = make([]ICommentLineContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICommentLineContext)
		}
	}

	return tst
}

func (s *CommentParagraphContext) CommentLine(i int) ICommentLineContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICommentLineContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICommentLineContext)
}

func (s *CommentParagraphContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommentParagraphContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommentParagraphContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.EnterCommentParagraph(s)
	}
}

func (s *CommentParagraphContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.ExitCommentParagraph(s)
	}
}

func (p *ReStructuredTextParser) CommentParagraph() (localctx ICommentParagraphContext) {
	this := p
	_ = this

	localctx = NewCommentParagraphContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, ReStructuredTextParserRULE_commentParagraph)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(168)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(167)
				p.CommentLine()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(170)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 9, p.GetParserRuleContext())
	}

	return localctx
}

// ICommentLineNoBreakContext is an interface to support dynamic dispatch.
type ICommentLineNoBreakContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCommentLineNoBreakContext differentiates from other interfaces.
	IsCommentLineNoBreakContext()
}

type CommentLineNoBreakContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommentLineNoBreakContext() *CommentLineNoBreakContext {
	var p = new(CommentLineNoBreakContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ReStructuredTextParserRULE_commentLineNoBreak
	return p
}

func (*CommentLineNoBreakContext) IsCommentLineNoBreakContext() {}

func NewCommentLineNoBreakContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommentLineNoBreakContext {
	var p = new(CommentLineNoBreakContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ReStructuredTextParserRULE_commentLineNoBreak

	return p
}

func (s *CommentLineNoBreakContext) GetParser() antlr.Parser { return s.parser }

func (s *CommentLineNoBreakContext) CommentLineAtoms() ICommentLineAtomsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICommentLineAtomsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICommentLineAtomsContext)
}

func (s *CommentLineNoBreakContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommentLineNoBreakContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommentLineNoBreakContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.EnterCommentLineNoBreak(s)
	}
}

func (s *CommentLineNoBreakContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.ExitCommentLineNoBreak(s)
	}
}

func (p *ReStructuredTextParser) CommentLineNoBreak() (localctx ICommentLineNoBreakContext) {
	this := p
	_ = this

	localctx = NewCommentLineNoBreakContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, ReStructuredTextParserRULE_commentLineNoBreak)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(172)
		p.CommentLineAtoms()
	}

	return localctx
}

// ICommentLineContext is an interface to support dynamic dispatch.
type ICommentLineContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCommentLineContext differentiates from other interfaces.
	IsCommentLineContext()
}

type CommentLineContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommentLineContext() *CommentLineContext {
	var p = new(CommentLineContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ReStructuredTextParserRULE_commentLine
	return p
}

func (*CommentLineContext) IsCommentLineContext() {}

func NewCommentLineContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommentLineContext {
	var p = new(CommentLineContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ReStructuredTextParserRULE_commentLine

	return p
}

func (s *CommentLineContext) GetParser() antlr.Parser { return s.parser }

func (s *CommentLineContext) LineBreak() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserLineBreak, 0)
}

func (s *CommentLineContext) AllSpace() []antlr.TerminalNode {
	return s.GetTokens(ReStructuredTextParserSpace)
}

func (s *CommentLineContext) Space(i int) antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserSpace, i)
}

func (s *CommentLineContext) CommentLineNoBreak() ICommentLineNoBreakContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICommentLineNoBreakContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICommentLineNoBreakContext)
}

func (s *CommentLineContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommentLineContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommentLineContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.EnterCommentLine(s)
	}
}

func (s *CommentLineContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.ExitCommentLine(s)
	}
}

func (p *ReStructuredTextParser) CommentLine() (localctx ICommentLineContext) {
	this := p
	_ = this

	localctx = NewCommentLineContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, ReStructuredTextParserRULE_commentLine)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(174)
		p.Match(ReStructuredTextParserLineBreak)
	}
	{
		p.SetState(175)
		p.Match(ReStructuredTextParserSpace)
	}
	{
		p.SetState(176)
		p.Match(ReStructuredTextParserSpace)
	}
	{
		p.SetState(177)
		p.Match(ReStructuredTextParserSpace)
	}
	{
		p.SetState(178)
		p.CommentLineNoBreak()
	}

	return localctx
}

// ICommentLineAtomsContext is an interface to support dynamic dispatch.
type ICommentLineAtomsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCommentLineAtomsContext differentiates from other interfaces.
	IsCommentLineAtomsContext()
}

type CommentLineAtomsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommentLineAtomsContext() *CommentLineAtomsContext {
	var p = new(CommentLineAtomsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ReStructuredTextParserRULE_commentLineAtoms
	return p
}

func (*CommentLineAtomsContext) IsCommentLineAtomsContext() {}

func NewCommentLineAtomsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommentLineAtomsContext {
	var p = new(CommentLineAtomsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ReStructuredTextParserRULE_commentLineAtoms

	return p
}

func (s *CommentLineAtomsContext) GetParser() antlr.Parser { return s.parser }

func (s *CommentLineAtomsContext) AllLineBreak() []antlr.TerminalNode {
	return s.GetTokens(ReStructuredTextParserLineBreak)
}

func (s *CommentLineAtomsContext) LineBreak(i int) antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserLineBreak, i)
}

func (s *CommentLineAtomsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommentLineAtomsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommentLineAtomsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.EnterCommentLineAtoms(s)
	}
}

func (s *CommentLineAtomsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.ExitCommentLineAtoms(s)
	}
}

func (p *ReStructuredTextParser) CommentLineAtoms() (localctx ICommentLineAtomsContext) {
	this := p
	_ = this

	localctx = NewCommentLineAtomsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, ReStructuredTextParserRULE_commentLineAtoms)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(181)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(180)
				_la = p.GetTokenStream().LA(1)

				if _la <= 0 || _la == ReStructuredTextParserLineBreak {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(183)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 10, p.GetParserRuleContext())
	}

	return localctx
}

// IParagraphContext is an interface to support dynamic dispatch.
type IParagraphContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParagraphContext differentiates from other interfaces.
	IsParagraphContext()
}

type ParagraphContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParagraphContext() *ParagraphContext {
	var p = new(ParagraphContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ReStructuredTextParserRULE_paragraph
	return p
}

func (*ParagraphContext) IsParagraphContext() {}

func NewParagraphContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParagraphContext {
	var p = new(ParagraphContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ReStructuredTextParserRULE_paragraph

	return p
}

func (s *ParagraphContext) GetParser() antlr.Parser { return s.parser }

func (s *ParagraphContext) Lines() ILinesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILinesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILinesContext)
}

func (s *ParagraphContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParagraphContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParagraphContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.EnterParagraph(s)
	}
}

func (s *ParagraphContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.ExitParagraph(s)
	}
}

func (p *ReStructuredTextParser) Paragraph() (localctx IParagraphContext) {
	this := p
	_ = this

	localctx = NewParagraphContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, ReStructuredTextParserRULE_paragraph)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(185)
		p.Lines()
	}

	return localctx
}

// ISectionContext is an interface to support dynamic dispatch.
type ISectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOverline returns the overline token.
	GetOverline() antlr.Token

	// SetOverline sets the overline token.
	SetOverline(antlr.Token)

	// IsSectionContext differentiates from other interfaces.
	IsSectionContext()
}

type SectionContext struct {
	*antlr.BaseParserRuleContext
	parser   antlr.Parser
	overline antlr.Token
}

func NewEmptySectionContext() *SectionContext {
	var p = new(SectionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ReStructuredTextParserRULE_section
	return p
}

func (*SectionContext) IsSectionContext() {}

func NewSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SectionContext {
	var p = new(SectionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ReStructuredTextParserRULE_section

	return p
}

func (s *SectionContext) GetParser() antlr.Parser { return s.parser }

func (s *SectionContext) GetOverline() antlr.Token { return s.overline }

func (s *SectionContext) SetOverline(v antlr.Token) { s.overline = v }

func (s *SectionContext) Title() ITitleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITitleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITitleContext)
}

func (s *SectionContext) AllSectionSeparator() []antlr.TerminalNode {
	return s.GetTokens(ReStructuredTextParserSectionSeparator)
}

func (s *SectionContext) SectionSeparator(i int) antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserSectionSeparator, i)
}

func (s *SectionContext) AllLineBreak() []antlr.TerminalNode {
	return s.GetTokens(ReStructuredTextParserLineBreak)
}

func (s *SectionContext) LineBreak(i int) antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserLineBreak, i)
}

func (s *SectionContext) AllSectionElement() []ISectionElementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISectionElementContext)(nil)).Elem())
	var tst = make([]ISectionElementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISectionElementContext)
		}
	}

	return tst
}

func (s *SectionContext) SectionElement(i int) ISectionElementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISectionElementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISectionElementContext)
}

func (s *SectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.EnterSection(s)
	}
}

func (s *SectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.ExitSection(s)
	}
}

func (p *ReStructuredTextParser) Section() (localctx ISectionContext) {
	this := p
	_ = this

	localctx = NewSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, ReStructuredTextParserRULE_section)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(189)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 11, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(187)
			p.Match(ReStructuredTextParserLineBreak)
		}
		{
			p.SetState(188)

			var _m = p.Match(ReStructuredTextParserSectionSeparator)

			localctx.(*SectionContext).overline = _m
		}

	}
	{
		p.SetState(191)
		p.Title()
	}
	p.SetState(193)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ReStructuredTextParserLineBreak {
		{
			p.SetState(192)
			p.Match(ReStructuredTextParserLineBreak)
		}

	}
	{
		p.SetState(195)
		p.Match(ReStructuredTextParserSectionSeparator)
	}
	p.SetState(199)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 13, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(196)
				p.Match(ReStructuredTextParserLineBreak)
			}

		}
		p.SetState(201)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 13, p.GetParserRuleContext())
	}
	p.SetState(205)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 14, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(202)
				p.SectionElement()
			}

		}
		p.SetState(207)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 14, p.GetParserRuleContext())
	}

	return localctx
}

// ITitleContext is an interface to support dynamic dispatch.
type ITitleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTitleContext differentiates from other interfaces.
	IsTitleContext()
}

type TitleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTitleContext() *TitleContext {
	var p = new(TitleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ReStructuredTextParserRULE_title
	return p
}

func (*TitleContext) IsTitleContext() {}

func NewTitleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TitleContext {
	var p = new(TitleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ReStructuredTextParserRULE_title

	return p
}

func (s *TitleContext) GetParser() antlr.Parser { return s.parser }

func (s *TitleContext) LineBreak() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserLineBreak, 0)
}

func (s *TitleContext) TextStart() ITextStartContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITextStartContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITextStartContext)
}

func (s *TitleContext) LineSpecial() ILineSpecialContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILineSpecialContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILineSpecialContext)
}

func (s *TitleContext) AllSpace() []antlr.TerminalNode {
	return s.GetTokens(ReStructuredTextParserSpace)
}

func (s *TitleContext) Space(i int) antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserSpace, i)
}

func (s *TitleContext) ParagraphNoBreak() IParagraphNoBreakContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParagraphNoBreakContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParagraphNoBreakContext)
}

func (s *TitleContext) LineNormal() ILineNormalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILineNormalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILineNormalContext)
}

func (s *TitleContext) LineStar() ILineStarContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILineStarContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILineStarContext)
}

func (s *TitleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TitleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TitleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.EnterTitle(s)
	}
}

func (s *TitleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.ExitTitle(s)
	}
}

func (p *ReStructuredTextParser) Title() (localctx ITitleContext) {
	this := p
	_ = this

	localctx = NewTitleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, ReStructuredTextParserRULE_title)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(222)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 17, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(208)
			p.Match(ReStructuredTextParserLineBreak)
		}
		{
			p.SetState(209)
			p.TextStart()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(210)
			p.Match(ReStructuredTextParserLineBreak)
		}
		{
			p.SetState(211)
			p.LineSpecial()
		}
		p.SetState(213)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(212)
					p.Match(ReStructuredTextParserSpace)
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(215)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 15, p.GetParserRuleContext())
		}
		p.SetState(218)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ReStructuredTextParserT__0)|(1<<ReStructuredTextParserTimeStar)|(1<<ReStructuredTextParserAlphabet)|(1<<ReStructuredTextParserNumbers)|(1<<ReStructuredTextParserSquareLeft)|(1<<ReStructuredTextParserSquareRight)|(1<<ReStructuredTextParserRoundLeft)|(1<<ReStructuredTextParserRoundRight)|(1<<ReStructuredTextParserAngleLeft)|(1<<ReStructuredTextParserAngleRight)|(1<<ReStructuredTextParserHat)|(1<<ReStructuredTextParserQuotationDouble)|(1<<ReStructuredTextParserQuotationSingle)|(1<<ReStructuredTextParserDot)|(1<<ReStructuredTextParserSemiColon)|(1<<ReStructuredTextParserColon)|(1<<ReStructuredTextParserEqual)|(1<<ReStructuredTextParserPlus)|(1<<ReStructuredTextParserMinus)|(1<<ReStructuredTextParserBlock)|(1<<ReStructuredTextParserUnderScore)|(1<<ReStructuredTextParserBackTick)|(1<<ReStructuredTextParserSpace)|(1<<ReStructuredTextParserAny))) != 0 {
			{
				p.SetState(217)
				p.ParagraphNoBreak()
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(220)
			p.LineNormal()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(221)
			p.LineStar()
		}

	}

	return localctx
}

// ILineBlockContext is an interface to support dynamic dispatch.
type ILineBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLineBlockContext differentiates from other interfaces.
	IsLineBlockContext()
}

type LineBlockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLineBlockContext() *LineBlockContext {
	var p = new(LineBlockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ReStructuredTextParserRULE_lineBlock
	return p
}

func (*LineBlockContext) IsLineBlockContext() {}

func NewLineBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LineBlockContext {
	var p = new(LineBlockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ReStructuredTextParserRULE_lineBlock

	return p
}

func (s *LineBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *LineBlockContext) AllLineBreak() []antlr.TerminalNode {
	return s.GetTokens(ReStructuredTextParserLineBreak)
}

func (s *LineBlockContext) LineBreak(i int) antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserLineBreak, i)
}

func (s *LineBlockContext) AllLineBlockLine() []ILineBlockLineContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILineBlockLineContext)(nil)).Elem())
	var tst = make([]ILineBlockLineContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILineBlockLineContext)
		}
	}

	return tst
}

func (s *LineBlockContext) LineBlockLine(i int) ILineBlockLineContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILineBlockLineContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILineBlockLineContext)
}

func (s *LineBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LineBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LineBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.EnterLineBlock(s)
	}
}

func (s *LineBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.ExitLineBlock(s)
	}
}

func (p *ReStructuredTextParser) LineBlock() (localctx ILineBlockContext) {
	this := p
	_ = this

	localctx = NewLineBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, ReStructuredTextParserRULE_lineBlock)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(224)
		p.Match(ReStructuredTextParserLineBreak)
	}
	{
		p.SetState(225)
		p.LineBlockLine()
	}
	p.SetState(227)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 18, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(226)
			p.Match(ReStructuredTextParserLineBreak)
		}

	}
	p.SetState(232)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ReStructuredTextParserBlock {
		{
			p.SetState(229)
			p.LineBlockLine()
		}

		p.SetState(234)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ILineBlockLineContext is an interface to support dynamic dispatch.
type ILineBlockLineContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLineBlockLineContext differentiates from other interfaces.
	IsLineBlockLineContext()
}

type LineBlockLineContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLineBlockLineContext() *LineBlockLineContext {
	var p = new(LineBlockLineContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ReStructuredTextParserRULE_lineBlockLine
	return p
}

func (*LineBlockLineContext) IsLineBlockLineContext() {}

func NewLineBlockLineContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LineBlockLineContext {
	var p = new(LineBlockLineContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ReStructuredTextParserRULE_lineBlockLine

	return p
}

func (s *LineBlockLineContext) GetParser() antlr.Parser { return s.parser }

func (s *LineBlockLineContext) Block() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserBlock, 0)
}

func (s *LineBlockLineContext) Space() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserSpace, 0)
}

func (s *LineBlockLineContext) StarText() IStarTextContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStarTextContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStarTextContext)
}

func (s *LineBlockLineContext) Indentation() IIndentationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIndentationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIndentationContext)
}

func (s *LineBlockLineContext) AllSpan() []ISpanContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISpanContext)(nil)).Elem())
	var tst = make([]ISpanContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISpanContext)
		}
	}

	return tst
}

func (s *LineBlockLineContext) Span(i int) ISpanContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpanContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISpanContext)
}

func (s *LineBlockLineContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LineBlockLineContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LineBlockLineContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.EnterLineBlockLine(s)
	}
}

func (s *LineBlockLineContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.ExitLineBlockLine(s)
	}
}

func (p *ReStructuredTextParser) LineBlockLine() (localctx ILineBlockLineContext) {
	this := p
	_ = this

	localctx = NewLineBlockLineContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, ReStructuredTextParserRULE_lineBlockLine)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(257)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 24, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(235)
			p.Match(ReStructuredTextParserBlock)
		}
		{
			p.SetState(236)
			p.Match(ReStructuredTextParserSpace)
		}
		p.SetState(238)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 20, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(237)
				p.Indentation()
			}

		}
		p.SetState(243)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 21, p.GetParserRuleContext())

		for _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1+1 {
				{
					p.SetState(240)
					p.Span()
				}

			}
			p.SetState(245)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 21, p.GetParserRuleContext())
		}
		{
			p.SetState(246)
			p.StarText()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(247)
			p.Match(ReStructuredTextParserBlock)
		}
		{
			p.SetState(248)
			p.Match(ReStructuredTextParserSpace)
		}
		p.SetState(250)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 22, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(249)
				p.Indentation()
			}

		}
		p.SetState(253)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(252)
					p.Span()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(255)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 23, p.GetParserRuleContext())
		}

	}

	return localctx
}

// IListItemBulletContext is an interface to support dynamic dispatch.
type IListItemBulletContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSpecial returns the special token.
	GetSpecial() antlr.Token

	// SetSpecial sets the special token.
	SetSpecial(antlr.Token)

	// IsListItemBulletContext differentiates from other interfaces.
	IsListItemBulletContext()
}

type ListItemBulletContext struct {
	*antlr.BaseParserRuleContext
	parser  antlr.Parser
	special antlr.Token
}

func NewEmptyListItemBulletContext() *ListItemBulletContext {
	var p = new(ListItemBulletContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ReStructuredTextParserRULE_listItemBullet
	return p
}

func (*ListItemBulletContext) IsListItemBulletContext() {}

func NewListItemBulletContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListItemBulletContext {
	var p = new(ListItemBulletContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ReStructuredTextParserRULE_listItemBullet

	return p
}

func (s *ListItemBulletContext) GetParser() antlr.Parser { return s.parser }

func (s *ListItemBulletContext) GetSpecial() antlr.Token { return s.special }

func (s *ListItemBulletContext) SetSpecial(v antlr.Token) { s.special = v }

func (s *ListItemBulletContext) BulletCrossLine() IBulletCrossLineContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBulletCrossLineContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBulletCrossLineContext)
}

func (s *ListItemBulletContext) BulletSimple() IBulletSimpleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBulletSimpleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBulletSimpleContext)
}

func (s *ListItemBulletContext) LineBreak() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserLineBreak, 0)
}

func (s *ListItemBulletContext) Minus() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserMinus, 0)
}

func (s *ListItemBulletContext) Plus() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserPlus, 0)
}

func (s *ListItemBulletContext) AllSpace() []antlr.TerminalNode {
	return s.GetTokens(ReStructuredTextParserSpace)
}

func (s *ListItemBulletContext) Space(i int) antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserSpace, i)
}

func (s *ListItemBulletContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListItemBulletContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListItemBulletContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.EnterListItemBullet(s)
	}
}

func (s *ListItemBulletContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.ExitListItemBullet(s)
	}
}

func (p *ReStructuredTextParser) ListItemBullet() (localctx IListItemBulletContext) {
	this := p
	_ = this

	localctx = NewListItemBulletContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, ReStructuredTextParserRULE_listItemBullet)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(269)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 26, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(259)
			p.BulletCrossLine()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(260)
			p.BulletSimple()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(261)
			p.Match(ReStructuredTextParserLineBreak)
		}
		p.SetState(265)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == ReStructuredTextParserSpace {
			{
				p.SetState(262)
				p.Match(ReStructuredTextParserSpace)
			}

			p.SetState(267)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(268)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ListItemBulletContext).special = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == ReStructuredTextParserPlus || _la == ReStructuredTextParserMinus) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ListItemBulletContext).special = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

	return localctx
}

// IBulletCrossLineContext is an interface to support dynamic dispatch.
type IBulletCrossLineContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBulletCrossLineContext differentiates from other interfaces.
	IsBulletCrossLineContext()
}

type BulletCrossLineContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBulletCrossLineContext() *BulletCrossLineContext {
	var p = new(BulletCrossLineContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ReStructuredTextParserRULE_bulletCrossLine
	return p
}

func (*BulletCrossLineContext) IsBulletCrossLineContext() {}

func NewBulletCrossLineContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BulletCrossLineContext {
	var p = new(BulletCrossLineContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ReStructuredTextParserRULE_bulletCrossLine

	return p
}

func (s *BulletCrossLineContext) GetParser() antlr.Parser { return s.parser }

func (s *BulletCrossLineContext) LineBreak() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserLineBreak, 0)
}

func (s *BulletCrossLineContext) Bullet() IBulletContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBulletContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBulletContext)
}

func (s *BulletCrossLineContext) AllSpace() []antlr.TerminalNode {
	return s.GetTokens(ReStructuredTextParserSpace)
}

func (s *BulletCrossLineContext) Space(i int) antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserSpace, i)
}

func (s *BulletCrossLineContext) AllParagraph() []IParagraphContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IParagraphContext)(nil)).Elem())
	var tst = make([]IParagraphContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IParagraphContext)
		}
	}

	return tst
}

func (s *BulletCrossLineContext) Paragraph(i int) IParagraphContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParagraphContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IParagraphContext)
}

func (s *BulletCrossLineContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BulletCrossLineContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BulletCrossLineContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.EnterBulletCrossLine(s)
	}
}

func (s *BulletCrossLineContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.ExitBulletCrossLine(s)
	}
}

func (p *ReStructuredTextParser) BulletCrossLine() (localctx IBulletCrossLineContext) {
	this := p
	_ = this

	localctx = NewBulletCrossLineContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, ReStructuredTextParserRULE_bulletCrossLine)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(271)
		p.Match(ReStructuredTextParserLineBreak)
	}
	p.SetState(275)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ReStructuredTextParserSpace {
		{
			p.SetState(272)
			p.Match(ReStructuredTextParserSpace)
		}

		p.SetState(277)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(278)
		p.Bullet()
	}
	p.SetState(282)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 28, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(279)
				p.Match(ReStructuredTextParserSpace)
			}

		}
		p.SetState(284)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 28, p.GetParserRuleContext())
	}
	p.SetState(290)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 30, p.GetParserRuleContext()) == 1 {
		p.SetState(286)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(285)
					p.Paragraph()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(288)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 29, p.GetParserRuleContext())
		}

	}

	return localctx
}

// IBulletSimpleContext is an interface to support dynamic dispatch.
type IBulletSimpleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBulletSimpleContext differentiates from other interfaces.
	IsBulletSimpleContext()
}

type BulletSimpleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBulletSimpleContext() *BulletSimpleContext {
	var p = new(BulletSimpleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ReStructuredTextParserRULE_bulletSimple
	return p
}

func (*BulletSimpleContext) IsBulletSimpleContext() {}

func NewBulletSimpleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BulletSimpleContext {
	var p = new(BulletSimpleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ReStructuredTextParserRULE_bulletSimple

	return p
}

func (s *BulletSimpleContext) GetParser() antlr.Parser { return s.parser }

func (s *BulletSimpleContext) LineBreak() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserLineBreak, 0)
}

func (s *BulletSimpleContext) Bullet() IBulletContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBulletContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBulletContext)
}

func (s *BulletSimpleContext) ParagraphNoBreak() IParagraphNoBreakContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParagraphNoBreakContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParagraphNoBreakContext)
}

func (s *BulletSimpleContext) AllSpace() []antlr.TerminalNode {
	return s.GetTokens(ReStructuredTextParserSpace)
}

func (s *BulletSimpleContext) Space(i int) antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserSpace, i)
}

func (s *BulletSimpleContext) AllParagraph() []IParagraphContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IParagraphContext)(nil)).Elem())
	var tst = make([]IParagraphContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IParagraphContext)
		}
	}

	return tst
}

func (s *BulletSimpleContext) Paragraph(i int) IParagraphContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParagraphContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IParagraphContext)
}

func (s *BulletSimpleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BulletSimpleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BulletSimpleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.EnterBulletSimple(s)
	}
}

func (s *BulletSimpleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.ExitBulletSimple(s)
	}
}

func (p *ReStructuredTextParser) BulletSimple() (localctx IBulletSimpleContext) {
	this := p
	_ = this

	localctx = NewBulletSimpleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, ReStructuredTextParserRULE_bulletSimple)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(292)
		p.Match(ReStructuredTextParserLineBreak)
	}
	p.SetState(296)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ReStructuredTextParserSpace {
		{
			p.SetState(293)
			p.Match(ReStructuredTextParserSpace)
		}

		p.SetState(298)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(299)
		p.Bullet()
	}
	p.SetState(301)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(300)
				p.Match(ReStructuredTextParserSpace)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(303)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 32, p.GetParserRuleContext())
	}
	{
		p.SetState(305)
		p.ParagraphNoBreak()
	}
	p.SetState(309)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 33, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(306)
				p.Paragraph()
			}

		}
		p.SetState(311)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 33, p.GetParserRuleContext())
	}

	return localctx
}

// IBulletContext is an interface to support dynamic dispatch.
type IBulletContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBulletContext differentiates from other interfaces.
	IsBulletContext()
}

type BulletContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBulletContext() *BulletContext {
	var p = new(BulletContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ReStructuredTextParserRULE_bullet
	return p
}

func (*BulletContext) IsBulletContext() {}

func NewBulletContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BulletContext {
	var p = new(BulletContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ReStructuredTextParserRULE_bullet

	return p
}

func (s *BulletContext) GetParser() antlr.Parser { return s.parser }

func (s *BulletContext) Star() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserStar, 0)
}

func (s *BulletContext) Minus() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserMinus, 0)
}

func (s *BulletContext) Plus() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserPlus, 0)
}

func (s *BulletContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BulletContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BulletContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.EnterBullet(s)
	}
}

func (s *BulletContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.ExitBullet(s)
	}
}

func (p *ReStructuredTextParser) Bullet() (localctx IBulletContext) {
	this := p
	_ = this

	localctx = NewBulletContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, ReStructuredTextParserRULE_bullet)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(312)
		_la = p.GetTokenStream().LA(1)

		if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ReStructuredTextParserPlus)|(1<<ReStructuredTextParserMinus)|(1<<ReStructuredTextParserStar))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IListItemEnumeratedContext is an interface to support dynamic dispatch.
type IListItemEnumeratedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetEnumerated returns the enumerated rule contexts.
	GetEnumerated() ILineSpecialContext

	// SetEnumerated sets the enumerated rule contexts.
	SetEnumerated(ILineSpecialContext)

	// IsListItemEnumeratedContext differentiates from other interfaces.
	IsListItemEnumeratedContext()
}

type ListItemEnumeratedContext struct {
	*antlr.BaseParserRuleContext
	parser     antlr.Parser
	enumerated ILineSpecialContext
}

func NewEmptyListItemEnumeratedContext() *ListItemEnumeratedContext {
	var p = new(ListItemEnumeratedContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ReStructuredTextParserRULE_listItemEnumerated
	return p
}

func (*ListItemEnumeratedContext) IsListItemEnumeratedContext() {}

func NewListItemEnumeratedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListItemEnumeratedContext {
	var p = new(ListItemEnumeratedContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ReStructuredTextParserRULE_listItemEnumerated

	return p
}

func (s *ListItemEnumeratedContext) GetParser() antlr.Parser { return s.parser }

func (s *ListItemEnumeratedContext) GetEnumerated() ILineSpecialContext { return s.enumerated }

func (s *ListItemEnumeratedContext) SetEnumerated(v ILineSpecialContext) { s.enumerated = v }

func (s *ListItemEnumeratedContext) LineBreak() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserLineBreak, 0)
}

func (s *ListItemEnumeratedContext) LineSpecial() ILineSpecialContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILineSpecialContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILineSpecialContext)
}

func (s *ListItemEnumeratedContext) AllSpace() []antlr.TerminalNode {
	return s.GetTokens(ReStructuredTextParserSpace)
}

func (s *ListItemEnumeratedContext) Space(i int) antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserSpace, i)
}

func (s *ListItemEnumeratedContext) ParagraphNoBreak() IParagraphNoBreakContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParagraphNoBreakContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParagraphNoBreakContext)
}

func (s *ListItemEnumeratedContext) AllParagraph() []IParagraphContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IParagraphContext)(nil)).Elem())
	var tst = make([]IParagraphContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IParagraphContext)
		}
	}

	return tst
}

func (s *ListItemEnumeratedContext) Paragraph(i int) IParagraphContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParagraphContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IParagraphContext)
}

func (s *ListItemEnumeratedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListItemEnumeratedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListItemEnumeratedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.EnterListItemEnumerated(s)
	}
}

func (s *ListItemEnumeratedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.ExitListItemEnumerated(s)
	}
}

func (p *ReStructuredTextParser) ListItemEnumerated() (localctx IListItemEnumeratedContext) {
	this := p
	_ = this

	localctx = NewListItemEnumeratedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, ReStructuredTextParserRULE_listItemEnumerated)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(314)
		p.Match(ReStructuredTextParserLineBreak)
	}
	{
		p.SetState(315)

		var _x = p.LineSpecial()

		localctx.(*ListItemEnumeratedContext).enumerated = _x
	}
	p.SetState(317)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(316)
				p.Match(ReStructuredTextParserSpace)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(319)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 34, p.GetParserRuleContext())
	}
	p.SetState(328)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 36, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(321)
			p.ParagraphNoBreak()
		}
		p.SetState(325)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 35, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(322)
					p.Paragraph()
				}

			}
			p.SetState(327)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 35, p.GetParserRuleContext())
		}

	}

	return localctx
}

// IParagraphNoBreakContext is an interface to support dynamic dispatch.
type IParagraphNoBreakContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParagraphNoBreakContext differentiates from other interfaces.
	IsParagraphNoBreakContext()
}

type ParagraphNoBreakContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParagraphNoBreakContext() *ParagraphNoBreakContext {
	var p = new(ParagraphNoBreakContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ReStructuredTextParserRULE_paragraphNoBreak
	return p
}

func (*ParagraphNoBreakContext) IsParagraphNoBreakContext() {}

func NewParagraphNoBreakContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParagraphNoBreakContext {
	var p = new(ParagraphNoBreakContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ReStructuredTextParserRULE_paragraphNoBreak

	return p
}

func (s *ParagraphNoBreakContext) GetParser() antlr.Parser { return s.parser }

func (s *ParagraphNoBreakContext) LineNoBreak() ILineNoBreakContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILineNoBreakContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILineNoBreakContext)
}

func (s *ParagraphNoBreakContext) AllLines() []ILinesContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILinesContext)(nil)).Elem())
	var tst = make([]ILinesContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILinesContext)
		}
	}

	return tst
}

func (s *ParagraphNoBreakContext) Lines(i int) ILinesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILinesContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILinesContext)
}

func (s *ParagraphNoBreakContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParagraphNoBreakContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParagraphNoBreakContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.EnterParagraphNoBreak(s)
	}
}

func (s *ParagraphNoBreakContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.ExitParagraphNoBreak(s)
	}
}

func (p *ReStructuredTextParser) ParagraphNoBreak() (localctx IParagraphNoBreakContext) {
	this := p
	_ = this

	localctx = NewParagraphNoBreakContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, ReStructuredTextParserRULE_paragraphNoBreak)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(330)
		p.LineNoBreak()
	}
	p.SetState(334)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 37, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(331)
				p.Lines()
			}

		}
		p.SetState(336)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 37, p.GetParserRuleContext())
	}

	return localctx
}

// ILineNoBreakContext is an interface to support dynamic dispatch.
type ILineNoBreakContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLineNoBreakContext differentiates from other interfaces.
	IsLineNoBreakContext()
}

type LineNoBreakContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLineNoBreakContext() *LineNoBreakContext {
	var p = new(LineNoBreakContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ReStructuredTextParserRULE_lineNoBreak
	return p
}

func (*LineNoBreakContext) IsLineNoBreakContext() {}

func NewLineNoBreakContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LineNoBreakContext {
	var p = new(LineNoBreakContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ReStructuredTextParserRULE_lineNoBreak

	return p
}

func (s *LineNoBreakContext) GetParser() antlr.Parser { return s.parser }

func (s *LineNoBreakContext) SpanLineStartNoStar() ISpanLineStartNoStarContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpanLineStartNoStarContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpanLineStartNoStarContext)
}

func (s *LineNoBreakContext) Indentation() IIndentationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIndentationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIndentationContext)
}

func (s *LineNoBreakContext) AllSpan() []ISpanContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISpanContext)(nil)).Elem())
	var tst = make([]ISpanContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISpanContext)
		}
	}

	return tst
}

func (s *LineNoBreakContext) Span(i int) ISpanContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpanContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISpanContext)
}

func (s *LineNoBreakContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LineNoBreakContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LineNoBreakContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.EnterLineNoBreak(s)
	}
}

func (s *LineNoBreakContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.ExitLineNoBreak(s)
	}
}

func (p *ReStructuredTextParser) LineNoBreak() (localctx ILineNoBreakContext) {
	this := p
	_ = this

	localctx = NewLineNoBreakContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, ReStructuredTextParserRULE_lineNoBreak)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(338)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ReStructuredTextParserSpace {
		{
			p.SetState(337)
			p.Indentation()
		}

	}
	{
		p.SetState(340)
		p.SpanLineStartNoStar()
	}
	p.SetState(344)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 39, p.GetParserRuleContext())

	for _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1+1 {
			{
				p.SetState(341)
				p.Span()
			}

		}
		p.SetState(346)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 39, p.GetParserRuleContext())
	}

	return localctx
}

// ILinesContext is an interface to support dynamic dispatch.
type ILinesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLinesContext differentiates from other interfaces.
	IsLinesContext()
}

type LinesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLinesContext() *LinesContext {
	var p = new(LinesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ReStructuredTextParserRULE_lines
	return p
}

func (*LinesContext) IsLinesContext() {}

func NewLinesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LinesContext {
	var p = new(LinesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ReStructuredTextParserRULE_lines

	return p
}

func (s *LinesContext) GetParser() antlr.Parser { return s.parser }

func (s *LinesContext) LinesStar() ILinesStarContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILinesStarContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILinesStarContext)
}

func (s *LinesContext) LinesNormal() ILinesNormalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILinesNormalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILinesNormalContext)
}

func (s *LinesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LinesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LinesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.EnterLines(s)
	}
}

func (s *LinesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.ExitLines(s)
	}
}

func (p *ReStructuredTextParser) Lines() (localctx ILinesContext) {
	this := p
	_ = this

	localctx = NewLinesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, ReStructuredTextParserRULE_lines)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(349)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 40, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(347)
			p.LinesStar()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(348)
			p.LinesNormal()
		}

	}

	return localctx
}

// ILinesNormalContext is an interface to support dynamic dispatch.
type ILinesNormalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLinesNormalContext differentiates from other interfaces.
	IsLinesNormalContext()
}

type LinesNormalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLinesNormalContext() *LinesNormalContext {
	var p = new(LinesNormalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ReStructuredTextParserRULE_linesNormal
	return p
}

func (*LinesNormalContext) IsLinesNormalContext() {}

func NewLinesNormalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LinesNormalContext {
	var p = new(LinesNormalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ReStructuredTextParserRULE_linesNormal

	return p
}

func (s *LinesNormalContext) GetParser() antlr.Parser { return s.parser }

func (s *LinesNormalContext) LineNormal() ILineNormalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILineNormalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILineNormalContext)
}

func (s *LinesNormalContext) LinesStar() ILinesStarContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILinesStarContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILinesStarContext)
}

func (s *LinesNormalContext) LinesNormal() ILinesNormalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILinesNormalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILinesNormalContext)
}

func (s *LinesNormalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LinesNormalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LinesNormalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.EnterLinesNormal(s)
	}
}

func (s *LinesNormalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.ExitLinesNormal(s)
	}
}

func (p *ReStructuredTextParser) LinesNormal() (localctx ILinesNormalContext) {
	this := p
	_ = this

	localctx = NewLinesNormalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, ReStructuredTextParserRULE_linesNormal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(351)
		p.LineNormal()
	}
	p.SetState(356)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 42, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(352)
			p.LinesStar()
		}

	case 2:
		p.SetState(354)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 41, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(353)
				p.LinesNormal()
			}

		}

	}

	return localctx
}

// ILinesStarContext is an interface to support dynamic dispatch.
type ILinesStarContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLinesStarContext differentiates from other interfaces.
	IsLinesStarContext()
}

type LinesStarContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLinesStarContext() *LinesStarContext {
	var p = new(LinesStarContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ReStructuredTextParserRULE_linesStar
	return p
}

func (*LinesStarContext) IsLinesStarContext() {}

func NewLinesStarContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LinesStarContext {
	var p = new(LinesStarContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ReStructuredTextParserRULE_linesStar

	return p
}

func (s *LinesStarContext) GetParser() antlr.Parser { return s.parser }

func (s *LinesStarContext) LineStar() ILineStarContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILineStarContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILineStarContext)
}

func (s *LinesStarContext) LineNoBreak() ILineNoBreakContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILineNoBreakContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILineNoBreakContext)
}

func (s *LinesStarContext) LinesNormal() ILinesNormalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILinesNormalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILinesNormalContext)
}

func (s *LinesStarContext) LinesStar() ILinesStarContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILinesStarContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILinesStarContext)
}

func (s *LinesStarContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LinesStarContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LinesStarContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.EnterLinesStar(s)
	}
}

func (s *LinesStarContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.ExitLinesStar(s)
	}
}

func (p *ReStructuredTextParser) LinesStar() (localctx ILinesStarContext) {
	this := p
	_ = this

	localctx = NewLinesStarContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, ReStructuredTextParserRULE_linesStar)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(368)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 44, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(358)
			p.LineStar()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(359)
			p.LineStar()
		}
		{
			p.SetState(360)
			p.LineNoBreak()
		}
		p.SetState(362)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 43, p.GetParserRuleContext()) == 1+1 {
			{
				p.SetState(361)
				p.LinesNormal()
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(364)
			p.LineStar()
		}
		{
			p.SetState(365)
			p.LineNoBreak()
		}
		{
			p.SetState(366)
			p.LinesStar()
		}

	}

	return localctx
}

// ILineNormalContext is an interface to support dynamic dispatch.
type ILineNormalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLineNormalContext differentiates from other interfaces.
	IsLineNormalContext()
}

type LineNormalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLineNormalContext() *LineNormalContext {
	var p = new(LineNormalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ReStructuredTextParserRULE_lineNormal
	return p
}

func (*LineNormalContext) IsLineNormalContext() {}

func NewLineNormalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LineNormalContext {
	var p = new(LineNormalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ReStructuredTextParserRULE_lineNormal

	return p
}

func (s *LineNormalContext) GetParser() antlr.Parser { return s.parser }

func (s *LineNormalContext) LineBreak() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserLineBreak, 0)
}

func (s *LineNormalContext) Indentation() IIndentationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIndentationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIndentationContext)
}

func (s *LineNormalContext) AllSpanLineStartNoStar() []ISpanLineStartNoStarContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISpanLineStartNoStarContext)(nil)).Elem())
	var tst = make([]ISpanLineStartNoStarContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISpanLineStartNoStarContext)
		}
	}

	return tst
}

func (s *LineNormalContext) SpanLineStartNoStar(i int) ISpanLineStartNoStarContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpanLineStartNoStarContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISpanLineStartNoStarContext)
}

func (s *LineNormalContext) AllSpan() []ISpanContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISpanContext)(nil)).Elem())
	var tst = make([]ISpanContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISpanContext)
		}
	}

	return tst
}

func (s *LineNormalContext) Span(i int) ISpanContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpanContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISpanContext)
}

func (s *LineNormalContext) AllSpanNoStar() []ISpanNoStarContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISpanNoStarContext)(nil)).Elem())
	var tst = make([]ISpanNoStarContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISpanNoStarContext)
		}
	}

	return tst
}

func (s *LineNormalContext) SpanNoStar(i int) ISpanNoStarContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpanNoStarContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISpanNoStarContext)
}

func (s *LineNormalContext) LineSpecial() ILineSpecialContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILineSpecialContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILineSpecialContext)
}

func (s *LineNormalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LineNormalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LineNormalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.EnterLineNormal(s)
	}
}

func (s *LineNormalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.ExitLineNormal(s)
	}
}

func (p *ReStructuredTextParser) LineNormal() (localctx ILineNormalContext) {
	this := p
	_ = this

	localctx = NewLineNormalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, ReStructuredTextParserRULE_lineNormal)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(393)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 50, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(370)
			p.Match(ReStructuredTextParserLineBreak)
		}
		p.SetState(372)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ReStructuredTextParserSpace {
			{
				p.SetState(371)
				p.Indentation()
			}

		}
		p.SetState(375)
		p.GetErrorHandler().Sync(p)
		_alt = 1 + 1
		for ok := true; ok; ok = _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1 + 1:
				{
					p.SetState(374)
					p.SpanLineStartNoStar()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(377)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 46, p.GetParserRuleContext())
		}
		p.SetState(390)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 49, p.GetParserRuleContext()) == 1 {
			p.SetState(382)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 47, p.GetParserRuleContext())

			for _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1+1 {
					{
						p.SetState(379)
						p.Span()
					}

				}
				p.SetState(384)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 47, p.GetParserRuleContext())
			}
			p.SetState(386)
			p.GetErrorHandler().Sync(p)
			_alt = 1 + 1
			for ok := true; ok; ok = _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
				switch _alt {
				case 1 + 1:
					{
						p.SetState(385)
						p.SpanNoStar()
					}

				default:
					panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				}

				p.SetState(388)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 48, p.GetParserRuleContext())
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(392)
			p.LineSpecial()
		}

	}

	return localctx
}

// ILineStarContext is an interface to support dynamic dispatch.
type ILineStarContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLineStarContext differentiates from other interfaces.
	IsLineStarContext()
}

type LineStarContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLineStarContext() *LineStarContext {
	var p = new(LineStarContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ReStructuredTextParserRULE_lineStar
	return p
}

func (*LineStarContext) IsLineStarContext() {}

func NewLineStarContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LineStarContext {
	var p = new(LineStarContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ReStructuredTextParserRULE_lineStar

	return p
}

func (s *LineStarContext) GetParser() antlr.Parser { return s.parser }

func (s *LineStarContext) LineBreak() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserLineBreak, 0)
}

func (s *LineStarContext) StarText() IStarTextContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStarTextContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStarTextContext)
}

func (s *LineStarContext) Indentation() IIndentationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIndentationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIndentationContext)
}

func (s *LineStarContext) AllSpanLineStartNoStar() []ISpanLineStartNoStarContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISpanLineStartNoStarContext)(nil)).Elem())
	var tst = make([]ISpanLineStartNoStarContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISpanLineStartNoStarContext)
		}
	}

	return tst
}

func (s *LineStarContext) SpanLineStartNoStar(i int) ISpanLineStartNoStarContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpanLineStartNoStarContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISpanLineStartNoStarContext)
}

func (s *LineStarContext) AllText_fragment() []IText_fragmentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IText_fragmentContext)(nil)).Elem())
	var tst = make([]IText_fragmentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IText_fragmentContext)
		}
	}

	return tst
}

func (s *LineStarContext) Text_fragment(i int) IText_fragmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IText_fragmentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IText_fragmentContext)
}

func (s *LineStarContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LineStarContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LineStarContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.EnterLineStar(s)
	}
}

func (s *LineStarContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.ExitLineStar(s)
	}
}

func (p *ReStructuredTextParser) LineStar() (localctx ILineStarContext) {
	this := p
	_ = this

	localctx = NewLineStarContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, ReStructuredTextParserRULE_lineStar)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(417)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 55, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(395)
			p.Match(ReStructuredTextParserLineBreak)
		}
		p.SetState(397)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ReStructuredTextParserSpace {
			{
				p.SetState(396)
				p.Indentation()
			}

		}
		p.SetState(402)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 52, p.GetParserRuleContext())

		for _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1+1 {
				{
					p.SetState(399)
					p.SpanLineStartNoStar()
				}

			}
			p.SetState(404)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 52, p.GetParserRuleContext())
		}
		{
			p.SetState(405)
			p.StarText()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(406)
			p.Match(ReStructuredTextParserLineBreak)
		}
		p.SetState(408)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 53, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(407)
				p.Indentation()
			}

		}
		p.SetState(411)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(410)
					p.Text_fragment()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(413)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 54, p.GetParserRuleContext())
		}
		{
			p.SetState(415)
			p.StarText()
		}

	}

	return localctx
}

// ILineSpecialContext is an interface to support dynamic dispatch.
type ILineSpecialContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLineSpecialContext differentiates from other interfaces.
	IsLineSpecialContext()
}

type LineSpecialContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLineSpecialContext() *LineSpecialContext {
	var p = new(LineSpecialContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ReStructuredTextParserRULE_lineSpecial
	return p
}

func (*LineSpecialContext) IsLineSpecialContext() {}

func NewLineSpecialContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LineSpecialContext {
	var p = new(LineSpecialContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ReStructuredTextParserRULE_lineSpecial

	return p
}

func (s *LineSpecialContext) GetParser() antlr.Parser { return s.parser }

func (s *LineSpecialContext) Numbers() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserNumbers, 0)
}

func (s *LineSpecialContext) Dot() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserDot, 0)
}

func (s *LineSpecialContext) LineBreak() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserLineBreak, 0)
}

func (s *LineSpecialContext) Indentation() IIndentationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIndentationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIndentationContext)
}

func (s *LineSpecialContext) AllSectionSeparator() []antlr.TerminalNode {
	return s.GetTokens(ReStructuredTextParserSectionSeparator)
}

func (s *LineSpecialContext) SectionSeparator(i int) antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserSectionSeparator, i)
}

func (s *LineSpecialContext) AllSpace() []antlr.TerminalNode {
	return s.GetTokens(ReStructuredTextParserSpace)
}

func (s *LineSpecialContext) Space(i int) antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserSpace, i)
}

func (s *LineSpecialContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LineSpecialContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LineSpecialContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.EnterLineSpecial(s)
	}
}

func (s *LineSpecialContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.ExitLineSpecial(s)
	}
}

func (p *ReStructuredTextParser) LineSpecial() (localctx ILineSpecialContext) {
	this := p
	_ = this

	localctx = NewLineSpecialContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, ReStructuredTextParserRULE_lineSpecial)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(444)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 60, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(419)
			p.Match(ReStructuredTextParserNumbers)
		}
		{
			p.SetState(420)
			p.Match(ReStructuredTextParserDot)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(421)
			p.Match(ReStructuredTextParserLineBreak)
		}
		p.SetState(423)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ReStructuredTextParserSpace {
			{
				p.SetState(422)
				p.Indentation()
			}

		}
		{
			p.SetState(425)
			p.Match(ReStructuredTextParserNumbers)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(426)
			p.Match(ReStructuredTextParserLineBreak)
		}
		p.SetState(428)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ReStructuredTextParserSpace {
			{
				p.SetState(427)
				p.Indentation()
			}

		}
		{
			p.SetState(430)
			p.Match(ReStructuredTextParserSectionSeparator)
		}

		p.SetState(432)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == ReStructuredTextParserSpace {
			{
				p.SetState(431)
				p.Match(ReStructuredTextParserSpace)
			}

			p.SetState(434)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(436)
			p.Match(ReStructuredTextParserSectionSeparator)
		}

		p.SetState(441)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 59, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(438)
					p.Match(ReStructuredTextParserSpace)
				}

			}
			p.SetState(443)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 59, p.GetParserRuleContext())
		}

	}

	return localctx
}

// IEmpty_lineContext is an interface to support dynamic dispatch.
type IEmpty_lineContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEmpty_lineContext differentiates from other interfaces.
	IsEmpty_lineContext()
}

type Empty_lineContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEmpty_lineContext() *Empty_lineContext {
	var p = new(Empty_lineContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ReStructuredTextParserRULE_empty_line
	return p
}

func (*Empty_lineContext) IsEmpty_lineContext() {}

func NewEmpty_lineContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Empty_lineContext {
	var p = new(Empty_lineContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ReStructuredTextParserRULE_empty_line

	return p
}

func (s *Empty_lineContext) GetParser() antlr.Parser { return s.parser }

func (s *Empty_lineContext) LineBreak() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserLineBreak, 0)
}

func (s *Empty_lineContext) AllSpace() []antlr.TerminalNode {
	return s.GetTokens(ReStructuredTextParserSpace)
}

func (s *Empty_lineContext) Space(i int) antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserSpace, i)
}

func (s *Empty_lineContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Empty_lineContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Empty_lineContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.EnterEmpty_line(s)
	}
}

func (s *Empty_lineContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.ExitEmpty_line(s)
	}
}

func (p *ReStructuredTextParser) Empty_line() (localctx IEmpty_lineContext) {
	this := p
	_ = this

	localctx = NewEmpty_lineContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, ReStructuredTextParserRULE_empty_line)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(446)
		p.Match(ReStructuredTextParserLineBreak)
	}
	p.SetState(450)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 61, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(447)
				p.Match(ReStructuredTextParserSpace)
			}

		}
		p.SetState(452)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 61, p.GetParserRuleContext())
	}

	return localctx
}

// IIndentationContext is an interface to support dynamic dispatch.
type IIndentationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIndentationContext differentiates from other interfaces.
	IsIndentationContext()
}

type IndentationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndentationContext() *IndentationContext {
	var p = new(IndentationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ReStructuredTextParserRULE_indentation
	return p
}

func (*IndentationContext) IsIndentationContext() {}

func NewIndentationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndentationContext {
	var p = new(IndentationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ReStructuredTextParserRULE_indentation

	return p
}

func (s *IndentationContext) GetParser() antlr.Parser { return s.parser }

func (s *IndentationContext) AllSpace() []antlr.TerminalNode {
	return s.GetTokens(ReStructuredTextParserSpace)
}

func (s *IndentationContext) Space(i int) antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserSpace, i)
}

func (s *IndentationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndentationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndentationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.EnterIndentation(s)
	}
}

func (s *IndentationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.ExitIndentation(s)
	}
}

func (p *ReStructuredTextParser) Indentation() (localctx IIndentationContext) {
	this := p
	_ = this

	localctx = NewIndentationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, ReStructuredTextParserRULE_indentation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(454)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(453)
				p.Match(ReStructuredTextParserSpace)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(456)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 62, p.GetParserRuleContext())
	}

	return localctx
}

// ISpanLineStartNoStarContext is an interface to support dynamic dispatch.
type ISpanLineStartNoStarContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSpanLineStartNoStarContext differentiates from other interfaces.
	IsSpanLineStartNoStarContext()
}

type SpanLineStartNoStarContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpanLineStartNoStarContext() *SpanLineStartNoStarContext {
	var p = new(SpanLineStartNoStarContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ReStructuredTextParserRULE_spanLineStartNoStar
	return p
}

func (*SpanLineStartNoStarContext) IsSpanLineStartNoStarContext() {}

func NewSpanLineStartNoStarContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SpanLineStartNoStarContext {
	var p = new(SpanLineStartNoStarContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ReStructuredTextParserRULE_spanLineStartNoStar

	return p
}

func (s *SpanLineStartNoStarContext) GetParser() antlr.Parser { return s.parser }

func (s *SpanLineStartNoStarContext) Reference() IReferenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReferenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReferenceContext)
}

func (s *SpanLineStartNoStarContext) ReferenceIn() IReferenceInContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReferenceInContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReferenceInContext)
}

func (s *SpanLineStartNoStarContext) HyperlinkTarget() IHyperlinkTargetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHyperlinkTargetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHyperlinkTargetContext)
}

func (s *SpanLineStartNoStarContext) Hyperlink() IHyperlinkContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHyperlinkContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHyperlinkContext)
}

func (s *SpanLineStartNoStarContext) HyperlinkDoc() IHyperlinkDocContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHyperlinkDocContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHyperlinkDocContext)
}

func (s *SpanLineStartNoStarContext) BackTickText() IBackTickTextContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBackTickTextContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBackTickTextContext)
}

func (s *SpanLineStartNoStarContext) QuotedLiteral() IQuotedLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuotedLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQuotedLiteralContext)
}

func (s *SpanLineStartNoStarContext) TextLineStart() ITextLineStartContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITextLineStartContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITextLineStartContext)
}

func (s *SpanLineStartNoStarContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpanLineStartNoStarContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SpanLineStartNoStarContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.EnterSpanLineStartNoStar(s)
	}
}

func (s *SpanLineStartNoStarContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.ExitSpanLineStartNoStar(s)
	}
}

func (p *ReStructuredTextParser) SpanLineStartNoStar() (localctx ISpanLineStartNoStarContext) {
	this := p
	_ = this

	localctx = NewSpanLineStartNoStarContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, ReStructuredTextParserRULE_spanLineStartNoStar)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(466)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 63, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(458)
			p.Reference()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(459)
			p.ReferenceIn()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(460)
			p.HyperlinkTarget()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(461)
			p.Hyperlink()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(462)
			p.HyperlinkDoc()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(463)
			p.BackTickText()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(464)
			p.QuotedLiteral()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(465)
			p.TextLineStart()
		}

	}

	return localctx
}

// ITextLineStartContext is an interface to support dynamic dispatch.
type ITextLineStartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTextLineStartContext differentiates from other interfaces.
	IsTextLineStartContext()
}

type TextLineStartContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTextLineStartContext() *TextLineStartContext {
	var p = new(TextLineStartContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ReStructuredTextParserRULE_textLineStart
	return p
}

func (*TextLineStartContext) IsTextLineStartContext() {}

func NewTextLineStartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TextLineStartContext {
	var p = new(TextLineStartContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ReStructuredTextParserRULE_textLineStart

	return p
}

func (s *TextLineStartContext) GetParser() antlr.Parser { return s.parser }

func (s *TextLineStartContext) AllLineStart_fragment() []ILineStart_fragmentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILineStart_fragmentContext)(nil)).Elem())
	var tst = make([]ILineStart_fragmentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILineStart_fragmentContext)
		}
	}

	return tst
}

func (s *TextLineStartContext) LineStart_fragment(i int) ILineStart_fragmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILineStart_fragmentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILineStart_fragmentContext)
}

func (s *TextLineStartContext) AllText_fragment() []IText_fragmentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IText_fragmentContext)(nil)).Elem())
	var tst = make([]IText_fragmentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IText_fragmentContext)
		}
	}

	return tst
}

func (s *TextLineStartContext) Text_fragment(i int) IText_fragmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IText_fragmentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IText_fragmentContext)
}

func (s *TextLineStartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TextLineStartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TextLineStartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.EnterTextLineStart(s)
	}
}

func (s *TextLineStartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.ExitTextLineStart(s)
	}
}

func (p *ReStructuredTextParser) TextLineStart() (localctx ITextLineStartContext) {
	this := p
	_ = this

	localctx = NewTextLineStartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, ReStructuredTextParserRULE_textLineStart)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(469)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(468)
				p.LineStart_fragment()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(471)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 64, p.GetParserRuleContext())
	}
	p.SetState(476)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 65, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(473)
				p.Text_fragment()
			}

		}
		p.SetState(478)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 65, p.GetParserRuleContext())
	}

	return localctx
}

// ILineStart_fragmentContext is an interface to support dynamic dispatch.
type ILineStart_fragmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLineStart_fragmentContext differentiates from other interfaces.
	IsLineStart_fragmentContext()
}

type LineStart_fragmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLineStart_fragmentContext() *LineStart_fragmentContext {
	var p = new(LineStart_fragmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ReStructuredTextParserRULE_lineStart_fragment
	return p
}

func (*LineStart_fragmentContext) IsLineStart_fragmentContext() {}

func NewLineStart_fragmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LineStart_fragmentContext {
	var p = new(LineStart_fragmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ReStructuredTextParserRULE_lineStart_fragment

	return p
}

func (s *LineStart_fragmentContext) GetParser() antlr.Parser { return s.parser }

func (s *LineStart_fragmentContext) Minus() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserMinus, 0)
}

func (s *LineStart_fragmentContext) Space() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserSpace, 0)
}

func (s *LineStart_fragmentContext) LineBreak() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserLineBreak, 0)
}

func (s *LineStart_fragmentContext) Star() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserStar, 0)
}

func (s *LineStart_fragmentContext) Plus() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserPlus, 0)
}

func (s *LineStart_fragmentContext) Numbers() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserNumbers, 0)
}

func (s *LineStart_fragmentContext) Dot() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserDot, 0)
}

func (s *LineStart_fragmentContext) Alphabet() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserAlphabet, 0)
}

func (s *LineStart_fragmentContext) Block() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserBlock, 0)
}

func (s *LineStart_fragmentContext) UnderScore() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserUnderScore, 0)
}

func (s *LineStart_fragmentContext) AllSeparator() []ISeparatorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISeparatorContext)(nil)).Elem())
	var tst = make([]ISeparatorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISeparatorContext)
		}
	}

	return tst
}

func (s *LineStart_fragmentContext) Separator(i int) ISeparatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISeparatorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISeparatorContext)
}

func (s *LineStart_fragmentContext) TimeStar() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserTimeStar, 0)
}

func (s *LineStart_fragmentContext) SquareLeft() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserSquareLeft, 0)
}

func (s *LineStart_fragmentContext) SquareRight() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserSquareRight, 0)
}

func (s *LineStart_fragmentContext) RoundLeft() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserRoundLeft, 0)
}

func (s *LineStart_fragmentContext) RoundRight() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserRoundRight, 0)
}

func (s *LineStart_fragmentContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserSemiColon, 0)
}

func (s *LineStart_fragmentContext) Colon() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserColon, 0)
}

func (s *LineStart_fragmentContext) QuotationDouble() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserQuotationDouble, 0)
}

func (s *LineStart_fragmentContext) QuotationSingle() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserQuotationSingle, 0)
}

func (s *LineStart_fragmentContext) AngleLeft() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserAngleLeft, 0)
}

func (s *LineStart_fragmentContext) AngleRight() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserAngleRight, 0)
}

func (s *LineStart_fragmentContext) Any() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserAny, 0)
}

func (s *LineStart_fragmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LineStart_fragmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LineStart_fragmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.EnterLineStart_fragment(s)
	}
}

func (s *LineStart_fragmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.ExitLineStart_fragment(s)
	}
}

func (p *ReStructuredTextParser) LineStart_fragment() (localctx ILineStart_fragmentContext) {
	this := p
	_ = this

	localctx = NewLineStart_fragmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, ReStructuredTextParserRULE_lineStart_fragment)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(514)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 66, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(479)
			p.Match(ReStructuredTextParserMinus)
		}
		{
			p.SetState(480)
			_la = p.GetTokenStream().LA(1)

			if _la <= 0 || (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ReStructuredTextParserStar)|(1<<ReStructuredTextParserSpace)|(1<<ReStructuredTextParserLineBreak))) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(481)
			p.Match(ReStructuredTextParserPlus)
		}
		{
			p.SetState(482)
			_la = p.GetTokenStream().LA(1)

			if _la <= 0 || _la == ReStructuredTextParserStar || _la == ReStructuredTextParserSpace {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(483)
			p.Match(ReStructuredTextParserNumbers)
		}
		{
			p.SetState(484)
			p.Match(ReStructuredTextParserDot)
		}
		{
			p.SetState(485)
			_la = p.GetTokenStream().LA(1)

			if _la <= 0 || (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ReStructuredTextParserStar)|(1<<ReStructuredTextParserSpace)|(1<<ReStructuredTextParserLineBreak))) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(486)
			p.Match(ReStructuredTextParserNumbers)
		}
		{
			p.SetState(487)
			_la = p.GetTokenStream().LA(1)

			if _la <= 0 || (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ReStructuredTextParserDot)|(1<<ReStructuredTextParserStar)|(1<<ReStructuredTextParserLineBreak))) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(488)
			p.Match(ReStructuredTextParserAlphabet)
		}
		{
			p.SetState(489)
			p.Match(ReStructuredTextParserDot)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(490)
			p.Match(ReStructuredTextParserBlock)
		}
		{
			p.SetState(491)
			_la = p.GetTokenStream().LA(1)

			if _la <= 0 || _la == ReStructuredTextParserStar || _la == ReStructuredTextParserSpace {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(492)
			p.Match(ReStructuredTextParserUnderScore)
		}
		{
			p.SetState(493)
			_la = p.GetTokenStream().LA(1)

			if _la <= 0 || _la == ReStructuredTextParserStar || _la == ReStructuredTextParserSpace {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(494)
			p.Match(ReStructuredTextParserAlphabet)
		}
		{
			p.SetState(495)
			_la = p.GetTokenStream().LA(1)

			if _la <= 0 || (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ReStructuredTextParserDot)|(1<<ReStructuredTextParserStar)|(1<<ReStructuredTextParserLineBreak))) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(496)
			p.Match(ReStructuredTextParserAlphabet)
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(497)
			p.Separator()
		}
		{
			p.SetState(498)
			p.Separator()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(500)
			p.Match(ReStructuredTextParserTimeStar)
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(501)
			p.Match(ReStructuredTextParserSquareLeft)
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(502)
			p.Match(ReStructuredTextParserSquareRight)
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(503)
			p.Match(ReStructuredTextParserRoundLeft)
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(504)
			p.Match(ReStructuredTextParserRoundRight)
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(505)
			p.Match(ReStructuredTextParserSemiColon)
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(506)
			p.Match(ReStructuredTextParserColon)
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(507)
			p.Match(ReStructuredTextParserQuotationDouble)
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(508)
			p.Match(ReStructuredTextParserQuotationSingle)
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(509)
			p.Match(ReStructuredTextParserDot)
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(510)
			p.Match(ReStructuredTextParserUnderScore)
		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(511)
			p.Match(ReStructuredTextParserAngleLeft)
		}

	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(512)
			p.Match(ReStructuredTextParserAngleRight)
		}

	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(513)
			p.Match(ReStructuredTextParserAny)
		}

	}

	return localctx
}

// ITextContext is an interface to support dynamic dispatch.
type ITextContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTextContext differentiates from other interfaces.
	IsTextContext()
}

type TextContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTextContext() *TextContext {
	var p = new(TextContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ReStructuredTextParserRULE_text
	return p
}

func (*TextContext) IsTextContext() {}

func NewTextContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TextContext {
	var p = new(TextContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ReStructuredTextParserRULE_text

	return p
}

func (s *TextContext) GetParser() antlr.Parser { return s.parser }

func (s *TextContext) AllTextStart() []ITextStartContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITextStartContext)(nil)).Elem())
	var tst = make([]ITextStartContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITextStartContext)
		}
	}

	return tst
}

func (s *TextContext) TextStart(i int) ITextStartContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITextStartContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITextStartContext)
}

func (s *TextContext) AllText_fragment() []IText_fragmentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IText_fragmentContext)(nil)).Elem())
	var tst = make([]IText_fragmentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IText_fragmentContext)
		}
	}

	return tst
}

func (s *TextContext) Text_fragment(i int) IText_fragmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IText_fragmentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IText_fragmentContext)
}

func (s *TextContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TextContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TextContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.EnterText(s)
	}
}

func (s *TextContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.ExitText(s)
	}
}

func (p *ReStructuredTextParser) Text() (localctx ITextContext) {
	this := p
	_ = this

	localctx = NewTextContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, ReStructuredTextParserRULE_text)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(517)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(516)
				p.TextStart()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(519)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 67, p.GetParserRuleContext())
	}
	p.SetState(524)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 68, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(521)
				p.Text_fragment()
			}

		}
		p.SetState(526)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 68, p.GetParserRuleContext())
	}

	return localctx
}

// ITextStartContext is an interface to support dynamic dispatch.
type ITextStartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTextStartContext differentiates from other interfaces.
	IsTextStartContext()
}

type TextStartContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTextStartContext() *TextStartContext {
	var p = new(TextStartContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ReStructuredTextParserRULE_textStart
	return p
}

func (*TextStartContext) IsTextStartContext() {}

func NewTextStartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TextStartContext {
	var p = new(TextStartContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ReStructuredTextParserRULE_textStart

	return p
}

func (s *TextStartContext) GetParser() antlr.Parser { return s.parser }

func (s *TextStartContext) ForcedText() IForcedTextContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IForcedTextContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IForcedTextContext)
}

func (s *TextStartContext) LineStart_fragment() ILineStart_fragmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILineStart_fragmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILineStart_fragmentContext)
}

func (s *TextStartContext) AllText_fragment_start() []IText_fragment_startContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IText_fragment_startContext)(nil)).Elem())
	var tst = make([]IText_fragment_startContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IText_fragment_startContext)
		}
	}

	return tst
}

func (s *TextStartContext) Text_fragment_start(i int) IText_fragment_startContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IText_fragment_startContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IText_fragment_startContext)
}

func (s *TextStartContext) Space() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserSpace, 0)
}

func (s *TextStartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TextStartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TextStartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.EnterTextStart(s)
	}
}

func (s *TextStartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.ExitTextStart(s)
	}
}

func (p *ReStructuredTextParser) TextStart() (localctx ITextStartContext) {
	this := p
	_ = this

	localctx = NewTextStartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, ReStructuredTextParserRULE_textStart)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(536)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 70, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(527)
			p.ForcedText()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(528)
			p.LineStart_fragment()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(529)
			p.Text_fragment_start()
		}
		p.SetState(531)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(530)
					p.Text_fragment_start()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(533)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 69, p.GetParserRuleContext())
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(535)
			p.Match(ReStructuredTextParserSpace)
		}

	}

	return localctx
}

// IForcedTextContext is an interface to support dynamic dispatch.
type IForcedTextContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsForcedTextContext differentiates from other interfaces.
	IsForcedTextContext()
}

type ForcedTextContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForcedTextContext() *ForcedTextContext {
	var p = new(ForcedTextContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ReStructuredTextParserRULE_forcedText
	return p
}

func (*ForcedTextContext) IsForcedTextContext() {}

func NewForcedTextContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForcedTextContext {
	var p = new(ForcedTextContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ReStructuredTextParserRULE_forcedText

	return p
}

func (s *ForcedTextContext) GetParser() antlr.Parser { return s.parser }

func (s *ForcedTextContext) RoundLeft() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserRoundLeft, 0)
}

func (s *ForcedTextContext) Star() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserStar, 0)
}

func (s *ForcedTextContext) RoundRight() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserRoundRight, 0)
}

func (s *ForcedTextContext) SquareLeft() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserSquareLeft, 0)
}

func (s *ForcedTextContext) SquareRight() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserSquareRight, 0)
}

func (s *ForcedTextContext) AllQuotationSingle() []antlr.TerminalNode {
	return s.GetTokens(ReStructuredTextParserQuotationSingle)
}

func (s *ForcedTextContext) QuotationSingle(i int) antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserQuotationSingle, i)
}

func (s *ForcedTextContext) AllQuotationDouble() []antlr.TerminalNode {
	return s.GetTokens(ReStructuredTextParserQuotationDouble)
}

func (s *ForcedTextContext) QuotationDouble(i int) antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserQuotationDouble, i)
}

func (s *ForcedTextContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForcedTextContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForcedTextContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.EnterForcedText(s)
	}
}

func (s *ForcedTextContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.ExitForcedText(s)
	}
}

func (p *ReStructuredTextParser) ForcedText() (localctx IForcedTextContext) {
	this := p
	_ = this

	localctx = NewForcedTextContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, ReStructuredTextParserRULE_forcedText)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(552)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 71, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(538)
			p.Match(ReStructuredTextParserRoundLeft)
		}
		{
			p.SetState(539)
			p.Match(ReStructuredTextParserStar)
		}
		{
			p.SetState(540)
			p.Match(ReStructuredTextParserRoundRight)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(541)
			p.Match(ReStructuredTextParserSquareLeft)
		}
		{
			p.SetState(542)
			p.Match(ReStructuredTextParserStar)
		}
		{
			p.SetState(543)
			p.Match(ReStructuredTextParserSquareRight)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(544)
			p.Match(ReStructuredTextParserQuotationSingle)
		}
		{
			p.SetState(545)
			p.Match(ReStructuredTextParserStar)
		}
		{
			p.SetState(546)
			p.Match(ReStructuredTextParserQuotationSingle)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(547)
			p.Match(ReStructuredTextParserQuotationSingle)
		}
		{
			p.SetState(548)
			p.Match(ReStructuredTextParserQuotationDouble)
		}
		{
			p.SetState(549)
			p.Match(ReStructuredTextParserStar)
		}
		{
			p.SetState(550)
			p.Match(ReStructuredTextParserQuotationDouble)
		}
		{
			p.SetState(551)
			p.Match(ReStructuredTextParserQuotationSingle)
		}

	}

	return localctx
}

// ISpanNoStarContext is an interface to support dynamic dispatch.
type ISpanNoStarContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSpanNoStarContext differentiates from other interfaces.
	IsSpanNoStarContext()
}

type SpanNoStarContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpanNoStarContext() *SpanNoStarContext {
	var p = new(SpanNoStarContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ReStructuredTextParserRULE_spanNoStar
	return p
}

func (*SpanNoStarContext) IsSpanNoStarContext() {}

func NewSpanNoStarContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SpanNoStarContext {
	var p = new(SpanNoStarContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ReStructuredTextParserRULE_spanNoStar

	return p
}

func (s *SpanNoStarContext) GetParser() antlr.Parser { return s.parser }

func (s *SpanNoStarContext) Reference() IReferenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReferenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReferenceContext)
}

func (s *SpanNoStarContext) ReferenceIn() IReferenceInContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReferenceInContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReferenceInContext)
}

func (s *SpanNoStarContext) HyperlinkTarget() IHyperlinkTargetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHyperlinkTargetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHyperlinkTargetContext)
}

func (s *SpanNoStarContext) Hyperlink() IHyperlinkContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHyperlinkContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHyperlinkContext)
}

func (s *SpanNoStarContext) HyperlinkDoc() IHyperlinkDocContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHyperlinkDocContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHyperlinkDocContext)
}

func (s *SpanNoStarContext) BackTickText() IBackTickTextContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBackTickTextContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBackTickTextContext)
}

func (s *SpanNoStarContext) QuotedLiteral() IQuotedLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuotedLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQuotedLiteralContext)
}

func (s *SpanNoStarContext) Text() ITextContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITextContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITextContext)
}

func (s *SpanNoStarContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpanNoStarContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SpanNoStarContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.EnterSpanNoStar(s)
	}
}

func (s *SpanNoStarContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.ExitSpanNoStar(s)
	}
}

func (p *ReStructuredTextParser) SpanNoStar() (localctx ISpanNoStarContext) {
	this := p
	_ = this

	localctx = NewSpanNoStarContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, ReStructuredTextParserRULE_spanNoStar)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(562)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 72, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(554)
			p.Reference()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(555)
			p.ReferenceIn()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(556)
			p.HyperlinkTarget()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(557)
			p.Hyperlink()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(558)
			p.HyperlinkDoc()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(559)
			p.BackTickText()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(560)
			p.QuotedLiteral()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(561)
			p.Text()
		}

	}

	return localctx
}

// ISpanContext is an interface to support dynamic dispatch.
type ISpanContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSpanContext differentiates from other interfaces.
	IsSpanContext()
}

type SpanContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpanContext() *SpanContext {
	var p = new(SpanContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ReStructuredTextParserRULE_span
	return p
}

func (*SpanContext) IsSpanContext() {}

func NewSpanContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SpanContext {
	var p = new(SpanContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ReStructuredTextParserRULE_span

	return p
}

func (s *SpanContext) GetParser() antlr.Parser { return s.parser }

func (s *SpanContext) StarText() IStarTextContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStarTextContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStarTextContext)
}

func (s *SpanContext) SpanNoStar() ISpanNoStarContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpanNoStarContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpanNoStarContext)
}

func (s *SpanContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpanContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SpanContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.EnterSpan(s)
	}
}

func (s *SpanContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.ExitSpan(s)
	}
}

func (p *ReStructuredTextParser) Span() (localctx ISpanContext) {
	this := p
	_ = this

	localctx = NewSpanContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, ReStructuredTextParserRULE_span)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(566)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 73, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(564)
			p.StarText()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(565)
			p.SpanNoStar()
		}

	}

	return localctx
}

// IQuotedLiteralContext is an interface to support dynamic dispatch.
type IQuotedLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQuotedLiteralContext differentiates from other interfaces.
	IsQuotedLiteralContext()
}

type QuotedLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuotedLiteralContext() *QuotedLiteralContext {
	var p = new(QuotedLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ReStructuredTextParserRULE_quotedLiteral
	return p
}

func (*QuotedLiteralContext) IsQuotedLiteralContext() {}

func NewQuotedLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuotedLiteralContext {
	var p = new(QuotedLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ReStructuredTextParserRULE_quotedLiteral

	return p
}

func (s *QuotedLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *QuotedLiteralContext) AngleRight() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserAngleRight, 0)
}

func (s *QuotedLiteralContext) Space() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserSpace, 0)
}

func (s *QuotedLiteralContext) LineNoBreak() ILineNoBreakContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILineNoBreakContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILineNoBreakContext)
}

func (s *QuotedLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuotedLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QuotedLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.EnterQuotedLiteral(s)
	}
}

func (s *QuotedLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.ExitQuotedLiteral(s)
	}
}

func (p *ReStructuredTextParser) QuotedLiteral() (localctx IQuotedLiteralContext) {
	this := p
	_ = this

	localctx = NewQuotedLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, ReStructuredTextParserRULE_quotedLiteral)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(568)
		p.Match(ReStructuredTextParserAngleRight)
	}
	{
		p.SetState(569)
		p.Match(ReStructuredTextParserSpace)
	}
	{
		p.SetState(570)
		p.LineNoBreak()
	}

	return localctx
}

// IText_fragment_startContext is an interface to support dynamic dispatch.
type IText_fragment_startContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsText_fragment_startContext differentiates from other interfaces.
	IsText_fragment_startContext()
}

type Text_fragment_startContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyText_fragment_startContext() *Text_fragment_startContext {
	var p = new(Text_fragment_startContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ReStructuredTextParserRULE_text_fragment_start
	return p
}

func (*Text_fragment_startContext) IsText_fragment_startContext() {}

func NewText_fragment_startContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Text_fragment_startContext {
	var p = new(Text_fragment_startContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ReStructuredTextParserRULE_text_fragment_start

	return p
}

func (s *Text_fragment_startContext) GetParser() antlr.Parser { return s.parser }

func (s *Text_fragment_startContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserSemiColon, 0)
}

func (s *Text_fragment_startContext) Numbers() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserNumbers, 0)
}

func (s *Text_fragment_startContext) Alphabet() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserAlphabet, 0)
}

func (s *Text_fragment_startContext) Space() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserSpace, 0)
}

func (s *Text_fragment_startContext) SquareLeft() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserSquareLeft, 0)
}

func (s *Text_fragment_startContext) SquareRight() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserSquareRight, 0)
}

func (s *Text_fragment_startContext) RoundLeft() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserRoundLeft, 0)
}

func (s *Text_fragment_startContext) RoundRight() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserRoundRight, 0)
}

func (s *Text_fragment_startContext) Colon() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserColon, 0)
}

func (s *Text_fragment_startContext) Separator() ISeparatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISeparatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISeparatorContext)
}

func (s *Text_fragment_startContext) AngleLeft() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserAngleLeft, 0)
}

func (s *Text_fragment_startContext) AngleRight() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserAngleRight, 0)
}

func (s *Text_fragment_startContext) QuotationDouble() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserQuotationDouble, 0)
}

func (s *Text_fragment_startContext) Dot() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserDot, 0)
}

func (s *Text_fragment_startContext) Star() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserStar, 0)
}

func (s *Text_fragment_startContext) Any() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserAny, 0)
}

func (s *Text_fragment_startContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Text_fragment_startContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Text_fragment_startContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.EnterText_fragment_start(s)
	}
}

func (s *Text_fragment_startContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.ExitText_fragment_start(s)
	}
}

func (p *ReStructuredTextParser) Text_fragment_start() (localctx IText_fragment_startContext) {
	this := p
	_ = this

	localctx = NewText_fragment_startContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, ReStructuredTextParserRULE_text_fragment_start)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(589)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ReStructuredTextParserSemiColon:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(572)
			p.Match(ReStructuredTextParserSemiColon)
		}

	case ReStructuredTextParserNumbers:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(573)
			p.Match(ReStructuredTextParserNumbers)
		}

	case ReStructuredTextParserAlphabet:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(574)
			p.Match(ReStructuredTextParserAlphabet)
		}

	case ReStructuredTextParserSpace:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(575)
			p.Match(ReStructuredTextParserSpace)
		}

	case ReStructuredTextParserSquareLeft:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(576)
			p.Match(ReStructuredTextParserSquareLeft)
		}

	case ReStructuredTextParserSquareRight:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(577)
			p.Match(ReStructuredTextParserSquareRight)
		}

	case ReStructuredTextParserRoundLeft:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(578)
			p.Match(ReStructuredTextParserRoundLeft)
		}

	case ReStructuredTextParserRoundRight:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(579)
			p.Match(ReStructuredTextParserRoundRight)
		}

	case ReStructuredTextParserColon:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(580)
			p.Match(ReStructuredTextParserColon)
		}

	case ReStructuredTextParserHat, ReStructuredTextParserEqual, ReStructuredTextParserPlus, ReStructuredTextParserMinus:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(581)
			p.Separator()
		}

	case ReStructuredTextParserAngleLeft:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(582)
			p.Match(ReStructuredTextParserAngleLeft)
		}

	case ReStructuredTextParserAngleRight:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(583)
			p.Match(ReStructuredTextParserAngleRight)
		}

	case ReStructuredTextParserQuotationDouble:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(584)
			p.Match(ReStructuredTextParserQuotationDouble)
		}

	case ReStructuredTextParserDot:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(585)
			p.Match(ReStructuredTextParserDot)
		}

	case ReStructuredTextParserStar:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(586)
			p.Match(ReStructuredTextParserStar)
		}
		{
			p.SetState(587)
			p.Match(ReStructuredTextParserSpace)
		}

	case ReStructuredTextParserAny:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(588)
			p.Match(ReStructuredTextParserAny)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IText_fragmentContext is an interface to support dynamic dispatch.
type IText_fragmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsText_fragmentContext differentiates from other interfaces.
	IsText_fragmentContext()
}

type Text_fragmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyText_fragmentContext() *Text_fragmentContext {
	var p = new(Text_fragmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ReStructuredTextParserRULE_text_fragment
	return p
}

func (*Text_fragmentContext) IsText_fragmentContext() {}

func NewText_fragmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Text_fragmentContext {
	var p = new(Text_fragmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ReStructuredTextParserRULE_text_fragment

	return p
}

func (s *Text_fragmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Text_fragmentContext) Text_fragment_start() IText_fragment_startContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IText_fragment_startContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IText_fragment_startContext)
}

func (s *Text_fragmentContext) ForcedText() IForcedTextContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IForcedTextContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IForcedTextContext)
}

func (s *Text_fragmentContext) Block() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserBlock, 0)
}

func (s *Text_fragmentContext) Literal() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserLiteral, 0)
}

func (s *Text_fragmentContext) Comment() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserComment, 0)
}

func (s *Text_fragmentContext) Dot() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserDot, 0)
}

func (s *Text_fragmentContext) Quote() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserQuote, 0)
}

func (s *Text_fragmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Text_fragmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Text_fragmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.EnterText_fragment(s)
	}
}

func (s *Text_fragmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.ExitText_fragment(s)
	}
}

func (p *ReStructuredTextParser) Text_fragment() (localctx IText_fragmentContext) {
	this := p
	_ = this

	localctx = NewText_fragmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, ReStructuredTextParserRULE_text_fragment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(598)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 75, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(591)
			p.Text_fragment_start()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(592)
			p.ForcedText()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(593)
			p.Match(ReStructuredTextParserBlock)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(594)
			p.Match(ReStructuredTextParserLiteral)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(595)
			p.Match(ReStructuredTextParserComment)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(596)
			p.Match(ReStructuredTextParserDot)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(597)
			p.Match(ReStructuredTextParserQuote)
		}

	}

	return localctx
}

// IStarTextContext is an interface to support dynamic dispatch.
type IStarTextContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStarTextContext differentiates from other interfaces.
	IsStarTextContext()
}

type StarTextContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStarTextContext() *StarTextContext {
	var p = new(StarTextContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ReStructuredTextParserRULE_starText
	return p
}

func (*StarTextContext) IsStarTextContext() {}

func NewStarTextContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StarTextContext {
	var p = new(StarTextContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ReStructuredTextParserRULE_starText

	return p
}

func (s *StarTextContext) GetParser() antlr.Parser { return s.parser }

func (s *StarTextContext) AllLineBreak() []antlr.TerminalNode {
	return s.GetTokens(ReStructuredTextParserLineBreak)
}

func (s *StarTextContext) LineBreak(i int) antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserLineBreak, i)
}

func (s *StarTextContext) AllStar() []antlr.TerminalNode {
	return s.GetTokens(ReStructuredTextParserStar)
}

func (s *StarTextContext) Star(i int) antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserStar, i)
}

func (s *StarTextContext) AllStarNoSpace() []IStarNoSpaceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStarNoSpaceContext)(nil)).Elem())
	var tst = make([]IStarNoSpaceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStarNoSpaceContext)
		}
	}

	return tst
}

func (s *StarTextContext) StarNoSpace(i int) IStarNoSpaceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStarNoSpaceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStarNoSpaceContext)
}

func (s *StarTextContext) AllStarAtoms() []IStarAtomsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStarAtomsContext)(nil)).Elem())
	var tst = make([]IStarAtomsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStarAtomsContext)
		}
	}

	return tst
}

func (s *StarTextContext) StarAtoms(i int) IStarAtomsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStarAtomsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStarAtomsContext)
}

func (s *StarTextContext) AllSpace() []antlr.TerminalNode {
	return s.GetTokens(ReStructuredTextParserSpace)
}

func (s *StarTextContext) Space(i int) antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserSpace, i)
}

func (s *StarTextContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StarTextContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StarTextContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.EnterStarText(s)
	}
}

func (s *StarTextContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.ExitStarText(s)
	}
}

func (p *ReStructuredTextParser) StarText() (localctx IStarTextContext) {
	this := p
	_ = this

	localctx = NewStarTextContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, ReStructuredTextParserRULE_starText)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(669)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 86, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(601)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == ReStructuredTextParserStar {
			{
				p.SetState(600)
				p.Match(ReStructuredTextParserStar)
			}

			p.SetState(603)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(605)
			p.Match(ReStructuredTextParserLineBreak)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(607)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == ReStructuredTextParserStar {
			{
				p.SetState(606)
				p.Match(ReStructuredTextParserStar)
			}

			p.SetState(609)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(611)
			p.StarNoSpace()
		}
		{
			p.SetState(612)
			p.StarAtoms()
		}
		p.SetState(625)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 79, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(613)
					p.Match(ReStructuredTextParserLineBreak)
				}
				p.SetState(617)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				for _la == ReStructuredTextParserStar {
					{
						p.SetState(614)
						p.Match(ReStructuredTextParserStar)
					}

					p.SetState(619)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(620)
					p.StarNoSpace()
				}
				{
					p.SetState(621)
					p.StarAtoms()
				}

			}
			p.SetState(627)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 79, p.GetParserRuleContext())
		}
		p.SetState(631)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == ReStructuredTextParserStar {
			{
				p.SetState(628)
				p.Match(ReStructuredTextParserStar)
			}

			p.SetState(633)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(634)
			p.Match(ReStructuredTextParserLineBreak)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(637)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == ReStructuredTextParserStar {
			{
				p.SetState(636)
				p.Match(ReStructuredTextParserStar)
			}

			p.SetState(639)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(641)
			p.StarNoSpace()
		}
		{
			p.SetState(642)
			p.StarAtoms()
		}
		p.SetState(646)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == ReStructuredTextParserStar {
			{
				p.SetState(643)
				p.Match(ReStructuredTextParserStar)
			}

			p.SetState(648)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(649)
			p.Match(ReStructuredTextParserLineBreak)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(652)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == ReStructuredTextParserStar {
			{
				p.SetState(651)
				p.Match(ReStructuredTextParserStar)
			}

			p.SetState(654)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(657)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(656)
					p.Match(ReStructuredTextParserSpace)
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(659)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 84, p.GetParserRuleContext())
		}
		{
			p.SetState(661)
			p.StarAtoms()
		}
		p.SetState(663)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == ReStructuredTextParserStar {
			{
				p.SetState(662)
				p.Match(ReStructuredTextParserStar)
			}

			p.SetState(665)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(667)
			p.Match(ReStructuredTextParserLineBreak)
		}

	}

	return localctx
}

// IStarAtomsContext is an interface to support dynamic dispatch.
type IStarAtomsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStarAtomsContext differentiates from other interfaces.
	IsStarAtomsContext()
}

type StarAtomsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStarAtomsContext() *StarAtomsContext {
	var p = new(StarAtomsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ReStructuredTextParserRULE_starAtoms
	return p
}

func (*StarAtomsContext) IsStarAtomsContext() {}

func NewStarAtomsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StarAtomsContext {
	var p = new(StarAtomsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ReStructuredTextParserRULE_starAtoms

	return p
}

func (s *StarAtomsContext) GetParser() antlr.Parser { return s.parser }

func (s *StarAtomsContext) AllStarAtom() []IStarAtomContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStarAtomContext)(nil)).Elem())
	var tst = make([]IStarAtomContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStarAtomContext)
		}
	}

	return tst
}

func (s *StarAtomsContext) StarAtom(i int) IStarAtomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStarAtomContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStarAtomContext)
}

func (s *StarAtomsContext) AllStar() []antlr.TerminalNode {
	return s.GetTokens(ReStructuredTextParserStar)
}

func (s *StarAtomsContext) Star(i int) antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserStar, i)
}

func (s *StarAtomsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StarAtomsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StarAtomsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.EnterStarAtoms(s)
	}
}

func (s *StarAtomsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.ExitStarAtoms(s)
	}
}

func (p *ReStructuredTextParser) StarAtoms() (localctx IStarAtomsContext) {
	this := p
	_ = this

	localctx = NewStarAtomsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, ReStructuredTextParserRULE_starAtoms)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(674)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 87, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(671)
				p.StarAtom()
			}

		}
		p.SetState(676)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 87, p.GetParserRuleContext())
	}
	p.SetState(686)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 89, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(680)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == ReStructuredTextParserStar {
				{
					p.SetState(677)
					p.Match(ReStructuredTextParserStar)
				}

				p.SetState(682)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(683)
				p.StarAtom()
			}

		}
		p.SetState(688)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 89, p.GetParserRuleContext())
	}

	return localctx
}

// IStarNoSpaceContext is an interface to support dynamic dispatch.
type IStarNoSpaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStarNoSpaceContext differentiates from other interfaces.
	IsStarNoSpaceContext()
}

type StarNoSpaceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStarNoSpaceContext() *StarNoSpaceContext {
	var p = new(StarNoSpaceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ReStructuredTextParserRULE_starNoSpace
	return p
}

func (*StarNoSpaceContext) IsStarNoSpaceContext() {}

func NewStarNoSpaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StarNoSpaceContext {
	var p = new(StarNoSpaceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ReStructuredTextParserRULE_starNoSpace

	return p
}

func (s *StarNoSpaceContext) GetParser() antlr.Parser { return s.parser }

func (s *StarNoSpaceContext) Star() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserStar, 0)
}

func (s *StarNoSpaceContext) LineBreak() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserLineBreak, 0)
}

func (s *StarNoSpaceContext) Space() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserSpace, 0)
}

func (s *StarNoSpaceContext) SectionSeparator() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserSectionSeparator, 0)
}

func (s *StarNoSpaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StarNoSpaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StarNoSpaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.EnterStarNoSpace(s)
	}
}

func (s *StarNoSpaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.ExitStarNoSpace(s)
	}
}

func (p *ReStructuredTextParser) StarNoSpace() (localctx IStarNoSpaceContext) {
	this := p
	_ = this

	localctx = NewStarNoSpaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, ReStructuredTextParserRULE_starNoSpace)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(689)
		_la = p.GetTokenStream().LA(1)

		if _la <= 0 || (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ReStructuredTextParserSectionSeparator)|(1<<ReStructuredTextParserStar)|(1<<ReStructuredTextParserSpace)|(1<<ReStructuredTextParserLineBreak))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IStarAtomContext is an interface to support dynamic dispatch.
type IStarAtomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStarAtomContext differentiates from other interfaces.
	IsStarAtomContext()
}

type StarAtomContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStarAtomContext() *StarAtomContext {
	var p = new(StarAtomContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ReStructuredTextParserRULE_starAtom
	return p
}

func (*StarAtomContext) IsStarAtomContext() {}

func NewStarAtomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StarAtomContext {
	var p = new(StarAtomContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ReStructuredTextParserRULE_starAtom

	return p
}

func (s *StarAtomContext) GetParser() antlr.Parser { return s.parser }

func (s *StarAtomContext) Star() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserStar, 0)
}

func (s *StarAtomContext) LineBreak() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserLineBreak, 0)
}

func (s *StarAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StarAtomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StarAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.EnterStarAtom(s)
	}
}

func (s *StarAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.ExitStarAtom(s)
	}
}

func (p *ReStructuredTextParser) StarAtom() (localctx IStarAtomContext) {
	this := p
	_ = this

	localctx = NewStarAtomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, ReStructuredTextParserRULE_starAtom)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(691)
		_la = p.GetTokenStream().LA(1)

		if _la <= 0 || _la == ReStructuredTextParserStar || _la == ReStructuredTextParserLineBreak {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IBackTickTextContext is an interface to support dynamic dispatch.
type IBackTickTextContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTitled returns the titled token.
	GetTitled() antlr.Token

	// SetTitled sets the titled token.
	SetTitled(antlr.Token)

	// IsBackTickTextContext differentiates from other interfaces.
	IsBackTickTextContext()
}

type BackTickTextContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	titled antlr.Token
}

func NewEmptyBackTickTextContext() *BackTickTextContext {
	var p = new(BackTickTextContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ReStructuredTextParserRULE_backTickText
	return p
}

func (*BackTickTextContext) IsBackTickTextContext() {}

func NewBackTickTextContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BackTickTextContext {
	var p = new(BackTickTextContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ReStructuredTextParserRULE_backTickText

	return p
}

func (s *BackTickTextContext) GetParser() antlr.Parser { return s.parser }

func (s *BackTickTextContext) GetTitled() antlr.Token { return s.titled }

func (s *BackTickTextContext) SetTitled(v antlr.Token) { s.titled = v }

func (s *BackTickTextContext) Body() IBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBodyContext)
}

func (s *BackTickTextContext) AllColon() []antlr.TerminalNode {
	return s.GetTokens(ReStructuredTextParserColon)
}

func (s *BackTickTextContext) Colon(i int) antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserColon, i)
}

func (s *BackTickTextContext) UnderScore() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserUnderScore, 0)
}

func (s *BackTickTextContext) Alphabet() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserAlphabet, 0)
}

func (s *BackTickTextContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BackTickTextContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BackTickTextContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.EnterBackTickText(s)
	}
}

func (s *BackTickTextContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.ExitBackTickText(s)
	}
}

func (p *ReStructuredTextParser) BackTickText() (localctx IBackTickTextContext) {
	this := p
	_ = this

	localctx = NewBackTickTextContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, ReStructuredTextParserRULE_backTickText)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(696)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ReStructuredTextParserColon {
		{
			p.SetState(693)
			p.Match(ReStructuredTextParserColon)
		}
		{
			p.SetState(694)

			var _m = p.Match(ReStructuredTextParserAlphabet)

			localctx.(*BackTickTextContext).titled = _m
		}
		{
			p.SetState(695)
			p.Match(ReStructuredTextParserColon)
		}

	}
	{
		p.SetState(698)
		p.Body()
	}
	p.SetState(700)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 91, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(699)
			p.Match(ReStructuredTextParserUnderScore)
		}

	}

	return localctx
}

// IBodyContext is an interface to support dynamic dispatch.
type IBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBodyContext differentiates from other interfaces.
	IsBodyContext()
}

type BodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBodyContext() *BodyContext {
	var p = new(BodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ReStructuredTextParserRULE_body
	return p
}

func (*BodyContext) IsBodyContext() {}

func NewBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BodyContext {
	var p = new(BodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ReStructuredTextParserRULE_body

	return p
}

func (s *BodyContext) GetParser() antlr.Parser { return s.parser }

func (s *BodyContext) AllBackTick() []antlr.TerminalNode {
	return s.GetTokens(ReStructuredTextParserBackTick)
}

func (s *BodyContext) BackTick(i int) antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserBackTick, i)
}

func (s *BodyContext) BackTickAtoms() IBackTickAtomsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBackTickAtomsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBackTickAtomsContext)
}

func (s *BodyContext) BackTickNoSpace() IBackTickNoSpaceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBackTickNoSpaceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBackTickNoSpaceContext)
}

func (s *BodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.EnterBody(s)
	}
}

func (s *BodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.ExitBody(s)
	}
}

func (p *ReStructuredTextParser) Body() (localctx IBodyContext) {
	this := p
	_ = this

	localctx = NewBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, ReStructuredTextParserRULE_body)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(725)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 95, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(702)
			p.Match(ReStructuredTextParserBackTick)
		}
		p.SetState(706)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 92, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(703)
					p.Match(ReStructuredTextParserBackTick)
				}

			}
			p.SetState(708)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 92, p.GetParserRuleContext())
		}
		{
			p.SetState(709)
			p.BackTickAtoms()
		}
		p.SetState(711)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(710)
					p.Match(ReStructuredTextParserBackTick)
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(713)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 93, p.GetParserRuleContext())
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(715)
			p.Match(ReStructuredTextParserBackTick)
		}
		{
			p.SetState(716)
			p.BackTickNoSpace()
		}
		{
			p.SetState(717)
			p.BackTickAtoms()
		}
		p.SetState(719)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(718)
					p.Match(ReStructuredTextParserBackTick)
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(721)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 94, p.GetParserRuleContext())
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(723)
			p.Match(ReStructuredTextParserBackTick)
		}
		{
			p.SetState(724)
			p.Match(ReStructuredTextParserBackTick)
		}

	}

	return localctx
}

// IBackTickAtomsContext is an interface to support dynamic dispatch.
type IBackTickAtomsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBackTickAtomsContext differentiates from other interfaces.
	IsBackTickAtomsContext()
}

type BackTickAtomsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBackTickAtomsContext() *BackTickAtomsContext {
	var p = new(BackTickAtomsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ReStructuredTextParserRULE_backTickAtoms
	return p
}

func (*BackTickAtomsContext) IsBackTickAtomsContext() {}

func NewBackTickAtomsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BackTickAtomsContext {
	var p = new(BackTickAtomsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ReStructuredTextParserRULE_backTickAtoms

	return p
}

func (s *BackTickAtomsContext) GetParser() antlr.Parser { return s.parser }

func (s *BackTickAtomsContext) AllBackTickAtom() []IBackTickAtomContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBackTickAtomContext)(nil)).Elem())
	var tst = make([]IBackTickAtomContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBackTickAtomContext)
		}
	}

	return tst
}

func (s *BackTickAtomsContext) BackTickAtom(i int) IBackTickAtomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBackTickAtomContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBackTickAtomContext)
}

func (s *BackTickAtomsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BackTickAtomsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BackTickAtomsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.EnterBackTickAtoms(s)
	}
}

func (s *BackTickAtomsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.ExitBackTickAtoms(s)
	}
}

func (p *ReStructuredTextParser) BackTickAtoms() (localctx IBackTickAtomsContext) {
	this := p
	_ = this

	localctx = NewBackTickAtomsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, ReStructuredTextParserRULE_backTickAtoms)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(728)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(727)
				p.BackTickAtom()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(730)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 96, p.GetParserRuleContext())
	}

	return localctx
}

// IBackTickNoSpaceContext is an interface to support dynamic dispatch.
type IBackTickNoSpaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBackTickNoSpaceContext differentiates from other interfaces.
	IsBackTickNoSpaceContext()
}

type BackTickNoSpaceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBackTickNoSpaceContext() *BackTickNoSpaceContext {
	var p = new(BackTickNoSpaceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ReStructuredTextParserRULE_backTickNoSpace
	return p
}

func (*BackTickNoSpaceContext) IsBackTickNoSpaceContext() {}

func NewBackTickNoSpaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BackTickNoSpaceContext {
	var p = new(BackTickNoSpaceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ReStructuredTextParserRULE_backTickNoSpace

	return p
}

func (s *BackTickNoSpaceContext) GetParser() antlr.Parser { return s.parser }

func (s *BackTickNoSpaceContext) BackTick() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserBackTick, 0)
}

func (s *BackTickNoSpaceContext) LineBreak() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserLineBreak, 0)
}

func (s *BackTickNoSpaceContext) Space() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserSpace, 0)
}

func (s *BackTickNoSpaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BackTickNoSpaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BackTickNoSpaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.EnterBackTickNoSpace(s)
	}
}

func (s *BackTickNoSpaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.ExitBackTickNoSpace(s)
	}
}

func (p *ReStructuredTextParser) BackTickNoSpace() (localctx IBackTickNoSpaceContext) {
	this := p
	_ = this

	localctx = NewBackTickNoSpaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, ReStructuredTextParserRULE_backTickNoSpace)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(732)
		_la = p.GetTokenStream().LA(1)

		if _la <= 0 || (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ReStructuredTextParserBackTick)|(1<<ReStructuredTextParserSpace)|(1<<ReStructuredTextParserLineBreak))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IBackTickAtomContext is an interface to support dynamic dispatch.
type IBackTickAtomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBackTickAtomContext differentiates from other interfaces.
	IsBackTickAtomContext()
}

type BackTickAtomContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBackTickAtomContext() *BackTickAtomContext {
	var p = new(BackTickAtomContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ReStructuredTextParserRULE_backTickAtom
	return p
}

func (*BackTickAtomContext) IsBackTickAtomContext() {}

func NewBackTickAtomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BackTickAtomContext {
	var p = new(BackTickAtomContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ReStructuredTextParserRULE_backTickAtom

	return p
}

func (s *BackTickAtomContext) GetParser() antlr.Parser { return s.parser }

func (s *BackTickAtomContext) AllBackTick() []antlr.TerminalNode {
	return s.GetTokens(ReStructuredTextParserBackTick)
}

func (s *BackTickAtomContext) BackTick(i int) antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserBackTick, i)
}

func (s *BackTickAtomContext) LineBreak() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserLineBreak, 0)
}

func (s *BackTickAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BackTickAtomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BackTickAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.EnterBackTickAtom(s)
	}
}

func (s *BackTickAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.ExitBackTickAtom(s)
	}
}

func (p *ReStructuredTextParser) BackTickAtom() (localctx IBackTickAtomContext) {
	this := p
	_ = this

	localctx = NewBackTickAtomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, ReStructuredTextParserRULE_backTickAtom)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(737)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ReStructuredTextParserT__0, ReStructuredTextParserSectionSeparator, ReStructuredTextParserLiteral, ReStructuredTextParserTimeStar, ReStructuredTextParserAlphabet, ReStructuredTextParserNumbers, ReStructuredTextParserQuote, ReStructuredTextParserSquareLeft, ReStructuredTextParserSquareRight, ReStructuredTextParserRoundLeft, ReStructuredTextParserRoundRight, ReStructuredTextParserAngleLeft, ReStructuredTextParserAngleRight, ReStructuredTextParserHat, ReStructuredTextParserQuotationDouble, ReStructuredTextParserQuotationSingle, ReStructuredTextParserDot, ReStructuredTextParserSemiColon, ReStructuredTextParserColon, ReStructuredTextParserEqual, ReStructuredTextParserPlus, ReStructuredTextParserMinus, ReStructuredTextParserBlock, ReStructuredTextParserComment, ReStructuredTextParserUnderScore, ReStructuredTextParserStar, ReStructuredTextParserSpace, ReStructuredTextParserAny:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(734)
			_la = p.GetTokenStream().LA(1)

			if _la <= 0 || _la == ReStructuredTextParserBackTick || _la == ReStructuredTextParserLineBreak {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case ReStructuredTextParserBackTick:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(735)
			p.Match(ReStructuredTextParserBackTick)
		}
		{
			p.SetState(736)
			_la = p.GetTokenStream().LA(1)

			if _la <= 0 || _la == ReStructuredTextParserBackTick || _la == ReStructuredTextParserLineBreak {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IReferenceContext is an interface to support dynamic dispatch.
type IReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReferenceContext differentiates from other interfaces.
	IsReferenceContext()
}

type ReferenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReferenceContext() *ReferenceContext {
	var p = new(ReferenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ReStructuredTextParserRULE_reference
	return p
}

func (*ReferenceContext) IsReferenceContext() {}

func NewReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReferenceContext {
	var p = new(ReferenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ReStructuredTextParserRULE_reference

	return p
}

func (s *ReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *ReferenceContext) UnderScore() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserUnderScore, 0)
}

func (s *ReferenceContext) AllAny() []antlr.TerminalNode {
	return s.GetTokens(ReStructuredTextParserAny)
}

func (s *ReferenceContext) Any(i int) antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserAny, i)
}

func (s *ReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.EnterReference(s)
	}
}

func (s *ReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.ExitReference(s)
	}
}

func (p *ReStructuredTextParser) Reference() (localctx IReferenceContext) {
	this := p
	_ = this

	localctx = NewReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, ReStructuredTextParserRULE_reference)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(740)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == ReStructuredTextParserAny {
		{
			p.SetState(739)
			p.Match(ReStructuredTextParserAny)
		}

		p.SetState(742)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(744)
		p.Match(ReStructuredTextParserUnderScore)
	}

	return localctx
}

// IReferenceInContext is an interface to support dynamic dispatch.
type IReferenceInContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReferenceInContext differentiates from other interfaces.
	IsReferenceInContext()
}

type ReferenceInContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReferenceInContext() *ReferenceInContext {
	var p = new(ReferenceInContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ReStructuredTextParserRULE_referenceIn
	return p
}

func (*ReferenceInContext) IsReferenceInContext() {}

func NewReferenceInContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReferenceInContext {
	var p = new(ReferenceInContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ReStructuredTextParserRULE_referenceIn

	return p
}

func (s *ReferenceInContext) GetParser() antlr.Parser { return s.parser }

func (s *ReferenceInContext) UnderScore() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserUnderScore, 0)
}

func (s *ReferenceInContext) Colon() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserColon, 0)
}

func (s *ReferenceInContext) Space() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserSpace, 0)
}

func (s *ReferenceInContext) Url() IUrlContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUrlContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUrlContext)
}

func (s *ReferenceInContext) AllHyperlinkAtom() []IHyperlinkAtomContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IHyperlinkAtomContext)(nil)).Elem())
	var tst = make([]IHyperlinkAtomContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IHyperlinkAtomContext)
		}
	}

	return tst
}

func (s *ReferenceInContext) HyperlinkAtom(i int) IHyperlinkAtomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHyperlinkAtomContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IHyperlinkAtomContext)
}

func (s *ReferenceInContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReferenceInContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReferenceInContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.EnterReferenceIn(s)
	}
}

func (s *ReferenceInContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.ExitReferenceIn(s)
	}
}

func (p *ReStructuredTextParser) ReferenceIn() (localctx IReferenceInContext) {
	this := p
	_ = this

	localctx = NewReferenceInContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, ReStructuredTextParserRULE_referenceIn)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(746)
		p.Match(ReStructuredTextParserUnderScore)
	}
	p.SetState(748)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(747)
				p.HyperlinkAtom()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(750)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 99, p.GetParserRuleContext())
	}
	{
		p.SetState(752)
		p.Match(ReStructuredTextParserColon)
	}
	{
		p.SetState(753)
		p.Match(ReStructuredTextParserSpace)
	}
	{
		p.SetState(754)
		p.Url()
	}

	return localctx
}

// IHyperlinkTargetContext is an interface to support dynamic dispatch.
type IHyperlinkTargetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHyperlinkTargetContext differentiates from other interfaces.
	IsHyperlinkTargetContext()
}

type HyperlinkTargetContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHyperlinkTargetContext() *HyperlinkTargetContext {
	var p = new(HyperlinkTargetContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ReStructuredTextParserRULE_hyperlinkTarget
	return p
}

func (*HyperlinkTargetContext) IsHyperlinkTargetContext() {}

func NewHyperlinkTargetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HyperlinkTargetContext {
	var p = new(HyperlinkTargetContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ReStructuredTextParserRULE_hyperlinkTarget

	return p
}

func (s *HyperlinkTargetContext) GetParser() antlr.Parser { return s.parser }

func (s *HyperlinkTargetContext) UnderScore() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserUnderScore, 0)
}

func (s *HyperlinkTargetContext) AllAny() []antlr.TerminalNode {
	return s.GetTokens(ReStructuredTextParserAny)
}

func (s *HyperlinkTargetContext) Any(i int) antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserAny, i)
}

func (s *HyperlinkTargetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HyperlinkTargetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HyperlinkTargetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.EnterHyperlinkTarget(s)
	}
}

func (s *HyperlinkTargetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.ExitHyperlinkTarget(s)
	}
}

func (p *ReStructuredTextParser) HyperlinkTarget() (localctx IHyperlinkTargetContext) {
	this := p
	_ = this

	localctx = NewHyperlinkTargetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, ReStructuredTextParserRULE_hyperlinkTarget)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(756)
		p.Match(ReStructuredTextParserUnderScore)
	}
	p.SetState(758)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(757)
				p.Match(ReStructuredTextParserAny)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(760)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 100, p.GetParserRuleContext())
	}

	return localctx
}

// IHyperlinkContext is an interface to support dynamic dispatch.
type IHyperlinkContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHyperlinkContext differentiates from other interfaces.
	IsHyperlinkContext()
}

type HyperlinkContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHyperlinkContext() *HyperlinkContext {
	var p = new(HyperlinkContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ReStructuredTextParserRULE_hyperlink
	return p
}

func (*HyperlinkContext) IsHyperlinkContext() {}

func NewHyperlinkContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HyperlinkContext {
	var p = new(HyperlinkContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ReStructuredTextParserRULE_hyperlink

	return p
}

func (s *HyperlinkContext) GetParser() antlr.Parser { return s.parser }

func (s *HyperlinkContext) AllBackTick() []antlr.TerminalNode {
	return s.GetTokens(ReStructuredTextParserBackTick)
}

func (s *HyperlinkContext) BackTick(i int) antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserBackTick, i)
}

func (s *HyperlinkContext) AllSpace() []antlr.TerminalNode {
	return s.GetTokens(ReStructuredTextParserSpace)
}

func (s *HyperlinkContext) Space(i int) antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserSpace, i)
}

func (s *HyperlinkContext) AngleLeft() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserAngleLeft, 0)
}

func (s *HyperlinkContext) Url() IUrlContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUrlContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUrlContext)
}

func (s *HyperlinkContext) AngleRight() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserAngleRight, 0)
}

func (s *HyperlinkContext) UnderScore() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserUnderScore, 0)
}

func (s *HyperlinkContext) AllHyperlinkAtom() []IHyperlinkAtomContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IHyperlinkAtomContext)(nil)).Elem())
	var tst = make([]IHyperlinkAtomContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IHyperlinkAtomContext)
		}
	}

	return tst
}

func (s *HyperlinkContext) HyperlinkAtom(i int) IHyperlinkAtomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHyperlinkAtomContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IHyperlinkAtomContext)
}

func (s *HyperlinkContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HyperlinkContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HyperlinkContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.EnterHyperlink(s)
	}
}

func (s *HyperlinkContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.ExitHyperlink(s)
	}
}

func (p *ReStructuredTextParser) Hyperlink() (localctx IHyperlinkContext) {
	this := p
	_ = this

	localctx = NewHyperlinkContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, ReStructuredTextParserRULE_hyperlink)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(762)
		p.Match(ReStructuredTextParserBackTick)
	}
	p.SetState(764)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(763)
				p.HyperlinkAtom()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(766)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 101, p.GetParserRuleContext())
	}
	{
		p.SetState(768)
		p.Match(ReStructuredTextParserSpace)
	}
	{
		p.SetState(769)
		p.Match(ReStructuredTextParserAngleLeft)
	}
	{
		p.SetState(770)
		p.Url()
	}
	{
		p.SetState(771)
		p.Match(ReStructuredTextParserAngleRight)
	}
	{
		p.SetState(772)
		p.Match(ReStructuredTextParserBackTick)
	}
	{
		p.SetState(773)
		p.Match(ReStructuredTextParserUnderScore)
	}
	{
		p.SetState(774)
		p.Match(ReStructuredTextParserSpace)
	}

	return localctx
}

// IHyperlinkDocContext is an interface to support dynamic dispatch.
type IHyperlinkDocContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHyperlinkDocContext differentiates from other interfaces.
	IsHyperlinkDocContext()
}

type HyperlinkDocContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHyperlinkDocContext() *HyperlinkDocContext {
	var p = new(HyperlinkDocContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ReStructuredTextParserRULE_hyperlinkDoc
	return p
}

func (*HyperlinkDocContext) IsHyperlinkDocContext() {}

func NewHyperlinkDocContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HyperlinkDocContext {
	var p = new(HyperlinkDocContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ReStructuredTextParserRULE_hyperlinkDoc

	return p
}

func (s *HyperlinkDocContext) GetParser() antlr.Parser { return s.parser }

func (s *HyperlinkDocContext) AllBackTick() []antlr.TerminalNode {
	return s.GetTokens(ReStructuredTextParserBackTick)
}

func (s *HyperlinkDocContext) BackTick(i int) antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserBackTick, i)
}

func (s *HyperlinkDocContext) Space() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserSpace, 0)
}

func (s *HyperlinkDocContext) AngleLeft() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserAngleLeft, 0)
}

func (s *HyperlinkDocContext) Url() IUrlContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUrlContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUrlContext)
}

func (s *HyperlinkDocContext) AngleRight() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserAngleRight, 0)
}

func (s *HyperlinkDocContext) AllHyperlinkAtom() []IHyperlinkAtomContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IHyperlinkAtomContext)(nil)).Elem())
	var tst = make([]IHyperlinkAtomContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IHyperlinkAtomContext)
		}
	}

	return tst
}

func (s *HyperlinkDocContext) HyperlinkAtom(i int) IHyperlinkAtomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHyperlinkAtomContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IHyperlinkAtomContext)
}

func (s *HyperlinkDocContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HyperlinkDocContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HyperlinkDocContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.EnterHyperlinkDoc(s)
	}
}

func (s *HyperlinkDocContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.ExitHyperlinkDoc(s)
	}
}

func (p *ReStructuredTextParser) HyperlinkDoc() (localctx IHyperlinkDocContext) {
	this := p
	_ = this

	localctx = NewHyperlinkDocContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, ReStructuredTextParserRULE_hyperlinkDoc)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(794)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 103, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(776)
			p.Match(ReStructuredTextParserT__0)
		}
		{
			p.SetState(777)
			p.Match(ReStructuredTextParserBackTick)
		}
		p.SetState(779)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(778)
					p.HyperlinkAtom()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(781)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 102, p.GetParserRuleContext())
		}
		{
			p.SetState(783)
			p.Match(ReStructuredTextParserSpace)
		}
		{
			p.SetState(784)
			p.Match(ReStructuredTextParserAngleLeft)
		}
		{
			p.SetState(785)
			p.Url()
		}
		{
			p.SetState(786)
			p.Match(ReStructuredTextParserAngleRight)
		}
		{
			p.SetState(787)
			p.Match(ReStructuredTextParserBackTick)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(789)
			p.Match(ReStructuredTextParserT__0)
		}
		{
			p.SetState(790)
			p.Match(ReStructuredTextParserBackTick)
		}
		{
			p.SetState(791)
			p.Url()
		}
		{
			p.SetState(792)
			p.Match(ReStructuredTextParserBackTick)
		}

	}

	return localctx
}

// IUrlContext is an interface to support dynamic dispatch.
type IUrlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUrlContext differentiates from other interfaces.
	IsUrlContext()
}

type UrlContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUrlContext() *UrlContext {
	var p = new(UrlContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ReStructuredTextParserRULE_url
	return p
}

func (*UrlContext) IsUrlContext() {}

func NewUrlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UrlContext {
	var p = new(UrlContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ReStructuredTextParserRULE_url

	return p
}

func (s *UrlContext) GetParser() antlr.Parser { return s.parser }

func (s *UrlContext) AllUrlAtom() []IUrlAtomContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IUrlAtomContext)(nil)).Elem())
	var tst = make([]IUrlAtomContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IUrlAtomContext)
		}
	}

	return tst
}

func (s *UrlContext) UrlAtom(i int) IUrlAtomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUrlAtomContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IUrlAtomContext)
}

func (s *UrlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UrlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UrlContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.EnterUrl(s)
	}
}

func (s *UrlContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.ExitUrl(s)
	}
}

func (p *ReStructuredTextParser) Url() (localctx IUrlContext) {
	this := p
	_ = this

	localctx = NewUrlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, ReStructuredTextParserRULE_url)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(797)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(796)
				p.UrlAtom()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(799)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 104, p.GetParserRuleContext())
	}

	return localctx
}

// IUrlAtomContext is an interface to support dynamic dispatch.
type IUrlAtomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUrlAtomContext differentiates from other interfaces.
	IsUrlAtomContext()
}

type UrlAtomContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUrlAtomContext() *UrlAtomContext {
	var p = new(UrlAtomContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ReStructuredTextParserRULE_urlAtom
	return p
}

func (*UrlAtomContext) IsUrlAtomContext() {}

func NewUrlAtomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UrlAtomContext {
	var p = new(UrlAtomContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ReStructuredTextParserRULE_urlAtom

	return p
}

func (s *UrlAtomContext) GetParser() antlr.Parser { return s.parser }

func (s *UrlAtomContext) LineBreak() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserLineBreak, 0)
}

func (s *UrlAtomContext) BackTick() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserBackTick, 0)
}

func (s *UrlAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UrlAtomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UrlAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.EnterUrlAtom(s)
	}
}

func (s *UrlAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.ExitUrlAtom(s)
	}
}

func (p *ReStructuredTextParser) UrlAtom() (localctx IUrlAtomContext) {
	this := p
	_ = this

	localctx = NewUrlAtomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, ReStructuredTextParserRULE_urlAtom)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(801)
		_la = p.GetTokenStream().LA(1)

		if _la <= 0 || _la == ReStructuredTextParserBackTick || _la == ReStructuredTextParserLineBreak {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IHyperlinkAtomContext is an interface to support dynamic dispatch.
type IHyperlinkAtomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHyperlinkAtomContext differentiates from other interfaces.
	IsHyperlinkAtomContext()
}

type HyperlinkAtomContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHyperlinkAtomContext() *HyperlinkAtomContext {
	var p = new(HyperlinkAtomContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ReStructuredTextParserRULE_hyperlinkAtom
	return p
}

func (*HyperlinkAtomContext) IsHyperlinkAtomContext() {}

func NewHyperlinkAtomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HyperlinkAtomContext {
	var p = new(HyperlinkAtomContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ReStructuredTextParserRULE_hyperlinkAtom

	return p
}

func (s *HyperlinkAtomContext) GetParser() antlr.Parser { return s.parser }

func (s *HyperlinkAtomContext) LineBreak() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserLineBreak, 0)
}

func (s *HyperlinkAtomContext) AngleLeft() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserAngleLeft, 0)
}

func (s *HyperlinkAtomContext) AngleRight() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserAngleRight, 0)
}

func (s *HyperlinkAtomContext) BackTick() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserBackTick, 0)
}

func (s *HyperlinkAtomContext) Star() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserStar, 0)
}

func (s *HyperlinkAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HyperlinkAtomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HyperlinkAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.EnterHyperlinkAtom(s)
	}
}

func (s *HyperlinkAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.ExitHyperlinkAtom(s)
	}
}

func (p *ReStructuredTextParser) HyperlinkAtom() (localctx IHyperlinkAtomContext) {
	this := p
	_ = this

	localctx = NewHyperlinkAtomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, ReStructuredTextParserRULE_hyperlinkAtom)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(803)
		_la = p.GetTokenStream().LA(1)

		if _la <= 0 || (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ReStructuredTextParserAngleLeft)|(1<<ReStructuredTextParserAngleRight)|(1<<ReStructuredTextParserBackTick)|(1<<ReStructuredTextParserStar)|(1<<ReStructuredTextParserLineBreak))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ISeparatorContext is an interface to support dynamic dispatch.
type ISeparatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSeparatorContext differentiates from other interfaces.
	IsSeparatorContext()
}

type SeparatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySeparatorContext() *SeparatorContext {
	var p = new(SeparatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ReStructuredTextParserRULE_separator
	return p
}

func (*SeparatorContext) IsSeparatorContext() {}

func NewSeparatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SeparatorContext {
	var p = new(SeparatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ReStructuredTextParserRULE_separator

	return p
}

func (s *SeparatorContext) GetParser() antlr.Parser { return s.parser }

func (s *SeparatorContext) Minus() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserMinus, 0)
}

func (s *SeparatorContext) Equal() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserEqual, 0)
}

func (s *SeparatorContext) Plus() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserPlus, 0)
}

func (s *SeparatorContext) Hat() antlr.TerminalNode {
	return s.GetToken(ReStructuredTextParserHat, 0)
}

func (s *SeparatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SeparatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SeparatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.EnterSeparator(s)
	}
}

func (s *SeparatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ReStructuredTextListener); ok {
		listenerT.ExitSeparator(s)
	}
}

func (p *ReStructuredTextParser) Separator() (localctx ISeparatorContext) {
	this := p
	_ = this

	localctx = NewSeparatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, ReStructuredTextParserRULE_separator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(805)
		_la = p.GetTokenStream().LA(1)

		if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ReStructuredTextParserHat)|(1<<ReStructuredTextParserEqual)|(1<<ReStructuredTextParserPlus)|(1<<ReStructuredTextParserMinus))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}
