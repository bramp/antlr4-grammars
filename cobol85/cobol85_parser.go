// Code generated from Cobol85.g4 by ANTLR 4.7.2. DO NOT EDIT.

package cobol85 // Cobol85
import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 567, 6290,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4,
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55,
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9,
	60, 4, 61, 9, 61, 4, 62, 9, 62, 4, 63, 9, 63, 4, 64, 9, 64, 4, 65, 9, 65,
	4, 66, 9, 66, 4, 67, 9, 67, 4, 68, 9, 68, 4, 69, 9, 69, 4, 70, 9, 70, 4,
	71, 9, 71, 4, 72, 9, 72, 4, 73, 9, 73, 4, 74, 9, 74, 4, 75, 9, 75, 4, 76,
	9, 76, 4, 77, 9, 77, 4, 78, 9, 78, 4, 79, 9, 79, 4, 80, 9, 80, 4, 81, 9,
	81, 4, 82, 9, 82, 4, 83, 9, 83, 4, 84, 9, 84, 4, 85, 9, 85, 4, 86, 9, 86,
	4, 87, 9, 87, 4, 88, 9, 88, 4, 89, 9, 89, 4, 90, 9, 90, 4, 91, 9, 91, 4,
	92, 9, 92, 4, 93, 9, 93, 4, 94, 9, 94, 4, 95, 9, 95, 4, 96, 9, 96, 4, 97,
	9, 97, 4, 98, 9, 98, 4, 99, 9, 99, 4, 100, 9, 100, 4, 101, 9, 101, 4, 102,
	9, 102, 4, 103, 9, 103, 4, 104, 9, 104, 4, 105, 9, 105, 4, 106, 9, 106,
	4, 107, 9, 107, 4, 108, 9, 108, 4, 109, 9, 109, 4, 110, 9, 110, 4, 111,
	9, 111, 4, 112, 9, 112, 4, 113, 9, 113, 4, 114, 9, 114, 4, 115, 9, 115,
	4, 116, 9, 116, 4, 117, 9, 117, 4, 118, 9, 118, 4, 119, 9, 119, 4, 120,
	9, 120, 4, 121, 9, 121, 4, 122, 9, 122, 4, 123, 9, 123, 4, 124, 9, 124,
	4, 125, 9, 125, 4, 126, 9, 126, 4, 127, 9, 127, 4, 128, 9, 128, 4, 129,
	9, 129, 4, 130, 9, 130, 4, 131, 9, 131, 4, 132, 9, 132, 4, 133, 9, 133,
	4, 134, 9, 134, 4, 135, 9, 135, 4, 136, 9, 136, 4, 137, 9, 137, 4, 138,
	9, 138, 4, 139, 9, 139, 4, 140, 9, 140, 4, 141, 9, 141, 4, 142, 9, 142,
	4, 143, 9, 143, 4, 144, 9, 144, 4, 145, 9, 145, 4, 146, 9, 146, 4, 147,
	9, 147, 4, 148, 9, 148, 4, 149, 9, 149, 4, 150, 9, 150, 4, 151, 9, 151,
	4, 152, 9, 152, 4, 153, 9, 153, 4, 154, 9, 154, 4, 155, 9, 155, 4, 156,
	9, 156, 4, 157, 9, 157, 4, 158, 9, 158, 4, 159, 9, 159, 4, 160, 9, 160,
	4, 161, 9, 161, 4, 162, 9, 162, 4, 163, 9, 163, 4, 164, 9, 164, 4, 165,
	9, 165, 4, 166, 9, 166, 4, 167, 9, 167, 4, 168, 9, 168, 4, 169, 9, 169,
	4, 170, 9, 170, 4, 171, 9, 171, 4, 172, 9, 172, 4, 173, 9, 173, 4, 174,
	9, 174, 4, 175, 9, 175, 4, 176, 9, 176, 4, 177, 9, 177, 4, 178, 9, 178,
	4, 179, 9, 179, 4, 180, 9, 180, 4, 181, 9, 181, 4, 182, 9, 182, 4, 183,
	9, 183, 4, 184, 9, 184, 4, 185, 9, 185, 4, 186, 9, 186, 4, 187, 9, 187,
	4, 188, 9, 188, 4, 189, 9, 189, 4, 190, 9, 190, 4, 191, 9, 191, 4, 192,
	9, 192, 4, 193, 9, 193, 4, 194, 9, 194, 4, 195, 9, 195, 4, 196, 9, 196,
	4, 197, 9, 197, 4, 198, 9, 198, 4, 199, 9, 199, 4, 200, 9, 200, 4, 201,
	9, 201, 4, 202, 9, 202, 4, 203, 9, 203, 4, 204, 9, 204, 4, 205, 9, 205,
	4, 206, 9, 206, 4, 207, 9, 207, 4, 208, 9, 208, 4, 209, 9, 209, 4, 210,
	9, 210, 4, 211, 9, 211, 4, 212, 9, 212, 4, 213, 9, 213, 4, 214, 9, 214,
	4, 215, 9, 215, 4, 216, 9, 216, 4, 217, 9, 217, 4, 218, 9, 218, 4, 219,
	9, 219, 4, 220, 9, 220, 4, 221, 9, 221, 4, 222, 9, 222, 4, 223, 9, 223,
	4, 224, 9, 224, 4, 225, 9, 225, 4, 226, 9, 226, 4, 227, 9, 227, 4, 228,
	9, 228, 4, 229, 9, 229, 4, 230, 9, 230, 4, 231, 9, 231, 4, 232, 9, 232,
	4, 233, 9, 233, 4, 234, 9, 234, 4, 235, 9, 235, 4, 236, 9, 236, 4, 237,
	9, 237, 4, 238, 9, 238, 4, 239, 9, 239, 4, 240, 9, 240, 4, 241, 9, 241,
	4, 242, 9, 242, 4, 243, 9, 243, 4, 244, 9, 244, 4, 245, 9, 245, 4, 246,
	9, 246, 4, 247, 9, 247, 4, 248, 9, 248, 4, 249, 9, 249, 4, 250, 9, 250,
	4, 251, 9, 251, 4, 252, 9, 252, 4, 253, 9, 253, 4, 254, 9, 254, 4, 255,
	9, 255, 4, 256, 9, 256, 4, 257, 9, 257, 4, 258, 9, 258, 4, 259, 9, 259,
	4, 260, 9, 260, 4, 261, 9, 261, 4, 262, 9, 262, 4, 263, 9, 263, 4, 264,
	9, 264, 4, 265, 9, 265, 4, 266, 9, 266, 4, 267, 9, 267, 4, 268, 9, 268,
	4, 269, 9, 269, 4, 270, 9, 270, 4, 271, 9, 271, 4, 272, 9, 272, 4, 273,
	9, 273, 4, 274, 9, 274, 4, 275, 9, 275, 4, 276, 9, 276, 4, 277, 9, 277,
	4, 278, 9, 278, 4, 279, 9, 279, 4, 280, 9, 280, 4, 281, 9, 281, 4, 282,
	9, 282, 4, 283, 9, 283, 4, 284, 9, 284, 4, 285, 9, 285, 4, 286, 9, 286,
	4, 287, 9, 287, 4, 288, 9, 288, 4, 289, 9, 289, 4, 290, 9, 290, 4, 291,
	9, 291, 4, 292, 9, 292, 4, 293, 9, 293, 4, 294, 9, 294, 4, 295, 9, 295,
	4, 296, 9, 296, 4, 297, 9, 297, 4, 298, 9, 298, 4, 299, 9, 299, 4, 300,
	9, 300, 4, 301, 9, 301, 4, 302, 9, 302, 4, 303, 9, 303, 4, 304, 9, 304,
	4, 305, 9, 305, 4, 306, 9, 306, 4, 307, 9, 307, 4, 308, 9, 308, 4, 309,
	9, 309, 4, 310, 9, 310, 4, 311, 9, 311, 4, 312, 9, 312, 4, 313, 9, 313,
	4, 314, 9, 314, 4, 315, 9, 315, 4, 316, 9, 316, 4, 317, 9, 317, 4, 318,
	9, 318, 4, 319, 9, 319, 4, 320, 9, 320, 4, 321, 9, 321, 4, 322, 9, 322,
	4, 323, 9, 323, 4, 324, 9, 324, 4, 325, 9, 325, 4, 326, 9, 326, 4, 327,
	9, 327, 4, 328, 9, 328, 4, 329, 9, 329, 4, 330, 9, 330, 4, 331, 9, 331,
	4, 332, 9, 332, 4, 333, 9, 333, 4, 334, 9, 334, 4, 335, 9, 335, 4, 336,
	9, 336, 4, 337, 9, 337, 4, 338, 9, 338, 4, 339, 9, 339, 4, 340, 9, 340,
	4, 341, 9, 341, 4, 342, 9, 342, 4, 343, 9, 343, 4, 344, 9, 344, 4, 345,
	9, 345, 4, 346, 9, 346, 4, 347, 9, 347, 4, 348, 9, 348, 4, 349, 9, 349,
	4, 350, 9, 350, 4, 351, 9, 351, 4, 352, 9, 352, 4, 353, 9, 353, 4, 354,
	9, 354, 4, 355, 9, 355, 4, 356, 9, 356, 4, 357, 9, 357, 4, 358, 9, 358,
	4, 359, 9, 359, 4, 360, 9, 360, 4, 361, 9, 361, 4, 362, 9, 362, 4, 363,
	9, 363, 4, 364, 9, 364, 4, 365, 9, 365, 4, 366, 9, 366, 4, 367, 9, 367,
	4, 368, 9, 368, 4, 369, 9, 369, 4, 370, 9, 370, 4, 371, 9, 371, 4, 372,
	9, 372, 4, 373, 9, 373, 4, 374, 9, 374, 4, 375, 9, 375, 4, 376, 9, 376,
	4, 377, 9, 377, 4, 378, 9, 378, 4, 379, 9, 379, 4, 380, 9, 380, 4, 381,
	9, 381, 4, 382, 9, 382, 4, 383, 9, 383, 4, 384, 9, 384, 4, 385, 9, 385,
	4, 386, 9, 386, 4, 387, 9, 387, 4, 388, 9, 388, 4, 389, 9, 389, 4, 390,
	9, 390, 4, 391, 9, 391, 4, 392, 9, 392, 4, 393, 9, 393, 4, 394, 9, 394,
	4, 395, 9, 395, 4, 396, 9, 396, 4, 397, 9, 397, 4, 398, 9, 398, 4, 399,
	9, 399, 4, 400, 9, 400, 4, 401, 9, 401, 4, 402, 9, 402, 4, 403, 9, 403,
	4, 404, 9, 404, 4, 405, 9, 405, 4, 406, 9, 406, 4, 407, 9, 407, 4, 408,
	9, 408, 4, 409, 9, 409, 4, 410, 9, 410, 4, 411, 9, 411, 4, 412, 9, 412,
	4, 413, 9, 413, 4, 414, 9, 414, 4, 415, 9, 415, 4, 416, 9, 416, 4, 417,
	9, 417, 4, 418, 9, 418, 4, 419, 9, 419, 4, 420, 9, 420, 4, 421, 9, 421,
	4, 422, 9, 422, 4, 423, 9, 423, 4, 424, 9, 424, 4, 425, 9, 425, 4, 426,
	9, 426, 4, 427, 9, 427, 4, 428, 9, 428, 4, 429, 9, 429, 4, 430, 9, 430,
	4, 431, 9, 431, 4, 432, 9, 432, 4, 433, 9, 433, 4, 434, 9, 434, 4, 435,
	9, 435, 4, 436, 9, 436, 4, 437, 9, 437, 4, 438, 9, 438, 4, 439, 9, 439,
	4, 440, 9, 440, 4, 441, 9, 441, 4, 442, 9, 442, 4, 443, 9, 443, 4, 444,
	9, 444, 4, 445, 9, 445, 4, 446, 9, 446, 4, 447, 9, 447, 4, 448, 9, 448,
	4, 449, 9, 449, 4, 450, 9, 450, 4, 451, 9, 451, 4, 452, 9, 452, 4, 453,
	9, 453, 4, 454, 9, 454, 4, 455, 9, 455, 4, 456, 9, 456, 4, 457, 9, 457,
	4, 458, 9, 458, 4, 459, 9, 459, 4, 460, 9, 460, 4, 461, 9, 461, 4, 462,
	9, 462, 4, 463, 9, 463, 4, 464, 9, 464, 4, 465, 9, 465, 4, 466, 9, 466,
	4, 467, 9, 467, 4, 468, 9, 468, 4, 469, 9, 469, 4, 470, 9, 470, 4, 471,
	9, 471, 4, 472, 9, 472, 4, 473, 9, 473, 4, 474, 9, 474, 4, 475, 9, 475,
	4, 476, 9, 476, 4, 477, 9, 477, 4, 478, 9, 478, 4, 479, 9, 479, 4, 480,
	9, 480, 4, 481, 9, 481, 4, 482, 9, 482, 4, 483, 9, 483, 4, 484, 9, 484,
	4, 485, 9, 485, 4, 486, 9, 486, 4, 487, 9, 487, 4, 488, 9, 488, 4, 489,
	9, 489, 4, 490, 9, 490, 4, 491, 9, 491, 4, 492, 9, 492, 4, 493, 9, 493,
	4, 494, 9, 494, 4, 495, 9, 495, 4, 496, 9, 496, 4, 497, 9, 497, 4, 498,
	9, 498, 4, 499, 9, 499, 4, 500, 9, 500, 4, 501, 9, 501, 4, 502, 9, 502,
	4, 503, 9, 503, 4, 504, 9, 504, 4, 505, 9, 505, 4, 506, 9, 506, 4, 507,
	9, 507, 4, 508, 9, 508, 4, 509, 9, 509, 4, 510, 9, 510, 4, 511, 9, 511,
	4, 512, 9, 512, 4, 513, 9, 513, 4, 514, 9, 514, 4, 515, 9, 515, 4, 516,
	9, 516, 4, 517, 9, 517, 4, 518, 9, 518, 4, 519, 9, 519, 4, 520, 9, 520,
	4, 521, 9, 521, 4, 522, 9, 522, 4, 523, 9, 523, 4, 524, 9, 524, 4, 525,
	9, 525, 4, 526, 9, 526, 4, 527, 9, 527, 4, 528, 9, 528, 4, 529, 9, 529,
	4, 530, 9, 530, 4, 531, 9, 531, 4, 532, 9, 532, 4, 533, 9, 533, 4, 534,
	9, 534, 4, 535, 9, 535, 4, 536, 9, 536, 4, 537, 9, 537, 4, 538, 9, 538,
	4, 539, 9, 539, 4, 540, 9, 540, 4, 541, 9, 541, 4, 542, 9, 542, 4, 543,
	9, 543, 4, 544, 9, 544, 4, 545, 9, 545, 4, 546, 9, 546, 4, 547, 9, 547,
	4, 548, 9, 548, 4, 549, 9, 549, 4, 550, 9, 550, 4, 551, 9, 551, 4, 552,
	9, 552, 4, 553, 9, 553, 4, 554, 9, 554, 4, 555, 9, 555, 4, 556, 9, 556,
	4, 557, 9, 557, 4, 558, 9, 558, 4, 559, 9, 559, 4, 560, 9, 560, 4, 561,
	9, 561, 4, 562, 9, 562, 4, 563, 9, 563, 4, 564, 9, 564, 4, 565, 9, 565,
	4, 566, 9, 566, 4, 567, 9, 567, 4, 568, 9, 568, 4, 569, 9, 569, 4, 570,
	9, 570, 4, 571, 9, 571, 4, 572, 9, 572, 4, 573, 9, 573, 4, 574, 9, 574,
	4, 575, 9, 575, 4, 576, 9, 576, 4, 577, 9, 577, 4, 578, 9, 578, 4, 579,
	9, 579, 4, 580, 9, 580, 4, 581, 9, 581, 4, 582, 9, 582, 4, 583, 9, 583,
	4, 584, 9, 584, 4, 585, 9, 585, 4, 586, 9, 586, 4, 587, 9, 587, 4, 588,
	9, 588, 4, 589, 9, 589, 4, 590, 9, 590, 4, 591, 9, 591, 4, 592, 9, 592,
	4, 593, 9, 593, 4, 594, 9, 594, 4, 595, 9, 595, 4, 596, 9, 596, 3, 2, 3,
	2, 3, 2, 3, 3, 6, 3, 1197, 10, 3, 13, 3, 14, 3, 1198, 3, 4, 3, 4, 5, 4,
	1203, 10, 4, 3, 4, 5, 4, 1206, 10, 4, 3, 4, 5, 4, 1209, 10, 4, 3, 4, 7,
	4, 1212, 10, 4, 12, 4, 14, 4, 1215, 11, 4, 3, 4, 5, 4, 1218, 10, 4, 3,
	5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 7, 6, 1230, 10,
	6, 12, 6, 14, 6, 1233, 11, 6, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 5, 7,
	1241, 10, 7, 3, 8, 3, 8, 3, 8, 3, 8, 5, 8, 1247, 10, 8, 3, 8, 3, 8, 5,
	8, 1251, 10, 8, 5, 8, 1253, 10, 8, 3, 8, 5, 8, 1256, 10, 8, 3, 8, 5, 8,
	1259, 10, 8, 3, 9, 3, 9, 3, 9, 5, 9, 1264, 10, 9, 3, 10, 3, 10, 3, 10,
	5, 10, 1269, 10, 10, 3, 11, 3, 11, 3, 11, 5, 11, 1274, 10, 11, 3, 12, 3,
	12, 3, 12, 5, 12, 1279, 10, 12, 3, 13, 3, 13, 3, 13, 5, 13, 1284, 10, 13,
	3, 14, 3, 14, 3, 14, 5, 14, 1289, 10, 14, 3, 15, 3, 15, 3, 15, 3, 15, 7,
	15, 1295, 10, 15, 12, 15, 14, 15, 1298, 11, 15, 3, 16, 3, 16, 3, 16, 5,
	16, 1303, 10, 16, 3, 17, 3, 17, 3, 17, 3, 17, 7, 17, 1309, 10, 17, 12,
	17, 14, 17, 1312, 11, 17, 3, 18, 3, 18, 3, 18, 5, 18, 1317, 10, 18, 3,
	19, 3, 19, 3, 19, 3, 19, 5, 19, 1323, 10, 19, 3, 19, 3, 19, 5, 19, 1327,
	10, 19, 3, 19, 3, 19, 3, 20, 3, 20, 3, 20, 3, 20, 7, 20, 1335, 10, 20,
	12, 20, 14, 20, 1338, 11, 20, 3, 20, 3, 20, 3, 21, 3, 21, 3, 21, 3, 21,
	3, 21, 5, 21, 1347, 10, 21, 3, 22, 3, 22, 5, 22, 1351, 10, 22, 3, 22, 3,
	22, 5, 22, 1355, 10, 22, 3, 22, 5, 22, 1358, 10, 22, 3, 23, 3, 23, 5, 23,
	1362, 10, 23, 3, 23, 5, 23, 1365, 10, 23, 3, 23, 3, 23, 5, 23, 1369, 10,
	23, 3, 23, 5, 23, 1372, 10, 23, 3, 24, 5, 24, 1375, 10, 24, 3, 24, 5, 24,
	1378, 10, 24, 3, 24, 3, 24, 5, 24, 1382, 10, 24, 3, 24, 6, 24, 1385, 10,
	24, 13, 24, 14, 24, 1386, 3, 24, 5, 24, 1390, 10, 24, 3, 24, 5, 24, 1393,
	10, 24, 3, 25, 5, 25, 1396, 10, 25, 3, 25, 3, 25, 5, 25, 1400, 10, 25,
	3, 25, 3, 25, 3, 26, 5, 26, 1405, 10, 26, 3, 26, 3, 26, 5, 26, 1409, 10,
	26, 3, 26, 3, 26, 3, 27, 3, 27, 5, 27, 1415, 10, 27, 3, 27, 3, 27, 3, 28,
	3, 28, 3, 28, 3, 28, 3, 29, 3, 29, 3, 29, 6, 29, 1426, 10, 29, 13, 29,
	14, 29, 1427, 3, 29, 3, 29, 5, 29, 1432, 10, 29, 3, 30, 3, 30, 3, 30, 3,
	30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 5, 30, 1445, 10, 30,
	3, 31, 3, 31, 5, 31, 1449, 10, 31, 3, 32, 3, 32, 3, 32, 3, 32, 5, 32, 1455,
	10, 32, 3, 32, 5, 32, 1458, 10, 32, 3, 32, 3, 32, 3, 32, 3, 32, 3, 32,
	3, 32, 3, 32, 6, 32, 1467, 10, 32, 13, 32, 14, 32, 1468, 5, 32, 1471, 10,
	32, 3, 33, 3, 33, 3, 33, 6, 33, 1476, 10, 33, 13, 33, 14, 33, 1477, 5,
	33, 1480, 10, 33, 3, 34, 3, 34, 3, 34, 3, 35, 3, 35, 6, 35, 1487, 10, 35,
	13, 35, 14, 35, 1488, 3, 36, 3, 36, 3, 36, 5, 36, 1494, 10, 36, 3, 36,
	3, 36, 5, 36, 1498, 10, 36, 3, 36, 3, 36, 3, 36, 5, 36, 1503, 10, 36, 3,
	37, 3, 37, 3, 37, 5, 37, 1508, 10, 37, 3, 37, 3, 37, 3, 38, 3, 38, 3, 38,
	5, 38, 1515, 10, 38, 3, 38, 5, 38, 1518, 10, 38, 3, 38, 5, 38, 1521, 10,
	38, 3, 38, 6, 38, 1524, 10, 38, 13, 38, 14, 38, 1525, 3, 39, 3, 39, 3,
	39, 5, 39, 1531, 10, 39, 3, 40, 3, 40, 5, 40, 1535, 10, 40, 3, 41, 3, 41,
	5, 41, 1539, 10, 41, 3, 42, 3, 42, 5, 42, 1543, 10, 42, 3, 42, 5, 42, 1546,
	10, 42, 3, 42, 3, 42, 5, 42, 1550, 10, 42, 3, 42, 3, 42, 3, 42, 5, 42,
	1555, 10, 42, 3, 43, 3, 43, 5, 43, 1559, 10, 43, 3, 43, 3, 43, 3, 44, 3,
	44, 5, 44, 1565, 10, 44, 3, 44, 3, 44, 5, 44, 1569, 10, 44, 5, 44, 1571,
	10, 44, 3, 44, 5, 44, 1574, 10, 44, 3, 44, 3, 44, 5, 44, 1578, 10, 44,
	3, 45, 3, 45, 3, 45, 5, 45, 1583, 10, 45, 5, 45, 1585, 10, 45, 3, 45, 3,
	45, 3, 45, 5, 45, 1590, 10, 45, 5, 45, 1592, 10, 45, 3, 46, 3, 46, 5, 46,
	1596, 10, 46, 3, 46, 3, 46, 5, 46, 1600, 10, 46, 3, 46, 5, 46, 1603, 10,
	46, 3, 47, 3, 47, 5, 47, 1607, 10, 47, 3, 47, 5, 47, 1610, 10, 47, 3, 47,
	3, 47, 3, 47, 5, 47, 1615, 10, 47, 3, 47, 5, 47, 1618, 10, 47, 3, 47, 5,
	47, 1621, 10, 47, 3, 47, 3, 47, 5, 47, 1625, 10, 47, 3, 47, 5, 47, 1628,
	10, 47, 3, 47, 3, 47, 3, 47, 5, 47, 1633, 10, 47, 3, 47, 5, 47, 1636, 10,
	47, 3, 47, 5, 47, 1639, 10, 47, 5, 47, 1641, 10, 47, 3, 48, 3, 48, 5, 48,
	1645, 10, 48, 3, 48, 3, 48, 3, 49, 3, 49, 5, 49, 1651, 10, 49, 3, 49, 5,
	49, 1654, 10, 49, 3, 49, 5, 49, 1657, 10, 49, 3, 49, 3, 49, 5, 49, 1661,
	10, 49, 3, 50, 3, 50, 5, 50, 1665, 10, 50, 3, 50, 5, 50, 1668, 10, 50,
	3, 50, 5, 50, 1671, 10, 50, 3, 50, 6, 50, 1674, 10, 50, 13, 50, 14, 50,
	1675, 3, 50, 3, 50, 5, 50, 1680, 10, 50, 3, 51, 6, 51, 1683, 10, 51, 13,
	51, 14, 51, 1684, 3, 51, 5, 51, 1688, 10, 51, 3, 51, 6, 51, 1691, 10, 51,
	13, 51, 14, 51, 1692, 3, 52, 3, 52, 3, 52, 3, 52, 7, 52, 1699, 10, 52,
	12, 52, 14, 52, 1702, 11, 52, 3, 53, 3, 53, 5, 53, 1706, 10, 53, 3, 54,
	3, 54, 5, 54, 1710, 10, 54, 3, 54, 7, 54, 1713, 10, 54, 12, 54, 14, 54,
	1716, 11, 54, 3, 54, 3, 54, 3, 55, 3, 55, 7, 55, 1722, 10, 55, 12, 55,
	14, 55, 1725, 11, 55, 3, 56, 3, 56, 5, 56, 1729, 10, 56, 3, 56, 3, 56,
	3, 57, 3, 57, 3, 57, 3, 57, 3, 57, 3, 57, 3, 57, 3, 57, 3, 57, 3, 57, 3,
	57, 5, 57, 1744, 10, 57, 3, 58, 3, 58, 5, 58, 1748, 10, 58, 3, 58, 3, 58,
	3, 58, 3, 58, 3, 58, 3, 58, 3, 58, 3, 58, 3, 58, 3, 58, 3, 58, 5, 58, 1761,
	10, 58, 3, 59, 3, 59, 3, 59, 5, 59, 1766, 10, 59, 3, 59, 5, 59, 1769, 10,
	59, 3, 59, 5, 59, 1772, 10, 59, 3, 60, 3, 60, 5, 60, 1776, 10, 60, 5, 60,
	1778, 10, 60, 3, 60, 3, 60, 3, 60, 3, 60, 3, 60, 5, 60, 1785, 10, 60, 3,
	60, 3, 60, 3, 61, 3, 61, 5, 61, 1791, 10, 61, 3, 61, 5, 61, 1794, 10, 61,
	3, 61, 3, 61, 5, 61, 1798, 10, 61, 3, 62, 3, 62, 3, 62, 5, 62, 1803, 10,
	62, 3, 62, 3, 62, 3, 62, 5, 62, 1808, 10, 62, 3, 63, 3, 63, 5, 63, 1812,
	10, 63, 3, 63, 5, 63, 1815, 10, 63, 3, 63, 3, 63, 3, 64, 3, 64, 5, 64,
	1821, 10, 64, 3, 64, 5, 64, 1824, 10, 64, 3, 64, 3, 64, 5, 64, 1828, 10,
	64, 3, 64, 5, 64, 1831, 10, 64, 3, 64, 5, 64, 1834, 10, 64, 3, 65, 3, 65,
	3, 65, 5, 65, 1839, 10, 65, 3, 65, 5, 65, 1842, 10, 65, 3, 65, 3, 65, 5,
	65, 1846, 10, 65, 3, 65, 5, 65, 1849, 10, 65, 3, 65, 5, 65, 1852, 10, 65,
	3, 66, 3, 66, 5, 66, 1856, 10, 66, 3, 66, 3, 66, 3, 67, 5, 67, 1861, 10,
	67, 3, 67, 3, 67, 5, 67, 1865, 10, 67, 3, 67, 3, 67, 5, 67, 1869, 10, 67,
	3, 68, 3, 68, 5, 68, 1873, 10, 68, 3, 68, 5, 68, 1876, 10, 68, 3, 68, 3,
	68, 3, 69, 3, 69, 3, 69, 3, 69, 3, 69, 5, 69, 1885, 10, 69, 3, 69, 7, 69,
	1888, 10, 69, 12, 69, 14, 69, 1891, 11, 69, 3, 69, 5, 69, 1894, 10, 69,
	3, 70, 3, 70, 3, 70, 3, 70, 5, 70, 1900, 10, 70, 3, 71, 3, 71, 3, 71, 3,
	71, 5, 71, 1906, 10, 71, 5, 71, 1908, 10, 71, 3, 71, 3, 71, 3, 71, 3, 71,
	5, 71, 1914, 10, 71, 3, 72, 3, 72, 3, 72, 3, 73, 5, 73, 1920, 10, 73, 3,
	73, 5, 73, 1923, 10, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 74, 3, 74, 5, 74,
	1931, 10, 74, 3, 75, 3, 75, 5, 75, 1935, 10, 75, 3, 75, 5, 75, 1938, 10,
	75, 3, 75, 5, 75, 1941, 10, 75, 3, 75, 6, 75, 1944, 10, 75, 13, 75, 14,
	75, 1945, 3, 76, 3, 76, 3, 76, 5, 76, 1951, 10, 76, 3, 76, 5, 76, 1954,
	10, 76, 3, 76, 6, 76, 1957, 10, 76, 13, 76, 14, 76, 1958, 3, 77, 3, 77,
	3, 77, 5, 77, 1964, 10, 77, 3, 78, 3, 78, 3, 78, 5, 78, 1969, 10, 78, 3,
	78, 3, 78, 3, 79, 3, 79, 3, 79, 3, 79, 7, 79, 1977, 10, 79, 12, 79, 14,
	79, 1980, 11, 79, 3, 80, 3, 80, 3, 80, 3, 80, 3, 80, 3, 80, 3, 80, 3, 80,
	3, 80, 5, 80, 1991, 10, 80, 3, 81, 3, 81, 3, 81, 3, 81, 7, 81, 1997, 10,
	81, 12, 81, 14, 81, 2000, 11, 81, 3, 82, 3, 82, 3, 82, 5, 82, 2005, 10,
	82, 3, 82, 7, 82, 2008, 10, 82, 12, 82, 14, 82, 2011, 11, 82, 3, 82, 3,
	82, 7, 82, 2015, 10, 82, 12, 82, 14, 82, 2018, 11, 82, 3, 83, 3, 83, 3,
	83, 3, 83, 3, 83, 3, 83, 3, 83, 3, 83, 3, 83, 3, 83, 3, 83, 5, 83, 2031,
	10, 83, 3, 84, 5, 84, 2034, 10, 84, 3, 84, 3, 84, 3, 85, 5, 85, 2039, 10,
	85, 3, 85, 3, 85, 3, 86, 3, 86, 5, 86, 2045, 10, 86, 3, 86, 3, 86, 5, 86,
	2049, 10, 86, 3, 86, 5, 86, 2052, 10, 86, 3, 87, 3, 87, 3, 87, 3, 88, 3,
	88, 3, 88, 3, 88, 5, 88, 2061, 10, 88, 3, 89, 5, 89, 2064, 10, 89, 3, 89,
	3, 89, 5, 89, 2068, 10, 89, 3, 90, 5, 90, 2071, 10, 90, 3, 90, 3, 90, 5,
	90, 2075, 10, 90, 3, 90, 5, 90, 2078, 10, 90, 3, 90, 5, 90, 2081, 10, 90,
	3, 90, 3, 90, 5, 90, 2085, 10, 90, 3, 90, 5, 90, 2088, 10, 90, 5, 90, 2090,
	10, 90, 3, 90, 3, 90, 5, 90, 2094, 10, 90, 3, 90, 5, 90, 2097, 10, 90,
	3, 91, 5, 91, 2100, 10, 91, 3, 91, 3, 91, 3, 91, 5, 91, 2105, 10, 91, 3,
	92, 3, 92, 3, 92, 3, 93, 3, 93, 3, 93, 5, 93, 2113, 10, 93, 3, 93, 3, 93,
	5, 93, 2117, 10, 93, 5, 93, 2119, 10, 93, 3, 93, 3, 93, 3, 93, 6, 93, 2124,
	10, 93, 13, 93, 14, 93, 2125, 5, 93, 2128, 10, 93, 3, 94, 3, 94, 3, 94,
	6, 94, 2133, 10, 94, 13, 94, 14, 94, 2134, 3, 95, 3, 95, 5, 95, 2139, 10,
	95, 3, 95, 3, 95, 5, 95, 2143, 10, 95, 3, 96, 3, 96, 3, 96, 5, 96, 2148,
	10, 96, 3, 96, 3, 96, 5, 96, 2152, 10, 96, 5, 96, 2154, 10, 96, 3, 96,
	6, 96, 2157, 10, 96, 13, 96, 14, 96, 2158, 3, 97, 3, 97, 5, 97, 2163, 10,
	97, 3, 97, 3, 97, 5, 97, 2167, 10, 97, 3, 97, 5, 97, 2170, 10, 97, 3, 97,
	7, 97, 2173, 10, 97, 12, 97, 14, 97, 2176, 11, 97, 3, 98, 3, 98, 3, 98,
	5, 98, 2181, 10, 98, 3, 99, 5, 99, 2184, 10, 99, 3, 99, 3, 99, 5, 99, 2188,
	10, 99, 3, 99, 3, 99, 5, 99, 2192, 10, 99, 3, 100, 5, 100, 2195, 10, 100,
	3, 100, 5, 100, 2198, 10, 100, 3, 100, 3, 100, 3, 100, 5, 100, 2203, 10,
	100, 3, 101, 5, 101, 2206, 10, 101, 3, 101, 5, 101, 2209, 10, 101, 3, 101,
	3, 101, 3, 101, 5, 101, 2214, 10, 101, 3, 102, 3, 102, 5, 102, 2218, 10,
	102, 3, 102, 5, 102, 2221, 10, 102, 3, 102, 3, 102, 3, 103, 3, 103, 3,
	104, 3, 104, 5, 104, 2229, 10, 104, 3, 104, 3, 104, 3, 105, 3, 105, 5,
	105, 2235, 10, 105, 3, 105, 3, 105, 5, 105, 2239, 10, 105, 5, 105, 2241,
	10, 105, 3, 105, 6, 105, 2244, 10, 105, 13, 105, 14, 105, 2245, 3, 106,
	3, 106, 3, 106, 3, 106, 7, 106, 2252, 10, 106, 12, 106, 14, 106, 2255,
	11, 106, 3, 107, 3, 107, 3, 107, 3, 107, 3, 107, 3, 108, 3, 108, 3, 108,
	3, 108, 7, 108, 2266, 10, 108, 12, 108, 14, 108, 2269, 11, 108, 3, 109,
	3, 109, 3, 109, 3, 109, 7, 109, 2275, 10, 109, 12, 109, 14, 109, 2278,
	11, 109, 3, 110, 3, 110, 3, 110, 3, 110, 3, 110, 7, 110, 2285, 10, 110,
	12, 110, 14, 110, 2288, 11, 110, 3, 111, 3, 111, 3, 111, 5, 111, 2293,
	10, 111, 3, 112, 3, 112, 3, 112, 5, 112, 2298, 10, 112, 3, 112, 5, 112,
	2301, 10, 112, 3, 112, 3, 112, 3, 112, 3, 112, 3, 112, 3, 112, 3, 112,
	3, 112, 3, 112, 3, 112, 5, 112, 2313, 10, 112, 3, 112, 7, 112, 2316, 10,
	112, 12, 112, 14, 112, 2319, 11, 112, 3, 112, 3, 112, 3, 113, 3, 113, 3,
	113, 5, 113, 2326, 10, 113, 3, 113, 3, 113, 3, 113, 3, 113, 3, 113, 3,
	113, 3, 113, 7, 113, 2335, 10, 113, 12, 113, 14, 113, 2338, 11, 113, 3,
	113, 3, 113, 3, 114, 3, 114, 3, 114, 5, 114, 2345, 10, 114, 3, 114, 3,
	114, 3, 114, 3, 114, 3, 114, 3, 114, 3, 114, 3, 114, 5, 114, 2355, 10,
	114, 3, 114, 7, 114, 2358, 10, 114, 12, 114, 14, 114, 2361, 11, 114, 3,
	114, 3, 114, 3, 115, 3, 115, 3, 115, 5, 115, 2368, 10, 115, 3, 115, 3,
	115, 3, 116, 3, 116, 3, 116, 3, 116, 3, 116, 3, 116, 3, 116, 3, 116, 6,
	116, 2380, 10, 116, 13, 116, 14, 116, 2381, 5, 116, 2384, 10, 116, 3, 117,
	3, 117, 3, 117, 5, 117, 2389, 10, 117, 3, 117, 3, 117, 3, 118, 3, 118,
	3, 118, 5, 118, 2396, 10, 118, 3, 118, 3, 118, 3, 119, 5, 119, 2401, 10,
	119, 3, 119, 3, 119, 5, 119, 2405, 10, 119, 3, 119, 3, 119, 3, 120, 3,
	120, 3, 120, 5, 120, 2412, 10, 120, 3, 120, 3, 120, 3, 121, 3, 121, 3,
	121, 5, 121, 2419, 10, 121, 3, 121, 3, 121, 3, 122, 3, 122, 3, 122, 5,
	122, 2426, 10, 122, 3, 122, 3, 122, 3, 123, 5, 123, 2431, 10, 123, 3, 123,
	3, 123, 5, 123, 2435, 10, 123, 3, 123, 3, 123, 3, 124, 5, 124, 2440, 10,
	124, 3, 124, 3, 124, 5, 124, 2444, 10, 124, 3, 124, 3, 124, 3, 125, 5,
	125, 2449, 10, 125, 3, 125, 3, 125, 5, 125, 2453, 10, 125, 3, 125, 3, 125,
	3, 126, 5, 126, 2458, 10, 126, 3, 126, 3, 126, 5, 126, 2462, 10, 126, 3,
	126, 3, 126, 3, 127, 5, 127, 2467, 10, 127, 3, 127, 3, 127, 5, 127, 2471,
	10, 127, 3, 127, 3, 127, 3, 128, 3, 128, 3, 128, 5, 128, 2478, 10, 128,
	3, 128, 3, 128, 3, 129, 3, 129, 3, 129, 3, 129, 3, 129, 3, 129, 3, 129,
	5, 129, 2489, 10, 129, 3, 129, 7, 129, 2492, 10, 129, 12, 129, 14, 129,
	2495, 11, 129, 3, 130, 3, 130, 3, 130, 3, 130, 7, 130, 2501, 10, 130, 12,
	130, 14, 130, 2504, 11, 130, 3, 131, 3, 131, 3, 131, 5, 131, 2509, 10,
	131, 3, 131, 3, 131, 3, 131, 3, 131, 3, 131, 3, 131, 3, 131, 3, 131, 3,
	131, 3, 131, 3, 131, 3, 131, 3, 131, 3, 131, 3, 131, 3, 131, 3, 131, 3,
	131, 5, 131, 2529, 10, 131, 3, 131, 3, 131, 3, 131, 3, 131, 3, 131, 3,
	131, 3, 131, 3, 131, 3, 131, 3, 131, 7, 131, 2541, 10, 131, 12, 131, 14,
	131, 2544, 11, 131, 3, 131, 3, 131, 3, 132, 3, 132, 3, 132, 3, 133, 3,
	133, 3, 134, 3, 134, 3, 135, 3, 135, 3, 135, 3, 136, 3, 136, 3, 137, 3,
	137, 3, 138, 3, 138, 3, 139, 3, 139, 3, 140, 3, 140, 5, 140, 2568, 10,
	140, 3, 140, 3, 140, 5, 140, 2572, 10, 140, 3, 141, 3, 141, 5, 141, 2576,
	10, 141, 3, 141, 5, 141, 2579, 10, 141, 3, 141, 5, 141, 2582, 10, 141,
	3, 141, 3, 141, 5, 141, 2586, 10, 141, 3, 142, 3, 142, 5, 142, 2590, 10,
	142, 3, 142, 5, 142, 2593, 10, 142, 3, 142, 5, 142, 2596, 10, 142, 3, 142,
	3, 142, 5, 142, 2600, 10, 142, 3, 143, 3, 143, 5, 143, 2604, 10, 143, 3,
	143, 3, 143, 5, 143, 2608, 10, 143, 3, 144, 3, 144, 5, 144, 2612, 10, 144,
	3, 144, 3, 144, 5, 144, 2616, 10, 144, 3, 145, 3, 145, 5, 145, 2620, 10,
	145, 3, 145, 3, 145, 3, 146, 3, 146, 5, 146, 2626, 10, 146, 3, 146, 3,
	146, 3, 147, 3, 147, 5, 147, 2632, 10, 147, 3, 147, 3, 147, 3, 148, 3,
	148, 3, 148, 5, 148, 2639, 10, 148, 3, 148, 5, 148, 2642, 10, 148, 3, 149,
	3, 149, 3, 149, 3, 150, 3, 150, 3, 150, 3, 151, 3, 151, 5, 151, 2652, 10,
	151, 3, 151, 3, 151, 3, 152, 3, 152, 5, 152, 2658, 10, 152, 3, 152, 3,
	152, 3, 153, 3, 153, 5, 153, 2664, 10, 153, 3, 154, 3, 154, 5, 154, 2668,
	10, 154, 5, 154, 2670, 10, 154, 3, 154, 3, 154, 3, 154, 5, 154, 2675, 10,
	154, 5, 154, 2677, 10, 154, 3, 155, 3, 155, 3, 156, 3, 156, 3, 157, 3,
	157, 3, 158, 3, 158, 5, 158, 2687, 10, 158, 3, 158, 5, 158, 2690, 10, 158,
	3, 158, 3, 158, 5, 158, 2694, 10, 158, 3, 158, 5, 158, 2697, 10, 158, 3,
	159, 3, 159, 3, 159, 5, 159, 2702, 10, 159, 3, 160, 3, 160, 3, 161, 3,
	161, 3, 162, 3, 162, 3, 162, 3, 162, 7, 162, 2712, 10, 162, 12, 162, 14,
	162, 2715, 11, 162, 3, 163, 3, 163, 6, 163, 2719, 10, 163, 13, 163, 14,
	163, 2720, 3, 164, 3, 164, 3, 164, 5, 164, 2726, 10, 164, 3, 164, 3, 164,
	5, 164, 2730, 10, 164, 3, 164, 5, 164, 2733, 10, 164, 3, 164, 5, 164, 2736,
	10, 164, 3, 164, 5, 164, 2739, 10, 164, 5, 164, 2741, 10, 164, 3, 164,
	3, 164, 3, 165, 5, 165, 2746, 10, 165, 3, 165, 3, 165, 3, 166, 3, 166,
	3, 166, 5, 166, 2753, 10, 166, 3, 166, 3, 166, 5, 166, 2757, 10, 166, 5,
	166, 2759, 10, 166, 3, 166, 3, 166, 5, 166, 2763, 10, 166, 3, 167, 3, 167,
	3, 167, 3, 168, 3, 168, 3, 168, 3, 168, 3, 169, 3, 169, 3, 169, 3, 169,
	3, 170, 3, 170, 3, 170, 3, 171, 3, 171, 3, 171, 5, 171, 2782, 10, 171,
	3, 172, 3, 172, 3, 172, 5, 172, 2787, 10, 172, 3, 172, 5, 172, 2790, 10,
	172, 3, 172, 3, 172, 5, 172, 2794, 10, 172, 3, 172, 3, 172, 3, 173, 3,
	173, 5, 173, 2800, 10, 173, 3, 173, 5, 173, 2803, 10, 173, 3, 173, 3, 173,
	3, 173, 3, 174, 3, 174, 5, 174, 2810, 10, 174, 3, 174, 3, 174, 3, 174,
	3, 174, 3, 174, 3, 174, 3, 174, 3, 174, 3, 174, 3, 174, 3, 174, 5, 174,
	2823, 10, 174, 3, 174, 7, 174, 2826, 10, 174, 12, 174, 14, 174, 2829, 11,
	174, 3, 174, 3, 174, 3, 175, 3, 175, 5, 175, 2835, 10, 175, 3, 175, 3,
	175, 3, 176, 3, 176, 5, 176, 2841, 10, 176, 3, 176, 5, 176, 2844, 10, 176,
	3, 176, 3, 176, 3, 177, 3, 177, 5, 177, 2850, 10, 177, 3, 178, 3, 178,
	5, 178, 2854, 10, 178, 3, 179, 5, 179, 2857, 10, 179, 3, 179, 5, 179, 2860,
	10, 179, 3, 179, 5, 179, 2863, 10, 179, 3, 179, 3, 179, 5, 179, 2867, 10,
	179, 3, 180, 3, 180, 5, 180, 2871, 10, 180, 3, 180, 3, 180, 5, 180, 2875,
	10, 180, 3, 181, 3, 181, 3, 181, 3, 182, 3, 182, 3, 182, 5, 182, 2883,
	10, 182, 3, 182, 3, 182, 3, 182, 5, 182, 2888, 10, 182, 3, 183, 3, 183,
	3, 183, 3, 184, 3, 184, 3, 184, 3, 185, 3, 185, 5, 185, 2898, 10, 185,
	3, 185, 3, 185, 3, 186, 3, 186, 5, 186, 2904, 10, 186, 3, 186, 3, 186,
	5, 186, 2908, 10, 186, 3, 187, 3, 187, 5, 187, 2912, 10, 187, 3, 187, 3,
	187, 3, 187, 5, 187, 2917, 10, 187, 3, 188, 3, 188, 5, 188, 2921, 10, 188,
	3, 188, 3, 188, 3, 189, 3, 189, 3, 189, 5, 189, 2928, 10, 189, 3, 189,
	7, 189, 2931, 10, 189, 12, 189, 14, 189, 2934, 11, 189, 3, 189, 3, 189,
	3, 189, 5, 189, 2939, 10, 189, 3, 189, 7, 189, 2942, 10, 189, 12, 189,
	14, 189, 2945, 11, 189, 5, 189, 2947, 10, 189, 3, 190, 3, 190, 5, 190,
	2951, 10, 190, 3, 190, 3, 190, 3, 190, 3, 190, 3, 190, 3, 190, 3, 190,
	5, 190, 2960, 10, 190, 3, 191, 3, 191, 3, 191, 5, 191, 2965, 10, 191, 3,
	192, 3, 192, 3, 192, 5, 192, 2970, 10, 192, 3, 193, 3, 193, 3, 193, 5,
	193, 2975, 10, 193, 3, 193, 3, 193, 5, 193, 2979, 10, 193, 3, 194, 3, 194,
	3, 195, 3, 195, 3, 195, 5, 195, 2986, 10, 195, 3, 195, 3, 195, 5, 195,
	2990, 10, 195, 3, 196, 3, 196, 5, 196, 2994, 10, 196, 5, 196, 2996, 10,
	196, 3, 196, 3, 196, 3, 197, 3, 197, 3, 197, 5, 197, 3003, 10, 197, 3,
	198, 3, 198, 3, 198, 5, 198, 3008, 10, 198, 3, 199, 3, 199, 5, 199, 3012,
	10, 199, 3, 199, 3, 199, 3, 200, 3, 200, 3, 200, 3, 200, 7, 200, 3020,
	10, 200, 12, 200, 14, 200, 3023, 11, 200, 3, 201, 3, 201, 5, 201, 3027,
	10, 201, 3, 202, 3, 202, 3, 202, 3, 202, 5, 202, 3033, 10, 202, 3, 202,
	5, 202, 3036, 10, 202, 3, 203, 3, 203, 3, 203, 3, 203, 5, 203, 3042, 10,
	203, 3, 203, 5, 203, 3045, 10, 203, 3, 203, 3, 203, 7, 203, 3049, 10, 203,
	12, 203, 14, 203, 3052, 11, 203, 3, 204, 3, 204, 3, 204, 5, 204, 3057,
	10, 204, 3, 204, 5, 204, 3060, 10, 204, 3, 205, 3, 205, 5, 205, 3064, 10,
	205, 3, 205, 3, 205, 5, 205, 3068, 10, 205, 3, 205, 5, 205, 3071, 10, 205,
	3, 205, 5, 205, 3074, 10, 205, 3, 205, 5, 205, 3077, 10, 205, 3, 206, 3,
	206, 3, 206, 3, 206, 3, 207, 3, 207, 5, 207, 3085, 10, 207, 3, 207, 3,
	207, 3, 208, 3, 208, 5, 208, 3091, 10, 208, 3, 208, 3, 208, 3, 209, 3,
	209, 3, 209, 5, 209, 3098, 10, 209, 3, 210, 3, 210, 3, 210, 5, 210, 3103,
	10, 210, 3, 210, 5, 210, 3106, 10, 210, 3, 210, 5, 210, 3109, 10, 210,
	3, 210, 5, 210, 3112, 10, 210, 3, 211, 3, 211, 3, 211, 3, 212, 3, 212,
	3, 212, 3, 213, 3, 213, 6, 213, 3122, 10, 213, 13, 213, 14, 213, 3123,
	3, 214, 3, 214, 5, 214, 3128, 10, 214, 3, 215, 3, 215, 6, 215, 3132, 10,
	215, 13, 215, 14, 215, 3133, 3, 216, 3, 216, 5, 216, 3138, 10, 216, 3,
	217, 5, 217, 3141, 10, 217, 3, 217, 3, 217, 3, 218, 5, 218, 3146, 10, 218,
	3, 218, 3, 218, 3, 219, 3, 219, 3, 219, 3, 219, 5, 219, 3154, 10, 219,
	3, 220, 3, 220, 3, 220, 5, 220, 3159, 10, 220, 3, 220, 3, 220, 3, 220,
	3, 220, 3, 220, 3, 220, 3, 220, 3, 220, 3, 220, 3, 220, 3, 220, 3, 220,
	3, 220, 3, 220, 3, 220, 3, 220, 3, 220, 3, 220, 3, 220, 3, 220, 3, 220,
	7, 220, 3182, 10, 220, 12, 220, 14, 220, 3185, 11, 220, 3, 220, 3, 220,
	3, 221, 3, 221, 3, 221, 3, 221, 3, 221, 3, 222, 3, 222, 3, 222, 3, 222,
	3, 222, 3, 223, 6, 223, 3200, 10, 223, 13, 223, 14, 223, 3201, 3, 223,
	5, 223, 3205, 10, 223, 3, 224, 3, 224, 3, 225, 3, 225, 5, 225, 3211, 10,
	225, 3, 225, 3, 225, 3, 226, 3, 226, 3, 227, 5, 227, 3218, 10, 227, 3,
	227, 3, 227, 3, 227, 5, 227, 3223, 10, 227, 3, 228, 5, 228, 3226, 10, 228,
	3, 228, 3, 228, 3, 229, 3, 229, 3, 230, 3, 230, 5, 230, 3234, 10, 230,
	3, 231, 3, 231, 3, 231, 5, 231, 3239, 10, 231, 3, 231, 5, 231, 3242, 10,
	231, 3, 231, 3, 231, 5, 231, 3246, 10, 231, 3, 231, 5, 231, 3249, 10, 231,
	3, 231, 7, 231, 3252, 10, 231, 12, 231, 14, 231, 3255, 11, 231, 3, 231,
	3, 231, 5, 231, 3259, 10, 231, 3, 231, 5, 231, 3262, 10, 231, 3, 231, 6,
	231, 3265, 10, 231, 13, 231, 14, 231, 3266, 5, 231, 3269, 10, 231, 3, 232,
	3, 232, 3, 232, 3, 233, 3, 233, 5, 233, 3276, 10, 233, 3, 233, 5, 233,
	3279, 10, 233, 3, 233, 6, 233, 3282, 10, 233, 13, 233, 14, 233, 3283, 3,
	234, 3, 234, 5, 234, 3288, 10, 234, 3, 234, 3, 234, 3, 235, 6, 235, 3293,
	10, 235, 13, 235, 14, 235, 3294, 3, 235, 5, 235, 3298, 10, 235, 6, 235,
	3300, 10, 235, 13, 235, 14, 235, 3301, 3, 236, 3, 236, 3, 236, 3, 236,
	3, 236, 3, 236, 3, 236, 3, 236, 3, 236, 3, 236, 3, 236, 3, 236, 3, 236,
	3, 236, 3, 236, 3, 236, 5, 236, 3320, 10, 236, 3, 237, 3, 237, 3, 237,
	3, 237, 3, 238, 5, 238, 3327, 10, 238, 3, 238, 5, 238, 3330, 10, 238, 3,
	238, 3, 238, 3, 239, 3, 239, 3, 239, 3, 240, 3, 240, 3, 240, 3, 241, 3,
	241, 3, 241, 3, 241, 5, 241, 3344, 10, 241, 3, 242, 3, 242, 5, 242, 3348,
	10, 242, 5, 242, 3350, 10, 242, 3, 242, 3, 242, 3, 242, 5, 242, 3355, 10,
	242, 5, 242, 3357, 10, 242, 3, 243, 3, 243, 5, 243, 3361, 10, 243, 3, 244,
	5, 244, 3364, 10, 244, 3, 244, 3, 244, 3, 245, 3, 245, 5, 245, 3370, 10,
	245, 3, 245, 3, 245, 3, 246, 5, 246, 3375, 10, 246, 3, 246, 3, 246, 3,
	247, 3, 247, 5, 247, 3381, 10, 247, 5, 247, 3383, 10, 247, 3, 247, 3, 247,
	5, 247, 3387, 10, 247, 3, 247, 3, 247, 3, 247, 3, 247, 3, 247, 3, 247,
	3, 247, 3, 247, 3, 247, 3, 247, 3, 247, 3, 247, 3, 247, 3, 247, 3, 247,
	3, 247, 3, 247, 3, 247, 3, 247, 3, 247, 3, 247, 3, 247, 3, 247, 3, 247,
	3, 247, 3, 247, 3, 247, 3, 247, 3, 247, 5, 247, 3418, 10, 247, 3, 248,
	3, 248, 3, 248, 5, 248, 3423, 10, 248, 3, 248, 3, 248, 5, 248, 3427, 10,
	248, 3, 249, 3, 249, 5, 249, 3431, 10, 249, 3, 249, 3, 249, 5, 249, 3435,
	10, 249, 5, 249, 3437, 10, 249, 3, 249, 3, 249, 5, 249, 3441, 10, 249,
	3, 249, 7, 249, 3444, 10, 249, 12, 249, 14, 249, 3447, 11, 249, 3, 250,
	3, 250, 5, 250, 3451, 10, 250, 3, 251, 3, 251, 5, 251, 3455, 10, 251, 3,
	252, 3, 252, 3, 252, 3, 253, 5, 253, 3461, 10, 253, 3, 253, 3, 253, 3,
	253, 3, 254, 3, 254, 3, 254, 5, 254, 3469, 10, 254, 3, 254, 5, 254, 3472,
	10, 254, 3, 254, 3, 254, 5, 254, 3476, 10, 254, 3, 254, 3, 254, 3, 255,
	3, 255, 6, 255, 3482, 10, 255, 13, 255, 14, 255, 3483, 3, 256, 3, 256,
	3, 256, 3, 257, 3, 257, 5, 257, 3491, 10, 257, 3, 258, 5, 258, 3494, 10,
	258, 3, 258, 5, 258, 3497, 10, 258, 3, 258, 6, 258, 3500, 10, 258, 13,
	258, 14, 258, 3501, 3, 259, 5, 259, 3505, 10, 259, 3, 259, 3, 259, 5, 259,
	3509, 10, 259, 3, 259, 5, 259, 3512, 10, 259, 3, 260, 5, 260, 3515, 10,
	260, 3, 260, 3, 260, 6, 260, 3519, 10, 260, 13, 260, 14, 260, 3520, 3,
	261, 3, 261, 3, 261, 5, 261, 3526, 10, 261, 3, 262, 3, 262, 3, 262, 6,
	262, 3531, 10, 262, 13, 262, 14, 262, 3532, 3, 262, 3, 262, 3, 262, 3,
	262, 3, 263, 3, 263, 3, 263, 3, 263, 3, 263, 3, 263, 3, 264, 3, 264, 3,
	264, 5, 264, 3548, 10, 264, 3, 265, 3, 265, 7, 265, 3552, 10, 265, 12,
	265, 14, 265, 3555, 11, 265, 3, 266, 3, 266, 3, 266, 3, 266, 3, 267, 7,
	267, 3562, 10, 267, 12, 267, 14, 267, 3565, 11, 267, 3, 267, 7, 267, 3568,
	10, 267, 12, 267, 14, 267, 3571, 11, 267, 3, 268, 3, 268, 3, 268, 3, 268,
	7, 268, 3577, 10, 268, 12, 268, 14, 268, 3580, 11, 268, 5, 268, 3582, 10,
	268, 3, 269, 7, 269, 3585, 10, 269, 12, 269, 14, 269, 3588, 11, 269, 3,
	269, 3, 269, 3, 270, 3, 270, 3, 270, 3, 270, 3, 270, 3, 270, 3, 270, 3,
	270, 3, 270, 3, 270, 3, 270, 3, 270, 3, 270, 3, 270, 3, 270, 3, 270, 3,
	270, 3, 270, 3, 270, 3, 270, 3, 270, 3, 270, 3, 270, 3, 270, 3, 270, 3,
	270, 3, 270, 3, 270, 3, 270, 3, 270, 3, 270, 3, 270, 3, 270, 3, 270, 3,
	270, 3, 270, 3, 270, 3, 270, 3, 270, 3, 270, 3, 270, 3, 270, 3, 270, 3,
	270, 3, 270, 3, 270, 3, 270, 3, 270, 3, 270, 5, 270, 3641, 10, 270, 3,
	271, 3, 271, 3, 271, 3, 271, 3, 271, 3, 271, 5, 271, 3649, 10, 271, 3,
	271, 5, 271, 3652, 10, 271, 3, 271, 5, 271, 3655, 10, 271, 3, 271, 5, 271,
	3658, 10, 271, 3, 272, 3, 272, 3, 272, 5, 272, 3663, 10, 272, 3, 272, 3,
	272, 5, 272, 3667, 10, 272, 3, 272, 3, 272, 3, 272, 3, 272, 3, 272, 5,
	272, 3674, 10, 272, 3, 272, 3, 272, 3, 272, 3, 272, 5, 272, 3680, 10, 272,
	3, 273, 3, 273, 3, 273, 3, 274, 3, 274, 3, 274, 3, 274, 3, 275, 5, 275,
	3690, 10, 275, 3, 275, 3, 275, 3, 276, 3, 276, 3, 276, 3, 276, 5, 276,
	3698, 10, 276, 3, 276, 5, 276, 3701, 10, 276, 3, 276, 5, 276, 3704, 10,
	276, 3, 276, 5, 276, 3707, 10, 276, 3, 277, 6, 277, 3710, 10, 277, 13,
	277, 14, 277, 3711, 3, 277, 3, 277, 6, 277, 3716, 10, 277, 13, 277, 14,
	277, 3717, 3, 278, 6, 278, 3721, 10, 278, 13, 278, 14, 278, 3722, 3, 278,
	3, 278, 6, 278, 3727, 10, 278, 13, 278, 14, 278, 3728, 5, 278, 3731, 10,
	278, 3, 278, 3, 278, 6, 278, 3735, 10, 278, 13, 278, 14, 278, 3736, 3,
	279, 3, 279, 3, 279, 3, 279, 3, 279, 3, 280, 3, 280, 5, 280, 3746, 10,
	280, 3, 281, 3, 281, 5, 281, 3750, 10, 281, 3, 282, 3, 282, 5, 282, 3754,
	10, 282, 3, 283, 3, 283, 5, 283, 3758, 10, 283, 3, 284, 3, 284, 5, 284,
	3762, 10, 284, 3, 284, 3, 284, 3, 285, 3, 285, 6, 285, 3768, 10, 285, 13,
	285, 14, 285, 3769, 3, 286, 3, 286, 3, 286, 3, 286, 5, 286, 3776, 10, 286,
	3, 286, 3, 286, 3, 287, 3, 287, 3, 287, 5, 287, 3783, 10, 287, 3, 287,
	5, 287, 3786, 10, 287, 3, 287, 5, 287, 3789, 10, 287, 3, 287, 5, 287, 3792,
	10, 287, 3, 287, 5, 287, 3795, 10, 287, 3, 287, 5, 287, 3798, 10, 287,
	3, 287, 5, 287, 3801, 10, 287, 3, 288, 3, 288, 6, 288, 3805, 10, 288, 13,
	288, 14, 288, 3806, 3, 289, 3, 289, 3, 289, 5, 289, 3812, 10, 289, 3, 290,
	5, 290, 3815, 10, 290, 3, 290, 5, 290, 3818, 10, 290, 3, 290, 6, 290, 3821,
	10, 290, 13, 290, 14, 290, 3822, 3, 291, 3, 291, 3, 291, 3, 291, 5, 291,
	3829, 10, 291, 3, 291, 3, 291, 3, 291, 5, 291, 3834, 10, 291, 3, 291, 5,
	291, 3837, 10, 291, 3, 292, 5, 292, 3840, 10, 292, 3, 292, 3, 292, 6, 292,
	3844, 10, 292, 13, 292, 14, 292, 3845, 3, 293, 3, 293, 3, 293, 3, 293,
	5, 293, 3852, 10, 293, 5, 293, 3854, 10, 293, 3, 293, 3, 293, 5, 293, 3858,
	10, 293, 3, 294, 5, 294, 3861, 10, 294, 3, 294, 3, 294, 6, 294, 3865, 10,
	294, 13, 294, 14, 294, 3866, 3, 295, 3, 295, 3, 295, 3, 295, 5, 295, 3873,
	10, 295, 5, 295, 3875, 10, 295, 3, 295, 3, 295, 3, 295, 5, 295, 3880, 10,
	295, 3, 296, 3, 296, 3, 296, 3, 297, 3, 297, 6, 297, 3887, 10, 297, 13,
	297, 14, 297, 3888, 3, 298, 3, 298, 3, 298, 3, 298, 3, 298, 5, 298, 3896,
	10, 298, 3, 299, 3, 299, 6, 299, 3900, 10, 299, 13, 299, 14, 299, 3901,
	3, 300, 3, 300, 3, 300, 3, 300, 5, 300, 3908, 10, 300, 3, 301, 3, 301,
	5, 301, 3912, 10, 301, 3, 301, 5, 301, 3915, 10, 301, 3, 301, 5, 301, 3918,
	10, 301, 3, 301, 3, 301, 3, 301, 5, 301, 3923, 10, 301, 5, 301, 3925, 10,
	301, 3, 302, 5, 302, 3928, 10, 302, 3, 302, 3, 302, 3, 302, 5, 302, 3933,
	10, 302, 3, 303, 5, 303, 3936, 10, 303, 3, 303, 3, 303, 3, 303, 3, 303,
	5, 303, 3942, 10, 303, 3, 303, 3, 303, 6, 303, 3946, 10, 303, 13, 303,
	14, 303, 3947, 5, 303, 3950, 10, 303, 3, 304, 3, 304, 3, 304, 5, 304, 3955,
	10, 304, 3, 305, 3, 305, 5, 305, 3959, 10, 305, 3, 305, 3, 305, 3, 306,
	3, 306, 3, 306, 5, 306, 3966, 10, 306, 3, 307, 3, 307, 5, 307, 3970, 10,
	307, 3, 307, 3, 307, 5, 307, 3974, 10, 307, 3, 308, 3, 308, 6, 308, 3978,
	10, 308, 13, 308, 14, 308, 3979, 3, 308, 3, 308, 3, 308, 5, 308, 3985,
	10, 308, 3, 308, 5, 308, 3988, 10, 308, 3, 308, 5, 308, 3991, 10, 308,
	3, 309, 3, 309, 5, 309, 3995, 10, 309, 3, 310, 3, 310, 3, 311, 3, 311,
	3, 311, 5, 311, 4002, 10, 311, 3, 311, 5, 311, 4005, 10, 311, 3, 311, 5,
	311, 4008, 10, 311, 3, 311, 5, 311, 4011, 10, 311, 3, 312, 3, 312, 3, 312,
	5, 312, 4016, 10, 312, 3, 312, 3, 312, 3, 312, 5, 312, 4021, 10, 312, 3,
	312, 3, 312, 5, 312, 4025, 10, 312, 3, 312, 3, 312, 3, 312, 5, 312, 4030,
	10, 312, 3, 313, 3, 313, 6, 313, 4034, 10, 313, 13, 313, 14, 313, 4035,
	3, 313, 5, 313, 4039, 10, 313, 3, 313, 5, 313, 4042, 10, 313, 3, 313, 5,
	313, 4045, 10, 313, 3, 314, 3, 314, 5, 314, 4049, 10, 314, 3, 315, 3, 315,
	3, 315, 5, 315, 4054, 10, 315, 3, 316, 3, 316, 3, 316, 5, 316, 4059, 10,
	316, 3, 317, 5, 317, 4062, 10, 317, 3, 317, 3, 317, 3, 317, 3, 318, 3,
	318, 3, 318, 5, 318, 4070, 10, 318, 3, 318, 3, 318, 3, 318, 5, 318, 4075,
	10, 318, 3, 318, 5, 318, 4078, 10, 318, 3, 318, 5, 318, 4081, 10, 318,
	3, 318, 5, 318, 4084, 10, 318, 3, 318, 5, 318, 4087, 10, 318, 3, 319, 3,
	319, 6, 319, 4091, 10, 319, 13, 319, 14, 319, 4092, 3, 320, 3, 320, 3,
	320, 5, 320, 4098, 10, 320, 3, 320, 5, 320, 4101, 10, 320, 3, 321, 3, 321,
	3, 321, 5, 321, 4106, 10, 321, 3, 321, 5, 321, 4109, 10, 321, 3, 322, 3,
	322, 6, 322, 4113, 10, 322, 13, 322, 14, 322, 4114, 3, 323, 3, 323, 5,
	323, 4119, 10, 323, 3, 324, 3, 324, 5, 324, 4123, 10, 324, 3, 325, 3, 325,
	3, 325, 3, 326, 3, 326, 3, 326, 5, 326, 4131, 10, 326, 3, 326, 3, 326,
	3, 326, 5, 326, 4136, 10, 326, 3, 326, 3, 326, 5, 326, 4140, 10, 326, 3,
	326, 3, 326, 3, 326, 5, 326, 4145, 10, 326, 3, 327, 3, 327, 3, 327, 3,
	327, 6, 327, 4151, 10, 327, 13, 327, 14, 327, 4152, 5, 327, 4155, 10, 327,
	3, 328, 3, 328, 3, 328, 7, 328, 4160, 10, 328, 12, 328, 14, 328, 4163,
	11, 328, 3, 328, 6, 328, 4166, 10, 328, 13, 328, 14, 328, 4167, 3, 328,
	5, 328, 4171, 10, 328, 3, 328, 5, 328, 4174, 10, 328, 3, 329, 3, 329, 3,
	329, 3, 329, 5, 329, 4180, 10, 329, 3, 330, 3, 330, 3, 330, 3, 331, 6,
	331, 4186, 10, 331, 13, 331, 14, 331, 4187, 3, 331, 7, 331, 4191, 10, 331,
	12, 331, 14, 331, 4194, 11, 331, 3, 332, 3, 332, 3, 332, 7, 332, 4199,
	10, 332, 12, 332, 14, 332, 4202, 11, 332, 3, 333, 3, 333, 5, 333, 4206,
	10, 333, 3, 333, 3, 333, 5, 333, 4210, 10, 333, 3, 333, 3, 333, 5, 333,
	4214, 10, 333, 3, 334, 3, 334, 3, 334, 3, 335, 3, 335, 3, 335, 3, 336,
	3, 336, 3, 336, 7, 336, 4225, 10, 336, 12, 336, 14, 336, 4228, 11, 336,
	3, 337, 3, 337, 3, 337, 5, 337, 4233, 10, 337, 3, 338, 6, 338, 4236, 10,
	338, 13, 338, 14, 338, 4237, 3, 339, 6, 339, 4241, 10, 339, 13, 339, 14,
	339, 4242, 3, 340, 6, 340, 4246, 10, 340, 13, 340, 14, 340, 4247, 3, 341,
	3, 341, 5, 341, 4252, 10, 341, 3, 341, 5, 341, 4255, 10, 341, 3, 341, 6,
	341, 4258, 10, 341, 13, 341, 14, 341, 4259, 3, 342, 3, 342, 5, 342, 4264,
	10, 342, 3, 343, 3, 343, 5, 343, 4268, 10, 343, 3, 344, 3, 344, 3, 344,
	3, 345, 3, 345, 3, 346, 3, 346, 5, 346, 4277, 10, 346, 3, 346, 3, 346,
	5, 346, 4281, 10, 346, 3, 347, 3, 347, 3, 348, 3, 348, 6, 348, 4287, 10,
	348, 13, 348, 14, 348, 4288, 3, 348, 3, 348, 5, 348, 4293, 10, 348, 3,
	348, 5, 348, 4296, 10, 348, 5, 348, 4298, 10, 348, 3, 349, 3, 349, 3, 349,
	3, 349, 5, 349, 4304, 10, 349, 3, 349, 5, 349, 4307, 10, 349, 3, 350, 5,
	350, 4310, 10, 350, 3, 350, 3, 350, 3, 350, 7, 350, 4315, 10, 350, 12,
	350, 14, 350, 4318, 11, 350, 5, 350, 4320, 10, 350, 3, 351, 3, 351, 3,
	351, 3, 351, 7, 351, 4326, 10, 351, 12, 351, 14, 351, 4329, 11, 351, 5,
	351, 4331, 10, 351, 3, 352, 3, 352, 6, 352, 4335, 10, 352, 13, 352, 14,
	352, 4336, 3, 352, 5, 352, 4340, 10, 352, 3, 353, 3, 353, 6, 353, 4344,
	10, 353, 13, 353, 14, 353, 4345, 3, 354, 3, 354, 5, 354, 4350, 10, 354,
	3, 354, 3, 354, 3, 354, 5, 354, 4355, 10, 354, 3, 355, 3, 355, 6, 355,
	4359, 10, 355, 13, 355, 14, 355, 4360, 3, 356, 3, 356, 3, 356, 3, 356,
	3, 356, 3, 356, 5, 356, 4369, 10, 356, 3, 357, 3, 357, 6, 357, 4373, 10,
	357, 13, 357, 14, 357, 4374, 3, 358, 3, 358, 3, 358, 6, 358, 4380, 10,
	358, 13, 358, 14, 358, 4381, 3, 359, 3, 359, 6, 359, 4386, 10, 359, 13,
	359, 14, 359, 4387, 3, 359, 6, 359, 4391, 10, 359, 13, 359, 14, 359, 4392,
	3, 360, 3, 360, 3, 360, 5, 360, 4398, 10, 360, 3, 360, 3, 360, 7, 360,
	4402, 10, 360, 12, 360, 14, 360, 4405, 11, 360, 3, 361, 3, 361, 3, 361,
	3, 361, 6, 361, 4411, 10, 361, 13, 361, 14, 361, 4412, 3, 362, 3, 362,
	7, 362, 4417, 10, 362, 12, 362, 14, 362, 4420, 11, 362, 3, 363, 3, 363,
	3, 363, 7, 363, 4425, 10, 363, 12, 363, 14, 363, 4428, 11, 363, 3, 364,
	3, 364, 6, 364, 4432, 10, 364, 13, 364, 14, 364, 4433, 3, 365, 3, 365,
	6, 365, 4438, 10, 365, 13, 365, 14, 365, 4439, 3, 366, 3, 366, 5, 366,
	4444, 10, 366, 3, 366, 7, 366, 4447, 10, 366, 12, 366, 14, 366, 4450, 11,
	366, 3, 367, 3, 367, 5, 367, 4454, 10, 367, 3, 367, 3, 367, 7, 367, 4458,
	10, 367, 12, 367, 14, 367, 4461, 11, 367, 3, 368, 3, 368, 3, 368, 5, 368,
	4466, 10, 368, 3, 369, 3, 369, 3, 369, 5, 369, 4471, 10, 369, 3, 370, 3,
	370, 5, 370, 4475, 10, 370, 3, 370, 3, 370, 5, 370, 4479, 10, 370, 3, 371,
	3, 371, 3, 371, 6, 371, 4484, 10, 371, 13, 371, 14, 371, 4485, 3, 371,
	5, 371, 4489, 10, 371, 3, 371, 7, 371, 4492, 10, 371, 12, 371, 14, 371,
	4495, 11, 371, 3, 371, 5, 371, 4498, 10, 371, 3, 371, 7, 371, 4501, 10,
	371, 12, 371, 14, 371, 4504, 11, 371, 3, 372, 5, 372, 4507, 10, 372, 3,
	372, 3, 372, 5, 372, 4511, 10, 372, 3, 372, 6, 372, 4514, 10, 372, 13,
	372, 14, 372, 4515, 3, 373, 5, 373, 4519, 10, 373, 3, 373, 3, 373, 5, 373,
	4523, 10, 373, 3, 373, 6, 373, 4526, 10, 373, 13, 373, 14, 373, 4527, 3,
	373, 5, 373, 4531, 10, 373, 3, 373, 5, 373, 4534, 10, 373, 3, 374, 5, 374,
	4537, 10, 374, 3, 374, 3, 374, 3, 374, 3, 374, 3, 375, 5, 375, 4544, 10,
	375, 3, 375, 3, 375, 5, 375, 4548, 10, 375, 3, 375, 3, 375, 3, 376, 3,
	376, 6, 376, 4554, 10, 376, 13, 376, 14, 376, 4555, 3, 377, 3, 377, 3,
	377, 5, 377, 4561, 10, 377, 3, 377, 3, 377, 5, 377, 4565, 10, 377, 3, 378,
	3, 378, 3, 378, 3, 379, 3, 379, 6, 379, 4572, 10, 379, 13, 379, 14, 379,
	4573, 3, 380, 3, 380, 3, 380, 3, 380, 3, 380, 3, 380, 3, 380, 3, 380, 3,
	380, 3, 380, 5, 380, 4586, 10, 380, 3, 381, 3, 381, 5, 381, 4590, 10, 381,
	3, 381, 3, 381, 5, 381, 4594, 10, 381, 3, 382, 3, 382, 3, 382, 6, 382,
	4599, 10, 382, 13, 382, 14, 382, 4600, 3, 383, 3, 383, 5, 383, 4605, 10,
	383, 3, 384, 3, 384, 3, 384, 3, 384, 6, 384, 4611, 10, 384, 13, 384, 14,
	384, 4612, 3, 385, 3, 385, 3, 386, 3, 386, 3, 386, 5, 386, 4620, 10, 386,
	3, 386, 3, 386, 3, 386, 5, 386, 4625, 10, 386, 3, 386, 5, 386, 4628, 10,
	386, 3, 386, 5, 386, 4631, 10, 386, 3, 386, 5, 386, 4634, 10, 386, 3, 387,
	6, 387, 4637, 10, 387, 13, 387, 14, 387, 4638, 3, 388, 3, 388, 5, 388,
	4643, 10, 388, 3, 389, 3, 389, 3, 389, 6, 389, 4648, 10, 389, 13, 389,
	14, 389, 4649, 3, 390, 3, 390, 5, 390, 4654, 10, 390, 3, 391, 3, 391, 5,
	391, 4658, 10, 391, 3, 392, 3, 392, 3, 392, 3, 392, 3, 392, 6, 392, 4665,
	10, 392, 13, 392, 14, 392, 4666, 3, 393, 3, 393, 6, 393, 4671, 10, 393,
	13, 393, 14, 393, 4672, 3, 394, 3, 394, 3, 394, 5, 394, 4678, 10, 394,
	3, 394, 3, 394, 5, 394, 4682, 10, 394, 3, 395, 3, 395, 6, 395, 4686, 10,
	395, 13, 395, 14, 395, 4687, 3, 396, 3, 396, 5, 396, 4692, 10, 396, 3,
	396, 3, 396, 5, 396, 4696, 10, 396, 3, 397, 3, 397, 6, 397, 4700, 10, 397,
	13, 397, 14, 397, 4701, 3, 398, 3, 398, 6, 398, 4706, 10, 398, 13, 398,
	14, 398, 4707, 3, 399, 3, 399, 3, 399, 5, 399, 4713, 10, 399, 3, 400, 5,
	400, 4716, 10, 400, 3, 400, 7, 400, 4719, 10, 400, 12, 400, 14, 400, 4722,
	11, 400, 3, 400, 3, 400, 3, 401, 3, 401, 3, 401, 5, 401, 4729, 10, 401,
	3, 401, 5, 401, 4732, 10, 401, 3, 402, 3, 402, 3, 402, 5, 402, 4737, 10,
	402, 3, 403, 3, 403, 5, 403, 4741, 10, 403, 3, 403, 3, 403, 3, 404, 5,
	404, 4746, 10, 404, 3, 404, 3, 404, 3, 404, 3, 405, 3, 405, 3, 405, 3,
	405, 3, 405, 5, 405, 4756, 10, 405, 5, 405, 4758, 10, 405, 3, 406, 3, 406,
	3, 406, 7, 406, 4763, 10, 406, 12, 406, 14, 406, 4766, 11, 406, 3, 407,
	3, 407, 5, 407, 4770, 10, 407, 3, 407, 3, 407, 3, 407, 3, 407, 3, 408,
	3, 408, 3, 408, 3, 409, 3, 409, 3, 409, 3, 409, 5, 409, 4783, 10, 409,
	3, 410, 3, 410, 3, 410, 3, 410, 5, 410, 4789, 10, 410, 3, 411, 5, 411,
	4792, 10, 411, 3, 411, 3, 411, 3, 411, 3, 412, 3, 412, 6, 412, 4799, 10,
	412, 13, 412, 14, 412, 4800, 3, 413, 3, 413, 3, 413, 5, 413, 4806, 10,
	413, 3, 413, 5, 413, 4809, 10, 413, 3, 413, 5, 413, 4812, 10, 413, 3, 413,
	5, 413, 4815, 10, 413, 3, 413, 5, 413, 4818, 10, 413, 3, 413, 5, 413, 4821,
	10, 413, 3, 413, 5, 413, 4824, 10, 413, 3, 413, 5, 413, 4827, 10, 413,
	3, 413, 5, 413, 4830, 10, 413, 3, 413, 5, 413, 4833, 10, 413, 3, 414, 3,
	414, 3, 414, 3, 415, 5, 415, 4839, 10, 415, 3, 415, 3, 415, 3, 415, 5,
	415, 4844, 10, 415, 3, 416, 3, 416, 5, 416, 4848, 10, 416, 3, 416, 3, 416,
	3, 417, 3, 417, 3, 417, 5, 417, 4855, 10, 417, 3, 417, 5, 417, 4858, 10,
	417, 3, 417, 5, 417, 4861, 10, 417, 3, 417, 5, 417, 4864, 10, 417, 3, 418,
	3, 418, 3, 418, 3, 418, 3, 418, 3, 418, 3, 418, 3, 418, 7, 418, 4874, 10,
	418, 12, 418, 14, 418, 4877, 11, 418, 3, 419, 3, 419, 3, 419, 3, 419, 3,
	419, 3, 419, 5, 419, 4885, 10, 419, 3, 420, 3, 420, 3, 420, 5, 420, 4890,
	10, 420, 3, 420, 3, 420, 5, 420, 4894, 10, 420, 3, 420, 5, 420, 4897, 10,
	420, 3, 421, 3, 421, 3, 421, 7, 421, 4902, 10, 421, 12, 421, 14, 421, 4905,
	11, 421, 3, 422, 3, 422, 3, 422, 7, 422, 4910, 10, 422, 12, 422, 14, 422,
	4913, 11, 422, 3, 423, 3, 423, 5, 423, 4917, 10, 423, 3, 423, 3, 423, 5,
	423, 4921, 10, 423, 3, 424, 5, 424, 4924, 10, 424, 3, 424, 3, 424, 3, 424,
	3, 425, 3, 425, 5, 425, 4931, 10, 425, 3, 425, 3, 425, 3, 426, 3, 426,
	5, 426, 4937, 10, 426, 3, 426, 3, 426, 5, 426, 4941, 10, 426, 3, 427, 3,
	427, 5, 427, 4945, 10, 427, 3, 427, 3, 427, 3, 428, 3, 428, 3, 428, 3,
	428, 5, 428, 4953, 10, 428, 3, 429, 3, 429, 3, 429, 5, 429, 4958, 10, 429,
	3, 429, 5, 429, 4961, 10, 429, 3, 429, 3, 429, 5, 429, 4965, 10, 429, 3,
	429, 5, 429, 4968, 10, 429, 3, 430, 3, 430, 3, 430, 3, 431, 3, 431, 3,
	431, 5, 431, 4976, 10, 431, 3, 431, 5, 431, 4979, 10, 431, 3, 431, 5, 431,
	4982, 10, 431, 3, 431, 5, 431, 4985, 10, 431, 3, 432, 3, 432, 3, 432, 3,
	433, 3, 433, 5, 433, 4992, 10, 433, 3, 433, 3, 433, 5, 433, 4996, 10, 433,
	3, 433, 5, 433, 4999, 10, 433, 3, 433, 6, 433, 5002, 10, 433, 13, 433,
	14, 433, 5003, 3, 433, 5, 433, 5007, 10, 433, 3, 434, 3, 434, 3, 434, 3,
	435, 3, 435, 3, 435, 3, 435, 3, 435, 7, 435, 5017, 10, 435, 12, 435, 14,
	435, 5020, 11, 435, 5, 435, 5022, 10, 435, 3, 436, 3, 436, 3, 436, 5, 436,
	5027, 10, 436, 3, 436, 5, 436, 5030, 10, 436, 3, 436, 5, 436, 5033, 10,
	436, 3, 437, 3, 437, 5, 437, 5037, 10, 437, 3, 437, 5, 437, 5040, 10, 437,
	3, 437, 5, 437, 5043, 10, 437, 3, 437, 5, 437, 5046, 10, 437, 3, 437, 5,
	437, 5049, 10, 437, 3, 438, 3, 438, 3, 438, 3, 438, 3, 439, 3, 439, 3,
	439, 3, 440, 3, 440, 3, 440, 3, 440, 3, 440, 5, 440, 5063, 10, 440, 3,
	441, 3, 441, 5, 441, 5067, 10, 441, 3, 442, 3, 442, 5, 442, 5071, 10, 442,
	3, 442, 3, 442, 3, 442, 5, 442, 5076, 10, 442, 3, 443, 3, 443, 3, 444,
	3, 444, 5, 444, 5082, 10, 444, 3, 444, 5, 444, 5085, 10, 444, 3, 445, 3,
	445, 3, 446, 3, 446, 6, 446, 5091, 10, 446, 13, 446, 14, 446, 5092, 3,
	446, 5, 446, 5096, 10, 446, 3, 447, 6, 447, 5099, 10, 447, 13, 447, 14,
	447, 5100, 3, 447, 3, 447, 6, 447, 5105, 10, 447, 13, 447, 14, 447, 5106,
	3, 448, 6, 448, 5110, 10, 448, 13, 448, 14, 448, 5111, 3, 448, 3, 448,
	3, 448, 3, 448, 5, 448, 5118, 10, 448, 3, 448, 3, 448, 3, 449, 3, 449,
	3, 450, 3, 450, 3, 450, 3, 450, 3, 450, 5, 450, 5129, 10, 450, 3, 450,
	3, 450, 5, 450, 5133, 10, 450, 3, 451, 3, 451, 5, 451, 5137, 10, 451, 3,
	452, 3, 452, 3, 452, 6, 452, 5142, 10, 452, 13, 452, 14, 452, 5143, 3,
	452, 5, 452, 5147, 10, 452, 3, 452, 5, 452, 5150, 10, 452, 3, 452, 5, 452,
	5153, 10, 452, 3, 452, 7, 452, 5156, 10, 452, 12, 452, 14, 452, 5159, 11,
	452, 3, 452, 5, 452, 5162, 10, 452, 3, 452, 7, 452, 5165, 10, 452, 12,
	452, 14, 452, 5168, 11, 452, 3, 453, 5, 453, 5171, 10, 453, 3, 453, 3,
	453, 5, 453, 5175, 10, 453, 3, 453, 6, 453, 5178, 10, 453, 13, 453, 14,
	453, 5179, 3, 454, 5, 454, 5183, 10, 454, 3, 454, 3, 454, 5, 454, 5187,
	10, 454, 3, 454, 5, 454, 5190, 10, 454, 3, 455, 5, 455, 5193, 10, 455,
	3, 455, 3, 455, 5, 455, 5197, 10, 455, 3, 455, 6, 455, 5200, 10, 455, 13,
	455, 14, 455, 5201, 3, 455, 5, 455, 5205, 10, 455, 3, 455, 5, 455, 5208,
	10, 455, 3, 456, 5, 456, 5211, 10, 456, 3, 456, 3, 456, 3, 456, 3, 456,
	3, 457, 5, 457, 5218, 10, 457, 3, 457, 3, 457, 5, 457, 5222, 10, 457, 3,
	457, 3, 457, 3, 458, 3, 458, 3, 458, 5, 458, 5229, 10, 458, 3, 458, 3,
	458, 5, 458, 5233, 10, 458, 3, 459, 3, 459, 3, 459, 3, 460, 3, 460, 6,
	460, 5240, 10, 460, 13, 460, 14, 460, 5241, 3, 461, 3, 461, 3, 461, 5,
	461, 5247, 10, 461, 3, 461, 3, 461, 5, 461, 5251, 10, 461, 3, 462, 3, 462,
	3, 462, 3, 463, 3, 463, 6, 463, 5258, 10, 463, 13, 463, 14, 463, 5259,
	3, 464, 3, 464, 3, 464, 3, 464, 3, 464, 3, 464, 3, 464, 3, 464, 3, 464,
	3, 464, 5, 464, 5272, 10, 464, 3, 465, 3, 465, 3, 465, 5, 465, 5277, 10,
	465, 3, 465, 5, 465, 5280, 10, 465, 3, 465, 5, 465, 5283, 10, 465, 3, 465,
	5, 465, 5286, 10, 465, 3, 466, 3, 466, 5, 466, 5290, 10, 466, 3, 466, 3,
	466, 5, 466, 5294, 10, 466, 3, 466, 3, 466, 3, 466, 5, 466, 5299, 10, 466,
	3, 466, 3, 466, 3, 466, 3, 466, 5, 466, 5305, 10, 466, 3, 466, 3, 466,
	3, 466, 3, 466, 5, 466, 5311, 10, 466, 3, 466, 3, 466, 3, 466, 5, 466,
	5316, 10, 466, 3, 466, 5, 466, 5319, 10, 466, 3, 466, 3, 466, 3, 467, 3,
	467, 3, 467, 5, 467, 5326, 10, 467, 3, 468, 3, 468, 6, 468, 5330, 10, 468,
	13, 468, 14, 468, 5331, 3, 468, 3, 468, 5, 468, 5336, 10, 468, 3, 468,
	5, 468, 5339, 10, 468, 3, 468, 5, 468, 5342, 10, 468, 3, 468, 5, 468, 5345,
	10, 468, 3, 469, 6, 469, 5348, 10, 469, 13, 469, 14, 469, 5349, 3, 469,
	3, 469, 5, 469, 5354, 10, 469, 3, 470, 3, 470, 5, 470, 5358, 10, 470, 3,
	471, 3, 471, 5, 471, 5362, 10, 471, 3, 471, 3, 471, 3, 471, 5, 471, 5367,
	10, 471, 3, 472, 3, 472, 3, 472, 5, 472, 5372, 10, 472, 3, 473, 3, 473,
	3, 473, 3, 474, 5, 474, 5378, 10, 474, 3, 474, 3, 474, 3, 474, 3, 475,
	3, 475, 3, 475, 3, 475, 5, 475, 5387, 10, 475, 3, 475, 5, 475, 5390, 10,
	475, 3, 475, 5, 475, 5393, 10, 475, 3, 475, 5, 475, 5396, 10, 475, 3, 476,
	6, 476, 5399, 10, 476, 13, 476, 14, 476, 5400, 3, 476, 3, 476, 6, 476,
	5405, 10, 476, 13, 476, 14, 476, 5406, 3, 477, 6, 477, 5410, 10, 477, 13,
	477, 14, 477, 5411, 3, 477, 3, 477, 3, 477, 3, 477, 6, 477, 5418, 10, 477,
	13, 477, 14, 477, 5419, 3, 478, 3, 478, 3, 478, 3, 478, 3, 478, 3, 479,
	3, 479, 5, 479, 5429, 10, 479, 3, 480, 3, 480, 5, 480, 5433, 10, 480, 3,
	481, 3, 481, 5, 481, 5437, 10, 481, 3, 482, 3, 482, 5, 482, 5441, 10, 482,
	3, 483, 3, 483, 5, 483, 5445, 10, 483, 3, 484, 3, 484, 3, 484, 3, 485,
	3, 485, 3, 485, 3, 485, 5, 485, 5454, 10, 485, 3, 485, 5, 485, 5457, 10,
	485, 3, 485, 5, 485, 5460, 10, 485, 3, 485, 5, 485, 5463, 10, 485, 3, 485,
	5, 485, 5466, 10, 485, 3, 486, 3, 486, 3, 486, 7, 486, 5471, 10, 486, 12,
	486, 14, 486, 5474, 11, 486, 5, 486, 5476, 10, 486, 3, 487, 3, 487, 5,
	487, 5480, 10, 487, 3, 487, 5, 487, 5483, 10, 487, 3, 487, 3, 487, 5, 487,
	5487, 10, 487, 3, 488, 3, 488, 5, 488, 5491, 10, 488, 3, 488, 3, 488, 5,
	488, 5495, 10, 488, 3, 489, 3, 489, 6, 489, 5499, 10, 489, 13, 489, 14,
	489, 5500, 3, 490, 3, 490, 5, 490, 5505, 10, 490, 3, 490, 5, 490, 5508,
	10, 490, 3, 491, 3, 491, 5, 491, 5512, 10, 491, 3, 491, 3, 491, 3, 492,
	3, 492, 5, 492, 5518, 10, 492, 3, 492, 3, 492, 3, 493, 5, 493, 5523, 10,
	493, 3, 493, 3, 493, 3, 493, 3, 494, 3, 494, 5, 494, 5530, 10, 494, 3,
	494, 3, 494, 3, 495, 3, 495, 3, 495, 5, 495, 5537, 10, 495, 3, 496, 5,
	496, 5540, 10, 496, 3, 496, 3, 496, 5, 496, 5544, 10, 496, 3, 496, 3, 496,
	3, 496, 5, 496, 5549, 10, 496, 3, 496, 3, 496, 3, 497, 3, 497, 3, 497,
	3, 497, 3, 497, 6, 497, 5558, 10, 497, 13, 497, 14, 497, 5559, 5, 497,
	5562, 10, 497, 3, 498, 5, 498, 5565, 10, 498, 3, 498, 3, 498, 5, 498, 5569,
	10, 498, 3, 498, 6, 498, 5572, 10, 498, 13, 498, 14, 498, 5573, 3, 499,
	3, 499, 3, 499, 3, 499, 5, 499, 5580, 10, 499, 3, 499, 5, 499, 5583, 10,
	499, 3, 499, 3, 499, 3, 499, 5, 499, 5588, 10, 499, 3, 500, 3, 500, 3,
	500, 5, 500, 5593, 10, 500, 3, 500, 5, 500, 5596, 10, 500, 3, 500, 5, 500,
	5599, 10, 500, 3, 500, 5, 500, 5602, 10, 500, 3, 500, 5, 500, 5605, 10,
	500, 3, 500, 5, 500, 5608, 10, 500, 3, 500, 5, 500, 5611, 10, 500, 3, 501,
	3, 501, 3, 501, 5, 501, 5616, 10, 501, 3, 502, 3, 502, 5, 502, 5620, 10,
	502, 3, 502, 3, 502, 3, 502, 5, 502, 5625, 10, 502, 3, 503, 3, 503, 3,
	504, 3, 504, 5, 504, 5631, 10, 504, 3, 504, 5, 504, 5634, 10, 504, 3, 505,
	3, 505, 3, 506, 5, 506, 5639, 10, 506, 3, 506, 3, 506, 7, 506, 5643, 10,
	506, 12, 506, 14, 506, 5646, 11, 506, 3, 507, 3, 507, 5, 507, 5650, 10,
	507, 3, 507, 3, 507, 7, 507, 5654, 10, 507, 12, 507, 14, 507, 5657, 11,
	507, 3, 508, 5, 508, 5660, 10, 508, 3, 508, 3, 508, 7, 508, 5664, 10, 508,
	12, 508, 14, 508, 5667, 11, 508, 3, 509, 3, 509, 5, 509, 5671, 10, 509,
	3, 509, 3, 509, 7, 509, 5675, 10, 509, 12, 509, 14, 509, 5678, 11, 509,
	3, 510, 3, 510, 5, 510, 5682, 10, 510, 3, 510, 7, 510, 5685, 10, 510, 12,
	510, 14, 510, 5688, 11, 510, 3, 511, 3, 511, 3, 511, 5, 511, 5693, 10,
	511, 3, 511, 7, 511, 5696, 10, 511, 12, 511, 14, 511, 5699, 11, 511, 3,
	512, 5, 512, 5702, 10, 512, 3, 512, 3, 512, 7, 512, 5706, 10, 512, 12,
	512, 14, 512, 5709, 11, 512, 3, 513, 3, 513, 5, 513, 5713, 10, 513, 3,
	513, 3, 513, 7, 513, 5717, 10, 513, 12, 513, 14, 513, 5720, 11, 513, 3,
	514, 5, 514, 5723, 10, 514, 3, 514, 3, 514, 3, 514, 7, 514, 5728, 10, 514,
	12, 514, 14, 514, 5731, 11, 514, 3, 515, 3, 515, 5, 515, 5735, 10, 515,
	3, 515, 3, 515, 3, 515, 7, 515, 5740, 10, 515, 12, 515, 14, 515, 5743,
	11, 515, 3, 516, 5, 516, 5746, 10, 516, 3, 516, 3, 516, 7, 516, 5750, 10,
	516, 12, 516, 14, 516, 5753, 11, 516, 3, 517, 3, 517, 5, 517, 5757, 10,
	517, 3, 517, 3, 517, 7, 517, 5761, 10, 517, 12, 517, 14, 517, 5764, 11,
	517, 3, 518, 3, 518, 7, 518, 5768, 10, 518, 12, 518, 14, 518, 5771, 11,
	518, 3, 519, 3, 519, 3, 519, 3, 520, 3, 520, 7, 520, 5778, 10, 520, 12,
	520, 14, 520, 5781, 11, 520, 3, 521, 3, 521, 3, 521, 3, 522, 5, 522, 5787,
	10, 522, 3, 522, 3, 522, 7, 522, 5791, 10, 522, 12, 522, 14, 522, 5794,
	11, 522, 3, 523, 3, 523, 3, 523, 3, 524, 3, 524, 3, 524, 3, 524, 3, 524,
	3, 524, 5, 524, 5805, 10, 524, 3, 525, 3, 525, 7, 525, 5809, 10, 525, 12,
	525, 14, 525, 5812, 11, 525, 3, 526, 3, 526, 3, 526, 6, 526, 5817, 10,
	526, 13, 526, 14, 526, 5818, 5, 526, 5821, 10, 526, 3, 527, 5, 527, 5824,
	10, 527, 3, 527, 3, 527, 3, 528, 3, 528, 3, 528, 3, 528, 3, 528, 3, 528,
	3, 528, 5, 528, 5835, 10, 528, 3, 529, 3, 529, 5, 529, 5839, 10, 529, 3,
	529, 5, 529, 5842, 10, 529, 3, 529, 3, 529, 3, 529, 3, 529, 3, 529, 3,
	529, 3, 529, 5, 529, 5851, 10, 529, 3, 530, 3, 530, 7, 530, 5855, 10, 530,
	12, 530, 14, 530, 5858, 11, 530, 3, 530, 5, 530, 5861, 10, 530, 3, 530,
	7, 530, 5864, 10, 530, 12, 530, 14, 530, 5867, 11, 530, 3, 530, 7, 530,
	5870, 10, 530, 12, 530, 14, 530, 5873, 11, 530, 5, 530, 5875, 10, 530,
	3, 531, 3, 531, 3, 531, 5, 531, 5880, 10, 531, 3, 531, 7, 531, 5883, 10,
	531, 12, 531, 14, 531, 5886, 11, 531, 3, 531, 3, 531, 3, 532, 3, 532, 3,
	532, 5, 532, 5893, 10, 532, 3, 533, 3, 533, 5, 533, 5897, 10, 533, 3, 533,
	5, 533, 5900, 10, 533, 3, 533, 3, 533, 3, 534, 3, 534, 3, 534, 3, 534,
	3, 535, 3, 535, 3, 535, 3, 535, 3, 535, 3, 535, 3, 536, 3, 536, 3, 536,
	6, 536, 5917, 10, 536, 13, 536, 14, 536, 5918, 3, 537, 5, 537, 5922, 10,
	537, 3, 537, 5, 537, 5925, 10, 537, 3, 537, 3, 537, 5, 537, 5929, 10, 537,
	3, 537, 3, 537, 3, 537, 5, 537, 5934, 10, 537, 3, 537, 3, 537, 3, 537,
	5, 537, 5939, 10, 537, 3, 537, 5, 537, 5942, 10, 537, 3, 537, 3, 537, 3,
	537, 5, 537, 5947, 10, 537, 3, 537, 3, 537, 3, 537, 5, 537, 5952, 10, 537,
	3, 537, 3, 537, 3, 537, 5, 537, 5957, 10, 537, 3, 537, 3, 537, 3, 537,
	5, 537, 5962, 10, 537, 3, 537, 5, 537, 5965, 10, 537, 3, 538, 5, 538, 5968,
	10, 538, 3, 538, 5, 538, 5971, 10, 538, 3, 538, 3, 538, 3, 538, 3, 538,
	3, 538, 3, 538, 5, 538, 5979, 10, 538, 3, 539, 3, 539, 3, 539, 3, 539,
	5, 539, 5985, 10, 539, 3, 540, 3, 540, 3, 540, 3, 540, 5, 540, 5991, 10,
	540, 3, 540, 7, 540, 5994, 10, 540, 12, 540, 14, 540, 5997, 11, 540, 3,
	540, 3, 540, 7, 540, 6001, 10, 540, 12, 540, 14, 540, 6004, 11, 540, 3,
	540, 5, 540, 6007, 10, 540, 3, 541, 3, 541, 3, 541, 3, 541, 3, 541, 5,
	541, 6014, 10, 541, 3, 541, 7, 541, 6017, 10, 541, 12, 541, 14, 541, 6020,
	11, 541, 3, 541, 3, 541, 7, 541, 6024, 10, 541, 12, 541, 14, 541, 6027,
	11, 541, 3, 541, 5, 541, 6030, 10, 541, 3, 542, 3, 542, 3, 542, 3, 542,
	5, 542, 6036, 10, 542, 3, 542, 3, 542, 3, 543, 3, 543, 3, 544, 3, 544,
	3, 545, 3, 545, 3, 545, 3, 545, 5, 545, 6048, 10, 545, 3, 545, 3, 545,
	5, 545, 6052, 10, 545, 3, 545, 5, 545, 6055, 10, 545, 3, 546, 3, 546, 3,
	546, 3, 546, 5, 546, 6061, 10, 546, 3, 546, 3, 546, 5, 546, 6065, 10, 546,
	3, 546, 5, 546, 6068, 10, 546, 3, 547, 3, 547, 3, 547, 3, 547, 5, 547,
	6074, 10, 547, 3, 548, 3, 548, 5, 548, 6078, 10, 548, 3, 548, 6, 548, 6081,
	10, 548, 13, 548, 14, 548, 6082, 3, 548, 5, 548, 6086, 10, 548, 3, 548,
	5, 548, 6089, 10, 548, 3, 549, 3, 549, 3, 549, 3, 550, 3, 550, 3, 550,
	3, 551, 3, 551, 3, 551, 3, 552, 3, 552, 5, 552, 6102, 10, 552, 3, 553,
	3, 553, 3, 553, 3, 554, 3, 554, 3, 554, 3, 555, 3, 555, 3, 555, 3, 556,
	3, 556, 3, 556, 3, 557, 3, 557, 3, 557, 3, 558, 3, 558, 3, 558, 3, 559,
	3, 559, 3, 560, 3, 560, 3, 561, 3, 561, 3, 562, 3, 562, 3, 563, 3, 563,
	3, 564, 3, 564, 3, 565, 3, 565, 3, 566, 3, 566, 3, 567, 3, 567, 3, 567,
	5, 567, 6141, 10, 567, 3, 568, 3, 568, 3, 569, 3, 569, 3, 570, 3, 570,
	3, 570, 3, 570, 3, 570, 3, 570, 5, 570, 6153, 10, 570, 3, 571, 3, 571,
	3, 572, 3, 572, 3, 573, 3, 573, 3, 574, 3, 574, 3, 575, 3, 575, 3, 576,
	3, 576, 5, 576, 6167, 10, 576, 3, 577, 3, 577, 5, 577, 6171, 10, 577, 3,
	577, 5, 577, 6174, 10, 577, 3, 578, 3, 578, 5, 578, 6178, 10, 578, 3, 579,
	3, 579, 3, 580, 3, 580, 3, 581, 3, 581, 3, 582, 3, 582, 3, 583, 3, 583,
	5, 583, 6190, 10, 583, 3, 584, 3, 584, 3, 585, 3, 585, 3, 586, 3, 586,
	3, 587, 3, 587, 3, 588, 3, 588, 3, 588, 3, 588, 3, 588, 3, 588, 5, 588,
	6206, 10, 588, 3, 589, 3, 589, 3, 590, 3, 590, 3, 590, 5, 590, 6213, 10,
	590, 3, 591, 3, 591, 3, 592, 3, 592, 3, 592, 3, 592, 5, 592, 6221, 10,
	592, 3, 592, 3, 592, 3, 593, 3, 593, 3, 593, 3, 593, 5, 593, 6229, 10,
	593, 3, 593, 3, 593, 3, 594, 3, 594, 3, 594, 3, 594, 3, 594, 3, 594, 3,
	594, 3, 594, 3, 594, 3, 594, 3, 594, 3, 594, 3, 594, 3, 594, 3, 594, 5,
	594, 6248, 10, 594, 3, 595, 3, 595, 3, 595, 3, 595, 3, 595, 3, 595, 3,
	595, 3, 595, 3, 595, 3, 595, 3, 595, 3, 595, 3, 595, 3, 595, 3, 595, 5,
	595, 6265, 10, 595, 3, 595, 3, 595, 3, 595, 3, 595, 3, 595, 3, 595, 3,
	595, 3, 595, 3, 595, 3, 595, 3, 595, 3, 595, 3, 595, 3, 595, 3, 595, 3,
	595, 5, 595, 6283, 10, 595, 3, 596, 6, 596, 6286, 10, 596, 13, 596, 14,
	596, 6287, 3, 596, 2, 2, 597, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24,
	26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60,
	62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96,
	98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126,
	128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 156,
	158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180, 182, 184, 186,
	188, 190, 192, 194, 196, 198, 200, 202, 204, 206, 208, 210, 212, 214, 216,
	218, 220, 222, 224, 226, 228, 230, 232, 234, 236, 238, 240, 242, 244, 246,
	248, 250, 252, 254, 256, 258, 260, 262, 264, 266, 268, 270, 272, 274, 276,
	278, 280, 282, 284, 286, 288, 290, 292, 294, 296, 298, 300, 302, 304, 306,
	308, 310, 312, 314, 316, 318, 320, 322, 324, 326, 328, 330, 332, 334, 336,
	338, 340, 342, 344, 346, 348, 350, 352, 354, 356, 358, 360, 362, 364, 366,
	368, 370, 372, 374, 376, 378, 380, 382, 384, 386, 388, 390, 392, 394, 396,
	398, 400, 402, 404, 406, 408, 410, 412, 414, 416, 418, 420, 422, 424, 426,
	428, 430, 432, 434, 436, 438, 440, 442, 444, 446, 448, 450, 452, 454, 456,
	458, 460, 462, 464, 466, 468, 470, 472, 474, 476, 478, 480, 482, 484, 486,
	488, 490, 492, 494, 496, 498, 500, 502, 504, 506, 508, 510, 512, 514, 516,
	518, 520, 522, 524, 526, 528, 530, 532, 534, 536, 538, 540, 542, 544, 546,
	548, 550, 552, 554, 556, 558, 560, 562, 564, 566, 568, 570, 572, 574, 576,
	578, 580, 582, 584, 586, 588, 590, 592, 594, 596, 598, 600, 602, 604, 606,
	608, 610, 612, 614, 616, 618, 620, 622, 624, 626, 628, 630, 632, 634, 636,
	638, 640, 642, 644, 646, 648, 650, 652, 654, 656, 658, 660, 662, 664, 666,
	668, 670, 672, 674, 676, 678, 680, 682, 684, 686, 688, 690, 692, 694, 696,
	698, 700, 702, 704, 706, 708, 710, 712, 714, 716, 718, 720, 722, 724, 726,
	728, 730, 732, 734, 736, 738, 740, 742, 744, 746, 748, 750, 752, 754, 756,
	758, 760, 762, 764, 766, 768, 770, 772, 774, 776, 778, 780, 782, 784, 786,
	788, 790, 792, 794, 796, 798, 800, 802, 804, 806, 808, 810, 812, 814, 816,
	818, 820, 822, 824, 826, 828, 830, 832, 834, 836, 838, 840, 842, 844, 846,
	848, 850, 852, 854, 856, 858, 860, 862, 864, 866, 868, 870, 872, 874, 876,
	878, 880, 882, 884, 886, 888, 890, 892, 894, 896, 898, 900, 902, 904, 906,
	908, 910, 912, 914, 916, 918, 920, 922, 924, 926, 928, 930, 932, 934, 936,
	938, 940, 942, 944, 946, 948, 950, 952, 954, 956, 958, 960, 962, 964, 966,
	968, 970, 972, 974, 976, 978, 980, 982, 984, 986, 988, 990, 992, 994, 996,
	998, 1000, 1002, 1004, 1006, 1008, 1010, 1012, 1014, 1016, 1018, 1020,
	1022, 1024, 1026, 1028, 1030, 1032, 1034, 1036, 1038, 1040, 1042, 1044,
	1046, 1048, 1050, 1052, 1054, 1056, 1058, 1060, 1062, 1064, 1066, 1068,
	1070, 1072, 1074, 1076, 1078, 1080, 1082, 1084, 1086, 1088, 1090, 1092,
	1094, 1096, 1098, 1100, 1102, 1104, 1106, 1108, 1110, 1112, 1114, 1116,
	1118, 1120, 1122, 1124, 1126, 1128, 1130, 1132, 1134, 1136, 1138, 1140,
	1142, 1144, 1146, 1148, 1150, 1152, 1154, 1156, 1158, 1160, 1162, 1164,
	1166, 1168, 1170, 1172, 1174, 1176, 1178, 1180, 1182, 1184, 1186, 1188,
	1190, 2, 72, 3, 2, 236, 237, 7, 2, 80, 80, 132, 132, 245, 245, 276, 276,
	382, 382, 5, 2, 65, 65, 300, 300, 517, 517, 4, 2, 300, 300, 517, 517, 3,
	2, 485, 486, 4, 2, 16, 16, 306, 306, 4, 2, 82, 82, 88, 88, 4, 2, 268, 268,
	495, 495, 4, 2, 23, 23, 256, 256, 3, 2, 24, 25, 5, 2, 243, 243, 388, 388,
	431, 431, 6, 2, 152, 152, 199, 199, 371, 371, 431, 431, 4, 2, 384, 384,
	501, 501, 5, 2, 379, 379, 442, 442, 446, 446, 4, 2, 207, 207, 419, 419,
	4, 2, 65, 65, 381, 381, 3, 2, 462, 464, 4, 2, 281, 281, 418, 418, 4, 2,
	40, 40, 43, 43, 3, 2, 191, 192, 4, 2, 231, 231, 292, 292, 5, 2, 228, 228,
	270, 270, 338, 338, 5, 2, 350, 350, 545, 545, 549, 549, 3, 2, 75, 76, 3,
	2, 215, 216, 3, 2, 37, 38, 3, 2, 348, 349, 3, 2, 144, 145, 3, 2, 257, 258,
	3, 2, 35, 36, 4, 2, 313, 313, 422, 422, 4, 2, 158, 158, 400, 400, 4, 2,
	218, 218, 272, 272, 3, 2, 281, 282, 4, 2, 119, 119, 139, 139, 5, 2, 148,
	148, 357, 357, 434, 435, 3, 2, 52, 53, 4, 2, 555, 555, 557, 557, 4, 2,
	523, 523, 525, 526, 5, 2, 80, 80, 286, 286, 339, 339, 4, 2, 252, 252, 461,
	461, 4, 2, 27, 27, 137, 137, 4, 2, 97, 97, 385, 386, 3, 2, 470, 471, 4,
	2, 269, 269, 413, 413, 6, 2, 289, 290, 319, 319, 321, 321, 439, 439, 4,
	2, 204, 204, 497, 497, 4, 2, 102, 102, 264, 264, 4, 2, 61, 61, 508, 508,
	4, 2, 224, 224, 407, 407, 3, 2, 105, 106, 4, 2, 3, 3, 333, 333, 4, 2, 188,
	188, 538, 538, 9, 2, 13, 13, 16, 17, 118, 118, 154, 154, 306, 307, 318,
	318, 320, 320, 4, 2, 11, 11, 268, 268, 5, 2, 11, 11, 212, 212, 268, 268,
	4, 2, 9, 9, 41, 41, 4, 2, 260, 260, 312, 312, 4, 2, 297, 297, 424, 424,
	4, 2, 50, 50, 494, 494, 4, 2, 190, 190, 198, 198, 4, 2, 170, 170, 187,
	187, 4, 2, 545, 545, 549, 549, 4, 2, 528, 528, 552, 552, 4, 2, 21, 21,
	331, 331, 5, 2, 309, 309, 353, 353, 523, 523, 4, 2, 241, 241, 325, 325,
	87, 2, 3, 3, 26, 26, 28, 28, 30, 31, 33, 33, 35, 38, 40, 40, 43, 45, 47,
	47, 49, 49, 56, 57, 62, 63, 70, 71, 79, 79, 100, 100, 102, 102, 108, 108,
	110, 110, 130, 132, 140, 141, 143, 143, 148, 149, 153, 153, 158, 158, 183,
	183, 185, 185, 189, 189, 191, 193, 196, 196, 199, 199, 202, 202, 204, 204,
	215, 216, 218, 218, 220, 221, 228, 228, 231, 231, 239, 240, 252, 252, 260,
	260, 262, 262, 264, 264, 266, 267, 270, 270, 272, 272, 274, 276, 285, 286,
	289, 292, 298, 298, 305, 307, 310, 310, 313, 313, 319, 319, 321, 321, 324,
	324, 333, 333, 338, 339, 344, 344, 354, 355, 357, 357, 362, 363, 366, 366,
	372, 373, 375, 375, 378, 378, 382, 382, 385, 385, 393, 393, 400, 400, 403,
	403, 417, 417, 422, 422, 433, 436, 439, 439, 468, 468, 475, 475, 483, 484,
	488, 488, 492, 493, 497, 497, 499, 500, 512, 513, 520, 522, 524, 524, 559,
	559, 4, 2, 206, 206, 496, 496, 3, 2, 554, 557, 2, 7061, 2, 1192, 3, 2,
	2, 2, 4, 1196, 3, 2, 2, 2, 6, 1200, 3, 2, 2, 2, 8, 1219, 3, 2, 2, 2, 10,
	1224, 3, 2, 2, 2, 12, 1240, 3, 2, 2, 2, 14, 1242, 3, 2, 2, 2, 16, 1260,
	3, 2, 2, 2, 18, 1265, 3, 2, 2, 2, 20, 1270, 3, 2, 2, 2, 22, 1275, 3, 2,
	2, 2, 24, 1280, 3, 2, 2, 2, 26, 1285, 3, 2, 2, 2, 28, 1290, 3, 2, 2, 2,
	30, 1302, 3, 2, 2, 2, 32, 1304, 3, 2, 2, 2, 34, 1316, 3, 2, 2, 2, 36, 1318,
	3, 2, 2, 2, 38, 1330, 3, 2, 2, 2, 40, 1346, 3, 2, 2, 2, 42, 1348, 3, 2,
	2, 2, 44, 1359, 3, 2, 2, 2, 46, 1374, 3, 2, 2, 2, 48, 1395, 3, 2, 2, 2,
	50, 1404, 3, 2, 2, 2, 52, 1412, 3, 2, 2, 2, 54, 1418, 3, 2, 2, 2, 56, 1422,
	3, 2, 2, 2, 58, 1444, 3, 2, 2, 2, 60, 1448, 3, 2, 2, 2, 62, 1450, 3, 2,
	2, 2, 64, 1472, 3, 2, 2, 2, 66, 1481, 3, 2, 2, 2, 68, 1484, 3, 2, 2, 2,
	70, 1490, 3, 2, 2, 2, 72, 1504, 3, 2, 2, 2, 74, 1511, 3, 2, 2, 2, 76, 1527,
	3, 2, 2, 2, 78, 1534, 3, 2, 2, 2, 80, 1538, 3, 2, 2, 2, 82, 1540, 3, 2,
	2, 2, 84, 1556, 3, 2, 2, 2, 86, 1562, 3, 2, 2, 2, 88, 1579, 3, 2, 2, 2,
	90, 1602, 3, 2, 2, 2, 92, 1640, 3, 2, 2, 2, 94, 1642, 3, 2, 2, 2, 96, 1648,
	3, 2, 2, 2, 98, 1662, 3, 2, 2, 2, 100, 1682, 3, 2, 2, 2, 102, 1694, 3,
	2, 2, 2, 104, 1705, 3, 2, 2, 2, 106, 1707, 3, 2, 2, 2, 108, 1719, 3, 2,
	2, 2, 110, 1726, 3, 2, 2, 2, 112, 1743, 3, 2, 2, 2, 114, 1745, 3, 2, 2,
	2, 116, 1762, 3, 2, 2, 2, 118, 1777, 3, 2, 2, 2, 120, 1788, 3, 2, 2, 2,
	122, 1799, 3, 2, 2, 2, 124, 1809, 3, 2, 2, 2, 126, 1818, 3, 2, 2, 2, 128,
	1835, 3, 2, 2, 2, 130, 1853, 3, 2, 2, 2, 132, 1860, 3, 2, 2, 2, 134, 1870,
	3, 2, 2, 2, 136, 1879, 3, 2, 2, 2, 138, 1899, 3, 2, 2, 2, 140, 1901, 3,
	2, 2, 2, 142, 1915, 3, 2, 2, 2, 144, 1919, 3, 2, 2, 2, 146, 1928, 3, 2,
	2, 2, 148, 1932, 3, 2, 2, 2, 150, 1947, 3, 2, 2, 2, 152, 1960, 3, 2, 2,
	2, 154, 1965, 3, 2, 2, 2, 156, 1972, 3, 2, 2, 2, 158, 1990, 3, 2, 2, 2,
	160, 1992, 3, 2, 2, 2, 162, 2001, 3, 2, 2, 2, 164, 2030, 3, 2, 2, 2, 166,
	2033, 3, 2, 2, 2, 168, 2038, 3, 2, 2, 2, 170, 2042, 3, 2, 2, 2, 172, 2053,
	3, 2, 2, 2, 174, 2056, 3, 2, 2, 2, 176, 2063, 3, 2, 2, 2, 178, 2070, 3,
	2, 2, 2, 180, 2099, 3, 2, 2, 2, 182, 2106, 3, 2, 2, 2, 184, 2109, 3, 2,
	2, 2, 186, 2129, 3, 2, 2, 2, 188, 2136, 3, 2, 2, 2, 190, 2144, 3, 2, 2,
	2, 192, 2160, 3, 2, 2, 2, 194, 2180, 3, 2, 2, 2, 196, 2183, 3, 2, 2, 2,
	198, 2194, 3, 2, 2, 2, 200, 2205, 3, 2, 2, 2, 202, 2215, 3, 2, 2, 2, 204,
	2224, 3, 2, 2, 2, 206, 2226, 3, 2, 2, 2, 208, 2240, 3, 2, 2, 2, 210, 2247,
	3, 2, 2, 2, 212, 2256, 3, 2, 2, 2, 214, 2261, 3, 2, 2, 2, 216, 2270, 3,
	2, 2, 2, 218, 2279, 3, 2, 2, 2, 220, 2292, 3, 2, 2, 2, 222, 2294, 3, 2,
	2, 2, 224, 2322, 3, 2, 2, 2, 226, 2341, 3, 2, 2, 2, 228, 2364, 3, 2, 2,
	2, 230, 2371, 3, 2, 2, 2, 232, 2385, 3, 2, 2, 2, 234, 2392, 3, 2, 2, 2,
	236, 2400, 3, 2, 2, 2, 238, 2408, 3, 2, 2, 2, 240, 2415, 3, 2, 2, 2, 242,
	2422, 3, 2, 2, 2, 244, 2430, 3, 2, 2, 2, 246, 2439, 3, 2, 2, 2, 248, 2448,
	3, 2, 2, 2, 250, 2457, 3, 2, 2, 2, 252, 2466, 3, 2, 2, 2, 254, 2474, 3,
	2, 2, 2, 256, 2481, 3, 2, 2, 2, 258, 2496, 3, 2, 2, 2, 260, 2505, 3, 2,
	2, 2, 262, 2547, 3, 2, 2, 2, 264, 2550, 3, 2, 2, 2, 266, 2552, 3, 2, 2,
	2, 268, 2554, 3, 2, 2, 2, 270, 2557, 3, 2, 2, 2, 272, 2559, 3, 2, 2, 2,
	274, 2561, 3, 2, 2, 2, 276, 2563, 3, 2, 2, 2, 278, 2565, 3, 2, 2, 2, 280,
	2573, 3, 2, 2, 2, 282, 2587, 3, 2, 2, 2, 284, 2601, 3, 2, 2, 2, 286, 2609,
	3, 2, 2, 2, 288, 2617, 3, 2, 2, 2, 290, 2623, 3, 2, 2, 2, 292, 2629, 3,
	2, 2, 2, 294, 2635, 3, 2, 2, 2, 296, 2643, 3, 2, 2, 2, 298, 2646, 3, 2,
	2, 2, 300, 2649, 3, 2, 2, 2, 302, 2655, 3, 2, 2, 2, 304, 2661, 3, 2, 2,
	2, 306, 2669, 3, 2, 2, 2, 308, 2678, 3, 2, 2, 2, 310, 2680, 3, 2, 2, 2,
	312, 2682, 3, 2, 2, 2, 314, 2684, 3, 2, 2, 2, 316, 2698, 3, 2, 2, 2, 318,
	2703, 3, 2, 2, 2, 320, 2705, 3, 2, 2, 2, 322, 2707, 3, 2, 2, 2, 324, 2716,
	3, 2, 2, 2, 326, 2722, 3, 2, 2, 2, 328, 2745, 3, 2, 2, 2, 330, 2749, 3,
	2, 2, 2, 332, 2764, 3, 2, 2, 2, 334, 2767, 3, 2, 2, 2, 336, 2771, 3, 2,
	2, 2, 338, 2775, 3, 2, 2, 2, 340, 2781, 3, 2, 2, 2, 342, 2783, 3, 2, 2,
	2, 344, 2797, 3, 2, 2, 2, 346, 2807, 3, 2, 2, 2, 348, 2832, 3, 2, 2, 2,
	350, 2838, 3, 2, 2, 2, 352, 2847, 3, 2, 2, 2, 354, 2851, 3, 2, 2, 2, 356,
	2856, 3, 2, 2, 2, 358, 2868, 3, 2, 2, 2, 360, 2876, 3, 2, 2, 2, 362, 2879,
	3, 2, 2, 2, 364, 2889, 3, 2, 2, 2, 366, 2892, 3, 2, 2, 2, 368, 2895, 3,
	2, 2, 2, 370, 2901, 3, 2, 2, 2, 372, 2909, 3, 2, 2, 2, 374, 2918, 3, 2,
	2, 2, 376, 2924, 3, 2, 2, 2, 378, 2948, 3, 2, 2, 2, 380, 2964, 3, 2, 2,
	2, 382, 2969, 3, 2, 2, 2, 384, 2974, 3, 2, 2, 2, 386, 2980, 3, 2, 2, 2,
	388, 2985, 3, 2, 2, 2, 390, 2995, 3, 2, 2, 2, 392, 3002, 3, 2, 2, 2, 394,
	3007, 3, 2, 2, 2, 396, 3009, 3, 2, 2, 2, 398, 3015, 3, 2, 2, 2, 400, 3026,
	3, 2, 2, 2, 402, 3028, 3, 2, 2, 2, 404, 3037, 3, 2, 2, 2, 406, 3053, 3,
	2, 2, 2, 408, 3061, 3, 2, 2, 2, 410, 3078, 3, 2, 2, 2, 412, 3082, 3, 2,
	2, 2, 414, 3088, 3, 2, 2, 2, 416, 3094, 3, 2, 2, 2, 418, 3099, 3, 2, 2,
	2, 420, 3113, 3, 2, 2, 2, 422, 3116, 3, 2, 2, 2, 424, 3119, 3, 2, 2, 2,
	426, 3127, 3, 2, 2, 2, 428, 3129, 3, 2, 2, 2, 430, 3137, 3, 2, 2, 2, 432,
	3140, 3, 2, 2, 2, 434, 3145, 3, 2, 2, 2, 436, 3153, 3, 2, 2, 2, 438, 3155,
	3, 2, 2, 2, 440, 3188, 3, 2, 2, 2, 442, 3193, 3, 2, 2, 2, 444, 3199, 3,
	2, 2, 2, 446, 3206, 3, 2, 2, 2, 448, 3208, 3, 2, 2, 2, 450, 3214, 3, 2,
	2, 2, 452, 3217, 3, 2, 2, 2, 454, 3225, 3, 2, 2, 2, 456, 3229, 3, 2, 2,
	2, 458, 3231, 3, 2, 2, 2, 460, 3235, 3, 2, 2, 2, 462, 3270, 3, 2, 2, 2,
	464, 3273, 3, 2, 2, 2, 466, 3285, 3, 2, 2, 2, 468, 3299, 3, 2, 2, 2, 470,
	3319, 3, 2, 2, 2, 472, 3321, 3, 2, 2, 2, 474, 3326, 3, 2, 2, 2, 476, 3333,
	3, 2, 2, 2, 478, 3336, 3, 2, 2, 2, 480, 3339, 3, 2, 2, 2, 482, 3349, 3,
	2, 2, 2, 484, 3358, 3, 2, 2, 2, 486, 3363, 3, 2, 2, 2, 488, 3367, 3, 2,
	2, 2, 490, 3374, 3, 2, 2, 2, 492, 3382, 3, 2, 2, 2, 494, 3419, 3, 2, 2,
	2, 496, 3436, 3, 2, 2, 2, 498, 3448, 3, 2, 2, 2, 500, 3454, 3, 2, 2, 2,
	502, 3456, 3, 2, 2, 2, 504, 3460, 3, 2, 2, 2, 506, 3465, 3, 2, 2, 2, 508,
	3479, 3, 2, 2, 2, 510, 3485, 3, 2, 2, 2, 512, 3490, 3, 2, 2, 2, 514, 3496,
	3, 2, 2, 2, 516, 3511, 3, 2, 2, 2, 518, 3514, 3, 2, 2, 2, 520, 3525, 3,
	2, 2, 2, 522, 3527, 3, 2, 2, 2, 524, 3538, 3, 2, 2, 2, 526, 3544, 3, 2,
	2, 2, 528, 3549, 3, 2, 2, 2, 530, 3556, 3, 2, 2, 2, 532, 3563, 3, 2, 2,
	2, 534, 3572, 3, 2, 2, 2, 536, 3586, 3, 2, 2, 2, 538, 3640, 3, 2, 2, 2,
	540, 3642, 3, 2, 2, 2, 542, 3659, 3, 2, 2, 2, 544, 3681, 3, 2, 2, 2, 546,
	3684, 3, 2, 2, 2, 548, 3689, 3, 2, 2, 2, 550, 3693, 3, 2, 2, 2, 552, 3709,
	3, 2, 2, 2, 554, 3720, 3, 2, 2, 2, 556, 3738, 3, 2, 2, 2, 558, 3745, 3,
	2, 2, 2, 560, 3747, 3, 2, 2, 2, 562, 3753, 3, 2, 2, 2, 564, 3755, 3, 2,
	2, 2, 566, 3759, 3, 2, 2, 2, 568, 3765, 3, 2, 2, 2, 570, 3771, 3, 2, 2,
	2, 572, 3779, 3, 2, 2, 2, 574, 3802, 3, 2, 2, 2, 576, 3811, 3, 2, 2, 2,
	578, 3817, 3, 2, 2, 2, 580, 3836, 3, 2, 2, 2, 582, 3839, 3, 2, 2, 2, 584,
	3853, 3, 2, 2, 2, 586, 3860, 3, 2, 2, 2, 588, 3879, 3, 2, 2, 2, 590, 3881,
	3, 2, 2, 2, 592, 3884, 3, 2, 2, 2, 594, 3895, 3, 2, 2, 2, 596, 3897, 3,
	2, 2, 2, 598, 3903, 3, 2, 2, 2, 600, 3909, 3, 2, 2, 2, 602, 3927, 3, 2,
	2, 2, 604, 3941, 3, 2, 2, 2, 606, 3954, 3, 2, 2, 2, 608, 3956, 3, 2, 2,
	2, 610, 3962, 3, 2, 2, 2, 612, 3967, 3, 2, 2, 2, 614, 3975, 3, 2, 2, 2,
	616, 3992, 3, 2, 2, 2, 618, 3996, 3, 2, 2, 2, 620, 3998, 3, 2, 2, 2, 622,
	4012, 3, 2, 2, 2, 624, 4031, 3, 2, 2, 2, 626, 4048, 3, 2, 2, 2, 628, 4050,
	3, 2, 2, 2, 630, 4055, 3, 2, 2, 2, 632, 4061, 3, 2, 2, 2, 634, 4066, 3,
	2, 2, 2, 636, 4088, 3, 2, 2, 2, 638, 4094, 3, 2, 2, 2, 640, 4102, 3, 2,
	2, 2, 642, 4110, 3, 2, 2, 2, 644, 4116, 3, 2, 2, 2, 646, 4120, 3, 2, 2,
	2, 648, 4124, 3, 2, 2, 2, 650, 4127, 3, 2, 2, 2, 652, 4146, 3, 2, 2, 2,
	654, 4156, 3, 2, 2, 2, 656, 4179, 3, 2, 2, 2, 658, 4181, 3, 2, 2, 2, 660,
	4185, 3, 2, 2, 2, 662, 4195, 3, 2, 2, 2, 664, 4213, 3, 2, 2, 2, 666, 4215,
	3, 2, 2, 2, 668, 4218, 3, 2, 2, 2, 670, 4221, 3, 2, 2, 2, 672, 4232, 3,
	2, 2, 2, 674, 4235, 3, 2, 2, 2, 676, 4240, 3, 2, 2, 2, 678, 4245, 3, 2,
	2, 2, 680, 4249, 3, 2, 2, 2, 682, 4263, 3, 2, 2, 2, 684, 4265, 3, 2, 2,
	2, 686, 4269, 3, 2, 2, 2, 688, 4272, 3, 2, 2, 2, 690, 4274, 3, 2, 2, 2,
	692, 4282, 3, 2, 2, 2, 694, 4297, 3, 2, 2, 2, 696, 4299, 3, 2, 2, 2, 698,
	4309, 3, 2, 2, 2, 700, 4321, 3, 2, 2, 2, 702, 4332, 3, 2, 2, 2, 704, 4341,
	3, 2, 2, 2, 706, 4347, 3, 2, 2, 2, 708, 4356, 3, 2, 2, 2, 710, 4362, 3,
	2, 2, 2, 712, 4370, 3, 2, 2, 2, 714, 4376, 3, 2, 2, 2, 716, 4383, 3, 2,
	2, 2, 718, 4394, 3, 2, 2, 2, 720, 4406, 3, 2, 2, 2, 722, 4414, 3, 2, 2,
	2, 724, 4421, 3, 2, 2, 2, 726, 4429, 3, 2, 2, 2, 728, 4435, 3, 2, 2, 2,
	730, 4443, 3, 2, 2, 2, 732, 4453, 3, 2, 2, 2, 734, 4462, 3, 2, 2, 2, 736,
	4467, 3, 2, 2, 2, 738, 4472, 3, 2, 2, 2, 740, 4480, 3, 2, 2, 2, 742, 4506,
	3, 2, 2, 2, 744, 4518, 3, 2, 2, 2, 746, 4536, 3, 2, 2, 2, 748, 4543, 3,
	2, 2, 2, 750, 4551, 3, 2, 2, 2, 752, 4557, 3, 2, 2, 2, 754, 4566, 3, 2,
	2, 2, 756, 4569, 3, 2, 2, 2, 758, 4575, 3, 2, 2, 2, 760, 4587, 3, 2, 2,
	2, 762, 4595, 3, 2, 2, 2, 764, 4604, 3, 2, 2, 2, 766, 4606, 3, 2, 2, 2,
	768, 4614, 3, 2, 2, 2, 770, 4616, 3, 2, 2, 2, 772, 4636, 3, 2, 2, 2, 774,
	4640, 3, 2, 2, 2, 776, 4644, 3, 2, 2, 2, 778, 4653, 3, 2, 2, 2, 780, 4655,
	3, 2, 2, 2, 782, 4659, 3, 2, 2, 2, 784, 4668, 3, 2, 2, 2, 786, 4674, 3,
	2, 2, 2, 788, 4683, 3, 2, 2, 2, 790, 4689, 3, 2, 2, 2, 792, 4697, 3, 2,
	2, 2, 794, 4703, 3, 2, 2, 2, 796, 4709, 3, 2, 2, 2, 798, 4715, 3, 2, 2,
	2, 800, 4725, 3, 2, 2, 2, 802, 4736, 3, 2, 2, 2, 804, 4740, 3, 2, 2, 2,
	806, 4745, 3, 2, 2, 2, 808, 4757, 3, 2, 2, 2, 810, 4759, 3, 2, 2, 2, 812,
	4769, 3, 2, 2, 2, 814, 4775, 3, 2, 2, 2, 816, 4778, 3, 2, 2, 2, 818, 4784,
	3, 2, 2, 2, 820, 4791, 3, 2, 2, 2, 822, 4796, 3, 2, 2, 2, 824, 4802, 3,
	2, 2, 2, 826, 4834, 3, 2, 2, 2, 828, 4838, 3, 2, 2, 2, 830, 4845, 3, 2,
	2, 2, 832, 4851, 3, 2, 2, 2, 834, 4865, 3, 2, 2, 2, 836, 4884, 3, 2, 2,
	2, 838, 4886, 3, 2, 2, 2, 840, 4898, 3, 2, 2, 2, 842, 4906, 3, 2, 2, 2,
	844, 4914, 3, 2, 2, 2, 846, 4923, 3, 2, 2, 2, 848, 4928, 3, 2, 2, 2, 850,
	4934, 3, 2, 2, 2, 852, 4942, 3, 2, 2, 2, 854, 4948, 3, 2, 2, 2, 856, 4954,
	3, 2, 2, 2, 858, 4969, 3, 2, 2, 2, 860, 4972, 3, 2, 2, 2, 862, 4986, 3,
	2, 2, 2, 864, 4989, 3, 2, 2, 2, 866, 5008, 3, 2, 2, 2, 868, 5011, 3, 2,
	2, 2, 870, 5023, 3, 2, 2, 2, 872, 5036, 3, 2, 2, 2, 874, 5050, 3, 2, 2,
	2, 876, 5054, 3, 2, 2, 2, 878, 5057, 3, 2, 2, 2, 880, 5064, 3, 2, 2, 2,
	882, 5068, 3, 2, 2, 2, 884, 5077, 3, 2, 2, 2, 886, 5081, 3, 2, 2, 2, 888,
	5086, 3, 2, 2, 2, 890, 5088, 3, 2, 2, 2, 892, 5098, 3, 2, 2, 2, 894, 5109,
	3, 2, 2, 2, 896, 5121, 3, 2, 2, 2, 898, 5132, 3, 2, 2, 2, 900, 5136, 3,
	2, 2, 2, 902, 5138, 3, 2, 2, 2, 904, 5170, 3, 2, 2, 2, 906, 5182, 3, 2,
	2, 2, 908, 5192, 3, 2, 2, 2, 910, 5210, 3, 2, 2, 2, 912, 5217, 3, 2, 2,
	2, 914, 5225, 3, 2, 2, 2, 916, 5234, 3, 2, 2, 2, 918, 5237, 3, 2, 2, 2,
	920, 5243, 3, 2, 2, 2, 922, 5252, 3, 2, 2, 2, 924, 5255, 3, 2, 2, 2, 926,
	5261, 3, 2, 2, 2, 928, 5273, 3, 2, 2, 2, 930, 5287, 3, 2, 2, 2, 932, 5322,
	3, 2, 2, 2, 934, 5327, 3, 2, 2, 2, 936, 5347, 3, 2, 2, 2, 938, 5357, 3,
	2, 2, 2, 940, 5359, 3, 2, 2, 2, 942, 5368, 3, 2, 2, 2, 944, 5373, 3, 2,
	2, 2, 946, 5377, 3, 2, 2, 2, 948, 5382, 3, 2, 2, 2, 950, 5398, 3, 2, 2,
	2, 952, 5409, 3, 2, 2, 2, 954, 5421, 3, 2, 2, 2, 956, 5428, 3, 2, 2, 2,
	958, 5430, 3, 2, 2, 2, 960, 5436, 3, 2, 2, 2, 962, 5438, 3, 2, 2, 2, 964,
	5442, 3, 2, 2, 2, 966, 5446, 3, 2, 2, 2, 968, 5449, 3, 2, 2, 2, 970, 5467,
	3, 2, 2, 2, 972, 5477, 3, 2, 2, 2, 974, 5488, 3, 2, 2, 2, 976, 5496, 3,
	2, 2, 2, 978, 5502, 3, 2, 2, 2, 980, 5509, 3, 2, 2, 2, 982, 5515, 3, 2,
	2, 2, 984, 5522, 3, 2, 2, 2, 986, 5527, 3, 2, 2, 2, 988, 5533, 3, 2, 2,
	2, 990, 5539, 3, 2, 2, 2, 992, 5561, 3, 2, 2, 2, 994, 5564, 3, 2, 2, 2,
	996, 5587, 3, 2, 2, 2, 998, 5589, 3, 2, 2, 2, 1000, 5612, 3, 2, 2, 2, 1002,
	5617, 3, 2, 2, 2, 1004, 5626, 3, 2, 2, 2, 1006, 5630, 3, 2, 2, 2, 1008,
	5635, 3, 2, 2, 2, 1010, 5638, 3, 2, 2, 2, 1012, 5647, 3, 2, 2, 2, 1014,
	5659, 3, 2, 2, 2, 1016, 5668, 3, 2, 2, 2, 1018, 5679, 3, 2, 2, 2, 1020,
	5689, 3, 2, 2, 2, 1022, 5701, 3, 2, 2, 2, 1024, 5710, 3, 2, 2, 2, 1026,
	5722, 3, 2, 2, 2, 1028, 5732, 3, 2, 2, 2, 1030, 5745, 3, 2, 2, 2, 1032,
	5754, 3, 2, 2, 2, 1034, 5765, 3, 2, 2, 2, 1036, 5772, 3, 2, 2, 2, 1038,
	5775, 3, 2, 2, 2, 1040, 5782, 3, 2, 2, 2, 1042, 5786, 3, 2, 2, 2, 1044,
	5795, 3, 2, 2, 2, 1046, 5804, 3, 2, 2, 2, 1048, 5806, 3, 2, 2, 2, 1050,
	5813, 3, 2, 2, 2, 1052, 5823, 3, 2, 2, 2, 1054, 5834, 3, 2, 2, 2, 1056,
	5836, 3, 2, 2, 2, 1058, 5852, 3, 2, 2, 2, 1060, 5876, 3, 2, 2, 2, 1062,
	5892, 3, 2, 2, 2, 1064, 5894, 3, 2, 2, 2, 1066, 5903, 3, 2, 2, 2, 1068,
	5907, 3, 2, 2, 2, 1070, 5913, 3, 2, 2, 2, 1072, 5921, 3, 2, 2, 2, 1074,
	5967, 3, 2, 2, 2, 1076, 5984, 3, 2, 2, 2, 1078, 5986, 3, 2, 2, 2, 1080,
	6008, 3, 2, 2, 2, 1082, 6031, 3, 2, 2, 2, 1084, 6039, 3, 2, 2, 2, 1086,
	6041, 3, 2, 2, 2, 1088, 6054, 3, 2, 2, 2, 1090, 6067, 3, 2, 2, 2, 1092,
	6073, 3, 2, 2, 2, 1094, 6077, 3, 2, 2, 2, 1096, 6090, 3, 2, 2, 2, 1098,
	6093, 3, 2, 2, 2, 1100, 6096, 3, 2, 2, 2, 1102, 6101, 3, 2, 2, 2, 1104,
	6103, 3, 2, 2, 2, 1106, 6106, 3, 2, 2, 2, 1108, 6109, 3, 2, 2, 2, 1110,
	6112, 3, 2, 2, 2, 1112, 6115, 3, 2, 2, 2, 1114, 6118, 3, 2, 2, 2, 1116,
	6121, 3, 2, 2, 2, 1118, 6123, 3, 2, 2, 2, 1120, 6125, 3, 2, 2, 2, 1122,
	6127, 3, 2, 2, 2, 1124, 6129, 3, 2, 2, 2, 1126, 6131, 3, 2, 2, 2, 1128,
	6133, 3, 2, 2, 2, 1130, 6135, 3, 2, 2, 2, 1132, 6140, 3, 2, 2, 2, 1134,
	6142, 3, 2, 2, 2, 1136, 6144, 3, 2, 2, 2, 1138, 6152, 3, 2, 2, 2, 1140,
	6154, 3, 2, 2, 2, 1142, 6156, 3, 2, 2, 2, 1144, 6158, 3, 2, 2, 2, 1146,
	6160, 3, 2, 2, 2, 1148, 6162, 3, 2, 2, 2, 1150, 6166, 3, 2, 2, 2, 1152,
	6173, 3, 2, 2, 2, 1154, 6177, 3, 2, 2, 2, 1156, 6179, 3, 2, 2, 2, 1158,
	6181, 3, 2, 2, 2, 1160, 6183, 3, 2, 2, 2, 1162, 6185, 3, 2, 2, 2, 1164,
	6189, 3, 2, 2, 2, 1166, 6191, 3, 2, 2, 2, 1168, 6193, 3, 2, 2, 2, 1170,
	6195, 3, 2, 2, 2, 1172, 6197, 3, 2, 2, 2, 1174, 6205, 3, 2, 2, 2, 1176,
	6207, 3, 2, 2, 2, 1178, 6212, 3, 2, 2, 2, 1180, 6214, 3, 2, 2, 2, 1182,
	6216, 3, 2, 2, 2, 1184, 6224, 3, 2, 2, 2, 1186, 6247, 3, 2, 2, 2, 1188,
	6282, 3, 2, 2, 2, 1190, 6285, 3, 2, 2, 2, 1192, 1193, 5, 4, 3, 2, 1193,
	1194, 7, 2, 2, 3, 1194, 3, 3, 2, 2, 2, 1195, 1197, 5, 6, 4, 2, 1196, 1195,
	3, 2, 2, 2, 1197, 1198, 3, 2, 2, 2, 1198, 1196, 3, 2, 2, 2, 1198, 1199,
	3, 2, 2, 2, 1199, 5, 3, 2, 2, 2, 1200, 1202, 5, 10, 6, 2, 1201, 1203, 5,
	28, 15, 2, 1202, 1201, 3, 2, 2, 2, 1202, 1203, 3, 2, 2, 2, 1203, 1205,
	3, 2, 2, 2, 1204, 1206, 5, 156, 79, 2, 1205, 1204, 3, 2, 2, 2, 1205, 1206,
	3, 2, 2, 2, 1206, 1208, 3, 2, 2, 2, 1207, 1209, 5, 506, 254, 2, 1208, 1207,
	3, 2, 2, 2, 1208, 1209, 3, 2, 2, 2, 1209, 1213, 3, 2, 2, 2, 1210, 1212,
	5, 6, 4, 2, 1211, 1210, 3, 2, 2, 2, 1212, 1215, 3, 2, 2, 2, 1213, 1211,
	3, 2, 2, 2, 1213, 1214, 3, 2, 2, 2, 1214, 1217, 3, 2, 2, 2, 1215, 1213,
	3, 2, 2, 2, 1216, 1218, 5, 8, 5, 2, 1217, 1216, 3, 2, 2, 2, 1217, 1218,
	3, 2, 2, 2, 1218, 7, 3, 2, 2, 2, 1219, 1220, 7, 160, 2, 2, 1220, 1221,
	7, 363, 2, 2, 1221, 1222, 5, 1154, 578, 2, 1222, 1223, 7, 536, 2, 2, 1223,
	9, 3, 2, 2, 2, 1224, 1225, 9, 2, 2, 2, 1225, 1226, 7, 147, 2, 2, 1226,
	1227, 7, 536, 2, 2, 1227, 1231, 5, 14, 8, 2, 1228, 1230, 5, 12, 7, 2, 1229,
	1228, 3, 2, 2, 2, 1230, 1233, 3, 2, 2, 2, 1231, 1229, 3, 2, 2, 2, 1231,
	1232, 3, 2, 2, 2, 1232, 11, 3, 2, 2, 2, 1233, 1231, 3, 2, 2, 2, 1234, 1241,
	5, 16, 9, 2, 1235, 1241, 5, 18, 10, 2, 1236, 1241, 5, 20, 11, 2, 1237,
	1241, 5, 22, 12, 2, 1238, 1241, 5, 24, 13, 2, 1239, 1241, 5, 26, 14, 2,
	1240, 1234, 3, 2, 2, 2, 1240, 1235, 3, 2, 2, 2, 1240, 1236, 3, 2, 2, 2,
	1240, 1237, 3, 2, 2, 2, 1240, 1238, 3, 2, 2, 2, 1240, 1239, 3, 2, 2, 2,
	1241, 13, 3, 2, 2, 2, 1242, 1243, 7, 364, 2, 2, 1243, 1244, 7, 536, 2,
	2, 1244, 1252, 5, 1154, 578, 2, 1245, 1247, 7, 256, 2, 2, 1246, 1245, 3,
	2, 2, 2, 1246, 1247, 3, 2, 2, 2, 1247, 1248, 3, 2, 2, 2, 1248, 1250, 9,
	3, 2, 2, 1249, 1251, 7, 363, 2, 2, 1250, 1249, 3, 2, 2, 2, 1250, 1251,
	3, 2, 2, 2, 1251, 1253, 3, 2, 2, 2, 1252, 1246, 3, 2, 2, 2, 1252, 1253,
	3, 2, 2, 2, 1253, 1255, 3, 2, 2, 2, 1254, 1256, 7, 536, 2, 2, 1255, 1254,
	3, 2, 2, 2, 1255, 1256, 3, 2, 2, 2, 1256, 1258, 3, 2, 2, 2, 1257, 1259,
	5, 1190, 596, 2, 1258, 1257, 3, 2, 2, 2, 1258, 1259, 3, 2, 2, 2, 1259,
	15, 3, 2, 2, 2, 1260, 1261, 7, 34, 2, 2, 1261, 1263, 7, 536, 2, 2, 1262,
	1264, 5, 1190, 596, 2, 1263, 1262, 3, 2, 2, 2, 1263, 1264, 3, 2, 2, 2,
	1264, 17, 3, 2, 2, 2, 1265, 1266, 7, 251, 2, 2, 1266, 1268, 7, 536, 2,
	2, 1267, 1269, 5, 1190, 596, 2, 1268, 1267, 3, 2, 2, 2, 1268, 1269, 3,
	2, 2, 2, 1269, 19, 3, 2, 2, 2, 1270, 1271, 7, 115, 2, 2, 1271, 1273, 7,
	536, 2, 2, 1272, 1274, 5, 1190, 596, 2, 1273, 1272, 3, 2, 2, 2, 1273, 1274,
	3, 2, 2, 2, 1274, 21, 3, 2, 2, 2, 1275, 1276, 7, 114, 2, 2, 1276, 1278,
	7, 536, 2, 2, 1277, 1279, 5, 1190, 596, 2, 1278, 1277, 3, 2, 2, 2, 1278,
	1279, 3, 2, 2, 2, 1279, 23, 3, 2, 2, 2, 1280, 1281, 7, 423, 2, 2, 1281,
	1283, 7, 536, 2, 2, 1282, 1284, 5, 1190, 596, 2, 1283, 1282, 3, 2, 2, 2,
	1283, 1284, 3, 2, 2, 2, 1284, 25, 3, 2, 2, 2, 1285, 1286, 7, 391, 2, 2,
	1286, 1288, 7, 536, 2, 2, 1287, 1289, 5, 1190, 596, 2, 1288, 1287, 3, 2,
	2, 2, 1288, 1289, 3, 2, 2, 2, 1289, 27, 3, 2, 2, 2, 1290, 1291, 7, 186,
	2, 2, 1291, 1292, 7, 147, 2, 2, 1292, 1296, 7, 536, 2, 2, 1293, 1295, 5,
	30, 16, 2, 1294, 1293, 3, 2, 2, 2, 1295, 1298, 3, 2, 2, 2, 1296, 1294,
	3, 2, 2, 2, 1296, 1297, 3, 2, 2, 2, 1297, 29, 3, 2, 2, 2, 1298, 1296, 3,
	2, 2, 2, 1299, 1303, 5, 32, 17, 2, 1300, 1303, 5, 56, 29, 2, 1301, 1303,
	5, 102, 52, 2, 1302, 1299, 3, 2, 2, 2, 1302, 1300, 3, 2, 2, 2, 1302, 1301,
	3, 2, 2, 2, 1303, 31, 3, 2, 2, 2, 1304, 1305, 7, 95, 2, 2, 1305, 1306,
	7, 421, 2, 2, 1306, 1310, 7, 536, 2, 2, 1307, 1309, 5, 34, 18, 2, 1308,
	1307, 3, 2, 2, 2, 1309, 1312, 3, 2, 2, 2, 1310, 1308, 3, 2, 2, 2, 1310,
	1311, 3, 2, 2, 2, 1311, 33, 3, 2, 2, 2, 1312, 1310, 3, 2, 2, 2, 1313, 1317,
	5, 36, 19, 2, 1314, 1317, 5, 38, 20, 2, 1315, 1317, 5, 56, 29, 2, 1316,
	1313, 3, 2, 2, 2, 1316, 1314, 3, 2, 2, 2, 1316, 1315, 3, 2, 2, 2, 1317,
	35, 3, 2, 2, 2, 1318, 1319, 7, 451, 2, 2, 1319, 1320, 7, 536, 2, 2, 1320,
	1326, 5, 1126, 564, 2, 1321, 1323, 7, 516, 2, 2, 1322, 1321, 3, 2, 2, 2,
	1322, 1323, 3, 2, 2, 2, 1323, 1324, 3, 2, 2, 2, 1324, 1325, 7, 127, 2,
	2, 1325, 1327, 7, 299, 2, 2, 1326, 1322, 3, 2, 2, 2, 1326, 1327, 3, 2,
	2, 2, 1327, 1328, 3, 2, 2, 2, 1328, 1329, 7, 536, 2, 2, 1329, 37, 3, 2,
	2, 2, 1330, 1331, 7, 322, 2, 2, 1331, 1332, 7, 536, 2, 2, 1332, 1336, 5,
	1126, 564, 2, 1333, 1335, 5, 40, 21, 2, 1334, 1333, 3, 2, 2, 2, 1335, 1338,
	3, 2, 2, 2, 1336, 1334, 3, 2, 2, 2, 1336, 1337, 3, 2, 2, 2, 1337, 1339,
	3, 2, 2, 2, 1338, 1336, 3, 2, 2, 2, 1339, 1340, 7, 536, 2, 2, 1340, 39,
	3, 2, 2, 2, 1341, 1347, 5, 42, 22, 2, 1342, 1347, 5, 44, 23, 2, 1343, 1347,
	5, 46, 24, 2, 1344, 1347, 5, 52, 27, 2, 1345, 1347, 5, 54, 28, 2, 1346,
	1341, 3, 2, 2, 2, 1346, 1342, 3, 2, 2, 2, 1346, 1343, 3, 2, 2, 2, 1346,
	1344, 3, 2, 2, 2, 1346, 1345, 3, 2, 2, 2, 1347, 41, 3, 2, 2, 2, 1348, 1350,
	7, 295, 2, 2, 1349, 1351, 7, 441, 2, 2, 1350, 1349, 3, 2, 2, 2, 1350, 1351,
	3, 2, 2, 2, 1351, 1354, 3, 2, 2, 2, 1352, 1355, 5, 1180, 591, 2, 1353,
	1355, 5, 1172, 587, 2, 1354, 1352, 3, 2, 2, 2, 1354, 1353, 3, 2, 2, 2,
	1355, 1357, 3, 2, 2, 2, 1356, 1358, 9, 4, 2, 2, 1357, 1356, 3, 2, 2, 2,
	1357, 1358, 3, 2, 2, 2, 1358, 43, 3, 2, 2, 2, 1359, 1361, 7, 143, 2, 2,
	1360, 1362, 7, 441, 2, 2, 1361, 1360, 3, 2, 2, 2, 1361, 1362, 3, 2, 2,
	2, 1362, 1364, 3, 2, 2, 2, 1363, 1365, 7, 256, 2, 2, 1364, 1363, 3, 2,
	2, 2, 1364, 1365, 3, 2, 2, 2, 1365, 1368, 3, 2, 2, 2, 1366, 1369, 5, 1180,
	591, 2, 1367, 1369, 5, 1172, 587, 2, 1368, 1366, 3, 2, 2, 2, 1368, 1367,
	3, 2, 2, 2, 1369, 1371, 3, 2, 2, 2, 1370, 1372, 9, 5, 2, 2, 1371, 1370,
	3, 2, 2, 2, 1371, 1372, 3, 2, 2, 2, 1372, 45, 3, 2, 2, 2, 1373, 1375, 7,
	363, 2, 2, 1374, 1373, 3, 2, 2, 2, 1374, 1375, 3, 2, 2, 2, 1375, 1377,
	3, 2, 2, 2, 1376, 1378, 7, 74, 2, 2, 1377, 1376, 3, 2, 2, 2, 1377, 1378,
	3, 2, 2, 2, 1378, 1379, 3, 2, 2, 2, 1379, 1381, 7, 430, 2, 2, 1380, 1382,
	7, 256, 2, 2, 1381, 1380, 3, 2, 2, 2, 1381, 1382, 3, 2, 2, 2, 1382, 1384,
	3, 2, 2, 2, 1383, 1385, 5, 1116, 559, 2, 1384, 1383, 3, 2, 2, 2, 1385,
	1386, 3, 2, 2, 2, 1386, 1384, 3, 2, 2, 2, 1386, 1387, 3, 2, 2, 2, 1387,
	1389, 3, 2, 2, 2, 1388, 1390, 5, 48, 25, 2, 1389, 1388, 3, 2, 2, 2, 1389,
	1390, 3, 2, 2, 2, 1390, 1392, 3, 2, 2, 2, 1391, 1393, 5, 50, 26, 2, 1392,
	1391, 3, 2, 2, 2, 1392, 1393, 3, 2, 2, 2, 1393, 47, 3, 2, 2, 2, 1394, 1396,
	7, 214, 2, 2, 1395, 1394, 3, 2, 2, 2, 1395, 1396, 3, 2, 2, 2, 1396, 1397,
	3, 2, 2, 2, 1397, 1399, 7, 16, 2, 2, 1398, 1400, 7, 256, 2, 2, 1399, 1398,
	3, 2, 2, 2, 1399, 1400, 3, 2, 2, 2, 1400, 1401, 3, 2, 2, 2, 1401, 1402,
	5, 1116, 559, 2, 1402, 49, 3, 2, 2, 2, 1403, 1405, 7, 214, 2, 2, 1404,
	1403, 3, 2, 2, 2, 1404, 1405, 3, 2, 2, 2, 1405, 1406, 3, 2, 2, 2, 1406,
	1408, 7, 306, 2, 2, 1407, 1409, 7, 256, 2, 2, 1408, 1407, 3, 2, 2, 2, 1408,
	1409, 3, 2, 2, 2, 1409, 1410, 3, 2, 2, 2, 1410, 1411, 5, 1116, 559, 2,
	1411, 51, 3, 2, 2, 2, 1412, 1414, 7, 425, 2, 2, 1413, 1415, 7, 256, 2,
	2, 1414, 1413, 3, 2, 2, 2, 1414, 1415, 3, 2, 2, 2, 1415, 1416, 3, 2, 2,
	2, 1416, 1417, 5, 1180, 591, 2, 1417, 53, 3, 2, 2, 2, 1418, 1419, 7, 64,
	2, 2, 1419, 1420, 7, 432, 2, 2, 1420, 1421, 7, 536, 2, 2, 1421, 55, 3,
	2, 2, 2, 1422, 1423, 7, 454, 2, 2, 1423, 1431, 7, 536, 2, 2, 1424, 1426,
	5, 58, 30, 2, 1425, 1424, 3, 2, 2, 2, 1426, 1427, 3, 2, 2, 2, 1427, 1425,
	3, 2, 2, 2, 1427, 1428, 3, 2, 2, 2, 1428, 1429, 3, 2, 2, 2, 1429, 1430,
	7, 536, 2, 2, 1430, 1432, 3, 2, 2, 2, 1431, 1425, 3, 2, 2, 2, 1431, 1432,
	3, 2, 2, 2, 1432, 57, 3, 2, 2, 2, 1433, 1445, 5, 72, 37, 2, 1434, 1445,
	5, 94, 48, 2, 1435, 1445, 5, 60, 31, 2, 1436, 1445, 5, 74, 38, 2, 1437,
	1445, 5, 82, 42, 2, 1438, 1445, 5, 84, 43, 2, 1439, 1445, 5, 98, 50, 2,
	1440, 1445, 5, 90, 46, 2, 1441, 1445, 5, 88, 45, 2, 1442, 1445, 5, 86,
	44, 2, 1443, 1445, 5, 96, 49, 2, 1444, 1433, 3, 2, 2, 2, 1444, 1434, 3,
	2, 2, 2, 1444, 1435, 3, 2, 2, 2, 1444, 1436, 3, 2, 2, 2, 1444, 1437, 3,
	2, 2, 2, 1444, 1438, 3, 2, 2, 2, 1444, 1439, 3, 2, 2, 2, 1444, 1440, 3,
	2, 2, 2, 1444, 1441, 3, 2, 2, 2, 1444, 1442, 3, 2, 2, 2, 1444, 1443, 3,
	2, 2, 2, 1445, 59, 3, 2, 2, 2, 1446, 1449, 5, 62, 32, 2, 1447, 1449, 5,
	70, 36, 2, 1448, 1446, 3, 2, 2, 2, 1448, 1447, 3, 2, 2, 2, 1449, 61, 3,
	2, 2, 2, 1450, 1451, 7, 12, 2, 2, 1451, 1454, 5, 1116, 559, 2, 1452, 1453,
	7, 214, 2, 2, 1453, 1455, 7, 16, 2, 2, 1454, 1452, 3, 2, 2, 2, 1454, 1455,
	3, 2, 2, 2, 1455, 1457, 3, 2, 2, 2, 1456, 1458, 7, 256, 2, 2, 1457, 1456,
	3, 2, 2, 2, 1457, 1458, 3, 2, 2, 2, 1458, 1470, 3, 2, 2, 2, 1459, 1471,
	7, 153, 2, 2, 1460, 1471, 7, 28, 2, 2, 1461, 1471, 7, 456, 2, 2, 1462,
	1471, 7, 457, 2, 2, 1463, 1471, 7, 308, 2, 2, 1464, 1471, 5, 1172, 587,
	2, 1465, 1467, 5, 64, 33, 2, 1466, 1465, 3, 2, 2, 2, 1467, 1468, 3, 2,
	2, 2, 1468, 1466, 3, 2, 2, 2, 1468, 1469, 3, 2, 2, 2, 1469, 1471, 3, 2,
	2, 2, 1470, 1459, 3, 2, 2, 2, 1470, 1460, 3, 2, 2, 2, 1470, 1461, 3, 2,
	2, 2, 1470, 1462, 3, 2, 2, 2, 1470, 1463, 3, 2, 2, 2, 1470, 1464, 3, 2,
	2, 2, 1470, 1466, 3, 2, 2, 2, 1471, 63, 3, 2, 2, 2, 1472, 1479, 5, 1174,
	588, 2, 1473, 1480, 5, 66, 34, 2, 1474, 1476, 5, 68, 35, 2, 1475, 1474,
	3, 2, 2, 2, 1476, 1477, 3, 2, 2, 2, 1477, 1475, 3, 2, 2, 2, 1477, 1478,
	3, 2, 2, 2, 1478, 1480, 3, 2, 2, 2, 1479, 1473, 3, 2, 2, 2, 1479, 1475,
	3, 2, 2, 2, 1479, 1480, 3, 2, 2, 2, 1480, 65, 3, 2, 2, 2, 1481, 1482, 9,
	6, 2, 2, 1482, 1483, 5, 1174, 588, 2, 1483, 67, 3, 2, 2, 2, 1484, 1486,
	7, 18, 2, 2, 1485, 1487, 5, 1174, 588, 2, 1486, 1485, 3, 2, 2, 2, 1487,
	1488, 3, 2, 2, 2, 1488, 1486, 3, 2, 2, 2, 1488, 1489, 3, 2, 2, 2, 1489,
	69, 3, 2, 2, 2, 1490, 1491, 7, 12, 2, 2, 1491, 1493, 5, 1116, 559, 2, 1492,
	1494, 7, 214, 2, 2, 1493, 1492, 3, 2, 2, 2, 1493, 1494, 3, 2, 2, 2, 1494,
	1495, 3, 2, 2, 2, 1495, 1497, 7, 306, 2, 2, 1496, 1498, 7, 256, 2, 2, 1497,
	1496, 3, 2, 2, 2, 1497, 1498, 3, 2, 2, 2, 1498, 1502, 3, 2, 2, 2, 1499,
	1503, 7, 308, 2, 2, 1500, 1501, 7, 57, 2, 2, 1501, 1503, 5, 1174, 588,
	2, 1502, 1499, 3, 2, 2, 2, 1502, 1500, 3, 2, 2, 2, 1503, 71, 3, 2, 2, 2,
	1504, 1505, 7, 63, 2, 2, 1505, 1507, 5, 1180, 591, 2, 1506, 1508, 7, 256,
	2, 2, 1507, 1506, 3, 2, 2, 2, 1507, 1508, 3, 2, 2, 2, 1508, 1509, 3, 2,
	2, 2, 1509, 1510, 5, 1148, 575, 2, 1510, 73, 3, 2, 2, 2, 1511, 1512, 7,
	66, 2, 2, 1512, 1517, 5, 1124, 563, 2, 1513, 1515, 7, 214, 2, 2, 1514,
	1513, 3, 2, 2, 2, 1514, 1515, 3, 2, 2, 2, 1515, 1516, 3, 2, 2, 2, 1516,
	1518, 9, 7, 2, 2, 1517, 1514, 3, 2, 2, 2, 1517, 1518, 3, 2, 2, 2, 1518,
	1520, 3, 2, 2, 2, 1519, 1521, 7, 256, 2, 2, 1520, 1519, 3, 2, 2, 2, 1520,
	1521, 3, 2, 2, 2, 1521, 1523, 3, 2, 2, 2, 1522, 1524, 5, 76, 39, 2, 1523,
	1522, 3, 2, 2, 2, 1524, 1525, 3, 2, 2, 2, 1525, 1523, 3, 2, 2, 2, 1525,
	1526, 3, 2, 2, 2, 1526, 75, 3, 2, 2, 2, 1527, 1530, 5, 78, 40, 2, 1528,
	1529, 9, 6, 2, 2, 1529, 1531, 5, 80, 41, 2, 1530, 1528, 3, 2, 2, 2, 1530,
	1531, 3, 2, 2, 2, 1531, 77, 3, 2, 2, 2, 1532, 1535, 5, 1076, 539, 2, 1533,
	1535, 5, 1174, 588, 2, 1534, 1532, 3, 2, 2, 2, 1534, 1533, 3, 2, 2, 2,
	1535, 79, 3, 2, 2, 2, 1536, 1539, 5, 1076, 539, 2, 1537, 1539, 5, 1174,
	588, 2, 1538, 1536, 3, 2, 2, 2, 1538, 1537, 3, 2, 2, 2, 1539, 81, 3, 2,
	2, 2, 1540, 1542, 7, 109, 2, 2, 1541, 1543, 7, 440, 2, 2, 1542, 1541, 3,
	2, 2, 2, 1542, 1543, 3, 2, 2, 2, 1543, 1545, 3, 2, 2, 2, 1544, 1546, 7,
	256, 2, 2, 1545, 1544, 3, 2, 2, 2, 1545, 1546, 3, 2, 2, 2, 1546, 1547,
	3, 2, 2, 2, 1547, 1554, 5, 1174, 588, 2, 1548, 1550, 7, 516, 2, 2, 1549,
	1548, 3, 2, 2, 2, 1549, 1550, 3, 2, 2, 2, 1550, 1551, 3, 2, 2, 2, 1551,
	1552, 7, 349, 2, 2, 1552, 1553, 7, 468, 2, 2, 1553, 1555, 5, 1174, 588,
	2, 1554, 1549, 3, 2, 2, 2, 1554, 1555, 3, 2, 2, 2, 1555, 83, 3, 2, 2, 2,
	1556, 1558, 7, 128, 2, 2, 1557, 1559, 7, 256, 2, 2, 1558, 1557, 3, 2, 2,
	2, 1558, 1559, 3, 2, 2, 2, 1559, 1560, 3, 2, 2, 2, 1560, 1561, 7, 78, 2,
	2, 1561, 85, 3, 2, 2, 2, 1562, 1564, 7, 130, 2, 2, 1563, 1565, 9, 8, 2,
	2, 1564, 1563, 3, 2, 2, 2, 1564, 1565, 3, 2, 2, 2, 1565, 1570, 3, 2, 2,
	2, 1566, 1568, 7, 440, 2, 2, 1567, 1569, 7, 256, 2, 2, 1568, 1567, 3, 2,
	2, 2, 1568, 1569, 3, 2, 2, 2, 1569, 1571, 3, 2, 2, 2, 1570, 1566, 3, 2,
	2, 2, 1570, 1571, 3, 2, 2, 2, 1571, 1573, 3, 2, 2, 2, 1572, 1574, 9, 9,
	2, 2, 1573, 1572, 3, 2, 2, 2, 1573, 1574, 3, 2, 2, 2, 1574, 1575, 3, 2,
	2, 2, 1575, 1577, 7, 429, 2, 2, 1576, 1578, 7, 64, 2, 2, 1577, 1576, 3,
	2, 2, 2, 1577, 1578, 3, 2, 2, 2, 1578, 87, 3, 2, 2, 2, 1579, 1584, 7, 131,
	2, 2, 1580, 1582, 7, 440, 2, 2, 1581, 1583, 7, 256, 2, 2, 1582, 1581, 3,
	2, 2, 2, 1582, 1583, 3, 2, 2, 2, 1583, 1585, 3, 2, 2, 2, 1584, 1580, 3,
	2, 2, 2, 1584, 1585, 3, 2, 2, 2, 1585, 1586, 3, 2, 2, 2, 1586, 1591, 9,
	9, 2, 2, 1587, 1589, 7, 429, 2, 2, 1588, 1590, 7, 64, 2, 2, 1589, 1588,
	3, 2, 2, 2, 1589, 1590, 3, 2, 2, 2, 1590, 1592, 3, 2, 2, 2, 1591, 1587,
	3, 2, 2, 2, 1591, 1592, 3, 2, 2, 2, 1592, 89, 3, 2, 2, 2, 1593, 1595, 5,
	1134, 568, 2, 1594, 1596, 7, 256, 2, 2, 1595, 1594, 3, 2, 2, 2, 1595, 1596,
	3, 2, 2, 2, 1596, 1597, 3, 2, 2, 2, 1597, 1599, 5, 1148, 575, 2, 1598,
	1600, 5, 92, 47, 2, 1599, 1598, 3, 2, 2, 2, 1599, 1600, 3, 2, 2, 2, 1600,
	1603, 3, 2, 2, 2, 1601, 1603, 5, 92, 47, 2, 1602, 1593, 3, 2, 2, 2, 1602,
	1601, 3, 2, 2, 2, 1603, 91, 3, 2, 2, 2, 1604, 1606, 7, 328, 2, 2, 1605,
	1607, 7, 459, 2, 2, 1606, 1605, 3, 2, 2, 2, 1606, 1607, 3, 2, 2, 2, 1607,
	1609, 3, 2, 2, 2, 1608, 1610, 7, 256, 2, 2, 1609, 1608, 3, 2, 2, 2, 1609,
	1610, 3, 2, 2, 2, 1610, 1611, 3, 2, 2, 2, 1611, 1620, 5, 1048, 525, 2,
	1612, 1614, 7, 326, 2, 2, 1613, 1615, 7, 459, 2, 2, 1614, 1613, 3, 2, 2,
	2, 1614, 1615, 3, 2, 2, 2, 1615, 1617, 3, 2, 2, 2, 1616, 1618, 7, 256,
	2, 2, 1617, 1616, 3, 2, 2, 2, 1617, 1618, 3, 2, 2, 2, 1618, 1619, 3, 2,
	2, 2, 1619, 1621, 5, 1048, 525, 2, 1620, 1612, 3, 2, 2, 2, 1620, 1621,
	3, 2, 2, 2, 1621, 1641, 3, 2, 2, 2, 1622, 1624, 7, 326, 2, 2, 1623, 1625,
	7, 459, 2, 2, 1624, 1623, 3, 2, 2, 2, 1624, 1625, 3, 2, 2, 2, 1625, 1627,
	3, 2, 2, 2, 1626, 1628, 7, 256, 2, 2, 1627, 1626, 3, 2, 2, 2, 1627, 1628,
	3, 2, 2, 2, 1628, 1629, 3, 2, 2, 2, 1629, 1638, 5, 1048, 525, 2, 1630,
	1632, 7, 328, 2, 2, 1631, 1633, 7, 459, 2, 2, 1632, 1631, 3, 2, 2, 2, 1632,
	1633, 3, 2, 2, 2, 1633, 1635, 3, 2, 2, 2, 1634, 1636, 7, 256, 2, 2, 1635,
	1634, 3, 2, 2, 2, 1635, 1636, 3, 2, 2, 2, 1636, 1637, 3, 2, 2, 2, 1637,
	1639, 5, 1048, 525, 2, 1638, 1630, 3, 2, 2, 2, 1638, 1639, 3, 2, 2, 2,
	1639, 1641, 3, 2, 2, 2, 1640, 1604, 3, 2, 2, 2, 1640, 1622, 3, 2, 2, 2,
	1641, 93, 3, 2, 2, 2, 1642, 1644, 7, 324, 2, 2, 1643, 1645, 7, 256, 2,
	2, 1644, 1643, 3, 2, 2, 2, 1644, 1645, 3, 2, 2, 2, 1645, 1646, 3, 2, 2,
	2, 1646, 1647, 5, 1148, 575, 2, 1647, 95, 3, 2, 2, 2, 1648, 1650, 7, 402,
	2, 2, 1649, 1651, 7, 517, 2, 2, 1650, 1649, 3, 2, 2, 2, 1650, 1651, 3,
	2, 2, 2, 1651, 1653, 3, 2, 2, 2, 1652, 1654, 7, 285, 2, 2, 1653, 1652,
	3, 2, 2, 2, 1653, 1654, 3, 2, 2, 2, 1654, 1656, 3, 2, 2, 2, 1655, 1657,
	7, 256, 2, 2, 1656, 1655, 3, 2, 2, 2, 1656, 1657, 3, 2, 2, 2, 1657, 1658,
	3, 2, 2, 2, 1658, 1660, 7, 310, 2, 2, 1659, 1661, 7, 56, 2, 2, 1660, 1659,
	3, 2, 2, 2, 1660, 1661, 3, 2, 2, 2, 1661, 97, 3, 2, 2, 2, 1662, 1664, 7,
	469, 2, 2, 1663, 1665, 7, 65, 2, 2, 1664, 1663, 3, 2, 2, 2, 1664, 1665,
	3, 2, 2, 2, 1665, 1670, 3, 2, 2, 2, 1666, 1668, 7, 214, 2, 2, 1667, 1666,
	3, 2, 2, 2, 1667, 1668, 3, 2, 2, 2, 1668, 1669, 3, 2, 2, 2, 1669, 1671,
	9, 7, 2, 2, 1670, 1667, 3, 2, 2, 2, 1670, 1671, 3, 2, 2, 2, 1671, 1673,
	3, 2, 2, 2, 1672, 1674, 5, 100, 51, 2, 1673, 1672, 3, 2, 2, 2, 1674, 1675,
	3, 2, 2, 2, 1675, 1673, 3, 2, 2, 2, 1675, 1676, 3, 2, 2, 2, 1676, 1679,
	3, 2, 2, 2, 1677, 1678, 7, 241, 2, 2, 1678, 1680, 5, 1116, 559, 2, 1679,
	1677, 3, 2, 2, 2, 1679, 1680, 3, 2, 2, 2, 1680, 99, 3, 2, 2, 2, 1681, 1683,
	5, 1168, 585, 2, 1682, 1681, 3, 2, 2, 2, 1683, 1684, 3, 2, 2, 2, 1684,
	1682, 3, 2, 2, 2, 1684, 1685, 3, 2, 2, 2, 1685, 1687, 3, 2, 2, 2, 1686,
	1688, 9, 10, 2, 2, 1687, 1686, 3, 2, 2, 2, 1687, 1688, 3, 2, 2, 2, 1688,
	1690, 3, 2, 2, 2, 1689, 1691, 5, 1180, 591, 2, 1690, 1689, 3, 2, 2, 2,
	1691, 1692, 3, 2, 2, 2, 1692, 1690, 3, 2, 2, 2, 1692, 1693, 3, 2, 2, 2,
	1693, 101, 3, 2, 2, 2, 1694, 1695, 7, 249, 2, 2, 1695, 1696, 7, 421, 2,
	2, 1696, 1700, 7, 536, 2, 2, 1697, 1699, 5, 104, 53, 2, 1698, 1697, 3,
	2, 2, 2, 1699, 1702, 3, 2, 2, 2, 1700, 1698, 3, 2, 2, 2, 1700, 1701, 3,
	2, 2, 2, 1701, 103, 3, 2, 2, 2, 1702, 1700, 3, 2, 2, 2, 1703, 1706, 5,
	106, 54, 2, 1704, 1706, 5, 136, 69, 2, 1705, 1703, 3, 2, 2, 2, 1705, 1704,
	3, 2, 2, 2, 1706, 105, 3, 2, 2, 2, 1707, 1714, 7, 209, 2, 2, 1708, 1710,
	7, 536, 2, 2, 1709, 1708, 3, 2, 2, 2, 1709, 1710, 3, 2, 2, 2, 1710, 1711,
	3, 2, 2, 2, 1711, 1713, 5, 108, 55, 2, 1712, 1709, 3, 2, 2, 2, 1713, 1716,
	3, 2, 2, 2, 1714, 1712, 3, 2, 2, 2, 1714, 1715, 3, 2, 2, 2, 1715, 1717,
	3, 2, 2, 2, 1716, 1714, 3, 2, 2, 2, 1717, 1718, 7, 536, 2, 2, 1718, 107,
	3, 2, 2, 2, 1719, 1723, 5, 110, 56, 2, 1720, 1722, 5, 112, 57, 2, 1721,
	1720, 3, 2, 2, 2, 1722, 1725, 3, 2, 2, 2, 1723, 1721, 3, 2, 2, 2, 1723,
	1724, 3, 2, 2, 2, 1724, 109, 3, 2, 2, 2, 1725, 1723, 3, 2, 2, 2, 1726,
	1728, 7, 426, 2, 2, 1727, 1729, 7, 330, 2, 2, 1728, 1727, 3, 2, 2, 2, 1728,
	1729, 3, 2, 2, 2, 1729, 1730, 3, 2, 2, 2, 1730, 1731, 5, 1136, 569, 2,
	1731, 111, 3, 2, 2, 2, 1732, 1744, 5, 114, 58, 2, 1733, 1744, 5, 116, 59,
	2, 1734, 1744, 5, 118, 60, 2, 1735, 1744, 5, 120, 61, 2, 1736, 1744, 5,
	122, 62, 2, 1737, 1744, 5, 124, 63, 2, 1738, 1744, 5, 126, 64, 2, 1739,
	1744, 5, 128, 65, 2, 1740, 1744, 5, 132, 67, 2, 1741, 1744, 5, 130, 66,
	2, 1742, 1744, 5, 134, 68, 2, 1743, 1732, 3, 2, 2, 2, 1743, 1733, 3, 2,
	2, 2, 1743, 1734, 3, 2, 2, 2, 1743, 1735, 3, 2, 2, 2, 1743, 1736, 3, 2,
	2, 2, 1743, 1737, 3, 2, 2, 2, 1743, 1738, 3, 2, 2, 2, 1743, 1739, 3, 2,
	2, 2, 1743, 1740, 3, 2, 2, 2, 1743, 1741, 3, 2, 2, 2, 1743, 1742, 3, 2,
	2, 2, 1744, 113, 3, 2, 2, 2, 1745, 1747, 7, 29, 2, 2, 1746, 1748, 7, 491,
	2, 2, 1747, 1746, 3, 2, 2, 2, 1747, 1748, 3, 2, 2, 2, 1748, 1760, 3, 2,
	2, 2, 1749, 1761, 7, 143, 2, 2, 1750, 1761, 7, 144, 2, 2, 1751, 1761, 7,
	262, 2, 2, 1752, 1761, 7, 354, 2, 2, 1753, 1761, 7, 355, 2, 2, 1754, 1761,
	7, 372, 2, 2, 1755, 1761, 7, 373, 2, 2, 1756, 1761, 7, 476, 2, 2, 1757,
	1761, 7, 512, 2, 2, 1758, 1761, 5, 1118, 560, 2, 1759, 1761, 5, 1174, 588,
	2, 1760, 1749, 3, 2, 2, 2, 1760, 1750, 3, 2, 2, 2, 1760, 1751, 3, 2, 2,
	2, 1760, 1752, 3, 2, 2, 2, 1760, 1753, 3, 2, 2, 2, 1760, 1754, 3, 2, 2,
	2, 1760, 1755, 3, 2, 2, 2, 1760, 1756, 3, 2, 2, 2, 1760, 1757, 3, 2, 2,
	2, 1760, 1758, 3, 2, 2, 2, 1760, 1759, 3, 2, 2, 2, 1761, 115, 3, 2, 2,
	2, 1762, 1765, 7, 402, 2, 2, 1763, 1766, 7, 312, 2, 2, 1764, 1766, 5, 1180,
	591, 2, 1765, 1763, 3, 2, 2, 2, 1765, 1764, 3, 2, 2, 2, 1766, 1768, 3,
	2, 2, 2, 1767, 1769, 7, 20, 2, 2, 1768, 1767, 3, 2, 2, 2, 1768, 1769, 3,
	2, 2, 2, 1769, 1771, 3, 2, 2, 2, 1770, 1772, 9, 11, 2, 2, 1771, 1770, 3,
	2, 2, 2, 1771, 1772, 3, 2, 2, 2, 1772, 117, 3, 2, 2, 2, 1773, 1775, 7,
	334, 2, 2, 1774, 1776, 7, 256, 2, 2, 1775, 1774, 3, 2, 2, 2, 1775, 1776,
	3, 2, 2, 2, 1776, 1778, 3, 2, 2, 2, 1777, 1773, 3, 2, 2, 2, 1777, 1778,
	3, 2, 2, 2, 1778, 1784, 3, 2, 2, 2, 1779, 1785, 7, 281, 2, 2, 1780, 1781,
	7, 379, 2, 2, 1781, 1785, 7, 44, 2, 2, 1782, 1785, 7, 379, 2, 2, 1783,
	1785, 7, 44, 2, 2, 1784, 1779, 3, 2, 2, 2, 1784, 1780, 3, 2, 2, 2, 1784,
	1782, 3, 2, 2, 2, 1784, 1783, 3, 2, 2, 2, 1784, 1785, 3, 2, 2, 2, 1785,
	1786, 3, 2, 2, 2, 1786, 1787, 9, 12, 2, 2, 1787, 119, 3, 2, 2, 2, 1788,
	1790, 7, 341, 2, 2, 1789, 1791, 7, 64, 2, 2, 1790, 1789, 3, 2, 2, 2, 1790,
	1791, 3, 2, 2, 2, 1791, 1793, 3, 2, 2, 2, 1792, 1794, 7, 256, 2, 2, 1793,
	1792, 3, 2, 2, 2, 1793, 1794, 3, 2, 2, 2, 1794, 1797, 3, 2, 2, 2, 1795,
	1798, 5, 1092, 547, 2, 1796, 1798, 5, 1174, 588, 2, 1797, 1795, 3, 2, 2,
	2, 1797, 1796, 3, 2, 2, 2, 1798, 121, 3, 2, 2, 2, 1799, 1800, 7, 379, 2,
	2, 1800, 1802, 7, 135, 2, 2, 1801, 1803, 7, 256, 2, 2, 1802, 1801, 3, 2,
	2, 2, 1802, 1803, 3, 2, 2, 2, 1803, 1807, 3, 2, 2, 2, 1804, 1808, 7, 456,
	2, 2, 1805, 1808, 7, 239, 2, 2, 1806, 1808, 5, 1118, 560, 2, 1807, 1804,
	3, 2, 2, 2, 1807, 1805, 3, 2, 2, 2, 1807, 1806, 3, 2, 2, 2, 1808, 123,
	3, 2, 2, 2, 1809, 1811, 7, 5, 2, 2, 1810, 1812, 7, 299, 2, 2, 1811, 1810,
	3, 2, 2, 2, 1811, 1812, 3, 2, 2, 2, 1812, 1814, 3, 2, 2, 2, 1813, 1815,
	7, 256, 2, 2, 1814, 1813, 3, 2, 2, 2, 1814, 1815, 3, 2, 2, 2, 1815, 1816,
	3, 2, 2, 2, 1816, 1817, 9, 13, 2, 2, 1817, 125, 3, 2, 2, 2, 1818, 1820,
	7, 379, 2, 2, 1819, 1821, 7, 261, 2, 2, 1820, 1819, 3, 2, 2, 2, 1820, 1821,
	3, 2, 2, 2, 1821, 1823, 3, 2, 2, 2, 1822, 1824, 7, 256, 2, 2, 1823, 1822,
	3, 2, 2, 2, 1823, 1824, 3, 2, 2, 2, 1824, 1825, 3, 2, 2, 2, 1825, 1827,
	5, 1092, 547, 2, 1826, 1828, 5, 130, 66, 2, 1827, 1826, 3, 2, 2, 2, 1827,
	1828, 3, 2, 2, 2, 1828, 1833, 3, 2, 2, 2, 1829, 1831, 7, 516, 2, 2, 1830,
	1829, 3, 2, 2, 2, 1830, 1831, 3, 2, 2, 2, 1831, 1832, 3, 2, 2, 2, 1832,
	1834, 7, 151, 2, 2, 1833, 1830, 3, 2, 2, 2, 1833, 1834, 3, 2, 2, 2, 1834,
	127, 3, 2, 2, 2, 1835, 1836, 7, 20, 2, 2, 1836, 1838, 7, 379, 2, 2, 1837,
	1839, 7, 261, 2, 2, 1838, 1837, 3, 2, 2, 2, 1838, 1839, 3, 2, 2, 2, 1839,
	1841, 3, 2, 2, 2, 1840, 1842, 7, 256, 2, 2, 1841, 1840, 3, 2, 2, 2, 1841,
	1842, 3, 2, 2, 2, 1842, 1843, 3, 2, 2, 2, 1843, 1845, 5, 1092, 547, 2,
	1844, 1846, 5, 130, 66, 2, 1845, 1844, 3, 2, 2, 2, 1845, 1846, 3, 2, 2,
	2, 1846, 1851, 3, 2, 2, 2, 1847, 1849, 7, 516, 2, 2, 1848, 1847, 3, 2,
	2, 2, 1848, 1849, 3, 2, 2, 2, 1849, 1850, 3, 2, 2, 2, 1850, 1852, 7, 151,
	2, 2, 1851, 1848, 3, 2, 2, 2, 1851, 1852, 3, 2, 2, 2, 1852, 129, 3, 2,
	2, 2, 1853, 1855, 7, 344, 2, 2, 1854, 1856, 7, 256, 2, 2, 1855, 1854, 3,
	2, 2, 2, 1855, 1856, 3, 2, 2, 2, 1856, 1857, 3, 2, 2, 2, 1857, 1858, 5,
	1130, 566, 2, 1858, 131, 3, 2, 2, 2, 1859, 1861, 7, 208, 2, 2, 1860, 1859,
	3, 2, 2, 2, 1860, 1861, 3, 2, 2, 2, 1861, 1862, 3, 2, 2, 2, 1862, 1864,
	7, 459, 2, 2, 1863, 1865, 7, 256, 2, 2, 1864, 1863, 3, 2, 2, 2, 1864, 1865,
	3, 2, 2, 2, 1865, 1866, 3, 2, 2, 2, 1866, 1868, 5, 1092, 547, 2, 1867,
	1869, 5, 1092, 547, 2, 1868, 1867, 3, 2, 2, 2, 1868, 1869, 3, 2, 2, 2,
	1869, 133, 3, 2, 2, 2, 1870, 1872, 7, 388, 2, 2, 1871, 1873, 7, 261, 2,
	2, 1872, 1871, 3, 2, 2, 2, 1872, 1873, 3, 2, 2, 2, 1873, 1875, 3, 2, 2,
	2, 1874, 1876, 7, 256, 2, 2, 1875, 1874, 3, 2, 2, 2, 1875, 1876, 3, 2,
	2, 2, 1876, 1877, 3, 2, 2, 2, 1877, 1878, 5, 1092, 547, 2, 1878, 135, 3,
	2, 2, 2, 1879, 1880, 7, 235, 2, 2, 1880, 1884, 7, 536, 2, 2, 1881, 1882,
	5, 1136, 569, 2, 1882, 1883, 7, 536, 2, 2, 1883, 1885, 3, 2, 2, 2, 1884,
	1881, 3, 2, 2, 2, 1884, 1885, 3, 2, 2, 2, 1885, 1893, 3, 2, 2, 2, 1886,
	1888, 5, 138, 70, 2, 1887, 1886, 3, 2, 2, 2, 1888, 1891, 3, 2, 2, 2, 1889,
	1887, 3, 2, 2, 2, 1889, 1890, 3, 2, 2, 2, 1890, 1892, 3, 2, 2, 2, 1891,
	1889, 3, 2, 2, 2, 1892, 1894, 7, 536, 2, 2, 1893, 1889, 3, 2, 2, 2, 1893,
	1894, 3, 2, 2, 2, 1894, 137, 3, 2, 2, 2, 1895, 1900, 5, 140, 71, 2, 1896,
	1900, 5, 148, 75, 2, 1897, 1900, 5, 150, 76, 2, 1898, 1900, 5, 154, 78,
	2, 1899, 1895, 3, 2, 2, 2, 1899, 1896, 3, 2, 2, 2, 1899, 1897, 3, 2, 2,
	2, 1899, 1898, 3, 2, 2, 2, 1900, 139, 3, 2, 2, 2, 1901, 1907, 7, 401, 2,
	2, 1902, 1905, 7, 328, 2, 2, 1903, 1906, 5, 1118, 560, 2, 1904, 1906, 5,
	1136, 569, 2, 1905, 1903, 3, 2, 2, 2, 1905, 1904, 3, 2, 2, 2, 1906, 1908,
	3, 2, 2, 2, 1907, 1902, 3, 2, 2, 2, 1907, 1908, 3, 2, 2, 2, 1908, 1909,
	3, 2, 2, 2, 1909, 1913, 7, 197, 2, 2, 1910, 1914, 5, 142, 72, 2, 1911,
	1914, 5, 144, 73, 2, 1912, 1914, 5, 146, 74, 2, 1913, 1910, 3, 2, 2, 2,
	1913, 1911, 3, 2, 2, 2, 1913, 1912, 3, 2, 2, 2, 1914, 141, 3, 2, 2, 2,
	1915, 1916, 5, 1180, 591, 2, 1916, 1917, 7, 381, 2, 2, 1917, 143, 3, 2,
	2, 2, 1918, 1920, 7, 160, 2, 2, 1919, 1918, 3, 2, 2, 2, 1919, 1920, 3,
	2, 2, 2, 1920, 1922, 3, 2, 2, 2, 1921, 1923, 7, 325, 2, 2, 1922, 1921,
	3, 2, 2, 2, 1922, 1923, 3, 2, 2, 2, 1923, 1924, 3, 2, 2, 2, 1924, 1925,
	9, 14, 2, 2, 1925, 1926, 7, 325, 2, 2, 1926, 1927, 5, 1136, 569, 2, 1927,
	145, 3, 2, 2, 2, 1928, 1930, 5, 1180, 591, 2, 1929, 1931, 7, 68, 2, 2,
	1930, 1929, 3, 2, 2, 2, 1930, 1931, 3, 2, 2, 2, 1931, 147, 3, 2, 2, 2,
	1932, 1934, 7, 416, 2, 2, 1933, 1935, 9, 15, 2, 2, 1934, 1933, 3, 2, 2,
	2, 1934, 1935, 3, 2, 2, 2, 1935, 1937, 3, 2, 2, 2, 1936, 1938, 7, 24, 2,
	2, 1937, 1936, 3, 2, 2, 2, 1937, 1938, 3, 2, 2, 2, 1938, 1940, 3, 2, 2,
	2, 1939, 1941, 7, 214, 2, 2, 1940, 1939, 3, 2, 2, 2, 1940, 1941, 3, 2,
	2, 2, 1941, 1943, 3, 2, 2, 2, 1942, 1944, 5, 1136, 569, 2, 1943, 1942,
	3, 2, 2, 2, 1944, 1945, 3, 2, 2, 2, 1945, 1943, 3, 2, 2, 2, 1945, 1946,
	3, 2, 2, 2, 1946, 149, 3, 2, 2, 2, 1947, 1948, 7, 303, 2, 2, 1948, 1950,
	7, 208, 2, 2, 1949, 1951, 7, 476, 2, 2, 1950, 1949, 3, 2, 2, 2, 1950, 1951,
	3, 2, 2, 2, 1951, 1953, 3, 2, 2, 2, 1952, 1954, 7, 96, 2, 2, 1953, 1952,
	3, 2, 2, 2, 1953, 1954, 3, 2, 2, 2, 1954, 1956, 3, 2, 2, 2, 1955, 1957,
	5, 152, 77, 2, 1956, 1955, 3, 2, 2, 2, 1957, 1958, 3, 2, 2, 2, 1958, 1956,
	3, 2, 2, 2, 1958, 1959, 3, 2, 2, 2, 1959, 151, 3, 2, 2, 2, 1960, 1963,
	5, 1136, 569, 2, 1961, 1962, 7, 352, 2, 2, 1962, 1964, 5, 1180, 591, 2,
	1963, 1961, 3, 2, 2, 2, 1963, 1964, 3, 2, 2, 2, 1964, 153, 3, 2, 2, 2,
	1965, 1966, 7, 79, 2, 2, 1966, 1968, 7, 99, 2, 2, 1967, 1969, 7, 214, 2,
	2, 1968, 1967, 3, 2, 2, 2, 1968, 1969, 3, 2, 2, 2, 1969, 1970, 3, 2, 2,
	2, 1970, 1971, 5, 1136, 569, 2, 1971, 155, 3, 2, 2, 2, 1972, 1973, 7, 111,
	2, 2, 1973, 1974, 7, 147, 2, 2, 1974, 1978, 7, 536, 2, 2, 1975, 1977, 5,
	158, 80, 2, 1976, 1975, 3, 2, 2, 2, 1977, 1980, 3, 2, 2, 2, 1978, 1976,
	3, 2, 2, 2, 1978, 1979, 3, 2, 2, 2, 1979, 157, 3, 2, 2, 2, 1980, 1978,
	3, 2, 2, 2, 1981, 1991, 5, 160, 81, 2, 1982, 1991, 5, 210, 106, 2, 1983,
	1991, 5, 214, 108, 2, 1984, 1991, 5, 216, 109, 2, 1985, 1991, 5, 218, 110,
	2, 1986, 1991, 5, 256, 129, 2, 1987, 1991, 5, 258, 130, 2, 1988, 1991,
	5, 322, 162, 2, 1989, 1991, 5, 398, 200, 2, 1990, 1981, 3, 2, 2, 2, 1990,
	1982, 3, 2, 2, 2, 1990, 1983, 3, 2, 2, 2, 1990, 1984, 3, 2, 2, 2, 1990,
	1985, 3, 2, 2, 2, 1990, 1986, 3, 2, 2, 2, 1990, 1987, 3, 2, 2, 2, 1990,
	1988, 3, 2, 2, 2, 1990, 1989, 3, 2, 2, 2, 1991, 159, 3, 2, 2, 2, 1992,
	1993, 7, 208, 2, 2, 1993, 1994, 7, 421, 2, 2, 1994, 1998, 7, 536, 2, 2,
	1995, 1997, 5, 162, 82, 2, 1996, 1995, 3, 2, 2, 2, 1997, 2000, 3, 2, 2,
	2, 1998, 1996, 3, 2, 2, 2, 1998, 1999, 3, 2, 2, 2, 1999, 161, 3, 2, 2,
	2, 2000, 1998, 3, 2, 2, 2, 2001, 2002, 9, 16, 2, 2, 2002, 2009, 5, 1136,
	569, 2, 2003, 2005, 7, 536, 2, 2, 2004, 2003, 3, 2, 2, 2, 2004, 2005, 3,
	2, 2, 2, 2005, 2006, 3, 2, 2, 2, 2006, 2008, 5, 164, 83, 2, 2007, 2004,
	3, 2, 2, 2, 2008, 2011, 3, 2, 2, 2, 2009, 2007, 3, 2, 2, 2, 2009, 2010,
	3, 2, 2, 2, 2010, 2012, 3, 2, 2, 2, 2011, 2009, 3, 2, 2, 2, 2012, 2016,
	7, 536, 2, 2, 2013, 2015, 5, 436, 219, 2, 2014, 2013, 3, 2, 2, 2, 2015,
	2018, 3, 2, 2, 2, 2016, 2014, 3, 2, 2, 2, 2016, 2017, 3, 2, 2, 2, 2017,
	163, 3, 2, 2, 2, 2018, 2016, 3, 2, 2, 2, 2019, 2031, 5, 166, 84, 2, 2020,
	2031, 5, 168, 85, 2, 2021, 2031, 5, 170, 86, 2, 2022, 2031, 5, 174, 88,
	2, 2023, 2031, 5, 184, 93, 2, 2024, 2031, 5, 186, 94, 2, 2025, 2031, 5,
	190, 96, 2, 2026, 2031, 5, 192, 97, 2, 2027, 2031, 5, 206, 104, 2, 2028,
	2031, 5, 208, 105, 2, 2029, 2031, 5, 202, 102, 2, 2030, 2019, 3, 2, 2,
	2, 2030, 2020, 3, 2, 2, 2, 2030, 2021, 3, 2, 2, 2, 2030, 2022, 3, 2, 2,
	2, 2030, 2023, 3, 2, 2, 2, 2030, 2024, 3, 2, 2, 2, 2030, 2025, 3, 2, 2,
	2, 2030, 2026, 3, 2, 2, 2, 2030, 2027, 3, 2, 2, 2, 2030, 2028, 3, 2, 2,
	2, 2030, 2029, 3, 2, 2, 2, 2031, 165, 3, 2, 2, 2, 2032, 2034, 7, 256, 2,
	2, 2033, 2032, 3, 2, 2, 2, 2033, 2034, 3, 2, 2, 2, 2034, 2035, 3, 2, 2,
	2, 2035, 2036, 7, 205, 2, 2, 2036, 167, 3, 2, 2, 2, 2037, 2039, 7, 256,
	2, 2, 2038, 2037, 3, 2, 2, 2, 2038, 2039, 3, 2, 2, 2, 2039, 2040, 3, 2,
	2, 2, 2040, 2041, 7, 225, 2, 2, 2041, 169, 3, 2, 2, 2, 2042, 2044, 7, 48,
	2, 2, 2043, 2045, 7, 96, 2, 2, 2044, 2043, 3, 2, 2, 2, 2044, 2045, 3, 2,
	2, 2, 2045, 2046, 3, 2, 2, 2, 2046, 2048, 5, 1180, 591, 2, 2047, 2049,
	5, 172, 87, 2, 2048, 2047, 3, 2, 2, 2, 2048, 2049, 3, 2, 2, 2, 2049, 2051,
	3, 2, 2, 2, 2050, 2052, 9, 17, 2, 2, 2051, 2050, 3, 2, 2, 2, 2051, 2052,
	3, 2, 2, 2, 2052, 171, 3, 2, 2, 2, 2053, 2054, 7, 491, 2, 2, 2054, 2055,
	5, 1180, 591, 2, 2055, 173, 3, 2, 2, 2, 2056, 2060, 7, 379, 2, 2, 2057,
	2061, 5, 176, 89, 2, 2058, 2061, 5, 178, 90, 2, 2059, 2061, 5, 180, 91,
	2, 2060, 2057, 3, 2, 2, 2, 2060, 2058, 3, 2, 2, 2, 2060, 2059, 3, 2, 2,
	2, 2061, 175, 3, 2, 2, 2, 2062, 2064, 7, 96, 2, 2, 2063, 2062, 3, 2, 2,
	2, 2063, 2064, 3, 2, 2, 2, 2064, 2065, 3, 2, 2, 2, 2065, 2067, 5, 1180,
	591, 2, 2066, 2068, 7, 65, 2, 2, 2067, 2066, 3, 2, 2, 2, 2067, 2068, 3,
	2, 2, 2, 2068, 177, 3, 2, 2, 2, 2069, 2071, 7, 256, 2, 2, 2070, 2069, 3,
	2, 2, 2, 2070, 2071, 3, 2, 2, 2, 2071, 2072, 3, 2, 2, 2, 2072, 2074, 7,
	511, 2, 2, 2073, 2075, 7, 241, 2, 2, 2074, 2073, 3, 2, 2, 2, 2074, 2075,
	3, 2, 2, 2, 2075, 2077, 3, 2, 2, 2, 2076, 2078, 7, 441, 2, 2, 2077, 2076,
	3, 2, 2, 2, 2077, 2078, 3, 2, 2, 2, 2078, 2089, 3, 2, 2, 2, 2079, 2081,
	7, 217, 2, 2, 2080, 2079, 3, 2, 2, 2, 2080, 2081, 3, 2, 2, 2, 2081, 2082,
	3, 2, 2, 2, 2082, 2084, 5, 1180, 591, 2, 2083, 2085, 5, 182, 92, 2, 2084,
	2083, 3, 2, 2, 2, 2084, 2085, 3, 2, 2, 2, 2085, 2087, 3, 2, 2, 2, 2086,
	2088, 7, 65, 2, 2, 2087, 2086, 3, 2, 2, 2, 2087, 2088, 3, 2, 2, 2, 2088,
	2090, 3, 2, 2, 2, 2089, 2080, 3, 2, 2, 2, 2089, 2090, 3, 2, 2, 2, 2090,
	2096, 3, 2, 2, 2, 2091, 2093, 7, 136, 2, 2, 2092, 2094, 7, 328, 2, 2, 2093,
	2092, 3, 2, 2, 2, 2093, 2094, 3, 2, 2, 2, 2094, 2095, 3, 2, 2, 2, 2095,
	2097, 5, 1092, 547, 2, 2096, 2091, 3, 2, 2, 2, 2096, 2097, 3, 2, 2, 2,
	2097, 179, 3, 2, 2, 2, 2098, 2100, 7, 96, 2, 2, 2099, 2098, 3, 2, 2, 2,
	2099, 2100, 3, 2, 2, 2, 2100, 2101, 3, 2, 2, 2, 2101, 2102, 5, 1180, 591,
	2, 2102, 2104, 5, 182, 92, 2, 2103, 2105, 7, 65, 2, 2, 2104, 2103, 3, 2,
	2, 2, 2104, 2105, 3, 2, 2, 2, 2105, 181, 3, 2, 2, 2, 2106, 2107, 7, 491,
	2, 2, 2107, 2108, 5, 1180, 591, 2, 2108, 183, 3, 2, 2, 2, 2109, 2118, 7,
	263, 2, 2, 2110, 2112, 7, 379, 2, 2, 2111, 2113, 7, 256, 2, 2, 2112, 2111,
	3, 2, 2, 2, 2112, 2113, 3, 2, 2, 2, 2113, 2119, 3, 2, 2, 2, 2114, 2116,
	7, 381, 2, 2, 2115, 2117, 7, 23, 2, 2, 2116, 2115, 3, 2, 2, 2, 2116, 2117,
	3, 2, 2, 2, 2117, 2119, 3, 2, 2, 2, 2118, 2110, 3, 2, 2, 2, 2118, 2114,
	3, 2, 2, 2, 2119, 2127, 3, 2, 2, 2, 2120, 2128, 7, 327, 2, 2, 2121, 2128,
	7, 455, 2, 2, 2122, 2124, 5, 1130, 566, 2, 2123, 2122, 3, 2, 2, 2, 2124,
	2125, 3, 2, 2, 2, 2125, 2123, 3, 2, 2, 2, 2125, 2126, 3, 2, 2, 2, 2126,
	2128, 3, 2, 2, 2, 2127, 2120, 3, 2, 2, 2, 2127, 2121, 3, 2, 2, 2, 2127,
	2123, 3, 2, 2, 2, 2128, 185, 3, 2, 2, 2, 2129, 2130, 7, 509, 2, 2, 2130,
	2132, 7, 325, 2, 2, 2131, 2133, 5, 188, 95, 2, 2132, 2131, 3, 2, 2, 2,
	2133, 2134, 3, 2, 2, 2, 2134, 2132, 3, 2, 2, 2, 2134, 2135, 3, 2, 2, 2,
	2135, 187, 3, 2, 2, 2, 2136, 2138, 5, 1166, 584, 2, 2137, 2139, 7, 256,
	2, 2, 2138, 2137, 3, 2, 2, 2, 2138, 2139, 3, 2, 2, 2, 2139, 2142, 3, 2,
	2, 2, 2140, 2143, 5, 1092, 547, 2, 2141, 2143, 5, 1174, 588, 2, 2142, 2140,
	3, 2, 2, 2, 2142, 2141, 3, 2, 2, 2, 2143, 189, 3, 2, 2, 2, 2144, 2153,
	7, 111, 2, 2, 2145, 2147, 7, 379, 2, 2, 2146, 2148, 7, 256, 2, 2, 2147,
	2146, 3, 2, 2, 2, 2147, 2148, 3, 2, 2, 2, 2148, 2154, 3, 2, 2, 2, 2149,
	2151, 7, 381, 2, 2, 2150, 2152, 7, 23, 2, 2, 2151, 2150, 3, 2, 2, 2, 2151,
	2152, 3, 2, 2, 2, 2152, 2154, 3, 2, 2, 2, 2153, 2145, 3, 2, 2, 2, 2153,
	2149, 3, 2, 2, 2, 2154, 2156, 3, 2, 2, 2, 2155, 2157, 5, 1130, 566, 2,
	2156, 2155, 3, 2, 2, 2, 2157, 2158, 3, 2, 2, 2, 2158, 2156, 3, 2, 2, 2,
	2158, 2159, 3, 2, 2, 2, 2159, 191, 3, 2, 2, 2, 2160, 2162, 7, 279, 2, 2,
	2161, 2163, 7, 256, 2, 2, 2162, 2161, 3, 2, 2, 2, 2162, 2163, 3, 2, 2,
	2, 2163, 2166, 3, 2, 2, 2, 2164, 2167, 5, 1130, 566, 2, 2165, 2167, 5,
	1180, 591, 2, 2166, 2164, 3, 2, 2, 2, 2166, 2165, 3, 2, 2, 2, 2167, 2169,
	3, 2, 2, 2, 2168, 2170, 7, 282, 2, 2, 2169, 2168, 3, 2, 2, 2, 2169, 2170,
	3, 2, 2, 2, 2170, 2174, 3, 2, 2, 2, 2171, 2173, 5, 194, 98, 2, 2172, 2171,
	3, 2, 2, 2, 2173, 2176, 3, 2, 2, 2, 2174, 2172, 3, 2, 2, 2, 2174, 2175,
	3, 2, 2, 2, 2175, 193, 3, 2, 2, 2, 2176, 2174, 3, 2, 2, 2, 2177, 2181,
	5, 196, 99, 2, 2178, 2181, 5, 198, 100, 2, 2179, 2181, 5, 200, 101, 2,
	2180, 2177, 3, 2, 2, 2, 2180, 2178, 3, 2, 2, 2, 2180, 2179, 3, 2, 2, 2,
	2181, 195, 3, 2, 2, 2, 2182, 2184, 7, 516, 2, 2, 2183, 2182, 3, 2, 2, 2,
	2183, 2184, 3, 2, 2, 2, 2184, 2185, 3, 2, 2, 2, 2185, 2187, 7, 213, 2,
	2, 2186, 2188, 7, 32, 2, 2, 2187, 2186, 3, 2, 2, 2, 2187, 2188, 3, 2, 2,
	2, 2188, 2191, 3, 2, 2, 2, 2189, 2192, 5, 1130, 566, 2, 2190, 2192, 5,
	1180, 591, 2, 2191, 2189, 3, 2, 2, 2, 2191, 2190, 3, 2, 2, 2, 2192, 197,
	3, 2, 2, 2, 2193, 2195, 7, 282, 2, 2, 2194, 2193, 3, 2, 2, 2, 2194, 2195,
	3, 2, 2, 2, 2195, 2197, 3, 2, 2, 2, 2196, 2198, 7, 32, 2, 2, 2197, 2196,
	3, 2, 2, 2, 2197, 2198, 3, 2, 2, 2, 2198, 2199, 3, 2, 2, 2, 2199, 2202,
	7, 494, 2, 2, 2200, 2203, 5, 1130, 566, 2, 2201, 2203, 5, 1180, 591, 2,
	2202, 2200, 3, 2, 2, 2, 2202, 2201, 3, 2, 2, 2, 2203, 199, 3, 2, 2, 2,
	2204, 2206, 7, 282, 2, 2, 2205, 2204, 3, 2, 2, 2, 2205, 2206, 3, 2, 2,
	2, 2206, 2208, 3, 2, 2, 2, 2207, 2209, 7, 32, 2, 2, 2208, 2207, 3, 2, 2,
	2, 2208, 2209, 3, 2, 2, 2, 2209, 2210, 3, 2, 2, 2, 2210, 2213, 7, 50, 2,
	2, 2211, 2214, 5, 1130, 566, 2, 2212, 2214, 5, 1180, 591, 2, 2213, 2211,
	3, 2, 2, 2, 2213, 2212, 3, 2, 2, 2, 2214, 201, 3, 2, 2, 2, 2215, 2217,
	7, 380, 2, 2, 2216, 2218, 7, 299, 2, 2, 2217, 2216, 3, 2, 2, 2, 2217, 2218,
	3, 2, 2, 2, 2218, 2220, 3, 2, 2, 2, 2219, 2221, 7, 256, 2, 2, 2220, 2219,
	3, 2, 2, 2, 2220, 2221, 3, 2, 2, 2, 2221, 2222, 3, 2, 2, 2, 2222, 2223,
	5, 204, 103, 2, 2223, 203, 3, 2, 2, 2, 2224, 2225, 5, 1172, 587, 2, 2225,
	205, 3, 2, 2, 2, 2226, 2228, 7, 73, 2, 2, 2227, 2229, 7, 256, 2, 2, 2228,
	2227, 3, 2, 2, 2, 2228, 2229, 3, 2, 2, 2, 2229, 2230, 3, 2, 2, 2, 2230,
	2231, 5, 1116, 559, 2, 2231, 207, 3, 2, 2, 2, 2232, 2234, 7, 397, 2, 2,
	2233, 2235, 7, 256, 2, 2, 2234, 2233, 3, 2, 2, 2, 2234, 2235, 3, 2, 2,
	2, 2235, 2241, 3, 2, 2, 2, 2236, 2238, 7, 399, 2, 2, 2237, 2239, 7, 23,
	2, 2, 2238, 2237, 3, 2, 2, 2, 2238, 2239, 3, 2, 2, 2, 2239, 2241, 3, 2,
	2, 2, 2240, 2232, 3, 2, 2, 2, 2240, 2236, 3, 2, 2, 2, 2241, 2243, 3, 2,
	2, 2, 2242, 2244, 5, 1158, 580, 2, 2243, 2242, 3, 2, 2, 2, 2244, 2245,
	3, 2, 2, 2, 2245, 2243, 3, 2, 2, 2, 2245, 2246, 3, 2, 2, 2, 2246, 209,
	3, 2, 2, 2, 2247, 2248, 7, 112, 2, 2, 2248, 2249, 7, 421, 2, 2, 2249, 2253,
	7, 536, 2, 2, 2250, 2252, 5, 212, 107, 2, 2251, 2250, 3, 2, 2, 2, 2252,
	2255, 3, 2, 2, 2, 2253, 2251, 3, 2, 2, 2, 2253, 2254, 3, 2, 2, 2, 2254,
	211, 3, 2, 2, 2, 2255, 2253, 3, 2, 2, 2, 2256, 2257, 5, 1180, 591, 2, 2257,
	2258, 5, 1174, 588, 2, 2258, 2259, 7, 255, 2, 2, 2259, 2260, 5, 1174, 588,
	2, 2260, 213, 3, 2, 2, 2, 2261, 2262, 7, 518, 2, 2, 2262, 2263, 7, 421,
	2, 2, 2263, 2267, 7, 536, 2, 2, 2264, 2266, 5, 436, 219, 2, 2265, 2264,
	3, 2, 2, 2, 2266, 2269, 3, 2, 2, 2, 2267, 2265, 3, 2, 2, 2, 2267, 2268,
	3, 2, 2, 2, 2268, 215, 3, 2, 2, 2, 2269, 2267, 3, 2, 2, 2, 2270, 2271,
	7, 284, 2, 2, 2271, 2272, 7, 421, 2, 2, 2272, 2276, 7, 536, 2, 2, 2273,
	2275, 5, 436, 219, 2, 2274, 2273, 3, 2, 2, 2, 2275, 2278, 3, 2, 2, 2, 2276,
	2274, 3, 2, 2, 2, 2276, 2277, 3, 2, 2, 2, 2277, 217, 3, 2, 2, 2, 2278,
	2276, 3, 2, 2, 2, 2279, 2280, 7, 81, 2, 2, 2280, 2281, 7, 421, 2, 2, 2281,
	2286, 7, 536, 2, 2, 2282, 2285, 5, 220, 111, 2, 2283, 2285, 5, 436, 219,
	2, 2284, 2282, 3, 2, 2, 2, 2284, 2283, 3, 2, 2, 2, 2285, 2288, 3, 2, 2,
	2, 2286, 2284, 3, 2, 2, 2, 2286, 2287, 3, 2, 2, 2, 2287, 219, 3, 2, 2,
	2, 2288, 2286, 3, 2, 2, 2, 2289, 2293, 5, 222, 112, 2, 2290, 2293, 5, 224,
	113, 2, 2291, 2293, 5, 226, 114, 2, 2292, 2289, 3, 2, 2, 2, 2292, 2290,
	3, 2, 2, 2, 2292, 2291, 3, 2, 2, 2, 2293, 221, 3, 2, 2, 2, 2294, 2295,
	7, 58, 2, 2, 2295, 2297, 5, 1122, 562, 2, 2296, 2298, 7, 214, 2, 2, 2297,
	2296, 3, 2, 2, 2, 2297, 2298, 3, 2, 2, 2, 2298, 2300, 3, 2, 2, 2, 2299,
	2301, 7, 245, 2, 2, 2300, 2299, 3, 2, 2, 2, 2300, 2301, 3, 2, 2, 2, 2301,
	2302, 3, 2, 2, 2, 2302, 2317, 7, 248, 2, 2, 2303, 2313, 5, 246, 124, 2,
	2304, 2313, 5, 252, 127, 2, 2305, 2313, 5, 238, 120, 2, 2306, 2313, 5,
	240, 121, 2, 2307, 2313, 5, 248, 125, 2, 2308, 2313, 5, 254, 128, 2, 2309,
	2313, 5, 232, 117, 2, 2310, 2313, 5, 242, 122, 2, 2311, 2313, 5, 236, 119,
	2, 2312, 2303, 3, 2, 2, 2, 2312, 2304, 3, 2, 2, 2, 2312, 2305, 3, 2, 2,
	2, 2312, 2306, 3, 2, 2, 2, 2312, 2307, 3, 2, 2, 2, 2312, 2308, 3, 2, 2,
	2, 2312, 2309, 3, 2, 2, 2, 2312, 2310, 3, 2, 2, 2, 2312, 2311, 3, 2, 2,
	2, 2313, 2316, 3, 2, 2, 2, 2314, 2316, 5, 1132, 567, 2, 2315, 2312, 3,
	2, 2, 2, 2315, 2314, 3, 2, 2, 2, 2316, 2319, 3, 2, 2, 2, 2317, 2315, 3,
	2, 2, 2, 2317, 2318, 3, 2, 2, 2, 2318, 2320, 3, 2, 2, 2, 2319, 2317, 3,
	2, 2, 2, 2320, 2321, 7, 536, 2, 2, 2321, 223, 3, 2, 2, 2, 2322, 2323, 7,
	58, 2, 2, 2323, 2325, 5, 1122, 562, 2, 2324, 2326, 7, 214, 2, 2, 2325,
	2324, 3, 2, 2, 2, 2325, 2326, 3, 2, 2, 2, 2326, 2327, 3, 2, 2, 2, 2327,
	2336, 7, 336, 2, 2, 2328, 2335, 5, 228, 115, 2, 2329, 2335, 5, 254, 128,
	2, 2330, 2335, 5, 242, 122, 2, 2331, 2335, 5, 230, 116, 2, 2332, 2335,
	5, 234, 118, 2, 2333, 2335, 5, 244, 123, 2, 2334, 2328, 3, 2, 2, 2, 2334,
	2329, 3, 2, 2, 2, 2334, 2330, 3, 2, 2, 2, 2334, 2331, 3, 2, 2, 2, 2334,
	2332, 3, 2, 2, 2, 2334, 2333, 3, 2, 2, 2, 2335, 2338, 3, 2, 2, 2, 2336,
	2334, 3, 2, 2, 2, 2336, 2337, 3, 2, 2, 2, 2337, 2339, 3, 2, 2, 2, 2338,
	2336, 3, 2, 2, 2, 2339, 2340, 7, 536, 2, 2, 2340, 225, 3, 2, 2, 2, 2341,
	2342, 7, 58, 2, 2, 2342, 2344, 5, 1122, 562, 2, 2343, 2345, 7, 214, 2,
	2, 2344, 2343, 3, 2, 2, 2, 2344, 2345, 3, 2, 2, 2, 2345, 2346, 3, 2, 2,
	2, 2346, 2347, 7, 245, 2, 2, 2347, 2359, 7, 234, 2, 2, 2348, 2355, 5, 238,
	120, 2, 2349, 2355, 5, 240, 121, 2, 2350, 2355, 5, 250, 126, 2, 2351, 2355,
	5, 254, 128, 2, 2352, 2355, 5, 232, 117, 2, 2353, 2355, 5, 242, 122, 2,
	2354, 2348, 3, 2, 2, 2, 2354, 2349, 3, 2, 2, 2, 2354, 2350, 3, 2, 2, 2,
	2354, 2351, 3, 2, 2, 2, 2354, 2352, 3, 2, 2, 2, 2354, 2353, 3, 2, 2, 2,
	2355, 2358, 3, 2, 2, 2, 2356, 2358, 5, 1132, 567, 2, 2357, 2354, 3, 2,
	2, 2, 2357, 2356, 3, 2, 2, 2, 2358, 2361, 3, 2, 2, 2, 2359, 2357, 3, 2,
	2, 2, 2359, 2360, 3, 2, 2, 2, 2360, 2362, 3, 2, 2, 2, 2361, 2359, 3, 2,
	2, 2, 2362, 2363, 7, 536, 2, 2, 2363, 227, 3, 2, 2, 2, 2364, 2365, 7, 138,
	2, 2, 2365, 2367, 7, 107, 2, 2, 2366, 2368, 7, 256, 2, 2, 2367, 2366, 3,
	2, 2, 2, 2367, 2368, 3, 2, 2, 2, 2368, 2369, 3, 2, 2, 2, 2369, 2370, 5,
	1132, 567, 2, 2370, 229, 3, 2, 2, 2, 2371, 2372, 7, 138, 2, 2, 2372, 2373,
	7, 472, 2, 2, 2373, 2374, 7, 323, 2, 2, 2374, 2375, 5, 1180, 591, 2, 2375,
	2383, 7, 489, 2, 2, 2376, 2377, 7, 243, 2, 2, 2377, 2379, 7, 51, 2, 2,
	2378, 2380, 5, 1140, 571, 2, 2379, 2378, 3, 2, 2, 2, 2380, 2381, 3, 2,
	2, 2, 2381, 2379, 3, 2, 2, 2, 2381, 2382, 3, 2, 2, 2, 2382, 2384, 3, 2,
	2, 2, 2383, 2376, 3, 2, 2, 2, 2383, 2384, 3, 2, 2, 2, 2384, 231, 3, 2,
	2, 2, 2385, 2386, 7, 160, 2, 2, 2386, 2388, 7, 261, 2, 2, 2387, 2389, 7,
	256, 2, 2, 2388, 2387, 3, 2, 2, 2, 2388, 2389, 3, 2, 2, 2, 2389, 2390,
	3, 2, 2, 2, 2390, 2391, 5, 1132, 567, 2, 2391, 233, 3, 2, 2, 2, 2392, 2393,
	7, 190, 2, 2, 2393, 2395, 7, 261, 2, 2, 2394, 2396, 7, 256, 2, 2, 2395,
	2394, 3, 2, 2, 2, 2395, 2396, 3, 2, 2, 2, 2396, 2397, 3, 2, 2, 2, 2397,
	2398, 5, 1132, 567, 2, 2398, 235, 3, 2, 2, 2, 2399, 2401, 7, 297, 2, 2,
	2400, 2399, 3, 2, 2, 2, 2400, 2401, 3, 2, 2, 2, 2401, 2402, 3, 2, 2, 2,
	2402, 2404, 7, 107, 2, 2, 2403, 2405, 7, 256, 2, 2, 2404, 2403, 3, 2, 2,
	2, 2404, 2405, 3, 2, 2, 2, 2405, 2406, 3, 2, 2, 2, 2406, 2407, 5, 1132,
	567, 2, 2407, 237, 3, 2, 2, 2, 2408, 2409, 7, 297, 2, 2, 2409, 2411, 7,
	113, 2, 2, 2410, 2412, 7, 256, 2, 2, 2411, 2410, 3, 2, 2, 2, 2411, 2412,
	3, 2, 2, 2, 2412, 2413, 3, 2, 2, 2, 2413, 2414, 5, 1132, 567, 2, 2414,
	239, 3, 2, 2, 2, 2415, 2416, 7, 297, 2, 2, 2416, 2418, 7, 487, 2, 2, 2417,
	2419, 7, 256, 2, 2, 2418, 2417, 3, 2, 2, 2, 2418, 2419, 3, 2, 2, 2, 2419,
	2420, 3, 2, 2, 2, 2420, 2421, 5, 1132, 567, 2, 2421, 241, 3, 2, 2, 2, 2422,
	2423, 7, 459, 2, 2, 2423, 2425, 7, 261, 2, 2, 2424, 2426, 7, 256, 2, 2,
	2425, 2424, 3, 2, 2, 2, 2425, 2426, 3, 2, 2, 2, 2426, 2427, 3, 2, 2, 2,
	2427, 2428, 5, 1132, 567, 2, 2428, 243, 3, 2, 2, 2, 2429, 2431, 7, 469,
	2, 2, 2430, 2429, 3, 2, 2, 2, 2430, 2431, 3, 2, 2, 2, 2431, 2432, 3, 2,
	2, 2, 2432, 2434, 7, 138, 2, 2, 2433, 2435, 7, 256, 2, 2, 2434, 2433, 3,
	2, 2, 2, 2434, 2435, 3, 2, 2, 2, 2435, 2436, 3, 2, 2, 2, 2436, 2437, 5,
	1132, 567, 2, 2437, 245, 3, 2, 2, 2, 2438, 2440, 7, 469, 2, 2, 2439, 2438,
	3, 2, 2, 2, 2439, 2440, 3, 2, 2, 2, 2440, 2441, 3, 2, 2, 2, 2441, 2443,
	7, 368, 2, 2, 2442, 2444, 7, 256, 2, 2, 2443, 2442, 3, 2, 2, 2, 2443, 2444,
	3, 2, 2, 2, 2444, 2445, 3, 2, 2, 2, 2445, 2446, 5, 1132, 567, 2, 2446,
	247, 3, 2, 2, 2, 2447, 2449, 7, 469, 2, 2, 2448, 2447, 3, 2, 2, 2, 2448,
	2449, 3, 2, 2, 2, 2449, 2450, 3, 2, 2, 2, 2450, 2452, 7, 450, 2, 2, 2451,
	2453, 7, 256, 2, 2, 2452, 2451, 3, 2, 2, 2, 2452, 2453, 3, 2, 2, 2, 2453,
	2454, 3, 2, 2, 2, 2454, 2455, 5, 1132, 567, 2, 2455, 249, 3, 2, 2, 2, 2456,
	2458, 7, 469, 2, 2, 2457, 2456, 3, 2, 2, 2, 2457, 2458, 3, 2, 2, 2, 2458,
	2459, 3, 2, 2, 2, 2459, 2461, 7, 477, 2, 2, 2460, 2462, 7, 256, 2, 2, 2461,
	2460, 3, 2, 2, 2, 2461, 2462, 3, 2, 2, 2, 2462, 2463, 3, 2, 2, 2, 2463,
	2464, 5, 1132, 567, 2, 2464, 251, 3, 2, 2, 2, 2465, 2467, 7, 469, 2, 2,
	2466, 2465, 3, 2, 2, 2, 2466, 2467, 3, 2, 2, 2, 2467, 2468, 3, 2, 2, 2,
	2468, 2470, 9, 18, 2, 2, 2469, 2471, 7, 256, 2, 2, 2470, 2469, 3, 2, 2,
	2, 2470, 2471, 3, 2, 2, 2, 2471, 2472, 3, 2, 2, 2, 2472, 2473, 5, 1132,
	567, 2, 2473, 253, 3, 2, 2, 2, 2474, 2475, 7, 480, 2, 2, 2475, 2477, 7,
	271, 2, 2, 2476, 2478, 7, 256, 2, 2, 2477, 2476, 3, 2, 2, 2, 2477, 2478,
	3, 2, 2, 2, 2478, 2479, 3, 2, 2, 2, 2479, 2480, 5, 1132, 567, 2, 2480,
	255, 3, 2, 2, 2, 2481, 2482, 7, 287, 2, 2, 2482, 2483, 7, 421, 2, 2, 2483,
	2488, 7, 536, 2, 2, 2484, 2485, 7, 267, 2, 2, 2485, 2486, 5, 1146, 574,
	2, 2486, 2487, 7, 536, 2, 2, 2487, 2489, 3, 2, 2, 2, 2488, 2484, 3, 2,
	2, 2, 2488, 2489, 3, 2, 2, 2, 2489, 2493, 3, 2, 2, 2, 2490, 2492, 5, 436,
	219, 2, 2491, 2490, 3, 2, 2, 2, 2492, 2495, 3, 2, 2, 2, 2493, 2491, 3,
	2, 2, 2, 2493, 2494, 3, 2, 2, 2, 2494, 257, 3, 2, 2, 2, 2495, 2493, 3,
	2, 2, 2, 2496, 2497, 7, 418, 2, 2, 2497, 2498, 7, 421, 2, 2, 2498, 2502,
	7, 536, 2, 2, 2499, 2501, 5, 260, 131, 2, 2500, 2499, 3, 2, 2, 2, 2501,
	2504, 3, 2, 2, 2, 2502, 2500, 3, 2, 2, 2, 2502, 2503, 3, 2, 2, 2, 2503,
	259, 3, 2, 2, 2, 2504, 2502, 3, 2, 2, 2, 2505, 2508, 7, 557, 2, 2, 2506,
	2509, 7, 210, 2, 2, 2507, 2509, 5, 1162, 582, 2, 2508, 2506, 3, 2, 2, 2,
	2508, 2507, 3, 2, 2, 2, 2508, 2509, 3, 2, 2, 2, 2509, 2542, 3, 2, 2, 2,
	2510, 2541, 5, 262, 132, 2, 2511, 2541, 5, 264, 133, 2, 2512, 2541, 5,
	266, 134, 2, 2513, 2541, 5, 268, 135, 2, 2514, 2541, 5, 270, 136, 2, 2515,
	2541, 5, 272, 137, 2, 2516, 2541, 5, 274, 138, 2, 2517, 2541, 5, 276, 139,
	2, 2518, 2541, 5, 278, 140, 2, 2519, 2541, 5, 280, 141, 2, 2520, 2541,
	5, 282, 142, 2, 2521, 2541, 5, 284, 143, 2, 2522, 2541, 5, 286, 144, 2,
	2523, 2541, 5, 288, 145, 2, 2524, 2541, 5, 290, 146, 2, 2525, 2541, 5,
	292, 147, 2, 2526, 2529, 5, 294, 148, 2, 2527, 2529, 5, 298, 150, 2, 2528,
	2526, 3, 2, 2, 2, 2528, 2527, 3, 2, 2, 2, 2529, 2541, 3, 2, 2, 2, 2530,
	2541, 5, 300, 151, 2, 2531, 2541, 5, 302, 152, 2, 2532, 2541, 5, 304, 153,
	2, 2533, 2541, 5, 306, 154, 2, 2534, 2541, 5, 308, 155, 2, 2535, 2541,
	5, 310, 156, 2, 2536, 2541, 5, 312, 157, 2, 2537, 2541, 5, 314, 158, 2,
	2538, 2541, 5, 318, 160, 2, 2539, 2541, 5, 320, 161, 2, 2540, 2510, 3,
	2, 2, 2, 2540, 2511, 3, 2, 2, 2, 2540, 2512, 3, 2, 2, 2, 2540, 2513, 3,
	2, 2, 2, 2540, 2514, 3, 2, 2, 2, 2540, 2515, 3, 2, 2, 2, 2540, 2516, 3,
	2, 2, 2, 2540, 2517, 3, 2, 2, 2, 2540, 2518, 3, 2, 2, 2, 2540, 2519, 3,
	2, 2, 2, 2540, 2520, 3, 2, 2, 2, 2540, 2521, 3, 2, 2, 2, 2540, 2522, 3,
	2, 2, 2, 2540, 2523, 3, 2, 2, 2, 2540, 2524, 3, 2, 2, 2, 2540, 2525, 3,
	2, 2, 2, 2540, 2528, 3, 2, 2, 2, 2540, 2530, 3, 2, 2, 2, 2540, 2531, 3,
	2, 2, 2, 2540, 2532, 3, 2, 2, 2, 2540, 2533, 3, 2, 2, 2, 2540, 2534, 3,
	2, 2, 2, 2540, 2535, 3, 2, 2, 2, 2540, 2536, 3, 2, 2, 2, 2540, 2537, 3,
	2, 2, 2, 2540, 2538, 3, 2, 2, 2, 2540, 2539, 3, 2, 2, 2, 2541, 2544, 3,
	2, 2, 2, 2542, 2540, 3, 2, 2, 2, 2542, 2543, 3, 2, 2, 2, 2543, 2545, 3,
	2, 2, 2, 2544, 2542, 3, 2, 2, 2, 2545, 2546, 7, 536, 2, 2, 2546, 261, 3,
	2, 2, 2, 2547, 2548, 7, 46, 2, 2, 2548, 2549, 9, 19, 2, 2, 2549, 263, 3,
	2, 2, 2, 2550, 2551, 9, 20, 2, 2, 2551, 265, 3, 2, 2, 2, 2552, 2553, 7,
	47, 2, 2, 2553, 267, 3, 2, 2, 2, 2554, 2555, 7, 189, 2, 2, 2555, 2556,
	9, 21, 2, 2, 2556, 269, 3, 2, 2, 2, 2557, 2558, 9, 22, 2, 2, 2558, 271,
	3, 2, 2, 2, 2559, 2560, 9, 23, 2, 2, 2560, 273, 3, 2, 2, 2, 2561, 2562,
	7, 403, 2, 2, 2562, 275, 3, 2, 2, 2, 2563, 2564, 7, 500, 2, 2, 2564, 277,
	3, 2, 2, 2, 2565, 2567, 7, 441, 2, 2, 2566, 2568, 7, 256, 2, 2, 2567, 2566,
	3, 2, 2, 2, 2567, 2568, 3, 2, 2, 2, 2568, 2571, 3, 2, 2, 2, 2569, 2572,
	5, 1076, 539, 2, 2570, 2572, 5, 1180, 591, 2, 2571, 2569, 3, 2, 2, 2, 2571,
	2570, 3, 2, 2, 2, 2572, 279, 3, 2, 2, 2, 2573, 2581, 7, 281, 2, 2, 2574,
	2576, 7, 317, 2, 2, 2575, 2574, 3, 2, 2, 2, 2575, 2576, 3, 2, 2, 2, 2576,
	2578, 3, 2, 2, 2, 2577, 2579, 7, 256, 2, 2, 2578, 2577, 3, 2, 2, 2, 2578,
	2579, 3, 2, 2, 2, 2579, 2580, 3, 2, 2, 2, 2580, 2582, 9, 24, 2, 2, 2581,
	2575, 3, 2, 2, 2, 2581, 2582, 3, 2, 2, 2, 2582, 2585, 3, 2, 2, 2, 2583,
	2586, 5, 1076, 539, 2, 2584, 2586, 5, 1180, 591, 2, 2585, 2583, 3, 2, 2,
	2, 2585, 2584, 3, 2, 2, 2, 2586, 281, 3, 2, 2, 2, 2587, 2595, 9, 25, 2,
	2, 2588, 2590, 7, 317, 2, 2, 2589, 2588, 3, 2, 2, 2, 2589, 2590, 3, 2,
	2, 2, 2590, 2592, 3, 2, 2, 2, 2591, 2593, 7, 256, 2, 2, 2592, 2591, 3,
	2, 2, 2, 2592, 2593, 3, 2, 2, 2, 2593, 2594, 3, 2, 2, 2, 2594, 2596, 9,
	24, 2, 2, 2595, 2589, 3, 2, 2, 2, 2595, 2596, 3, 2, 2, 2, 2596, 2599, 3,
	2, 2, 2, 2597, 2600, 5, 1076, 539, 2, 2598, 2600, 5, 1180, 591, 2, 2599,
	2597, 3, 2, 2, 2, 2599, 2598, 3, 2, 2, 2, 2600, 283, 3, 2, 2, 2, 2601,
	2603, 9, 26, 2, 2, 2602, 2604, 7, 256, 2, 2, 2603, 2602, 3, 2, 2, 2, 2603,
	2604, 3, 2, 2, 2, 2604, 2607, 3, 2, 2, 2, 2605, 2608, 5, 1076, 539, 2,
	2606, 2608, 5, 1180, 591, 2, 2607, 2605, 3, 2, 2, 2, 2607, 2606, 3, 2,
	2, 2, 2608, 285, 3, 2, 2, 2, 2609, 2611, 9, 27, 2, 2, 2610, 2612, 7, 256,
	2, 2, 2611, 2610, 3, 2, 2, 2, 2611, 2612, 3, 2, 2, 2, 2612, 2615, 3, 2,
	2, 2, 2613, 2616, 5, 1076, 539, 2, 2614, 2616, 5, 1180, 591, 2, 2615, 2613,
	3, 2, 2, 2, 2615, 2614, 3, 2, 2, 2, 2616, 287, 3, 2, 2, 2, 2617, 2619,
	7, 99, 2, 2, 2618, 2620, 7, 256, 2, 2, 2619, 2618, 3, 2, 2, 2, 2619, 2620,
	3, 2, 2, 2, 2620, 2621, 3, 2, 2, 2, 2621, 2622, 5, 1076, 539, 2, 2622,
	289, 3, 2, 2, 2, 2623, 2625, 7, 509, 2, 2, 2624, 2626, 7, 256, 2, 2, 2625,
	2624, 3, 2, 2, 2, 2625, 2626, 3, 2, 2, 2, 2626, 2627, 3, 2, 2, 2, 2627,
	2628, 5, 1174, 588, 2, 2628, 291, 3, 2, 2, 2, 2629, 2631, 9, 28, 2, 2,
	2630, 2632, 7, 256, 2, 2, 2631, 2630, 3, 2, 2, 2, 2631, 2632, 3, 2, 2,
	2, 2632, 2633, 3, 2, 2, 2, 2633, 2634, 5, 468, 235, 2, 2634, 293, 3, 2,
	2, 2, 2635, 2638, 7, 217, 2, 2, 2636, 2639, 5, 1076, 539, 2, 2637, 2639,
	5, 1174, 588, 2, 2638, 2636, 3, 2, 2, 2, 2638, 2637, 3, 2, 2, 2, 2639,
	2641, 3, 2, 2, 2, 2640, 2642, 5, 296, 149, 2, 2641, 2640, 3, 2, 2, 2, 2641,
	2642, 3, 2, 2, 2, 2642, 295, 3, 2, 2, 2, 2643, 2644, 7, 491, 2, 2, 2644,
	2645, 5, 1076, 539, 2, 2645, 297, 3, 2, 2, 2, 2646, 2647, 7, 508, 2, 2,
	2647, 2648, 5, 1076, 539, 2, 2648, 299, 3, 2, 2, 2, 2649, 2651, 7, 506,
	2, 2, 2650, 2652, 7, 256, 2, 2, 2651, 2650, 3, 2, 2, 2, 2651, 2652, 3,
	2, 2, 2, 2652, 2653, 3, 2, 2, 2, 2653, 2654, 9, 29, 2, 2, 2654, 301, 3,
	2, 2, 2, 2655, 2657, 7, 46, 2, 2, 2656, 2658, 7, 514, 2, 2, 2657, 2656,
	3, 2, 2, 2, 2657, 2658, 3, 2, 2, 2, 2658, 2659, 3, 2, 2, 2, 2659, 2660,
	7, 523, 2, 2, 2660, 303, 3, 2, 2, 2, 2661, 2663, 9, 30, 2, 2, 2662, 2664,
	7, 413, 2, 2, 2663, 2662, 3, 2, 2, 2, 2663, 2664, 3, 2, 2, 2, 2664, 305,
	3, 2, 2, 2, 2665, 2667, 7, 440, 2, 2, 2666, 2668, 7, 256, 2, 2, 2667, 2666,
	3, 2, 2, 2, 2667, 2668, 3, 2, 2, 2, 2668, 2670, 3, 2, 2, 2, 2669, 2665,
	3, 2, 2, 2, 2669, 2670, 3, 2, 2, 2, 2670, 2671, 3, 2, 2, 2, 2671, 2676,
	9, 9, 2, 2, 2672, 2674, 7, 429, 2, 2, 2673, 2675, 7, 64, 2, 2, 2674, 2673,
	3, 2, 2, 2, 2674, 2675, 3, 2, 2, 2, 2675, 2677, 3, 2, 2, 2, 2676, 2672,
	3, 2, 2, 2, 2676, 2677, 3, 2, 2, 2, 2677, 307, 3, 2, 2, 2, 2678, 2679,
	9, 31, 2, 2, 2679, 309, 3, 2, 2, 2, 2680, 2681, 9, 32, 2, 2, 2681, 311,
	3, 2, 2, 2, 2682, 2683, 9, 33, 2, 2, 2683, 313, 3, 2, 2, 2, 2684, 2686,
	7, 366, 2, 2, 2685, 2687, 7, 64, 2, 2, 2686, 2685, 3, 2, 2, 2, 2686, 2687,
	3, 2, 2, 2, 2687, 2689, 3, 2, 2, 2, 2688, 2690, 7, 256, 2, 2, 2689, 2688,
	3, 2, 2, 2, 2689, 2690, 3, 2, 2, 2, 2690, 2693, 3, 2, 2, 2, 2691, 2694,
	5, 1076, 539, 2, 2692, 2694, 5, 1174, 588, 2, 2693, 2691, 3, 2, 2, 2, 2693,
	2692, 3, 2, 2, 2, 2694, 2696, 3, 2, 2, 2, 2695, 2697, 5, 316, 159, 2, 2696,
	2695, 3, 2, 2, 2, 2696, 2697, 3, 2, 2, 2, 2697, 315, 3, 2, 2, 2, 2698,
	2699, 7, 323, 2, 2, 2699, 2701, 5, 1180, 591, 2, 2700, 2702, 7, 489, 2,
	2, 2701, 2700, 3, 2, 2, 2, 2701, 2702, 3, 2, 2, 2, 2702, 317, 3, 2, 2,
	2, 2703, 2704, 9, 34, 2, 2, 2704, 319, 3, 2, 2, 2, 2705, 2706, 7, 524,
	2, 2, 2706, 321, 3, 2, 2, 2, 2707, 2708, 7, 397, 2, 2, 2708, 2709, 7, 421,
	2, 2, 2709, 2713, 7, 536, 2, 2, 2710, 2712, 5, 324, 163, 2, 2711, 2710,
	3, 2, 2, 2, 2712, 2715, 3, 2, 2, 2, 2713, 2711, 3, 2, 2, 2, 2713, 2714,
	3, 2, 2, 2, 2714, 323, 3, 2, 2, 2, 2715, 2713, 3, 2, 2, 2, 2716, 2718,
	5, 326, 164, 2, 2717, 2719, 5, 340, 171, 2, 2718, 2717, 3, 2, 2, 2, 2719,
	2720, 3, 2, 2, 2, 2720, 2718, 3, 2, 2, 2, 2720, 2721, 3, 2, 2, 2, 2721,
	325, 3, 2, 2, 2, 2722, 2723, 7, 374, 2, 2, 2723, 2725, 5, 1158, 580, 2,
	2724, 2726, 5, 328, 165, 2, 2725, 2724, 3, 2, 2, 2, 2725, 2726, 3, 2, 2,
	2, 2726, 2740, 3, 2, 2, 2, 2727, 2729, 5, 330, 166, 2, 2728, 2730, 5, 332,
	167, 2, 2729, 2728, 3, 2, 2, 2, 2729, 2730, 3, 2, 2, 2, 2730, 2732, 3,
	2, 2, 2, 2731, 2733, 5, 334, 168, 2, 2732, 2731, 3, 2, 2, 2, 2732, 2733,
	3, 2, 2, 2, 2733, 2735, 3, 2, 2, 2, 2734, 2736, 5, 336, 169, 2, 2735, 2734,
	3, 2, 2, 2, 2735, 2736, 3, 2, 2, 2, 2736, 2738, 3, 2, 2, 2, 2737, 2739,
	5, 338, 170, 2, 2738, 2737, 3, 2, 2, 2, 2738, 2739, 3, 2, 2, 2, 2739, 2741,
	3, 2, 2, 2, 2740, 2727, 3, 2, 2, 2, 2740, 2741, 3, 2, 2, 2, 2741, 2742,
	3, 2, 2, 2, 2742, 2743, 7, 536, 2, 2, 2743, 327, 3, 2, 2, 2, 2744, 2746,
	7, 256, 2, 2, 2745, 2744, 3, 2, 2, 2, 2745, 2746, 3, 2, 2, 2, 2746, 2747,
	3, 2, 2, 2, 2747, 2748, 7, 225, 2, 2, 2748, 329, 3, 2, 2, 2, 2749, 2758,
	7, 342, 2, 2, 2750, 2752, 7, 277, 2, 2, 2751, 2753, 7, 256, 2, 2, 2752,
	2751, 3, 2, 2, 2, 2752, 2753, 3, 2, 2, 2, 2753, 2759, 3, 2, 2, 2, 2754,
	2756, 7, 278, 2, 2, 2755, 2757, 7, 23, 2, 2, 2756, 2755, 3, 2, 2, 2, 2756,
	2757, 3, 2, 2, 2, 2757, 2759, 3, 2, 2, 2, 2758, 2750, 3, 2, 2, 2, 2758,
	2754, 3, 2, 2, 2, 2758, 2759, 3, 2, 2, 2, 2759, 2760, 3, 2, 2, 2, 2760,
	2762, 5, 1180, 591, 2, 2761, 2763, 9, 35, 2, 2, 2762, 2761, 3, 2, 2, 2,
	2762, 2763, 3, 2, 2, 2, 2763, 331, 3, 2, 2, 2, 2764, 2765, 7, 230, 2, 2,
	2765, 2766, 5, 1180, 591, 2, 2766, 333, 3, 2, 2, 2, 2767, 2768, 7, 212,
	2, 2, 2768, 2769, 7, 139, 2, 2, 2769, 2770, 5, 1180, 591, 2, 2770, 335,
	3, 2, 2, 2, 2771, 2772, 7, 265, 2, 2, 2772, 2773, 7, 139, 2, 2, 2773, 2774,
	5, 1180, 591, 2, 2774, 337, 3, 2, 2, 2, 2775, 2776, 7, 213, 2, 2, 2776,
	2777, 5, 1180, 591, 2, 2777, 339, 3, 2, 2, 2, 2778, 2782, 5, 342, 172,
	2, 2779, 2782, 5, 344, 173, 2, 2780, 2782, 5, 346, 174, 2, 2781, 2778,
	3, 2, 2, 2, 2781, 2779, 3, 2, 2, 2, 2781, 2780, 3, 2, 2, 2, 2782, 341,
	3, 2, 2, 2, 2783, 2784, 5, 1180, 591, 2, 2784, 2786, 5, 1130, 566, 2, 2785,
	2787, 5, 356, 179, 2, 2786, 2785, 3, 2, 2, 2, 2786, 2787, 3, 2, 2, 2, 2787,
	2789, 3, 2, 2, 2, 2788, 2790, 5, 362, 182, 2, 2789, 2788, 3, 2, 2, 2, 2789,
	2790, 3, 2, 2, 2, 2790, 2791, 3, 2, 2, 2, 2791, 2793, 5, 378, 190, 2, 2792,
	2794, 5, 390, 196, 2, 2793, 2792, 3, 2, 2, 2, 2793, 2794, 3, 2, 2, 2, 2794,
	2795, 3, 2, 2, 2, 2795, 2796, 7, 536, 2, 2, 2796, 343, 3, 2, 2, 2, 2797,
	2799, 5, 1180, 591, 2, 2798, 2800, 5, 1130, 566, 2, 2799, 2798, 3, 2, 2,
	2, 2799, 2800, 3, 2, 2, 2, 2800, 2802, 3, 2, 2, 2, 2801, 2803, 5, 356,
	179, 2, 2802, 2801, 3, 2, 2, 2, 2802, 2803, 3, 2, 2, 2, 2803, 2804, 3,
	2, 2, 2, 2804, 2805, 5, 390, 196, 2, 2805, 2806, 7, 536, 2, 2, 2806, 345,
	3, 2, 2, 2, 2807, 2809, 5, 1180, 591, 2, 2808, 2810, 5, 1130, 566, 2, 2809,
	2808, 3, 2, 2, 2, 2809, 2810, 3, 2, 2, 2, 2810, 2827, 3, 2, 2, 2, 2811,
	2826, 5, 368, 185, 2, 2812, 2826, 5, 390, 196, 2, 2813, 2826, 5, 372, 187,
	2, 2814, 2826, 5, 354, 178, 2, 2815, 2826, 5, 348, 175, 2, 2816, 2826,
	5, 356, 179, 2, 2817, 2826, 5, 350, 176, 2, 2818, 2823, 5, 374, 188, 2,
	2819, 2823, 5, 396, 199, 2, 2820, 2823, 5, 376, 189, 2, 2821, 2823, 5,
	370, 186, 2, 2822, 2818, 3, 2, 2, 2, 2822, 2819, 3, 2, 2, 2, 2822, 2820,
	3, 2, 2, 2, 2822, 2821, 3, 2, 2, 2, 2823, 2826, 3, 2, 2, 2, 2824, 2826,
	5, 352, 177, 2, 2825, 2811, 3, 2, 2, 2, 2825, 2812, 3, 2, 2, 2, 2825, 2813,
	3, 2, 2, 2, 2825, 2814, 3, 2, 2, 2, 2825, 2815, 3, 2, 2, 2, 2825, 2816,
	3, 2, 2, 2, 2825, 2817, 3, 2, 2, 2, 2825, 2822, 3, 2, 2, 2, 2825, 2824,
	3, 2, 2, 2, 2826, 2829, 3, 2, 2, 2, 2827, 2825, 3, 2, 2, 2, 2827, 2828,
	3, 2, 2, 2, 2828, 2830, 3, 2, 2, 2, 2829, 2827, 3, 2, 2, 2, 2830, 2831,
	7, 536, 2, 2, 2831, 347, 3, 2, 2, 2, 2832, 2834, 7, 46, 2, 2, 2833, 2835,
	7, 514, 2, 2, 2834, 2833, 3, 2, 2, 2, 2834, 2835, 3, 2, 2, 2, 2835, 2836,
	3, 2, 2, 2, 2836, 2837, 7, 523, 2, 2, 2837, 349, 3, 2, 2, 2, 2838, 2840,
	7, 76, 2, 2, 2839, 2841, 7, 317, 2, 2, 2840, 2839, 3, 2, 2, 2, 2840, 2841,
	3, 2, 2, 2, 2841, 2843, 3, 2, 2, 2, 2842, 2844, 7, 256, 2, 2, 2843, 2842,
	3, 2, 2, 2, 2843, 2844, 3, 2, 2, 2, 2844, 2845, 3, 2, 2, 2, 2845, 2846,
	5, 1180, 591, 2, 2846, 351, 3, 2, 2, 2, 2847, 2849, 7, 229, 2, 2, 2848,
	2850, 7, 244, 2, 2, 2849, 2848, 3, 2, 2, 2, 2849, 2850, 3, 2, 2, 2, 2850,
	353, 3, 2, 2, 2, 2851, 2853, 9, 30, 2, 2, 2852, 2854, 7, 413, 2, 2, 2853,
	2852, 3, 2, 2, 2, 2853, 2854, 3, 2, 2, 2, 2854, 355, 3, 2, 2, 2, 2855,
	2857, 7, 281, 2, 2, 2856, 2855, 3, 2, 2, 2, 2856, 2857, 3, 2, 2, 2, 2857,
	2859, 3, 2, 2, 2, 2858, 2860, 7, 317, 2, 2, 2859, 2858, 3, 2, 2, 2, 2859,
	2860, 3, 2, 2, 2, 2860, 2862, 3, 2, 2, 2, 2861, 2863, 7, 256, 2, 2, 2862,
	2861, 3, 2, 2, 2, 2862, 2863, 3, 2, 2, 2, 2863, 2866, 3, 2, 2, 2, 2864,
	2867, 5, 358, 180, 2, 2865, 2867, 5, 360, 181, 2, 2866, 2864, 3, 2, 2,
	2, 2866, 2865, 3, 2, 2, 2, 2867, 357, 3, 2, 2, 2, 2868, 2874, 5, 1180,
	591, 2, 2869, 2871, 7, 328, 2, 2, 2870, 2869, 3, 2, 2, 2, 2870, 2871, 3,
	2, 2, 2, 2871, 2872, 3, 2, 2, 2, 2872, 2873, 7, 311, 2, 2, 2873, 2875,
	7, 342, 2, 2, 2874, 2870, 3, 2, 2, 2, 2874, 2875, 3, 2, 2, 2, 2875, 359,
	3, 2, 2, 2, 2876, 2877, 7, 350, 2, 2, 2877, 2878, 5, 1180, 591, 2, 2878,
	361, 3, 2, 2, 2, 2879, 2880, 7, 311, 2, 2, 2880, 2882, 7, 229, 2, 2, 2881,
	2883, 7, 256, 2, 2, 2882, 2881, 3, 2, 2, 2, 2882, 2883, 3, 2, 2, 2, 2883,
	2887, 3, 2, 2, 2, 2884, 2888, 5, 1180, 591, 2, 2885, 2888, 5, 366, 184,
	2, 2886, 2888, 5, 364, 183, 2, 2887, 2884, 3, 2, 2, 2, 2887, 2885, 3, 2,
	2, 2, 2887, 2886, 3, 2, 2, 2, 2888, 363, 3, 2, 2, 2, 2889, 2890, 7, 350,
	2, 2, 2890, 2891, 5, 1180, 591, 2, 2891, 365, 3, 2, 2, 2, 2892, 2893, 7,
	311, 2, 2, 2893, 2894, 7, 342, 2, 2, 2894, 367, 3, 2, 2, 2, 2895, 2897,
	9, 28, 2, 2, 2896, 2898, 7, 256, 2, 2, 2897, 2896, 3, 2, 2, 2, 2897, 2898,
	3, 2, 2, 2, 2898, 2899, 3, 2, 2, 2, 2899, 2900, 5, 468, 235, 2, 2900, 369,
	3, 2, 2, 2, 2901, 2903, 7, 404, 2, 2, 2902, 2904, 7, 328, 2, 2, 2903, 2902,
	3, 2, 2, 2, 2903, 2904, 3, 2, 2, 2, 2904, 2907, 3, 2, 2, 2, 2905, 2908,
	7, 211, 2, 2, 2906, 2908, 5, 1130, 566, 2, 2907, 2905, 3, 2, 2, 2, 2907,
	2906, 3, 2, 2, 2, 2908, 371, 3, 2, 2, 2, 2909, 2911, 7, 440, 2, 2, 2910,
	2912, 7, 256, 2, 2, 2911, 2910, 3, 2, 2, 2, 2911, 2912, 3, 2, 2, 2, 2912,
	2913, 3, 2, 2, 2, 2913, 2914, 9, 9, 2, 2, 2914, 2916, 7, 429, 2, 2, 2915,
	2917, 7, 64, 2, 2, 2916, 2915, 3, 2, 2, 2, 2916, 2917, 3, 2, 2, 2, 2917,
	373, 3, 2, 2, 2, 2918, 2920, 7, 450, 2, 2, 2919, 2921, 7, 256, 2, 2, 2920,
	2919, 3, 2, 2, 2, 2920, 2921, 3, 2, 2, 2, 2921, 2922, 3, 2, 2, 2, 2922,
	2923, 5, 1076, 539, 2, 2923, 375, 3, 2, 2, 2, 2924, 2925, 7, 466, 2, 2,
	2925, 2932, 5, 1076, 539, 2, 2926, 2928, 7, 531, 2, 2, 2927, 2926, 3, 2,
	2, 2, 2927, 2928, 3, 2, 2, 2, 2928, 2929, 3, 2, 2, 2, 2929, 2931, 5, 1076,
	539, 2, 2930, 2927, 3, 2, 2, 2, 2931, 2934, 3, 2, 2, 2, 2932, 2930, 3,
	2, 2, 2, 2932, 2933, 3, 2, 2, 2, 2933, 2946, 3, 2, 2, 2, 2934, 2932, 3,
	2, 2, 2, 2935, 2936, 7, 505, 2, 2, 2936, 2943, 5, 1130, 566, 2, 2937, 2939,
	7, 531, 2, 2, 2938, 2937, 3, 2, 2, 2, 2938, 2939, 3, 2, 2, 2, 2939, 2940,
	3, 2, 2, 2, 2940, 2942, 5, 1130, 566, 2, 2941, 2938, 3, 2, 2, 2, 2942,
	2945, 3, 2, 2, 2, 2943, 2941, 3, 2, 2, 2, 2943, 2944, 3, 2, 2, 2, 2944,
	2947, 3, 2, 2, 2, 2945, 2943, 3, 2, 2, 2, 2946, 2935, 3, 2, 2, 2, 2946,
	2947, 3, 2, 2, 2, 2947, 377, 3, 2, 2, 2, 2948, 2950, 7, 498, 2, 2, 2949,
	2951, 7, 256, 2, 2, 2950, 2949, 3, 2, 2, 2, 2950, 2951, 3, 2, 2, 2, 2951,
	2959, 3, 2, 2, 2, 2952, 2960, 5, 380, 191, 2, 2953, 2960, 5, 382, 192,
	2, 2954, 2960, 5, 384, 193, 2, 2955, 2960, 5, 386, 194, 2, 2956, 2960,
	5, 388, 195, 2, 2957, 2960, 5, 392, 197, 2, 2958, 2960, 5, 394, 198, 2,
	2959, 2952, 3, 2, 2, 2, 2959, 2953, 3, 2, 2, 2, 2959, 2954, 3, 2, 2, 2,
	2959, 2955, 3, 2, 2, 2, 2959, 2956, 3, 2, 2, 2, 2959, 2957, 3, 2, 2, 2,
	2959, 2958, 3, 2, 2, 2, 2960, 379, 3, 2, 2, 2, 2961, 2962, 7, 397, 2, 2,
	2962, 2965, 7, 230, 2, 2, 2963, 2965, 7, 412, 2, 2, 2964, 2961, 3, 2, 2,
	2, 2964, 2963, 3, 2, 2, 2, 2965, 381, 3, 2, 2, 2, 2966, 2967, 7, 342, 2,
	2, 2967, 2970, 7, 230, 2, 2, 2968, 2970, 7, 347, 2, 2, 2969, 2966, 3, 2,
	2, 2, 2969, 2968, 3, 2, 2, 2, 2970, 383, 3, 2, 2, 2, 2971, 2972, 7, 99,
	2, 2, 2972, 2975, 7, 230, 2, 2, 2973, 2975, 7, 60, 2, 2, 2974, 2971, 3,
	2, 2, 2, 2974, 2973, 3, 2, 2, 2, 2975, 2978, 3, 2, 2, 2, 2976, 2979, 7,
	211, 2, 2, 2977, 2979, 5, 1130, 566, 2, 2978, 2976, 3, 2, 2, 2, 2978, 2977,
	3, 2, 2, 2, 2979, 385, 3, 2, 2, 2, 2980, 2981, 9, 36, 2, 2, 2981, 387,
	3, 2, 2, 2, 2982, 2983, 7, 99, 2, 2, 2983, 2986, 7, 213, 2, 2, 2984, 2986,
	7, 59, 2, 2, 2985, 2982, 3, 2, 2, 2, 2985, 2984, 3, 2, 2, 2, 2986, 2989,
	3, 2, 2, 2, 2987, 2990, 7, 211, 2, 2, 2988, 2990, 5, 1130, 566, 2, 2989,
	2987, 3, 2, 2, 2, 2989, 2988, 3, 2, 2, 2, 2990, 389, 3, 2, 2, 2, 2991,
	2993, 7, 506, 2, 2, 2992, 2994, 7, 256, 2, 2, 2993, 2992, 3, 2, 2, 2, 2993,
	2994, 3, 2, 2, 2, 2994, 2996, 3, 2, 2, 2, 2995, 2991, 3, 2, 2, 2, 2995,
	2996, 3, 2, 2, 2, 2996, 2997, 3, 2, 2, 2, 2997, 2998, 9, 29, 2, 2, 2998,
	391, 3, 2, 2, 2, 2999, 3000, 7, 342, 2, 2, 3000, 3003, 7, 213, 2, 2, 3001,
	3003, 7, 346, 2, 2, 3002, 2999, 3, 2, 2, 2, 3002, 3001, 3, 2, 2, 2, 3003,
	393, 3, 2, 2, 2, 3004, 3005, 7, 397, 2, 2, 3005, 3008, 7, 213, 2, 2, 3006,
	3008, 7, 411, 2, 2, 3007, 3004, 3, 2, 2, 2, 3007, 3006, 3, 2, 2, 2, 3008,
	395, 3, 2, 2, 2, 3009, 3011, 7, 509, 2, 2, 3010, 3012, 7, 256, 2, 2, 3011,
	3010, 3, 2, 2, 2, 3011, 3012, 3, 2, 2, 2, 3012, 3013, 3, 2, 2, 2, 3013,
	3014, 5, 1174, 588, 2, 3014, 397, 3, 2, 2, 2, 3015, 3016, 7, 365, 2, 2,
	3016, 3017, 7, 421, 2, 2, 3017, 3021, 7, 536, 2, 2, 3018, 3020, 5, 400,
	201, 2, 3019, 3018, 3, 2, 2, 2, 3020, 3023, 3, 2, 2, 2, 3021, 3019, 3,
	2, 2, 2, 3021, 3022, 3, 2, 2, 2, 3022, 399, 3, 2, 2, 2, 3023, 3021, 3,
	2, 2, 2, 3024, 3027, 5, 402, 202, 2, 3025, 3027, 5, 404, 203, 2, 3026,
	3024, 3, 2, 2, 2, 3026, 3025, 3, 2, 2, 2, 3027, 401, 3, 2, 2, 2, 3028,
	3029, 7, 267, 2, 2, 3029, 3030, 5, 1144, 573, 2, 3030, 3032, 7, 202, 2,
	2, 3031, 3033, 5, 406, 204, 2, 3032, 3031, 3, 2, 2, 2, 3032, 3033, 3, 2,
	2, 2, 3033, 3035, 3, 2, 2, 2, 3034, 3036, 5, 416, 209, 2, 3035, 3034, 3,
	2, 2, 2, 3035, 3036, 3, 2, 2, 2, 3036, 403, 3, 2, 2, 2, 3037, 3038, 7,
	266, 2, 2, 3038, 3039, 5, 1144, 573, 2, 3039, 3041, 7, 240, 2, 2, 3040,
	3042, 5, 434, 218, 2, 3041, 3040, 3, 2, 2, 2, 3041, 3042, 3, 2, 2, 2, 3042,
	3044, 3, 2, 2, 2, 3043, 3045, 5, 432, 217, 2, 3044, 3043, 3, 2, 2, 2, 3044,
	3045, 3, 2, 2, 2, 3045, 3050, 3, 2, 2, 2, 3046, 3049, 5, 408, 205, 2, 3047,
	3049, 5, 418, 210, 2, 3048, 3046, 3, 2, 2, 2, 3048, 3047, 3, 2, 2, 2, 3049,
	3052, 3, 2, 2, 2, 3050, 3048, 3, 2, 2, 2, 3050, 3051, 3, 2, 2, 2, 3051,
	405, 3, 2, 2, 2, 3052, 3050, 3, 2, 2, 2, 3053, 3059, 7, 33, 2, 2, 3054,
	3056, 7, 436, 2, 2, 3055, 3057, 7, 256, 2, 2, 3056, 3055, 3, 2, 2, 2, 3056,
	3057, 3, 2, 2, 2, 3057, 3058, 3, 2, 2, 2, 3058, 3060, 9, 37, 2, 2, 3059,
	3054, 3, 2, 2, 2, 3059, 3060, 3, 2, 2, 2, 3060, 407, 3, 2, 2, 2, 3061,
	3063, 7, 33, 2, 2, 3062, 3064, 5, 410, 206, 2, 3063, 3062, 3, 2, 2, 2,
	3063, 3064, 3, 2, 2, 2, 3064, 3070, 3, 2, 2, 2, 3065, 3067, 7, 274, 2,
	2, 3066, 3068, 7, 256, 2, 2, 3067, 3066, 3, 2, 2, 2, 3067, 3068, 3, 2,
	2, 2, 3068, 3069, 3, 2, 2, 2, 3069, 3071, 9, 38, 2, 2, 3070, 3065, 3, 2,
	2, 2, 3070, 3071, 3, 2, 2, 2, 3071, 3073, 3, 2, 2, 2, 3072, 3074, 5, 412,
	207, 2, 3073, 3072, 3, 2, 2, 2, 3073, 3074, 3, 2, 2, 2, 3074, 3076, 3,
	2, 2, 2, 3075, 3077, 5, 414, 208, 2, 3076, 3075, 3, 2, 2, 2, 3076, 3077,
	3, 2, 2, 2, 3077, 409, 3, 2, 2, 2, 3078, 3079, 7, 220, 2, 2, 3079, 3080,
	7, 256, 2, 2, 3080, 3081, 5, 1174, 588, 2, 3081, 411, 3, 2, 2, 2, 3082,
	3084, 7, 275, 2, 2, 3083, 3085, 7, 256, 2, 2, 3084, 3083, 3, 2, 2, 2, 3084,
	3085, 3, 2, 2, 2, 3085, 3086, 3, 2, 2, 2, 3086, 3087, 5, 1174, 588, 2,
	3087, 413, 3, 2, 2, 2, 3088, 3090, 7, 490, 2, 2, 3089, 3091, 7, 256, 2,
	2, 3090, 3089, 3, 2, 2, 2, 3090, 3091, 3, 2, 2, 2, 3091, 3092, 3, 2, 2,
	2, 3092, 3093, 5, 1174, 588, 2, 3093, 415, 3, 2, 2, 2, 3094, 3095, 7, 185,
	2, 2, 3095, 3097, 5, 1154, 578, 2, 3096, 3098, 5, 420, 211, 2, 3097, 3096,
	3, 2, 2, 2, 3097, 3098, 3, 2, 2, 2, 3098, 417, 3, 2, 2, 2, 3099, 3100,
	7, 185, 2, 2, 3100, 3102, 5, 1154, 578, 2, 3101, 3103, 5, 420, 211, 2,
	3102, 3101, 3, 2, 2, 2, 3102, 3103, 3, 2, 2, 2, 3103, 3105, 3, 2, 2, 2,
	3104, 3106, 5, 428, 215, 2, 3105, 3104, 3, 2, 2, 2, 3105, 3106, 3, 2, 2,
	2, 3106, 3108, 3, 2, 2, 2, 3107, 3109, 5, 424, 213, 2, 3108, 3107, 3, 2,
	2, 2, 3108, 3109, 3, 2, 2, 2, 3109, 3111, 3, 2, 2, 2, 3110, 3112, 5, 422,
	212, 2, 3111, 3110, 3, 2, 2, 2, 3111, 3112, 3, 2, 2, 2, 3112, 419, 3, 2,
	2, 2, 3113, 3114, 7, 214, 2, 2, 3114, 3115, 5, 1174, 588, 2, 3115, 421,
	3, 2, 2, 2, 3116, 3117, 7, 224, 2, 2, 3117, 3118, 5, 1130, 566, 2, 3118,
	423, 3, 2, 2, 2, 3119, 3121, 7, 508, 2, 2, 3120, 3122, 5, 426, 214, 2,
	3121, 3120, 3, 2, 2, 2, 3122, 3123, 3, 2, 2, 2, 3123, 3121, 3, 2, 2, 2,
	3123, 3124, 3, 2, 2, 2, 3124, 425, 3, 2, 2, 2, 3125, 3128, 5, 1130, 566,
	2, 3126, 3128, 5, 1136, 569, 2, 3127, 3125, 3, 2, 2, 2, 3127, 3126, 3,
	2, 2, 2, 3128, 427, 3, 2, 2, 2, 3129, 3131, 7, 516, 2, 2, 3130, 3132, 5,
	430, 216, 2, 3131, 3130, 3, 2, 2, 2, 3132, 3133, 3, 2, 2, 2, 3133, 3131,
	3, 2, 2, 2, 3133, 3134, 3, 2, 2, 2, 3134, 429, 3, 2, 2, 2, 3135, 3138,
	5, 1146, 574, 2, 3136, 3138, 5, 1136, 569, 2, 3137, 3135, 3, 2, 2, 2, 3137,
	3136, 3, 2, 2, 2, 3138, 431, 3, 2, 2, 2, 3139, 3141, 7, 256, 2, 2, 3140,
	3139, 3, 2, 2, 2, 3140, 3141, 3, 2, 2, 2, 3141, 3142, 3, 2, 2, 2, 3142,
	3143, 7, 80, 2, 2, 3143, 433, 3, 2, 2, 2, 3144, 3146, 7, 256, 2, 2, 3145,
	3144, 3, 2, 2, 2, 3145, 3146, 3, 2, 2, 2, 3146, 3147, 3, 2, 2, 2, 3147,
	3148, 7, 225, 2, 2, 3148, 435, 3, 2, 2, 2, 3149, 3154, 5, 438, 220, 2,
	3150, 3154, 5, 440, 221, 2, 3151, 3154, 5, 442, 222, 2, 3152, 3154, 5,
	444, 223, 2, 3153, 3149, 3, 2, 2, 2, 3153, 3150, 3, 2, 2, 2, 3153, 3151,
	3, 2, 2, 2, 3153, 3152, 3, 2, 2, 2, 3154, 437, 3, 2, 2, 2, 3155, 3158,
	9, 39, 2, 2, 3156, 3159, 7, 210, 2, 2, 3157, 3159, 5, 1130, 566, 2, 3158,
	3156, 3, 2, 2, 2, 3158, 3157, 3, 2, 2, 2, 3158, 3159, 3, 2, 2, 2, 3159,
	3183, 3, 2, 2, 2, 3160, 3182, 5, 478, 240, 2, 3161, 3182, 5, 456, 229,
	2, 3162, 3182, 5, 452, 227, 2, 3163, 3182, 5, 454, 228, 2, 3164, 3182,
	5, 490, 246, 2, 3165, 3182, 5, 486, 244, 2, 3166, 3182, 5, 466, 234, 2,
	3167, 3182, 5, 450, 226, 2, 3168, 3182, 5, 488, 245, 2, 3169, 3182, 5,
	494, 248, 2, 3170, 3182, 5, 492, 247, 2, 3171, 3182, 5, 496, 249, 2, 3172,
	3182, 5, 474, 238, 2, 3173, 3182, 5, 460, 231, 2, 3174, 3182, 5, 482, 242,
	2, 3175, 3182, 5, 484, 243, 2, 3176, 3182, 5, 458, 230, 2, 3177, 3182,
	5, 448, 225, 2, 3178, 3182, 5, 504, 253, 2, 3179, 3182, 5, 446, 224, 2,
	3180, 3182, 5, 476, 239, 2, 3181, 3160, 3, 2, 2, 2, 3181, 3161, 3, 2, 2,
	2, 3181, 3162, 3, 2, 2, 2, 3181, 3163, 3, 2, 2, 2, 3181, 3164, 3, 2, 2,
	2, 3181, 3165, 3, 2, 2, 2, 3181, 3166, 3, 2, 2, 2, 3181, 3167, 3, 2, 2,
	2, 3181, 3168, 3, 2, 2, 2, 3181, 3169, 3, 2, 2, 2, 3181, 3170, 3, 2, 2,
	2, 3181, 3171, 3, 2, 2, 2, 3181, 3172, 3, 2, 2, 2, 3181, 3173, 3, 2, 2,
	2, 3181, 3174, 3, 2, 2, 2, 3181, 3175, 3, 2, 2, 2, 3181, 3176, 3, 2, 2,
	2, 3181, 3177, 3, 2, 2, 2, 3181, 3178, 3, 2, 2, 2, 3181, 3179, 3, 2, 2,
	2, 3181, 3180, 3, 2, 2, 2, 3182, 3185, 3, 2, 2, 2, 3183, 3181, 3, 2, 2,
	2, 3183, 3184, 3, 2, 2, 2, 3184, 3186, 3, 2, 2, 2, 3185, 3183, 3, 2, 2,
	2, 3186, 3187, 7, 536, 2, 2, 3187, 439, 3, 2, 2, 2, 3188, 3189, 7, 554,
	2, 2, 3189, 3190, 5, 1130, 566, 2, 3190, 3191, 5, 480, 241, 2, 3191, 3192,
	7, 536, 2, 2, 3192, 441, 3, 2, 2, 2, 3193, 3194, 7, 556, 2, 2, 3194, 3195,
	5, 1128, 565, 2, 3195, 3196, 5, 496, 249, 2, 3196, 3197, 7, 536, 2, 2,
	3197, 443, 3, 2, 2, 2, 3198, 3200, 7, 563, 2, 2, 3199, 3198, 3, 2, 2, 2,
	3200, 3201, 3, 2, 2, 2, 3201, 3199, 3, 2, 2, 2, 3201, 3202, 3, 2, 2, 2,
	3202, 3204, 3, 2, 2, 2, 3203, 3205, 7, 536, 2, 2, 3204, 3203, 3, 2, 2,
	2, 3204, 3205, 3, 2, 2, 2, 3205, 445, 3, 2, 2, 2, 3206, 3207, 7, 10, 2,
	2, 3207, 447, 3, 2, 2, 2, 3208, 3210, 7, 46, 2, 2, 3209, 3211, 7, 514,
	2, 2, 3210, 3209, 3, 2, 2, 2, 3210, 3211, 3, 2, 2, 2, 3211, 3212, 3, 2,
	2, 2, 3212, 3213, 9, 40, 2, 2, 3213, 449, 3, 2, 2, 2, 3214, 3215, 9, 41,
	2, 2, 3215, 451, 3, 2, 2, 2, 3216, 3218, 7, 256, 2, 2, 3217, 3216, 3, 2,
	2, 2, 3217, 3218, 3, 2, 2, 2, 3218, 3219, 3, 2, 2, 2, 3219, 3222, 7, 205,
	2, 2, 3220, 3221, 7, 51, 2, 2, 3221, 3223, 5, 1174, 588, 2, 3222, 3220,
	3, 2, 2, 2, 3222, 3223, 3, 2, 2, 2, 3223, 453, 3, 2, 2, 2, 3224, 3226,
	7, 256, 2, 2, 3225, 3224, 3, 2, 2, 2, 3225, 3226, 3, 2, 2, 2, 3226, 3227,
	3, 2, 2, 2, 3227, 3228, 7, 225, 2, 2, 3228, 455, 3, 2, 2, 2, 3229, 3230,
	9, 42, 2, 2, 3230, 457, 3, 2, 2, 2, 3231, 3233, 9, 30, 2, 2, 3232, 3234,
	7, 413, 2, 2, 3233, 3232, 3, 2, 2, 2, 3233, 3234, 3, 2, 2, 2, 3234, 459,
	3, 2, 2, 2, 3235, 3236, 7, 323, 2, 2, 3236, 3238, 5, 1180, 591, 2, 3237,
	3239, 5, 462, 232, 2, 3238, 3237, 3, 2, 2, 2, 3238, 3239, 3, 2, 2, 2, 3239,
	3241, 3, 2, 2, 2, 3240, 3242, 7, 489, 2, 2, 3241, 3240, 3, 2, 2, 2, 3241,
	3242, 3, 2, 2, 2, 3242, 3248, 3, 2, 2, 2, 3243, 3245, 7, 136, 2, 2, 3244,
	3246, 7, 328, 2, 2, 3245, 3244, 3, 2, 2, 2, 3245, 3246, 3, 2, 2, 2, 3246,
	3247, 3, 2, 2, 2, 3247, 3249, 5, 1092, 547, 2, 3248, 3243, 3, 2, 2, 2,
	3248, 3249, 3, 2, 2, 2, 3249, 3253, 3, 2, 2, 2, 3250, 3252, 5, 464, 233,
	2, 3251, 3250, 3, 2, 2, 2, 3252, 3255, 3, 2, 2, 2, 3253, 3251, 3, 2, 2,
	2, 3253, 3254, 3, 2, 2, 2, 3254, 3268, 3, 2, 2, 2, 3255, 3253, 3, 2, 2,
	2, 3256, 3258, 7, 243, 2, 2, 3257, 3259, 7, 51, 2, 2, 3258, 3257, 3, 2,
	2, 2, 3258, 3259, 3, 2, 2, 2, 3259, 3261, 3, 2, 2, 2, 3260, 3262, 7, 286,
	2, 2, 3261, 3260, 3, 2, 2, 2, 3261, 3262, 3, 2, 2, 2, 3262, 3264, 3, 2,
	2, 2, 3263, 3265, 5, 1140, 571, 2, 3264, 3263, 3, 2, 2, 2, 3265, 3266,
	3, 2, 2, 2, 3266, 3264, 3, 2, 2, 2, 3266, 3267, 3, 2, 2, 2, 3267, 3269,
	3, 2, 2, 2, 3268, 3256, 3, 2, 2, 2, 3268, 3269, 3, 2, 2, 2, 3269, 461,
	3, 2, 2, 2, 3270, 3271, 7, 491, 2, 2, 3271, 3272, 5, 1180, 591, 2, 3272,
	463, 3, 2, 2, 2, 3273, 3275, 9, 43, 2, 2, 3274, 3276, 7, 261, 2, 2, 3275,
	3274, 3, 2, 2, 2, 3275, 3276, 3, 2, 2, 2, 3276, 3278, 3, 2, 2, 2, 3277,
	3279, 7, 256, 2, 2, 3278, 3277, 3, 2, 2, 2, 3278, 3279, 3, 2, 2, 2, 3279,
	3281, 3, 2, 2, 2, 3280, 3282, 5, 1092, 547, 2, 3281, 3280, 3, 2, 2, 2,
	3282, 3283, 3, 2, 2, 2, 3283, 3281, 3, 2, 2, 2, 3283, 3284, 3, 2, 2, 2,
	3284, 465, 3, 2, 2, 2, 3285, 3287, 9, 28, 2, 2, 3286, 3288, 7, 256, 2,
	2, 3287, 3286, 3, 2, 2, 2, 3287, 3288, 3, 2, 2, 2, 3288, 3289, 3, 2, 2,
	2, 3289, 3290, 5, 468, 235, 2, 3290, 467, 3, 2, 2, 2, 3291, 3293, 5, 470,
	236, 2, 3292, 3291, 3, 2, 2, 2, 3293, 3294, 3, 2, 2, 2, 3294, 3292, 3,
	2, 2, 2, 3294, 3295, 3, 2, 2, 2, 3295, 3297, 3, 2, 2, 2, 3296, 3298, 5,
	472, 237, 2, 3297, 3296, 3, 2, 2, 2, 3297, 3298, 3, 2, 2, 2, 3298, 3300,
	3, 2, 2, 2, 3299, 3292, 3, 2, 2, 2, 3300, 3301, 3, 2, 2, 2, 3301, 3299,
	3, 2, 2, 2, 3301, 3302, 3, 2, 2, 2, 3302, 469, 3, 2, 2, 2, 3303, 3320,
	7, 534, 2, 2, 3304, 3320, 7, 559, 2, 2, 3305, 3320, 7, 558, 2, 2, 3306,
	3320, 7, 552, 2, 2, 3307, 3320, 7, 531, 2, 2, 3308, 3320, 7, 537, 2, 2,
	3309, 3320, 7, 530, 2, 2, 3310, 3320, 7, 528, 2, 2, 3311, 3320, 7, 529,
	2, 2, 3312, 3320, 7, 544, 2, 2, 3313, 3320, 7, 551, 2, 2, 3314, 3320, 7,
	549, 2, 2, 3315, 3320, 7, 545, 2, 2, 3316, 3320, 7, 542, 2, 2, 3317, 3320,
	7, 546, 2, 2, 3318, 3320, 5, 1180, 591, 2, 3319, 3303, 3, 2, 2, 2, 3319,
	3304, 3, 2, 2, 2, 3319, 3305, 3, 2, 2, 2, 3319, 3306, 3, 2, 2, 2, 3319,
	3307, 3, 2, 2, 2, 3319, 3308, 3, 2, 2, 2, 3319, 3309, 3, 2, 2, 2, 3319,
	3310, 3, 2, 2, 2, 3319, 3311, 3, 2, 2, 2, 3319, 3312, 3, 2, 2, 2, 3319,
	3313, 3, 2, 2, 2, 3319, 3314, 3, 2, 2, 2, 3319, 3315, 3, 2, 2, 2, 3319,
	3316, 3, 2, 2, 2, 3319, 3317, 3, 2, 2, 2, 3319, 3318, 3, 2, 2, 2, 3320,
	471, 3, 2, 2, 2, 3321, 3322, 7, 544, 2, 2, 3322, 3323, 5, 1180, 591, 2,
	3323, 3324, 7, 551, 2, 2, 3324, 473, 3, 2, 2, 2, 3325, 3327, 7, 378, 2,
	2, 3326, 3325, 3, 2, 2, 2, 3326, 3327, 3, 2, 2, 2, 3327, 3329, 3, 2, 2,
	2, 3328, 3330, 7, 51, 2, 2, 3329, 3328, 3, 2, 2, 2, 3329, 3330, 3, 2, 2,
	2, 3330, 3331, 3, 2, 2, 2, 3331, 3332, 9, 44, 2, 2, 3332, 475, 3, 2, 2,
	2, 3333, 3334, 7, 379, 2, 2, 3334, 3335, 7, 24, 2, 2, 3335, 477, 3, 2,
	2, 2, 3336, 3337, 7, 383, 2, 2, 3337, 3338, 5, 1130, 566, 2, 3338, 479,
	3, 2, 2, 2, 3339, 3340, 7, 394, 2, 2, 3340, 3343, 5, 1092, 547, 2, 3341,
	3342, 9, 6, 2, 2, 3342, 3344, 5, 1092, 547, 2, 3343, 3341, 3, 2, 2, 2,
	3343, 3344, 3, 2, 2, 2, 3344, 481, 3, 2, 2, 2, 3345, 3347, 7, 440, 2, 2,
	3346, 3348, 7, 256, 2, 2, 3347, 3346, 3, 2, 2, 2, 3347, 3348, 3, 2, 2,
	2, 3348, 3350, 3, 2, 2, 2, 3349, 3345, 3, 2, 2, 2, 3349, 3350, 3, 2, 2,
	2, 3350, 3351, 3, 2, 2, 2, 3351, 3356, 9, 9, 2, 2, 3352, 3354, 7, 429,
	2, 2, 3353, 3355, 7, 64, 2, 2, 3354, 3353, 3, 2, 2, 2, 3354, 3355, 3, 2,
	2, 2, 3355, 3357, 3, 2, 2, 2, 3356, 3352, 3, 2, 2, 2, 3356, 3357, 3, 2,
	2, 2, 3357, 483, 3, 2, 2, 2, 3358, 3360, 9, 45, 2, 2, 3359, 3361, 9, 46,
	2, 2, 3360, 3359, 3, 2, 2, 2, 3360, 3361, 3, 2, 2, 2, 3361, 485, 3, 2,
	2, 2, 3362, 3364, 7, 256, 2, 2, 3363, 3362, 3, 2, 2, 2, 3363, 3364, 3,
	2, 2, 2, 3364, 3365, 3, 2, 2, 2, 3365, 3366, 7, 484, 2, 2, 3366, 487, 3,
	2, 2, 2, 3367, 3369, 7, 498, 2, 2, 3368, 3370, 7, 256, 2, 2, 3369, 3368,
	3, 2, 2, 2, 3369, 3370, 3, 2, 2, 2, 3370, 3371, 3, 2, 2, 2, 3371, 3372,
	9, 47, 2, 2, 3372, 489, 3, 2, 2, 2, 3373, 3375, 7, 256, 2, 2, 3374, 3373,
	3, 2, 2, 2, 3374, 3375, 3, 2, 2, 2, 3375, 3376, 3, 2, 2, 2, 3376, 3377,
	7, 499, 2, 2, 3377, 491, 3, 2, 2, 2, 3378, 3380, 7, 506, 2, 2, 3379, 3381,
	7, 256, 2, 2, 3380, 3379, 3, 2, 2, 2, 3380, 3381, 3, 2, 2, 2, 3381, 3383,
	3, 2, 2, 2, 3382, 3378, 3, 2, 2, 2, 3382, 3383, 3, 2, 2, 2, 3383, 3417,
	3, 2, 2, 2, 3384, 3386, 7, 44, 2, 2, 3385, 3387, 9, 48, 2, 2, 3386, 3385,
	3, 2, 2, 2, 3386, 3387, 3, 2, 2, 2, 3387, 3418, 3, 2, 2, 2, 3388, 3418,
	7, 45, 2, 2, 3389, 3418, 7, 82, 2, 2, 3390, 3418, 7, 83, 2, 2, 3391, 3418,
	7, 84, 2, 2, 3392, 3418, 7, 85, 2, 2, 3393, 3418, 7, 86, 2, 2, 3394, 3418,
	7, 87, 2, 2, 3395, 3418, 7, 88, 2, 2, 3396, 3418, 7, 89, 2, 2, 3397, 3418,
	7, 90, 2, 2, 3398, 3418, 7, 91, 2, 2, 3399, 3418, 7, 92, 2, 2, 3400, 3418,
	7, 93, 2, 2, 3401, 3418, 7, 100, 2, 2, 3402, 3418, 7, 113, 2, 2, 3403,
	3418, 7, 144, 2, 2, 3404, 3418, 7, 145, 2, 2, 3405, 3418, 7, 149, 2, 2,
	3406, 3418, 7, 196, 2, 2, 3407, 3418, 7, 221, 2, 2, 3408, 3418, 7, 242,
	2, 2, 3409, 3418, 7, 259, 2, 2, 3410, 3418, 7, 288, 2, 2, 3411, 3418, 7,
	306, 2, 2, 3412, 3418, 7, 340, 2, 2, 3413, 3418, 7, 351, 2, 2, 3414, 3418,
	7, 359, 2, 2, 3415, 3418, 7, 375, 2, 2, 3416, 3418, 7, 475, 2, 2, 3417,
	3384, 3, 2, 2, 2, 3417, 3388, 3, 2, 2, 2, 3417, 3389, 3, 2, 2, 2, 3417,
	3390, 3, 2, 2, 2, 3417, 3391, 3, 2, 2, 2, 3417, 3392, 3, 2, 2, 2, 3417,
	3393, 3, 2, 2, 2, 3417, 3394, 3, 2, 2, 2, 3417, 3395, 3, 2, 2, 2, 3417,
	3396, 3, 2, 2, 2, 3417, 3397, 3, 2, 2, 2, 3417, 3398, 3, 2, 2, 2, 3417,
	3399, 3, 2, 2, 2, 3417, 3400, 3, 2, 2, 2, 3417, 3401, 3, 2, 2, 2, 3417,
	3402, 3, 2, 2, 2, 3417, 3403, 3, 2, 2, 2, 3417, 3404, 3, 2, 2, 2, 3417,
	3405, 3, 2, 2, 2, 3417, 3406, 3, 2, 2, 2, 3417, 3407, 3, 2, 2, 2, 3417,
	3408, 3, 2, 2, 2, 3417, 3409, 3, 2, 2, 2, 3417, 3410, 3, 2, 2, 2, 3417,
	3411, 3, 2, 2, 2, 3417, 3412, 3, 2, 2, 2, 3417, 3413, 3, 2, 2, 2, 3417,
	3414, 3, 2, 2, 2, 3417, 3415, 3, 2, 2, 2, 3417, 3416, 3, 2, 2, 2, 3418,
	493, 3, 2, 2, 2, 3419, 3420, 7, 508, 2, 2, 3420, 3422, 9, 49, 2, 2, 3421,
	3423, 7, 325, 2, 2, 3422, 3421, 3, 2, 2, 2, 3422, 3423, 3, 2, 2, 2, 3423,
	3426, 3, 2, 2, 2, 3424, 3427, 5, 1172, 587, 2, 3425, 3427, 5, 1130, 566,
	2, 3426, 3424, 3, 2, 2, 2, 3426, 3425, 3, 2, 2, 2, 3427, 495, 3, 2, 2,
	2, 3428, 3430, 7, 509, 2, 2, 3429, 3431, 7, 256, 2, 2, 3430, 3429, 3, 2,
	2, 2, 3430, 3431, 3, 2, 2, 2, 3431, 3437, 3, 2, 2, 2, 3432, 3434, 7, 510,
	2, 2, 3433, 3435, 7, 23, 2, 2, 3434, 3433, 3, 2, 2, 2, 3434, 3435, 3, 2,
	2, 2, 3435, 3437, 3, 2, 2, 2, 3436, 3428, 3, 2, 2, 2, 3436, 3432, 3, 2,
	2, 2, 3436, 3437, 3, 2, 2, 2, 3437, 3438, 3, 2, 2, 2, 3438, 3445, 5, 498,
	250, 2, 3439, 3441, 7, 531, 2, 2, 3440, 3439, 3, 2, 2, 2, 3440, 3441, 3,
	2, 2, 2, 3441, 3442, 3, 2, 2, 2, 3442, 3444, 5, 498, 250, 2, 3443, 3440,
	3, 2, 2, 2, 3444, 3447, 3, 2, 2, 2, 3445, 3443, 3, 2, 2, 2, 3445, 3446,
	3, 2, 2, 2, 3446, 497, 3, 2, 2, 2, 3447, 3445, 3, 2, 2, 2, 3448, 3450,
	5, 500, 251, 2, 3449, 3451, 5, 502, 252, 2, 3450, 3449, 3, 2, 2, 2, 3450,
	3451, 3, 2, 2, 2, 3451, 499, 3, 2, 2, 2, 3452, 3455, 5, 1174, 588, 2, 3453,
	3455, 5, 1172, 587, 2, 3454, 3452, 3, 2, 2, 2, 3454, 3453, 3, 2, 2, 2,
	3455, 501, 3, 2, 2, 2, 3456, 3457, 9, 6, 2, 2, 3457, 3458, 5, 1174, 588,
	2, 3458, 503, 3, 2, 2, 2, 3459, 3461, 7, 516, 2, 2, 3460, 3459, 3, 2, 2,
	2, 3460, 3461, 3, 2, 2, 2, 3461, 3462, 3, 2, 2, 2, 3462, 3463, 7, 291,
	2, 2, 3463, 3464, 7, 49, 2, 2, 3464, 505, 3, 2, 2, 2, 3465, 3466, 7, 358,
	2, 2, 3466, 3468, 7, 147, 2, 2, 3467, 3469, 5, 508, 255, 2, 3468, 3467,
	3, 2, 2, 2, 3468, 3469, 3, 2, 2, 2, 3469, 3471, 3, 2, 2, 2, 3470, 3472,
	5, 510, 256, 2, 3471, 3470, 3, 2, 2, 2, 3471, 3472, 3, 2, 2, 2, 3472, 3473,
	3, 2, 2, 2, 3473, 3475, 7, 536, 2, 2, 3474, 3476, 5, 522, 262, 2, 3475,
	3474, 3, 2, 2, 2, 3475, 3476, 3, 2, 2, 2, 3476, 3477, 3, 2, 2, 2, 3477,
	3478, 5, 528, 265, 2, 3478, 507, 3, 2, 2, 2, 3479, 3481, 9, 50, 2, 2, 3480,
	3482, 5, 512, 257, 2, 3481, 3480, 3, 2, 2, 2, 3482, 3483, 3, 2, 2, 2, 3483,
	3481, 3, 2, 2, 2, 3483, 3484, 3, 2, 2, 2, 3484, 509, 3, 2, 2, 2, 3485,
	3486, 9, 51, 2, 2, 3486, 3487, 5, 1130, 566, 2, 3487, 511, 3, 2, 2, 2,
	3488, 3491, 5, 514, 258, 2, 3489, 3491, 5, 518, 260, 2, 3490, 3488, 3,
	2, 2, 2, 3490, 3489, 3, 2, 2, 2, 3491, 513, 3, 2, 2, 2, 3492, 3494, 7,
	51, 2, 2, 3493, 3492, 3, 2, 2, 2, 3493, 3494, 3, 2, 2, 2, 3494, 3495, 3,
	2, 2, 2, 3495, 3497, 7, 386, 2, 2, 3496, 3493, 3, 2, 2, 2, 3496, 3497,
	3, 2, 2, 2, 3497, 3499, 3, 2, 2, 2, 3498, 3500, 5, 516, 259, 2, 3499, 3498,
	3, 2, 2, 2, 3500, 3501, 3, 2, 2, 2, 3501, 3499, 3, 2, 2, 2, 3501, 3502,
	3, 2, 2, 2, 3502, 515, 3, 2, 2, 2, 3503, 3505, 7, 330, 2, 2, 3504, 3503,
	3, 2, 2, 2, 3504, 3505, 3, 2, 2, 2, 3505, 3508, 3, 2, 2, 2, 3506, 3509,
	5, 1076, 539, 2, 3507, 3509, 5, 1136, 569, 2, 3508, 3506, 3, 2, 2, 2, 3508,
	3507, 3, 2, 2, 2, 3509, 3512, 3, 2, 2, 2, 3510, 3512, 7, 22, 2, 2, 3511,
	3504, 3, 2, 2, 2, 3511, 3510, 3, 2, 2, 2, 3512, 517, 3, 2, 2, 2, 3513,
	3515, 7, 51, 2, 2, 3514, 3513, 3, 2, 2, 2, 3514, 3515, 3, 2, 2, 2, 3515,
	3516, 3, 2, 2, 2, 3516, 3518, 7, 509, 2, 2, 3517, 3519, 5, 520, 261, 2,
	3518, 3517, 3, 2, 2, 2, 3519, 3520, 3, 2, 2, 2, 3520, 3518, 3, 2, 2, 2,
	3520, 3521, 3, 2, 2, 2, 3521, 519, 3, 2, 2, 2, 3522, 3526, 5, 1076, 539,
	2, 3523, 3526, 5, 1174, 588, 2, 3524, 3526, 7, 22, 2, 2, 3525, 3522, 3,
	2, 2, 2, 3525, 3523, 3, 2, 2, 2, 3525, 3524, 3, 2, 2, 2, 3526, 521, 3,
	2, 2, 2, 3527, 3528, 7, 129, 2, 2, 3528, 3530, 7, 536, 2, 2, 3529, 3531,
	5, 524, 263, 2, 3530, 3529, 3, 2, 2, 2, 3531, 3532, 3, 2, 2, 2, 3532, 3530,
	3, 2, 2, 2, 3532, 3533, 3, 2, 2, 2, 3533, 3534, 3, 2, 2, 2, 3534, 3535,
	7, 160, 2, 2, 3535, 3536, 7, 129, 2, 2, 3536, 3537, 7, 536, 2, 2, 3537,
	523, 3, 2, 2, 2, 3538, 3539, 5, 526, 264, 2, 3539, 3540, 7, 536, 2, 2,
	3540, 3541, 5, 988, 495, 2, 3541, 3542, 7, 536, 2, 2, 3542, 3543, 5, 532,
	267, 2, 3543, 525, 3, 2, 2, 2, 3544, 3545, 5, 1164, 583, 2, 3545, 3547,
	7, 421, 2, 2, 3546, 3548, 5, 1180, 591, 2, 3547, 3546, 3, 2, 2, 2, 3547,
	3548, 3, 2, 2, 2, 3548, 527, 3, 2, 2, 2, 3549, 3553, 5, 532, 267, 2, 3550,
	3552, 5, 530, 266, 2, 3551, 3550, 3, 2, 2, 2, 3552, 3555, 3, 2, 2, 2, 3553,
	3551, 3, 2, 2, 2, 3553, 3554, 3, 2, 2, 2, 3554, 529, 3, 2, 2, 2, 3555,
	3553, 3, 2, 2, 2, 3556, 3557, 5, 526, 264, 2, 3557, 3558, 7, 536, 2, 2,
	3558, 3559, 5, 532, 267, 2, 3559, 531, 3, 2, 2, 2, 3560, 3562, 5, 536,
	269, 2, 3561, 3560, 3, 2, 2, 2, 3562, 3565, 3, 2, 2, 2, 3563, 3561, 3,
	2, 2, 2, 3563, 3564, 3, 2, 2, 2, 3564, 3569, 3, 2, 2, 2, 3565, 3563, 3,
	2, 2, 2, 3566, 3568, 5, 534, 268, 2, 3567, 3566, 3, 2, 2, 2, 3568, 3571,
	3, 2, 2, 2, 3569, 3567, 3, 2, 2, 2, 3569, 3570, 3, 2, 2, 2, 3570, 533,
	3, 2, 2, 2, 3571, 3569, 3, 2, 2, 2, 3572, 3573, 5, 1150, 576, 2, 3573,
	3581, 7, 536, 2, 2, 3574, 3582, 5, 566, 284, 2, 3575, 3577, 5, 536, 269,
	2, 3576, 3575, 3, 2, 2, 2, 3577, 3580, 3, 2, 2, 2, 3578, 3576, 3, 2, 2,
	2, 3578, 3579, 3, 2, 2, 2, 3579, 3582, 3, 2, 2, 2, 3580, 3578, 3, 2, 2,
	2, 3581, 3574, 3, 2, 2, 2, 3581, 3578, 3, 2, 2, 2, 3582, 535, 3, 2, 2,
	2, 3583, 3585, 5, 538, 270, 2, 3584, 3583, 3, 2, 2, 2, 3585, 3588, 3, 2,
	2, 2, 3586, 3584, 3, 2, 2, 2, 3586, 3587, 3, 2, 2, 2, 3587, 3589, 3, 2,
	2, 2, 3588, 3586, 3, 2, 2, 2, 3589, 3590, 7, 536, 2, 2, 3590, 537, 3, 2,
	2, 2, 3591, 3641, 5, 540, 271, 2, 3592, 3641, 5, 550, 276, 2, 3593, 3641,
	5, 568, 285, 2, 3594, 3641, 5, 572, 287, 2, 3595, 3641, 5, 592, 297, 2,
	3596, 3641, 5, 596, 299, 2, 3597, 3641, 5, 614, 308, 2, 3598, 3641, 5,
	618, 310, 2, 3599, 3641, 5, 620, 311, 2, 3600, 3641, 5, 622, 312, 2, 3601,
	3641, 5, 624, 313, 2, 3602, 3641, 5, 634, 318, 2, 3603, 3641, 5, 650, 326,
	2, 3604, 3641, 5, 652, 327, 2, 3605, 3641, 5, 654, 328, 2, 3606, 3641,
	5, 680, 341, 2, 3607, 3641, 5, 674, 338, 2, 3608, 3641, 5, 676, 339, 2,
	3609, 3641, 5, 678, 340, 2, 3610, 3641, 5, 684, 343, 2, 3611, 3641, 5,
	686, 344, 2, 3612, 3641, 5, 688, 345, 2, 3613, 3641, 5, 690, 346, 2, 3614,
	3641, 5, 696, 349, 2, 3615, 3641, 5, 702, 352, 2, 3616, 3641, 5, 708, 355,
	2, 3617, 3641, 5, 710, 356, 2, 3618, 3641, 5, 740, 371, 2, 3619, 3641,
	5, 760, 381, 2, 3620, 3641, 5, 770, 386, 2, 3621, 3641, 5, 782, 392, 2,
	3622, 3641, 5, 796, 399, 2, 3623, 3641, 5, 822, 412, 2, 3624, 3641, 5,
	824, 413, 2, 3625, 3641, 5, 832, 417, 2, 3626, 3641, 5, 854, 428, 2, 3627,
	3641, 5, 856, 429, 2, 3628, 3641, 5, 860, 431, 2, 3629, 3641, 5, 864, 433,
	2, 3630, 3641, 5, 870, 436, 2, 3631, 3641, 5, 890, 446, 2, 3632, 3641,
	5, 902, 452, 2, 3633, 3641, 5, 928, 465, 2, 3634, 3641, 5, 932, 467, 2,
	3635, 3641, 5, 934, 468, 2, 3636, 3641, 5, 948, 475, 2, 3637, 3641, 5,
	966, 484, 2, 3638, 3641, 5, 968, 485, 2, 3639, 3641, 5, 998, 500, 2, 3640,
	3591, 3, 2, 2, 2, 3640, 3592, 3, 2, 2, 2, 3640, 3593, 3, 2, 2, 2, 3640,
	3594, 3, 2, 2, 2, 3640, 3595, 3, 2, 2, 2, 3640, 3596, 3, 2, 2, 2, 3640,
	3597, 3, 2, 2, 2, 3640, 3598, 3, 2, 2, 2, 3640, 3599, 3, 2, 2, 2, 3640,
	3600, 3, 2, 2, 2, 3640, 3601, 3, 2, 2, 2, 3640, 3602, 3, 2, 2, 2, 3640,
	3603, 3, 2, 2, 2, 3640, 3604, 3, 2, 2, 2, 3640, 3605, 3, 2, 2, 2, 3640,
	3606, 3, 2, 2, 2, 3640, 3607, 3, 2, 2, 2, 3640, 3608, 3, 2, 2, 2, 3640,
	3609, 3, 2, 2, 2, 3640, 3610, 3, 2, 2, 2, 3640, 3611, 3, 2, 2, 2, 3640,
	3612, 3, 2, 2, 2, 3640, 3613, 3, 2, 2, 2, 3640, 3614, 3, 2, 2, 2, 3640,
	3615, 3, 2, 2, 2, 3640, 3616, 3, 2, 2, 2, 3640, 3617, 3, 2, 2, 2, 3640,
	3618, 3, 2, 2, 2, 3640, 3619, 3, 2, 2, 2, 3640, 3620, 3, 2, 2, 2, 3640,
	3621, 3, 2, 2, 2, 3640, 3622, 3, 2, 2, 2, 3640, 3623, 3, 2, 2, 2, 3640,
	3624, 3, 2, 2, 2, 3640, 3625, 3, 2, 2, 2, 3640, 3626, 3, 2, 2, 2, 3640,
	3627, 3, 2, 2, 2, 3640, 3628, 3, 2, 2, 2, 3640, 3629, 3, 2, 2, 2, 3640,
	3630, 3, 2, 2, 2, 3640, 3631, 3, 2, 2, 2, 3640, 3632, 3, 2, 2, 2, 3640,
	3633, 3, 2, 2, 2, 3640, 3634, 3, 2, 2, 2, 3640, 3635, 3, 2, 2, 2, 3640,
	3636, 3, 2, 2, 2, 3640, 3637, 3, 2, 2, 2, 3640, 3638, 3, 2, 2, 2, 3640,
	3639, 3, 2, 2, 2, 3641, 539, 3, 2, 2, 2, 3642, 3643, 7, 4, 2, 2, 3643,
	3648, 5, 1076, 539, 2, 3644, 3649, 5, 542, 272, 2, 3645, 3649, 5, 546,
	274, 2, 3646, 3649, 5, 544, 273, 2, 3647, 3649, 5, 548, 275, 2, 3648, 3644,
	3, 2, 2, 2, 3648, 3645, 3, 2, 2, 2, 3648, 3646, 3, 2, 2, 2, 3648, 3647,
	3, 2, 2, 2, 3648, 3649, 3, 2, 2, 2, 3649, 3651, 3, 2, 2, 2, 3650, 3652,
	5, 1030, 516, 2, 3651, 3650, 3, 2, 2, 2, 3651, 3652, 3, 2, 2, 2, 3652,
	3654, 3, 2, 2, 2, 3653, 3655, 5, 1032, 517, 2, 3654, 3653, 3, 2, 2, 2,
	3654, 3655, 3, 2, 2, 2, 3655, 3657, 3, 2, 2, 2, 3656, 3658, 7, 161, 2,
	2, 3657, 3656, 3, 2, 2, 2, 3657, 3658, 3, 2, 2, 2, 3658, 541, 3, 2, 2,
	2, 3659, 3679, 7, 217, 2, 2, 3660, 3662, 7, 113, 2, 2, 3661, 3663, 7, 521,
	2, 2, 3662, 3661, 3, 2, 2, 2, 3662, 3663, 3, 2, 2, 2, 3663, 3680, 3, 2,
	2, 2, 3664, 3666, 7, 116, 2, 2, 3665, 3667, 7, 522, 2, 2, 3666, 3665, 3,
	2, 2, 2, 3666, 3667, 3, 2, 2, 2, 3667, 3680, 3, 2, 2, 2, 3668, 3680, 7,
	117, 2, 2, 3669, 3680, 7, 487, 2, 2, 3670, 3680, 7, 488, 2, 2, 3671, 3673,
	7, 492, 2, 2, 3672, 3674, 7, 298, 2, 2, 3673, 3672, 3, 2, 2, 2, 3673, 3674,
	3, 2, 2, 2, 3674, 3680, 3, 2, 2, 2, 3675, 3680, 7, 493, 2, 2, 3676, 3680,
	7, 520, 2, 2, 3677, 3680, 7, 521, 2, 2, 3678, 3680, 7, 522, 2, 2, 3679,
	3660, 3, 2, 2, 2, 3679, 3664, 3, 2, 2, 2, 3679, 3668, 3, 2, 2, 2, 3679,
	3669, 3, 2, 2, 2, 3679, 3670, 3, 2, 2, 2, 3679, 3671, 3, 2, 2, 2, 3679,
	3675, 3, 2, 2, 2, 3679, 3676, 3, 2, 2, 2, 3679, 3677, 3, 2, 2, 2, 3679,
	3678, 3, 2, 2, 2, 3680, 543, 3, 2, 2, 2, 3681, 3682, 7, 217, 2, 2, 3682,
	3683, 5, 1148, 575, 2, 3683, 545, 3, 2, 2, 2, 3684, 3685, 7, 217, 2, 2,
	3685, 3686, 7, 193, 2, 2, 3686, 3687, 7, 261, 2, 2, 3687, 547, 3, 2, 2,
	2, 3688, 3690, 7, 297, 2, 2, 3689, 3688, 3, 2, 2, 2, 3689, 3690, 3, 2,
	2, 2, 3690, 3691, 3, 2, 2, 2, 3691, 3692, 7, 107, 2, 2, 3692, 549, 3, 2,
	2, 2, 3693, 3697, 7, 6, 2, 2, 3694, 3698, 5, 552, 277, 2, 3695, 3698, 5,
	554, 278, 2, 3696, 3698, 5, 556, 279, 2, 3697, 3694, 3, 2, 2, 2, 3697,
	3695, 3, 2, 2, 2, 3697, 3696, 3, 2, 2, 2, 3698, 3700, 3, 2, 2, 2, 3699,
	3701, 5, 1026, 514, 2, 3700, 3699, 3, 2, 2, 2, 3700, 3701, 3, 2, 2, 2,
	3701, 3703, 3, 2, 2, 2, 3702, 3704, 5, 1028, 515, 2, 3703, 3702, 3, 2,
	2, 2, 3703, 3704, 3, 2, 2, 2, 3704, 3706, 3, 2, 2, 2, 3705, 3707, 7, 162,
	2, 2, 3706, 3705, 3, 2, 2, 2, 3706, 3707, 3, 2, 2, 2, 3707, 551, 3, 2,
	2, 2, 3708, 3710, 5, 558, 280, 2, 3709, 3708, 3, 2, 2, 2, 3710, 3711, 3,
	2, 2, 2, 3711, 3709, 3, 2, 2, 2, 3711, 3712, 3, 2, 2, 2, 3712, 3713, 3,
	2, 2, 2, 3713, 3715, 7, 491, 2, 2, 3714, 3716, 5, 560, 281, 2, 3715, 3714,
	3, 2, 2, 2, 3716, 3717, 3, 2, 2, 2, 3717, 3715, 3, 2, 2, 2, 3717, 3718,
	3, 2, 2, 2, 3718, 553, 3, 2, 2, 2, 3719, 3721, 5, 558, 280, 2, 3720, 3719,
	3, 2, 2, 2, 3721, 3722, 3, 2, 2, 2, 3722, 3720, 3, 2, 2, 2, 3722, 3723,
	3, 2, 2, 2, 3723, 3730, 3, 2, 2, 2, 3724, 3726, 7, 491, 2, 2, 3725, 3727,
	5, 562, 282, 2, 3726, 3725, 3, 2, 2, 2, 3727, 3728, 3, 2, 2, 2, 3728, 3726,
	3, 2, 2, 2, 3728, 3729, 3, 2, 2, 2, 3729, 3731, 3, 2, 2, 2, 3730, 3724,
	3, 2, 2, 2, 3730, 3731, 3, 2, 2, 2, 3731, 3732, 3, 2, 2, 2, 3732, 3734,
	7, 224, 2, 2, 3733, 3735, 5, 564, 283, 2, 3734, 3733, 3, 2, 2, 2, 3735,
	3736, 3, 2, 2, 2, 3736, 3734, 3, 2, 2, 2, 3736, 3737, 3, 2, 2, 2, 3737,
	555, 3, 2, 2, 2, 3738, 3739, 9, 52, 2, 2, 3739, 3740, 5, 1076, 539, 2,
	3740, 3741, 7, 491, 2, 2, 3741, 3742, 5, 560, 281, 2, 3742, 557, 3, 2,
	2, 2, 3743, 3746, 5, 1076, 539, 2, 3744, 3746, 5, 1174, 588, 2, 3745, 3743,
	3, 2, 2, 2, 3745, 3744, 3, 2, 2, 2, 3746, 559, 3, 2, 2, 2, 3747, 3749,
	5, 1076, 539, 2, 3748, 3750, 7, 414, 2, 2, 3749, 3748, 3, 2, 2, 2, 3749,
	3750, 3, 2, 2, 2, 3750, 561, 3, 2, 2, 2, 3751, 3754, 5, 1076, 539, 2, 3752,
	3754, 5, 1174, 588, 2, 3753, 3751, 3, 2, 2, 2, 3753, 3752, 3, 2, 2, 2,
	3754, 563, 3, 2, 2, 2, 3755, 3757, 5, 1076, 539, 2, 3756, 3758, 7, 414,
	2, 2, 3757, 3756, 3, 2, 2, 2, 3757, 3758, 3, 2, 2, 2, 3758, 565, 3, 2,
	2, 2, 3759, 3761, 7, 226, 2, 2, 3760, 3762, 7, 491, 2, 2, 3761, 3760, 3,
	2, 2, 2, 3761, 3762, 3, 2, 2, 2, 3762, 3763, 3, 2, 2, 2, 3763, 3764, 7,
	536, 2, 2, 3764, 567, 3, 2, 2, 2, 3765, 3767, 7, 19, 2, 2, 3766, 3768,
	5, 570, 286, 2, 3767, 3766, 3, 2, 2, 2, 3768, 3769, 3, 2, 2, 2, 3769, 3767,
	3, 2, 2, 2, 3769, 3770, 3, 2, 2, 2, 3770, 569, 3, 2, 2, 2, 3771, 3772,
	5, 1152, 577, 2, 3772, 3775, 7, 491, 2, 2, 3773, 3774, 7, 361, 2, 2, 3774,
	3776, 7, 491, 2, 2, 3775, 3773, 3, 2, 2, 2, 3775, 3776, 3, 2, 2, 2, 3776,
	3777, 3, 2, 2, 2, 3777, 3778, 5, 1152, 577, 2, 3778, 571, 3, 2, 2, 2, 3779,
	3782, 7, 54, 2, 2, 3780, 3783, 5, 1076, 539, 2, 3781, 3783, 5, 1174, 588,
	2, 3782, 3780, 3, 2, 2, 2, 3782, 3781, 3, 2, 2, 2, 3783, 3785, 3, 2, 2,
	2, 3784, 3786, 5, 574, 288, 2, 3785, 3784, 3, 2, 2, 2, 3785, 3786, 3, 2,
	2, 2, 3786, 3788, 3, 2, 2, 2, 3787, 3789, 5, 590, 296, 2, 3788, 3787, 3,
	2, 2, 2, 3788, 3789, 3, 2, 2, 2, 3789, 3791, 3, 2, 2, 2, 3790, 3792, 5,
	1022, 512, 2, 3791, 3790, 3, 2, 2, 2, 3791, 3792, 3, 2, 2, 2, 3792, 3794,
	3, 2, 2, 2, 3793, 3795, 5, 1030, 516, 2, 3794, 3793, 3, 2, 2, 2, 3794,
	3795, 3, 2, 2, 2, 3795, 3797, 3, 2, 2, 2, 3796, 3798, 5, 1032, 517, 2,
	3797, 3796, 3, 2, 2, 2, 3797, 3798, 3, 2, 2, 2, 3798, 3800, 3, 2, 2, 2,
	3799, 3801, 7, 163, 2, 2, 3800, 3799, 3, 2, 2, 2, 3800, 3801, 3, 2, 2,
	2, 3801, 573, 3, 2, 2, 2, 3802, 3804, 7, 508, 2, 2, 3803, 3805, 5, 576,
	289, 2, 3804, 3803, 3, 2, 2, 2, 3805, 3806, 3, 2, 2, 2, 3806, 3804, 3,
	2, 2, 2, 3806, 3807, 3, 2, 2, 2, 3807, 575, 3, 2, 2, 2, 3808, 3812, 5,
	578, 290, 2, 3809, 3812, 5, 582, 292, 2, 3810, 3812, 5, 586, 294, 2, 3811,
	3808, 3, 2, 2, 2, 3811, 3809, 3, 2, 2, 2, 3811, 3810, 3, 2, 2, 2, 3812,
	577, 3, 2, 2, 2, 3813, 3815, 7, 51, 2, 2, 3814, 3813, 3, 2, 2, 2, 3814,
	3815, 3, 2, 2, 2, 3815, 3816, 3, 2, 2, 2, 3816, 3818, 7, 386, 2, 2, 3817,
	3814, 3, 2, 2, 2, 3817, 3818, 3, 2, 2, 2, 3818, 3820, 3, 2, 2, 2, 3819,
	3821, 5, 580, 291, 2, 3820, 3819, 3, 2, 2, 2, 3821, 3822, 3, 2, 2, 2, 3822,
	3820, 3, 2, 2, 2, 3822, 3823, 3, 2, 2, 2, 3823, 579, 3, 2, 2, 2, 3824,
	3825, 7, 7, 2, 2, 3825, 3829, 7, 325, 2, 2, 3826, 3829, 7, 252, 2, 2, 3827,
	3829, 7, 461, 2, 2, 3828, 3824, 3, 2, 2, 2, 3828, 3826, 3, 2, 2, 2, 3828,
	3827, 3, 2, 2, 2, 3828, 3829, 3, 2, 2, 2, 3829, 3830, 3, 2, 2, 2, 3830,
	3834, 5, 1076, 539, 2, 3831, 3834, 5, 1174, 588, 2, 3832, 3834, 5, 1136,
	569, 2, 3833, 3828, 3, 2, 2, 2, 3833, 3831, 3, 2, 2, 2, 3833, 3832, 3,
	2, 2, 2, 3834, 3837, 3, 2, 2, 2, 3835, 3837, 7, 327, 2, 2, 3836, 3833,
	3, 2, 2, 2, 3836, 3835, 3, 2, 2, 2, 3837, 581, 3, 2, 2, 2, 3838, 3840,
	7, 51, 2, 2, 3839, 3838, 3, 2, 2, 2, 3839, 3840, 3, 2, 2, 2, 3840, 3841,
	3, 2, 2, 2, 3841, 3843, 7, 509, 2, 2, 3842, 3844, 5, 584, 293, 2, 3843,
	3842, 3, 2, 2, 2, 3844, 3845, 3, 2, 2, 2, 3845, 3843, 3, 2, 2, 2, 3845,
	3846, 3, 2, 2, 2, 3846, 583, 3, 2, 2, 2, 3847, 3848, 7, 7, 2, 2, 3848,
	3854, 7, 325, 2, 2, 3849, 3851, 7, 271, 2, 2, 3850, 3852, 7, 325, 2, 2,
	3851, 3850, 3, 2, 2, 2, 3851, 3852, 3, 2, 2, 2, 3852, 3854, 3, 2, 2, 2,
	3853, 3847, 3, 2, 2, 2, 3853, 3849, 3, 2, 2, 2, 3853, 3854, 3, 2, 2, 2,
	3854, 3857, 3, 2, 2, 2, 3855, 3858, 5, 1076, 539, 2, 3856, 3858, 5, 1174,
	588, 2, 3857, 3855, 3, 2, 2, 2, 3857, 3856, 3, 2, 2, 2, 3858, 585, 3, 2,
	2, 2, 3859, 3861, 7, 51, 2, 2, 3860, 3859, 3, 2, 2, 2, 3860, 3861, 3, 2,
	2, 2, 3861, 3862, 3, 2, 2, 2, 3862, 3864, 7, 97, 2, 2, 3863, 3865, 5, 588,
	295, 2, 3864, 3863, 3, 2, 2, 2, 3865, 3866, 3, 2, 2, 2, 3866, 3864, 3,
	2, 2, 2, 3866, 3867, 3, 2, 2, 2, 3867, 587, 3, 2, 2, 2, 3868, 3869, 7,
	7, 2, 2, 3869, 3875, 7, 325, 2, 2, 3870, 3872, 7, 271, 2, 2, 3871, 3873,
	7, 325, 2, 2, 3872, 3871, 3, 2, 2, 2, 3872, 3873, 3, 2, 2, 2, 3873, 3875,
	3, 2, 2, 2, 3874, 3868, 3, 2, 2, 2, 3874, 3870, 3, 2, 2, 2, 3874, 3875,
	3, 2, 2, 2, 3875, 3876, 3, 2, 2, 2, 3876, 3880, 5, 1076, 539, 2, 3877,
	3880, 5, 1174, 588, 2, 3878, 3880, 7, 327, 2, 2, 3879, 3874, 3, 2, 2, 2,
	3879, 3877, 3, 2, 2, 2, 3879, 3878, 3, 2, 2, 2, 3880, 589, 3, 2, 2, 2,
	3881, 3882, 9, 51, 2, 2, 3882, 3883, 5, 1076, 539, 2, 3883, 591, 3, 2,
	2, 2, 3884, 3886, 7, 55, 2, 2, 3885, 3887, 5, 594, 298, 2, 3886, 3885,
	3, 2, 2, 2, 3887, 3888, 3, 2, 2, 2, 3888, 3886, 3, 2, 2, 2, 3888, 3889,
	3, 2, 2, 2, 3889, 593, 3, 2, 2, 2, 3890, 3891, 5, 1144, 573, 2, 3891, 3892,
	9, 38, 2, 2, 3892, 3896, 3, 2, 2, 2, 3893, 3896, 5, 1076, 539, 2, 3894,
	3896, 5, 1174, 588, 2, 3895, 3890, 3, 2, 2, 2, 3895, 3893, 3, 2, 2, 2,
	3895, 3894, 3, 2, 2, 2, 3896, 595, 3, 2, 2, 2, 3897, 3899, 7, 69, 2, 2,
	3898, 3900, 5, 598, 300, 2, 3899, 3898, 3, 2, 2, 2, 3900, 3901, 3, 2, 2,
	2, 3901, 3899, 3, 2, 2, 2, 3901, 3902, 3, 2, 2, 2, 3902, 597, 3, 2, 2,
	2, 3903, 3907, 5, 1136, 569, 2, 3904, 3908, 5, 600, 301, 2, 3905, 3908,
	5, 602, 302, 2, 3906, 3908, 5, 604, 303, 2, 3907, 3904, 3, 2, 2, 2, 3907,
	3905, 3, 2, 2, 2, 3907, 3906, 3, 2, 2, 2, 3907, 3908, 3, 2, 2, 2, 3908,
	599, 3, 2, 2, 2, 3909, 3914, 9, 14, 2, 2, 3910, 3912, 7, 214, 2, 2, 3911,
	3910, 3, 2, 2, 2, 3911, 3912, 3, 2, 2, 2, 3912, 3913, 3, 2, 2, 2, 3913,
	3915, 7, 392, 2, 2, 3914, 3911, 3, 2, 2, 2, 3914, 3915, 3, 2, 2, 2, 3915,
	3924, 3, 2, 2, 2, 3916, 3918, 7, 516, 2, 2, 3917, 3916, 3, 2, 2, 2, 3917,
	3918, 3, 2, 2, 2, 3918, 3922, 3, 2, 2, 2, 3919, 3920, 7, 312, 2, 2, 3920,
	3923, 7, 409, 2, 2, 3921, 3923, 7, 288, 2, 2, 3922, 3919, 3, 2, 2, 2, 3922,
	3921, 3, 2, 2, 2, 3923, 3925, 3, 2, 2, 2, 3924, 3917, 3, 2, 2, 2, 3924,
	3925, 3, 2, 2, 2, 3925, 601, 3, 2, 2, 2, 3926, 3928, 7, 516, 2, 2, 3927,
	3926, 3, 2, 2, 2, 3927, 3928, 3, 2, 2, 2, 3928, 3932, 3, 2, 2, 2, 3929,
	3930, 7, 312, 2, 2, 3930, 3933, 7, 409, 2, 2, 3931, 3933, 7, 288, 2, 2,
	3932, 3929, 3, 2, 2, 2, 3932, 3931, 3, 2, 2, 2, 3933, 603, 3, 2, 2, 2,
	3934, 3936, 7, 516, 2, 2, 3935, 3934, 3, 2, 2, 2, 3935, 3936, 3, 2, 2,
	2, 3936, 3937, 3, 2, 2, 2, 3937, 3938, 7, 312, 2, 2, 3938, 3942, 7, 513,
	2, 2, 3939, 3940, 7, 516, 2, 2, 3940, 3942, 7, 513, 2, 2, 3941, 3935, 3,
	2, 2, 2, 3941, 3939, 3, 2, 2, 2, 3942, 3949, 3, 2, 2, 2, 3943, 3945, 7,
	508, 2, 2, 3944, 3946, 5, 606, 304, 2, 3945, 3944, 3, 2, 2, 2, 3946, 3947,
	3, 2, 2, 2, 3947, 3945, 3, 2, 2, 2, 3947, 3948, 3, 2, 2, 2, 3948, 3950,
	3, 2, 2, 2, 3949, 3943, 3, 2, 2, 2, 3949, 3950, 3, 2, 2, 2, 3950, 605,
	3, 2, 2, 2, 3951, 3955, 5, 608, 305, 2, 3952, 3955, 5, 610, 306, 2, 3953,
	3955, 5, 612, 307, 2, 3954, 3951, 3, 2, 2, 2, 3954, 3952, 3, 2, 2, 2, 3954,
	3953, 3, 2, 2, 2, 3955, 607, 3, 2, 2, 2, 3956, 3958, 7, 70, 2, 2, 3957,
	3959, 7, 325, 2, 2, 3958, 3957, 3, 2, 2, 2, 3958, 3959, 3, 2, 2, 2, 3959,
	3960, 3, 2, 2, 2, 3960, 3961, 9, 53, 2, 2, 3961, 609, 3, 2, 2, 2, 3962,
	3965, 7, 30, 2, 2, 3963, 3966, 5, 1076, 539, 2, 3964, 3966, 5, 1180, 591,
	2, 3965, 3963, 3, 2, 2, 2, 3965, 3964, 3, 2, 2, 2, 3966, 611, 3, 2, 2,
	2, 3967, 3969, 7, 31, 2, 2, 3968, 3970, 7, 325, 2, 2, 3969, 3968, 3, 2,
	2, 2, 3969, 3970, 3, 2, 2, 2, 3970, 3973, 3, 2, 2, 2, 3971, 3974, 5, 1076,
	539, 2, 3972, 3974, 5, 1180, 591, 2, 3973, 3971, 3, 2, 2, 2, 3973, 3972,
	3, 2, 2, 2, 3974, 613, 3, 2, 2, 2, 3975, 3977, 7, 94, 2, 2, 3976, 3978,
	5, 616, 309, 2, 3977, 3976, 3, 2, 2, 2, 3978, 3979, 3, 2, 2, 2, 3979, 3977,
	3, 2, 2, 2, 3979, 3980, 3, 2, 2, 2, 3980, 3981, 3, 2, 2, 2, 3981, 3982,
	9, 54, 2, 2, 3982, 3984, 5, 1034, 518, 2, 3983, 3985, 5, 1026, 514, 2,
	3984, 3983, 3, 2, 2, 2, 3984, 3985, 3, 2, 2, 2, 3985, 3987, 3, 2, 2, 2,
	3986, 3988, 5, 1028, 515, 2, 3987, 3986, 3, 2, 2, 2, 3987, 3988, 3, 2,
	2, 2, 3988, 3990, 3, 2, 2, 2, 3989, 3991, 7, 164, 2, 2, 3990, 3989, 3,
	2, 2, 2, 3990, 3991, 3, 2, 2, 2, 3991, 615, 3, 2, 2, 2, 3992, 3994, 5,
	1076, 539, 2, 3993, 3995, 7, 414, 2, 2, 3994, 3993, 3, 2, 2, 2, 3994, 3995,
	3, 2, 2, 2, 3995, 617, 3, 2, 2, 2, 3996, 3997, 7, 98, 2, 2, 3997, 619,
	3, 2, 2, 2, 3998, 3999, 7, 133, 2, 2, 3999, 4001, 5, 1136, 569, 2, 4000,
	4002, 7, 379, 2, 2, 4001, 4000, 3, 2, 2, 2, 4001, 4002, 3, 2, 2, 2, 4002,
	4004, 3, 2, 2, 2, 4003, 4005, 5, 1018, 510, 2, 4004, 4003, 3, 2, 2, 2,
	4004, 4005, 3, 2, 2, 2, 4005, 4007, 3, 2, 2, 2, 4006, 4008, 5, 1020, 511,
	2, 4007, 4006, 3, 2, 2, 2, 4007, 4008, 3, 2, 2, 2, 4008, 4010, 3, 2, 2,
	2, 4009, 4011, 7, 165, 2, 2, 4010, 4009, 3, 2, 2, 2, 4010, 4011, 3, 2,
	2, 2, 4011, 621, 3, 2, 2, 2, 4012, 4020, 7, 142, 2, 2, 4013, 4015, 7, 248,
	2, 2, 4014, 4016, 7, 477, 2, 2, 4015, 4014, 3, 2, 2, 2, 4015, 4016, 3,
	2, 2, 2, 4016, 4021, 3, 2, 2, 2, 4017, 4018, 7, 234, 2, 2, 4018, 4021,
	7, 477, 2, 2, 4019, 4021, 7, 336, 2, 2, 4020, 4013, 3, 2, 2, 2, 4020, 4017,
	3, 2, 2, 2, 4020, 4019, 3, 2, 2, 2, 4021, 4022, 3, 2, 2, 2, 4022, 4024,
	5, 1122, 562, 2, 4023, 4025, 7, 516, 2, 2, 4024, 4023, 3, 2, 2, 2, 4024,
	4025, 3, 2, 2, 2, 4025, 4026, 3, 2, 2, 2, 4026, 4029, 7, 261, 2, 2, 4027,
	4030, 5, 1076, 539, 2, 4028, 4030, 5, 1174, 588, 2, 4029, 4027, 3, 2, 2,
	2, 4029, 4028, 3, 2, 2, 2, 4030, 623, 3, 2, 2, 2, 4031, 4033, 7, 144, 2,
	2, 4032, 4034, 5, 626, 314, 2, 4033, 4032, 3, 2, 2, 2, 4034, 4035, 3, 2,
	2, 2, 4035, 4033, 3, 2, 2, 2, 4035, 4036, 3, 2, 2, 2, 4036, 4038, 3, 2,
	2, 2, 4037, 4039, 5, 628, 315, 2, 4038, 4037, 3, 2, 2, 2, 4038, 4039, 3,
	2, 2, 2, 4039, 4041, 3, 2, 2, 2, 4040, 4042, 5, 630, 316, 2, 4041, 4040,
	3, 2, 2, 2, 4041, 4042, 3, 2, 2, 2, 4042, 4044, 3, 2, 2, 2, 4043, 4045,
	5, 632, 317, 2, 4044, 4043, 3, 2, 2, 2, 4044, 4045, 3, 2, 2, 2, 4045, 625,
	3, 2, 2, 2, 4046, 4049, 5, 1076, 539, 2, 4047, 4049, 5, 1174, 588, 2, 4048,
	4046, 3, 2, 2, 2, 4048, 4047, 3, 2, 2, 2, 4049, 627, 3, 2, 2, 2, 4050,
	4053, 7, 32, 2, 2, 4051, 4054, 5, 1076, 539, 2, 4052, 4054, 5, 1174, 588,
	2, 4053, 4051, 3, 2, 2, 2, 4053, 4052, 3, 2, 2, 2, 4054, 629, 3, 2, 2,
	2, 4055, 4058, 7, 505, 2, 2, 4056, 4059, 5, 1148, 575, 2, 4057, 4059, 5,
	1134, 568, 2, 4058, 4056, 3, 2, 2, 2, 4058, 4057, 3, 2, 2, 2, 4059, 631,
	3, 2, 2, 2, 4060, 4062, 7, 516, 2, 2, 4061, 4060, 3, 2, 2, 2, 4061, 4062,
	3, 2, 2, 2, 4062, 4063, 3, 2, 2, 2, 4063, 4064, 7, 312, 2, 2, 4064, 4065,
	7, 8, 2, 2, 4065, 633, 3, 2, 2, 2, 4066, 4069, 7, 146, 2, 2, 4067, 4070,
	5, 1076, 539, 2, 4068, 4070, 5, 1174, 588, 2, 4069, 4067, 3, 2, 2, 2, 4069,
	4068, 3, 2, 2, 2, 4070, 4074, 3, 2, 2, 2, 4071, 4075, 5, 636, 319, 2, 4072,
	4075, 5, 638, 320, 2, 4073, 4075, 5, 640, 321, 2, 4074, 4071, 3, 2, 2,
	2, 4074, 4072, 3, 2, 2, 2, 4074, 4073, 3, 2, 2, 2, 4075, 4077, 3, 2, 2,
	2, 4076, 4078, 5, 648, 325, 2, 4077, 4076, 3, 2, 2, 2, 4077, 4078, 3, 2,
	2, 2, 4078, 4080, 3, 2, 2, 2, 4079, 4081, 5, 1026, 514, 2, 4080, 4079,
	3, 2, 2, 2, 4080, 4081, 3, 2, 2, 2, 4081, 4083, 3, 2, 2, 2, 4082, 4084,
	5, 1028, 515, 2, 4083, 4082, 3, 2, 2, 2, 4083, 4084, 3, 2, 2, 2, 4084,
	4086, 3, 2, 2, 2, 4085, 4087, 7, 166, 2, 2, 4086, 4085, 3, 2, 2, 2, 4086,
	4087, 3, 2, 2, 2, 4087, 635, 3, 2, 2, 2, 4088, 4090, 7, 253, 2, 2, 4089,
	4091, 5, 644, 323, 2, 4090, 4089, 3, 2, 2, 2, 4091, 4092, 3, 2, 2, 2, 4092,
	4090, 3, 2, 2, 2, 4092, 4093, 3, 2, 2, 2, 4093, 637, 3, 2, 2, 2, 4094,
	4097, 7, 253, 2, 2, 4095, 4098, 5, 1076, 539, 2, 4096, 4098, 5, 1174, 588,
	2, 4097, 4095, 3, 2, 2, 2, 4097, 4096, 3, 2, 2, 2, 4098, 4100, 3, 2, 2,
	2, 4099, 4101, 5, 642, 322, 2, 4100, 4099, 3, 2, 2, 2, 4100, 4101, 3, 2,
	2, 2, 4101, 639, 3, 2, 2, 2, 4102, 4105, 7, 51, 2, 2, 4103, 4106, 5, 1076,
	539, 2, 4104, 4106, 5, 1174, 588, 2, 4105, 4103, 3, 2, 2, 2, 4105, 4104,
	3, 2, 2, 2, 4106, 4108, 3, 2, 2, 2, 4107, 4109, 5, 642, 322, 2, 4108, 4107,
	3, 2, 2, 2, 4108, 4109, 3, 2, 2, 2, 4109, 641, 3, 2, 2, 2, 4110, 4112,
	7, 224, 2, 2, 4111, 4113, 5, 646, 324, 2, 4112, 4111, 3, 2, 2, 2, 4113,
	4114, 3, 2, 2, 2, 4114, 4112, 3, 2, 2, 2, 4114, 4115, 3, 2, 2, 2, 4115,
	643, 3, 2, 2, 2, 4116, 4118, 5, 1076, 539, 2, 4117, 4119, 7, 414, 2, 2,
	4118, 4117, 3, 2, 2, 2, 4118, 4119, 3, 2, 2, 2, 4119, 645, 3, 2, 2, 2,
	4120, 4122, 5, 1076, 539, 2, 4121, 4123, 7, 414, 2, 2, 4122, 4121, 3, 2,
	2, 2, 4122, 4123, 3, 2, 2, 2, 4123, 647, 3, 2, 2, 2, 4124, 4125, 7, 390,
	2, 2, 4125, 4126, 5, 1076, 539, 2, 4126, 649, 3, 2, 2, 2, 4127, 4135, 7,
	159, 2, 2, 4128, 4130, 7, 248, 2, 2, 4129, 4131, 7, 477, 2, 2, 4130, 4129,
	3, 2, 2, 2, 4130, 4131, 3, 2, 2, 2, 4131, 4136, 3, 2, 2, 2, 4132, 4133,
	7, 234, 2, 2, 4133, 4136, 7, 477, 2, 2, 4134, 4136, 7, 336, 2, 2, 4135,
	4128, 3, 2, 2, 2, 4135, 4132, 3, 2, 2, 2, 4135, 4134, 3, 2, 2, 2, 4136,
	4137, 3, 2, 2, 2, 4137, 4139, 5, 1122, 562, 2, 4138, 4140, 7, 516, 2, 2,
	4139, 4138, 3, 2, 2, 2, 4139, 4140, 3, 2, 2, 2, 4140, 4141, 3, 2, 2, 2,
	4141, 4144, 7, 261, 2, 2, 4142, 4145, 5, 1174, 588, 2, 4143, 4145, 5, 1076,
	539, 2, 4144, 4142, 3, 2, 2, 2, 4144, 4143, 3, 2, 2, 2, 4145, 651, 3, 2,
	2, 2, 4146, 4147, 7, 184, 2, 2, 4147, 4154, 5, 1174, 588, 2, 4148, 4150,
	7, 508, 2, 2, 4149, 4151, 5, 1076, 539, 2, 4150, 4149, 3, 2, 2, 2, 4151,
	4152, 3, 2, 2, 2, 4152, 4150, 3, 2, 2, 2, 4152, 4153, 3, 2, 2, 2, 4153,
	4155, 3, 2, 2, 2, 4154, 4148, 3, 2, 2, 2, 4154, 4155, 3, 2, 2, 2, 4155,
	653, 3, 2, 2, 2, 4156, 4157, 7, 195, 2, 2, 4157, 4161, 5, 656, 329, 2,
	4158, 4160, 5, 658, 330, 2, 4159, 4158, 3, 2, 2, 2, 4160, 4163, 3, 2, 2,
	2, 4161, 4159, 3, 2, 2, 2, 4161, 4162, 3, 2, 2, 2, 4162, 4165, 3, 2, 2,
	2, 4163, 4161, 3, 2, 2, 2, 4164, 4166, 5, 660, 331, 2, 4165, 4164, 3, 2,
	2, 2, 4166, 4167, 3, 2, 2, 2, 4167, 4165, 3, 2, 2, 2, 4167, 4168, 3, 2,
	2, 2, 4168, 4170, 3, 2, 2, 2, 4169, 4171, 5, 670, 336, 2, 4170, 4169, 3,
	2, 2, 2, 4170, 4171, 3, 2, 2, 2, 4171, 4173, 3, 2, 2, 2, 4172, 4174, 7,
	167, 2, 2, 4173, 4172, 3, 2, 2, 2, 4173, 4174, 3, 2, 2, 2, 4174, 655, 3,
	2, 2, 2, 4175, 4180, 5, 1076, 539, 2, 4176, 4180, 5, 1174, 588, 2, 4177,
	4180, 5, 1034, 518, 2, 4178, 4180, 5, 1048, 525, 2, 4179, 4175, 3, 2, 2,
	2, 4179, 4176, 3, 2, 2, 2, 4179, 4177, 3, 2, 2, 2, 4179, 4178, 3, 2, 2,
	2, 4180, 657, 3, 2, 2, 2, 4181, 4182, 7, 18, 2, 2, 4182, 4183, 5, 656,
	329, 2, 4183, 659, 3, 2, 2, 2, 4184, 4186, 5, 662, 332, 2, 4185, 4184,
	3, 2, 2, 2, 4186, 4187, 3, 2, 2, 2, 4187, 4185, 3, 2, 2, 2, 4187, 4188,
	3, 2, 2, 2, 4188, 4192, 3, 2, 2, 2, 4189, 4191, 5, 538, 270, 2, 4190, 4189,
	3, 2, 2, 2, 4191, 4194, 3, 2, 2, 2, 4192, 4190, 3, 2, 2, 2, 4192, 4193,
	3, 2, 2, 2, 4193, 661, 3, 2, 2, 2, 4194, 4192, 3, 2, 2, 2, 4195, 4196,
	7, 514, 2, 2, 4196, 4200, 5, 664, 333, 2, 4197, 4199, 5, 668, 335, 2, 4198,
	4197, 3, 2, 2, 2, 4199, 4202, 3, 2, 2, 2, 4200, 4198, 3, 2, 2, 2, 4200,
	4201, 3, 2, 2, 2, 4201, 663, 3, 2, 2, 2, 4202, 4200, 3, 2, 2, 2, 4203,
	4214, 7, 22, 2, 2, 4204, 4206, 7, 314, 2, 2, 4205, 4204, 3, 2, 2, 2, 4205,
	4206, 3, 2, 2, 2, 4206, 4207, 3, 2, 2, 2, 4207, 4209, 5, 672, 337, 2, 4208,
	4210, 5, 666, 334, 2, 4209, 4208, 3, 2, 2, 2, 4209, 4210, 3, 2, 2, 2, 4210,
	4214, 3, 2, 2, 2, 4211, 4214, 5, 1048, 525, 2, 4212, 4214, 5, 1176, 589,
	2, 4213, 4203, 3, 2, 2, 2, 4213, 4205, 3, 2, 2, 2, 4213, 4211, 3, 2, 2,
	2, 4213, 4212, 3, 2, 2, 2, 4214, 665, 3, 2, 2, 2, 4215, 4216, 9, 6, 2,
	2, 4216, 4217, 5, 672, 337, 2, 4217, 667, 3, 2, 2, 2, 4218, 4219, 7, 18,
	2, 2, 4219, 4220, 5, 664, 333, 2, 4220, 669, 3, 2, 2, 2, 4221, 4222, 7,
	514, 2, 2, 4222, 4226, 7, 335, 2, 2, 4223, 4225, 5, 538, 270, 2, 4224,
	4223, 3, 2, 2, 2, 4225, 4228, 3, 2, 2, 2, 4226, 4224, 3, 2, 2, 2, 4226,
	4227, 3, 2, 2, 2, 4227, 671, 3, 2, 2, 2, 4228, 4226, 3, 2, 2, 2, 4229,
	4233, 5, 1076, 539, 2, 4230, 4233, 5, 1174, 588, 2, 4231, 4233, 5, 1034,
	518, 2, 4232, 4229, 3, 2, 2, 2, 4232, 4230, 3, 2, 2, 2, 4232, 4231, 3,
	2, 2, 2, 4233, 673, 3, 2, 2, 2, 4234, 4236, 7, 561, 2, 2, 4235, 4234, 3,
	2, 2, 2, 4236, 4237, 3, 2, 2, 2, 4237, 4235, 3, 2, 2, 2, 4237, 4238, 3,
	2, 2, 2, 4238, 675, 3, 2, 2, 2, 4239, 4241, 7, 563, 2, 2, 4240, 4239, 3,
	2, 2, 2, 4241, 4242, 3, 2, 2, 2, 4242, 4240, 3, 2, 2, 2, 4242, 4243, 3,
	2, 2, 2, 4243, 677, 3, 2, 2, 2, 4244, 4246, 7, 562, 2, 2, 4245, 4244, 3,
	2, 2, 2, 4246, 4247, 3, 2, 2, 2, 4247, 4245, 3, 2, 2, 2, 4247, 4248, 3,
	2, 2, 2, 4248, 679, 3, 2, 2, 2, 4249, 4251, 7, 200, 2, 2, 4250, 4252, 7,
	305, 2, 2, 4251, 4250, 3, 2, 2, 2, 4251, 4252, 3, 2, 2, 2, 4252, 4254,
	3, 2, 2, 2, 4253, 4255, 7, 62, 2, 2, 4254, 4253, 3, 2, 2, 2, 4254, 4255,
	3, 2, 2, 2, 4255, 4257, 3, 2, 2, 2, 4256, 4258, 5, 682, 342, 2, 4257, 4256,
	3, 2, 2, 2, 4258, 4259, 3, 2, 2, 2, 4259, 4257, 3, 2, 2, 2, 4259, 4260,
	3, 2, 2, 2, 4260, 681, 3, 2, 2, 2, 4261, 4264, 5, 1076, 539, 2, 4262, 4264,
	5, 1174, 588, 2, 4263, 4261, 3, 2, 2, 2, 4263, 4262, 3, 2, 2, 2, 4264,
	683, 3, 2, 2, 2, 4265, 4267, 7, 201, 2, 2, 4266, 4268, 7, 363, 2, 2, 4267,
	4266, 3, 2, 2, 2, 4267, 4268, 3, 2, 2, 2, 4268, 685, 3, 2, 2, 2, 4269,
	4270, 7, 222, 2, 2, 4270, 4271, 5, 1158, 580, 2, 4271, 687, 3, 2, 2, 2,
	4272, 4273, 7, 223, 2, 2, 4273, 689, 3, 2, 2, 2, 4274, 4276, 7, 226, 2,
	2, 4275, 4277, 7, 491, 2, 2, 4276, 4275, 3, 2, 2, 2, 4276, 4277, 3, 2,
	2, 2, 4277, 4280, 3, 2, 2, 2, 4278, 4281, 5, 692, 347, 2, 4279, 4281, 5,
	694, 348, 2, 4280, 4278, 3, 2, 2, 2, 4280, 4279, 3, 2, 2, 2, 4281, 691,
	3, 2, 2, 2, 4282, 4283, 5, 1152, 577, 2, 4283, 693, 3, 2, 2, 2, 4284, 4298,
	7, 301, 2, 2, 4285, 4287, 5, 1152, 577, 2, 4286, 4285, 3, 2, 2, 2, 4287,
	4288, 3, 2, 2, 2, 4288, 4286, 3, 2, 2, 2, 4288, 4289, 3, 2, 2, 2, 4289,
	4295, 3, 2, 2, 2, 4290, 4292, 7, 136, 2, 2, 4291, 4293, 7, 328, 2, 2, 4292,
	4291, 3, 2, 2, 2, 4292, 4293, 3, 2, 2, 2, 4293, 4294, 3, 2, 2, 2, 4294,
	4296, 5, 1076, 539, 2, 4295, 4290, 3, 2, 2, 2, 4295, 4296, 3, 2, 2, 2,
	4296, 4298, 3, 2, 2, 2, 4297, 4284, 3, 2, 2, 2, 4297, 4286, 3, 2, 2, 2,
	4298, 695, 3, 2, 2, 2, 4299, 4300, 7, 238, 2, 2, 4300, 4301, 5, 1048, 525,
	2, 4301, 4303, 5, 698, 350, 2, 4302, 4304, 5, 700, 351, 2, 4303, 4302,
	3, 2, 2, 2, 4303, 4304, 3, 2, 2, 2, 4304, 4306, 3, 2, 2, 2, 4305, 4307,
	7, 168, 2, 2, 4306, 4305, 3, 2, 2, 2, 4306, 4307, 3, 2, 2, 2, 4307, 697,
	3, 2, 2, 2, 4308, 4310, 7, 482, 2, 2, 4309, 4308, 3, 2, 2, 2, 4309, 4310,
	3, 2, 2, 2, 4310, 4319, 3, 2, 2, 2, 4311, 4312, 7, 311, 2, 2, 4312, 4320,
	7, 428, 2, 2, 4313, 4315, 5, 538, 270, 2, 4314, 4313, 3, 2, 2, 2, 4315,
	4318, 3, 2, 2, 2, 4316, 4314, 3, 2, 2, 2, 4316, 4317, 3, 2, 2, 2, 4317,
	4320, 3, 2, 2, 2, 4318, 4316, 3, 2, 2, 2, 4319, 4311, 3, 2, 2, 2, 4319,
	4316, 3, 2, 2, 2, 4320, 699, 3, 2, 2, 2, 4321, 4330, 7, 156, 2, 2, 4322,
	4323, 7, 311, 2, 2, 4323, 4331, 7, 428, 2, 2, 4324, 4326, 5, 538, 270,
	2, 4325, 4324, 3, 2, 2, 2, 4326, 4329, 3, 2, 2, 2, 4327, 4325, 3, 2, 2,
	2, 4327, 4328, 3, 2, 2, 2, 4328, 4331, 3, 2, 2, 2, 4329, 4327, 3, 2, 2,
	2, 4330, 4322, 3, 2, 2, 2, 4330, 4327, 3, 2, 2, 2, 4331, 701, 3, 2, 2,
	2, 4332, 4334, 7, 246, 2, 2, 4333, 4335, 5, 1076, 539, 2, 4334, 4333, 3,
	2, 2, 2, 4335, 4336, 3, 2, 2, 2, 4336, 4334, 3, 2, 2, 2, 4336, 4337, 3,
	2, 2, 2, 4337, 4339, 3, 2, 2, 2, 4338, 4340, 5, 704, 353, 2, 4339, 4338,
	3, 2, 2, 2, 4339, 4340, 3, 2, 2, 2, 4340, 703, 3, 2, 2, 2, 4341, 4343,
	7, 396, 2, 2, 4342, 4344, 5, 706, 354, 2, 4343, 4342, 3, 2, 2, 2, 4344,
	4345, 3, 2, 2, 2, 4345, 4343, 3, 2, 2, 2, 4345, 4346, 3, 2, 2, 2, 4346,
	705, 3, 2, 2, 2, 4347, 4349, 9, 55, 2, 2, 4348, 4350, 7, 111, 2, 2, 4349,
	4348, 3, 2, 2, 2, 4349, 4350, 3, 2, 2, 2, 4350, 4351, 3, 2, 2, 2, 4351,
	4354, 7, 51, 2, 2, 4352, 4355, 5, 1076, 539, 2, 4353, 4355, 5, 1174, 588,
	2, 4354, 4352, 3, 2, 2, 2, 4354, 4353, 3, 2, 2, 2, 4355, 707, 3, 2, 2,
	2, 4356, 4358, 7, 247, 2, 2, 4357, 4359, 5, 1158, 580, 2, 4358, 4357, 3,
	2, 2, 2, 4359, 4360, 3, 2, 2, 2, 4360, 4358, 3, 2, 2, 2, 4360, 4361, 3,
	2, 2, 2, 4361, 709, 3, 2, 2, 2, 4362, 4363, 7, 250, 2, 2, 4363, 4368, 5,
	1076, 539, 2, 4364, 4369, 5, 712, 357, 2, 4365, 4369, 5, 714, 358, 2, 4366,
	4369, 5, 716, 359, 2, 4367, 4369, 5, 718, 360, 2, 4368, 4364, 3, 2, 2,
	2, 4368, 4365, 3, 2, 2, 2, 4368, 4366, 3, 2, 2, 2, 4368, 4367, 3, 2, 2,
	2, 4369, 711, 3, 2, 2, 2, 4370, 4372, 7, 474, 2, 2, 4371, 4373, 5, 720,
	361, 2, 4372, 4371, 3, 2, 2, 2, 4373, 4374, 3, 2, 2, 2, 4374, 4372, 3,
	2, 2, 2, 4374, 4375, 3, 2, 2, 2, 4375, 713, 3, 2, 2, 2, 4376, 4379, 7,
	396, 2, 2, 4377, 4380, 5, 724, 363, 2, 4378, 4380, 5, 728, 365, 2, 4379,
	4377, 3, 2, 2, 2, 4379, 4378, 3, 2, 2, 2, 4380, 4381, 3, 2, 2, 2, 4381,
	4379, 3, 2, 2, 2, 4381, 4382, 3, 2, 2, 2, 4382, 715, 3, 2, 2, 2, 4383,
	4385, 7, 474, 2, 2, 4384, 4386, 5, 720, 361, 2, 4385, 4384, 3, 2, 2, 2,
	4386, 4387, 3, 2, 2, 2, 4387, 4385, 3, 2, 2, 2, 4387, 4388, 3, 2, 2, 2,
	4388, 4390, 3, 2, 2, 2, 4389, 4391, 5, 714, 358, 2, 4390, 4389, 3, 2, 2,
	2, 4391, 4392, 3, 2, 2, 2, 4392, 4390, 3, 2, 2, 2, 4392, 4393, 3, 2, 2,
	2, 4393, 717, 3, 2, 2, 2, 4394, 4397, 7, 103, 2, 2, 4395, 4398, 5, 1076,
	539, 2, 4396, 4398, 5, 1174, 588, 2, 4397, 4395, 3, 2, 2, 2, 4397, 4396,
	3, 2, 2, 2, 4398, 4399, 3, 2, 2, 2, 4399, 4403, 5, 736, 369, 2, 4400, 4402,
	5, 738, 370, 2, 4401, 4400, 3, 2, 2, 2, 4402, 4405, 3, 2, 2, 2, 4403, 4401,
	3, 2, 2, 2, 4403, 4404, 3, 2, 2, 2, 4404, 719, 3, 2, 2, 2, 4405, 4403,
	3, 2, 2, 2, 4406, 4407, 5, 1076, 539, 2, 4407, 4410, 7, 214, 2, 2, 4408,
	4411, 5, 722, 362, 2, 4409, 4411, 5, 726, 364, 2, 4410, 4408, 3, 2, 2,
	2, 4410, 4409, 3, 2, 2, 2, 4411, 4412, 3, 2, 2, 2, 4412, 4410, 3, 2, 2,
	2, 4412, 4413, 3, 2, 2, 2, 4413, 721, 3, 2, 2, 2, 4414, 4418, 7, 65, 2,
	2, 4415, 4417, 5, 738, 370, 2, 4416, 4415, 3, 2, 2, 2, 4417, 4420, 3, 2,
	2, 2, 4418, 4416, 3, 2, 2, 2, 4418, 4419, 3, 2, 2, 2, 4419, 723, 3, 2,
	2, 2, 4420, 4418, 3, 2, 2, 2, 4421, 4422, 7, 65, 2, 2, 4422, 4426, 5, 734,
	368, 2, 4423, 4425, 5, 738, 370, 2, 4424, 4423, 3, 2, 2, 2, 4425, 4428,
	3, 2, 2, 2, 4426, 4424, 3, 2, 2, 2, 4426, 4427, 3, 2, 2, 2, 4427, 725,
	3, 2, 2, 2, 4428, 4426, 3, 2, 2, 2, 4429, 4431, 9, 56, 2, 2, 4430, 4432,
	5, 730, 366, 2, 4431, 4430, 3, 2, 2, 2, 4432, 4433, 3, 2, 2, 2, 4433, 4431,
	3, 2, 2, 2, 4433, 4434, 3, 2, 2, 2, 4434, 727, 3, 2, 2, 2, 4435, 4437,
	9, 57, 2, 2, 4436, 4438, 5, 732, 367, 2, 4437, 4436, 3, 2, 2, 2, 4438,
	4439, 3, 2, 2, 2, 4439, 4437, 3, 2, 2, 2, 4439, 4440, 3, 2, 2, 2, 4440,
	729, 3, 2, 2, 2, 4441, 4444, 5, 1076, 539, 2, 4442, 4444, 5, 1174, 588,
	2, 4443, 4441, 3, 2, 2, 2, 4443, 4442, 3, 2, 2, 2, 4444, 4448, 3, 2, 2,
	2, 4445, 4447, 5, 738, 370, 2, 4446, 4445, 3, 2, 2, 2, 4447, 4450, 3, 2,
	2, 2, 4448, 4446, 3, 2, 2, 2, 4448, 4449, 3, 2, 2, 2, 4449, 731, 3, 2,
	2, 2, 4450, 4448, 3, 2, 2, 2, 4451, 4454, 5, 1076, 539, 2, 4452, 4454,
	5, 1174, 588, 2, 4453, 4451, 3, 2, 2, 2, 4453, 4452, 3, 2, 2, 2, 4454,
	4455, 3, 2, 2, 2, 4455, 4459, 5, 734, 368, 2, 4456, 4458, 5, 738, 370,
	2, 4457, 4456, 3, 2, 2, 2, 4458, 4461, 3, 2, 2, 2, 4459, 4457, 3, 2, 2,
	2, 4459, 4460, 3, 2, 2, 2, 4460, 733, 3, 2, 2, 2, 4461, 4459, 3, 2, 2,
	2, 4462, 4465, 7, 51, 2, 2, 4463, 4466, 5, 1076, 539, 2, 4464, 4466, 5,
	1174, 588, 2, 4465, 4463, 3, 2, 2, 2, 4465, 4464, 3, 2, 2, 2, 4466, 735,
	3, 2, 2, 2, 4467, 4470, 7, 491, 2, 2, 4468, 4471, 5, 1076, 539, 2, 4469,
	4471, 5, 1174, 588, 2, 4470, 4468, 3, 2, 2, 2, 4470, 4469, 3, 2, 2, 2,
	4471, 737, 3, 2, 2, 2, 4472, 4474, 9, 58, 2, 2, 4473, 4475, 7, 245, 2,
	2, 4474, 4473, 3, 2, 2, 2, 4474, 4475, 3, 2, 2, 2, 4475, 4478, 3, 2, 2,
	2, 4476, 4479, 5, 1076, 539, 2, 4477, 4479, 5, 1174, 588, 2, 4478, 4476,
	3, 2, 2, 2, 4478, 4477, 3, 2, 2, 2, 4479, 739, 3, 2, 2, 2, 4480, 4481,
	7, 296, 2, 2, 4481, 4483, 5, 1136, 569, 2, 4482, 4484, 5, 742, 372, 2,
	4483, 4482, 3, 2, 2, 2, 4484, 4485, 3, 2, 2, 2, 4485, 4483, 3, 2, 2, 2,
	4485, 4486, 3, 2, 2, 2, 4486, 4488, 3, 2, 2, 2, 4487, 4489, 5, 744, 373,
	2, 4488, 4487, 3, 2, 2, 2, 4488, 4489, 3, 2, 2, 2, 4489, 4493, 3, 2, 2,
	2, 4490, 4492, 5, 750, 376, 2, 4491, 4490, 3, 2, 2, 2, 4492, 4495, 3, 2,
	2, 2, 4493, 4491, 3, 2, 2, 2, 4493, 4494, 3, 2, 2, 2, 4494, 4497, 3, 2,
	2, 2, 4495, 4493, 3, 2, 2, 2, 4496, 4498, 5, 752, 377, 2, 4497, 4496, 3,
	2, 2, 2, 4497, 4498, 3, 2, 2, 2, 4498, 4502, 3, 2, 2, 2, 4499, 4501, 5,
	756, 379, 2, 4500, 4499, 3, 2, 2, 2, 4501, 4504, 3, 2, 2, 2, 4502, 4500,
	3, 2, 2, 2, 4502, 4503, 3, 2, 2, 2, 4503, 741, 3, 2, 2, 2, 4504, 4502,
	3, 2, 2, 2, 4505, 4507, 7, 328, 2, 2, 4506, 4505, 3, 2, 2, 2, 4506, 4507,
	3, 2, 2, 2, 4507, 4508, 3, 2, 2, 2, 4508, 4510, 9, 43, 2, 2, 4509, 4511,
	7, 261, 2, 2, 4510, 4509, 3, 2, 2, 2, 4510, 4511, 3, 2, 2, 2, 4511, 4513,
	3, 2, 2, 2, 4512, 4514, 5, 1092, 547, 2, 4513, 4512, 3, 2, 2, 2, 4514,
	4515, 3, 2, 2, 2, 4515, 4513, 3, 2, 2, 2, 4515, 4516, 3, 2, 2, 2, 4516,
	743, 3, 2, 2, 2, 4517, 4519, 7, 74, 2, 2, 4518, 4517, 3, 2, 2, 2, 4518,
	4519, 3, 2, 2, 2, 4519, 4520, 3, 2, 2, 2, 4520, 4522, 7, 430, 2, 2, 4521,
	4523, 7, 256, 2, 2, 4522, 4521, 3, 2, 2, 2, 4522, 4523, 3, 2, 2, 2, 4523,
	4525, 3, 2, 2, 2, 4524, 4526, 5, 1116, 559, 2, 4525, 4524, 3, 2, 2, 2,
	4526, 4527, 3, 2, 2, 2, 4527, 4525, 3, 2, 2, 2, 4527, 4528, 3, 2, 2, 2,
	4528, 4530, 3, 2, 2, 2, 4529, 4531, 5, 746, 374, 2, 4530, 4529, 3, 2, 2,
	2, 4530, 4531, 3, 2, 2, 2, 4531, 4533, 3, 2, 2, 2, 4532, 4534, 5, 748,
	375, 2, 4533, 4532, 3, 2, 2, 2, 4533, 4534, 3, 2, 2, 2, 4534, 745, 3, 2,
	2, 2, 4535, 4537, 7, 214, 2, 2, 4536, 4535, 3, 2, 2, 2, 4536, 4537, 3,
	2, 2, 2, 4537, 4538, 3, 2, 2, 2, 4538, 4539, 7, 16, 2, 2, 4539, 4540, 7,
	256, 2, 2, 4540, 4541, 5, 1116, 559, 2, 4541, 747, 3, 2, 2, 2, 4542, 4544,
	7, 214, 2, 2, 4543, 4542, 3, 2, 2, 2, 4543, 4544, 3, 2, 2, 2, 4544, 4545,
	3, 2, 2, 2, 4545, 4547, 7, 306, 2, 2, 4546, 4548, 7, 256, 2, 2, 4547, 4546,
	3, 2, 2, 2, 4547, 4548, 3, 2, 2, 2, 4548, 4549, 3, 2, 2, 2, 4549, 4550,
	5, 1116, 559, 2, 4550, 749, 3, 2, 2, 2, 4551, 4553, 7, 508, 2, 2, 4552,
	4554, 5, 1136, 569, 2, 4553, 4552, 3, 2, 2, 2, 4554, 4555, 3, 2, 2, 2,
	4555, 4553, 3, 2, 2, 2, 4555, 4556, 3, 2, 2, 2, 4556, 751, 3, 2, 2, 2,
	4557, 4558, 7, 336, 2, 2, 4558, 4560, 7, 358, 2, 2, 4559, 4561, 7, 256,
	2, 2, 4560, 4559, 3, 2, 2, 2, 4560, 4561, 3, 2, 2, 2, 4561, 4562, 3, 2,
	2, 2, 4562, 4564, 5, 1152, 577, 2, 4563, 4565, 5, 754, 378, 2, 4564, 4563,
	3, 2, 2, 2, 4564, 4565, 3, 2, 2, 2, 4565, 753, 3, 2, 2, 2, 4566, 4567,
	9, 6, 2, 2, 4567, 4568, 5, 1152, 577, 2, 4568, 755, 3, 2, 2, 2, 4569, 4571,
	7, 224, 2, 2, 4570, 4572, 5, 758, 380, 2, 4571, 4570, 3, 2, 2, 2, 4572,
	4573, 3, 2, 2, 2, 4573, 4571, 3, 2, 2, 2, 4573, 4574, 3, 2, 2, 2, 4574,
	757, 3, 2, 2, 2, 4575, 4585, 5, 1136, 569, 2, 4576, 4586, 7, 288, 2, 2,
	4577, 4586, 7, 417, 2, 2, 4578, 4579, 7, 312, 2, 2, 4579, 4586, 7, 409,
	2, 2, 4580, 4586, 7, 108, 2, 2, 4581, 4586, 7, 389, 2, 2, 4582, 4583, 7,
	516, 2, 2, 4583, 4584, 7, 393, 2, 2, 4584, 4586, 7, 108, 2, 2, 4585, 4576,
	3, 2, 2, 2, 4585, 4577, 3, 2, 2, 2, 4585, 4578, 3, 2, 2, 2, 4585, 4580,
	3, 2, 2, 2, 4585, 4581, 3, 2, 2, 2, 4585, 4582, 3, 2, 2, 2, 4585, 4586,
	3, 2, 2, 2, 4586, 759, 3, 2, 2, 2, 4587, 4589, 7, 302, 2, 2, 4588, 4590,
	7, 11, 2, 2, 4589, 4588, 3, 2, 2, 2, 4589, 4590, 3, 2, 2, 2, 4590, 4593,
	3, 2, 2, 2, 4591, 4594, 5, 762, 382, 2, 4592, 4594, 5, 766, 384, 2, 4593,
	4591, 3, 2, 2, 2, 4593, 4592, 3, 2, 2, 2, 4594, 761, 3, 2, 2, 2, 4595,
	4596, 5, 764, 383, 2, 4596, 4598, 7, 491, 2, 2, 4597, 4599, 5, 1076, 539,
	2, 4598, 4597, 3, 2, 2, 2, 4599, 4600, 3, 2, 2, 2, 4600, 4598, 3, 2, 2,
	2, 4600, 4601, 3, 2, 2, 2, 4601, 763, 3, 2, 2, 2, 4602, 4605, 5, 1076,
	539, 2, 4603, 4605, 5, 1174, 588, 2, 4604, 4602, 3, 2, 2, 2, 4604, 4603,
	3, 2, 2, 2, 4605, 765, 3, 2, 2, 2, 4606, 4607, 9, 52, 2, 2, 4607, 4608,
	5, 768, 385, 2, 4608, 4610, 7, 491, 2, 2, 4609, 4611, 5, 1076, 539, 2,
	4610, 4609, 3, 2, 2, 2, 4611, 4612, 3, 2, 2, 2, 4612, 4610, 3, 2, 2, 2,
	4612, 4613, 3, 2, 2, 2, 4613, 767, 3, 2, 2, 2, 4614, 4615, 5, 1076, 539,
	2, 4615, 769, 3, 2, 2, 2, 4616, 4619, 7, 304, 2, 2, 4617, 4620, 5, 1076,
	539, 2, 4618, 4620, 5, 1174, 588, 2, 4619, 4617, 3, 2, 2, 2, 4619, 4618,
	3, 2, 2, 2, 4620, 4621, 3, 2, 2, 2, 4621, 4624, 7, 51, 2, 2, 4622, 4625,
	5, 772, 387, 2, 4623, 4625, 5, 776, 389, 2, 4624, 4622, 3, 2, 2, 2, 4624,
	4623, 3, 2, 2, 2, 4625, 4627, 3, 2, 2, 2, 4626, 4628, 5, 1026, 514, 2,
	4627, 4626, 3, 2, 2, 2, 4627, 4628, 3, 2, 2, 2, 4628, 4630, 3, 2, 2, 2,
	4629, 4631, 5, 1028, 515, 2, 4630, 4629, 3, 2, 2, 2, 4630, 4631, 3, 2,
	2, 2, 4631, 4633, 3, 2, 2, 2, 4632, 4634, 7, 169, 2, 2, 4633, 4632, 3,
	2, 2, 2, 4633, 4634, 3, 2, 2, 2, 4634, 771, 3, 2, 2, 2, 4635, 4637, 5,
	774, 388, 2, 4636, 4635, 3, 2, 2, 2, 4637, 4638, 3, 2, 2, 2, 4638, 4636,
	3, 2, 2, 2, 4638, 4639, 3, 2, 2, 2, 4639, 773, 3, 2, 2, 2, 4640, 4642,
	5, 1076, 539, 2, 4641, 4643, 7, 414, 2, 2, 4642, 4641, 3, 2, 2, 2, 4642,
	4643, 3, 2, 2, 2, 4643, 775, 3, 2, 2, 2, 4644, 4645, 5, 778, 390, 2, 4645,
	4647, 7, 224, 2, 2, 4646, 4648, 5, 780, 391, 2, 4647, 4646, 3, 2, 2, 2,
	4648, 4649, 3, 2, 2, 2, 4649, 4647, 3, 2, 2, 2, 4649, 4650, 3, 2, 2, 2,
	4650, 777, 3, 2, 2, 2, 4651, 4654, 5, 1076, 539, 2, 4652, 4654, 5, 1174,
	588, 2, 4653, 4651, 3, 2, 2, 2, 4653, 4652, 3, 2, 2, 2, 4654, 779, 3, 2,
	2, 2, 4655, 4657, 5, 1076, 539, 2, 4656, 4658, 7, 414, 2, 2, 4657, 4656,
	3, 2, 2, 2, 4657, 4658, 3, 2, 2, 2, 4658, 781, 3, 2, 2, 2, 4659, 4664,
	7, 329, 2, 2, 4660, 4665, 5, 784, 393, 2, 4661, 4665, 5, 788, 395, 2, 4662,
	4665, 5, 792, 397, 2, 4663, 4665, 5, 794, 398, 2, 4664, 4660, 3, 2, 2,
	2, 4664, 4661, 3, 2, 2, 2, 4664, 4662, 3, 2, 2, 2, 4664, 4663, 3, 2, 2,
	2, 4665, 4666, 3, 2, 2, 2, 4666, 4664, 3, 2, 2, 2, 4666, 4667, 3, 2, 2,
	2, 4667, 783, 3, 2, 2, 2, 4668, 4670, 7, 248, 2, 2, 4669, 4671, 5, 786,
	394, 2, 4670, 4669, 3, 2, 2, 2, 4671, 4672, 3, 2, 2, 2, 4672, 4670, 3,
	2, 2, 2, 4672, 4673, 3, 2, 2, 2, 4673, 785, 3, 2, 2, 2, 4674, 4681, 5,
	1136, 569, 2, 4675, 4682, 7, 408, 2, 2, 4676, 4678, 7, 516, 2, 2, 4677,
	4676, 3, 2, 2, 2, 4677, 4678, 3, 2, 2, 2, 4678, 4679, 3, 2, 2, 2, 4679,
	4680, 7, 312, 2, 2, 4680, 4682, 7, 409, 2, 2, 4681, 4675, 3, 2, 2, 2, 4681,
	4677, 3, 2, 2, 2, 4681, 4682, 3, 2, 2, 2, 4682, 787, 3, 2, 2, 2, 4683,
	4685, 7, 336, 2, 2, 4684, 4686, 5, 790, 396, 2, 4685, 4684, 3, 2, 2, 2,
	4686, 4687, 3, 2, 2, 2, 4687, 4685, 3, 2, 2, 2, 4687, 4688, 3, 2, 2, 2,
	4688, 789, 3, 2, 2, 2, 4689, 4695, 5, 1136, 569, 2, 4690, 4692, 7, 516,
	2, 2, 4691, 4690, 3, 2, 2, 2, 4691, 4692, 3, 2, 2, 2, 4692, 4693, 3, 2,
	2, 2, 4693, 4694, 7, 312, 2, 2, 4694, 4696, 7, 409, 2, 2, 4695, 4691, 3,
	2, 2, 2, 4695, 4696, 3, 2, 2, 2, 4696, 791, 3, 2, 2, 2, 4697, 4699, 7,
	234, 2, 2, 4698, 4700, 5, 1136, 569, 2, 4699, 4698, 3, 2, 2, 2, 4700, 4701,
	3, 2, 2, 2, 4701, 4699, 3, 2, 2, 2, 4701, 4702, 3, 2, 2, 2, 4702, 793,
	3, 2, 2, 2, 4703, 4705, 7, 203, 2, 2, 4704, 4706, 5, 1136, 569, 2, 4705,
	4704, 3, 2, 2, 2, 4706, 4707, 3, 2, 2, 2, 4707, 4705, 3, 2, 2, 2, 4707,
	4708, 3, 2, 2, 2, 4708, 795, 3, 2, 2, 2, 4709, 4712, 7, 345, 2, 2, 4710,
	4713, 5, 798, 400, 2, 4711, 4713, 5, 800, 401, 2, 4712, 4710, 3, 2, 2,
	2, 4712, 4711, 3, 2, 2, 2, 4713, 797, 3, 2, 2, 2, 4714, 4716, 5, 802, 402,
	2, 4715, 4714, 3, 2, 2, 2, 4715, 4716, 3, 2, 2, 2, 4716, 4720, 3, 2, 2,
	2, 4717, 4719, 5, 538, 270, 2, 4718, 4717, 3, 2, 2, 2, 4719, 4722, 3, 2,
	2, 2, 4720, 4718, 3, 2, 2, 2, 4720, 4721, 3, 2, 2, 2, 4721, 4723, 3, 2,
	2, 2, 4722, 4720, 3, 2, 2, 2, 4723, 4724, 7, 171, 2, 2, 4724, 799, 3, 2,
	2, 2, 4725, 4728, 5, 1152, 577, 2, 4726, 4727, 9, 6, 2, 2, 4727, 4729,
	5, 1152, 577, 2, 4728, 4726, 3, 2, 2, 2, 4728, 4729, 3, 2, 2, 2, 4729,
	4731, 3, 2, 2, 2, 4730, 4732, 5, 802, 402, 2, 4731, 4730, 3, 2, 2, 2, 4731,
	4732, 3, 2, 2, 2, 4732, 801, 3, 2, 2, 2, 4733, 4737, 5, 804, 403, 2, 4734,
	4737, 5, 806, 404, 2, 4735, 4737, 5, 808, 405, 2, 4736, 4733, 3, 2, 2,
	2, 4736, 4734, 3, 2, 2, 2, 4736, 4735, 3, 2, 2, 2, 4737, 803, 3, 2, 2,
	2, 4738, 4741, 5, 1076, 539, 2, 4739, 4741, 5, 1180, 591, 2, 4740, 4738,
	3, 2, 2, 2, 4740, 4739, 3, 2, 2, 2, 4741, 4742, 3, 2, 2, 2, 4742, 4743,
	7, 489, 2, 2, 4743, 805, 3, 2, 2, 2, 4744, 4746, 5, 820, 411, 2, 4745,
	4744, 3, 2, 2, 2, 4745, 4746, 3, 2, 2, 2, 4746, 4747, 3, 2, 2, 2, 4747,
	4748, 7, 503, 2, 2, 4748, 4749, 5, 1048, 525, 2, 4749, 807, 3, 2, 2, 2,
	4750, 4751, 5, 820, 411, 2, 4751, 4752, 5, 810, 406, 2, 4752, 4758, 3,
	2, 2, 2, 4753, 4755, 5, 810, 406, 2, 4754, 4756, 5, 820, 411, 2, 4755,
	4754, 3, 2, 2, 2, 4755, 4756, 3, 2, 2, 2, 4756, 4758, 3, 2, 2, 2, 4757,
	4750, 3, 2, 2, 2, 4757, 4753, 3, 2, 2, 2, 4758, 809, 3, 2, 2, 2, 4759,
	4760, 7, 511, 2, 2, 4760, 4764, 5, 812, 407, 2, 4761, 4763, 5, 814, 408,
	2, 4762, 4761, 3, 2, 2, 2, 4763, 4766, 3, 2, 2, 2, 4764, 4762, 3, 2, 2,
	2, 4764, 4765, 3, 2, 2, 2, 4765, 811, 3, 2, 2, 2, 4766, 4764, 3, 2, 2,
	2, 4767, 4770, 5, 1076, 539, 2, 4768, 4770, 5, 1174, 588, 2, 4769, 4767,
	3, 2, 2, 2, 4769, 4768, 3, 2, 2, 2, 4770, 4771, 3, 2, 2, 2, 4771, 4772,
	5, 816, 409, 2, 4772, 4773, 5, 818, 410, 2, 4773, 4774, 5, 806, 404, 2,
	4774, 813, 3, 2, 2, 2, 4775, 4776, 7, 9, 2, 2, 4776, 4777, 5, 812, 407,
	2, 4777, 815, 3, 2, 2, 2, 4778, 4782, 7, 217, 2, 2, 4779, 4783, 5, 1076,
	539, 2, 4780, 4783, 5, 1174, 588, 2, 4781, 4783, 5, 1034, 518, 2, 4782,
	4779, 3, 2, 2, 2, 4782, 4780, 3, 2, 2, 2, 4782, 4781, 3, 2, 2, 2, 4783,
	817, 3, 2, 2, 2, 4784, 4788, 7, 51, 2, 2, 4785, 4789, 5, 1076, 539, 2,
	4786, 4789, 5, 1174, 588, 2, 4787, 4789, 5, 1034, 518, 2, 4788, 4785, 3,
	2, 2, 2, 4788, 4786, 3, 2, 2, 2, 4788, 4787, 3, 2, 2, 2, 4789, 819, 3,
	2, 2, 2, 4790, 4792, 7, 516, 2, 2, 4791, 4790, 3, 2, 2, 2, 4791, 4792,
	3, 2, 2, 2, 4792, 4793, 3, 2, 2, 2, 4793, 4794, 7, 479, 2, 2, 4794, 4795,
	9, 58, 2, 2, 4795, 821, 3, 2, 2, 2, 4796, 4798, 7, 367, 2, 2, 4797, 4799,
	5, 1122, 562, 2, 4798, 4797, 3, 2, 2, 2, 4799, 4800, 3, 2, 2, 2, 4800,
	4798, 3, 2, 2, 2, 4800, 4801, 3, 2, 2, 2, 4801, 823, 3, 2, 2, 2, 4802,
	4803, 7, 376, 2, 2, 4803, 4805, 5, 1136, 569, 2, 4804, 4806, 7, 311, 2,
	2, 4805, 4804, 3, 2, 2, 2, 4805, 4806, 3, 2, 2, 2, 4806, 4808, 3, 2, 2,
	2, 4807, 4809, 7, 379, 2, 2, 4808, 4807, 3, 2, 2, 2, 4808, 4809, 3, 2,
	2, 2, 4809, 4811, 3, 2, 2, 2, 4810, 4812, 5, 826, 414, 2, 4811, 4810, 3,
	2, 2, 2, 4811, 4812, 3, 2, 2, 2, 4812, 4814, 3, 2, 2, 2, 4813, 4815, 5,
	828, 415, 2, 4814, 4813, 3, 2, 2, 2, 4814, 4815, 3, 2, 2, 2, 4815, 4817,
	3, 2, 2, 2, 4816, 4818, 5, 830, 416, 2, 4817, 4816, 3, 2, 2, 2, 4817, 4818,
	3, 2, 2, 2, 4818, 4820, 3, 2, 2, 2, 4819, 4821, 5, 1018, 510, 2, 4820,
	4819, 3, 2, 2, 2, 4820, 4821, 3, 2, 2, 2, 4821, 4823, 3, 2, 2, 2, 4822,
	4824, 5, 1020, 511, 2, 4823, 4822, 3, 2, 2, 2, 4823, 4824, 3, 2, 2, 2,
	4824, 4826, 3, 2, 2, 2, 4825, 4827, 5, 1014, 508, 2, 4826, 4825, 3, 2,
	2, 2, 4826, 4827, 3, 2, 2, 2, 4827, 4829, 3, 2, 2, 2, 4828, 4830, 5, 1016,
	509, 2, 4829, 4828, 3, 2, 2, 2, 4829, 4830, 3, 2, 2, 2, 4830, 4832, 3,
	2, 2, 2, 4831, 4833, 7, 172, 2, 2, 4832, 4831, 3, 2, 2, 2, 4832, 4833,
	3, 2, 2, 2, 4833, 825, 3, 2, 2, 2, 4834, 4835, 7, 253, 2, 2, 4835, 4836,
	5, 1076, 539, 2, 4836, 827, 3, 2, 2, 2, 4837, 4839, 7, 516, 2, 2, 4838,
	4837, 3, 2, 2, 2, 4838, 4839, 3, 2, 2, 2, 4839, 4843, 3, 2, 2, 2, 4840,
	4841, 9, 59, 2, 2, 4841, 4844, 7, 288, 2, 2, 4842, 4844, 7, 513, 2, 2,
	4843, 4840, 3, 2, 2, 2, 4843, 4842, 3, 2, 2, 2, 4844, 829, 3, 2, 2, 2,
	4845, 4847, 7, 261, 2, 2, 4846, 4848, 7, 256, 2, 2, 4847, 4846, 3, 2, 2,
	2, 4847, 4848, 3, 2, 2, 2, 4848, 4849, 3, 2, 2, 2, 4849, 4850, 5, 1092,
	547, 2, 4850, 831, 3, 2, 2, 2, 4851, 4854, 7, 377, 2, 2, 4852, 4855, 5,
	834, 418, 2, 4853, 4855, 5, 838, 420, 2, 4854, 4852, 3, 2, 2, 2, 4854,
	4853, 3, 2, 2, 2, 4855, 4857, 3, 2, 2, 2, 4856, 4858, 5, 1030, 516, 2,
	4857, 4856, 3, 2, 2, 2, 4857, 4858, 3, 2, 2, 2, 4858, 4860, 3, 2, 2, 2,
	4859, 4861, 5, 1032, 517, 2, 4860, 4859, 3, 2, 2, 2, 4860, 4861, 3, 2,
	2, 2, 4861, 4863, 3, 2, 2, 2, 4862, 4864, 7, 173, 2, 2, 4863, 4862, 3,
	2, 2, 2, 4863, 4864, 3, 2, 2, 2, 4864, 833, 3, 2, 2, 2, 4865, 4866, 5,
	1130, 566, 2, 4866, 4867, 7, 217, 2, 2, 4867, 4875, 5, 836, 419, 2, 4868,
	4874, 5, 844, 423, 2, 4869, 4874, 5, 846, 424, 2, 4870, 4874, 5, 848, 425,
	2, 4871, 4874, 5, 850, 426, 2, 4872, 4874, 5, 852, 427, 2, 4873, 4868,
	3, 2, 2, 2, 4873, 4869, 3, 2, 2, 2, 4873, 4870, 3, 2, 2, 2, 4873, 4871,
	3, 2, 2, 2, 4873, 4872, 3, 2, 2, 2, 4874, 4877, 3, 2, 2, 2, 4875, 4873,
	3, 2, 2, 2, 4875, 4876, 3, 2, 2, 2, 4876, 835, 3, 2, 2, 2, 4877, 4875,
	3, 2, 2, 2, 4878, 4879, 7, 483, 2, 2, 4879, 4885, 5, 1130, 566, 2, 4880,
	4881, 7, 265, 2, 2, 4881, 4885, 7, 483, 2, 2, 4882, 4883, 7, 22, 2, 2,
	4883, 4885, 7, 483, 2, 2, 4884, 4878, 3, 2, 2, 2, 4884, 4880, 3, 2, 2,
	2, 4884, 4882, 3, 2, 2, 2, 4885, 837, 3, 2, 2, 2, 4886, 4887, 5, 1122,
	562, 2, 4887, 4889, 9, 60, 2, 2, 4888, 4890, 7, 253, 2, 2, 4889, 4888,
	3, 2, 2, 2, 4889, 4890, 3, 2, 2, 2, 4890, 4891, 3, 2, 2, 2, 4891, 4893,
	5, 1076, 539, 2, 4892, 4894, 5, 840, 421, 2, 4893, 4892, 3, 2, 2, 2, 4893,
	4894, 3, 2, 2, 2, 4894, 4896, 3, 2, 2, 2, 4895, 4897, 5, 842, 422, 2, 4896,
	4895, 3, 2, 2, 2, 4896, 4897, 3, 2, 2, 2, 4897, 839, 3, 2, 2, 2, 4898,
	4899, 7, 312, 2, 2, 4899, 4903, 7, 111, 2, 2, 4900, 4902, 5, 538, 270,
	2, 4901, 4900, 3, 2, 2, 2, 4902, 4905, 3, 2, 2, 2, 4903, 4901, 3, 2, 2,
	2, 4903, 4904, 3, 2, 2, 2, 4904, 841, 3, 2, 2, 2, 4905, 4903, 3, 2, 2,
	2, 4906, 4907, 7, 516, 2, 2, 4907, 4911, 7, 111, 2, 2, 4908, 4910, 5, 538,
	270, 2, 4909, 4908, 3, 2, 2, 2, 4910, 4913, 3, 2, 2, 2, 4911, 4909, 3,
	2, 2, 2, 4911, 4912, 3, 2, 2, 2, 4912, 843, 3, 2, 2, 2, 4913, 4911, 3,
	2, 2, 2, 4914, 4916, 7, 41, 2, 2, 4915, 4917, 7, 487, 2, 2, 4916, 4915,
	3, 2, 2, 2, 4916, 4917, 3, 2, 2, 2, 4917, 4920, 3, 2, 2, 2, 4918, 4921,
	5, 1178, 590, 2, 4919, 4921, 5, 1076, 539, 2, 4920, 4918, 3, 2, 2, 2, 4920,
	4919, 3, 2, 2, 2, 4921, 845, 3, 2, 2, 2, 4922, 4924, 7, 516, 2, 2, 4923,
	4922, 3, 2, 2, 2, 4923, 4924, 3, 2, 2, 2, 4924, 4925, 3, 2, 2, 2, 4925,
	4926, 7, 312, 2, 2, 4926, 4927, 7, 513, 2, 2, 4927, 847, 3, 2, 2, 2, 4928,
	4930, 7, 483, 2, 2, 4929, 4931, 7, 241, 2, 2, 4930, 4929, 3, 2, 2, 2, 4930,
	4931, 3, 2, 2, 2, 4931, 4932, 3, 2, 2, 2, 4932, 4933, 5, 1130, 566, 2,
	4933, 849, 3, 2, 2, 2, 4934, 4936, 7, 441, 2, 2, 4935, 4937, 7, 241, 2,
	2, 4936, 4935, 3, 2, 2, 2, 4936, 4937, 3, 2, 2, 2, 4937, 4940, 3, 2, 2,
	2, 4938, 4941, 5, 1178, 590, 2, 4939, 4941, 5, 1076, 539, 2, 4940, 4938,
	3, 2, 2, 2, 4940, 4939, 3, 2, 2, 2, 4941, 851, 3, 2, 2, 2, 4942, 4944,
	7, 459, 2, 2, 4943, 4945, 7, 241, 2, 2, 4944, 4943, 3, 2, 2, 2, 4944, 4945,
	3, 2, 2, 2, 4945, 4946, 3, 2, 2, 2, 4946, 4947, 5, 1076, 539, 2, 4947,
	853, 3, 2, 2, 2, 4948, 4949, 7, 389, 2, 2, 4949, 4952, 5, 1156, 579, 2,
	4950, 4951, 7, 217, 2, 2, 4951, 4953, 5, 1092, 547, 2, 4952, 4950, 3, 2,
	2, 2, 4952, 4953, 3, 2, 2, 2, 4953, 855, 3, 2, 2, 2, 4954, 4955, 7, 405,
	2, 2, 4955, 4957, 5, 1136, 569, 2, 4956, 4958, 7, 379, 2, 2, 4957, 4956,
	3, 2, 2, 2, 4957, 4958, 3, 2, 2, 2, 4958, 4960, 3, 2, 2, 2, 4959, 4961,
	5, 858, 430, 2, 4960, 4959, 3, 2, 2, 2, 4960, 4961, 3, 2, 2, 2, 4961, 4962,
	3, 2, 2, 2, 4962, 4964, 5, 1014, 508, 2, 4963, 4965, 5, 1016, 509, 2, 4964,
	4963, 3, 2, 2, 2, 4964, 4965, 3, 2, 2, 2, 4965, 4967, 3, 2, 2, 2, 4966,
	4968, 7, 174, 2, 2, 4967, 4966, 3, 2, 2, 2, 4967, 4968, 3, 2, 2, 2, 4968,
	857, 3, 2, 2, 2, 4969, 4970, 7, 253, 2, 2, 4970, 4971, 5, 1092, 547, 2,
	4971, 859, 3, 2, 2, 2, 4972, 4973, 7, 410, 2, 2, 4973, 4975, 5, 1156, 579,
	2, 4974, 4976, 5, 862, 432, 2, 4975, 4974, 3, 2, 2, 2, 4975, 4976, 3, 2,
	2, 2, 4976, 4978, 3, 2, 2, 2, 4977, 4979, 5, 1018, 510, 2, 4978, 4977,
	3, 2, 2, 2, 4978, 4979, 3, 2, 2, 2, 4979, 4981, 3, 2, 2, 2, 4980, 4982,
	5, 1020, 511, 2, 4981, 4980, 3, 2, 2, 2, 4981, 4982, 3, 2, 2, 2, 4982,
	4984, 3, 2, 2, 2, 4983, 4985, 7, 175, 2, 2, 4984, 4983, 3, 2, 2, 2, 4984,
	4985, 3, 2, 2, 2, 4985, 861, 3, 2, 2, 2, 4986, 4987, 7, 217, 2, 2, 4987,
	4988, 5, 1076, 539, 2, 4988, 863, 3, 2, 2, 2, 4989, 4991, 7, 420, 2, 2,
	4990, 4992, 7, 11, 2, 2, 4991, 4990, 3, 2, 2, 2, 4991, 4992, 3, 2, 2, 2,
	4992, 4993, 3, 2, 2, 2, 4993, 4995, 5, 1092, 547, 2, 4994, 4996, 5, 866,
	434, 2, 4995, 4994, 3, 2, 2, 2, 4995, 4996, 3, 2, 2, 2, 4996, 4998, 3,
	2, 2, 2, 4997, 4999, 5, 1014, 508, 2, 4998, 4997, 3, 2, 2, 2, 4998, 4999,
	3, 2, 2, 2, 4999, 5001, 3, 2, 2, 2, 5000, 5002, 5, 868, 435, 2, 5001, 5000,
	3, 2, 2, 2, 5002, 5003, 3, 2, 2, 2, 5003, 5001, 3, 2, 2, 2, 5003, 5004,
	3, 2, 2, 2, 5004, 5006, 3, 2, 2, 2, 5005, 5007, 7, 176, 2, 2, 5006, 5005,
	3, 2, 2, 2, 5006, 5007, 3, 2, 2, 2, 5007, 865, 3, 2, 2, 2, 5008, 5009,
	7, 511, 2, 2, 5009, 5010, 5, 1092, 547, 2, 5010, 867, 3, 2, 2, 2, 5011,
	5012, 7, 514, 2, 2, 5012, 5021, 5, 1048, 525, 2, 5013, 5014, 7, 311, 2,
	2, 5014, 5022, 7, 428, 2, 2, 5015, 5017, 5, 538, 270, 2, 5016, 5015, 3,
	2, 2, 2, 5017, 5020, 3, 2, 2, 2, 5018, 5016, 3, 2, 2, 2, 5018, 5019, 3,
	2, 2, 2, 5019, 5022, 3, 2, 2, 2, 5020, 5018, 3, 2, 2, 2, 5021, 5013, 3,
	2, 2, 2, 5021, 5018, 3, 2, 2, 2, 5022, 869, 3, 2, 2, 2, 5023, 5026, 7,
	427, 2, 2, 5024, 5027, 5, 872, 437, 2, 5025, 5027, 5, 874, 438, 2, 5026,
	5024, 3, 2, 2, 2, 5026, 5025, 3, 2, 2, 2, 5027, 5029, 3, 2, 2, 2, 5028,
	5030, 5, 1030, 516, 2, 5029, 5028, 3, 2, 2, 2, 5029, 5030, 3, 2, 2, 2,
	5030, 5032, 3, 2, 2, 2, 5031, 5033, 5, 1032, 517, 2, 5032, 5031, 3, 2,
	2, 2, 5032, 5033, 3, 2, 2, 2, 5033, 871, 3, 2, 2, 2, 5034, 5037, 5, 1076,
	539, 2, 5035, 5037, 5, 1174, 588, 2, 5036, 5034, 3, 2, 2, 2, 5036, 5035,
	3, 2, 2, 2, 5037, 5039, 3, 2, 2, 2, 5038, 5040, 5, 876, 439, 2, 5039, 5038,
	3, 2, 2, 2, 5039, 5040, 3, 2, 2, 2, 5040, 5042, 3, 2, 2, 2, 5041, 5043,
	5, 878, 440, 2, 5042, 5041, 3, 2, 2, 2, 5042, 5043, 3, 2, 2, 2, 5043, 5045,
	3, 2, 2, 2, 5044, 5046, 5, 880, 441, 2, 5045, 5044, 3, 2, 2, 2, 5045, 5046,
	3, 2, 2, 2, 5046, 5048, 3, 2, 2, 2, 5047, 5049, 5, 882, 442, 2, 5048, 5047,
	3, 2, 2, 2, 5048, 5049, 3, 2, 2, 2, 5049, 873, 3, 2, 2, 2, 5050, 5051,
	7, 491, 2, 2, 5051, 5052, 9, 61, 2, 2, 5052, 5053, 5, 1076, 539, 2, 5053,
	875, 3, 2, 2, 2, 5054, 5055, 7, 217, 2, 2, 5055, 5056, 5, 1076, 539, 2,
	5056, 877, 3, 2, 2, 2, 5057, 5062, 7, 516, 2, 2, 5058, 5063, 7, 155, 2,
	2, 5059, 5063, 7, 157, 2, 2, 5060, 5063, 7, 194, 2, 2, 5061, 5063, 5, 1076,
	539, 2, 5062, 5058, 3, 2, 2, 2, 5062, 5059, 3, 2, 2, 2, 5062, 5060, 3,
	2, 2, 2, 5062, 5061, 3, 2, 2, 2, 5063, 879, 3, 2, 2, 2, 5064, 5066, 7,
	396, 2, 2, 5065, 5067, 7, 281, 2, 2, 5066, 5065, 3, 2, 2, 2, 5066, 5067,
	3, 2, 2, 2, 5067, 881, 3, 2, 2, 2, 5068, 5070, 9, 58, 2, 2, 5069, 5071,
	7, 8, 2, 2, 5070, 5069, 3, 2, 2, 2, 5070, 5071, 3, 2, 2, 2, 5071, 5075,
	3, 2, 2, 2, 5072, 5076, 5, 884, 443, 2, 5073, 5076, 5, 886, 444, 2, 5074,
	5076, 5, 888, 445, 2, 5075, 5072, 3, 2, 2, 2, 5075, 5073, 3, 2, 2, 2, 5075,
	5074, 3, 2, 2, 2, 5076, 883, 3, 2, 2, 2, 5077, 5078, 7, 342, 2, 2, 5078,
	885, 3, 2, 2, 2, 5079, 5082, 5, 1076, 539, 2, 5080, 5082, 5, 1174, 588,
	2, 5081, 5079, 3, 2, 2, 2, 5081, 5080, 3, 2, 2, 2, 5082, 5084, 3, 2, 2,
	2, 5083, 5085, 9, 35, 2, 2, 5084, 5083, 3, 2, 2, 2, 5084, 5085, 3, 2, 2,
	2, 5085, 887, 3, 2, 2, 2, 5086, 5087, 5, 1148, 575, 2, 5087, 889, 3, 2,
	2, 2, 5088, 5095, 7, 432, 2, 2, 5089, 5091, 5, 892, 447, 2, 5090, 5089,
	3, 2, 2, 2, 5091, 5092, 3, 2, 2, 2, 5092, 5090, 3, 2, 2, 2, 5092, 5093,
	3, 2, 2, 2, 5093, 5096, 3, 2, 2, 2, 5094, 5096, 5, 894, 448, 2, 5095, 5090,
	3, 2, 2, 2, 5095, 5094, 3, 2, 2, 2, 5096, 891, 3, 2, 2, 2, 5097, 5099,
	5, 896, 449, 2, 5098, 5097, 3, 2, 2, 2, 5099, 5100, 3, 2, 2, 2, 5100, 5098,
	3, 2, 2, 2, 5100, 5101, 3, 2, 2, 2, 5101, 5102, 3, 2, 2, 2, 5102, 5104,
	7, 491, 2, 2, 5103, 5105, 5, 898, 450, 2, 5104, 5103, 3, 2, 2, 2, 5105,
	5106, 3, 2, 2, 2, 5106, 5104, 3, 2, 2, 2, 5106, 5107, 3, 2, 2, 2, 5107,
	893, 3, 2, 2, 2, 5108, 5110, 5, 896, 449, 2, 5109, 5108, 3, 2, 2, 2, 5110,
	5111, 3, 2, 2, 2, 5111, 5109, 3, 2, 2, 2, 5111, 5112, 3, 2, 2, 2, 5112,
	5117, 3, 2, 2, 2, 5113, 5114, 7, 504, 2, 2, 5114, 5118, 7, 51, 2, 2, 5115,
	5116, 7, 150, 2, 2, 5116, 5118, 7, 51, 2, 2, 5117, 5113, 3, 2, 2, 2, 5117,
	5115, 3, 2, 2, 2, 5118, 5119, 3, 2, 2, 2, 5119, 5120, 5, 900, 451, 2, 5120,
	895, 3, 2, 2, 2, 5121, 5122, 5, 1076, 539, 2, 5122, 897, 3, 2, 2, 2, 5123,
	5133, 7, 328, 2, 2, 5124, 5133, 7, 326, 2, 2, 5125, 5128, 7, 184, 2, 2,
	5126, 5129, 5, 1076, 539, 2, 5127, 5129, 5, 1174, 588, 2, 5128, 5126, 3,
	2, 2, 2, 5128, 5127, 3, 2, 2, 2, 5129, 5133, 3, 2, 2, 2, 5130, 5133, 5,
	1076, 539, 2, 5131, 5133, 5, 1174, 588, 2, 5132, 5123, 3, 2, 2, 2, 5132,
	5124, 3, 2, 2, 2, 5132, 5125, 3, 2, 2, 2, 5132, 5130, 3, 2, 2, 2, 5132,
	5131, 3, 2, 2, 2, 5133, 899, 3, 2, 2, 2, 5134, 5137, 5, 1076, 539, 2, 5135,
	5137, 5, 1174, 588, 2, 5136, 5134, 3, 2, 2, 2, 5136, 5135, 3, 2, 2, 2,
	5137, 901, 3, 2, 2, 2, 5138, 5139, 7, 442, 2, 2, 5139, 5141, 5, 1136, 569,
	2, 5140, 5142, 5, 904, 453, 2, 5141, 5140, 3, 2, 2, 2, 5142, 5143, 3, 2,
	2, 2, 5143, 5141, 3, 2, 2, 2, 5143, 5144, 3, 2, 2, 2, 5144, 5146, 3, 2,
	2, 2, 5145, 5147, 5, 906, 454, 2, 5146, 5145, 3, 2, 2, 2, 5146, 5147, 3,
	2, 2, 2, 5147, 5149, 3, 2, 2, 2, 5148, 5150, 5, 908, 455, 2, 5149, 5148,
	3, 2, 2, 2, 5149, 5150, 3, 2, 2, 2, 5150, 5152, 3, 2, 2, 2, 5151, 5153,
	5, 914, 458, 2, 5152, 5151, 3, 2, 2, 2, 5152, 5153, 3, 2, 2, 2, 5153, 5157,
	3, 2, 2, 2, 5154, 5156, 5, 918, 460, 2, 5155, 5154, 3, 2, 2, 2, 5156, 5159,
	3, 2, 2, 2, 5157, 5155, 3, 2, 2, 2, 5157, 5158, 3, 2, 2, 2, 5158, 5161,
	3, 2, 2, 2, 5159, 5157, 3, 2, 2, 2, 5160, 5162, 5, 920, 461, 2, 5161, 5160,
	3, 2, 2, 2, 5161, 5162, 3, 2, 2, 2, 5162, 5166, 3, 2, 2, 2, 5163, 5165,
	5, 924, 463, 2, 5164, 5163, 3, 2, 2, 2, 5165, 5168, 3, 2, 2, 2, 5166, 5164,
	3, 2, 2, 2, 5166, 5167, 3, 2, 2, 2, 5167, 903, 3, 2, 2, 2, 5168, 5166,
	3, 2, 2, 2, 5169, 5171, 7, 328, 2, 2, 5170, 5169, 3, 2, 2, 2, 5170, 5171,
	3, 2, 2, 2, 5171, 5172, 3, 2, 2, 2, 5172, 5174, 9, 43, 2, 2, 5173, 5175,
	7, 261, 2, 2, 5174, 5173, 3, 2, 2, 2, 5174, 5175, 3, 2, 2, 2, 5175, 5177,
	3, 2, 2, 2, 5176, 5178, 5, 1092, 547, 2, 5177, 5176, 3, 2, 2, 2, 5178,
	5179, 3, 2, 2, 2, 5179, 5177, 3, 2, 2, 2, 5179, 5180, 3, 2, 2, 2, 5180,
	905, 3, 2, 2, 2, 5181, 5183, 7, 516, 2, 2, 5182, 5181, 3, 2, 2, 2, 5182,
	5183, 3, 2, 2, 2, 5183, 5184, 3, 2, 2, 2, 5184, 5186, 7, 151, 2, 2, 5185,
	5187, 7, 241, 2, 2, 5186, 5185, 3, 2, 2, 2, 5186, 5187, 3, 2, 2, 2, 5187,
	5189, 3, 2, 2, 2, 5188, 5190, 7, 332, 2, 2, 5189, 5188, 3, 2, 2, 2, 5189,
	5190, 3, 2, 2, 2, 5190, 907, 3, 2, 2, 2, 5191, 5193, 7, 74, 2, 2, 5192,
	5191, 3, 2, 2, 2, 5192, 5193, 3, 2, 2, 2, 5193, 5194, 3, 2, 2, 2, 5194,
	5196, 7, 430, 2, 2, 5195, 5197, 7, 256, 2, 2, 5196, 5195, 3, 2, 2, 2, 5196,
	5197, 3, 2, 2, 2, 5197, 5199, 3, 2, 2, 2, 5198, 5200, 5, 1116, 559, 2,
	5199, 5198, 3, 2, 2, 2, 5200, 5201, 3, 2, 2, 2, 5201, 5199, 3, 2, 2, 2,
	5201, 5202, 3, 2, 2, 2, 5202, 5204, 3, 2, 2, 2, 5203, 5205, 5, 910, 456,
	2, 5204, 5203, 3, 2, 2, 2, 5204, 5205, 3, 2, 2, 2, 5205, 5207, 3, 2, 2,
	2, 5206, 5208, 5, 912, 457, 2, 5207, 5206, 3, 2, 2, 2, 5207, 5208, 3, 2,
	2, 2, 5208, 909, 3, 2, 2, 2, 5209, 5211, 7, 214, 2, 2, 5210, 5209, 3, 2,
	2, 2, 5210, 5211, 3, 2, 2, 2, 5211, 5212, 3, 2, 2, 2, 5212, 5213, 7, 16,
	2, 2, 5213, 5214, 7, 256, 2, 2, 5214, 5215, 5, 1116, 559, 2, 5215, 911,
	3, 2, 2, 2, 5216, 5218, 7, 214, 2, 2, 5217, 5216, 3, 2, 2, 2, 5217, 5218,
	3, 2, 2, 2, 5218, 5219, 3, 2, 2, 2, 5219, 5221, 7, 306, 2, 2, 5220, 5222,
	7, 256, 2, 2, 5221, 5220, 3, 2, 2, 2, 5221, 5222, 3, 2, 2, 2, 5222, 5223,
	3, 2, 2, 2, 5223, 5224, 5, 1116, 559, 2, 5224, 913, 3, 2, 2, 2, 5225, 5226,
	7, 248, 2, 2, 5226, 5228, 7, 358, 2, 2, 5227, 5229, 7, 256, 2, 2, 5228,
	5227, 3, 2, 2, 2, 5228, 5229, 3, 2, 2, 2, 5229, 5230, 3, 2, 2, 2, 5230,
	5232, 5, 1152, 577, 2, 5231, 5233, 5, 916, 459, 2, 5232, 5231, 3, 2, 2,
	2, 5232, 5233, 3, 2, 2, 2, 5233, 915, 3, 2, 2, 2, 5234, 5235, 9, 6, 2,
	2, 5235, 5236, 5, 1152, 577, 2, 5236, 917, 3, 2, 2, 2, 5237, 5239, 7, 508,
	2, 2, 5238, 5240, 5, 1136, 569, 2, 5239, 5238, 3, 2, 2, 2, 5240, 5241,
	3, 2, 2, 2, 5241, 5239, 3, 2, 2, 2, 5241, 5242, 3, 2, 2, 2, 5242, 919,
	3, 2, 2, 2, 5243, 5244, 7, 336, 2, 2, 5244, 5246, 7, 358, 2, 2, 5245, 5247,
	7, 256, 2, 2, 5246, 5245, 3, 2, 2, 2, 5246, 5247, 3, 2, 2, 2, 5247, 5248,
	3, 2, 2, 2, 5248, 5250, 5, 1152, 577, 2, 5249, 5251, 5, 922, 462, 2, 5250,
	5249, 3, 2, 2, 2, 5250, 5251, 3, 2, 2, 2, 5251, 921, 3, 2, 2, 2, 5252,
	5253, 9, 6, 2, 2, 5253, 5254, 5, 1152, 577, 2, 5254, 923, 3, 2, 2, 2, 5255,
	5257, 7, 224, 2, 2, 5256, 5258, 5, 926, 464, 2, 5257, 5256, 3, 2, 2, 2,
	5258, 5259, 3, 2, 2, 2, 5259, 5257, 3, 2, 2, 2, 5259, 5260, 3, 2, 2, 2,
	5260, 925, 3, 2, 2, 2, 5261, 5271, 5, 1136, 569, 2, 5262, 5272, 7, 288,
	2, 2, 5263, 5272, 7, 417, 2, 2, 5264, 5265, 7, 312, 2, 2, 5265, 5272, 7,
	409, 2, 2, 5266, 5272, 7, 108, 2, 2, 5267, 5272, 7, 389, 2, 2, 5268, 5269,
	7, 516, 2, 2, 5269, 5270, 7, 393, 2, 2, 5270, 5272, 7, 108, 2, 2, 5271,
	5262, 3, 2, 2, 2, 5271, 5263, 3, 2, 2, 2, 5271, 5264, 3, 2, 2, 2, 5271,
	5266, 3, 2, 2, 2, 5271, 5267, 3, 2, 2, 2, 5271, 5268, 3, 2, 2, 2, 5271,
	5272, 3, 2, 2, 2, 5272, 927, 3, 2, 2, 2, 5273, 5274, 7, 458, 2, 2, 5274,
	5276, 5, 1136, 569, 2, 5275, 5277, 5, 930, 466, 2, 5276, 5275, 3, 2, 2,
	2, 5276, 5277, 3, 2, 2, 2, 5277, 5279, 3, 2, 2, 2, 5278, 5280, 5, 1018,
	510, 2, 5279, 5278, 3, 2, 2, 2, 5279, 5280, 3, 2, 2, 2, 5280, 5282, 3,
	2, 2, 2, 5281, 5283, 5, 1020, 511, 2, 5282, 5281, 3, 2, 2, 2, 5282, 5283,
	3, 2, 2, 2, 5283, 5285, 3, 2, 2, 2, 5284, 5286, 7, 177, 2, 2, 5285, 5284,
	3, 2, 2, 2, 5285, 5286, 3, 2, 2, 2, 5286, 929, 3, 2, 2, 2, 5287, 5289,
	7, 261, 2, 2, 5288, 5290, 7, 256, 2, 2, 5289, 5288, 3, 2, 2, 2, 5289, 5290,
	3, 2, 2, 2, 5290, 5318, 3, 2, 2, 2, 5291, 5293, 7, 188, 2, 2, 5292, 5294,
	7, 491, 2, 2, 5293, 5292, 3, 2, 2, 2, 5293, 5294, 3, 2, 2, 2, 5294, 5319,
	3, 2, 2, 2, 5295, 5319, 7, 538, 2, 2, 5296, 5298, 7, 227, 2, 2, 5297, 5299,
	7, 481, 2, 2, 5298, 5297, 3, 2, 2, 2, 5298, 5299, 3, 2, 2, 2, 5299, 5319,
	3, 2, 2, 2, 5300, 5319, 7, 546, 2, 2, 5301, 5302, 7, 314, 2, 2, 5302, 5304,
	7, 273, 2, 2, 5303, 5305, 7, 481, 2, 2, 5304, 5303, 3, 2, 2, 2, 5304, 5305,
	3, 2, 2, 2, 5305, 5319, 3, 2, 2, 2, 5306, 5307, 7, 314, 2, 2, 5307, 5319,
	7, 542, 2, 2, 5308, 5310, 7, 227, 2, 2, 5309, 5311, 7, 481, 2, 2, 5310,
	5309, 3, 2, 2, 2, 5310, 5311, 3, 2, 2, 2, 5311, 5312, 3, 2, 2, 2, 5312,
	5313, 7, 331, 2, 2, 5313, 5315, 7, 188, 2, 2, 5314, 5316, 7, 491, 2, 2,
	5315, 5314, 3, 2, 2, 2, 5315, 5316, 3, 2, 2, 2, 5316, 5319, 3, 2, 2, 2,
	5317, 5319, 7, 547, 2, 2, 5318, 5291, 3, 2, 2, 2, 5318, 5295, 3, 2, 2,
	2, 5318, 5296, 3, 2, 2, 2, 5318, 5300, 3, 2, 2, 2, 5318, 5301, 3, 2, 2,
	2, 5318, 5306, 3, 2, 2, 2, 5318, 5308, 3, 2, 2, 2, 5318, 5317, 3, 2, 2,
	2, 5319, 5320, 3, 2, 2, 2, 5320, 5321, 5, 1092, 547, 2, 5321, 931, 3, 2,
	2, 2, 5322, 5325, 7, 460, 2, 2, 5323, 5326, 7, 415, 2, 2, 5324, 5326, 5,
	1174, 588, 2, 5325, 5323, 3, 2, 2, 2, 5325, 5324, 3, 2, 2, 2, 5326, 933,
	3, 2, 2, 2, 5327, 5329, 7, 461, 2, 2, 5328, 5330, 5, 936, 469, 2, 5329,
	5328, 3, 2, 2, 2, 5330, 5331, 3, 2, 2, 2, 5331, 5329, 3, 2, 2, 2, 5331,
	5332, 3, 2, 2, 2, 5332, 5333, 3, 2, 2, 2, 5333, 5335, 5, 944, 473, 2, 5334,
	5336, 5, 946, 474, 2, 5335, 5334, 3, 2, 2, 2, 5335, 5336, 3, 2, 2, 2, 5336,
	5338, 3, 2, 2, 2, 5337, 5339, 5, 1022, 512, 2, 5338, 5337, 3, 2, 2, 2,
	5338, 5339, 3, 2, 2, 2, 5339, 5341, 3, 2, 2, 2, 5340, 5342, 5, 1024, 513,
	2, 5341, 5340, 3, 2, 2, 2, 5341, 5342, 3, 2, 2, 2, 5342, 5344, 3, 2, 2,
	2, 5343, 5345, 7, 178, 2, 2, 5344, 5343, 3, 2, 2, 2, 5344, 5345, 3, 2,
	2, 2, 5345, 935, 3, 2, 2, 2, 5346, 5348, 5, 938, 470, 2, 5347, 5346, 3,
	2, 2, 2, 5348, 5349, 3, 2, 2, 2, 5349, 5347, 3, 2, 2, 2, 5349, 5350, 3,
	2, 2, 2, 5350, 5353, 3, 2, 2, 2, 5351, 5354, 5, 940, 471, 2, 5352, 5354,
	5, 942, 472, 2, 5353, 5351, 3, 2, 2, 2, 5353, 5352, 3, 2, 2, 2, 5354, 937,
	3, 2, 2, 2, 5355, 5358, 5, 1076, 539, 2, 5356, 5358, 5, 1174, 588, 2, 5357,
	5355, 3, 2, 2, 2, 5357, 5356, 3, 2, 2, 2, 5358, 939, 3, 2, 2, 2, 5359,
	5361, 7, 134, 2, 2, 5360, 5362, 7, 51, 2, 2, 5361, 5360, 3, 2, 2, 2, 5361,
	5362, 3, 2, 2, 2, 5362, 5366, 3, 2, 2, 2, 5363, 5367, 7, 441, 2, 2, 5364,
	5367, 5, 1076, 539, 2, 5365, 5367, 5, 1174, 588, 2, 5366, 5363, 3, 2, 2,
	2, 5366, 5364, 3, 2, 2, 2, 5366, 5365, 3, 2, 2, 2, 5367, 941, 3, 2, 2,
	2, 5368, 5371, 7, 214, 2, 2, 5369, 5372, 5, 1076, 539, 2, 5370, 5372, 5,
	1174, 588, 2, 5371, 5369, 3, 2, 2, 2, 5371, 5370, 3, 2, 2, 2, 5372, 943,
	3, 2, 2, 2, 5373, 5374, 7, 253, 2, 2, 5374, 5375, 5, 1076, 539, 2, 5375,
	945, 3, 2, 2, 2, 5376, 5378, 7, 516, 2, 2, 5377, 5376, 3, 2, 2, 2, 5377,
	5378, 3, 2, 2, 2, 5378, 5379, 3, 2, 2, 2, 5379, 5380, 7, 351, 2, 2, 5380,
	5381, 5, 1092, 547, 2, 5381, 947, 3, 2, 2, 2, 5382, 5386, 7, 465, 2, 2,
	5383, 5387, 5, 950, 476, 2, 5384, 5387, 5, 952, 477, 2, 5385, 5387, 5,
	954, 478, 2, 5386, 5383, 3, 2, 2, 2, 5386, 5384, 3, 2, 2, 2, 5386, 5385,
	3, 2, 2, 2, 5387, 5389, 3, 2, 2, 2, 5388, 5390, 5, 1026, 514, 2, 5389,
	5388, 3, 2, 2, 2, 5389, 5390, 3, 2, 2, 2, 5390, 5392, 3, 2, 2, 2, 5391,
	5393, 5, 1028, 515, 2, 5392, 5391, 3, 2, 2, 2, 5392, 5393, 3, 2, 2, 2,
	5393, 5395, 3, 2, 2, 2, 5394, 5396, 7, 179, 2, 2, 5395, 5394, 3, 2, 2,
	2, 5395, 5396, 3, 2, 2, 2, 5396, 949, 3, 2, 2, 2, 5397, 5399, 5, 956, 479,
	2, 5398, 5397, 3, 2, 2, 2, 5399, 5400, 3, 2, 2, 2, 5400, 5398, 3, 2, 2,
	2, 5400, 5401, 3, 2, 2, 2, 5401, 5402, 3, 2, 2, 2, 5402, 5404, 7, 217,
	2, 2, 5403, 5405, 5, 958, 480, 2, 5404, 5403, 3, 2, 2, 2, 5405, 5406, 3,
	2, 2, 2, 5406, 5404, 3, 2, 2, 2, 5406, 5407, 3, 2, 2, 2, 5407, 951, 3,
	2, 2, 2, 5408, 5410, 5, 956, 479, 2, 5409, 5408, 3, 2, 2, 2, 5410, 5411,
	3, 2, 2, 2, 5411, 5409, 3, 2, 2, 2, 5411, 5412, 3, 2, 2, 2, 5412, 5413,
	3, 2, 2, 2, 5413, 5414, 7, 217, 2, 2, 5414, 5415, 5, 960, 481, 2, 5415,
	5417, 7, 224, 2, 2, 5416, 5418, 5, 962, 482, 2, 5417, 5416, 3, 2, 2, 2,
	5418, 5419, 3, 2, 2, 2, 5419, 5417, 3, 2, 2, 2, 5419, 5420, 3, 2, 2, 2,
	5420, 953, 3, 2, 2, 2, 5421, 5422, 9, 52, 2, 2, 5422, 5423, 5, 1092, 547,
	2, 5423, 5424, 7, 217, 2, 2, 5424, 5425, 5, 964, 483, 2, 5425, 955, 3,
	2, 2, 2, 5426, 5429, 5, 1076, 539, 2, 5427, 5429, 5, 1174, 588, 2, 5428,
	5426, 3, 2, 2, 2, 5428, 5427, 3, 2, 2, 2, 5429, 957, 3, 2, 2, 2, 5430,
	5432, 5, 1076, 539, 2, 5431, 5433, 7, 414, 2, 2, 5432, 5431, 3, 2, 2, 2,
	5432, 5433, 3, 2, 2, 2, 5433, 959, 3, 2, 2, 2, 5434, 5437, 5, 1076, 539,
	2, 5435, 5437, 5, 1174, 588, 2, 5436, 5434, 3, 2, 2, 2, 5436, 5435, 3,
	2, 2, 2, 5437, 961, 3, 2, 2, 2, 5438, 5440, 5, 1076, 539, 2, 5439, 5441,
	7, 414, 2, 2, 5440, 5439, 3, 2, 2, 2, 5440, 5441, 3, 2, 2, 2, 5441, 963,
	3, 2, 2, 2, 5442, 5444, 5, 1092, 547, 2, 5443, 5445, 7, 414, 2, 2, 5444,
	5443, 3, 2, 2, 2, 5444, 5445, 3, 2, 2, 2, 5445, 965, 3, 2, 2, 2, 5446,
	5447, 7, 478, 2, 2, 5447, 5448, 5, 1158, 580, 2, 5448, 967, 3, 2, 2, 2,
	5449, 5450, 7, 502, 2, 2, 5450, 5451, 5, 970, 486, 2, 5451, 5453, 5, 976,
	489, 2, 5452, 5454, 5, 984, 493, 2, 5453, 5452, 3, 2, 2, 2, 5453, 5454,
	3, 2, 2, 2, 5454, 5456, 3, 2, 2, 2, 5455, 5457, 5, 986, 494, 2, 5456, 5455,
	3, 2, 2, 2, 5456, 5457, 3, 2, 2, 2, 5457, 5459, 3, 2, 2, 2, 5458, 5460,
	5, 1022, 512, 2, 5459, 5458, 3, 2, 2, 2, 5459, 5460, 3, 2, 2, 2, 5460,
	5462, 3, 2, 2, 2, 5461, 5463, 5, 1024, 513, 2, 5462, 5461, 3, 2, 2, 2,
	5462, 5463, 3, 2, 2, 2, 5463, 5465, 3, 2, 2, 2, 5464, 5466, 7, 180, 2,
	2, 5465, 5464, 3, 2, 2, 2, 5465, 5466, 3, 2, 2, 2, 5466, 969, 3, 2, 2,
	2, 5467, 5475, 5, 1076, 539, 2, 5468, 5472, 5, 972, 487, 2, 5469, 5471,
	5, 974, 488, 2, 5470, 5469, 3, 2, 2, 2, 5471, 5474, 3, 2, 2, 2, 5472, 5470,
	3, 2, 2, 2, 5472, 5473, 3, 2, 2, 2, 5473, 5476, 3, 2, 2, 2, 5474, 5472,
	3, 2, 2, 2, 5475, 5468, 3, 2, 2, 2, 5475, 5476, 3, 2, 2, 2, 5476, 971,
	3, 2, 2, 2, 5477, 5479, 7, 134, 2, 2, 5478, 5480, 7, 51, 2, 2, 5479, 5478,
	3, 2, 2, 2, 5479, 5480, 3, 2, 2, 2, 5480, 5482, 3, 2, 2, 2, 5481, 5483,
	7, 11, 2, 2, 5482, 5481, 3, 2, 2, 2, 5482, 5483, 3, 2, 2, 2, 5483, 5486,
	3, 2, 2, 2, 5484, 5487, 5, 1076, 539, 2, 5485, 5487, 5, 1174, 588, 2, 5486,
	5484, 3, 2, 2, 2, 5486, 5485, 3, 2, 2, 2, 5487, 973, 3, 2, 2, 2, 5488,
	5490, 7, 331, 2, 2, 5489, 5491, 7, 11, 2, 2, 5490, 5489, 3, 2, 2, 2, 5490,
	5491, 3, 2, 2, 2, 5491, 5494, 3, 2, 2, 2, 5492, 5495, 5, 1076, 539, 2,
	5493, 5495, 5, 1174, 588, 2, 5494, 5492, 3, 2, 2, 2, 5494, 5493, 3, 2,
	2, 2, 5495, 975, 3, 2, 2, 2, 5496, 5498, 7, 253, 2, 2, 5497, 5499, 5, 978,
	490, 2, 5498, 5497, 3, 2, 2, 2, 5499, 5500, 3, 2, 2, 2, 5500, 5498, 3,
	2, 2, 2, 5500, 5501, 3, 2, 2, 2, 5501, 977, 3, 2, 2, 2, 5502, 5504, 5,
	1076, 539, 2, 5503, 5505, 5, 980, 491, 2, 5504, 5503, 3, 2, 2, 2, 5504,
	5505, 3, 2, 2, 2, 5505, 5507, 3, 2, 2, 2, 5506, 5508, 5, 982, 492, 2, 5507,
	5506, 3, 2, 2, 2, 5507, 5508, 3, 2, 2, 2, 5508, 979, 3, 2, 2, 2, 5509,
	5511, 7, 135, 2, 2, 5510, 5512, 7, 241, 2, 2, 5511, 5510, 3, 2, 2, 2, 5511,
	5512, 3, 2, 2, 2, 5512, 5513, 3, 2, 2, 2, 5513, 5514, 5, 1076, 539, 2,
	5514, 981, 3, 2, 2, 2, 5515, 5517, 7, 107, 2, 2, 5516, 5518, 7, 241, 2,
	2, 5517, 5516, 3, 2, 2, 2, 5517, 5518, 3, 2, 2, 2, 5518, 5519, 3, 2, 2,
	2, 5519, 5520, 5, 1076, 539, 2, 5520, 983, 3, 2, 2, 2, 5521, 5523, 7, 516,
	2, 2, 5522, 5521, 3, 2, 2, 2, 5522, 5523, 3, 2, 2, 2, 5523, 5524, 3, 2,
	2, 2, 5524, 5525, 7, 351, 2, 2, 5525, 5526, 5, 1092, 547, 2, 5526, 985,
	3, 2, 2, 2, 5527, 5529, 7, 474, 2, 2, 5528, 5530, 7, 241, 2, 2, 5529, 5528,
	3, 2, 2, 2, 5529, 5530, 3, 2, 2, 2, 5530, 5531, 3, 2, 2, 2, 5531, 5532,
	5, 1092, 547, 2, 5532, 987, 3, 2, 2, 2, 5533, 5536, 7, 507, 2, 2, 5534,
	5537, 5, 990, 496, 2, 5535, 5537, 5, 994, 498, 2, 5536, 5534, 3, 2, 2,
	2, 5536, 5535, 3, 2, 2, 2, 5537, 989, 3, 2, 2, 2, 5538, 5540, 7, 225, 2,
	2, 5539, 5538, 3, 2, 2, 2, 5539, 5540, 3, 2, 2, 2, 5540, 5541, 3, 2, 2,
	2, 5541, 5543, 7, 9, 2, 2, 5542, 5544, 7, 455, 2, 2, 5543, 5542, 3, 2,
	2, 2, 5543, 5544, 3, 2, 2, 2, 5544, 5545, 3, 2, 2, 2, 5545, 5546, 9, 62,
	2, 2, 5546, 5548, 7, 358, 2, 2, 5547, 5549, 7, 328, 2, 2, 5548, 5547, 3,
	2, 2, 2, 5548, 5549, 3, 2, 2, 2, 5549, 5550, 3, 2, 2, 2, 5550, 5551, 5,
	992, 497, 2, 5551, 991, 3, 2, 2, 2, 5552, 5562, 7, 248, 2, 2, 5553, 5562,
	7, 336, 2, 2, 5554, 5562, 7, 234, 2, 2, 5555, 5562, 7, 203, 2, 2, 5556,
	5558, 5, 1136, 569, 2, 5557, 5556, 3, 2, 2, 2, 5558, 5559, 3, 2, 2, 2,
	5559, 5557, 3, 2, 2, 2, 5559, 5560, 3, 2, 2, 2, 5560, 5562, 3, 2, 2, 2,
	5561, 5552, 3, 2, 2, 2, 5561, 5553, 3, 2, 2, 2, 5561, 5554, 3, 2, 2, 2,
	5561, 5555, 3, 2, 2, 2, 5561, 5557, 3, 2, 2, 2, 5562, 993, 3, 2, 2, 2,
	5563, 5565, 7, 214, 2, 2, 5564, 5563, 3, 2, 2, 2, 5564, 5565, 3, 2, 2,
	2, 5565, 5566, 3, 2, 2, 2, 5566, 5568, 7, 127, 2, 2, 5567, 5569, 7, 328,
	2, 2, 5568, 5567, 3, 2, 2, 2, 5568, 5569, 3, 2, 2, 2, 5569, 5571, 3, 2,
	2, 2, 5570, 5572, 5, 996, 499, 2, 5571, 5570, 3, 2, 2, 2, 5572, 5573, 3,
	2, 2, 2, 5573, 5571, 3, 2, 2, 2, 5573, 5574, 3, 2, 2, 2, 5574, 995, 3,
	2, 2, 2, 5575, 5576, 7, 11, 2, 2, 5576, 5588, 7, 360, 2, 2, 5577, 5579,
	7, 11, 2, 2, 5578, 5580, 7, 387, 2, 2, 5579, 5578, 3, 2, 2, 2, 5579, 5580,
	3, 2, 2, 2, 5580, 5582, 3, 2, 2, 2, 5581, 5583, 7, 325, 2, 2, 5582, 5581,
	3, 2, 2, 2, 5582, 5583, 3, 2, 2, 2, 5583, 5584, 3, 2, 2, 2, 5584, 5588,
	5, 1076, 539, 2, 5585, 5588, 5, 1152, 577, 2, 5586, 5588, 5, 1136, 569,
	2, 5587, 5575, 3, 2, 2, 2, 5587, 5577, 3, 2, 2, 2, 5587, 5585, 3, 2, 2,
	2, 5587, 5586, 3, 2, 2, 2, 5588, 997, 3, 2, 2, 2, 5589, 5590, 7, 519, 2,
	2, 5590, 5592, 5, 1156, 579, 2, 5591, 5593, 5, 1000, 501, 2, 5592, 5591,
	3, 2, 2, 2, 5592, 5593, 3, 2, 2, 2, 5593, 5595, 3, 2, 2, 2, 5594, 5596,
	5, 1002, 502, 2, 5595, 5594, 3, 2, 2, 2, 5595, 5596, 3, 2, 2, 2, 5596,
	5598, 3, 2, 2, 2, 5597, 5599, 5, 1010, 506, 2, 5598, 5597, 3, 2, 2, 2,
	5598, 5599, 3, 2, 2, 2, 5599, 5601, 3, 2, 2, 2, 5600, 5602, 5, 1012, 507,
	2, 5601, 5600, 3, 2, 2, 2, 5601, 5602, 3, 2, 2, 2, 5602, 5604, 3, 2, 2,
	2, 5603, 5605, 5, 1018, 510, 2, 5604, 5603, 3, 2, 2, 2, 5604, 5605, 3,
	2, 2, 2, 5605, 5607, 3, 2, 2, 2, 5606, 5608, 5, 1020, 511, 2, 5607, 5606,
	3, 2, 2, 2, 5607, 5608, 3, 2, 2, 2, 5608, 5610, 3, 2, 2, 2, 5609, 5611,
	7, 181, 2, 2, 5610, 5609, 3, 2, 2, 2, 5610, 5611, 3, 2, 2, 2, 5611, 999,
	3, 2, 2, 2, 5612, 5615, 7, 217, 2, 2, 5613, 5616, 5, 1076, 539, 2, 5614,
	5616, 5, 1174, 588, 2, 5615, 5613, 3, 2, 2, 2, 5615, 5614, 3, 2, 2, 2,
	5616, 1001, 3, 2, 2, 2, 5617, 5619, 9, 58, 2, 2, 5618, 5620, 7, 8, 2, 2,
	5619, 5618, 3, 2, 2, 2, 5619, 5620, 3, 2, 2, 2, 5620, 5624, 3, 2, 2, 2,
	5621, 5625, 5, 1004, 503, 2, 5622, 5625, 5, 1006, 504, 2, 5623, 5625, 5,
	1008, 505, 2, 5624, 5621, 3, 2, 2, 2, 5624, 5622, 3, 2, 2, 2, 5624, 5623,
	3, 2, 2, 2, 5625, 1003, 3, 2, 2, 2, 5626, 5627, 7, 342, 2, 2, 5627, 1005,
	3, 2, 2, 2, 5628, 5631, 5, 1076, 539, 2, 5629, 5631, 5, 1174, 588, 2, 5630,
	5628, 3, 2, 2, 2, 5630, 5629, 3, 2, 2, 2, 5631, 5633, 3, 2, 2, 2, 5632,
	5634, 9, 35, 2, 2, 5633, 5632, 3, 2, 2, 2, 5633, 5634, 3, 2, 2, 2, 5634,
	1007, 3, 2, 2, 2, 5635, 5636, 5, 1148, 575, 2, 5636, 1009, 3, 2, 2, 2,
	5637, 5639, 7, 32, 2, 2, 5638, 5637, 3, 2, 2, 2, 5638, 5639, 3, 2, 2, 2,
	5639, 5640, 3, 2, 2, 2, 5640, 5644, 9, 63, 2, 2, 5641, 5643, 5, 538, 270,
	2, 5642, 5641, 3, 2, 2, 2, 5643, 5646, 3, 2, 2, 2, 5644, 5642, 3, 2, 2,
	2, 5644, 5645, 3, 2, 2, 2, 5645, 1011, 3, 2, 2, 2, 5646, 5644, 3, 2, 2,
	2, 5647, 5649, 7, 314, 2, 2, 5648, 5650, 7, 32, 2, 2, 5649, 5648, 3, 2,
	2, 2, 5649, 5650, 3, 2, 2, 2, 5650, 5651, 3, 2, 2, 2, 5651, 5655, 9, 63,
	2, 2, 5652, 5654, 5, 538, 270, 2, 5653, 5652, 3, 2, 2, 2, 5654, 5657, 3,
	2, 2, 2, 5655, 5653, 3, 2, 2, 2, 5655, 5656, 3, 2, 2, 2, 5656, 1013, 3,
	2, 2, 2, 5657, 5655, 3, 2, 2, 2, 5658, 5660, 7, 32, 2, 2, 5659, 5658, 3,
	2, 2, 2, 5659, 5660, 3, 2, 2, 2, 5660, 5661, 3, 2, 2, 2, 5661, 5665, 7,
	160, 2, 2, 5662, 5664, 5, 538, 270, 2, 5663, 5662, 3, 2, 2, 2, 5664, 5667,
	3, 2, 2, 2, 5665, 5663, 3, 2, 2, 2, 5665, 5666, 3, 2, 2, 2, 5666, 1015,
	3, 2, 2, 2, 5667, 5665, 3, 2, 2, 2, 5668, 5670, 7, 314, 2, 2, 5669, 5671,
	7, 32, 2, 2, 5670, 5669, 3, 2, 2, 2, 5670, 5671, 3, 2, 2, 2, 5671, 5672,
	3, 2, 2, 2, 5672, 5676, 7, 160, 2, 2, 5673, 5675, 5, 538, 270, 2, 5674,
	5673, 3, 2, 2, 2, 5675, 5678, 3, 2, 2, 2, 5676, 5674, 3, 2, 2, 2, 5676,
	5677, 3, 2, 2, 2, 5677, 1017, 3, 2, 2, 2, 5678, 5676, 3, 2, 2, 2, 5679,
	5681, 7, 254, 2, 2, 5680, 5682, 7, 261, 2, 2, 5681, 5680, 3, 2, 2, 2, 5681,
	5682, 3, 2, 2, 2, 5682, 5686, 3, 2, 2, 2, 5683, 5685, 5, 538, 270, 2, 5684,
	5683, 3, 2, 2, 2, 5685, 5688, 3, 2, 2, 2, 5686, 5684, 3, 2, 2, 2, 5686,
	5687, 3, 2, 2, 2, 5687, 1019, 3, 2, 2, 2, 5688, 5686, 3, 2, 2, 2, 5689,
	5690, 7, 314, 2, 2, 5690, 5692, 7, 254, 2, 2, 5691, 5693, 7, 261, 2, 2,
	5692, 5691, 3, 2, 2, 2, 5692, 5693, 3, 2, 2, 2, 5693, 5697, 3, 2, 2, 2,
	5694, 5696, 5, 538, 270, 2, 5695, 5694, 3, 2, 2, 2, 5696, 5699, 3, 2, 2,
	2, 5697, 5695, 3, 2, 2, 2, 5697, 5698, 3, 2, 2, 2, 5698, 1021, 3, 2, 2,
	2, 5699, 5697, 3, 2, 2, 2, 5700, 5702, 7, 328, 2, 2, 5701, 5700, 3, 2,
	2, 2, 5701, 5702, 3, 2, 2, 2, 5702, 5703, 3, 2, 2, 2, 5703, 5707, 7, 337,
	2, 2, 5704, 5706, 5, 538, 270, 2, 5705, 5704, 3, 2, 2, 2, 5706, 5709, 3,
	2, 2, 2, 5707, 5705, 3, 2, 2, 2, 5707, 5708, 3, 2, 2, 2, 5708, 1023, 3,
	2, 2, 2, 5709, 5707, 3, 2, 2, 2, 5710, 5712, 7, 314, 2, 2, 5711, 5713,
	7, 328, 2, 2, 5712, 5711, 3, 2, 2, 2, 5712, 5713, 3, 2, 2, 2, 5713, 5714,
	3, 2, 2, 2, 5714, 5718, 7, 337, 2, 2, 5715, 5717, 5, 538, 270, 2, 5716,
	5715, 3, 2, 2, 2, 5717, 5720, 3, 2, 2, 2, 5718, 5716, 3, 2, 2, 2, 5718,
	5719, 3, 2, 2, 2, 5719, 1025, 3, 2, 2, 2, 5720, 5718, 3, 2, 2, 2, 5721,
	5723, 7, 328, 2, 2, 5722, 5721, 3, 2, 2, 2, 5722, 5723, 3, 2, 2, 2, 5723,
	5724, 3, 2, 2, 2, 5724, 5725, 7, 441, 2, 2, 5725, 5729, 7, 190, 2, 2, 5726,
	5728, 5, 538, 270, 2, 5727, 5726, 3, 2, 2, 2, 5728, 5731, 3, 2, 2, 2, 5729,
	5727, 3, 2, 2, 2, 5729, 5730, 3, 2, 2, 2, 5730, 1027, 3, 2, 2, 2, 5731,
	5729, 3, 2, 2, 2, 5732, 5734, 7, 314, 2, 2, 5733, 5735, 7, 328, 2, 2, 5734,
	5733, 3, 2, 2, 2, 5734, 5735, 3, 2, 2, 2, 5735, 5736, 3, 2, 2, 2, 5736,
	5737, 7, 441, 2, 2, 5737, 5741, 7, 190, 2, 2, 5738, 5740, 5, 538, 270,
	2, 5739, 5738, 3, 2, 2, 2, 5740, 5743, 3, 2, 2, 2, 5741, 5739, 3, 2, 2,
	2, 5741, 5742, 3, 2, 2, 2, 5742, 1029, 3, 2, 2, 2, 5743, 5741, 3, 2, 2,
	2, 5744, 5746, 7, 328, 2, 2, 5745, 5744, 3, 2, 2, 2, 5745, 5746, 3, 2,
	2, 2, 5746, 5747, 3, 2, 2, 2, 5747, 5751, 7, 198, 2, 2, 5748, 5750, 5,
	538, 270, 2, 5749, 5748, 3, 2, 2, 2, 5750, 5753, 3, 2, 2, 2, 5751, 5749,
	3, 2, 2, 2, 5751, 5752, 3, 2, 2, 2, 5752, 1031, 3, 2, 2, 2, 5753, 5751,
	3, 2, 2, 2, 5754, 5756, 7, 314, 2, 2, 5755, 5757, 7, 328, 2, 2, 5756, 5755,
	3, 2, 2, 2, 5756, 5757, 3, 2, 2, 2, 5757, 5758, 3, 2, 2, 2, 5758, 5762,
	7, 198, 2, 2, 5759, 5761, 5, 538, 270, 2, 5760, 5759, 3, 2, 2, 2, 5761,
	5764, 3, 2, 2, 2, 5762, 5760, 3, 2, 2, 2, 5762, 5763, 3, 2, 2, 2, 5763,
	1033, 3, 2, 2, 2, 5764, 5762, 3, 2, 2, 2, 5765, 5769, 5, 1038, 520, 2,
	5766, 5768, 5, 1036, 519, 2, 5767, 5766, 3, 2, 2, 2, 5768, 5771, 3, 2,
	2, 2, 5769, 5767, 3, 2, 2, 2, 5769, 5770, 3, 2, 2, 2, 5770, 1035, 3, 2,
	2, 2, 5771, 5769, 3, 2, 2, 2, 5772, 5773, 9, 64, 2, 2, 5773, 5774, 5, 1038,
	520, 2, 5774, 1037, 3, 2, 2, 2, 5775, 5779, 5, 1042, 522, 2, 5776, 5778,
	5, 1040, 521, 2, 5777, 5776, 3, 2, 2, 2, 5778, 5781, 3, 2, 2, 2, 5779,
	5777, 3, 2, 2, 2, 5779, 5780, 3, 2, 2, 2, 5780, 1039, 3, 2, 2, 2, 5781,
	5779, 3, 2, 2, 2, 5782, 5783, 9, 65, 2, 2, 5783, 5784, 5, 1042, 522, 2,
	5784, 1041, 3, 2, 2, 2, 5785, 5787, 9, 64, 2, 2, 5786, 5785, 3, 2, 2, 2,
	5786, 5787, 3, 2, 2, 2, 5787, 5788, 3, 2, 2, 2, 5788, 5792, 5, 1046, 524,
	2, 5789, 5791, 5, 1044, 523, 2, 5790, 5789, 3, 2, 2, 2, 5791, 5794, 3,
	2, 2, 2, 5792, 5790, 3, 2, 2, 2, 5792, 5793, 3, 2, 2, 2, 5793, 1043, 3,
	2, 2, 2, 5794, 5792, 3, 2, 2, 2, 5795, 5796, 7, 529, 2, 2, 5796, 5797,
	5, 1046, 524, 2, 5797, 1045, 3, 2, 2, 2, 5798, 5799, 7, 544, 2, 2, 5799,
	5800, 5, 1034, 518, 2, 5800, 5801, 7, 551, 2, 2, 5801, 5805, 3, 2, 2, 2,
	5802, 5805, 5, 1076, 539, 2, 5803, 5805, 5, 1174, 588, 2, 5804, 5798, 3,
	2, 2, 2, 5804, 5802, 3, 2, 2, 2, 5804, 5803, 3, 2, 2, 2, 5805, 1047, 3,
	2, 2, 2, 5806, 5810, 5, 1052, 527, 2, 5807, 5809, 5, 1050, 526, 2, 5808,
	5807, 3, 2, 2, 2, 5809, 5812, 3, 2, 2, 2, 5810, 5808, 3, 2, 2, 2, 5810,
	5811, 3, 2, 2, 2, 5811, 1049, 3, 2, 2, 2, 5812, 5810, 3, 2, 2, 2, 5813,
	5820, 9, 66, 2, 2, 5814, 5821, 5, 1052, 527, 2, 5815, 5817, 5, 1074, 538,
	2, 5816, 5815, 3, 2, 2, 2, 5817, 5818, 3, 2, 2, 2, 5818, 5816, 3, 2, 2,
	2, 5818, 5819, 3, 2, 2, 2, 5819, 5821, 3, 2, 2, 2, 5820, 5814, 3, 2, 2,
	2, 5820, 5816, 3, 2, 2, 2, 5821, 1051, 3, 2, 2, 2, 5822, 5824, 7, 314,
	2, 2, 5823, 5822, 3, 2, 2, 2, 5823, 5824, 3, 2, 2, 2, 5824, 5825, 3, 2,
	2, 2, 5825, 5826, 5, 1054, 528, 2, 5826, 1053, 3, 2, 2, 2, 5827, 5828,
	7, 544, 2, 2, 5828, 5829, 5, 1048, 525, 2, 5829, 5830, 7, 551, 2, 2, 5830,
	5835, 3, 2, 2, 2, 5831, 5835, 5, 1062, 532, 2, 5832, 5835, 5, 1056, 529,
	2, 5833, 5835, 5, 1058, 530, 2, 5834, 5827, 3, 2, 2, 2, 5834, 5831, 3,
	2, 2, 2, 5834, 5832, 3, 2, 2, 2, 5834, 5833, 3, 2, 2, 2, 5835, 1055, 3,
	2, 2, 2, 5836, 5838, 5, 1076, 539, 2, 5837, 5839, 7, 256, 2, 2, 5838, 5837,
	3, 2, 2, 2, 5838, 5839, 3, 2, 2, 2, 5839, 5841, 3, 2, 2, 2, 5840, 5842,
	7, 314, 2, 2, 5841, 5840, 3, 2, 2, 2, 5841, 5842, 3, 2, 2, 2, 5842, 5850,
	3, 2, 2, 2, 5843, 5851, 7, 318, 2, 2, 5844, 5851, 7, 13, 2, 2, 5845, 5851,
	7, 14, 2, 2, 5846, 5851, 7, 15, 2, 2, 5847, 5851, 7, 118, 2, 2, 5848, 5851,
	7, 259, 2, 2, 5849, 5851, 5, 1124, 563, 2, 5850, 5843, 3, 2, 2, 2, 5850,
	5844, 3, 2, 2, 2, 5850, 5845, 3, 2, 2, 2, 5850, 5846, 3, 2, 2, 2, 5850,
	5847, 3, 2, 2, 2, 5850, 5848, 3, 2, 2, 2, 5850, 5849, 3, 2, 2, 2, 5851,
	1057, 3, 2, 2, 2, 5852, 5874, 5, 1128, 565, 2, 5853, 5855, 5, 1104, 553,
	2, 5854, 5853, 3, 2, 2, 2, 5855, 5858, 3, 2, 2, 2, 5856, 5854, 3, 2, 2,
	2, 5856, 5857, 3, 2, 2, 2, 5857, 5860, 3, 2, 2, 2, 5858, 5856, 3, 2, 2,
	2, 5859, 5861, 5, 1106, 554, 2, 5860, 5859, 3, 2, 2, 2, 5860, 5861, 3,
	2, 2, 2, 5861, 5865, 3, 2, 2, 2, 5862, 5864, 5, 1060, 531, 2, 5863, 5862,
	3, 2, 2, 2, 5864, 5867, 3, 2, 2, 2, 5865, 5863, 3, 2, 2, 2, 5865, 5866,
	3, 2, 2, 2, 5866, 5875, 3, 2, 2, 2, 5867, 5865, 3, 2, 2, 2, 5868, 5870,
	5, 1108, 555, 2, 5869, 5868, 3, 2, 2, 2, 5870, 5873, 3, 2, 2, 2, 5871,
	5869, 3, 2, 2, 2, 5871, 5872, 3, 2, 2, 2, 5872, 5875, 3, 2, 2, 2, 5873,
	5871, 3, 2, 2, 2, 5874, 5856, 3, 2, 2, 2, 5874, 5871, 3, 2, 2, 2, 5875,
	1059, 3, 2, 2, 2, 5876, 5877, 7, 544, 2, 2, 5877, 5884, 5, 1088, 545, 2,
	5878, 5880, 7, 531, 2, 2, 5879, 5878, 3, 2, 2, 2, 5879, 5880, 3, 2, 2,
	2, 5880, 5881, 3, 2, 2, 2, 5881, 5883, 5, 1088, 545, 2, 5882, 5879, 3,
	2, 2, 2, 5883, 5886, 3, 2, 2, 2, 5884, 5882, 3, 2, 2, 2, 5884, 5885, 3,
	2, 2, 2, 5885, 5887, 3, 2, 2, 2, 5886, 5884, 3, 2, 2, 2, 5887, 5888, 7,
	551, 2, 2, 5888, 1061, 3, 2, 2, 2, 5889, 5893, 5, 1064, 533, 2, 5890, 5893,
	5, 1066, 534, 2, 5891, 5893, 5, 1068, 535, 2, 5892, 5889, 3, 2, 2, 2, 5892,
	5890, 3, 2, 2, 2, 5892, 5891, 3, 2, 2, 2, 5893, 1063, 3, 2, 2, 2, 5894,
	5896, 5, 1034, 518, 2, 5895, 5897, 7, 256, 2, 2, 5896, 5895, 3, 2, 2, 2,
	5896, 5897, 3, 2, 2, 2, 5897, 5899, 3, 2, 2, 2, 5898, 5900, 7, 314, 2,
	2, 5899, 5898, 3, 2, 2, 2, 5899, 5900, 3, 2, 2, 2, 5900, 5901, 3, 2, 2,
	2, 5901, 5902, 9, 67, 2, 2, 5902, 1065, 3, 2, 2, 2, 5903, 5904, 5, 1034,
	518, 2, 5904, 5905, 5, 1072, 537, 2, 5905, 5906, 5, 1034, 518, 2, 5906,
	1067, 3, 2, 2, 2, 5907, 5908, 5, 1034, 518, 2, 5908, 5909, 5, 1072, 537,
	2, 5909, 5910, 7, 544, 2, 2, 5910, 5911, 5, 1070, 536, 2, 5911, 5912, 7,
	551, 2, 2, 5912, 1069, 3, 2, 2, 2, 5913, 5916, 5, 1034, 518, 2, 5914, 5915,
	9, 66, 2, 2, 5915, 5917, 5, 1034, 518, 2, 5916, 5914, 3, 2, 2, 2, 5917,
	5918, 3, 2, 2, 2, 5918, 5916, 3, 2, 2, 2, 5918, 5919, 3, 2, 2, 2, 5919,
	1071, 3, 2, 2, 2, 5920, 5922, 9, 10, 2, 2, 5921, 5920, 3, 2, 2, 2, 5921,
	5922, 3, 2, 2, 2, 5922, 5964, 3, 2, 2, 2, 5923, 5925, 7, 314, 2, 2, 5924,
	5923, 3, 2, 2, 2, 5924, 5925, 3, 2, 2, 2, 5925, 5941, 3, 2, 2, 2, 5926,
	5928, 7, 227, 2, 2, 5927, 5929, 7, 481, 2, 2, 5928, 5927, 3, 2, 2, 2, 5928,
	5929, 3, 2, 2, 2, 5929, 5942, 3, 2, 2, 2, 5930, 5942, 7, 546, 2, 2, 5931,
	5933, 7, 273, 2, 2, 5932, 5934, 7, 481, 2, 2, 5933, 5932, 3, 2, 2, 2, 5933,
	5934, 3, 2, 2, 2, 5934, 5942, 3, 2, 2, 2, 5935, 5942, 7, 542, 2, 2, 5936,
	5938, 7, 188, 2, 2, 5937, 5939, 7, 491, 2, 2, 5938, 5937, 3, 2, 2, 2, 5938,
	5939, 3, 2, 2, 2, 5939, 5942, 3, 2, 2, 2, 5940, 5942, 7, 538, 2, 2, 5941,
	5926, 3, 2, 2, 2, 5941, 5930, 3, 2, 2, 2, 5941, 5931, 3, 2, 2, 2, 5941,
	5935, 3, 2, 2, 2, 5941, 5936, 3, 2, 2, 2, 5941, 5940, 3, 2, 2, 2, 5942,
	5965, 3, 2, 2, 2, 5943, 5965, 7, 548, 2, 2, 5944, 5946, 7, 227, 2, 2, 5945,
	5947, 7, 481, 2, 2, 5946, 5945, 3, 2, 2, 2, 5946, 5947, 3, 2, 2, 2, 5947,
	5948, 3, 2, 2, 2, 5948, 5949, 7, 331, 2, 2, 5949, 5951, 7, 188, 2, 2, 5950,
	5952, 7, 491, 2, 2, 5951, 5950, 3, 2, 2, 2, 5951, 5952, 3, 2, 2, 2, 5952,
	5965, 3, 2, 2, 2, 5953, 5965, 7, 547, 2, 2, 5954, 5956, 7, 273, 2, 2, 5955,
	5957, 7, 481, 2, 2, 5956, 5955, 3, 2, 2, 2, 5956, 5957, 3, 2, 2, 2, 5957,
	5958, 3, 2, 2, 2, 5958, 5959, 7, 331, 2, 2, 5959, 5961, 7, 188, 2, 2, 5960,
	5962, 7, 491, 2, 2, 5961, 5960, 3, 2, 2, 2, 5961, 5962, 3, 2, 2, 2, 5962,
	5965, 3, 2, 2, 2, 5963, 5965, 7, 543, 2, 2, 5964, 5924, 3, 2, 2, 2, 5964,
	5943, 3, 2, 2, 2, 5964, 5944, 3, 2, 2, 2, 5964, 5953, 3, 2, 2, 2, 5964,
	5954, 3, 2, 2, 2, 5964, 5963, 3, 2, 2, 2, 5965, 1073, 3, 2, 2, 2, 5966,
	5968, 7, 314, 2, 2, 5967, 5966, 3, 2, 2, 2, 5967, 5968, 3, 2, 2, 2, 5968,
	5970, 3, 2, 2, 2, 5969, 5971, 5, 1072, 537, 2, 5970, 5969, 3, 2, 2, 2,
	5970, 5971, 3, 2, 2, 2, 5971, 5978, 3, 2, 2, 2, 5972, 5979, 5, 1034, 518,
	2, 5973, 5974, 7, 544, 2, 2, 5974, 5975, 5, 1034, 518, 2, 5975, 5976, 5,
	1074, 538, 2, 5976, 5977, 7, 551, 2, 2, 5977, 5979, 3, 2, 2, 2, 5978, 5972,
	3, 2, 2, 2, 5978, 5973, 3, 2, 2, 2, 5979, 1075, 3, 2, 2, 2, 5980, 5985,
	5, 1092, 547, 2, 5981, 5985, 5, 1078, 540, 2, 5982, 5985, 5, 1080, 541,
	2, 5983, 5985, 5, 1188, 595, 2, 5984, 5980, 3, 2, 2, 2, 5984, 5981, 3,
	2, 2, 2, 5984, 5982, 3, 2, 2, 2, 5984, 5983, 3, 2, 2, 2, 5985, 1077, 3,
	2, 2, 2, 5986, 6002, 5, 1092, 547, 2, 5987, 5988, 7, 544, 2, 2, 5988, 5995,
	5, 1088, 545, 2, 5989, 5991, 7, 531, 2, 2, 5990, 5989, 3, 2, 2, 2, 5990,
	5991, 3, 2, 2, 2, 5991, 5992, 3, 2, 2, 2, 5992, 5994, 5, 1088, 545, 2,
	5993, 5990, 3, 2, 2, 2, 5994, 5997, 3, 2, 2, 2, 5995, 5993, 3, 2, 2, 2,
	5995, 5996, 3, 2, 2, 2, 5996, 5998, 3, 2, 2, 2, 5997, 5995, 3, 2, 2, 2,
	5998, 5999, 7, 551, 2, 2, 5999, 6001, 3, 2, 2, 2, 6000, 5987, 3, 2, 2,
	2, 6001, 6004, 3, 2, 2, 2, 6002, 6000, 3, 2, 2, 2, 6002, 6003, 3, 2, 2,
	2, 6003, 6006, 3, 2, 2, 2, 6004, 6002, 3, 2, 2, 2, 6005, 6007, 5, 1082,
	542, 2, 6006, 6005, 3, 2, 2, 2, 6006, 6007, 3, 2, 2, 2, 6007, 1079, 3,
	2, 2, 2, 6008, 6009, 7, 219, 2, 2, 6009, 6025, 5, 1138, 570, 2, 6010, 6011,
	7, 544, 2, 2, 6011, 6018, 5, 1090, 546, 2, 6012, 6014, 7, 531, 2, 2, 6013,
	6012, 3, 2, 2, 2, 6013, 6014, 3, 2, 2, 2, 6014, 6015, 3, 2, 2, 2, 6015,
	6017, 5, 1090, 546, 2, 6016, 6013, 3, 2, 2, 2, 6017, 6020, 3, 2, 2, 2,
	6018, 6016, 3, 2, 2, 2, 6018, 6019, 3, 2, 2, 2, 6019, 6021, 3, 2, 2, 2,
	6020, 6018, 3, 2, 2, 2, 6021, 6022, 7, 551, 2, 2, 6022, 6024, 3, 2, 2,
	2, 6023, 6010, 3, 2, 2, 2, 6024, 6027, 3, 2, 2, 2, 6025, 6023, 3, 2, 2,
	2, 6025, 6026, 3, 2, 2, 2, 6026, 6029, 3, 2, 2, 2, 6027, 6025, 3, 2, 2,
	2, 6028, 6030, 5, 1082, 542, 2, 6029, 6028, 3, 2, 2, 2, 6029, 6030, 3,
	2, 2, 2, 6030, 1081, 3, 2, 2, 2, 6031, 6032, 7, 544, 2, 2, 6032, 6033,
	5, 1084, 543, 2, 6033, 6035, 7, 530, 2, 2, 6034, 6036, 5, 1086, 544, 2,
	6035, 6034, 3, 2, 2, 2, 6035, 6036, 3, 2, 2, 2, 6036, 6037, 3, 2, 2, 2,
	6037, 6038, 7, 551, 2, 2, 6038, 1083, 3, 2, 2, 2, 6039, 6040, 5, 1034,
	518, 2, 6040, 1085, 3, 2, 2, 2, 6041, 6042, 5, 1034, 518, 2, 6042, 1087,
	3, 2, 2, 2, 6043, 6055, 7, 11, 2, 2, 6044, 6055, 5, 1180, 591, 2, 6045,
	6047, 5, 1092, 547, 2, 6046, 6048, 5, 1180, 591, 2, 6047, 6046, 3, 2, 2,
	2, 6047, 6048, 3, 2, 2, 2, 6048, 6055, 3, 2, 2, 2, 6049, 6051, 5, 1140,
	571, 2, 6050, 6052, 5, 1180, 591, 2, 6051, 6050, 3, 2, 2, 2, 6051, 6052,
	3, 2, 2, 2, 6052, 6055, 3, 2, 2, 2, 6053, 6055, 5, 1034, 518, 2, 6054,
	6043, 3, 2, 2, 2, 6054, 6044, 3, 2, 2, 2, 6054, 6045, 3, 2, 2, 2, 6054,
	6049, 3, 2, 2, 2, 6054, 6053, 3, 2, 2, 2, 6055, 1089, 3, 2, 2, 2, 6056,
	6068, 5, 1174, 588, 2, 6057, 6068, 5, 1076, 539, 2, 6058, 6060, 5, 1092,
	547, 2, 6059, 6061, 5, 1180, 591, 2, 6060, 6059, 3, 2, 2, 2, 6060, 6061,
	3, 2, 2, 2, 6061, 6068, 3, 2, 2, 2, 6062, 6064, 5, 1140, 571, 2, 6063,
	6065, 5, 1180, 591, 2, 6064, 6063, 3, 2, 2, 2, 6064, 6065, 3, 2, 2, 2,
	6065, 6068, 3, 2, 2, 2, 6066, 6068, 5, 1034, 518, 2, 6067, 6056, 3, 2,
	2, 2, 6067, 6057, 3, 2, 2, 2, 6067, 6058, 3, 2, 2, 2, 6067, 6062, 3, 2,
	2, 2, 6067, 6066, 3, 2, 2, 2, 6068, 1091, 3, 2, 2, 2, 6069, 6074, 5, 1094,
	548, 2, 6070, 6074, 5, 1096, 549, 2, 6071, 6074, 5, 1098, 550, 2, 6072,
	6074, 5, 1100, 551, 2, 6073, 6069, 3, 2, 2, 2, 6073, 6070, 3, 2, 2, 2,
	6073, 6071, 3, 2, 2, 2, 6073, 6072, 3, 2, 2, 2, 6074, 1093, 3, 2, 2, 2,
	6075, 6078, 5, 1130, 566, 2, 6076, 6078, 5, 1128, 565, 2, 6077, 6075, 3,
	2, 2, 2, 6077, 6076, 3, 2, 2, 2, 6078, 6088, 3, 2, 2, 2, 6079, 6081, 5,
	1102, 552, 2, 6080, 6079, 3, 2, 2, 2, 6081, 6082, 3, 2, 2, 2, 6082, 6080,
	3, 2, 2, 2, 6082, 6083, 3, 2, 2, 2, 6083, 6085, 3, 2, 2, 2, 6084, 6086,
	5, 1106, 554, 2, 6085, 6084, 3, 2, 2, 2, 6085, 6086, 3, 2, 2, 2, 6086,
	6089, 3, 2, 2, 2, 6087, 6089, 5, 1106, 554, 2, 6088, 6080, 3, 2, 2, 2,
	6088, 6087, 3, 2, 2, 2, 6088, 6089, 3, 2, 2, 2, 6089, 1095, 3, 2, 2, 2,
	6090, 6091, 5, 1150, 576, 2, 6091, 6092, 5, 1110, 556, 2, 6092, 1097, 3,
	2, 2, 2, 6093, 6094, 5, 1170, 586, 2, 6094, 6095, 5, 1112, 557, 2, 6095,
	1099, 3, 2, 2, 2, 6096, 6097, 7, 280, 2, 2, 6097, 6098, 5, 1106, 554, 2,
	6098, 1101, 3, 2, 2, 2, 6099, 6102, 5, 1104, 553, 2, 6100, 6102, 5, 1114,
	558, 2, 6101, 6099, 3, 2, 2, 2, 6101, 6100, 3, 2, 2, 2, 6102, 1103, 3,
	2, 2, 2, 6103, 6104, 9, 68, 2, 2, 6104, 6105, 5, 1130, 566, 2, 6105, 1105,
	3, 2, 2, 2, 6106, 6107, 9, 68, 2, 2, 6107, 6108, 5, 1136, 569, 2, 6108,
	1107, 3, 2, 2, 2, 6109, 6110, 9, 68, 2, 2, 6110, 6111, 5, 1148, 575, 2,
	6111, 1109, 3, 2, 2, 2, 6112, 6113, 9, 68, 2, 2, 6113, 6114, 5, 1164, 583,
	2, 6114, 1111, 3, 2, 2, 2, 6115, 6116, 9, 68, 2, 2, 6116, 6117, 5, 1144,
	573, 2, 6117, 1113, 3, 2, 2, 2, 6118, 6119, 9, 68, 2, 2, 6119, 6120, 5,
	1078, 540, 2, 6120, 1115, 3, 2, 2, 2, 6121, 6122, 5, 1172, 587, 2, 6122,
	1117, 3, 2, 2, 2, 6123, 6124, 5, 1166, 584, 2, 6124, 1119, 3, 2, 2, 2,
	6125, 6126, 5, 1154, 578, 2, 6126, 1121, 3, 2, 2, 2, 6127, 6128, 5, 1172,
	587, 2, 6128, 1123, 3, 2, 2, 2, 6129, 6130, 5, 1172, 587, 2, 6130, 1125,
	3, 2, 2, 2, 6131, 6132, 5, 1166, 584, 2, 6132, 1127, 3, 2, 2, 2, 6133,
	6134, 5, 1172, 587, 2, 6134, 1129, 3, 2, 2, 2, 6135, 6136, 5, 1172, 587,
	2, 6136, 1131, 3, 2, 2, 2, 6137, 6141, 7, 210, 2, 2, 6138, 6141, 7, 110,
	2, 2, 6139, 6141, 5, 1130, 566, 2, 6140, 6137, 3, 2, 2, 2, 6140, 6138,
	3, 2, 2, 2, 6140, 6139, 3, 2, 2, 2, 6141, 1133, 3, 2, 2, 2, 6142, 6143,
	5, 1166, 584, 2, 6143, 1135, 3, 2, 2, 2, 6144, 6145, 5, 1172, 587, 2, 6145,
	1137, 3, 2, 2, 2, 6146, 6153, 7, 252, 2, 2, 6147, 6153, 7, 271, 2, 2, 6148,
	6153, 7, 371, 2, 2, 6149, 6153, 7, 466, 2, 2, 6150, 6153, 7, 515, 2, 2,
	6151, 6153, 5, 1172, 587, 2, 6152, 6146, 3, 2, 2, 2, 6152, 6147, 3, 2,
	2, 2, 6152, 6148, 3, 2, 2, 2, 6152, 6149, 3, 2, 2, 2, 6152, 6150, 3, 2,
	2, 2, 6152, 6151, 3, 2, 2, 2, 6153, 1139, 3, 2, 2, 2, 6154, 6155, 5, 1172,
	587, 2, 6155, 1141, 3, 2, 2, 2, 6156, 6157, 5, 1166, 584, 2, 6157, 1143,
	3, 2, 2, 2, 6158, 6159, 5, 1172, 587, 2, 6159, 1145, 3, 2, 2, 2, 6160,
	6161, 5, 1172, 587, 2, 6161, 1147, 3, 2, 2, 2, 6162, 6163, 5, 1172, 587,
	2, 6163, 1149, 3, 2, 2, 2, 6164, 6167, 5, 1172, 587, 2, 6165, 6167, 5,
	1180, 591, 2, 6166, 6164, 3, 2, 2, 2, 6166, 6165, 3, 2, 2, 2, 6167, 1151,
	3, 2, 2, 2, 6168, 6170, 5, 1150, 576, 2, 6169, 6171, 5, 1110, 556, 2, 6170,
	6169, 3, 2, 2, 2, 6170, 6171, 3, 2, 2, 2, 6171, 6174, 3, 2, 2, 2, 6172,
	6174, 5, 1164, 583, 2, 6173, 6168, 3, 2, 2, 2, 6173, 6172, 3, 2, 2, 2,
	6174, 1153, 3, 2, 2, 2, 6175, 6178, 7, 553, 2, 2, 6176, 6178, 5, 1172,
	587, 2, 6177, 6175, 3, 2, 2, 2, 6177, 6176, 3, 2, 2, 2, 6178, 1155, 3,
	2, 2, 2, 6179, 6180, 5, 1092, 547, 2, 6180, 1157, 3, 2, 2, 2, 6181, 6182,
	5, 1092, 547, 2, 6182, 1159, 3, 2, 2, 2, 6183, 6184, 5, 1172, 587, 2, 6184,
	1161, 3, 2, 2, 2, 6185, 6186, 5, 1172, 587, 2, 6186, 1163, 3, 2, 2, 2,
	6187, 6190, 5, 1172, 587, 2, 6188, 6190, 5, 1180, 591, 2, 6189, 6187, 3,
	2, 2, 2, 6189, 6188, 3, 2, 2, 2, 6190, 1165, 3, 2, 2, 2, 6191, 6192, 5,
	1172, 587, 2, 6192, 1167, 3, 2, 2, 2, 6193, 6194, 5, 1172, 587, 2, 6194,
	1169, 3, 2, 2, 2, 6195, 6196, 5, 1172, 587, 2, 6196, 1171, 3, 2, 2, 2,
	6197, 6198, 9, 69, 2, 2, 6198, 1173, 3, 2, 2, 2, 6199, 6206, 7, 553, 2,
	2, 6200, 6206, 5, 1186, 594, 2, 6201, 6206, 5, 1178, 590, 2, 6202, 6206,
	5, 1176, 589, 2, 6203, 6206, 5, 1182, 592, 2, 6204, 6206, 5, 1184, 593,
	2, 6205, 6199, 3, 2, 2, 2, 6205, 6200, 3, 2, 2, 2, 6205, 6201, 3, 2, 2,
	2, 6205, 6202, 3, 2, 2, 2, 6205, 6203, 3, 2, 2, 2, 6205, 6204, 3, 2, 2,
	2, 6206, 1175, 3, 2, 2, 2, 6207, 6208, 9, 70, 2, 2, 6208, 1177, 3, 2, 2,
	2, 6209, 6213, 7, 558, 2, 2, 6210, 6213, 7, 523, 2, 2, 6211, 6213, 5, 1180,
	591, 2, 6212, 6209, 3, 2, 2, 2, 6212, 6210, 3, 2, 2, 2, 6212, 6211, 3,
	2, 2, 2, 6213, 1179, 3, 2, 2, 2, 6214, 6215, 9, 71, 2, 2, 6215, 1181, 3,
	2, 2, 2, 6216, 6217, 7, 140, 2, 2, 6217, 6220, 7, 544, 2, 2, 6218, 6221,
	5, 1172, 587, 2, 6219, 6221, 5, 1174, 588, 2, 6220, 6218, 3, 2, 2, 2, 6220,
	6219, 3, 2, 2, 2, 6221, 6222, 3, 2, 2, 2, 6222, 6223, 7, 551, 2, 2, 6223,
	1183, 3, 2, 2, 2, 6224, 6225, 7, 141, 2, 2, 6225, 6228, 7, 544, 2, 2, 6226,
	6229, 5, 1172, 587, 2, 6227, 6229, 5, 1174, 588, 2, 6228, 6226, 3, 2, 2,
	2, 6228, 6227, 3, 2, 2, 2, 6229, 6230, 3, 2, 2, 2, 6230, 6231, 7, 551,
	2, 2, 6231, 1185, 3, 2, 2, 2, 6232, 6233, 7, 11, 2, 2, 6233, 6248, 5, 1174,
	588, 2, 6234, 6248, 7, 232, 2, 2, 6235, 6248, 7, 233, 2, 2, 6236, 6248,
	7, 293, 2, 2, 6237, 6248, 7, 294, 2, 2, 6238, 6248, 7, 315, 2, 2, 6239,
	6248, 7, 316, 2, 2, 6240, 6248, 7, 369, 2, 2, 6241, 6248, 7, 370, 2, 2,
	6242, 6248, 7, 452, 2, 2, 6243, 6248, 7, 453, 2, 2, 6244, 6248, 7, 523,
	2, 2, 6245, 6248, 7, 525, 2, 2, 6246, 6248, 7, 526, 2, 2, 6247, 6232, 3,
	2, 2, 2, 6247, 6234, 3, 2, 2, 2, 6247, 6235, 3, 2, 2, 2, 6247, 6236, 3,
	2, 2, 2, 6247, 6237, 3, 2, 2, 2, 6247, 6238, 3, 2, 2, 2, 6247, 6239, 3,
	2, 2, 2, 6247, 6240, 3, 2, 2, 2, 6247, 6241, 3, 2, 2, 2, 6247, 6242, 3,
	2, 2, 2, 6247, 6243, 3, 2, 2, 2, 6247, 6244, 3, 2, 2, 2, 6247, 6245, 3,
	2, 2, 2, 6247, 6246, 3, 2, 2, 2, 6248, 1187, 3, 2, 2, 2, 6249, 6250, 7,
	7, 2, 2, 6250, 6251, 7, 325, 2, 2, 6251, 6283, 5, 1076, 539, 2, 6252, 6283,
	7, 113, 2, 2, 6253, 6283, 7, 116, 2, 2, 6254, 6283, 7, 117, 2, 2, 6255,
	6283, 7, 120, 2, 2, 6256, 6283, 7, 121, 2, 2, 6257, 6283, 7, 122, 2, 2,
	6258, 6283, 7, 123, 2, 2, 6259, 6283, 7, 124, 2, 2, 6260, 6283, 7, 125,
	2, 2, 6261, 6283, 7, 126, 2, 2, 6262, 6264, 7, 271, 2, 2, 6263, 6265, 7,
	325, 2, 2, 6264, 6263, 3, 2, 2, 2, 6264, 6265, 3, 2, 2, 2, 6265, 6266,
	3, 2, 2, 2, 6266, 6283, 5, 1076, 539, 2, 6267, 6283, 7, 280, 2, 2, 6268,
	6283, 7, 283, 2, 2, 6269, 6283, 7, 343, 2, 2, 6270, 6283, 7, 406, 2, 2,
	6271, 6283, 7, 437, 2, 2, 6272, 6283, 7, 438, 2, 2, 6273, 6283, 7, 443,
	2, 2, 6274, 6283, 7, 444, 2, 2, 6275, 6283, 7, 445, 2, 2, 6276, 6283, 7,
	447, 2, 2, 6277, 6283, 7, 448, 2, 2, 6278, 6283, 7, 449, 2, 2, 6279, 6283,
	7, 473, 2, 2, 6280, 6283, 7, 487, 2, 2, 6281, 6283, 7, 515, 2, 2, 6282,
	6249, 3, 2, 2, 2, 6282, 6252, 3, 2, 2, 2, 6282, 6253, 3, 2, 2, 2, 6282,
	6254, 3, 2, 2, 2, 6282, 6255, 3, 2, 2, 2, 6282, 6256, 3, 2, 2, 2, 6282,
	6257, 3, 2, 2, 2, 6282, 6258, 3, 2, 2, 2, 6282, 6259, 3, 2, 2, 2, 6282,
	6260, 3, 2, 2, 2, 6282, 6261, 3, 2, 2, 2, 6282, 6262, 3, 2, 2, 2, 6282,
	6267, 3, 2, 2, 2, 6282, 6268, 3, 2, 2, 2, 6282, 6269, 3, 2, 2, 2, 6282,
	6270, 3, 2, 2, 2, 6282, 6271, 3, 2, 2, 2, 6282, 6272, 3, 2, 2, 2, 6282,
	6273, 3, 2, 2, 2, 6282, 6274, 3, 2, 2, 2, 6282, 6275, 3, 2, 2, 2, 6282,
	6276, 3, 2, 2, 2, 6282, 6277, 3, 2, 2, 2, 6282, 6278, 3, 2, 2, 2, 6282,
	6279, 3, 2, 2, 2, 6282, 6280, 3, 2, 2, 2, 6282, 6281, 3, 2, 2, 2, 6283,
	1189, 3, 2, 2, 2, 6284, 6286, 7, 564, 2, 2, 6285, 6284, 3, 2, 2, 2, 6286,
	6287, 3, 2, 2, 2, 6287, 6285, 3, 2, 2, 2, 6287, 6288, 3, 2, 2, 2, 6288,
	1191, 3, 2, 2, 2, 981, 1198, 1202, 1205, 1208, 1213, 1217, 1231, 1240,
	1246, 1250, 1252, 1255, 1258, 1263, 1268, 1273, 1278, 1283, 1288, 1296,
	1302, 1310, 1316, 1322, 1326, 1336, 1346, 1350, 1354, 1357, 1361, 1364,
	1368, 1371, 1374, 1377, 1381, 1386, 1389, 1392, 1395, 1399, 1404, 1408,
	1414, 1427, 1431, 1444, 1448, 1454, 1457, 1468, 1470, 1477, 1479, 1488,
	1493, 1497, 1502, 1507, 1514, 1517, 1520, 1525, 1530, 1534, 1538, 1542,
	1545, 1549, 1554, 1558, 1564, 1568, 1570, 1573, 1577, 1582, 1584, 1589,
	1591, 1595, 1599, 1602, 1606, 1609, 1614, 1617, 1620, 1624, 1627, 1632,
	1635, 1638, 1640, 1644, 1650, 1653, 1656, 1660, 1664, 1667, 1670, 1675,
	1679, 1684, 1687, 1692, 1700, 1705, 1709, 1714, 1723, 1728, 1743, 1747,
	1760, 1765, 1768, 1771, 1775, 1777, 1784, 1790, 1793, 1797, 1802, 1807,
	1811, 1814, 1820, 1823, 1827, 1830, 1833, 1838, 1841, 1845, 1848, 1851,
	1855, 1860, 1864, 1868, 1872, 1875, 1884, 1889, 1893, 1899, 1905, 1907,
	1913, 1919, 1922, 1930, 1934, 1937, 1940, 1945, 1950, 1953, 1958, 1963,
	1968, 1978, 1990, 1998, 2004, 2009, 2016, 2030, 2033, 2038, 2044, 2048,
	2051, 2060, 2063, 2067, 2070, 2074, 2077, 2080, 2084, 2087, 2089, 2093,
	2096, 2099, 2104, 2112, 2116, 2118, 2125, 2127, 2134, 2138, 2142, 2147,
	2151, 2153, 2158, 2162, 2166, 2169, 2174, 2180, 2183, 2187, 2191, 2194,
	2197, 2202, 2205, 2208, 2213, 2217, 2220, 2228, 2234, 2238, 2240, 2245,
	2253, 2267, 2276, 2284, 2286, 2292, 2297, 2300, 2312, 2315, 2317, 2325,
	2334, 2336, 2344, 2354, 2357, 2359, 2367, 2381, 2383, 2388, 2395, 2400,
	2404, 2411, 2418, 2425, 2430, 2434, 2439, 2443, 2448, 2452, 2457, 2461,
	2466, 2470, 2477, 2488, 2493, 2502, 2508, 2528, 2540, 2542, 2567, 2571,
	2575, 2578, 2581, 2585, 2589, 2592, 2595, 2599, 2603, 2607, 2611, 2615,
	2619, 2625, 2631, 2638, 2641, 2651, 2657, 2663, 2667, 2669, 2674, 2676,
	2686, 2689, 2693, 2696, 2701, 2713, 2720, 2725, 2729, 2732, 2735, 2738,
	2740, 2745, 2752, 2756, 2758, 2762, 2781, 2786, 2789, 2793, 2799, 2802,
	2809, 2822, 2825, 2827, 2834, 2840, 2843, 2849, 2853, 2856, 2859, 2862,
	2866, 2870, 2874, 2882, 2887, 2897, 2903, 2907, 2911, 2916, 2920, 2927,
	2932, 2938, 2943, 2946, 2950, 2959, 2964, 2969, 2974, 2978, 2985, 2989,
	2993, 2995, 3002, 3007, 3011, 3021, 3026, 3032, 3035, 3041, 3044, 3048,
	3050, 3056, 3059, 3063, 3067, 3070, 3073, 3076, 3084, 3090, 3097, 3102,
	3105, 3108, 3111, 3123, 3127, 3133, 3137, 3140, 3145, 3153, 3158, 3181,
	3183, 3201, 3204, 3210, 3217, 3222, 3225, 3233, 3238, 3241, 3245, 3248,
	3253, 3258, 3261, 3266, 3268, 3275, 3278, 3283, 3287, 3294, 3297, 3301,
	3319, 3326, 3329, 3343, 3347, 3349, 3354, 3356, 3360, 3363, 3369, 3374,
	3380, 3382, 3386, 3417, 3422, 3426, 3430, 3434, 3436, 3440, 3445, 3450,
	3454, 3460, 3468, 3471, 3475, 3483, 3490, 3493, 3496, 3501, 3504, 3508,
	3511, 3514, 3520, 3525, 3532, 3547, 3553, 3563, 3569, 3578, 3581, 3586,
	3640, 3648, 3651, 3654, 3657, 3662, 3666, 3673, 3679, 3689, 3697, 3700,
	3703, 3706, 3711, 3717, 3722, 3728, 3730, 3736, 3745, 3749, 3753, 3757,
	3761, 3769, 3775, 3782, 3785, 3788, 3791, 3794, 3797, 3800, 3806, 3811,
	3814, 3817, 3822, 3828, 3833, 3836, 3839, 3845, 3851, 3853, 3857, 3860,
	3866, 3872, 3874, 3879, 3888, 3895, 3901, 3907, 3911, 3914, 3917, 3922,
	3924, 3927, 3932, 3935, 3941, 3947, 3949, 3954, 3958, 3965, 3969, 3973,
	3979, 3984, 3987, 3990, 3994, 4001, 4004, 4007, 4010, 4015, 4020, 4024,
	4029, 4035, 4038, 4041, 4044, 4048, 4053, 4058, 4061, 4069, 4074, 4077,
	4080, 4083, 4086, 4092, 4097, 4100, 4105, 4108, 4114, 4118, 4122, 4130,
	4135, 4139, 4144, 4152, 4154, 4161, 4167, 4170, 4173, 4179, 4187, 4192,
	4200, 4205, 4209, 4213, 4226, 4232, 4237, 4242, 4247, 4251, 4254, 4259,
	4263, 4267, 4276, 4280, 4288, 4292, 4295, 4297, 4303, 4306, 4309, 4316,
	4319, 4327, 4330, 4336, 4339, 4345, 4349, 4354, 4360, 4368, 4374, 4379,
	4381, 4387, 4392, 4397, 4403, 4410, 4412, 4418, 4426, 4433, 4439, 4443,
	4448, 4453, 4459, 4465, 4470, 4474, 4478, 4485, 4488, 4493, 4497, 4502,
	4506, 4510, 4515, 4518, 4522, 4527, 4530, 4533, 4536, 4543, 4547, 4555,
	4560, 4564, 4573, 4585, 4589, 4593, 4600, 4604, 4612, 4619, 4624, 4627,
	4630, 4633, 4638, 4642, 4649, 4653, 4657, 4664, 4666, 4672, 4677, 4681,
	4687, 4691, 4695, 4701, 4707, 4712, 4715, 4720, 4728, 4731, 4736, 4740,
	4745, 4755, 4757, 4764, 4769, 4782, 4788, 4791, 4800, 4805, 4808, 4811,
	4814, 4817, 4820, 4823, 4826, 4829, 4832, 4838, 4843, 4847, 4854, 4857,
	4860, 4863, 4873, 4875, 4884, 4889, 4893, 4896, 4903, 4911, 4916, 4920,
	4923, 4930, 4936, 4940, 4944, 4952, 4957, 4960, 4964, 4967, 4975, 4978,
	4981, 4984, 4991, 4995, 4998, 5003, 5006, 5018, 5021, 5026, 5029, 5032,
	5036, 5039, 5042, 5045, 5048, 5062, 5066, 5070, 5075, 5081, 5084, 5092,
	5095, 5100, 5106, 5111, 5117, 5128, 5132, 5136, 5143, 5146, 5149, 5152,
	5157, 5161, 5166, 5170, 5174, 5179, 5182, 5186, 5189, 5192, 5196, 5201,
	5204, 5207, 5210, 5217, 5221, 5228, 5232, 5241, 5246, 5250, 5259, 5271,
	5276, 5279, 5282, 5285, 5289, 5293, 5298, 5304, 5310, 5315, 5318, 5325,
	5331, 5335, 5338, 5341, 5344, 5349, 5353, 5357, 5361, 5366, 5371, 5377,
	5386, 5389, 5392, 5395, 5400, 5406, 5411, 5419, 5428, 5432, 5436, 5440,
	5444, 5453, 5456, 5459, 5462, 5465, 5472, 5475, 5479, 5482, 5486, 5490,
	5494, 5500, 5504, 5507, 5511, 5517, 5522, 5529, 5536, 5539, 5543, 5548,
	5559, 5561, 5564, 5568, 5573, 5579, 5582, 5587, 5592, 5595, 5598, 5601,
	5604, 5607, 5610, 5615, 5619, 5624, 5630, 5633, 5638, 5644, 5649, 5655,
	5659, 5665, 5670, 5676, 5681, 5686, 5692, 5697, 5701, 5707, 5712, 5718,
	5722, 5729, 5734, 5741, 5745, 5751, 5756, 5762, 5769, 5779, 5786, 5792,
	5804, 5810, 5818, 5820, 5823, 5834, 5838, 5841, 5850, 5856, 5860, 5865,
	5871, 5874, 5879, 5884, 5892, 5896, 5899, 5918, 5921, 5924, 5928, 5933,
	5938, 5941, 5946, 5951, 5956, 5961, 5964, 5967, 5970, 5978, 5984, 5990,
	5995, 6002, 6006, 6013, 6018, 6025, 6029, 6035, 6047, 6051, 6054, 6060,
	6064, 6067, 6073, 6077, 6082, 6085, 6088, 6101, 6140, 6152, 6166, 6170,
	6173, 6177, 6189, 6205, 6212, 6220, 6228, 6247, 6264, 6282, 6287,
}
var deserializer = antlr.NewATNDeserializer(nil)
var deserializedATN = deserializer.DeserializeFromUInt16(parserATN)

var literalNames = []string{
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "'&'", "'*'", "'**'", "':'", "','", "'*>CE'", "'*>'", "'$'",
	"'\"'", "", "'.'", "'='", "'*>EXECCICS'", "'*>EXECSQL'", "'*>EXECSQLIMS'",
	"'<'", "'<='", "'('", "'-'", "'>'", "'>='", "'<>'", "'+'", "'''", "')'",
	"'/'", "", "'66'", "'77'", "'88'", "", "", "", "", "", "", "", "", "",
	"", "', '",
}
var symbolicNames = []string{
	"", "ABORT", "ACCEPT", "ACCESS", "ADD", "ADDRESS", "ADVANCING", "AFTER",
	"ALIGNED", "ALL", "ALPHABET", "ALPHABETIC", "ALPHABETIC_LOWER", "ALPHABETIC_UPPER",
	"ALPHANUMERIC", "ALPHANUMERIC_EDITED", "ALSO", "ALTER", "ALTERNATE", "AND",
	"ANY", "ARE", "AREA", "AREAS", "AS", "ASCENDING", "ASCII", "ASSIGN", "ASSOCIATED_DATA",
	"ASSOCIATED_DATA_LENGTH", "AT", "ATTRIBUTE", "AUTHOR", "AUTO", "AUTO_SKIP",
	"BACKGROUND_COLOR", "BACKGROUND_COLOUR", "BASIS", "BEEP", "BEFORE", "BEGINNING",
	"BELL", "BINARY", "BIT", "BLANK", "BLINK", "BLOCK", "BOUNDS", "BOTTOM",
	"BY", "BYFUNCTION", "BYTITLE", "CALL", "CANCEL", "CAPABLE", "CCSVERSION",
	"CD", "CF", "CH", "CHAINING", "CHANGED", "CHANNEL", "CHARACTER", "CHARACTERS",
	"CLASS", "CLASS_ID", "CLOCK_UNITS", "CLOSE", "CLOSE_DISPOSITION", "COBOL",
	"CODE", "CODE_SET", "COLLATING", "COL", "COLUMN", "COM_REG", "COMMA", "COMMITMENT",
	"COMMON", "COMMUNICATION", "COMP", "COMP_1", "COMP_2", "COMP_3", "COMP_4",
	"COMP_5", "COMPUTATIONAL", "COMPUTATIONAL_1", "COMPUTATIONAL_2", "COMPUTATIONAL_3",
	"COMPUTATIONAL_4", "COMPUTATIONAL_5", "COMPUTE", "CONFIGURATION", "CONTAINS",
	"CONTENT", "CONTINUE", "CONTROL", "CONTROL_POINT", "CONTROLS", "CONVENTION",
	"CONVERTING", "COPY", "CORR", "CORRESPONDING", "COUNT", "CRUNCH", "CURRENCY",
	"CURSOR", "DATA", "DATA_BASE", "DATE", "DATE_COMPILED", "DATE_WRITTEN",
	"DAY", "DAY_OF_WEEK", "DBCS", "DE", "DEBUG_CONTENTS", "DEBUG_ITEM", "DEBUG_LINE",
	"DEBUG_NAME", "DEBUG_SUB_1", "DEBUG_SUB_2", "DEBUG_SUB_3", "DEBUGGING",
	"DECIMAL_POINT", "DECLARATIVES", "DEFAULT", "DEFAULT_DISPLAY", "DEFINITION",
	"DELETE", "DELIMITED", "DELIMITER", "DEPENDING", "DESCENDING", "DESTINATION",
	"DETAIL", "DFHRESP", "DFHVALUE", "DISABLE", "DISK", "DISPLAY", "DISPLAY_1",
	"DIVIDE", "DIVISION", "DONTCARE", "DOUBLE", "DOWN", "DUPLICATES", "DYNAMIC",
	"EBCDIC", "EGCS", "EGI", "ELSE", "EMI", "EMPTY_CHECK", "ENABLE", "END",
	"END_ACCEPT", "END_ADD", "END_CALL", "END_COMPUTE", "END_DELETE", "END_DIVIDE",
	"END_EVALUATE", "END_IF", "END_MULTIPLY", "END_OF_PAGE", "END_PERFORM",
	"END_READ", "END_RECEIVE", "END_RETURN", "END_REWRITE", "END_SEARCH", "END_START",
	"END_STRING", "END_SUBTRACT", "END_UNSTRING", "END_WRITE", "ENDING", "ENTER",
	"ENTRY", "ENTRY_PROCEDURE", "ENVIRONMENT", "EOP", "EQUAL", "ERASE", "ERROR",
	"EOL", "EOS", "ESCAPE", "ESI", "EVALUATE", "EVENT", "EVERY", "EXCEPTION",
	"EXCLUSIVE", "EXHIBIT", "EXIT", "EXPORT", "EXTEND", "EXTENDED", "EXTERNAL",
	"FALSE", "FD", "FILE", "FILE_CONTROL", "FILLER", "FINAL", "FIRST", "FOOTING",
	"FOR", "FOREGROUND_COLOR", "FOREGROUND_COLOUR", "FROM", "FULL", "FUNCTION",
	"FUNCTIONNAME", "FUNCTION_POINTER", "GENERATE", "GOBACK", "GIVING", "GLOBAL",
	"GO", "GREATER", "GRID", "GROUP", "HEADING", "HIGHLIGHT", "HIGH_VALUE",
	"HIGH_VALUES", "I_O", "I_O_CONTROL", "ID", "IDENTIFICATION", "IF", "IMPLICIT",
	"IMPORT", "IN", "INDEX", "INDEXED", "INDICATE", "INITIAL", "INITIALIZE",
	"INITIATE", "INPUT", "INPUT_OUTPUT", "INSPECT", "INSTALLATION", "INTEGER",
	"INTO", "INVALID", "INVOKE", "IS", "JUST", "JUSTIFIED", "KANJI", "KEPT",
	"KEY", "KEYBOARD", "LABEL", "LANGUAGE", "LAST", "LB", "LD", "LEADING",
	"LEFT", "LEFTLINE", "LENGTH", "LENGTH_CHECK", "LESS", "LIBACCESS", "LIBPARAMETER",
	"LIBRARY", "LIMIT", "LIMITS", "LINAGE", "LINAGE_COUNTER", "LINE", "LINES",
	"LINE_COUNTER", "LINKAGE", "LIST", "LOCAL", "LOCAL_STORAGE", "LOCK", "LONG_DATE",
	"LONG_TIME", "LOWER", "LOWLIGHT", "LOW_VALUE", "LOW_VALUES", "MEMORY",
	"MERGE", "MESSAGE", "MMDDYYYY", "MODE", "MODULES", "MORE_LABELS", "MOVE",
	"MULTIPLE", "MULTIPLY", "NAMED", "NATIONAL", "NATIONAL_EDITED", "NATIVE",
	"NEGATIVE", "NETWORK", "NEXT", "NO", "NO_ECHO", "NOT", "NULL", "NULLS",
	"NUMBER", "NUMERIC", "NUMERIC_DATE", "NUMERIC_EDITED", "NUMERIC_TIME",
	"OBJECT_COMPUTER", "OCCURS", "ODT", "OF", "OFF", "OMITTED", "ON", "OPEN",
	"OPTIONAL", "OR", "ORDER", "ORDERLY", "ORGANIZATION", "OTHER", "OUTPUT",
	"OVERFLOW", "OVERLINE", "OWN", "PACKED_DECIMAL", "PADDING", "PAGE", "PAGE_COUNTER",
	"PASSWORD", "PERFORM", "PF", "PH", "PIC", "PICTURE", "PLUS", "POINTER",
	"POSITION", "POSITIVE", "PORT", "PRINTER", "PRINTING", "PRIVATE", "PROCEDURE",
	"PROCEDURE_POINTER", "PROCEDURES", "PROCEED", "PROCESS", "PROGRAM", "PROGRAM_ID",
	"PROGRAM_LIBRARY", "PROMPT", "PURGE", "QUEUE", "QUOTE", "QUOTES", "RANDOM",
	"READER", "REMOTE", "RD", "REAL", "READ", "RECEIVE", "RECEIVED", "RECORD",
	"RECORDING", "RECORDS", "RECURSIVE", "REDEFINES", "REEL", "REF", "REFERENCE",
	"REFERENCES", "RELATIVE", "RELEASE", "REMAINDER", "REMARKS", "REMOVAL",
	"REMOVE", "RENAMES", "REPLACE", "REPLACING", "REPORT", "REPORTING", "REPORTS",
	"REQUIRED", "RERUN", "RESERVE", "REVERSE_VIDEO", "RESET", "RETURN", "RETURN_CODE",
	"RETURNING", "REVERSED", "REWIND", "REWRITE", "RF", "RH", "RIGHT", "ROUNDED",
	"RUN", "SAME", "SAVE", "SCREEN", "SD", "SEARCH", "SECTION", "SECURE", "SECURITY",
	"SEGMENT", "SEGMENT_LIMIT", "SELECT", "SEND", "SENTENCE", "SEPARATE", "SEQUENCE",
	"SEQUENTIAL", "SET", "SHARED", "SHAREDBYALL", "SHAREDBYRUNUNIT", "SHARING",
	"SHIFT_IN", "SHIFT_OUT", "SHORT_DATE", "SIGN", "SIZE", "SORT", "SORT_CONTROL",
	"SORT_CORE_SIZE", "SORT_FILE_SIZE", "SORT_MERGE", "SORT_MESSAGE", "SORT_MODE_SIZE",
	"SORT_RETURN", "SOURCE", "SOURCE_COMPUTER", "SPACE", "SPACES", "SPECIAL_NAMES",
	"STANDARD", "STANDARD_1", "STANDARD_2", "START", "STATUS", "STOP", "STRING",
	"SUB_QUEUE_1", "SUB_QUEUE_2", "SUB_QUEUE_3", "SUBTRACT", "SUM", "SUPPRESS",
	"SYMBOL", "SYMBOLIC", "SYNC", "SYNCHRONIZED", "TABLE", "TALLY", "TALLYING",
	"TASK", "TAPE", "TERMINAL", "TERMINATE", "TEST", "TEXT", "THAN", "THEN",
	"THREAD", "THREAD_LOCAL", "THROUGH", "THRU", "TIME", "TIMER", "TIMES",
	"TITLE", "TO", "TODAYS_DATE", "TODAYS_NAME", "TOP", "TRAILING", "TRUE",
	"TRUNCATED", "TYPE", "TYPEDEF", "UNDERLINE", "UNIT", "UNSTRING", "UNTIL",
	"UP", "UPON", "USAGE", "USE", "USING", "VALUE", "VALUES", "VARYING", "VIRTUAL",
	"WAIT", "WHEN", "WHEN_COMPILED", "WITH", "WORDS", "WORKING_STORAGE", "WRITE",
	"YEAR", "YYYYMMDD", "YYYYDDD", "ZERO", "ZERO_FILL", "ZEROS", "ZEROES",
	"AMPCHAR", "ASTERISKCHAR", "DOUBLEASTERISKCHAR", "COLONCHAR", "COMMACHAR",
	"COMMENTENTRYTAG", "COMMENTTAG", "DOLLARCHAR", "DOUBLEQUOTE", "DOT_FS",
	"DOT", "EQUALCHAR", "EXECCICSTAG", "EXECSQLTAG", "EXECSQLIMSTAG", "LESSTHANCHAR",
	"LESSTHANOREQUAL", "LPARENCHAR", "MINUSCHAR", "MORETHANCHAR", "MORETHANOREQUAL",
	"NOTEQUALCHAR", "PLUSCHAR", "SINGLEQUOTE", "RPARENCHAR", "SLASHCHAR", "NONNUMERICLITERAL",
	"LEVEL_NUMBER_66", "LEVEL_NUMBER_77", "LEVEL_NUMBER_88", "INTEGERLITERAL",
	"NUMERICLITERAL", "IDENTIFIER", "NEWLINE", "EXECCICSLINE", "EXECSQLIMSLINE",
	"EXECSQLLINE", "COMMENTENTRYLINE", "COMMENTLINE", "WS", "SEPARATOR",
}

var ruleNames = []string{
	"startRule", "compilationUnit", "programUnit", "endProgramStatement", "identificationDivision",
	"identificationDivisionBody", "programIdParagraph", "authorParagraph",
	"installationParagraph", "dateWrittenParagraph", "dateCompiledParagraph",
	"securityParagraph", "remarksParagraph", "environmentDivision", "environmentDivisionBody",
	"configurationSection", "configurationSectionParagraph", "sourceComputerParagraph",
	"objectComputerParagraph", "objectComputerClause", "memorySizeClause",
	"diskSizeClause", "collatingSequenceClause", "collatingSequenceClauseAlphanumeric",
	"collatingSequenceClauseNational", "segmentLimitClause", "characterSetClause",
	"specialNamesParagraph", "specialNameClause", "alphabetClause", "alphabetClauseFormat1",
	"alphabetLiterals", "alphabetThrough", "alphabetAlso", "alphabetClauseFormat2",
	"channelClause", "classClause", "classClauseThrough", "classClauseFrom",
	"classClauseTo", "currencySignClause", "decimalPointClause", "defaultComputationalSignClause",
	"defaultDisplaySignClause", "environmentSwitchNameClause", "environmentSwitchNameSpecialNamesStatusPhrase",
	"odtClause", "reserveNetworkClause", "symbolicCharactersClause", "symbolicCharacters",
	"inputOutputSection", "inputOutputSectionParagraph", "fileControlParagraph",
	"fileControlEntry", "selectClause", "fileControlClause", "assignClause",
	"reserveClause", "organizationClause", "paddingCharacterClause", "recordDelimiterClause",
	"accessModeClause", "recordKeyClause", "alternateRecordKeyClause", "passwordClause",
	"fileStatusClause", "relativeKeyClause", "ioControlParagraph", "ioControlClause",
	"rerunClause", "rerunEveryRecords", "rerunEveryOf", "rerunEveryClock",
	"sameClause", "multipleFileClause", "multipleFilePosition", "commitmentControlClause",
	"dataDivision", "dataDivisionSection", "fileSection", "fileDescriptionEntry",
	"fileDescriptionEntryClause", "externalClause", "globalClause", "blockContainsClause",
	"blockContainsTo", "recordContainsClause", "recordContainsClauseFormat1",
	"recordContainsClauseFormat2", "recordContainsClauseFormat3", "recordContainsTo",
	"labelRecordsClause", "valueOfClause", "valuePair", "dataRecordsClause",
	"linageClause", "linageAt", "linageFootingAt", "linageLinesAtTop", "linageLinesAtBottom",
	"recordingModeClause", "modeStatement", "codeSetClause", "reportClause",
	"dataBaseSection", "dataBaseSectionEntry", "workingStorageSection", "linkageSection",
	"communicationSection", "communicationDescriptionEntry", "communicationDescriptionEntryFormat1",
	"communicationDescriptionEntryFormat2", "communicationDescriptionEntryFormat3",
	"destinationCountClause", "destinationTableClause", "endKeyClause", "errorKeyClause",
	"messageCountClause", "messageDateClause", "messageTimeClause", "statusKeyClause",
	"symbolicDestinationClause", "symbolicQueueClause", "symbolicSourceClause",
	"symbolicTerminalClause", "symbolicSubQueueClause", "textLengthClause",
	"localStorageSection", "screenSection", "screenDescriptionEntry", "screenDescriptionBlankClause",
	"screenDescriptionBellClause", "screenDescriptionBlinkClause", "screenDescriptionEraseClause",
	"screenDescriptionLightClause", "screenDescriptionGridClause", "screenDescriptionReverseVideoClause",
	"screenDescriptionUnderlineClause", "screenDescriptionSizeClause", "screenDescriptionLineClause",
	"screenDescriptionColumnClause", "screenDescriptionForegroundColorClause",
	"screenDescriptionBackgroundColorClause", "screenDescriptionControlClause",
	"screenDescriptionValueClause", "screenDescriptionPictureClause", "screenDescriptionFromClause",
	"screenDescriptionToClause", "screenDescriptionUsingClause", "screenDescriptionUsageClause",
	"screenDescriptionBlankWhenZeroClause", "screenDescriptionJustifiedClause",
	"screenDescriptionSignClause", "screenDescriptionAutoClause", "screenDescriptionSecureClause",
	"screenDescriptionRequiredClause", "screenDescriptionPromptClause", "screenDescriptionPromptOccursClause",
	"screenDescriptionFullClause", "screenDescriptionZeroFillClause", "reportSection",
	"reportDescription", "reportDescriptionEntry", "reportDescriptionGlobalClause",
	"reportDescriptionPageLimitClause", "reportDescriptionHeadingClause", "reportDescriptionFirstDetailClause",
	"reportDescriptionLastDetailClause", "reportDescriptionFootingClause",
	"reportGroupDescriptionEntry", "reportGroupDescriptionEntryFormat1", "reportGroupDescriptionEntryFormat2",
	"reportGroupDescriptionEntryFormat3", "reportGroupBlankWhenZeroClause",
	"reportGroupColumnNumberClause", "reportGroupIndicateClause", "reportGroupJustifiedClause",
	"reportGroupLineNumberClause", "reportGroupLineNumberNextPage", "reportGroupLineNumberPlus",
	"reportGroupNextGroupClause", "reportGroupNextGroupPlus", "reportGroupNextGroupNextPage",
	"reportGroupPictureClause", "reportGroupResetClause", "reportGroupSignClause",
	"reportGroupSourceClause", "reportGroupSumClause", "reportGroupTypeClause",
	"reportGroupTypeReportHeading", "reportGroupTypePageHeading", "reportGroupTypeControlHeading",
	"reportGroupTypeDetail", "reportGroupTypeControlFooting", "reportGroupUsageClause",
	"reportGroupTypePageFooting", "reportGroupTypeReportFooting", "reportGroupValueClause",
	"programLibrarySection", "libraryDescriptionEntry", "libraryDescriptionEntryFormat1",
	"libraryDescriptionEntryFormat2", "libraryAttributeClauseFormat1", "libraryAttributeClauseFormat2",
	"libraryAttributeFunction", "libraryAttributeParameter", "libraryAttributeTitle",
	"libraryEntryProcedureClauseFormat1", "libraryEntryProcedureClauseFormat2",
	"libraryEntryProcedureForClause", "libraryEntryProcedureGivingClause",
	"libraryEntryProcedureUsingClause", "libraryEntryProcedureUsingName", "libraryEntryProcedureWithClause",
	"libraryEntryProcedureWithName", "libraryIsCommonClause", "libraryIsGlobalClause",
	"dataDescriptionEntry", "dataDescriptionEntryFormat1", "dataDescriptionEntryFormat2",
	"dataDescriptionEntryFormat3", "dataDescriptionEntryExecSql", "dataAlignedClause",
	"dataBlankWhenZeroClause", "dataCommonOwnLocalClause", "dataExternalClause",
	"dataGlobalClause", "dataIntegerStringClause", "dataJustifiedClause", "dataOccursClause",
	"dataOccursTo", "dataOccursSort", "dataPictureClause", "pictureString",
	"pictureChars", "pictureCardinality", "dataReceivedByClause", "dataRecordAreaClause",
	"dataRedefinesClause", "dataRenamesClause", "dataSignClause", "dataSynchronizedClause",
	"dataThreadLocalClause", "dataTypeClause", "dataTypeDefClause", "dataUsageClause",
	"dataUsingClause", "dataValueClause", "dataValueInterval", "dataValueIntervalFrom",
	"dataValueIntervalTo", "dataWithLowerBoundsClause", "procedureDivision",
	"procedureDivisionUsingClause", "procedureDivisionGivingClause", "procedureDivisionUsingParameter",
	"procedureDivisionByReferencePhrase", "procedureDivisionByReference", "procedureDivisionByValuePhrase",
	"procedureDivisionByValue", "procedureDeclaratives", "procedureDeclarative",
	"procedureSectionHeader", "procedureDivisionBody", "procedureSection",
	"paragraphs", "paragraph", "sentence", "statement", "acceptStatement",
	"acceptFromDateStatement", "acceptFromMnemonicStatement", "acceptFromEscapeKeyStatement",
	"acceptMessageCountStatement", "addStatement", "addToStatement", "addToGivingStatement",
	"addCorrespondingStatement", "addFrom", "addTo", "addToGiving", "addGiving",
	"alteredGoTo", "alterStatement", "alterProceedTo", "callStatement", "callUsingPhrase",
	"callUsingParameter", "callByReferencePhrase", "callByReference", "callByValuePhrase",
	"callByValue", "callByContentPhrase", "callByContent", "callGivingPhrase",
	"cancelStatement", "cancelCall", "closeStatement", "closeFile", "closeReelUnitStatement",
	"closeRelativeStatement", "closePortFileIOStatement", "closePortFileIOUsing",
	"closePortFileIOUsingCloseDisposition", "closePortFileIOUsingAssociatedData",
	"closePortFileIOUsingAssociatedDataLength", "computeStatement", "computeStore",
	"continueStatement", "deleteStatement", "disableStatement", "displayStatement",
	"displayOperand", "displayAt", "displayUpon", "displayWith", "divideStatement",
	"divideIntoStatement", "divideIntoGivingStatement", "divideByGivingStatement",
	"divideGivingPhrase", "divideInto", "divideGiving", "divideRemainder",
	"enableStatement", "entryStatement", "evaluateStatement", "evaluateSelect",
	"evaluateAlsoSelect", "evaluateWhenPhrase", "evaluateWhen", "evaluateCondition",
	"evaluateThrough", "evaluateAlsoCondition", "evaluateWhenOther", "evaluateValue",
	"execCicsStatement", "execSqlStatement", "execSqlImsStatement", "exhibitStatement",
	"exhibitOperand", "exitStatement", "generateStatement", "gobackStatement",
	"goToStatement", "goToStatementSimple", "goToDependingOnStatement", "ifStatement",
	"ifThen", "ifElse", "initializeStatement", "initializeReplacingPhrase",
	"initializeReplacingBy", "initiateStatement", "inspectStatement", "inspectTallyingPhrase",
	"inspectReplacingPhrase", "inspectTallyingReplacingPhrase", "inspectConvertingPhrase",
	"inspectFor", "inspectCharacters", "inspectReplacingCharacters", "inspectAllLeadings",
	"inspectReplacingAllLeadings", "inspectAllLeading", "inspectReplacingAllLeading",
	"inspectBy", "inspectTo", "inspectBeforeAfter", "mergeStatement", "mergeOnKeyClause",
	"mergeCollatingSequencePhrase", "mergeCollatingAlphanumeric", "mergeCollatingNational",
	"mergeUsing", "mergeOutputProcedurePhrase", "mergeOutputThrough", "mergeGivingPhrase",
	"mergeGiving", "moveStatement", "moveToStatement", "moveToSendingArea",
	"moveCorrespondingToStatement", "moveCorrespondingToSendingArea", "multiplyStatement",
	"multiplyRegular", "multiplyRegularOperand", "multiplyGiving", "multiplyGivingOperand",
	"multiplyGivingResult", "openStatement", "openInputStatement", "openInput",
	"openOutputStatement", "openOutput", "openIOStatement", "openExtendStatement",
	"performStatement", "performInlineStatement", "performProcedureStatement",
	"performType", "performTimes", "performUntil", "performVarying", "performVaryingClause",
	"performVaryingPhrase", "performAfter", "performFrom", "performBy", "performTestClause",
	"purgeStatement", "readStatement", "readInto", "readWith", "readKey", "receiveStatement",
	"receiveFromStatement", "receiveFrom", "receiveIntoStatement", "receiveNoData",
	"receiveWithData", "receiveBefore", "receiveWith", "receiveThread", "receiveSize",
	"receiveStatus", "releaseStatement", "returnStatement", "returnInto", "rewriteStatement",
	"rewriteFrom", "searchStatement", "searchVarying", "searchWhen", "sendStatement",
	"sendStatementSync", "sendStatementAsync", "sendFromPhrase", "sendWithPhrase",
	"sendReplacingPhrase", "sendAdvancingPhrase", "sendAdvancingPage", "sendAdvancingLines",
	"sendAdvancingMnemonic", "setStatement", "setToStatement", "setUpDownByStatement",
	"setTo", "setToValue", "setByValue", "sortStatement", "sortOnKeyClause",
	"sortDuplicatesPhrase", "sortCollatingSequencePhrase", "sortCollatingAlphanumeric",
	"sortCollatingNational", "sortInputProcedurePhrase", "sortInputThrough",
	"sortUsing", "sortOutputProcedurePhrase", "sortOutputThrough", "sortGivingPhrase",
	"sortGiving", "startStatement", "startKey", "stopStatement", "stringStatement",
	"stringSendingPhrase", "stringSending", "stringDelimitedByPhrase", "stringForPhrase",
	"stringIntoPhrase", "stringWithPointerPhrase", "subtractStatement", "subtractFromStatement",
	"subtractFromGivingStatement", "subtractCorrespondingStatement", "subtractSubtrahend",
	"subtractMinuend", "subtractMinuendGiving", "subtractGiving", "subtractMinuendCorresponding",
	"terminateStatement", "unstringStatement", "unstringSendingPhrase", "unstringDelimitedByPhrase",
	"unstringOrAllPhrase", "unstringIntoPhrase", "unstringInto", "unstringDelimiterIn",
	"unstringCountIn", "unstringWithPointerPhrase", "unstringTallyingPhrase",
	"useStatement", "useAfterClause", "useAfterOn", "useDebugClause", "useDebugOn",
	"writeStatement", "writeFromPhrase", "writeAdvancingPhrase", "writeAdvancingPage",
	"writeAdvancingLines", "writeAdvancingMnemonic", "writeAtEndOfPagePhrase",
	"writeNotAtEndOfPagePhrase", "atEndPhrase", "notAtEndPhrase", "invalidKeyPhrase",
	"notInvalidKeyPhrase", "onOverflowPhrase", "notOnOverflowPhrase", "onSizeErrorPhrase",
	"notOnSizeErrorPhrase", "onExceptionClause", "notOnExceptionClause", "arithmeticExpression",
	"plusMinus", "multDivs", "multDiv", "powers", "power", "basis", "condition",
	"andOrCondition", "combinableCondition", "simpleCondition", "classCondition",
	"conditionNameReference", "conditionNameSubscriptReference", "relationCondition",
	"relationSignCondition", "relationArithmeticComparison", "relationCombinedComparison",
	"relationCombinedCondition", "relationalOperator", "abbreviation", "identifier",
	"tableCall", "functionCall", "referenceModifier", "characterPosition",
	"length", "subscript", "argument", "qualifiedDataName", "qualifiedDataNameFormat1",
	"qualifiedDataNameFormat2", "qualifiedDataNameFormat3", "qualifiedDataNameFormat4",
	"qualifiedInData", "inData", "inFile", "inMnemonic", "inSection", "inLibrary",
	"inTable", "alphabetName", "assignmentName", "basisName", "cdName", "className",
	"computerName", "conditionName", "dataName", "dataDescName", "environmentName",
	"fileName", "functionName", "indexName", "languageName", "libraryName",
	"localName", "mnemonicName", "paragraphName", "procedureName", "programName",
	"recordName", "reportName", "routineName", "screenName", "sectionName",
	"systemName", "symbolicCharacter", "textName", "cobolWord", "literal",
	"booleanLiteral", "numericLiteral", "integerLiteral", "cicsDfhRespLiteral",
	"cicsDfhValueLiteral", "figurativeConstant", "specialRegister", "commentEntry",
}
var decisionToDFA = make([]*antlr.DFA, len(deserializedATN.DecisionToState))

func init() {
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
}

type Cobol85Parser struct {
	*antlr.BaseParser
}

func NewCobol85Parser(input antlr.TokenStream) *Cobol85Parser {
	this := new(Cobol85Parser)

	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "Cobol85.g4"

	return this
}

// Cobol85Parser tokens.
const (
	Cobol85ParserEOF                    = antlr.TokenEOF
	Cobol85ParserABORT                  = 1
	Cobol85ParserACCEPT                 = 2
	Cobol85ParserACCESS                 = 3
	Cobol85ParserADD                    = 4
	Cobol85ParserADDRESS                = 5
	Cobol85ParserADVANCING              = 6
	Cobol85ParserAFTER                  = 7
	Cobol85ParserALIGNED                = 8
	Cobol85ParserALL                    = 9
	Cobol85ParserALPHABET               = 10
	Cobol85ParserALPHABETIC             = 11
	Cobol85ParserALPHABETIC_LOWER       = 12
	Cobol85ParserALPHABETIC_UPPER       = 13
	Cobol85ParserALPHANUMERIC           = 14
	Cobol85ParserALPHANUMERIC_EDITED    = 15
	Cobol85ParserALSO                   = 16
	Cobol85ParserALTER                  = 17
	Cobol85ParserALTERNATE              = 18
	Cobol85ParserAND                    = 19
	Cobol85ParserANY                    = 20
	Cobol85ParserARE                    = 21
	Cobol85ParserAREA                   = 22
	Cobol85ParserAREAS                  = 23
	Cobol85ParserAS                     = 24
	Cobol85ParserASCENDING              = 25
	Cobol85ParserASCII                  = 26
	Cobol85ParserASSIGN                 = 27
	Cobol85ParserASSOCIATED_DATA        = 28
	Cobol85ParserASSOCIATED_DATA_LENGTH = 29
	Cobol85ParserAT                     = 30
	Cobol85ParserATTRIBUTE              = 31
	Cobol85ParserAUTHOR                 = 32
	Cobol85ParserAUTO                   = 33
	Cobol85ParserAUTO_SKIP              = 34
	Cobol85ParserBACKGROUND_COLOR       = 35
	Cobol85ParserBACKGROUND_COLOUR      = 36
	Cobol85ParserBASIS                  = 37
	Cobol85ParserBEEP                   = 38
	Cobol85ParserBEFORE                 = 39
	Cobol85ParserBEGINNING              = 40
	Cobol85ParserBELL                   = 41
	Cobol85ParserBINARY                 = 42
	Cobol85ParserBIT                    = 43
	Cobol85ParserBLANK                  = 44
	Cobol85ParserBLINK                  = 45
	Cobol85ParserBLOCK                  = 46
	Cobol85ParserBOUNDS                 = 47
	Cobol85ParserBOTTOM                 = 48
	Cobol85ParserBY                     = 49
	Cobol85ParserBYFUNCTION             = 50
	Cobol85ParserBYTITLE                = 51
	Cobol85ParserCALL                   = 52
	Cobol85ParserCANCEL                 = 53
	Cobol85ParserCAPABLE                = 54
	Cobol85ParserCCSVERSION             = 55
	Cobol85ParserCD                     = 56
	Cobol85ParserCF                     = 57
	Cobol85ParserCH                     = 58
	Cobol85ParserCHAINING               = 59
	Cobol85ParserCHANGED                = 60
	Cobol85ParserCHANNEL                = 61
	Cobol85ParserCHARACTER              = 62
	Cobol85ParserCHARACTERS             = 63
	Cobol85ParserCLASS                  = 64
	Cobol85ParserCLASS_ID               = 65
	Cobol85ParserCLOCK_UNITS            = 66
	Cobol85ParserCLOSE                  = 67
	Cobol85ParserCLOSE_DISPOSITION      = 68
	Cobol85ParserCOBOL                  = 69
	Cobol85ParserCODE                   = 70
	Cobol85ParserCODE_SET               = 71
	Cobol85ParserCOLLATING              = 72
	Cobol85ParserCOL                    = 73
	Cobol85ParserCOLUMN                 = 74
	Cobol85ParserCOM_REG                = 75
	Cobol85ParserCOMMA                  = 76
	Cobol85ParserCOMMITMENT             = 77
	Cobol85ParserCOMMON                 = 78
	Cobol85ParserCOMMUNICATION          = 79
	Cobol85ParserCOMP                   = 80
	Cobol85ParserCOMP_1                 = 81
	Cobol85ParserCOMP_2                 = 82
	Cobol85ParserCOMP_3                 = 83
	Cobol85ParserCOMP_4                 = 84
	Cobol85ParserCOMP_5                 = 85
	Cobol85ParserCOMPUTATIONAL          = 86
	Cobol85ParserCOMPUTATIONAL_1        = 87
	Cobol85ParserCOMPUTATIONAL_2        = 88
	Cobol85ParserCOMPUTATIONAL_3        = 89
	Cobol85ParserCOMPUTATIONAL_4        = 90
	Cobol85ParserCOMPUTATIONAL_5        = 91
	Cobol85ParserCOMPUTE                = 92
	Cobol85ParserCONFIGURATION          = 93
	Cobol85ParserCONTAINS               = 94
	Cobol85ParserCONTENT                = 95
	Cobol85ParserCONTINUE               = 96
	Cobol85ParserCONTROL                = 97
	Cobol85ParserCONTROL_POINT          = 98
	Cobol85ParserCONTROLS               = 99
	Cobol85ParserCONVENTION             = 100
	Cobol85ParserCONVERTING             = 101
	Cobol85ParserCOPY                   = 102
	Cobol85ParserCORR                   = 103
	Cobol85ParserCORRESPONDING          = 104
	Cobol85ParserCOUNT                  = 105
	Cobol85ParserCRUNCH                 = 106
	Cobol85ParserCURRENCY               = 107
	Cobol85ParserCURSOR                 = 108
	Cobol85ParserDATA                   = 109
	Cobol85ParserDATA_BASE              = 110
	Cobol85ParserDATE                   = 111
	Cobol85ParserDATE_COMPILED          = 112
	Cobol85ParserDATE_WRITTEN           = 113
	Cobol85ParserDAY                    = 114
	Cobol85ParserDAY_OF_WEEK            = 115
	Cobol85ParserDBCS                   = 116
	Cobol85ParserDE                     = 117
	Cobol85ParserDEBUG_CONTENTS         = 118
	Cobol85ParserDEBUG_ITEM             = 119
	Cobol85ParserDEBUG_LINE             = 120
	Cobol85ParserDEBUG_NAME             = 121
	Cobol85ParserDEBUG_SUB_1            = 122
	Cobol85ParserDEBUG_SUB_2            = 123
	Cobol85ParserDEBUG_SUB_3            = 124
	Cobol85ParserDEBUGGING              = 125
	Cobol85ParserDECIMAL_POINT          = 126
	Cobol85ParserDECLARATIVES           = 127
	Cobol85ParserDEFAULT                = 128
	Cobol85ParserDEFAULT_DISPLAY        = 129
	Cobol85ParserDEFINITION             = 130
	Cobol85ParserDELETE                 = 131
	Cobol85ParserDELIMITED              = 132
	Cobol85ParserDELIMITER              = 133
	Cobol85ParserDEPENDING              = 134
	Cobol85ParserDESCENDING             = 135
	Cobol85ParserDESTINATION            = 136
	Cobol85ParserDETAIL                 = 137
	Cobol85ParserDFHRESP                = 138
	Cobol85ParserDFHVALUE               = 139
	Cobol85ParserDISABLE                = 140
	Cobol85ParserDISK                   = 141
	Cobol85ParserDISPLAY                = 142
	Cobol85ParserDISPLAY_1              = 143
	Cobol85ParserDIVIDE                 = 144
	Cobol85ParserDIVISION               = 145
	Cobol85ParserDONTCARE               = 146
	Cobol85ParserDOUBLE                 = 147
	Cobol85ParserDOWN                   = 148
	Cobol85ParserDUPLICATES             = 149
	Cobol85ParserDYNAMIC                = 150
	Cobol85ParserEBCDIC                 = 151
	Cobol85ParserEGCS                   = 152
	Cobol85ParserEGI                    = 153
	Cobol85ParserELSE                   = 154
	Cobol85ParserEMI                    = 155
	Cobol85ParserEMPTY_CHECK            = 156
	Cobol85ParserENABLE                 = 157
	Cobol85ParserEND                    = 158
	Cobol85ParserEND_ACCEPT             = 159
	Cobol85ParserEND_ADD                = 160
	Cobol85ParserEND_CALL               = 161
	Cobol85ParserEND_COMPUTE            = 162
	Cobol85ParserEND_DELETE             = 163
	Cobol85ParserEND_DIVIDE             = 164
	Cobol85ParserEND_EVALUATE           = 165
	Cobol85ParserEND_IF                 = 166
	Cobol85ParserEND_MULTIPLY           = 167
	Cobol85ParserEND_OF_PAGE            = 168
	Cobol85ParserEND_PERFORM            = 169
	Cobol85ParserEND_READ               = 170
	Cobol85ParserEND_RECEIVE            = 171
	Cobol85ParserEND_RETURN             = 172
	Cobol85ParserEND_REWRITE            = 173
	Cobol85ParserEND_SEARCH             = 174
	Cobol85ParserEND_START              = 175
	Cobol85ParserEND_STRING             = 176
	Cobol85ParserEND_SUBTRACT           = 177
	Cobol85ParserEND_UNSTRING           = 178
	Cobol85ParserEND_WRITE              = 179
	Cobol85ParserENDING                 = 180
	Cobol85ParserENTER                  = 181
	Cobol85ParserENTRY                  = 182
	Cobol85ParserENTRY_PROCEDURE        = 183
	Cobol85ParserENVIRONMENT            = 184
	Cobol85ParserEOP                    = 185
	Cobol85ParserEQUAL                  = 186
	Cobol85ParserERASE                  = 187
	Cobol85ParserERROR                  = 188
	Cobol85ParserEOL                    = 189
	Cobol85ParserEOS                    = 190
	Cobol85ParserESCAPE                 = 191
	Cobol85ParserESI                    = 192
	Cobol85ParserEVALUATE               = 193
	Cobol85ParserEVENT                  = 194
	Cobol85ParserEVERY                  = 195
	Cobol85ParserEXCEPTION              = 196
	Cobol85ParserEXCLUSIVE              = 197
	Cobol85ParserEXHIBIT                = 198
	Cobol85ParserEXIT                   = 199
	Cobol85ParserEXPORT                 = 200
	Cobol85ParserEXTEND                 = 201
	Cobol85ParserEXTENDED               = 202
	Cobol85ParserEXTERNAL               = 203
	Cobol85ParserFALSE                  = 204
	Cobol85ParserFD                     = 205
	Cobol85ParserFILE                   = 206
	Cobol85ParserFILE_CONTROL           = 207
	Cobol85ParserFILLER                 = 208
	Cobol85ParserFINAL                  = 209
	Cobol85ParserFIRST                  = 210
	Cobol85ParserFOOTING                = 211
	Cobol85ParserFOR                    = 212
	Cobol85ParserFOREGROUND_COLOR       = 213
	Cobol85ParserFOREGROUND_COLOUR      = 214
	Cobol85ParserFROM                   = 215
	Cobol85ParserFULL                   = 216
	Cobol85ParserFUNCTION               = 217
	Cobol85ParserFUNCTIONNAME           = 218
	Cobol85ParserFUNCTION_POINTER       = 219
	Cobol85ParserGENERATE               = 220
	Cobol85ParserGOBACK                 = 221
	Cobol85ParserGIVING                 = 222
	Cobol85ParserGLOBAL                 = 223
	Cobol85ParserGO                     = 224
	Cobol85ParserGREATER                = 225
	Cobol85ParserGRID                   = 226
	Cobol85ParserGROUP                  = 227
	Cobol85ParserHEADING                = 228
	Cobol85ParserHIGHLIGHT              = 229
	Cobol85ParserHIGH_VALUE             = 230
	Cobol85ParserHIGH_VALUES            = 231
	Cobol85ParserI_O                    = 232
	Cobol85ParserI_O_CONTROL            = 233
	Cobol85ParserID                     = 234
	Cobol85ParserIDENTIFICATION         = 235
	Cobol85ParserIF                     = 236
	Cobol85ParserIMPLICIT               = 237
	Cobol85ParserIMPORT                 = 238
	Cobol85ParserIN                     = 239
	Cobol85ParserINDEX                  = 240
	Cobol85ParserINDEXED                = 241
	Cobol85ParserINDICATE               = 242
	Cobol85ParserINITIAL                = 243
	Cobol85ParserINITIALIZE             = 244
	Cobol85ParserINITIATE               = 245
	Cobol85ParserINPUT                  = 246
	Cobol85ParserINPUT_OUTPUT           = 247
	Cobol85ParserINSPECT                = 248
	Cobol85ParserINSTALLATION           = 249
	Cobol85ParserINTEGER                = 250
	Cobol85ParserINTO                   = 251
	Cobol85ParserINVALID                = 252
	Cobol85ParserINVOKE                 = 253
	Cobol85ParserIS                     = 254
	Cobol85ParserJUST                   = 255
	Cobol85ParserJUSTIFIED              = 256
	Cobol85ParserKANJI                  = 257
	Cobol85ParserKEPT                   = 258
	Cobol85ParserKEY                    = 259
	Cobol85ParserKEYBOARD               = 260
	Cobol85ParserLABEL                  = 261
	Cobol85ParserLANGUAGE               = 262
	Cobol85ParserLAST                   = 263
	Cobol85ParserLB                     = 264
	Cobol85ParserLD                     = 265
	Cobol85ParserLEADING                = 266
	Cobol85ParserLEFT                   = 267
	Cobol85ParserLEFTLINE               = 268
	Cobol85ParserLENGTH                 = 269
	Cobol85ParserLENGTH_CHECK           = 270
	Cobol85ParserLESS                   = 271
	Cobol85ParserLIBACCESS              = 272
	Cobol85ParserLIBPARAMETER           = 273
	Cobol85ParserLIBRARY                = 274
	Cobol85ParserLIMIT                  = 275
	Cobol85ParserLIMITS                 = 276
	Cobol85ParserLINAGE                 = 277
	Cobol85ParserLINAGE_COUNTER         = 278
	Cobol85ParserLINE                   = 279
	Cobol85ParserLINES                  = 280
	Cobol85ParserLINE_COUNTER           = 281
	Cobol85ParserLINKAGE                = 282
	Cobol85ParserLIST                   = 283
	Cobol85ParserLOCAL                  = 284
	Cobol85ParserLOCAL_STORAGE          = 285
	Cobol85ParserLOCK                   = 286
	Cobol85ParserLONG_DATE              = 287
	Cobol85ParserLONG_TIME              = 288
	Cobol85ParserLOWER                  = 289
	Cobol85ParserLOWLIGHT               = 290
	Cobol85ParserLOW_VALUE              = 291
	Cobol85ParserLOW_VALUES             = 292
	Cobol85ParserMEMORY                 = 293
	Cobol85ParserMERGE                  = 294
	Cobol85ParserMESSAGE                = 295
	Cobol85ParserMMDDYYYY               = 296
	Cobol85ParserMODE                   = 297
	Cobol85ParserMODULES                = 298
	Cobol85ParserMORE_LABELS            = 299
	Cobol85ParserMOVE                   = 300
	Cobol85ParserMULTIPLE               = 301
	Cobol85ParserMULTIPLY               = 302
	Cobol85ParserNAMED                  = 303
	Cobol85ParserNATIONAL               = 304
	Cobol85ParserNATIONAL_EDITED        = 305
	Cobol85ParserNATIVE                 = 306
	Cobol85ParserNEGATIVE               = 307
	Cobol85ParserNETWORK                = 308
	Cobol85ParserNEXT                   = 309
	Cobol85ParserNO                     = 310
	Cobol85ParserNO_ECHO                = 311
	Cobol85ParserNOT                    = 312
	Cobol85ParserNULL                   = 313
	Cobol85ParserNULLS                  = 314
	Cobol85ParserNUMBER                 = 315
	Cobol85ParserNUMERIC                = 316
	Cobol85ParserNUMERIC_DATE           = 317
	Cobol85ParserNUMERIC_EDITED         = 318
	Cobol85ParserNUMERIC_TIME           = 319
	Cobol85ParserOBJECT_COMPUTER        = 320
	Cobol85ParserOCCURS                 = 321
	Cobol85ParserODT                    = 322
	Cobol85ParserOF                     = 323
	Cobol85ParserOFF                    = 324
	Cobol85ParserOMITTED                = 325
	Cobol85ParserON                     = 326
	Cobol85ParserOPEN                   = 327
	Cobol85ParserOPTIONAL               = 328
	Cobol85ParserOR                     = 329
	Cobol85ParserORDER                  = 330
	Cobol85ParserORDERLY                = 331
	Cobol85ParserORGANIZATION           = 332
	Cobol85ParserOTHER                  = 333
	Cobol85ParserOUTPUT                 = 334
	Cobol85ParserOVERFLOW               = 335
	Cobol85ParserOVERLINE               = 336
	Cobol85ParserOWN                    = 337
	Cobol85ParserPACKED_DECIMAL         = 338
	Cobol85ParserPADDING                = 339
	Cobol85ParserPAGE                   = 340
	Cobol85ParserPAGE_COUNTER           = 341
	Cobol85ParserPASSWORD               = 342
	Cobol85ParserPERFORM                = 343
	Cobol85ParserPF                     = 344
	Cobol85ParserPH                     = 345
	Cobol85ParserPIC                    = 346
	Cobol85ParserPICTURE                = 347
	Cobol85ParserPLUS                   = 348
	Cobol85ParserPOINTER                = 349
	Cobol85ParserPOSITION               = 350
	Cobol85ParserPOSITIVE               = 351
	Cobol85ParserPORT                   = 352
	Cobol85ParserPRINTER                = 353
	Cobol85ParserPRINTING               = 354
	Cobol85ParserPRIVATE                = 355
	Cobol85ParserPROCEDURE              = 356
	Cobol85ParserPROCEDURE_POINTER      = 357
	Cobol85ParserPROCEDURES             = 358
	Cobol85ParserPROCEED                = 359
	Cobol85ParserPROCESS                = 360
	Cobol85ParserPROGRAM                = 361
	Cobol85ParserPROGRAM_ID             = 362
	Cobol85ParserPROGRAM_LIBRARY        = 363
	Cobol85ParserPROMPT                 = 364
	Cobol85ParserPURGE                  = 365
	Cobol85ParserQUEUE                  = 366
	Cobol85ParserQUOTE                  = 367
	Cobol85ParserQUOTES                 = 368
	Cobol85ParserRANDOM                 = 369
	Cobol85ParserREADER                 = 370
	Cobol85ParserREMOTE                 = 371
	Cobol85ParserRD                     = 372
	Cobol85ParserREAL                   = 373
	Cobol85ParserREAD                   = 374
	Cobol85ParserRECEIVE                = 375
	Cobol85ParserRECEIVED               = 376
	Cobol85ParserRECORD                 = 377
	Cobol85ParserRECORDING              = 378
	Cobol85ParserRECORDS                = 379
	Cobol85ParserRECURSIVE              = 380
	Cobol85ParserREDEFINES              = 381
	Cobol85ParserREEL                   = 382
	Cobol85ParserREF                    = 383
	Cobol85ParserREFERENCE              = 384
	Cobol85ParserREFERENCES             = 385
	Cobol85ParserRELATIVE               = 386
	Cobol85ParserRELEASE                = 387
	Cobol85ParserREMAINDER              = 388
	Cobol85ParserREMARKS                = 389
	Cobol85ParserREMOVAL                = 390
	Cobol85ParserREMOVE                 = 391
	Cobol85ParserRENAMES                = 392
	Cobol85ParserREPLACE                = 393
	Cobol85ParserREPLACING              = 394
	Cobol85ParserREPORT                 = 395
	Cobol85ParserREPORTING              = 396
	Cobol85ParserREPORTS                = 397
	Cobol85ParserREQUIRED               = 398
	Cobol85ParserRERUN                  = 399
	Cobol85ParserRESERVE                = 400
	Cobol85ParserREVERSE_VIDEO          = 401
	Cobol85ParserRESET                  = 402
	Cobol85ParserRETURN                 = 403
	Cobol85ParserRETURN_CODE            = 404
	Cobol85ParserRETURNING              = 405
	Cobol85ParserREVERSED               = 406
	Cobol85ParserREWIND                 = 407
	Cobol85ParserREWRITE                = 408
	Cobol85ParserRF                     = 409
	Cobol85ParserRH                     = 410
	Cobol85ParserRIGHT                  = 411
	Cobol85ParserROUNDED                = 412
	Cobol85ParserRUN                    = 413
	Cobol85ParserSAME                   = 414
	Cobol85ParserSAVE                   = 415
	Cobol85ParserSCREEN                 = 416
	Cobol85ParserSD                     = 417
	Cobol85ParserSEARCH                 = 418
	Cobol85ParserSECTION                = 419
	Cobol85ParserSECURE                 = 420
	Cobol85ParserSECURITY               = 421
	Cobol85ParserSEGMENT                = 422
	Cobol85ParserSEGMENT_LIMIT          = 423
	Cobol85ParserSELECT                 = 424
	Cobol85ParserSEND                   = 425
	Cobol85ParserSENTENCE               = 426
	Cobol85ParserSEPARATE               = 427
	Cobol85ParserSEQUENCE               = 428
	Cobol85ParserSEQUENTIAL             = 429
	Cobol85ParserSET                    = 430
	Cobol85ParserSHARED                 = 431
	Cobol85ParserSHAREDBYALL            = 432
	Cobol85ParserSHAREDBYRUNUNIT        = 433
	Cobol85ParserSHARING                = 434
	Cobol85ParserSHIFT_IN               = 435
	Cobol85ParserSHIFT_OUT              = 436
	Cobol85ParserSHORT_DATE             = 437
	Cobol85ParserSIGN                   = 438
	Cobol85ParserSIZE                   = 439
	Cobol85ParserSORT                   = 440
	Cobol85ParserSORT_CONTROL           = 441
	Cobol85ParserSORT_CORE_SIZE         = 442
	Cobol85ParserSORT_FILE_SIZE         = 443
	Cobol85ParserSORT_MERGE             = 444
	Cobol85ParserSORT_MESSAGE           = 445
	Cobol85ParserSORT_MODE_SIZE         = 446
	Cobol85ParserSORT_RETURN            = 447
	Cobol85ParserSOURCE                 = 448
	Cobol85ParserSOURCE_COMPUTER        = 449
	Cobol85ParserSPACE                  = 450
	Cobol85ParserSPACES                 = 451
	Cobol85ParserSPECIAL_NAMES          = 452
	Cobol85ParserSTANDARD               = 453
	Cobol85ParserSTANDARD_1             = 454
	Cobol85ParserSTANDARD_2             = 455
	Cobol85ParserSTART                  = 456
	Cobol85ParserSTATUS                 = 457
	Cobol85ParserSTOP                   = 458
	Cobol85ParserSTRING                 = 459
	Cobol85ParserSUB_QUEUE_1            = 460
	Cobol85ParserSUB_QUEUE_2            = 461
	Cobol85ParserSUB_QUEUE_3            = 462
	Cobol85ParserSUBTRACT               = 463
	Cobol85ParserSUM                    = 464
	Cobol85ParserSUPPRESS               = 465
	Cobol85ParserSYMBOL                 = 466
	Cobol85ParserSYMBOLIC               = 467
	Cobol85ParserSYNC                   = 468
	Cobol85ParserSYNCHRONIZED           = 469
	Cobol85ParserTABLE                  = 470
	Cobol85ParserTALLY                  = 471
	Cobol85ParserTALLYING               = 472
	Cobol85ParserTASK                   = 473
	Cobol85ParserTAPE                   = 474
	Cobol85ParserTERMINAL               = 475
	Cobol85ParserTERMINATE              = 476
	Cobol85ParserTEST                   = 477
	Cobol85ParserTEXT                   = 478
	Cobol85ParserTHAN                   = 479
	Cobol85ParserTHEN                   = 480
	Cobol85ParserTHREAD                 = 481
	Cobol85ParserTHREAD_LOCAL           = 482
	Cobol85ParserTHROUGH                = 483
	Cobol85ParserTHRU                   = 484
	Cobol85ParserTIME                   = 485
	Cobol85ParserTIMER                  = 486
	Cobol85ParserTIMES                  = 487
	Cobol85ParserTITLE                  = 488
	Cobol85ParserTO                     = 489
	Cobol85ParserTODAYS_DATE            = 490
	Cobol85ParserTODAYS_NAME            = 491
	Cobol85ParserTOP                    = 492
	Cobol85ParserTRAILING               = 493
	Cobol85ParserTRUE                   = 494
	Cobol85ParserTRUNCATED              = 495
	Cobol85ParserTYPE                   = 496
	Cobol85ParserTYPEDEF                = 497
	Cobol85ParserUNDERLINE              = 498
	Cobol85ParserUNIT                   = 499
	Cobol85ParserUNSTRING               = 500
	Cobol85ParserUNTIL                  = 501
	Cobol85ParserUP                     = 502
	Cobol85ParserUPON                   = 503
	Cobol85ParserUSAGE                  = 504
	Cobol85ParserUSE                    = 505
	Cobol85ParserUSING                  = 506
	Cobol85ParserVALUE                  = 507
	Cobol85ParserVALUES                 = 508
	Cobol85ParserVARYING                = 509
	Cobol85ParserVIRTUAL                = 510
	Cobol85ParserWAIT                   = 511
	Cobol85ParserWHEN                   = 512
	Cobol85ParserWHEN_COMPILED          = 513
	Cobol85ParserWITH                   = 514
	Cobol85ParserWORDS                  = 515
	Cobol85ParserWORKING_STORAGE        = 516
	Cobol85ParserWRITE                  = 517
	Cobol85ParserYEAR                   = 518
	Cobol85ParserYYYYMMDD               = 519
	Cobol85ParserYYYYDDD                = 520
	Cobol85ParserZERO                   = 521
	Cobol85ParserZERO_FILL              = 522
	Cobol85ParserZEROS                  = 523
	Cobol85ParserZEROES                 = 524
	Cobol85ParserAMPCHAR                = 525
	Cobol85ParserASTERISKCHAR           = 526
	Cobol85ParserDOUBLEASTERISKCHAR     = 527
	Cobol85ParserCOLONCHAR              = 528
	Cobol85ParserCOMMACHAR              = 529
	Cobol85ParserCOMMENTENTRYTAG        = 530
	Cobol85ParserCOMMENTTAG             = 531
	Cobol85ParserDOLLARCHAR             = 532
	Cobol85ParserDOUBLEQUOTE            = 533
	Cobol85ParserDOT_FS                 = 534
	Cobol85ParserDOT                    = 535
	Cobol85ParserEQUALCHAR              = 536
	Cobol85ParserEXECCICSTAG            = 537
	Cobol85ParserEXECSQLTAG             = 538
	Cobol85ParserEXECSQLIMSTAG          = 539
	Cobol85ParserLESSTHANCHAR           = 540
	Cobol85ParserLESSTHANOREQUAL        = 541
	Cobol85ParserLPARENCHAR             = 542
	Cobol85ParserMINUSCHAR              = 543
	Cobol85ParserMORETHANCHAR           = 544
	Cobol85ParserMORETHANOREQUAL        = 545
	Cobol85ParserNOTEQUALCHAR           = 546
	Cobol85ParserPLUSCHAR               = 547
	Cobol85ParserSINGLEQUOTE            = 548
	Cobol85ParserRPARENCHAR             = 549
	Cobol85ParserSLASHCHAR              = 550
	Cobol85ParserNONNUMERICLITERAL      = 551
	Cobol85ParserLEVEL_NUMBER_66        = 552
	Cobol85ParserLEVEL_NUMBER_77        = 553
	Cobol85ParserLEVEL_NUMBER_88        = 554
	Cobol85ParserINTEGERLITERAL         = 555
	Cobol85ParserNUMERICLITERAL         = 556
	Cobol85ParserIDENTIFIER             = 557
	Cobol85ParserNEWLINE                = 558
	Cobol85ParserEXECCICSLINE           = 559
	Cobol85ParserEXECSQLIMSLINE         = 560
	Cobol85ParserEXECSQLLINE            = 561
	Cobol85ParserCOMMENTENTRYLINE       = 562
	Cobol85ParserCOMMENTLINE            = 563
	Cobol85ParserWS                     = 564
	Cobol85ParserSEPARATOR              = 565
)

// Cobol85Parser rules.
const (
	Cobol85ParserRULE_startRule                                     = 0
	Cobol85ParserRULE_compilationUnit                               = 1
	Cobol85ParserRULE_programUnit                                   = 2
	Cobol85ParserRULE_endProgramStatement                           = 3
	Cobol85ParserRULE_identificationDivision                        = 4
	Cobol85ParserRULE_identificationDivisionBody                    = 5
	Cobol85ParserRULE_programIdParagraph                            = 6
	Cobol85ParserRULE_authorParagraph                               = 7
	Cobol85ParserRULE_installationParagraph                         = 8
	Cobol85ParserRULE_dateWrittenParagraph                          = 9
	Cobol85ParserRULE_dateCompiledParagraph                         = 10
	Cobol85ParserRULE_securityParagraph                             = 11
	Cobol85ParserRULE_remarksParagraph                              = 12
	Cobol85ParserRULE_environmentDivision                           = 13
	Cobol85ParserRULE_environmentDivisionBody                       = 14
	Cobol85ParserRULE_configurationSection                          = 15
	Cobol85ParserRULE_configurationSectionParagraph                 = 16
	Cobol85ParserRULE_sourceComputerParagraph                       = 17
	Cobol85ParserRULE_objectComputerParagraph                       = 18
	Cobol85ParserRULE_objectComputerClause                          = 19
	Cobol85ParserRULE_memorySizeClause                              = 20
	Cobol85ParserRULE_diskSizeClause                                = 21
	Cobol85ParserRULE_collatingSequenceClause                       = 22
	Cobol85ParserRULE_collatingSequenceClauseAlphanumeric           = 23
	Cobol85ParserRULE_collatingSequenceClauseNational               = 24
	Cobol85ParserRULE_segmentLimitClause                            = 25
	Cobol85ParserRULE_characterSetClause                            = 26
	Cobol85ParserRULE_specialNamesParagraph                         = 27
	Cobol85ParserRULE_specialNameClause                             = 28
	Cobol85ParserRULE_alphabetClause                                = 29
	Cobol85ParserRULE_alphabetClauseFormat1                         = 30
	Cobol85ParserRULE_alphabetLiterals                              = 31
	Cobol85ParserRULE_alphabetThrough                               = 32
	Cobol85ParserRULE_alphabetAlso                                  = 33
	Cobol85ParserRULE_alphabetClauseFormat2                         = 34
	Cobol85ParserRULE_channelClause                                 = 35
	Cobol85ParserRULE_classClause                                   = 36
	Cobol85ParserRULE_classClauseThrough                            = 37
	Cobol85ParserRULE_classClauseFrom                               = 38
	Cobol85ParserRULE_classClauseTo                                 = 39
	Cobol85ParserRULE_currencySignClause                            = 40
	Cobol85ParserRULE_decimalPointClause                            = 41
	Cobol85ParserRULE_defaultComputationalSignClause                = 42
	Cobol85ParserRULE_defaultDisplaySignClause                      = 43
	Cobol85ParserRULE_environmentSwitchNameClause                   = 44
	Cobol85ParserRULE_environmentSwitchNameSpecialNamesStatusPhrase = 45
	Cobol85ParserRULE_odtClause                                     = 46
	Cobol85ParserRULE_reserveNetworkClause                          = 47
	Cobol85ParserRULE_symbolicCharactersClause                      = 48
	Cobol85ParserRULE_symbolicCharacters                            = 49
	Cobol85ParserRULE_inputOutputSection                            = 50
	Cobol85ParserRULE_inputOutputSectionParagraph                   = 51
	Cobol85ParserRULE_fileControlParagraph                          = 52
	Cobol85ParserRULE_fileControlEntry                              = 53
	Cobol85ParserRULE_selectClause                                  = 54
	Cobol85ParserRULE_fileControlClause                             = 55
	Cobol85ParserRULE_assignClause                                  = 56
	Cobol85ParserRULE_reserveClause                                 = 57
	Cobol85ParserRULE_organizationClause                            = 58
	Cobol85ParserRULE_paddingCharacterClause                        = 59
	Cobol85ParserRULE_recordDelimiterClause                         = 60
	Cobol85ParserRULE_accessModeClause                              = 61
	Cobol85ParserRULE_recordKeyClause                               = 62
	Cobol85ParserRULE_alternateRecordKeyClause                      = 63
	Cobol85ParserRULE_passwordClause                                = 64
	Cobol85ParserRULE_fileStatusClause                              = 65
	Cobol85ParserRULE_relativeKeyClause                             = 66
	Cobol85ParserRULE_ioControlParagraph                            = 67
	Cobol85ParserRULE_ioControlClause                               = 68
	Cobol85ParserRULE_rerunClause                                   = 69
	Cobol85ParserRULE_rerunEveryRecords                             = 70
	Cobol85ParserRULE_rerunEveryOf                                  = 71
	Cobol85ParserRULE_rerunEveryClock                               = 72
	Cobol85ParserRULE_sameClause                                    = 73
	Cobol85ParserRULE_multipleFileClause                            = 74
	Cobol85ParserRULE_multipleFilePosition                          = 75
	Cobol85ParserRULE_commitmentControlClause                       = 76
	Cobol85ParserRULE_dataDivision                                  = 77
	Cobol85ParserRULE_dataDivisionSection                           = 78
	Cobol85ParserRULE_fileSection                                   = 79
	Cobol85ParserRULE_fileDescriptionEntry                          = 80
	Cobol85ParserRULE_fileDescriptionEntryClause                    = 81
	Cobol85ParserRULE_externalClause                                = 82
	Cobol85ParserRULE_globalClause                                  = 83
	Cobol85ParserRULE_blockContainsClause                           = 84
	Cobol85ParserRULE_blockContainsTo                               = 85
	Cobol85ParserRULE_recordContainsClause                          = 86
	Cobol85ParserRULE_recordContainsClauseFormat1                   = 87
	Cobol85ParserRULE_recordContainsClauseFormat2                   = 88
	Cobol85ParserRULE_recordContainsClauseFormat3                   = 89
	Cobol85ParserRULE_recordContainsTo                              = 90
	Cobol85ParserRULE_labelRecordsClause                            = 91
	Cobol85ParserRULE_valueOfClause                                 = 92
	Cobol85ParserRULE_valuePair                                     = 93
	Cobol85ParserRULE_dataRecordsClause                             = 94
	Cobol85ParserRULE_linageClause                                  = 95
	Cobol85ParserRULE_linageAt                                      = 96
	Cobol85ParserRULE_linageFootingAt                               = 97
	Cobol85ParserRULE_linageLinesAtTop                              = 98
	Cobol85ParserRULE_linageLinesAtBottom                           = 99
	Cobol85ParserRULE_recordingModeClause                           = 100
	Cobol85ParserRULE_modeStatement                                 = 101
	Cobol85ParserRULE_codeSetClause                                 = 102
	Cobol85ParserRULE_reportClause                                  = 103
	Cobol85ParserRULE_dataBaseSection                               = 104
	Cobol85ParserRULE_dataBaseSectionEntry                          = 105
	Cobol85ParserRULE_workingStorageSection                         = 106
	Cobol85ParserRULE_linkageSection                                = 107
	Cobol85ParserRULE_communicationSection                          = 108
	Cobol85ParserRULE_communicationDescriptionEntry                 = 109
	Cobol85ParserRULE_communicationDescriptionEntryFormat1          = 110
	Cobol85ParserRULE_communicationDescriptionEntryFormat2          = 111
	Cobol85ParserRULE_communicationDescriptionEntryFormat3          = 112
	Cobol85ParserRULE_destinationCountClause                        = 113
	Cobol85ParserRULE_destinationTableClause                        = 114
	Cobol85ParserRULE_endKeyClause                                  = 115
	Cobol85ParserRULE_errorKeyClause                                = 116
	Cobol85ParserRULE_messageCountClause                            = 117
	Cobol85ParserRULE_messageDateClause                             = 118
	Cobol85ParserRULE_messageTimeClause                             = 119
	Cobol85ParserRULE_statusKeyClause                               = 120
	Cobol85ParserRULE_symbolicDestinationClause                     = 121
	Cobol85ParserRULE_symbolicQueueClause                           = 122
	Cobol85ParserRULE_symbolicSourceClause                          = 123
	Cobol85ParserRULE_symbolicTerminalClause                        = 124
	Cobol85ParserRULE_symbolicSubQueueClause                        = 125
	Cobol85ParserRULE_textLengthClause                              = 126
	Cobol85ParserRULE_localStorageSection                           = 127
	Cobol85ParserRULE_screenSection                                 = 128
	Cobol85ParserRULE_screenDescriptionEntry                        = 129
	Cobol85ParserRULE_screenDescriptionBlankClause                  = 130
	Cobol85ParserRULE_screenDescriptionBellClause                   = 131
	Cobol85ParserRULE_screenDescriptionBlinkClause                  = 132
	Cobol85ParserRULE_screenDescriptionEraseClause                  = 133
	Cobol85ParserRULE_screenDescriptionLightClause                  = 134
	Cobol85ParserRULE_screenDescriptionGridClause                   = 135
	Cobol85ParserRULE_screenDescriptionReverseVideoClause           = 136
	Cobol85ParserRULE_screenDescriptionUnderlineClause              = 137
	Cobol85ParserRULE_screenDescriptionSizeClause                   = 138
	Cobol85ParserRULE_screenDescriptionLineClause                   = 139
	Cobol85ParserRULE_screenDescriptionColumnClause                 = 140
	Cobol85ParserRULE_screenDescriptionForegroundColorClause        = 141
	Cobol85ParserRULE_screenDescriptionBackgroundColorClause        = 142
	Cobol85ParserRULE_screenDescriptionControlClause                = 143
	Cobol85ParserRULE_screenDescriptionValueClause                  = 144
	Cobol85ParserRULE_screenDescriptionPictureClause                = 145
	Cobol85ParserRULE_screenDescriptionFromClause                   = 146
	Cobol85ParserRULE_screenDescriptionToClause                     = 147
	Cobol85ParserRULE_screenDescriptionUsingClause                  = 148
	Cobol85ParserRULE_screenDescriptionUsageClause                  = 149
	Cobol85ParserRULE_screenDescriptionBlankWhenZeroClause          = 150
	Cobol85ParserRULE_screenDescriptionJustifiedClause              = 151
	Cobol85ParserRULE_screenDescriptionSignClause                   = 152
	Cobol85ParserRULE_screenDescriptionAutoClause                   = 153
	Cobol85ParserRULE_screenDescriptionSecureClause                 = 154
	Cobol85ParserRULE_screenDescriptionRequiredClause               = 155
	Cobol85ParserRULE_screenDescriptionPromptClause                 = 156
	Cobol85ParserRULE_screenDescriptionPromptOccursClause           = 157
	Cobol85ParserRULE_screenDescriptionFullClause                   = 158
	Cobol85ParserRULE_screenDescriptionZeroFillClause               = 159
	Cobol85ParserRULE_reportSection                                 = 160
	Cobol85ParserRULE_reportDescription                             = 161
	Cobol85ParserRULE_reportDescriptionEntry                        = 162
	Cobol85ParserRULE_reportDescriptionGlobalClause                 = 163
	Cobol85ParserRULE_reportDescriptionPageLimitClause              = 164
	Cobol85ParserRULE_reportDescriptionHeadingClause                = 165
	Cobol85ParserRULE_reportDescriptionFirstDetailClause            = 166
	Cobol85ParserRULE_reportDescriptionLastDetailClause             = 167
	Cobol85ParserRULE_reportDescriptionFootingClause                = 168
	Cobol85ParserRULE_reportGroupDescriptionEntry                   = 169
	Cobol85ParserRULE_reportGroupDescriptionEntryFormat1            = 170
	Cobol85ParserRULE_reportGroupDescriptionEntryFormat2            = 171
	Cobol85ParserRULE_reportGroupDescriptionEntryFormat3            = 172
	Cobol85ParserRULE_reportGroupBlankWhenZeroClause                = 173
	Cobol85ParserRULE_reportGroupColumnNumberClause                 = 174
	Cobol85ParserRULE_reportGroupIndicateClause                     = 175
	Cobol85ParserRULE_reportGroupJustifiedClause                    = 176
	Cobol85ParserRULE_reportGroupLineNumberClause                   = 177
	Cobol85ParserRULE_reportGroupLineNumberNextPage                 = 178
	Cobol85ParserRULE_reportGroupLineNumberPlus                     = 179
	Cobol85ParserRULE_reportGroupNextGroupClause                    = 180
	Cobol85ParserRULE_reportGroupNextGroupPlus                      = 181
	Cobol85ParserRULE_reportGroupNextGroupNextPage                  = 182
	Cobol85ParserRULE_reportGroupPictureClause                      = 183
	Cobol85ParserRULE_reportGroupResetClause                        = 184
	Cobol85ParserRULE_reportGroupSignClause                         = 185
	Cobol85ParserRULE_reportGroupSourceClause                       = 186
	Cobol85ParserRULE_reportGroupSumClause                          = 187
	Cobol85ParserRULE_reportGroupTypeClause                         = 188
	Cobol85ParserRULE_reportGroupTypeReportHeading                  = 189
	Cobol85ParserRULE_reportGroupTypePageHeading                    = 190
	Cobol85ParserRULE_reportGroupTypeControlHeading                 = 191
	Cobol85ParserRULE_reportGroupTypeDetail                         = 192
	Cobol85ParserRULE_reportGroupTypeControlFooting                 = 193
	Cobol85ParserRULE_reportGroupUsageClause                        = 194
	Cobol85ParserRULE_reportGroupTypePageFooting                    = 195
	Cobol85ParserRULE_reportGroupTypeReportFooting                  = 196
	Cobol85ParserRULE_reportGroupValueClause                        = 197
	Cobol85ParserRULE_programLibrarySection                         = 198
	Cobol85ParserRULE_libraryDescriptionEntry                       = 199
	Cobol85ParserRULE_libraryDescriptionEntryFormat1                = 200
	Cobol85ParserRULE_libraryDescriptionEntryFormat2                = 201
	Cobol85ParserRULE_libraryAttributeClauseFormat1                 = 202
	Cobol85ParserRULE_libraryAttributeClauseFormat2                 = 203
	Cobol85ParserRULE_libraryAttributeFunction                      = 204
	Cobol85ParserRULE_libraryAttributeParameter                     = 205
	Cobol85ParserRULE_libraryAttributeTitle                         = 206
	Cobol85ParserRULE_libraryEntryProcedureClauseFormat1            = 207
	Cobol85ParserRULE_libraryEntryProcedureClauseFormat2            = 208
	Cobol85ParserRULE_libraryEntryProcedureForClause                = 209
	Cobol85ParserRULE_libraryEntryProcedureGivingClause             = 210
	Cobol85ParserRULE_libraryEntryProcedureUsingClause              = 211
	Cobol85ParserRULE_libraryEntryProcedureUsingName                = 212
	Cobol85ParserRULE_libraryEntryProcedureWithClause               = 213
	Cobol85ParserRULE_libraryEntryProcedureWithName                 = 214
	Cobol85ParserRULE_libraryIsCommonClause                         = 215
	Cobol85ParserRULE_libraryIsGlobalClause                         = 216
	Cobol85ParserRULE_dataDescriptionEntry                          = 217
	Cobol85ParserRULE_dataDescriptionEntryFormat1                   = 218
	Cobol85ParserRULE_dataDescriptionEntryFormat2                   = 219
	Cobol85ParserRULE_dataDescriptionEntryFormat3                   = 220
	Cobol85ParserRULE_dataDescriptionEntryExecSql                   = 221
	Cobol85ParserRULE_dataAlignedClause                             = 222
	Cobol85ParserRULE_dataBlankWhenZeroClause                       = 223
	Cobol85ParserRULE_dataCommonOwnLocalClause                      = 224
	Cobol85ParserRULE_dataExternalClause                            = 225
	Cobol85ParserRULE_dataGlobalClause                              = 226
	Cobol85ParserRULE_dataIntegerStringClause                       = 227
	Cobol85ParserRULE_dataJustifiedClause                           = 228
	Cobol85ParserRULE_dataOccursClause                              = 229
	Cobol85ParserRULE_dataOccursTo                                  = 230
	Cobol85ParserRULE_dataOccursSort                                = 231
	Cobol85ParserRULE_dataPictureClause                             = 232
	Cobol85ParserRULE_pictureString                                 = 233
	Cobol85ParserRULE_pictureChars                                  = 234
	Cobol85ParserRULE_pictureCardinality                            = 235
	Cobol85ParserRULE_dataReceivedByClause                          = 236
	Cobol85ParserRULE_dataRecordAreaClause                          = 237
	Cobol85ParserRULE_dataRedefinesClause                           = 238
	Cobol85ParserRULE_dataRenamesClause                             = 239
	Cobol85ParserRULE_dataSignClause                                = 240
	Cobol85ParserRULE_dataSynchronizedClause                        = 241
	Cobol85ParserRULE_dataThreadLocalClause                         = 242
	Cobol85ParserRULE_dataTypeClause                                = 243
	Cobol85ParserRULE_dataTypeDefClause                             = 244
	Cobol85ParserRULE_dataUsageClause                               = 245
	Cobol85ParserRULE_dataUsingClause                               = 246
	Cobol85ParserRULE_dataValueClause                               = 247
	Cobol85ParserRULE_dataValueInterval                             = 248
	Cobol85ParserRULE_dataValueIntervalFrom                         = 249
	Cobol85ParserRULE_dataValueIntervalTo                           = 250
	Cobol85ParserRULE_dataWithLowerBoundsClause                     = 251
	Cobol85ParserRULE_procedureDivision                             = 252
	Cobol85ParserRULE_procedureDivisionUsingClause                  = 253
	Cobol85ParserRULE_procedureDivisionGivingClause                 = 254
	Cobol85ParserRULE_procedureDivisionUsingParameter               = 255
	Cobol85ParserRULE_procedureDivisionByReferencePhrase            = 256
	Cobol85ParserRULE_procedureDivisionByReference                  = 257
	Cobol85ParserRULE_procedureDivisionByValuePhrase                = 258
	Cobol85ParserRULE_procedureDivisionByValue                      = 259
	Cobol85ParserRULE_procedureDeclaratives                         = 260
	Cobol85ParserRULE_procedureDeclarative                          = 261
	Cobol85ParserRULE_procedureSectionHeader                        = 262
	Cobol85ParserRULE_procedureDivisionBody                         = 263
	Cobol85ParserRULE_procedureSection                              = 264
	Cobol85ParserRULE_paragraphs                                    = 265
	Cobol85ParserRULE_paragraph                                     = 266
	Cobol85ParserRULE_sentence                                      = 267
	Cobol85ParserRULE_statement                                     = 268
	Cobol85ParserRULE_acceptStatement                               = 269
	Cobol85ParserRULE_acceptFromDateStatement                       = 270
	Cobol85ParserRULE_acceptFromMnemonicStatement                   = 271
	Cobol85ParserRULE_acceptFromEscapeKeyStatement                  = 272
	Cobol85ParserRULE_acceptMessageCountStatement                   = 273
	Cobol85ParserRULE_addStatement                                  = 274
	Cobol85ParserRULE_addToStatement                                = 275
	Cobol85ParserRULE_addToGivingStatement                          = 276
	Cobol85ParserRULE_addCorrespondingStatement                     = 277
	Cobol85ParserRULE_addFrom                                       = 278
	Cobol85ParserRULE_addTo                                         = 279
	Cobol85ParserRULE_addToGiving                                   = 280
	Cobol85ParserRULE_addGiving                                     = 281
	Cobol85ParserRULE_alteredGoTo                                   = 282
	Cobol85ParserRULE_alterStatement                                = 283
	Cobol85ParserRULE_alterProceedTo                                = 284
	Cobol85ParserRULE_callStatement                                 = 285
	Cobol85ParserRULE_callUsingPhrase                               = 286
	Cobol85ParserRULE_callUsingParameter                            = 287
	Cobol85ParserRULE_callByReferencePhrase                         = 288
	Cobol85ParserRULE_callByReference                               = 289
	Cobol85ParserRULE_callByValuePhrase                             = 290
	Cobol85ParserRULE_callByValue                                   = 291
	Cobol85ParserRULE_callByContentPhrase                           = 292
	Cobol85ParserRULE_callByContent                                 = 293
	Cobol85ParserRULE_callGivingPhrase                              = 294
	Cobol85ParserRULE_cancelStatement                               = 295
	Cobol85ParserRULE_cancelCall                                    = 296
	Cobol85ParserRULE_closeStatement                                = 297
	Cobol85ParserRULE_closeFile                                     = 298
	Cobol85ParserRULE_closeReelUnitStatement                        = 299
	Cobol85ParserRULE_closeRelativeStatement                        = 300
	Cobol85ParserRULE_closePortFileIOStatement                      = 301
	Cobol85ParserRULE_closePortFileIOUsing                          = 302
	Cobol85ParserRULE_closePortFileIOUsingCloseDisposition          = 303
	Cobol85ParserRULE_closePortFileIOUsingAssociatedData            = 304
	Cobol85ParserRULE_closePortFileIOUsingAssociatedDataLength      = 305
	Cobol85ParserRULE_computeStatement                              = 306
	Cobol85ParserRULE_computeStore                                  = 307
	Cobol85ParserRULE_continueStatement                             = 308
	Cobol85ParserRULE_deleteStatement                               = 309
	Cobol85ParserRULE_disableStatement                              = 310
	Cobol85ParserRULE_displayStatement                              = 311
	Cobol85ParserRULE_displayOperand                                = 312
	Cobol85ParserRULE_displayAt                                     = 313
	Cobol85ParserRULE_displayUpon                                   = 314
	Cobol85ParserRULE_displayWith                                   = 315
	Cobol85ParserRULE_divideStatement                               = 316
	Cobol85ParserRULE_divideIntoStatement                           = 317
	Cobol85ParserRULE_divideIntoGivingStatement                     = 318
	Cobol85ParserRULE_divideByGivingStatement                       = 319
	Cobol85ParserRULE_divideGivingPhrase                            = 320
	Cobol85ParserRULE_divideInto                                    = 321
	Cobol85ParserRULE_divideGiving                                  = 322
	Cobol85ParserRULE_divideRemainder                               = 323
	Cobol85ParserRULE_enableStatement                               = 324
	Cobol85ParserRULE_entryStatement                                = 325
	Cobol85ParserRULE_evaluateStatement                             = 326
	Cobol85ParserRULE_evaluateSelect                                = 327
	Cobol85ParserRULE_evaluateAlsoSelect                            = 328
	Cobol85ParserRULE_evaluateWhenPhrase                            = 329
	Cobol85ParserRULE_evaluateWhen                                  = 330
	Cobol85ParserRULE_evaluateCondition                             = 331
	Cobol85ParserRULE_evaluateThrough                               = 332
	Cobol85ParserRULE_evaluateAlsoCondition                         = 333
	Cobol85ParserRULE_evaluateWhenOther                             = 334
	Cobol85ParserRULE_evaluateValue                                 = 335
	Cobol85ParserRULE_execCicsStatement                             = 336
	Cobol85ParserRULE_execSqlStatement                              = 337
	Cobol85ParserRULE_execSqlImsStatement                           = 338
	Cobol85ParserRULE_exhibitStatement                              = 339
	Cobol85ParserRULE_exhibitOperand                                = 340
	Cobol85ParserRULE_exitStatement                                 = 341
	Cobol85ParserRULE_generateStatement                             = 342
	Cobol85ParserRULE_gobackStatement                               = 343
	Cobol85ParserRULE_goToStatement                                 = 344
	Cobol85ParserRULE_goToStatementSimple                           = 345
	Cobol85ParserRULE_goToDependingOnStatement                      = 346
	Cobol85ParserRULE_ifStatement                                   = 347
	Cobol85ParserRULE_ifThen                                        = 348
	Cobol85ParserRULE_ifElse                                        = 349
	Cobol85ParserRULE_initializeStatement                           = 350
	Cobol85ParserRULE_initializeReplacingPhrase                     = 351
	Cobol85ParserRULE_initializeReplacingBy                         = 352
	Cobol85ParserRULE_initiateStatement                             = 353
	Cobol85ParserRULE_inspectStatement                              = 354
	Cobol85ParserRULE_inspectTallyingPhrase                         = 355
	Cobol85ParserRULE_inspectReplacingPhrase                        = 356
	Cobol85ParserRULE_inspectTallyingReplacingPhrase                = 357
	Cobol85ParserRULE_inspectConvertingPhrase                       = 358
	Cobol85ParserRULE_inspectFor                                    = 359
	Cobol85ParserRULE_inspectCharacters                             = 360
	Cobol85ParserRULE_inspectReplacingCharacters                    = 361
	Cobol85ParserRULE_inspectAllLeadings                            = 362
	Cobol85ParserRULE_inspectReplacingAllLeadings                   = 363
	Cobol85ParserRULE_inspectAllLeading                             = 364
	Cobol85ParserRULE_inspectReplacingAllLeading                    = 365
	Cobol85ParserRULE_inspectBy                                     = 366
	Cobol85ParserRULE_inspectTo                                     = 367
	Cobol85ParserRULE_inspectBeforeAfter                            = 368
	Cobol85ParserRULE_mergeStatement                                = 369
	Cobol85ParserRULE_mergeOnKeyClause                              = 370
	Cobol85ParserRULE_mergeCollatingSequencePhrase                  = 371
	Cobol85ParserRULE_mergeCollatingAlphanumeric                    = 372
	Cobol85ParserRULE_mergeCollatingNational                        = 373
	Cobol85ParserRULE_mergeUsing                                    = 374
	Cobol85ParserRULE_mergeOutputProcedurePhrase                    = 375
	Cobol85ParserRULE_mergeOutputThrough                            = 376
	Cobol85ParserRULE_mergeGivingPhrase                             = 377
	Cobol85ParserRULE_mergeGiving                                   = 378
	Cobol85ParserRULE_moveStatement                                 = 379
	Cobol85ParserRULE_moveToStatement                               = 380
	Cobol85ParserRULE_moveToSendingArea                             = 381
	Cobol85ParserRULE_moveCorrespondingToStatement                  = 382
	Cobol85ParserRULE_moveCorrespondingToSendingArea                = 383
	Cobol85ParserRULE_multiplyStatement                             = 384
	Cobol85ParserRULE_multiplyRegular                               = 385
	Cobol85ParserRULE_multiplyRegularOperand                        = 386
	Cobol85ParserRULE_multiplyGiving                                = 387
	Cobol85ParserRULE_multiplyGivingOperand                         = 388
	Cobol85ParserRULE_multiplyGivingResult                          = 389
	Cobol85ParserRULE_openStatement                                 = 390
	Cobol85ParserRULE_openInputStatement                            = 391
	Cobol85ParserRULE_openInput                                     = 392
	Cobol85ParserRULE_openOutputStatement                           = 393
	Cobol85ParserRULE_openOutput                                    = 394
	Cobol85ParserRULE_openIOStatement                               = 395
	Cobol85ParserRULE_openExtendStatement                           = 396
	Cobol85ParserRULE_performStatement                              = 397
	Cobol85ParserRULE_performInlineStatement                        = 398
	Cobol85ParserRULE_performProcedureStatement                     = 399
	Cobol85ParserRULE_performType                                   = 400
	Cobol85ParserRULE_performTimes                                  = 401
	Cobol85ParserRULE_performUntil                                  = 402
	Cobol85ParserRULE_performVarying                                = 403
	Cobol85ParserRULE_performVaryingClause                          = 404
	Cobol85ParserRULE_performVaryingPhrase                          = 405
	Cobol85ParserRULE_performAfter                                  = 406
	Cobol85ParserRULE_performFrom                                   = 407
	Cobol85ParserRULE_performBy                                     = 408
	Cobol85ParserRULE_performTestClause                             = 409
	Cobol85ParserRULE_purgeStatement                                = 410
	Cobol85ParserRULE_readStatement                                 = 411
	Cobol85ParserRULE_readInto                                      = 412
	Cobol85ParserRULE_readWith                                      = 413
	Cobol85ParserRULE_readKey                                       = 414
	Cobol85ParserRULE_receiveStatement                              = 415
	Cobol85ParserRULE_receiveFromStatement                          = 416
	Cobol85ParserRULE_receiveFrom                                   = 417
	Cobol85ParserRULE_receiveIntoStatement                          = 418
	Cobol85ParserRULE_receiveNoData                                 = 419
	Cobol85ParserRULE_receiveWithData                               = 420
	Cobol85ParserRULE_receiveBefore                                 = 421
	Cobol85ParserRULE_receiveWith                                   = 422
	Cobol85ParserRULE_receiveThread                                 = 423
	Cobol85ParserRULE_receiveSize                                   = 424
	Cobol85ParserRULE_receiveStatus                                 = 425
	Cobol85ParserRULE_releaseStatement                              = 426
	Cobol85ParserRULE_returnStatement                               = 427
	Cobol85ParserRULE_returnInto                                    = 428
	Cobol85ParserRULE_rewriteStatement                              = 429
	Cobol85ParserRULE_rewriteFrom                                   = 430
	Cobol85ParserRULE_searchStatement                               = 431
	Cobol85ParserRULE_searchVarying                                 = 432
	Cobol85ParserRULE_searchWhen                                    = 433
	Cobol85ParserRULE_sendStatement                                 = 434
	Cobol85ParserRULE_sendStatementSync                             = 435
	Cobol85ParserRULE_sendStatementAsync                            = 436
	Cobol85ParserRULE_sendFromPhrase                                = 437
	Cobol85ParserRULE_sendWithPhrase                                = 438
	Cobol85ParserRULE_sendReplacingPhrase                           = 439
	Cobol85ParserRULE_sendAdvancingPhrase                           = 440
	Cobol85ParserRULE_sendAdvancingPage                             = 441
	Cobol85ParserRULE_sendAdvancingLines                            = 442
	Cobol85ParserRULE_sendAdvancingMnemonic                         = 443
	Cobol85ParserRULE_setStatement                                  = 444
	Cobol85ParserRULE_setToStatement                                = 445
	Cobol85ParserRULE_setUpDownByStatement                          = 446
	Cobol85ParserRULE_setTo                                         = 447
	Cobol85ParserRULE_setToValue                                    = 448
	Cobol85ParserRULE_setByValue                                    = 449
	Cobol85ParserRULE_sortStatement                                 = 450
	Cobol85ParserRULE_sortOnKeyClause                               = 451
	Cobol85ParserRULE_sortDuplicatesPhrase                          = 452
	Cobol85ParserRULE_sortCollatingSequencePhrase                   = 453
	Cobol85ParserRULE_sortCollatingAlphanumeric                     = 454
	Cobol85ParserRULE_sortCollatingNational                         = 455
	Cobol85ParserRULE_sortInputProcedurePhrase                      = 456
	Cobol85ParserRULE_sortInputThrough                              = 457
	Cobol85ParserRULE_sortUsing                                     = 458
	Cobol85ParserRULE_sortOutputProcedurePhrase                     = 459
	Cobol85ParserRULE_sortOutputThrough                             = 460
	Cobol85ParserRULE_sortGivingPhrase                              = 461
	Cobol85ParserRULE_sortGiving                                    = 462
	Cobol85ParserRULE_startStatement                                = 463
	Cobol85ParserRULE_startKey                                      = 464
	Cobol85ParserRULE_stopStatement                                 = 465
	Cobol85ParserRULE_stringStatement                               = 466
	Cobol85ParserRULE_stringSendingPhrase                           = 467
	Cobol85ParserRULE_stringSending                                 = 468
	Cobol85ParserRULE_stringDelimitedByPhrase                       = 469
	Cobol85ParserRULE_stringForPhrase                               = 470
	Cobol85ParserRULE_stringIntoPhrase                              = 471
	Cobol85ParserRULE_stringWithPointerPhrase                       = 472
	Cobol85ParserRULE_subtractStatement                             = 473
	Cobol85ParserRULE_subtractFromStatement                         = 474
	Cobol85ParserRULE_subtractFromGivingStatement                   = 475
	Cobol85ParserRULE_subtractCorrespondingStatement                = 476
	Cobol85ParserRULE_subtractSubtrahend                            = 477
	Cobol85ParserRULE_subtractMinuend                               = 478
	Cobol85ParserRULE_subtractMinuendGiving                         = 479
	Cobol85ParserRULE_subtractGiving                                = 480
	Cobol85ParserRULE_subtractMinuendCorresponding                  = 481
	Cobol85ParserRULE_terminateStatement                            = 482
	Cobol85ParserRULE_unstringStatement                             = 483
	Cobol85ParserRULE_unstringSendingPhrase                         = 484
	Cobol85ParserRULE_unstringDelimitedByPhrase                     = 485
	Cobol85ParserRULE_unstringOrAllPhrase                           = 486
	Cobol85ParserRULE_unstringIntoPhrase                            = 487
	Cobol85ParserRULE_unstringInto                                  = 488
	Cobol85ParserRULE_unstringDelimiterIn                           = 489
	Cobol85ParserRULE_unstringCountIn                               = 490
	Cobol85ParserRULE_unstringWithPointerPhrase                     = 491
	Cobol85ParserRULE_unstringTallyingPhrase                        = 492
	Cobol85ParserRULE_useStatement                                  = 493
	Cobol85ParserRULE_useAfterClause                                = 494
	Cobol85ParserRULE_useAfterOn                                    = 495
	Cobol85ParserRULE_useDebugClause                                = 496
	Cobol85ParserRULE_useDebugOn                                    = 497
	Cobol85ParserRULE_writeStatement                                = 498
	Cobol85ParserRULE_writeFromPhrase                               = 499
	Cobol85ParserRULE_writeAdvancingPhrase                          = 500
	Cobol85ParserRULE_writeAdvancingPage                            = 501
	Cobol85ParserRULE_writeAdvancingLines                           = 502
	Cobol85ParserRULE_writeAdvancingMnemonic                        = 503
	Cobol85ParserRULE_writeAtEndOfPagePhrase                        = 504
	Cobol85ParserRULE_writeNotAtEndOfPagePhrase                     = 505
	Cobol85ParserRULE_atEndPhrase                                   = 506
	Cobol85ParserRULE_notAtEndPhrase                                = 507
	Cobol85ParserRULE_invalidKeyPhrase                              = 508
	Cobol85ParserRULE_notInvalidKeyPhrase                           = 509
	Cobol85ParserRULE_onOverflowPhrase                              = 510
	Cobol85ParserRULE_notOnOverflowPhrase                           = 511
	Cobol85ParserRULE_onSizeErrorPhrase                             = 512
	Cobol85ParserRULE_notOnSizeErrorPhrase                          = 513
	Cobol85ParserRULE_onExceptionClause                             = 514
	Cobol85ParserRULE_notOnExceptionClause                          = 515
	Cobol85ParserRULE_arithmeticExpression                          = 516
	Cobol85ParserRULE_plusMinus                                     = 517
	Cobol85ParserRULE_multDivs                                      = 518
	Cobol85ParserRULE_multDiv                                       = 519
	Cobol85ParserRULE_powers                                        = 520
	Cobol85ParserRULE_power                                         = 521
	Cobol85ParserRULE_basis                                         = 522
	Cobol85ParserRULE_condition                                     = 523
	Cobol85ParserRULE_andOrCondition                                = 524
	Cobol85ParserRULE_combinableCondition                           = 525
	Cobol85ParserRULE_simpleCondition                               = 526
	Cobol85ParserRULE_classCondition                                = 527
	Cobol85ParserRULE_conditionNameReference                        = 528
	Cobol85ParserRULE_conditionNameSubscriptReference               = 529
	Cobol85ParserRULE_relationCondition                             = 530
	Cobol85ParserRULE_relationSignCondition                         = 531
	Cobol85ParserRULE_relationArithmeticComparison                  = 532
	Cobol85ParserRULE_relationCombinedComparison                    = 533
	Cobol85ParserRULE_relationCombinedCondition                     = 534
	Cobol85ParserRULE_relationalOperator                            = 535
	Cobol85ParserRULE_abbreviation                                  = 536
	Cobol85ParserRULE_identifier                                    = 537
	Cobol85ParserRULE_tableCall                                     = 538
	Cobol85ParserRULE_functionCall                                  = 539
	Cobol85ParserRULE_referenceModifier                             = 540
	Cobol85ParserRULE_characterPosition                             = 541
	Cobol85ParserRULE_length                                        = 542
	Cobol85ParserRULE_subscript                                     = 543
	Cobol85ParserRULE_argument                                      = 544
	Cobol85ParserRULE_qualifiedDataName                             = 545
	Cobol85ParserRULE_qualifiedDataNameFormat1                      = 546
	Cobol85ParserRULE_qualifiedDataNameFormat2                      = 547
	Cobol85ParserRULE_qualifiedDataNameFormat3                      = 548
	Cobol85ParserRULE_qualifiedDataNameFormat4                      = 549
	Cobol85ParserRULE_qualifiedInData                               = 550
	Cobol85ParserRULE_inData                                        = 551
	Cobol85ParserRULE_inFile                                        = 552
	Cobol85ParserRULE_inMnemonic                                    = 553
	Cobol85ParserRULE_inSection                                     = 554
	Cobol85ParserRULE_inLibrary                                     = 555
	Cobol85ParserRULE_inTable                                       = 556
	Cobol85ParserRULE_alphabetName                                  = 557
	Cobol85ParserRULE_assignmentName                                = 558
	Cobol85ParserRULE_basisName                                     = 559
	Cobol85ParserRULE_cdName                                        = 560
	Cobol85ParserRULE_className                                     = 561
	Cobol85ParserRULE_computerName                                  = 562
	Cobol85ParserRULE_conditionName                                 = 563
	Cobol85ParserRULE_dataName                                      = 564
	Cobol85ParserRULE_dataDescName                                  = 565
	Cobol85ParserRULE_environmentName                               = 566
	Cobol85ParserRULE_fileName                                      = 567
	Cobol85ParserRULE_functionName                                  = 568
	Cobol85ParserRULE_indexName                                     = 569
	Cobol85ParserRULE_languageName                                  = 570
	Cobol85ParserRULE_libraryName                                   = 571
	Cobol85ParserRULE_localName                                     = 572
	Cobol85ParserRULE_mnemonicName                                  = 573
	Cobol85ParserRULE_paragraphName                                 = 574
	Cobol85ParserRULE_procedureName                                 = 575
	Cobol85ParserRULE_programName                                   = 576
	Cobol85ParserRULE_recordName                                    = 577
	Cobol85ParserRULE_reportName                                    = 578
	Cobol85ParserRULE_routineName                                   = 579
	Cobol85ParserRULE_screenName                                    = 580
	Cobol85ParserRULE_sectionName                                   = 581
	Cobol85ParserRULE_systemName                                    = 582
	Cobol85ParserRULE_symbolicCharacter                             = 583
	Cobol85ParserRULE_textName                                      = 584
	Cobol85ParserRULE_cobolWord                                     = 585
	Cobol85ParserRULE_literal                                       = 586
	Cobol85ParserRULE_booleanLiteral                                = 587
	Cobol85ParserRULE_numericLiteral                                = 588
	Cobol85ParserRULE_integerLiteral                                = 589
	Cobol85ParserRULE_cicsDfhRespLiteral                            = 590
	Cobol85ParserRULE_cicsDfhValueLiteral                           = 591
	Cobol85ParserRULE_figurativeConstant                            = 592
	Cobol85ParserRULE_specialRegister                               = 593
	Cobol85ParserRULE_commentEntry                                  = 594
)

// IStartRuleContext is an interface to support dynamic dispatch.
type IStartRuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStartRuleContext differentiates from other interfaces.
	IsStartRuleContext()
}

type StartRuleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStartRuleContext() *StartRuleContext {
	var p = new(StartRuleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_startRule
	return p
}

func (*StartRuleContext) IsStartRuleContext() {}

func NewStartRuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StartRuleContext {
	var p = new(StartRuleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_startRule

	return p
}

func (s *StartRuleContext) GetParser() antlr.Parser { return s.parser }

func (s *StartRuleContext) CompilationUnit() ICompilationUnitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompilationUnitContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICompilationUnitContext)
}

func (s *StartRuleContext) EOF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEOF, 0)
}

func (s *StartRuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StartRuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StartRuleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterStartRule(s)
	}
}

func (s *StartRuleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitStartRule(s)
	}
}

func (p *Cobol85Parser) StartRule() (localctx IStartRuleContext) {
	localctx = NewStartRuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, Cobol85ParserRULE_startRule)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1190)
		p.CompilationUnit()
	}
	{
		p.SetState(1191)
		p.Match(Cobol85ParserEOF)
	}

	return localctx
}

// ICompilationUnitContext is an interface to support dynamic dispatch.
type ICompilationUnitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCompilationUnitContext differentiates from other interfaces.
	IsCompilationUnitContext()
}

type CompilationUnitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompilationUnitContext() *CompilationUnitContext {
	var p = new(CompilationUnitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_compilationUnit
	return p
}

func (*CompilationUnitContext) IsCompilationUnitContext() {}

func NewCompilationUnitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompilationUnitContext {
	var p = new(CompilationUnitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_compilationUnit

	return p
}

func (s *CompilationUnitContext) GetParser() antlr.Parser { return s.parser }

func (s *CompilationUnitContext) AllProgramUnit() []IProgramUnitContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IProgramUnitContext)(nil)).Elem())
	var tst = make([]IProgramUnitContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IProgramUnitContext)
		}
	}

	return tst
}

func (s *CompilationUnitContext) ProgramUnit(i int) IProgramUnitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProgramUnitContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IProgramUnitContext)
}

func (s *CompilationUnitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompilationUnitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompilationUnitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCompilationUnit(s)
	}
}

func (s *CompilationUnitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCompilationUnit(s)
	}
}

func (p *Cobol85Parser) CompilationUnit() (localctx ICompilationUnitContext) {
	localctx = NewCompilationUnitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, Cobol85ParserRULE_compilationUnit)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1194)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == Cobol85ParserID || _la == Cobol85ParserIDENTIFICATION {
		{
			p.SetState(1193)
			p.ProgramUnit()
		}

		p.SetState(1196)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IProgramUnitContext is an interface to support dynamic dispatch.
type IProgramUnitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProgramUnitContext differentiates from other interfaces.
	IsProgramUnitContext()
}

type ProgramUnitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProgramUnitContext() *ProgramUnitContext {
	var p = new(ProgramUnitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_programUnit
	return p
}

func (*ProgramUnitContext) IsProgramUnitContext() {}

func NewProgramUnitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProgramUnitContext {
	var p = new(ProgramUnitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_programUnit

	return p
}

func (s *ProgramUnitContext) GetParser() antlr.Parser { return s.parser }

func (s *ProgramUnitContext) IdentificationDivision() IIdentificationDivisionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentificationDivisionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentificationDivisionContext)
}

func (s *ProgramUnitContext) EnvironmentDivision() IEnvironmentDivisionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnvironmentDivisionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnvironmentDivisionContext)
}

func (s *ProgramUnitContext) DataDivision() IDataDivisionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataDivisionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataDivisionContext)
}

func (s *ProgramUnitContext) ProcedureDivision() IProcedureDivisionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedureDivisionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedureDivisionContext)
}

func (s *ProgramUnitContext) AllProgramUnit() []IProgramUnitContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IProgramUnitContext)(nil)).Elem())
	var tst = make([]IProgramUnitContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IProgramUnitContext)
		}
	}

	return tst
}

func (s *ProgramUnitContext) ProgramUnit(i int) IProgramUnitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProgramUnitContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IProgramUnitContext)
}

func (s *ProgramUnitContext) EndProgramStatement() IEndProgramStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndProgramStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEndProgramStatementContext)
}

func (s *ProgramUnitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProgramUnitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProgramUnitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterProgramUnit(s)
	}
}

func (s *ProgramUnitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitProgramUnit(s)
	}
}

func (p *Cobol85Parser) ProgramUnit() (localctx IProgramUnitContext) {
	localctx = NewProgramUnitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, Cobol85ParserRULE_programUnit)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1198)
		p.IdentificationDivision()
	}
	p.SetState(1200)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserENVIRONMENT {
		{
			p.SetState(1199)
			p.EnvironmentDivision()
		}

	}
	p.SetState(1203)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserDATA {
		{
			p.SetState(1202)
			p.DataDivision()
		}

	}
	p.SetState(1206)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserPROCEDURE {
		{
			p.SetState(1205)
			p.ProcedureDivision()
		}

	}
	p.SetState(1211)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 4, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1208)
				p.ProgramUnit()
			}

		}
		p.SetState(1213)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 4, p.GetParserRuleContext())
	}
	p.SetState(1215)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 5, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1214)
			p.EndProgramStatement()
		}

	}

	return localctx
}

// IEndProgramStatementContext is an interface to support dynamic dispatch.
type IEndProgramStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEndProgramStatementContext differentiates from other interfaces.
	IsEndProgramStatementContext()
}

type EndProgramStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEndProgramStatementContext() *EndProgramStatementContext {
	var p = new(EndProgramStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_endProgramStatement
	return p
}

func (*EndProgramStatementContext) IsEndProgramStatementContext() {}

func NewEndProgramStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EndProgramStatementContext {
	var p = new(EndProgramStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_endProgramStatement

	return p
}

func (s *EndProgramStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *EndProgramStatementContext) END() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND, 0)
}

func (s *EndProgramStatementContext) PROGRAM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPROGRAM, 0)
}

func (s *EndProgramStatementContext) ProgramName() IProgramNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProgramNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProgramNameContext)
}

func (s *EndProgramStatementContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *EndProgramStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EndProgramStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EndProgramStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterEndProgramStatement(s)
	}
}

func (s *EndProgramStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitEndProgramStatement(s)
	}
}

func (p *Cobol85Parser) EndProgramStatement() (localctx IEndProgramStatementContext) {
	localctx = NewEndProgramStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, Cobol85ParserRULE_endProgramStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1217)
		p.Match(Cobol85ParserEND)
	}
	{
		p.SetState(1218)
		p.Match(Cobol85ParserPROGRAM)
	}
	{
		p.SetState(1219)
		p.ProgramName()
	}
	{
		p.SetState(1220)
		p.Match(Cobol85ParserDOT_FS)
	}

	return localctx
}

// IIdentificationDivisionContext is an interface to support dynamic dispatch.
type IIdentificationDivisionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdentificationDivisionContext differentiates from other interfaces.
	IsIdentificationDivisionContext()
}

type IdentificationDivisionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentificationDivisionContext() *IdentificationDivisionContext {
	var p = new(IdentificationDivisionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_identificationDivision
	return p
}

func (*IdentificationDivisionContext) IsIdentificationDivisionContext() {}

func NewIdentificationDivisionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentificationDivisionContext {
	var p = new(IdentificationDivisionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_identificationDivision

	return p
}

func (s *IdentificationDivisionContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentificationDivisionContext) DIVISION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDIVISION, 0)
}

func (s *IdentificationDivisionContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *IdentificationDivisionContext) ProgramIdParagraph() IProgramIdParagraphContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProgramIdParagraphContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProgramIdParagraphContext)
}

func (s *IdentificationDivisionContext) IDENTIFICATION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIDENTIFICATION, 0)
}

func (s *IdentificationDivisionContext) ID() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserID, 0)
}

func (s *IdentificationDivisionContext) AllIdentificationDivisionBody() []IIdentificationDivisionBodyContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentificationDivisionBodyContext)(nil)).Elem())
	var tst = make([]IIdentificationDivisionBodyContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentificationDivisionBodyContext)
		}
	}

	return tst
}

func (s *IdentificationDivisionContext) IdentificationDivisionBody(i int) IIdentificationDivisionBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentificationDivisionBodyContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentificationDivisionBodyContext)
}

func (s *IdentificationDivisionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentificationDivisionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentificationDivisionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterIdentificationDivision(s)
	}
}

func (s *IdentificationDivisionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitIdentificationDivision(s)
	}
}

func (p *Cobol85Parser) IdentificationDivision() (localctx IIdentificationDivisionContext) {
	localctx = NewIdentificationDivisionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, Cobol85ParserRULE_identificationDivision)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1222)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserID || _la == Cobol85ParserIDENTIFICATION) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1223)
		p.Match(Cobol85ParserDIVISION)
	}
	{
		p.SetState(1224)
		p.Match(Cobol85ParserDOT_FS)
	}
	{
		p.SetState(1225)
		p.ProgramIdParagraph()
	}
	p.SetState(1229)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserAUTHOR || _la == Cobol85ParserDATE_COMPILED || _la == Cobol85ParserDATE_WRITTEN || _la == Cobol85ParserINSTALLATION || _la == Cobol85ParserREMARKS || _la == Cobol85ParserSECURITY {
		{
			p.SetState(1226)
			p.IdentificationDivisionBody()
		}

		p.SetState(1231)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IIdentificationDivisionBodyContext is an interface to support dynamic dispatch.
type IIdentificationDivisionBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdentificationDivisionBodyContext differentiates from other interfaces.
	IsIdentificationDivisionBodyContext()
}

type IdentificationDivisionBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentificationDivisionBodyContext() *IdentificationDivisionBodyContext {
	var p = new(IdentificationDivisionBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_identificationDivisionBody
	return p
}

func (*IdentificationDivisionBodyContext) IsIdentificationDivisionBodyContext() {}

func NewIdentificationDivisionBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentificationDivisionBodyContext {
	var p = new(IdentificationDivisionBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_identificationDivisionBody

	return p
}

func (s *IdentificationDivisionBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentificationDivisionBodyContext) AuthorParagraph() IAuthorParagraphContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAuthorParagraphContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAuthorParagraphContext)
}

func (s *IdentificationDivisionBodyContext) InstallationParagraph() IInstallationParagraphContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInstallationParagraphContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInstallationParagraphContext)
}

func (s *IdentificationDivisionBodyContext) DateWrittenParagraph() IDateWrittenParagraphContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDateWrittenParagraphContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDateWrittenParagraphContext)
}

func (s *IdentificationDivisionBodyContext) DateCompiledParagraph() IDateCompiledParagraphContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDateCompiledParagraphContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDateCompiledParagraphContext)
}

func (s *IdentificationDivisionBodyContext) SecurityParagraph() ISecurityParagraphContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISecurityParagraphContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISecurityParagraphContext)
}

func (s *IdentificationDivisionBodyContext) RemarksParagraph() IRemarksParagraphContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRemarksParagraphContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRemarksParagraphContext)
}

func (s *IdentificationDivisionBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentificationDivisionBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentificationDivisionBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterIdentificationDivisionBody(s)
	}
}

func (s *IdentificationDivisionBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitIdentificationDivisionBody(s)
	}
}

func (p *Cobol85Parser) IdentificationDivisionBody() (localctx IIdentificationDivisionBodyContext) {
	localctx = NewIdentificationDivisionBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, Cobol85ParserRULE_identificationDivisionBody)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1238)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserAUTHOR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1232)
			p.AuthorParagraph()
		}

	case Cobol85ParserINSTALLATION:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1233)
			p.InstallationParagraph()
		}

	case Cobol85ParserDATE_WRITTEN:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1234)
			p.DateWrittenParagraph()
		}

	case Cobol85ParserDATE_COMPILED:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1235)
			p.DateCompiledParagraph()
		}

	case Cobol85ParserSECURITY:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1236)
			p.SecurityParagraph()
		}

	case Cobol85ParserREMARKS:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1237)
			p.RemarksParagraph()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IProgramIdParagraphContext is an interface to support dynamic dispatch.
type IProgramIdParagraphContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProgramIdParagraphContext differentiates from other interfaces.
	IsProgramIdParagraphContext()
}

type ProgramIdParagraphContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProgramIdParagraphContext() *ProgramIdParagraphContext {
	var p = new(ProgramIdParagraphContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_programIdParagraph
	return p
}

func (*ProgramIdParagraphContext) IsProgramIdParagraphContext() {}

func NewProgramIdParagraphContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProgramIdParagraphContext {
	var p = new(ProgramIdParagraphContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_programIdParagraph

	return p
}

func (s *ProgramIdParagraphContext) GetParser() antlr.Parser { return s.parser }

func (s *ProgramIdParagraphContext) PROGRAM_ID() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPROGRAM_ID, 0)
}

func (s *ProgramIdParagraphContext) AllDOT_FS() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserDOT_FS)
}

func (s *ProgramIdParagraphContext) DOT_FS(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, i)
}

func (s *ProgramIdParagraphContext) ProgramName() IProgramNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProgramNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProgramNameContext)
}

func (s *ProgramIdParagraphContext) CommentEntry() ICommentEntryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICommentEntryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICommentEntryContext)
}

func (s *ProgramIdParagraphContext) COMMON() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMMON, 0)
}

func (s *ProgramIdParagraphContext) INITIAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINITIAL, 0)
}

func (s *ProgramIdParagraphContext) LIBRARY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLIBRARY, 0)
}

func (s *ProgramIdParagraphContext) DEFINITION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDEFINITION, 0)
}

func (s *ProgramIdParagraphContext) RECURSIVE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRECURSIVE, 0)
}

func (s *ProgramIdParagraphContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ProgramIdParagraphContext) PROGRAM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPROGRAM, 0)
}

func (s *ProgramIdParagraphContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProgramIdParagraphContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProgramIdParagraphContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterProgramIdParagraph(s)
	}
}

func (s *ProgramIdParagraphContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitProgramIdParagraph(s)
	}
}

func (p *Cobol85Parser) ProgramIdParagraph() (localctx IProgramIdParagraphContext) {
	localctx = NewProgramIdParagraphContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, Cobol85ParserRULE_programIdParagraph)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1240)
		p.Match(Cobol85ParserPROGRAM_ID)
	}
	{
		p.SetState(1241)
		p.Match(Cobol85ParserDOT_FS)
	}
	{
		p.SetState(1242)
		p.ProgramName()
	}
	p.SetState(1250)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCOMMON || _la == Cobol85ParserDEFINITION || (((_la-243)&-(0x1f+1)) == 0 && ((1<<uint((_la-243)))&((1<<(Cobol85ParserINITIAL-243))|(1<<(Cobol85ParserIS-243))|(1<<(Cobol85ParserLIBRARY-243)))) != 0) || _la == Cobol85ParserRECURSIVE {
		p.SetState(1244)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserIS {
			{
				p.SetState(1243)
				p.Match(Cobol85ParserIS)
			}

		}
		{
			p.SetState(1246)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85ParserCOMMON || _la == Cobol85ParserDEFINITION || _la == Cobol85ParserINITIAL || _la == Cobol85ParserLIBRARY || _la == Cobol85ParserRECURSIVE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1248)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserPROGRAM {
			{
				p.SetState(1247)
				p.Match(Cobol85ParserPROGRAM)
			}

		}

	}
	p.SetState(1253)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserDOT_FS {
		{
			p.SetState(1252)
			p.Match(Cobol85ParserDOT_FS)
		}

	}
	p.SetState(1256)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCOMMENTENTRYLINE {
		{
			p.SetState(1255)
			p.CommentEntry()
		}

	}

	return localctx
}

// IAuthorParagraphContext is an interface to support dynamic dispatch.
type IAuthorParagraphContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAuthorParagraphContext differentiates from other interfaces.
	IsAuthorParagraphContext()
}

type AuthorParagraphContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAuthorParagraphContext() *AuthorParagraphContext {
	var p = new(AuthorParagraphContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_authorParagraph
	return p
}

func (*AuthorParagraphContext) IsAuthorParagraphContext() {}

func NewAuthorParagraphContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AuthorParagraphContext {
	var p = new(AuthorParagraphContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_authorParagraph

	return p
}

func (s *AuthorParagraphContext) GetParser() antlr.Parser { return s.parser }

func (s *AuthorParagraphContext) AUTHOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAUTHOR, 0)
}

func (s *AuthorParagraphContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *AuthorParagraphContext) CommentEntry() ICommentEntryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICommentEntryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICommentEntryContext)
}

func (s *AuthorParagraphContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AuthorParagraphContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AuthorParagraphContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAuthorParagraph(s)
	}
}

func (s *AuthorParagraphContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAuthorParagraph(s)
	}
}

func (p *Cobol85Parser) AuthorParagraph() (localctx IAuthorParagraphContext) {
	localctx = NewAuthorParagraphContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, Cobol85ParserRULE_authorParagraph)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1258)
		p.Match(Cobol85ParserAUTHOR)
	}
	{
		p.SetState(1259)
		p.Match(Cobol85ParserDOT_FS)
	}
	p.SetState(1261)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCOMMENTENTRYLINE {
		{
			p.SetState(1260)
			p.CommentEntry()
		}

	}

	return localctx
}

// IInstallationParagraphContext is an interface to support dynamic dispatch.
type IInstallationParagraphContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInstallationParagraphContext differentiates from other interfaces.
	IsInstallationParagraphContext()
}

type InstallationParagraphContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInstallationParagraphContext() *InstallationParagraphContext {
	var p = new(InstallationParagraphContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_installationParagraph
	return p
}

func (*InstallationParagraphContext) IsInstallationParagraphContext() {}

func NewInstallationParagraphContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InstallationParagraphContext {
	var p = new(InstallationParagraphContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_installationParagraph

	return p
}

func (s *InstallationParagraphContext) GetParser() antlr.Parser { return s.parser }

func (s *InstallationParagraphContext) INSTALLATION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINSTALLATION, 0)
}

func (s *InstallationParagraphContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *InstallationParagraphContext) CommentEntry() ICommentEntryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICommentEntryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICommentEntryContext)
}

func (s *InstallationParagraphContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InstallationParagraphContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InstallationParagraphContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInstallationParagraph(s)
	}
}

func (s *InstallationParagraphContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInstallationParagraph(s)
	}
}

func (p *Cobol85Parser) InstallationParagraph() (localctx IInstallationParagraphContext) {
	localctx = NewInstallationParagraphContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, Cobol85ParserRULE_installationParagraph)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1263)
		p.Match(Cobol85ParserINSTALLATION)
	}
	{
		p.SetState(1264)
		p.Match(Cobol85ParserDOT_FS)
	}
	p.SetState(1266)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCOMMENTENTRYLINE {
		{
			p.SetState(1265)
			p.CommentEntry()
		}

	}

	return localctx
}

// IDateWrittenParagraphContext is an interface to support dynamic dispatch.
type IDateWrittenParagraphContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDateWrittenParagraphContext differentiates from other interfaces.
	IsDateWrittenParagraphContext()
}

type DateWrittenParagraphContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDateWrittenParagraphContext() *DateWrittenParagraphContext {
	var p = new(DateWrittenParagraphContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dateWrittenParagraph
	return p
}

func (*DateWrittenParagraphContext) IsDateWrittenParagraphContext() {}

func NewDateWrittenParagraphContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DateWrittenParagraphContext {
	var p = new(DateWrittenParagraphContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dateWrittenParagraph

	return p
}

func (s *DateWrittenParagraphContext) GetParser() antlr.Parser { return s.parser }

func (s *DateWrittenParagraphContext) DATE_WRITTEN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDATE_WRITTEN, 0)
}

func (s *DateWrittenParagraphContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *DateWrittenParagraphContext) CommentEntry() ICommentEntryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICommentEntryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICommentEntryContext)
}

func (s *DateWrittenParagraphContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DateWrittenParagraphContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DateWrittenParagraphContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDateWrittenParagraph(s)
	}
}

func (s *DateWrittenParagraphContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDateWrittenParagraph(s)
	}
}

func (p *Cobol85Parser) DateWrittenParagraph() (localctx IDateWrittenParagraphContext) {
	localctx = NewDateWrittenParagraphContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, Cobol85ParserRULE_dateWrittenParagraph)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1268)
		p.Match(Cobol85ParserDATE_WRITTEN)
	}
	{
		p.SetState(1269)
		p.Match(Cobol85ParserDOT_FS)
	}
	p.SetState(1271)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCOMMENTENTRYLINE {
		{
			p.SetState(1270)
			p.CommentEntry()
		}

	}

	return localctx
}

// IDateCompiledParagraphContext is an interface to support dynamic dispatch.
type IDateCompiledParagraphContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDateCompiledParagraphContext differentiates from other interfaces.
	IsDateCompiledParagraphContext()
}

type DateCompiledParagraphContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDateCompiledParagraphContext() *DateCompiledParagraphContext {
	var p = new(DateCompiledParagraphContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dateCompiledParagraph
	return p
}

func (*DateCompiledParagraphContext) IsDateCompiledParagraphContext() {}

func NewDateCompiledParagraphContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DateCompiledParagraphContext {
	var p = new(DateCompiledParagraphContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dateCompiledParagraph

	return p
}

func (s *DateCompiledParagraphContext) GetParser() antlr.Parser { return s.parser }

func (s *DateCompiledParagraphContext) DATE_COMPILED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDATE_COMPILED, 0)
}

func (s *DateCompiledParagraphContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *DateCompiledParagraphContext) CommentEntry() ICommentEntryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICommentEntryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICommentEntryContext)
}

func (s *DateCompiledParagraphContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DateCompiledParagraphContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DateCompiledParagraphContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDateCompiledParagraph(s)
	}
}

func (s *DateCompiledParagraphContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDateCompiledParagraph(s)
	}
}

func (p *Cobol85Parser) DateCompiledParagraph() (localctx IDateCompiledParagraphContext) {
	localctx = NewDateCompiledParagraphContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, Cobol85ParserRULE_dateCompiledParagraph)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1273)
		p.Match(Cobol85ParserDATE_COMPILED)
	}
	{
		p.SetState(1274)
		p.Match(Cobol85ParserDOT_FS)
	}
	p.SetState(1276)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCOMMENTENTRYLINE {
		{
			p.SetState(1275)
			p.CommentEntry()
		}

	}

	return localctx
}

// ISecurityParagraphContext is an interface to support dynamic dispatch.
type ISecurityParagraphContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSecurityParagraphContext differentiates from other interfaces.
	IsSecurityParagraphContext()
}

type SecurityParagraphContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySecurityParagraphContext() *SecurityParagraphContext {
	var p = new(SecurityParagraphContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_securityParagraph
	return p
}

func (*SecurityParagraphContext) IsSecurityParagraphContext() {}

func NewSecurityParagraphContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SecurityParagraphContext {
	var p = new(SecurityParagraphContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_securityParagraph

	return p
}

func (s *SecurityParagraphContext) GetParser() antlr.Parser { return s.parser }

func (s *SecurityParagraphContext) SECURITY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSECURITY, 0)
}

func (s *SecurityParagraphContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *SecurityParagraphContext) CommentEntry() ICommentEntryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICommentEntryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICommentEntryContext)
}

func (s *SecurityParagraphContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SecurityParagraphContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SecurityParagraphContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSecurityParagraph(s)
	}
}

func (s *SecurityParagraphContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSecurityParagraph(s)
	}
}

func (p *Cobol85Parser) SecurityParagraph() (localctx ISecurityParagraphContext) {
	localctx = NewSecurityParagraphContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, Cobol85ParserRULE_securityParagraph)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1278)
		p.Match(Cobol85ParserSECURITY)
	}
	{
		p.SetState(1279)
		p.Match(Cobol85ParserDOT_FS)
	}
	p.SetState(1281)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCOMMENTENTRYLINE {
		{
			p.SetState(1280)
			p.CommentEntry()
		}

	}

	return localctx
}

// IRemarksParagraphContext is an interface to support dynamic dispatch.
type IRemarksParagraphContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRemarksParagraphContext differentiates from other interfaces.
	IsRemarksParagraphContext()
}

type RemarksParagraphContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRemarksParagraphContext() *RemarksParagraphContext {
	var p = new(RemarksParagraphContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_remarksParagraph
	return p
}

func (*RemarksParagraphContext) IsRemarksParagraphContext() {}

func NewRemarksParagraphContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RemarksParagraphContext {
	var p = new(RemarksParagraphContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_remarksParagraph

	return p
}

func (s *RemarksParagraphContext) GetParser() antlr.Parser { return s.parser }

func (s *RemarksParagraphContext) REMARKS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREMARKS, 0)
}

func (s *RemarksParagraphContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *RemarksParagraphContext) CommentEntry() ICommentEntryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICommentEntryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICommentEntryContext)
}

func (s *RemarksParagraphContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RemarksParagraphContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RemarksParagraphContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterRemarksParagraph(s)
	}
}

func (s *RemarksParagraphContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitRemarksParagraph(s)
	}
}

func (p *Cobol85Parser) RemarksParagraph() (localctx IRemarksParagraphContext) {
	localctx = NewRemarksParagraphContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, Cobol85ParserRULE_remarksParagraph)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1283)
		p.Match(Cobol85ParserREMARKS)
	}
	{
		p.SetState(1284)
		p.Match(Cobol85ParserDOT_FS)
	}
	p.SetState(1286)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCOMMENTENTRYLINE {
		{
			p.SetState(1285)
			p.CommentEntry()
		}

	}

	return localctx
}

// IEnvironmentDivisionContext is an interface to support dynamic dispatch.
type IEnvironmentDivisionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnvironmentDivisionContext differentiates from other interfaces.
	IsEnvironmentDivisionContext()
}

type EnvironmentDivisionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnvironmentDivisionContext() *EnvironmentDivisionContext {
	var p = new(EnvironmentDivisionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_environmentDivision
	return p
}

func (*EnvironmentDivisionContext) IsEnvironmentDivisionContext() {}

func NewEnvironmentDivisionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnvironmentDivisionContext {
	var p = new(EnvironmentDivisionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_environmentDivision

	return p
}

func (s *EnvironmentDivisionContext) GetParser() antlr.Parser { return s.parser }

func (s *EnvironmentDivisionContext) ENVIRONMENT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserENVIRONMENT, 0)
}

func (s *EnvironmentDivisionContext) DIVISION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDIVISION, 0)
}

func (s *EnvironmentDivisionContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *EnvironmentDivisionContext) AllEnvironmentDivisionBody() []IEnvironmentDivisionBodyContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEnvironmentDivisionBodyContext)(nil)).Elem())
	var tst = make([]IEnvironmentDivisionBodyContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEnvironmentDivisionBodyContext)
		}
	}

	return tst
}

func (s *EnvironmentDivisionContext) EnvironmentDivisionBody(i int) IEnvironmentDivisionBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnvironmentDivisionBodyContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEnvironmentDivisionBodyContext)
}

func (s *EnvironmentDivisionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnvironmentDivisionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnvironmentDivisionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterEnvironmentDivision(s)
	}
}

func (s *EnvironmentDivisionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitEnvironmentDivision(s)
	}
}

func (p *Cobol85Parser) EnvironmentDivision() (localctx IEnvironmentDivisionContext) {
	localctx = NewEnvironmentDivisionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, Cobol85ParserRULE_environmentDivision)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1288)
		p.Match(Cobol85ParserENVIRONMENT)
	}
	{
		p.SetState(1289)
		p.Match(Cobol85ParserDIVISION)
	}
	{
		p.SetState(1290)
		p.Match(Cobol85ParserDOT_FS)
	}
	p.SetState(1294)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserCONFIGURATION || _la == Cobol85ParserINPUT_OUTPUT || _la == Cobol85ParserSPECIAL_NAMES {
		{
			p.SetState(1291)
			p.EnvironmentDivisionBody()
		}

		p.SetState(1296)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IEnvironmentDivisionBodyContext is an interface to support dynamic dispatch.
type IEnvironmentDivisionBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnvironmentDivisionBodyContext differentiates from other interfaces.
	IsEnvironmentDivisionBodyContext()
}

type EnvironmentDivisionBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnvironmentDivisionBodyContext() *EnvironmentDivisionBodyContext {
	var p = new(EnvironmentDivisionBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_environmentDivisionBody
	return p
}

func (*EnvironmentDivisionBodyContext) IsEnvironmentDivisionBodyContext() {}

func NewEnvironmentDivisionBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnvironmentDivisionBodyContext {
	var p = new(EnvironmentDivisionBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_environmentDivisionBody

	return p
}

func (s *EnvironmentDivisionBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *EnvironmentDivisionBodyContext) ConfigurationSection() IConfigurationSectionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConfigurationSectionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConfigurationSectionContext)
}

func (s *EnvironmentDivisionBodyContext) SpecialNamesParagraph() ISpecialNamesParagraphContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecialNamesParagraphContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpecialNamesParagraphContext)
}

func (s *EnvironmentDivisionBodyContext) InputOutputSection() IInputOutputSectionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInputOutputSectionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInputOutputSectionContext)
}

func (s *EnvironmentDivisionBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnvironmentDivisionBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnvironmentDivisionBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterEnvironmentDivisionBody(s)
	}
}

func (s *EnvironmentDivisionBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitEnvironmentDivisionBody(s)
	}
}

func (p *Cobol85Parser) EnvironmentDivisionBody() (localctx IEnvironmentDivisionBodyContext) {
	localctx = NewEnvironmentDivisionBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, Cobol85ParserRULE_environmentDivisionBody)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1300)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserCONFIGURATION:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1297)
			p.ConfigurationSection()
		}

	case Cobol85ParserSPECIAL_NAMES:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1298)
			p.SpecialNamesParagraph()
		}

	case Cobol85ParserINPUT_OUTPUT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1299)
			p.InputOutputSection()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IConfigurationSectionContext is an interface to support dynamic dispatch.
type IConfigurationSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConfigurationSectionContext differentiates from other interfaces.
	IsConfigurationSectionContext()
}

type ConfigurationSectionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConfigurationSectionContext() *ConfigurationSectionContext {
	var p = new(ConfigurationSectionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_configurationSection
	return p
}

func (*ConfigurationSectionContext) IsConfigurationSectionContext() {}

func NewConfigurationSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConfigurationSectionContext {
	var p = new(ConfigurationSectionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_configurationSection

	return p
}

func (s *ConfigurationSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *ConfigurationSectionContext) CONFIGURATION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCONFIGURATION, 0)
}

func (s *ConfigurationSectionContext) SECTION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSECTION, 0)
}

func (s *ConfigurationSectionContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *ConfigurationSectionContext) AllConfigurationSectionParagraph() []IConfigurationSectionParagraphContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConfigurationSectionParagraphContext)(nil)).Elem())
	var tst = make([]IConfigurationSectionParagraphContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConfigurationSectionParagraphContext)
		}
	}

	return tst
}

func (s *ConfigurationSectionContext) ConfigurationSectionParagraph(i int) IConfigurationSectionParagraphContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConfigurationSectionParagraphContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConfigurationSectionParagraphContext)
}

func (s *ConfigurationSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConfigurationSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConfigurationSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterConfigurationSection(s)
	}
}

func (s *ConfigurationSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitConfigurationSection(s)
	}
}

func (p *Cobol85Parser) ConfigurationSection() (localctx IConfigurationSectionContext) {
	localctx = NewConfigurationSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, Cobol85ParserRULE_configurationSection)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1302)
		p.Match(Cobol85ParserCONFIGURATION)
	}
	{
		p.SetState(1303)
		p.Match(Cobol85ParserSECTION)
	}
	{
		p.SetState(1304)
		p.Match(Cobol85ParserDOT_FS)
	}
	p.SetState(1308)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 21, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1305)
				p.ConfigurationSectionParagraph()
			}

		}
		p.SetState(1310)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 21, p.GetParserRuleContext())
	}

	return localctx
}

// IConfigurationSectionParagraphContext is an interface to support dynamic dispatch.
type IConfigurationSectionParagraphContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConfigurationSectionParagraphContext differentiates from other interfaces.
	IsConfigurationSectionParagraphContext()
}

type ConfigurationSectionParagraphContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConfigurationSectionParagraphContext() *ConfigurationSectionParagraphContext {
	var p = new(ConfigurationSectionParagraphContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_configurationSectionParagraph
	return p
}

func (*ConfigurationSectionParagraphContext) IsConfigurationSectionParagraphContext() {}

func NewConfigurationSectionParagraphContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConfigurationSectionParagraphContext {
	var p = new(ConfigurationSectionParagraphContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_configurationSectionParagraph

	return p
}

func (s *ConfigurationSectionParagraphContext) GetParser() antlr.Parser { return s.parser }

func (s *ConfigurationSectionParagraphContext) SourceComputerParagraph() ISourceComputerParagraphContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISourceComputerParagraphContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISourceComputerParagraphContext)
}

func (s *ConfigurationSectionParagraphContext) ObjectComputerParagraph() IObjectComputerParagraphContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectComputerParagraphContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectComputerParagraphContext)
}

func (s *ConfigurationSectionParagraphContext) SpecialNamesParagraph() ISpecialNamesParagraphContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecialNamesParagraphContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpecialNamesParagraphContext)
}

func (s *ConfigurationSectionParagraphContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConfigurationSectionParagraphContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConfigurationSectionParagraphContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterConfigurationSectionParagraph(s)
	}
}

func (s *ConfigurationSectionParagraphContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitConfigurationSectionParagraph(s)
	}
}

func (p *Cobol85Parser) ConfigurationSectionParagraph() (localctx IConfigurationSectionParagraphContext) {
	localctx = NewConfigurationSectionParagraphContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, Cobol85ParserRULE_configurationSectionParagraph)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1314)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserSOURCE_COMPUTER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1311)
			p.SourceComputerParagraph()
		}

	case Cobol85ParserOBJECT_COMPUTER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1312)
			p.ObjectComputerParagraph()
		}

	case Cobol85ParserSPECIAL_NAMES:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1313)
			p.SpecialNamesParagraph()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISourceComputerParagraphContext is an interface to support dynamic dispatch.
type ISourceComputerParagraphContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSourceComputerParagraphContext differentiates from other interfaces.
	IsSourceComputerParagraphContext()
}

type SourceComputerParagraphContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySourceComputerParagraphContext() *SourceComputerParagraphContext {
	var p = new(SourceComputerParagraphContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sourceComputerParagraph
	return p
}

func (*SourceComputerParagraphContext) IsSourceComputerParagraphContext() {}

func NewSourceComputerParagraphContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SourceComputerParagraphContext {
	var p = new(SourceComputerParagraphContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sourceComputerParagraph

	return p
}

func (s *SourceComputerParagraphContext) GetParser() antlr.Parser { return s.parser }

func (s *SourceComputerParagraphContext) SOURCE_COMPUTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSOURCE_COMPUTER, 0)
}

func (s *SourceComputerParagraphContext) AllDOT_FS() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserDOT_FS)
}

func (s *SourceComputerParagraphContext) DOT_FS(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, i)
}

func (s *SourceComputerParagraphContext) ComputerName() IComputerNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComputerNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComputerNameContext)
}

func (s *SourceComputerParagraphContext) DEBUGGING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDEBUGGING, 0)
}

func (s *SourceComputerParagraphContext) MODE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMODE, 0)
}

func (s *SourceComputerParagraphContext) WITH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWITH, 0)
}

func (s *SourceComputerParagraphContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SourceComputerParagraphContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SourceComputerParagraphContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSourceComputerParagraph(s)
	}
}

func (s *SourceComputerParagraphContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSourceComputerParagraph(s)
	}
}

func (p *Cobol85Parser) SourceComputerParagraph() (localctx ISourceComputerParagraphContext) {
	localctx = NewSourceComputerParagraphContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, Cobol85ParserRULE_sourceComputerParagraph)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1316)
		p.Match(Cobol85ParserSOURCE_COMPUTER)
	}
	{
		p.SetState(1317)
		p.Match(Cobol85ParserDOT_FS)
	}
	{
		p.SetState(1318)
		p.ComputerName()
	}
	p.SetState(1324)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserDEBUGGING || _la == Cobol85ParserWITH {
		p.SetState(1320)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserWITH {
			{
				p.SetState(1319)
				p.Match(Cobol85ParserWITH)
			}

		}
		{
			p.SetState(1322)
			p.Match(Cobol85ParserDEBUGGING)
		}
		{
			p.SetState(1323)
			p.Match(Cobol85ParserMODE)
		}

	}
	{
		p.SetState(1326)
		p.Match(Cobol85ParserDOT_FS)
	}

	return localctx
}

// IObjectComputerParagraphContext is an interface to support dynamic dispatch.
type IObjectComputerParagraphContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObjectComputerParagraphContext differentiates from other interfaces.
	IsObjectComputerParagraphContext()
}

type ObjectComputerParagraphContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectComputerParagraphContext() *ObjectComputerParagraphContext {
	var p = new(ObjectComputerParagraphContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_objectComputerParagraph
	return p
}

func (*ObjectComputerParagraphContext) IsObjectComputerParagraphContext() {}

func NewObjectComputerParagraphContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectComputerParagraphContext {
	var p = new(ObjectComputerParagraphContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_objectComputerParagraph

	return p
}

func (s *ObjectComputerParagraphContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectComputerParagraphContext) OBJECT_COMPUTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOBJECT_COMPUTER, 0)
}

func (s *ObjectComputerParagraphContext) AllDOT_FS() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserDOT_FS)
}

func (s *ObjectComputerParagraphContext) DOT_FS(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, i)
}

func (s *ObjectComputerParagraphContext) ComputerName() IComputerNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComputerNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComputerNameContext)
}

func (s *ObjectComputerParagraphContext) AllObjectComputerClause() []IObjectComputerClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IObjectComputerClauseContext)(nil)).Elem())
	var tst = make([]IObjectComputerClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IObjectComputerClauseContext)
		}
	}

	return tst
}

func (s *ObjectComputerParagraphContext) ObjectComputerClause(i int) IObjectComputerClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectComputerClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IObjectComputerClauseContext)
}

func (s *ObjectComputerParagraphContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectComputerParagraphContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectComputerParagraphContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterObjectComputerParagraph(s)
	}
}

func (s *ObjectComputerParagraphContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitObjectComputerParagraph(s)
	}
}

func (p *Cobol85Parser) ObjectComputerParagraph() (localctx IObjectComputerParagraphContext) {
	localctx = NewObjectComputerParagraphContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, Cobol85ParserRULE_objectComputerParagraph)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1328)
		p.Match(Cobol85ParserOBJECT_COMPUTER)
	}
	{
		p.SetState(1329)
		p.Match(Cobol85ParserDOT_FS)
	}
	{
		p.SetState(1330)
		p.ComputerName()
	}
	p.SetState(1334)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserCHARACTER || _la == Cobol85ParserCOLLATING || _la == Cobol85ParserDISK || _la == Cobol85ParserMEMORY || _la == Cobol85ParserPROGRAM || _la == Cobol85ParserSEGMENT_LIMIT || _la == Cobol85ParserSEQUENCE {
		{
			p.SetState(1331)
			p.ObjectComputerClause()
		}

		p.SetState(1336)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1337)
		p.Match(Cobol85ParserDOT_FS)
	}

	return localctx
}

// IObjectComputerClauseContext is an interface to support dynamic dispatch.
type IObjectComputerClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObjectComputerClauseContext differentiates from other interfaces.
	IsObjectComputerClauseContext()
}

type ObjectComputerClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectComputerClauseContext() *ObjectComputerClauseContext {
	var p = new(ObjectComputerClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_objectComputerClause
	return p
}

func (*ObjectComputerClauseContext) IsObjectComputerClauseContext() {}

func NewObjectComputerClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectComputerClauseContext {
	var p = new(ObjectComputerClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_objectComputerClause

	return p
}

func (s *ObjectComputerClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectComputerClauseContext) MemorySizeClause() IMemorySizeClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMemorySizeClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMemorySizeClauseContext)
}

func (s *ObjectComputerClauseContext) DiskSizeClause() IDiskSizeClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDiskSizeClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDiskSizeClauseContext)
}

func (s *ObjectComputerClauseContext) CollatingSequenceClause() ICollatingSequenceClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollatingSequenceClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollatingSequenceClauseContext)
}

func (s *ObjectComputerClauseContext) SegmentLimitClause() ISegmentLimitClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISegmentLimitClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISegmentLimitClauseContext)
}

func (s *ObjectComputerClauseContext) CharacterSetClause() ICharacterSetClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICharacterSetClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICharacterSetClauseContext)
}

func (s *ObjectComputerClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectComputerClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectComputerClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterObjectComputerClause(s)
	}
}

func (s *ObjectComputerClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitObjectComputerClause(s)
	}
}

func (p *Cobol85Parser) ObjectComputerClause() (localctx IObjectComputerClauseContext) {
	localctx = NewObjectComputerClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, Cobol85ParserRULE_objectComputerClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1344)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserMEMORY:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1339)
			p.MemorySizeClause()
		}

	case Cobol85ParserDISK:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1340)
			p.DiskSizeClause()
		}

	case Cobol85ParserCOLLATING, Cobol85ParserPROGRAM, Cobol85ParserSEQUENCE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1341)
			p.CollatingSequenceClause()
		}

	case Cobol85ParserSEGMENT_LIMIT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1342)
			p.SegmentLimitClause()
		}

	case Cobol85ParserCHARACTER:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1343)
			p.CharacterSetClause()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IMemorySizeClauseContext is an interface to support dynamic dispatch.
type IMemorySizeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMemorySizeClauseContext differentiates from other interfaces.
	IsMemorySizeClauseContext()
}

type MemorySizeClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMemorySizeClauseContext() *MemorySizeClauseContext {
	var p = new(MemorySizeClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_memorySizeClause
	return p
}

func (*MemorySizeClauseContext) IsMemorySizeClauseContext() {}

func NewMemorySizeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MemorySizeClauseContext {
	var p = new(MemorySizeClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_memorySizeClause

	return p
}

func (s *MemorySizeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *MemorySizeClauseContext) MEMORY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMEMORY, 0)
}

func (s *MemorySizeClauseContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *MemorySizeClauseContext) CobolWord() ICobolWordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICobolWordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *MemorySizeClauseContext) SIZE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSIZE, 0)
}

func (s *MemorySizeClauseContext) WORDS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWORDS, 0)
}

func (s *MemorySizeClauseContext) CHARACTERS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCHARACTERS, 0)
}

func (s *MemorySizeClauseContext) MODULES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMODULES, 0)
}

func (s *MemorySizeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MemorySizeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MemorySizeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMemorySizeClause(s)
	}
}

func (s *MemorySizeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMemorySizeClause(s)
	}
}

func (p *Cobol85Parser) MemorySizeClause() (localctx IMemorySizeClauseContext) {
	localctx = NewMemorySizeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, Cobol85ParserRULE_memorySizeClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1346)
		p.Match(Cobol85ParserMEMORY)
	}
	p.SetState(1348)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserSIZE {
		{
			p.SetState(1347)
			p.Match(Cobol85ParserSIZE)
		}

	}
	p.SetState(1352)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserLEVEL_NUMBER_66, Cobol85ParserLEVEL_NUMBER_77, Cobol85ParserLEVEL_NUMBER_88, Cobol85ParserINTEGERLITERAL:
		{
			p.SetState(1350)
			p.IntegerLiteral()
		}

	case Cobol85ParserABORT, Cobol85ParserAS, Cobol85ParserASCII, Cobol85ParserASSOCIATED_DATA, Cobol85ParserASSOCIATED_DATA_LENGTH, Cobol85ParserATTRIBUTE, Cobol85ParserAUTO, Cobol85ParserAUTO_SKIP, Cobol85ParserBACKGROUND_COLOR, Cobol85ParserBACKGROUND_COLOUR, Cobol85ParserBEEP, Cobol85ParserBELL, Cobol85ParserBINARY, Cobol85ParserBIT, Cobol85ParserBLINK, Cobol85ParserBOUNDS, Cobol85ParserCAPABLE, Cobol85ParserCCSVERSION, Cobol85ParserCHANGED, Cobol85ParserCHANNEL, Cobol85ParserCLOSE_DISPOSITION, Cobol85ParserCOBOL, Cobol85ParserCOMMITMENT, Cobol85ParserCONTROL_POINT, Cobol85ParserCONVENTION, Cobol85ParserCRUNCH, Cobol85ParserCURSOR, Cobol85ParserDEFAULT, Cobol85ParserDEFAULT_DISPLAY, Cobol85ParserDEFINITION, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserDISK, Cobol85ParserDONTCARE, Cobol85ParserDOUBLE, Cobol85ParserEBCDIC, Cobol85ParserEMPTY_CHECK, Cobol85ParserENTER, Cobol85ParserENTRY_PROCEDURE, Cobol85ParserERASE, Cobol85ParserEOL, Cobol85ParserEOS, Cobol85ParserESCAPE, Cobol85ParserEVENT, Cobol85ParserEXCLUSIVE, Cobol85ParserEXPORT, Cobol85ParserEXTENDED, Cobol85ParserFOREGROUND_COLOR, Cobol85ParserFOREGROUND_COLOUR, Cobol85ParserFULL, Cobol85ParserFUNCTIONNAME, Cobol85ParserFUNCTION_POINTER, Cobol85ParserGRID, Cobol85ParserHIGHLIGHT, Cobol85ParserIMPLICIT, Cobol85ParserIMPORT, Cobol85ParserINTEGER, Cobol85ParserKEPT, Cobol85ParserKEYBOARD, Cobol85ParserLANGUAGE, Cobol85ParserLB, Cobol85ParserLD, Cobol85ParserLEFTLINE, Cobol85ParserLENGTH_CHECK, Cobol85ParserLIBACCESS, Cobol85ParserLIBPARAMETER, Cobol85ParserLIBRARY, Cobol85ParserLIST, Cobol85ParserLOCAL, Cobol85ParserLONG_DATE, Cobol85ParserLONG_TIME, Cobol85ParserLOWER, Cobol85ParserLOWLIGHT, Cobol85ParserMMDDYYYY, Cobol85ParserNAMED, Cobol85ParserNATIONAL, Cobol85ParserNATIONAL_EDITED, Cobol85ParserNETWORK, Cobol85ParserNO_ECHO, Cobol85ParserNUMERIC_DATE, Cobol85ParserNUMERIC_TIME, Cobol85ParserODT, Cobol85ParserORDERLY, Cobol85ParserOVERLINE, Cobol85ParserOWN, Cobol85ParserPASSWORD, Cobol85ParserPORT, Cobol85ParserPRINTER, Cobol85ParserPRIVATE, Cobol85ParserPROCESS, Cobol85ParserPROGRAM, Cobol85ParserPROMPT, Cobol85ParserREADER, Cobol85ParserREMOTE, Cobol85ParserREAL, Cobol85ParserRECEIVED, Cobol85ParserRECURSIVE, Cobol85ParserREF, Cobol85ParserREMOVE, Cobol85ParserREQUIRED, Cobol85ParserREVERSE_VIDEO, Cobol85ParserSAVE, Cobol85ParserSECURE, Cobol85ParserSHARED, Cobol85ParserSHAREDBYALL, Cobol85ParserSHAREDBYRUNUNIT, Cobol85ParserSHARING, Cobol85ParserSHORT_DATE, Cobol85ParserSYMBOL, Cobol85ParserTASK, Cobol85ParserTHREAD, Cobol85ParserTHREAD_LOCAL, Cobol85ParserTIMER, Cobol85ParserTODAYS_DATE, Cobol85ParserTODAYS_NAME, Cobol85ParserTRUNCATED, Cobol85ParserTYPEDEF, Cobol85ParserUNDERLINE, Cobol85ParserVIRTUAL, Cobol85ParserWAIT, Cobol85ParserYEAR, Cobol85ParserYYYYMMDD, Cobol85ParserYYYYDDD, Cobol85ParserZERO_FILL, Cobol85ParserIDENTIFIER:
		{
			p.SetState(1351)
			p.CobolWord()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(1355)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCHARACTERS || _la == Cobol85ParserMODULES || _la == Cobol85ParserWORDS {
		{
			p.SetState(1354)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85ParserCHARACTERS || _la == Cobol85ParserMODULES || _la == Cobol85ParserWORDS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

	return localctx
}

// IDiskSizeClauseContext is an interface to support dynamic dispatch.
type IDiskSizeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDiskSizeClauseContext differentiates from other interfaces.
	IsDiskSizeClauseContext()
}

type DiskSizeClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDiskSizeClauseContext() *DiskSizeClauseContext {
	var p = new(DiskSizeClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_diskSizeClause
	return p
}

func (*DiskSizeClauseContext) IsDiskSizeClauseContext() {}

func NewDiskSizeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DiskSizeClauseContext {
	var p = new(DiskSizeClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_diskSizeClause

	return p
}

func (s *DiskSizeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DiskSizeClauseContext) DISK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDISK, 0)
}

func (s *DiskSizeClauseContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *DiskSizeClauseContext) CobolWord() ICobolWordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICobolWordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *DiskSizeClauseContext) SIZE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSIZE, 0)
}

func (s *DiskSizeClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *DiskSizeClauseContext) WORDS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWORDS, 0)
}

func (s *DiskSizeClauseContext) MODULES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMODULES, 0)
}

func (s *DiskSizeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DiskSizeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DiskSizeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDiskSizeClause(s)
	}
}

func (s *DiskSizeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDiskSizeClause(s)
	}
}

func (p *Cobol85Parser) DiskSizeClause() (localctx IDiskSizeClauseContext) {
	localctx = NewDiskSizeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, Cobol85ParserRULE_diskSizeClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1357)
		p.Match(Cobol85ParserDISK)
	}
	p.SetState(1359)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserSIZE {
		{
			p.SetState(1358)
			p.Match(Cobol85ParserSIZE)
		}

	}
	p.SetState(1362)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(1361)
			p.Match(Cobol85ParserIS)
		}

	}
	p.SetState(1366)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserLEVEL_NUMBER_66, Cobol85ParserLEVEL_NUMBER_77, Cobol85ParserLEVEL_NUMBER_88, Cobol85ParserINTEGERLITERAL:
		{
			p.SetState(1364)
			p.IntegerLiteral()
		}

	case Cobol85ParserABORT, Cobol85ParserAS, Cobol85ParserASCII, Cobol85ParserASSOCIATED_DATA, Cobol85ParserASSOCIATED_DATA_LENGTH, Cobol85ParserATTRIBUTE, Cobol85ParserAUTO, Cobol85ParserAUTO_SKIP, Cobol85ParserBACKGROUND_COLOR, Cobol85ParserBACKGROUND_COLOUR, Cobol85ParserBEEP, Cobol85ParserBELL, Cobol85ParserBINARY, Cobol85ParserBIT, Cobol85ParserBLINK, Cobol85ParserBOUNDS, Cobol85ParserCAPABLE, Cobol85ParserCCSVERSION, Cobol85ParserCHANGED, Cobol85ParserCHANNEL, Cobol85ParserCLOSE_DISPOSITION, Cobol85ParserCOBOL, Cobol85ParserCOMMITMENT, Cobol85ParserCONTROL_POINT, Cobol85ParserCONVENTION, Cobol85ParserCRUNCH, Cobol85ParserCURSOR, Cobol85ParserDEFAULT, Cobol85ParserDEFAULT_DISPLAY, Cobol85ParserDEFINITION, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserDISK, Cobol85ParserDONTCARE, Cobol85ParserDOUBLE, Cobol85ParserEBCDIC, Cobol85ParserEMPTY_CHECK, Cobol85ParserENTER, Cobol85ParserENTRY_PROCEDURE, Cobol85ParserERASE, Cobol85ParserEOL, Cobol85ParserEOS, Cobol85ParserESCAPE, Cobol85ParserEVENT, Cobol85ParserEXCLUSIVE, Cobol85ParserEXPORT, Cobol85ParserEXTENDED, Cobol85ParserFOREGROUND_COLOR, Cobol85ParserFOREGROUND_COLOUR, Cobol85ParserFULL, Cobol85ParserFUNCTIONNAME, Cobol85ParserFUNCTION_POINTER, Cobol85ParserGRID, Cobol85ParserHIGHLIGHT, Cobol85ParserIMPLICIT, Cobol85ParserIMPORT, Cobol85ParserINTEGER, Cobol85ParserKEPT, Cobol85ParserKEYBOARD, Cobol85ParserLANGUAGE, Cobol85ParserLB, Cobol85ParserLD, Cobol85ParserLEFTLINE, Cobol85ParserLENGTH_CHECK, Cobol85ParserLIBACCESS, Cobol85ParserLIBPARAMETER, Cobol85ParserLIBRARY, Cobol85ParserLIST, Cobol85ParserLOCAL, Cobol85ParserLONG_DATE, Cobol85ParserLONG_TIME, Cobol85ParserLOWER, Cobol85ParserLOWLIGHT, Cobol85ParserMMDDYYYY, Cobol85ParserNAMED, Cobol85ParserNATIONAL, Cobol85ParserNATIONAL_EDITED, Cobol85ParserNETWORK, Cobol85ParserNO_ECHO, Cobol85ParserNUMERIC_DATE, Cobol85ParserNUMERIC_TIME, Cobol85ParserODT, Cobol85ParserORDERLY, Cobol85ParserOVERLINE, Cobol85ParserOWN, Cobol85ParserPASSWORD, Cobol85ParserPORT, Cobol85ParserPRINTER, Cobol85ParserPRIVATE, Cobol85ParserPROCESS, Cobol85ParserPROGRAM, Cobol85ParserPROMPT, Cobol85ParserREADER, Cobol85ParserREMOTE, Cobol85ParserREAL, Cobol85ParserRECEIVED, Cobol85ParserRECURSIVE, Cobol85ParserREF, Cobol85ParserREMOVE, Cobol85ParserREQUIRED, Cobol85ParserREVERSE_VIDEO, Cobol85ParserSAVE, Cobol85ParserSECURE, Cobol85ParserSHARED, Cobol85ParserSHAREDBYALL, Cobol85ParserSHAREDBYRUNUNIT, Cobol85ParserSHARING, Cobol85ParserSHORT_DATE, Cobol85ParserSYMBOL, Cobol85ParserTASK, Cobol85ParserTHREAD, Cobol85ParserTHREAD_LOCAL, Cobol85ParserTIMER, Cobol85ParserTODAYS_DATE, Cobol85ParserTODAYS_NAME, Cobol85ParserTRUNCATED, Cobol85ParserTYPEDEF, Cobol85ParserUNDERLINE, Cobol85ParserVIRTUAL, Cobol85ParserWAIT, Cobol85ParserYEAR, Cobol85ParserYYYYMMDD, Cobol85ParserYYYYDDD, Cobol85ParserZERO_FILL, Cobol85ParserIDENTIFIER:
		{
			p.SetState(1365)
			p.CobolWord()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(1369)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserMODULES || _la == Cobol85ParserWORDS {
		{
			p.SetState(1368)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85ParserMODULES || _la == Cobol85ParserWORDS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

	return localctx
}

// ICollatingSequenceClauseContext is an interface to support dynamic dispatch.
type ICollatingSequenceClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollatingSequenceClauseContext differentiates from other interfaces.
	IsCollatingSequenceClauseContext()
}

type CollatingSequenceClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollatingSequenceClauseContext() *CollatingSequenceClauseContext {
	var p = new(CollatingSequenceClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_collatingSequenceClause
	return p
}

func (*CollatingSequenceClauseContext) IsCollatingSequenceClauseContext() {}

func NewCollatingSequenceClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CollatingSequenceClauseContext {
	var p = new(CollatingSequenceClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_collatingSequenceClause

	return p
}

func (s *CollatingSequenceClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CollatingSequenceClauseContext) SEQUENCE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSEQUENCE, 0)
}

func (s *CollatingSequenceClauseContext) PROGRAM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPROGRAM, 0)
}

func (s *CollatingSequenceClauseContext) COLLATING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOLLATING, 0)
}

func (s *CollatingSequenceClauseContext) CollatingSequenceClauseAlphanumeric() ICollatingSequenceClauseAlphanumericContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollatingSequenceClauseAlphanumericContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollatingSequenceClauseAlphanumericContext)
}

func (s *CollatingSequenceClauseContext) CollatingSequenceClauseNational() ICollatingSequenceClauseNationalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollatingSequenceClauseNationalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollatingSequenceClauseNationalContext)
}

func (s *CollatingSequenceClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *CollatingSequenceClauseContext) AllAlphabetName() []IAlphabetNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAlphabetNameContext)(nil)).Elem())
	var tst = make([]IAlphabetNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAlphabetNameContext)
		}
	}

	return tst
}

func (s *CollatingSequenceClauseContext) AlphabetName(i int) IAlphabetNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlphabetNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAlphabetNameContext)
}

func (s *CollatingSequenceClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollatingSequenceClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CollatingSequenceClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCollatingSequenceClause(s)
	}
}

func (s *CollatingSequenceClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCollatingSequenceClause(s)
	}
}

func (p *Cobol85Parser) CollatingSequenceClause() (localctx ICollatingSequenceClauseContext) {
	localctx = NewCollatingSequenceClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, Cobol85ParserRULE_collatingSequenceClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1372)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserPROGRAM {
		{
			p.SetState(1371)
			p.Match(Cobol85ParserPROGRAM)
		}

	}
	p.SetState(1375)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCOLLATING {
		{
			p.SetState(1374)
			p.Match(Cobol85ParserCOLLATING)
		}

	}
	{
		p.SetState(1377)
		p.Match(Cobol85ParserSEQUENCE)
	}

	p.SetState(1379)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(1378)
			p.Match(Cobol85ParserIS)
		}

	}
	p.SetState(1382)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1381)
				p.AlphabetName()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(1384)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 37, p.GetParserRuleContext())
	}

	p.SetState(1387)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 38, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1386)
			p.CollatingSequenceClauseAlphanumeric()
		}

	}
	p.SetState(1390)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFOR || _la == Cobol85ParserNATIONAL {
		{
			p.SetState(1389)
			p.CollatingSequenceClauseNational()
		}

	}

	return localctx
}

// ICollatingSequenceClauseAlphanumericContext is an interface to support dynamic dispatch.
type ICollatingSequenceClauseAlphanumericContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollatingSequenceClauseAlphanumericContext differentiates from other interfaces.
	IsCollatingSequenceClauseAlphanumericContext()
}

type CollatingSequenceClauseAlphanumericContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollatingSequenceClauseAlphanumericContext() *CollatingSequenceClauseAlphanumericContext {
	var p = new(CollatingSequenceClauseAlphanumericContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_collatingSequenceClauseAlphanumeric
	return p
}

func (*CollatingSequenceClauseAlphanumericContext) IsCollatingSequenceClauseAlphanumericContext() {}

func NewCollatingSequenceClauseAlphanumericContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CollatingSequenceClauseAlphanumericContext {
	var p = new(CollatingSequenceClauseAlphanumericContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_collatingSequenceClauseAlphanumeric

	return p
}

func (s *CollatingSequenceClauseAlphanumericContext) GetParser() antlr.Parser { return s.parser }

func (s *CollatingSequenceClauseAlphanumericContext) ALPHANUMERIC() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALPHANUMERIC, 0)
}

func (s *CollatingSequenceClauseAlphanumericContext) AlphabetName() IAlphabetNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlphabetNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlphabetNameContext)
}

func (s *CollatingSequenceClauseAlphanumericContext) FOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOR, 0)
}

func (s *CollatingSequenceClauseAlphanumericContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *CollatingSequenceClauseAlphanumericContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollatingSequenceClauseAlphanumericContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CollatingSequenceClauseAlphanumericContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCollatingSequenceClauseAlphanumeric(s)
	}
}

func (s *CollatingSequenceClauseAlphanumericContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCollatingSequenceClauseAlphanumeric(s)
	}
}

func (p *Cobol85Parser) CollatingSequenceClauseAlphanumeric() (localctx ICollatingSequenceClauseAlphanumericContext) {
	localctx = NewCollatingSequenceClauseAlphanumericContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, Cobol85ParserRULE_collatingSequenceClauseAlphanumeric)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1393)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFOR {
		{
			p.SetState(1392)
			p.Match(Cobol85ParserFOR)
		}

	}
	{
		p.SetState(1395)
		p.Match(Cobol85ParserALPHANUMERIC)
	}
	p.SetState(1397)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(1396)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(1399)
		p.AlphabetName()
	}

	return localctx
}

// ICollatingSequenceClauseNationalContext is an interface to support dynamic dispatch.
type ICollatingSequenceClauseNationalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollatingSequenceClauseNationalContext differentiates from other interfaces.
	IsCollatingSequenceClauseNationalContext()
}

type CollatingSequenceClauseNationalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollatingSequenceClauseNationalContext() *CollatingSequenceClauseNationalContext {
	var p = new(CollatingSequenceClauseNationalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_collatingSequenceClauseNational
	return p
}

func (*CollatingSequenceClauseNationalContext) IsCollatingSequenceClauseNationalContext() {}

func NewCollatingSequenceClauseNationalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CollatingSequenceClauseNationalContext {
	var p = new(CollatingSequenceClauseNationalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_collatingSequenceClauseNational

	return p
}

func (s *CollatingSequenceClauseNationalContext) GetParser() antlr.Parser { return s.parser }

func (s *CollatingSequenceClauseNationalContext) NATIONAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNATIONAL, 0)
}

func (s *CollatingSequenceClauseNationalContext) AlphabetName() IAlphabetNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlphabetNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlphabetNameContext)
}

func (s *CollatingSequenceClauseNationalContext) FOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOR, 0)
}

func (s *CollatingSequenceClauseNationalContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *CollatingSequenceClauseNationalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollatingSequenceClauseNationalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CollatingSequenceClauseNationalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCollatingSequenceClauseNational(s)
	}
}

func (s *CollatingSequenceClauseNationalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCollatingSequenceClauseNational(s)
	}
}

func (p *Cobol85Parser) CollatingSequenceClauseNational() (localctx ICollatingSequenceClauseNationalContext) {
	localctx = NewCollatingSequenceClauseNationalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, Cobol85ParserRULE_collatingSequenceClauseNational)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1402)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFOR {
		{
			p.SetState(1401)
			p.Match(Cobol85ParserFOR)
		}

	}
	{
		p.SetState(1404)
		p.Match(Cobol85ParserNATIONAL)
	}
	p.SetState(1406)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(1405)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(1408)
		p.AlphabetName()
	}

	return localctx
}

// ISegmentLimitClauseContext is an interface to support dynamic dispatch.
type ISegmentLimitClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSegmentLimitClauseContext differentiates from other interfaces.
	IsSegmentLimitClauseContext()
}

type SegmentLimitClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySegmentLimitClauseContext() *SegmentLimitClauseContext {
	var p = new(SegmentLimitClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_segmentLimitClause
	return p
}

func (*SegmentLimitClauseContext) IsSegmentLimitClauseContext() {}

func NewSegmentLimitClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SegmentLimitClauseContext {
	var p = new(SegmentLimitClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_segmentLimitClause

	return p
}

func (s *SegmentLimitClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SegmentLimitClauseContext) SEGMENT_LIMIT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSEGMENT_LIMIT, 0)
}

func (s *SegmentLimitClauseContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *SegmentLimitClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *SegmentLimitClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SegmentLimitClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SegmentLimitClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSegmentLimitClause(s)
	}
}

func (s *SegmentLimitClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSegmentLimitClause(s)
	}
}

func (p *Cobol85Parser) SegmentLimitClause() (localctx ISegmentLimitClauseContext) {
	localctx = NewSegmentLimitClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, Cobol85ParserRULE_segmentLimitClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1410)
		p.Match(Cobol85ParserSEGMENT_LIMIT)
	}
	p.SetState(1412)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(1411)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(1414)
		p.IntegerLiteral()
	}

	return localctx
}

// ICharacterSetClauseContext is an interface to support dynamic dispatch.
type ICharacterSetClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCharacterSetClauseContext differentiates from other interfaces.
	IsCharacterSetClauseContext()
}

type CharacterSetClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharacterSetClauseContext() *CharacterSetClauseContext {
	var p = new(CharacterSetClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_characterSetClause
	return p
}

func (*CharacterSetClauseContext) IsCharacterSetClauseContext() {}

func NewCharacterSetClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CharacterSetClauseContext {
	var p = new(CharacterSetClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_characterSetClause

	return p
}

func (s *CharacterSetClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CharacterSetClauseContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCHARACTER, 0)
}

func (s *CharacterSetClauseContext) SET() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSET, 0)
}

func (s *CharacterSetClauseContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *CharacterSetClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CharacterSetClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CharacterSetClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCharacterSetClause(s)
	}
}

func (s *CharacterSetClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCharacterSetClause(s)
	}
}

func (p *Cobol85Parser) CharacterSetClause() (localctx ICharacterSetClauseContext) {
	localctx = NewCharacterSetClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, Cobol85ParserRULE_characterSetClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1416)
		p.Match(Cobol85ParserCHARACTER)
	}
	{
		p.SetState(1417)
		p.Match(Cobol85ParserSET)
	}
	{
		p.SetState(1418)
		p.Match(Cobol85ParserDOT_FS)
	}

	return localctx
}

// ISpecialNamesParagraphContext is an interface to support dynamic dispatch.
type ISpecialNamesParagraphContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSpecialNamesParagraphContext differentiates from other interfaces.
	IsSpecialNamesParagraphContext()
}

type SpecialNamesParagraphContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpecialNamesParagraphContext() *SpecialNamesParagraphContext {
	var p = new(SpecialNamesParagraphContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_specialNamesParagraph
	return p
}

func (*SpecialNamesParagraphContext) IsSpecialNamesParagraphContext() {}

func NewSpecialNamesParagraphContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SpecialNamesParagraphContext {
	var p = new(SpecialNamesParagraphContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_specialNamesParagraph

	return p
}

func (s *SpecialNamesParagraphContext) GetParser() antlr.Parser { return s.parser }

func (s *SpecialNamesParagraphContext) SPECIAL_NAMES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSPECIAL_NAMES, 0)
}

func (s *SpecialNamesParagraphContext) AllDOT_FS() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserDOT_FS)
}

func (s *SpecialNamesParagraphContext) DOT_FS(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, i)
}

func (s *SpecialNamesParagraphContext) AllSpecialNameClause() []ISpecialNameClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISpecialNameClauseContext)(nil)).Elem())
	var tst = make([]ISpecialNameClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISpecialNameClauseContext)
		}
	}

	return tst
}

func (s *SpecialNamesParagraphContext) SpecialNameClause(i int) ISpecialNameClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecialNameClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISpecialNameClauseContext)
}

func (s *SpecialNamesParagraphContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpecialNamesParagraphContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SpecialNamesParagraphContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSpecialNamesParagraph(s)
	}
}

func (s *SpecialNamesParagraphContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSpecialNamesParagraph(s)
	}
}

func (p *Cobol85Parser) SpecialNamesParagraph() (localctx ISpecialNamesParagraphContext) {
	localctx = NewSpecialNamesParagraphContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, Cobol85ParserRULE_specialNamesParagraph)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1420)
		p.Match(Cobol85ParserSPECIAL_NAMES)
	}
	{
		p.SetState(1421)
		p.Match(Cobol85ParserDOT_FS)
	}
	p.SetState(1429)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserALPHABET)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH)|(1<<Cobol85ParserATTRIBUTE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBINARY-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33))|(1<<(Cobol85ParserCLASS-33)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-68))|(1<<(Cobol85ParserCOBOL-68))|(1<<(Cobol85ParserCOMMITMENT-68))|(1<<(Cobol85ParserCONTROL_POINT-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(Cobol85ParserCONVENTION-100))|(1<<(Cobol85ParserCRUNCH-100))|(1<<(Cobol85ParserCURRENCY-100))|(1<<(Cobol85ParserCURSOR-100))|(1<<(Cobol85ParserDECIMAL_POINT-100))|(1<<(Cobol85ParserDEFAULT-100))|(1<<(Cobol85ParserDEFAULT_DISPLAY-100))|(1<<(Cobol85ParserDEFINITION-100)))) != 0) || (((_la-138)&-(0x1f+1)) == 0 && ((1<<uint((_la-138)))&((1<<(Cobol85ParserDFHRESP-138))|(1<<(Cobol85ParserDFHVALUE-138))|(1<<(Cobol85ParserDISK-138))|(1<<(Cobol85ParserDONTCARE-138))|(1<<(Cobol85ParserDOUBLE-138))|(1<<(Cobol85ParserEBCDIC-138))|(1<<(Cobol85ParserEMPTY_CHECK-138)))) != 0) || (((_la-181)&-(0x1f+1)) == 0 && ((1<<uint((_la-181)))&((1<<(Cobol85ParserENTER-181))|(1<<(Cobol85ParserENTRY_PROCEDURE-181))|(1<<(Cobol85ParserERASE-181))|(1<<(Cobol85ParserEOL-181))|(1<<(Cobol85ParserEOS-181))|(1<<(Cobol85ParserESCAPE-181))|(1<<(Cobol85ParserEVENT-181))|(1<<(Cobol85ParserEXCLUSIVE-181))|(1<<(Cobol85ParserEXPORT-181))|(1<<(Cobol85ParserEXTENDED-181)))) != 0) || (((_la-213)&-(0x1f+1)) == 0 && ((1<<uint((_la-213)))&((1<<(Cobol85ParserFOREGROUND_COLOR-213))|(1<<(Cobol85ParserFOREGROUND_COLOUR-213))|(1<<(Cobol85ParserFULL-213))|(1<<(Cobol85ParserFUNCTIONNAME-213))|(1<<(Cobol85ParserFUNCTION_POINTER-213))|(1<<(Cobol85ParserGRID-213))|(1<<(Cobol85ParserHIGHLIGHT-213))|(1<<(Cobol85ParserIMPLICIT-213))|(1<<(Cobol85ParserIMPORT-213)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(Cobol85ParserINTEGER-250))|(1<<(Cobol85ParserKEPT-250))|(1<<(Cobol85ParserKEYBOARD-250))|(1<<(Cobol85ParserLANGUAGE-250))|(1<<(Cobol85ParserLB-250))|(1<<(Cobol85ParserLD-250))|(1<<(Cobol85ParserLEFTLINE-250))|(1<<(Cobol85ParserLENGTH_CHECK-250))|(1<<(Cobol85ParserLIBACCESS-250))|(1<<(Cobol85ParserLIBPARAMETER-250))|(1<<(Cobol85ParserLIBRARY-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(Cobol85ParserLIST-283))|(1<<(Cobol85ParserLOCAL-283))|(1<<(Cobol85ParserLONG_DATE-283))|(1<<(Cobol85ParserLONG_TIME-283))|(1<<(Cobol85ParserLOWER-283))|(1<<(Cobol85ParserLOWLIGHT-283))|(1<<(Cobol85ParserMMDDYYYY-283))|(1<<(Cobol85ParserNAMED-283))|(1<<(Cobol85ParserNATIONAL-283))|(1<<(Cobol85ParserNATIONAL_EDITED-283))|(1<<(Cobol85ParserNETWORK-283))|(1<<(Cobol85ParserNO_ECHO-283)))) != 0) || (((_la-317)&-(0x1f+1)) == 0 && ((1<<uint((_la-317)))&((1<<(Cobol85ParserNUMERIC_DATE-317))|(1<<(Cobol85ParserNUMERIC_TIME-317))|(1<<(Cobol85ParserODT-317))|(1<<(Cobol85ParserOFF-317))|(1<<(Cobol85ParserON-317))|(1<<(Cobol85ParserORDERLY-317))|(1<<(Cobol85ParserOVERLINE-317))|(1<<(Cobol85ParserOWN-317))|(1<<(Cobol85ParserPASSWORD-317)))) != 0) || (((_la-352)&-(0x1f+1)) == 0 && ((1<<uint((_la-352)))&((1<<(Cobol85ParserPORT-352))|(1<<(Cobol85ParserPRINTER-352))|(1<<(Cobol85ParserPRIVATE-352))|(1<<(Cobol85ParserPROCESS-352))|(1<<(Cobol85ParserPROGRAM-352))|(1<<(Cobol85ParserPROMPT-352))|(1<<(Cobol85ParserREADER-352))|(1<<(Cobol85ParserREMOTE-352))|(1<<(Cobol85ParserREAL-352))|(1<<(Cobol85ParserRECEIVED-352))|(1<<(Cobol85ParserRECURSIVE-352))|(1<<(Cobol85ParserREF-352)))) != 0) || (((_la-391)&-(0x1f+1)) == 0 && ((1<<uint((_la-391)))&((1<<(Cobol85ParserREMOVE-391))|(1<<(Cobol85ParserREQUIRED-391))|(1<<(Cobol85ParserRESERVE-391))|(1<<(Cobol85ParserREVERSE_VIDEO-391))|(1<<(Cobol85ParserSAVE-391))|(1<<(Cobol85ParserSECURE-391)))) != 0) || (((_la-431)&-(0x1f+1)) == 0 && ((1<<uint((_la-431)))&((1<<(Cobol85ParserSHARED-431))|(1<<(Cobol85ParserSHAREDBYALL-431))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-431))|(1<<(Cobol85ParserSHARING-431))|(1<<(Cobol85ParserSHORT_DATE-431)))) != 0) || (((_la-466)&-(0x1f+1)) == 0 && ((1<<uint((_la-466)))&((1<<(Cobol85ParserSYMBOL-466))|(1<<(Cobol85ParserSYMBOLIC-466))|(1<<(Cobol85ParserTASK-466))|(1<<(Cobol85ParserTHREAD-466))|(1<<(Cobol85ParserTHREAD_LOCAL-466))|(1<<(Cobol85ParserTIMER-466))|(1<<(Cobol85ParserTODAYS_DATE-466))|(1<<(Cobol85ParserTODAYS_NAME-466))|(1<<(Cobol85ParserTRUNCATED-466))|(1<<(Cobol85ParserTYPEDEF-466)))) != 0) || (((_la-498)&-(0x1f+1)) == 0 && ((1<<uint((_la-498)))&((1<<(Cobol85ParserUNDERLINE-498))|(1<<(Cobol85ParserVIRTUAL-498))|(1<<(Cobol85ParserWAIT-498))|(1<<(Cobol85ParserYEAR-498))|(1<<(Cobol85ParserYYYYMMDD-498))|(1<<(Cobol85ParserYYYYDDD-498))|(1<<(Cobol85ParserZERO_FILL-498)))) != 0) || _la == Cobol85ParserIDENTIFIER {
		p.SetState(1423)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserALPHABET)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH)|(1<<Cobol85ParserATTRIBUTE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBINARY-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33))|(1<<(Cobol85ParserCLASS-33)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-68))|(1<<(Cobol85ParserCOBOL-68))|(1<<(Cobol85ParserCOMMITMENT-68))|(1<<(Cobol85ParserCONTROL_POINT-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(Cobol85ParserCONVENTION-100))|(1<<(Cobol85ParserCRUNCH-100))|(1<<(Cobol85ParserCURRENCY-100))|(1<<(Cobol85ParserCURSOR-100))|(1<<(Cobol85ParserDECIMAL_POINT-100))|(1<<(Cobol85ParserDEFAULT-100))|(1<<(Cobol85ParserDEFAULT_DISPLAY-100))|(1<<(Cobol85ParserDEFINITION-100)))) != 0) || (((_la-138)&-(0x1f+1)) == 0 && ((1<<uint((_la-138)))&((1<<(Cobol85ParserDFHRESP-138))|(1<<(Cobol85ParserDFHVALUE-138))|(1<<(Cobol85ParserDISK-138))|(1<<(Cobol85ParserDONTCARE-138))|(1<<(Cobol85ParserDOUBLE-138))|(1<<(Cobol85ParserEBCDIC-138))|(1<<(Cobol85ParserEMPTY_CHECK-138)))) != 0) || (((_la-181)&-(0x1f+1)) == 0 && ((1<<uint((_la-181)))&((1<<(Cobol85ParserENTER-181))|(1<<(Cobol85ParserENTRY_PROCEDURE-181))|(1<<(Cobol85ParserERASE-181))|(1<<(Cobol85ParserEOL-181))|(1<<(Cobol85ParserEOS-181))|(1<<(Cobol85ParserESCAPE-181))|(1<<(Cobol85ParserEVENT-181))|(1<<(Cobol85ParserEXCLUSIVE-181))|(1<<(Cobol85ParserEXPORT-181))|(1<<(Cobol85ParserEXTENDED-181)))) != 0) || (((_la-213)&-(0x1f+1)) == 0 && ((1<<uint((_la-213)))&((1<<(Cobol85ParserFOREGROUND_COLOR-213))|(1<<(Cobol85ParserFOREGROUND_COLOUR-213))|(1<<(Cobol85ParserFULL-213))|(1<<(Cobol85ParserFUNCTIONNAME-213))|(1<<(Cobol85ParserFUNCTION_POINTER-213))|(1<<(Cobol85ParserGRID-213))|(1<<(Cobol85ParserHIGHLIGHT-213))|(1<<(Cobol85ParserIMPLICIT-213))|(1<<(Cobol85ParserIMPORT-213)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(Cobol85ParserINTEGER-250))|(1<<(Cobol85ParserKEPT-250))|(1<<(Cobol85ParserKEYBOARD-250))|(1<<(Cobol85ParserLANGUAGE-250))|(1<<(Cobol85ParserLB-250))|(1<<(Cobol85ParserLD-250))|(1<<(Cobol85ParserLEFTLINE-250))|(1<<(Cobol85ParserLENGTH_CHECK-250))|(1<<(Cobol85ParserLIBACCESS-250))|(1<<(Cobol85ParserLIBPARAMETER-250))|(1<<(Cobol85ParserLIBRARY-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(Cobol85ParserLIST-283))|(1<<(Cobol85ParserLOCAL-283))|(1<<(Cobol85ParserLONG_DATE-283))|(1<<(Cobol85ParserLONG_TIME-283))|(1<<(Cobol85ParserLOWER-283))|(1<<(Cobol85ParserLOWLIGHT-283))|(1<<(Cobol85ParserMMDDYYYY-283))|(1<<(Cobol85ParserNAMED-283))|(1<<(Cobol85ParserNATIONAL-283))|(1<<(Cobol85ParserNATIONAL_EDITED-283))|(1<<(Cobol85ParserNETWORK-283))|(1<<(Cobol85ParserNO_ECHO-283)))) != 0) || (((_la-317)&-(0x1f+1)) == 0 && ((1<<uint((_la-317)))&((1<<(Cobol85ParserNUMERIC_DATE-317))|(1<<(Cobol85ParserNUMERIC_TIME-317))|(1<<(Cobol85ParserODT-317))|(1<<(Cobol85ParserOFF-317))|(1<<(Cobol85ParserON-317))|(1<<(Cobol85ParserORDERLY-317))|(1<<(Cobol85ParserOVERLINE-317))|(1<<(Cobol85ParserOWN-317))|(1<<(Cobol85ParserPASSWORD-317)))) != 0) || (((_la-352)&-(0x1f+1)) == 0 && ((1<<uint((_la-352)))&((1<<(Cobol85ParserPORT-352))|(1<<(Cobol85ParserPRINTER-352))|(1<<(Cobol85ParserPRIVATE-352))|(1<<(Cobol85ParserPROCESS-352))|(1<<(Cobol85ParserPROGRAM-352))|(1<<(Cobol85ParserPROMPT-352))|(1<<(Cobol85ParserREADER-352))|(1<<(Cobol85ParserREMOTE-352))|(1<<(Cobol85ParserREAL-352))|(1<<(Cobol85ParserRECEIVED-352))|(1<<(Cobol85ParserRECURSIVE-352))|(1<<(Cobol85ParserREF-352)))) != 0) || (((_la-391)&-(0x1f+1)) == 0 && ((1<<uint((_la-391)))&((1<<(Cobol85ParserREMOVE-391))|(1<<(Cobol85ParserREQUIRED-391))|(1<<(Cobol85ParserRESERVE-391))|(1<<(Cobol85ParserREVERSE_VIDEO-391))|(1<<(Cobol85ParserSAVE-391))|(1<<(Cobol85ParserSECURE-391)))) != 0) || (((_la-431)&-(0x1f+1)) == 0 && ((1<<uint((_la-431)))&((1<<(Cobol85ParserSHARED-431))|(1<<(Cobol85ParserSHAREDBYALL-431))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-431))|(1<<(Cobol85ParserSHARING-431))|(1<<(Cobol85ParserSHORT_DATE-431)))) != 0) || (((_la-466)&-(0x1f+1)) == 0 && ((1<<uint((_la-466)))&((1<<(Cobol85ParserSYMBOL-466))|(1<<(Cobol85ParserSYMBOLIC-466))|(1<<(Cobol85ParserTASK-466))|(1<<(Cobol85ParserTHREAD-466))|(1<<(Cobol85ParserTHREAD_LOCAL-466))|(1<<(Cobol85ParserTIMER-466))|(1<<(Cobol85ParserTODAYS_DATE-466))|(1<<(Cobol85ParserTODAYS_NAME-466))|(1<<(Cobol85ParserTRUNCATED-466))|(1<<(Cobol85ParserTYPEDEF-466)))) != 0) || (((_la-498)&-(0x1f+1)) == 0 && ((1<<uint((_la-498)))&((1<<(Cobol85ParserUNDERLINE-498))|(1<<(Cobol85ParserVIRTUAL-498))|(1<<(Cobol85ParserWAIT-498))|(1<<(Cobol85ParserYEAR-498))|(1<<(Cobol85ParserYYYYMMDD-498))|(1<<(Cobol85ParserYYYYDDD-498))|(1<<(Cobol85ParserZERO_FILL-498)))) != 0) || _la == Cobol85ParserIDENTIFIER {
			{
				p.SetState(1422)
				p.SpecialNameClause()
			}

			p.SetState(1425)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1427)
			p.Match(Cobol85ParserDOT_FS)
		}

	}

	return localctx
}

// ISpecialNameClauseContext is an interface to support dynamic dispatch.
type ISpecialNameClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSpecialNameClauseContext differentiates from other interfaces.
	IsSpecialNameClauseContext()
}

type SpecialNameClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpecialNameClauseContext() *SpecialNameClauseContext {
	var p = new(SpecialNameClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_specialNameClause
	return p
}

func (*SpecialNameClauseContext) IsSpecialNameClauseContext() {}

func NewSpecialNameClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SpecialNameClauseContext {
	var p = new(SpecialNameClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_specialNameClause

	return p
}

func (s *SpecialNameClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SpecialNameClauseContext) ChannelClause() IChannelClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IChannelClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IChannelClauseContext)
}

func (s *SpecialNameClauseContext) OdtClause() IOdtClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOdtClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOdtClauseContext)
}

func (s *SpecialNameClauseContext) AlphabetClause() IAlphabetClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlphabetClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlphabetClauseContext)
}

func (s *SpecialNameClauseContext) ClassClause() IClassClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassClauseContext)
}

func (s *SpecialNameClauseContext) CurrencySignClause() ICurrencySignClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICurrencySignClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICurrencySignClauseContext)
}

func (s *SpecialNameClauseContext) DecimalPointClause() IDecimalPointClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDecimalPointClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDecimalPointClauseContext)
}

func (s *SpecialNameClauseContext) SymbolicCharactersClause() ISymbolicCharactersClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolicCharactersClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISymbolicCharactersClauseContext)
}

func (s *SpecialNameClauseContext) EnvironmentSwitchNameClause() IEnvironmentSwitchNameClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnvironmentSwitchNameClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnvironmentSwitchNameClauseContext)
}

func (s *SpecialNameClauseContext) DefaultDisplaySignClause() IDefaultDisplaySignClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefaultDisplaySignClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefaultDisplaySignClauseContext)
}

func (s *SpecialNameClauseContext) DefaultComputationalSignClause() IDefaultComputationalSignClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefaultComputationalSignClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefaultComputationalSignClauseContext)
}

func (s *SpecialNameClauseContext) ReserveNetworkClause() IReserveNetworkClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReserveNetworkClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReserveNetworkClauseContext)
}

func (s *SpecialNameClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpecialNameClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SpecialNameClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSpecialNameClause(s)
	}
}

func (s *SpecialNameClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSpecialNameClause(s)
	}
}

func (p *Cobol85Parser) SpecialNameClause() (localctx ISpecialNameClauseContext) {
	localctx = NewSpecialNameClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, Cobol85ParserRULE_specialNameClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1442)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 47, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1431)
			p.ChannelClause()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1432)
			p.OdtClause()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1433)
			p.AlphabetClause()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1434)
			p.ClassClause()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1435)
			p.CurrencySignClause()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1436)
			p.DecimalPointClause()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1437)
			p.SymbolicCharactersClause()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1438)
			p.EnvironmentSwitchNameClause()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1439)
			p.DefaultDisplaySignClause()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1440)
			p.DefaultComputationalSignClause()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1441)
			p.ReserveNetworkClause()
		}

	}

	return localctx
}

// IAlphabetClauseContext is an interface to support dynamic dispatch.
type IAlphabetClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlphabetClauseContext differentiates from other interfaces.
	IsAlphabetClauseContext()
}

type AlphabetClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlphabetClauseContext() *AlphabetClauseContext {
	var p = new(AlphabetClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_alphabetClause
	return p
}

func (*AlphabetClauseContext) IsAlphabetClauseContext() {}

func NewAlphabetClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlphabetClauseContext {
	var p = new(AlphabetClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_alphabetClause

	return p
}

func (s *AlphabetClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AlphabetClauseContext) AlphabetClauseFormat1() IAlphabetClauseFormat1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlphabetClauseFormat1Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlphabetClauseFormat1Context)
}

func (s *AlphabetClauseContext) AlphabetClauseFormat2() IAlphabetClauseFormat2Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlphabetClauseFormat2Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlphabetClauseFormat2Context)
}

func (s *AlphabetClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlphabetClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlphabetClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAlphabetClause(s)
	}
}

func (s *AlphabetClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAlphabetClause(s)
	}
}

func (p *Cobol85Parser) AlphabetClause() (localctx IAlphabetClauseContext) {
	localctx = NewAlphabetClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, Cobol85ParserRULE_alphabetClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1446)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 48, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1444)
			p.AlphabetClauseFormat1()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1445)
			p.AlphabetClauseFormat2()
		}

	}

	return localctx
}

// IAlphabetClauseFormat1Context is an interface to support dynamic dispatch.
type IAlphabetClauseFormat1Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlphabetClauseFormat1Context differentiates from other interfaces.
	IsAlphabetClauseFormat1Context()
}

type AlphabetClauseFormat1Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlphabetClauseFormat1Context() *AlphabetClauseFormat1Context {
	var p = new(AlphabetClauseFormat1Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_alphabetClauseFormat1
	return p
}

func (*AlphabetClauseFormat1Context) IsAlphabetClauseFormat1Context() {}

func NewAlphabetClauseFormat1Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlphabetClauseFormat1Context {
	var p = new(AlphabetClauseFormat1Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_alphabetClauseFormat1

	return p
}

func (s *AlphabetClauseFormat1Context) GetParser() antlr.Parser { return s.parser }

func (s *AlphabetClauseFormat1Context) ALPHABET() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALPHABET, 0)
}

func (s *AlphabetClauseFormat1Context) AlphabetName() IAlphabetNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlphabetNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlphabetNameContext)
}

func (s *AlphabetClauseFormat1Context) EBCDIC() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEBCDIC, 0)
}

func (s *AlphabetClauseFormat1Context) ASCII() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserASCII, 0)
}

func (s *AlphabetClauseFormat1Context) STANDARD_1() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSTANDARD_1, 0)
}

func (s *AlphabetClauseFormat1Context) STANDARD_2() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSTANDARD_2, 0)
}

func (s *AlphabetClauseFormat1Context) NATIVE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNATIVE, 0)
}

func (s *AlphabetClauseFormat1Context) CobolWord() ICobolWordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICobolWordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *AlphabetClauseFormat1Context) FOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOR, 0)
}

func (s *AlphabetClauseFormat1Context) ALPHANUMERIC() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALPHANUMERIC, 0)
}

func (s *AlphabetClauseFormat1Context) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *AlphabetClauseFormat1Context) AllAlphabetLiterals() []IAlphabetLiteralsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAlphabetLiteralsContext)(nil)).Elem())
	var tst = make([]IAlphabetLiteralsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAlphabetLiteralsContext)
		}
	}

	return tst
}

func (s *AlphabetClauseFormat1Context) AlphabetLiterals(i int) IAlphabetLiteralsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlphabetLiteralsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAlphabetLiteralsContext)
}

func (s *AlphabetClauseFormat1Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlphabetClauseFormat1Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlphabetClauseFormat1Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAlphabetClauseFormat1(s)
	}
}

func (s *AlphabetClauseFormat1Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAlphabetClauseFormat1(s)
	}
}

func (p *Cobol85Parser) AlphabetClauseFormat1() (localctx IAlphabetClauseFormat1Context) {
	localctx = NewAlphabetClauseFormat1Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, Cobol85ParserRULE_alphabetClauseFormat1)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1448)
		p.Match(Cobol85ParserALPHABET)
	}
	{
		p.SetState(1449)
		p.AlphabetName()
	}
	p.SetState(1452)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFOR {
		{
			p.SetState(1450)
			p.Match(Cobol85ParserFOR)
		}
		{
			p.SetState(1451)
			p.Match(Cobol85ParserALPHANUMERIC)
		}

	}
	p.SetState(1455)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(1454)
			p.Match(Cobol85ParserIS)
		}

	}
	p.SetState(1468)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 52, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1457)
			p.Match(Cobol85ParserEBCDIC)
		}

	case 2:
		{
			p.SetState(1458)
			p.Match(Cobol85ParserASCII)
		}

	case 3:
		{
			p.SetState(1459)
			p.Match(Cobol85ParserSTANDARD_1)
		}

	case 4:
		{
			p.SetState(1460)
			p.Match(Cobol85ParserSTANDARD_2)
		}

	case 5:
		{
			p.SetState(1461)
			p.Match(Cobol85ParserNATIVE)
		}

	case 6:
		{
			p.SetState(1462)
			p.CobolWord()
		}

	case 7:
		p.SetState(1464)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(1463)
					p.AlphabetLiterals()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(1466)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 51, p.GetParserRuleContext())
		}

	}

	return localctx
}

// IAlphabetLiteralsContext is an interface to support dynamic dispatch.
type IAlphabetLiteralsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlphabetLiteralsContext differentiates from other interfaces.
	IsAlphabetLiteralsContext()
}

type AlphabetLiteralsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlphabetLiteralsContext() *AlphabetLiteralsContext {
	var p = new(AlphabetLiteralsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_alphabetLiterals
	return p
}

func (*AlphabetLiteralsContext) IsAlphabetLiteralsContext() {}

func NewAlphabetLiteralsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlphabetLiteralsContext {
	var p = new(AlphabetLiteralsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_alphabetLiterals

	return p
}

func (s *AlphabetLiteralsContext) GetParser() antlr.Parser { return s.parser }

func (s *AlphabetLiteralsContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *AlphabetLiteralsContext) AlphabetThrough() IAlphabetThroughContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlphabetThroughContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlphabetThroughContext)
}

func (s *AlphabetLiteralsContext) AllAlphabetAlso() []IAlphabetAlsoContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAlphabetAlsoContext)(nil)).Elem())
	var tst = make([]IAlphabetAlsoContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAlphabetAlsoContext)
		}
	}

	return tst
}

func (s *AlphabetLiteralsContext) AlphabetAlso(i int) IAlphabetAlsoContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlphabetAlsoContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAlphabetAlsoContext)
}

func (s *AlphabetLiteralsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlphabetLiteralsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlphabetLiteralsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAlphabetLiterals(s)
	}
}

func (s *AlphabetLiteralsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAlphabetLiterals(s)
	}
}

func (p *Cobol85Parser) AlphabetLiterals() (localctx IAlphabetLiteralsContext) {
	localctx = NewAlphabetLiteralsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, Cobol85ParserRULE_alphabetLiterals)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1470)
		p.Literal()
	}
	p.SetState(1477)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserTHROUGH, Cobol85ParserTHRU:
		{
			p.SetState(1471)
			p.AlphabetThrough()
		}

	case Cobol85ParserALSO:
		p.SetState(1473)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == Cobol85ParserALSO {
			{
				p.SetState(1472)
				p.AlphabetAlso()
			}

			p.SetState(1475)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case Cobol85ParserABORT, Cobol85ParserALL, Cobol85ParserALPHABET, Cobol85ParserAS, Cobol85ParserASCII, Cobol85ParserASSOCIATED_DATA, Cobol85ParserASSOCIATED_DATA_LENGTH, Cobol85ParserATTRIBUTE, Cobol85ParserAUTO, Cobol85ParserAUTO_SKIP, Cobol85ParserBACKGROUND_COLOR, Cobol85ParserBACKGROUND_COLOUR, Cobol85ParserBEEP, Cobol85ParserBELL, Cobol85ParserBINARY, Cobol85ParserBIT, Cobol85ParserBLINK, Cobol85ParserBOUNDS, Cobol85ParserCAPABLE, Cobol85ParserCCSVERSION, Cobol85ParserCHANGED, Cobol85ParserCHANNEL, Cobol85ParserCLASS, Cobol85ParserCLOSE_DISPOSITION, Cobol85ParserCOBOL, Cobol85ParserCOMMITMENT, Cobol85ParserCONTROL_POINT, Cobol85ParserCONVENTION, Cobol85ParserCRUNCH, Cobol85ParserCURRENCY, Cobol85ParserCURSOR, Cobol85ParserDECIMAL_POINT, Cobol85ParserDEFAULT, Cobol85ParserDEFAULT_DISPLAY, Cobol85ParserDEFINITION, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserDISK, Cobol85ParserDONTCARE, Cobol85ParserDOUBLE, Cobol85ParserEBCDIC, Cobol85ParserEMPTY_CHECK, Cobol85ParserENTER, Cobol85ParserENTRY_PROCEDURE, Cobol85ParserERASE, Cobol85ParserEOL, Cobol85ParserEOS, Cobol85ParserESCAPE, Cobol85ParserEVENT, Cobol85ParserEXCLUSIVE, Cobol85ParserEXPORT, Cobol85ParserEXTENDED, Cobol85ParserFALSE, Cobol85ParserFOREGROUND_COLOR, Cobol85ParserFOREGROUND_COLOUR, Cobol85ParserFULL, Cobol85ParserFUNCTIONNAME, Cobol85ParserFUNCTION_POINTER, Cobol85ParserGRID, Cobol85ParserHIGHLIGHT, Cobol85ParserHIGH_VALUE, Cobol85ParserHIGH_VALUES, Cobol85ParserIMPLICIT, Cobol85ParserIMPORT, Cobol85ParserINTEGER, Cobol85ParserKEPT, Cobol85ParserKEYBOARD, Cobol85ParserLANGUAGE, Cobol85ParserLB, Cobol85ParserLD, Cobol85ParserLEFTLINE, Cobol85ParserLENGTH_CHECK, Cobol85ParserLIBACCESS, Cobol85ParserLIBPARAMETER, Cobol85ParserLIBRARY, Cobol85ParserLIST, Cobol85ParserLOCAL, Cobol85ParserLONG_DATE, Cobol85ParserLONG_TIME, Cobol85ParserLOWER, Cobol85ParserLOWLIGHT, Cobol85ParserLOW_VALUE, Cobol85ParserLOW_VALUES, Cobol85ParserMMDDYYYY, Cobol85ParserNAMED, Cobol85ParserNATIONAL, Cobol85ParserNATIONAL_EDITED, Cobol85ParserNETWORK, Cobol85ParserNO_ECHO, Cobol85ParserNULL, Cobol85ParserNULLS, Cobol85ParserNUMERIC_DATE, Cobol85ParserNUMERIC_TIME, Cobol85ParserODT, Cobol85ParserOFF, Cobol85ParserON, Cobol85ParserORDERLY, Cobol85ParserOVERLINE, Cobol85ParserOWN, Cobol85ParserPASSWORD, Cobol85ParserPORT, Cobol85ParserPRINTER, Cobol85ParserPRIVATE, Cobol85ParserPROCESS, Cobol85ParserPROGRAM, Cobol85ParserPROMPT, Cobol85ParserQUOTE, Cobol85ParserQUOTES, Cobol85ParserREADER, Cobol85ParserREMOTE, Cobol85ParserREAL, Cobol85ParserRECEIVED, Cobol85ParserRECURSIVE, Cobol85ParserREF, Cobol85ParserREMOVE, Cobol85ParserREQUIRED, Cobol85ParserRESERVE, Cobol85ParserREVERSE_VIDEO, Cobol85ParserSAVE, Cobol85ParserSECURE, Cobol85ParserSHARED, Cobol85ParserSHAREDBYALL, Cobol85ParserSHAREDBYRUNUNIT, Cobol85ParserSHARING, Cobol85ParserSHORT_DATE, Cobol85ParserSPACE, Cobol85ParserSPACES, Cobol85ParserSYMBOL, Cobol85ParserSYMBOLIC, Cobol85ParserTASK, Cobol85ParserTHREAD, Cobol85ParserTHREAD_LOCAL, Cobol85ParserTIMER, Cobol85ParserTODAYS_DATE, Cobol85ParserTODAYS_NAME, Cobol85ParserTRUE, Cobol85ParserTRUNCATED, Cobol85ParserTYPEDEF, Cobol85ParserUNDERLINE, Cobol85ParserVIRTUAL, Cobol85ParserWAIT, Cobol85ParserYEAR, Cobol85ParserYYYYMMDD, Cobol85ParserYYYYDDD, Cobol85ParserZERO, Cobol85ParserZERO_FILL, Cobol85ParserZEROS, Cobol85ParserZEROES, Cobol85ParserDOT_FS, Cobol85ParserNONNUMERICLITERAL, Cobol85ParserLEVEL_NUMBER_66, Cobol85ParserLEVEL_NUMBER_77, Cobol85ParserLEVEL_NUMBER_88, Cobol85ParserINTEGERLITERAL, Cobol85ParserNUMERICLITERAL, Cobol85ParserIDENTIFIER:

	default:
	}

	return localctx
}

// IAlphabetThroughContext is an interface to support dynamic dispatch.
type IAlphabetThroughContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlphabetThroughContext differentiates from other interfaces.
	IsAlphabetThroughContext()
}

type AlphabetThroughContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlphabetThroughContext() *AlphabetThroughContext {
	var p = new(AlphabetThroughContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_alphabetThrough
	return p
}

func (*AlphabetThroughContext) IsAlphabetThroughContext() {}

func NewAlphabetThroughContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlphabetThroughContext {
	var p = new(AlphabetThroughContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_alphabetThrough

	return p
}

func (s *AlphabetThroughContext) GetParser() antlr.Parser { return s.parser }

func (s *AlphabetThroughContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *AlphabetThroughContext) THROUGH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHROUGH, 0)
}

func (s *AlphabetThroughContext) THRU() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHRU, 0)
}

func (s *AlphabetThroughContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlphabetThroughContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlphabetThroughContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAlphabetThrough(s)
	}
}

func (s *AlphabetThroughContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAlphabetThrough(s)
	}
}

func (p *Cobol85Parser) AlphabetThrough() (localctx IAlphabetThroughContext) {
	localctx = NewAlphabetThroughContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, Cobol85ParserRULE_alphabetThrough)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1479)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserTHROUGH || _la == Cobol85ParserTHRU) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1480)
		p.Literal()
	}

	return localctx
}

// IAlphabetAlsoContext is an interface to support dynamic dispatch.
type IAlphabetAlsoContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlphabetAlsoContext differentiates from other interfaces.
	IsAlphabetAlsoContext()
}

type AlphabetAlsoContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlphabetAlsoContext() *AlphabetAlsoContext {
	var p = new(AlphabetAlsoContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_alphabetAlso
	return p
}

func (*AlphabetAlsoContext) IsAlphabetAlsoContext() {}

func NewAlphabetAlsoContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlphabetAlsoContext {
	var p = new(AlphabetAlsoContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_alphabetAlso

	return p
}

func (s *AlphabetAlsoContext) GetParser() antlr.Parser { return s.parser }

func (s *AlphabetAlsoContext) ALSO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALSO, 0)
}

func (s *AlphabetAlsoContext) AllLiteral() []ILiteralContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILiteralContext)(nil)).Elem())
	var tst = make([]ILiteralContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILiteralContext)
		}
	}

	return tst
}

func (s *AlphabetAlsoContext) Literal(i int) ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *AlphabetAlsoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlphabetAlsoContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlphabetAlsoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAlphabetAlso(s)
	}
}

func (s *AlphabetAlsoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAlphabetAlso(s)
	}
}

func (p *Cobol85Parser) AlphabetAlso() (localctx IAlphabetAlsoContext) {
	localctx = NewAlphabetAlsoContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, Cobol85ParserRULE_alphabetAlso)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1482)
		p.Match(Cobol85ParserALSO)
	}
	p.SetState(1484)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1483)
				p.Literal()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(1486)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 55, p.GetParserRuleContext())
	}

	return localctx
}

// IAlphabetClauseFormat2Context is an interface to support dynamic dispatch.
type IAlphabetClauseFormat2Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlphabetClauseFormat2Context differentiates from other interfaces.
	IsAlphabetClauseFormat2Context()
}

type AlphabetClauseFormat2Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlphabetClauseFormat2Context() *AlphabetClauseFormat2Context {
	var p = new(AlphabetClauseFormat2Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_alphabetClauseFormat2
	return p
}

func (*AlphabetClauseFormat2Context) IsAlphabetClauseFormat2Context() {}

func NewAlphabetClauseFormat2Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlphabetClauseFormat2Context {
	var p = new(AlphabetClauseFormat2Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_alphabetClauseFormat2

	return p
}

func (s *AlphabetClauseFormat2Context) GetParser() antlr.Parser { return s.parser }

func (s *AlphabetClauseFormat2Context) ALPHABET() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALPHABET, 0)
}

func (s *AlphabetClauseFormat2Context) AlphabetName() IAlphabetNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlphabetNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlphabetNameContext)
}

func (s *AlphabetClauseFormat2Context) NATIONAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNATIONAL, 0)
}

func (s *AlphabetClauseFormat2Context) NATIVE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNATIVE, 0)
}

func (s *AlphabetClauseFormat2Context) CCSVERSION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCCSVERSION, 0)
}

func (s *AlphabetClauseFormat2Context) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *AlphabetClauseFormat2Context) FOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOR, 0)
}

func (s *AlphabetClauseFormat2Context) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *AlphabetClauseFormat2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlphabetClauseFormat2Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlphabetClauseFormat2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAlphabetClauseFormat2(s)
	}
}

func (s *AlphabetClauseFormat2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAlphabetClauseFormat2(s)
	}
}

func (p *Cobol85Parser) AlphabetClauseFormat2() (localctx IAlphabetClauseFormat2Context) {
	localctx = NewAlphabetClauseFormat2Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, Cobol85ParserRULE_alphabetClauseFormat2)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1488)
		p.Match(Cobol85ParserALPHABET)
	}
	{
		p.SetState(1489)
		p.AlphabetName()
	}
	p.SetState(1491)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFOR {
		{
			p.SetState(1490)
			p.Match(Cobol85ParserFOR)
		}

	}
	{
		p.SetState(1493)
		p.Match(Cobol85ParserNATIONAL)
	}
	p.SetState(1495)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(1494)
			p.Match(Cobol85ParserIS)
		}

	}
	p.SetState(1500)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserNATIVE:
		{
			p.SetState(1497)
			p.Match(Cobol85ParserNATIVE)
		}

	case Cobol85ParserCCSVERSION:
		{
			p.SetState(1498)
			p.Match(Cobol85ParserCCSVERSION)
		}
		{
			p.SetState(1499)
			p.Literal()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IChannelClauseContext is an interface to support dynamic dispatch.
type IChannelClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsChannelClauseContext differentiates from other interfaces.
	IsChannelClauseContext()
}

type ChannelClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChannelClauseContext() *ChannelClauseContext {
	var p = new(ChannelClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_channelClause
	return p
}

func (*ChannelClauseContext) IsChannelClauseContext() {}

func NewChannelClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ChannelClauseContext {
	var p = new(ChannelClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_channelClause

	return p
}

func (s *ChannelClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ChannelClauseContext) CHANNEL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCHANNEL, 0)
}

func (s *ChannelClauseContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ChannelClauseContext) MnemonicName() IMnemonicNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMnemonicNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMnemonicNameContext)
}

func (s *ChannelClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ChannelClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ChannelClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ChannelClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterChannelClause(s)
	}
}

func (s *ChannelClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitChannelClause(s)
	}
}

func (p *Cobol85Parser) ChannelClause() (localctx IChannelClauseContext) {
	localctx = NewChannelClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, Cobol85ParserRULE_channelClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1502)
		p.Match(Cobol85ParserCHANNEL)
	}
	{
		p.SetState(1503)
		p.IntegerLiteral()
	}
	p.SetState(1505)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(1504)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(1507)
		p.MnemonicName()
	}

	return localctx
}

// IClassClauseContext is an interface to support dynamic dispatch.
type IClassClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassClauseContext differentiates from other interfaces.
	IsClassClauseContext()
}

type ClassClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassClauseContext() *ClassClauseContext {
	var p = new(ClassClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_classClause
	return p
}

func (*ClassClauseContext) IsClassClauseContext() {}

func NewClassClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassClauseContext {
	var p = new(ClassClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_classClause

	return p
}

func (s *ClassClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassClauseContext) CLASS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCLASS, 0)
}

func (s *ClassClauseContext) ClassName() IClassNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassNameContext)
}

func (s *ClassClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ClassClauseContext) AllClassClauseThrough() []IClassClauseThroughContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IClassClauseThroughContext)(nil)).Elem())
	var tst = make([]IClassClauseThroughContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IClassClauseThroughContext)
		}
	}

	return tst
}

func (s *ClassClauseContext) ClassClauseThrough(i int) IClassClauseThroughContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassClauseThroughContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IClassClauseThroughContext)
}

func (s *ClassClauseContext) ALPHANUMERIC() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALPHANUMERIC, 0)
}

func (s *ClassClauseContext) NATIONAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNATIONAL, 0)
}

func (s *ClassClauseContext) FOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOR, 0)
}

func (s *ClassClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterClassClause(s)
	}
}

func (s *ClassClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitClassClause(s)
	}
}

func (p *Cobol85Parser) ClassClause() (localctx IClassClauseContext) {
	localctx = NewClassClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, Cobol85ParserRULE_classClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1509)
		p.Match(Cobol85ParserCLASS)
	}
	{
		p.SetState(1510)
		p.ClassName()
	}
	p.SetState(1515)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 61, p.GetParserRuleContext()) == 1 {
		p.SetState(1512)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserFOR {
			{
				p.SetState(1511)
				p.Match(Cobol85ParserFOR)
			}

		}
		{
			p.SetState(1514)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85ParserALPHANUMERIC || _la == Cobol85ParserNATIONAL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(1518)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(1517)
			p.Match(Cobol85ParserIS)
		}

	}
	p.SetState(1521)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1520)
				p.ClassClauseThrough()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(1523)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 63, p.GetParserRuleContext())
	}

	return localctx
}

// IClassClauseThroughContext is an interface to support dynamic dispatch.
type IClassClauseThroughContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassClauseThroughContext differentiates from other interfaces.
	IsClassClauseThroughContext()
}

type ClassClauseThroughContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassClauseThroughContext() *ClassClauseThroughContext {
	var p = new(ClassClauseThroughContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_classClauseThrough
	return p
}

func (*ClassClauseThroughContext) IsClassClauseThroughContext() {}

func NewClassClauseThroughContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassClauseThroughContext {
	var p = new(ClassClauseThroughContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_classClauseThrough

	return p
}

func (s *ClassClauseThroughContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassClauseThroughContext) ClassClauseFrom() IClassClauseFromContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassClauseFromContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassClauseFromContext)
}

func (s *ClassClauseThroughContext) ClassClauseTo() IClassClauseToContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassClauseToContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassClauseToContext)
}

func (s *ClassClauseThroughContext) THROUGH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHROUGH, 0)
}

func (s *ClassClauseThroughContext) THRU() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHRU, 0)
}

func (s *ClassClauseThroughContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassClauseThroughContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassClauseThroughContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterClassClauseThrough(s)
	}
}

func (s *ClassClauseThroughContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitClassClauseThrough(s)
	}
}

func (p *Cobol85Parser) ClassClauseThrough() (localctx IClassClauseThroughContext) {
	localctx = NewClassClauseThroughContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, Cobol85ParserRULE_classClauseThrough)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1525)
		p.ClassClauseFrom()
	}
	p.SetState(1528)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserTHROUGH || _la == Cobol85ParserTHRU {
		{
			p.SetState(1526)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85ParserTHROUGH || _la == Cobol85ParserTHRU) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1527)
			p.ClassClauseTo()
		}

	}

	return localctx
}

// IClassClauseFromContext is an interface to support dynamic dispatch.
type IClassClauseFromContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassClauseFromContext differentiates from other interfaces.
	IsClassClauseFromContext()
}

type ClassClauseFromContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassClauseFromContext() *ClassClauseFromContext {
	var p = new(ClassClauseFromContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_classClauseFrom
	return p
}

func (*ClassClauseFromContext) IsClassClauseFromContext() {}

func NewClassClauseFromContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassClauseFromContext {
	var p = new(ClassClauseFromContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_classClauseFrom

	return p
}

func (s *ClassClauseFromContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassClauseFromContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ClassClauseFromContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *ClassClauseFromContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassClauseFromContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassClauseFromContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterClassClauseFrom(s)
	}
}

func (s *ClassClauseFromContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitClassClauseFrom(s)
	}
}

func (p *Cobol85Parser) ClassClauseFrom() (localctx IClassClauseFromContext) {
	localctx = NewClassClauseFromContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, Cobol85ParserRULE_classClauseFrom)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1532)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 65, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1530)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1531)
			p.Literal()
		}

	}

	return localctx
}

// IClassClauseToContext is an interface to support dynamic dispatch.
type IClassClauseToContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassClauseToContext differentiates from other interfaces.
	IsClassClauseToContext()
}

type ClassClauseToContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassClauseToContext() *ClassClauseToContext {
	var p = new(ClassClauseToContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_classClauseTo
	return p
}

func (*ClassClauseToContext) IsClassClauseToContext() {}

func NewClassClauseToContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassClauseToContext {
	var p = new(ClassClauseToContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_classClauseTo

	return p
}

func (s *ClassClauseToContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassClauseToContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ClassClauseToContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *ClassClauseToContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassClauseToContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassClauseToContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterClassClauseTo(s)
	}
}

func (s *ClassClauseToContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitClassClauseTo(s)
	}
}

func (p *Cobol85Parser) ClassClauseTo() (localctx IClassClauseToContext) {
	localctx = NewClassClauseToContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, Cobol85ParserRULE_classClauseTo)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1536)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 66, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1534)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1535)
			p.Literal()
		}

	}

	return localctx
}

// ICurrencySignClauseContext is an interface to support dynamic dispatch.
type ICurrencySignClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCurrencySignClauseContext differentiates from other interfaces.
	IsCurrencySignClauseContext()
}

type CurrencySignClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCurrencySignClauseContext() *CurrencySignClauseContext {
	var p = new(CurrencySignClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_currencySignClause
	return p
}

func (*CurrencySignClauseContext) IsCurrencySignClauseContext() {}

func NewCurrencySignClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CurrencySignClauseContext {
	var p = new(CurrencySignClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_currencySignClause

	return p
}

func (s *CurrencySignClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CurrencySignClauseContext) CURRENCY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCURRENCY, 0)
}

func (s *CurrencySignClauseContext) AllLiteral() []ILiteralContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILiteralContext)(nil)).Elem())
	var tst = make([]ILiteralContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILiteralContext)
		}
	}

	return tst
}

func (s *CurrencySignClauseContext) Literal(i int) ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *CurrencySignClauseContext) SIGN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSIGN, 0)
}

func (s *CurrencySignClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *CurrencySignClauseContext) PICTURE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPICTURE, 0)
}

func (s *CurrencySignClauseContext) SYMBOL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSYMBOL, 0)
}

func (s *CurrencySignClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWITH, 0)
}

func (s *CurrencySignClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CurrencySignClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CurrencySignClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCurrencySignClause(s)
	}
}

func (s *CurrencySignClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCurrencySignClause(s)
	}
}

func (p *Cobol85Parser) CurrencySignClause() (localctx ICurrencySignClauseContext) {
	localctx = NewCurrencySignClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, Cobol85ParserRULE_currencySignClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1538)
		p.Match(Cobol85ParserCURRENCY)
	}
	p.SetState(1540)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserSIGN {
		{
			p.SetState(1539)
			p.Match(Cobol85ParserSIGN)
		}

	}
	p.SetState(1543)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(1542)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(1545)
		p.Literal()
	}
	p.SetState(1552)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserPICTURE || _la == Cobol85ParserWITH {
		p.SetState(1547)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserWITH {
			{
				p.SetState(1546)
				p.Match(Cobol85ParserWITH)
			}

		}
		{
			p.SetState(1549)
			p.Match(Cobol85ParserPICTURE)
		}
		{
			p.SetState(1550)
			p.Match(Cobol85ParserSYMBOL)
		}
		{
			p.SetState(1551)
			p.Literal()
		}

	}

	return localctx
}

// IDecimalPointClauseContext is an interface to support dynamic dispatch.
type IDecimalPointClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDecimalPointClauseContext differentiates from other interfaces.
	IsDecimalPointClauseContext()
}

type DecimalPointClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDecimalPointClauseContext() *DecimalPointClauseContext {
	var p = new(DecimalPointClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_decimalPointClause
	return p
}

func (*DecimalPointClauseContext) IsDecimalPointClauseContext() {}

func NewDecimalPointClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DecimalPointClauseContext {
	var p = new(DecimalPointClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_decimalPointClause

	return p
}

func (s *DecimalPointClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DecimalPointClauseContext) DECIMAL_POINT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDECIMAL_POINT, 0)
}

func (s *DecimalPointClauseContext) COMMA() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMMA, 0)
}

func (s *DecimalPointClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *DecimalPointClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecimalPointClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DecimalPointClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDecimalPointClause(s)
	}
}

func (s *DecimalPointClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDecimalPointClause(s)
	}
}

func (p *Cobol85Parser) DecimalPointClause() (localctx IDecimalPointClauseContext) {
	localctx = NewDecimalPointClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, Cobol85ParserRULE_decimalPointClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1554)
		p.Match(Cobol85ParserDECIMAL_POINT)
	}
	p.SetState(1556)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(1555)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(1558)
		p.Match(Cobol85ParserCOMMA)
	}

	return localctx
}

// IDefaultComputationalSignClauseContext is an interface to support dynamic dispatch.
type IDefaultComputationalSignClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDefaultComputationalSignClauseContext differentiates from other interfaces.
	IsDefaultComputationalSignClauseContext()
}

type DefaultComputationalSignClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefaultComputationalSignClauseContext() *DefaultComputationalSignClauseContext {
	var p = new(DefaultComputationalSignClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_defaultComputationalSignClause
	return p
}

func (*DefaultComputationalSignClauseContext) IsDefaultComputationalSignClauseContext() {}

func NewDefaultComputationalSignClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefaultComputationalSignClauseContext {
	var p = new(DefaultComputationalSignClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_defaultComputationalSignClause

	return p
}

func (s *DefaultComputationalSignClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DefaultComputationalSignClauseContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDEFAULT, 0)
}

func (s *DefaultComputationalSignClauseContext) SEPARATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSEPARATE, 0)
}

func (s *DefaultComputationalSignClauseContext) SIGN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSIGN, 0)
}

func (s *DefaultComputationalSignClauseContext) COMPUTATIONAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMPUTATIONAL, 0)
}

func (s *DefaultComputationalSignClauseContext) COMP() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMP, 0)
}

func (s *DefaultComputationalSignClauseContext) LEADING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLEADING, 0)
}

func (s *DefaultComputationalSignClauseContext) TRAILING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTRAILING, 0)
}

func (s *DefaultComputationalSignClauseContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCHARACTER, 0)
}

func (s *DefaultComputationalSignClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *DefaultComputationalSignClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultComputationalSignClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefaultComputationalSignClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDefaultComputationalSignClause(s)
	}
}

func (s *DefaultComputationalSignClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDefaultComputationalSignClause(s)
	}
}

func (p *Cobol85Parser) DefaultComputationalSignClause() (localctx IDefaultComputationalSignClauseContext) {
	localctx = NewDefaultComputationalSignClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, Cobol85ParserRULE_defaultComputationalSignClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1560)
		p.Match(Cobol85ParserDEFAULT)
	}
	p.SetState(1562)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCOMP || _la == Cobol85ParserCOMPUTATIONAL {
		{
			p.SetState(1561)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85ParserCOMP || _la == Cobol85ParserCOMPUTATIONAL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(1568)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserSIGN {
		{
			p.SetState(1564)
			p.Match(Cobol85ParserSIGN)
		}
		p.SetState(1566)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserIS {
			{
				p.SetState(1565)
				p.Match(Cobol85ParserIS)
			}

		}

	}
	p.SetState(1571)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserLEADING || _la == Cobol85ParserTRAILING {
		{
			p.SetState(1570)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85ParserLEADING || _la == Cobol85ParserTRAILING) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

	{
		p.SetState(1573)
		p.Match(Cobol85ParserSEPARATE)
	}
	p.SetState(1575)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCHARACTER {
		{
			p.SetState(1574)
			p.Match(Cobol85ParserCHARACTER)
		}

	}

	return localctx
}

// IDefaultDisplaySignClauseContext is an interface to support dynamic dispatch.
type IDefaultDisplaySignClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDefaultDisplaySignClauseContext differentiates from other interfaces.
	IsDefaultDisplaySignClauseContext()
}

type DefaultDisplaySignClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefaultDisplaySignClauseContext() *DefaultDisplaySignClauseContext {
	var p = new(DefaultDisplaySignClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_defaultDisplaySignClause
	return p
}

func (*DefaultDisplaySignClauseContext) IsDefaultDisplaySignClauseContext() {}

func NewDefaultDisplaySignClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefaultDisplaySignClauseContext {
	var p = new(DefaultDisplaySignClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_defaultDisplaySignClause

	return p
}

func (s *DefaultDisplaySignClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DefaultDisplaySignClauseContext) DEFAULT_DISPLAY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDEFAULT_DISPLAY, 0)
}

func (s *DefaultDisplaySignClauseContext) LEADING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLEADING, 0)
}

func (s *DefaultDisplaySignClauseContext) TRAILING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTRAILING, 0)
}

func (s *DefaultDisplaySignClauseContext) SIGN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSIGN, 0)
}

func (s *DefaultDisplaySignClauseContext) SEPARATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSEPARATE, 0)
}

func (s *DefaultDisplaySignClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *DefaultDisplaySignClauseContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCHARACTER, 0)
}

func (s *DefaultDisplaySignClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultDisplaySignClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefaultDisplaySignClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDefaultDisplaySignClause(s)
	}
}

func (s *DefaultDisplaySignClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDefaultDisplaySignClause(s)
	}
}

func (p *Cobol85Parser) DefaultDisplaySignClause() (localctx IDefaultDisplaySignClauseContext) {
	localctx = NewDefaultDisplaySignClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, Cobol85ParserRULE_defaultDisplaySignClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1577)
		p.Match(Cobol85ParserDEFAULT_DISPLAY)
	}
	p.SetState(1582)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserSIGN {
		{
			p.SetState(1578)
			p.Match(Cobol85ParserSIGN)
		}
		p.SetState(1580)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserIS {
			{
				p.SetState(1579)
				p.Match(Cobol85ParserIS)
			}

		}

	}
	{
		p.SetState(1584)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserLEADING || _la == Cobol85ParserTRAILING) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(1589)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserSEPARATE {
		{
			p.SetState(1585)
			p.Match(Cobol85ParserSEPARATE)
		}
		p.SetState(1587)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserCHARACTER {
			{
				p.SetState(1586)
				p.Match(Cobol85ParserCHARACTER)
			}

		}

	}

	return localctx
}

// IEnvironmentSwitchNameClauseContext is an interface to support dynamic dispatch.
type IEnvironmentSwitchNameClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnvironmentSwitchNameClauseContext differentiates from other interfaces.
	IsEnvironmentSwitchNameClauseContext()
}

type EnvironmentSwitchNameClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnvironmentSwitchNameClauseContext() *EnvironmentSwitchNameClauseContext {
	var p = new(EnvironmentSwitchNameClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_environmentSwitchNameClause
	return p
}

func (*EnvironmentSwitchNameClauseContext) IsEnvironmentSwitchNameClauseContext() {}

func NewEnvironmentSwitchNameClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnvironmentSwitchNameClauseContext {
	var p = new(EnvironmentSwitchNameClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_environmentSwitchNameClause

	return p
}

func (s *EnvironmentSwitchNameClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *EnvironmentSwitchNameClauseContext) EnvironmentName() IEnvironmentNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnvironmentNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnvironmentNameContext)
}

func (s *EnvironmentSwitchNameClauseContext) MnemonicName() IMnemonicNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMnemonicNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMnemonicNameContext)
}

func (s *EnvironmentSwitchNameClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *EnvironmentSwitchNameClauseContext) EnvironmentSwitchNameSpecialNamesStatusPhrase() IEnvironmentSwitchNameSpecialNamesStatusPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnvironmentSwitchNameSpecialNamesStatusPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnvironmentSwitchNameSpecialNamesStatusPhraseContext)
}

func (s *EnvironmentSwitchNameClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnvironmentSwitchNameClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnvironmentSwitchNameClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterEnvironmentSwitchNameClause(s)
	}
}

func (s *EnvironmentSwitchNameClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitEnvironmentSwitchNameClause(s)
	}
}

func (p *Cobol85Parser) EnvironmentSwitchNameClause() (localctx IEnvironmentSwitchNameClauseContext) {
	localctx = NewEnvironmentSwitchNameClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, Cobol85ParserRULE_environmentSwitchNameClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1600)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserABORT, Cobol85ParserAS, Cobol85ParserASCII, Cobol85ParserASSOCIATED_DATA, Cobol85ParserASSOCIATED_DATA_LENGTH, Cobol85ParserATTRIBUTE, Cobol85ParserAUTO, Cobol85ParserAUTO_SKIP, Cobol85ParserBACKGROUND_COLOR, Cobol85ParserBACKGROUND_COLOUR, Cobol85ParserBEEP, Cobol85ParserBELL, Cobol85ParserBINARY, Cobol85ParserBIT, Cobol85ParserBLINK, Cobol85ParserBOUNDS, Cobol85ParserCAPABLE, Cobol85ParserCCSVERSION, Cobol85ParserCHANGED, Cobol85ParserCHANNEL, Cobol85ParserCLOSE_DISPOSITION, Cobol85ParserCOBOL, Cobol85ParserCOMMITMENT, Cobol85ParserCONTROL_POINT, Cobol85ParserCONVENTION, Cobol85ParserCRUNCH, Cobol85ParserCURSOR, Cobol85ParserDEFAULT, Cobol85ParserDEFAULT_DISPLAY, Cobol85ParserDEFINITION, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserDISK, Cobol85ParserDONTCARE, Cobol85ParserDOUBLE, Cobol85ParserEBCDIC, Cobol85ParserEMPTY_CHECK, Cobol85ParserENTER, Cobol85ParserENTRY_PROCEDURE, Cobol85ParserERASE, Cobol85ParserEOL, Cobol85ParserEOS, Cobol85ParserESCAPE, Cobol85ParserEVENT, Cobol85ParserEXCLUSIVE, Cobol85ParserEXPORT, Cobol85ParserEXTENDED, Cobol85ParserFOREGROUND_COLOR, Cobol85ParserFOREGROUND_COLOUR, Cobol85ParserFULL, Cobol85ParserFUNCTIONNAME, Cobol85ParserFUNCTION_POINTER, Cobol85ParserGRID, Cobol85ParserHIGHLIGHT, Cobol85ParserIMPLICIT, Cobol85ParserIMPORT, Cobol85ParserINTEGER, Cobol85ParserKEPT, Cobol85ParserKEYBOARD, Cobol85ParserLANGUAGE, Cobol85ParserLB, Cobol85ParserLD, Cobol85ParserLEFTLINE, Cobol85ParserLENGTH_CHECK, Cobol85ParserLIBACCESS, Cobol85ParserLIBPARAMETER, Cobol85ParserLIBRARY, Cobol85ParserLIST, Cobol85ParserLOCAL, Cobol85ParserLONG_DATE, Cobol85ParserLONG_TIME, Cobol85ParserLOWER, Cobol85ParserLOWLIGHT, Cobol85ParserMMDDYYYY, Cobol85ParserNAMED, Cobol85ParserNATIONAL, Cobol85ParserNATIONAL_EDITED, Cobol85ParserNETWORK, Cobol85ParserNO_ECHO, Cobol85ParserNUMERIC_DATE, Cobol85ParserNUMERIC_TIME, Cobol85ParserODT, Cobol85ParserORDERLY, Cobol85ParserOVERLINE, Cobol85ParserOWN, Cobol85ParserPASSWORD, Cobol85ParserPORT, Cobol85ParserPRINTER, Cobol85ParserPRIVATE, Cobol85ParserPROCESS, Cobol85ParserPROGRAM, Cobol85ParserPROMPT, Cobol85ParserREADER, Cobol85ParserREMOTE, Cobol85ParserREAL, Cobol85ParserRECEIVED, Cobol85ParserRECURSIVE, Cobol85ParserREF, Cobol85ParserREMOVE, Cobol85ParserREQUIRED, Cobol85ParserREVERSE_VIDEO, Cobol85ParserSAVE, Cobol85ParserSECURE, Cobol85ParserSHARED, Cobol85ParserSHAREDBYALL, Cobol85ParserSHAREDBYRUNUNIT, Cobol85ParserSHARING, Cobol85ParserSHORT_DATE, Cobol85ParserSYMBOL, Cobol85ParserTASK, Cobol85ParserTHREAD, Cobol85ParserTHREAD_LOCAL, Cobol85ParserTIMER, Cobol85ParserTODAYS_DATE, Cobol85ParserTODAYS_NAME, Cobol85ParserTRUNCATED, Cobol85ParserTYPEDEF, Cobol85ParserUNDERLINE, Cobol85ParserVIRTUAL, Cobol85ParserWAIT, Cobol85ParserYEAR, Cobol85ParserYYYYMMDD, Cobol85ParserYYYYDDD, Cobol85ParserZERO_FILL, Cobol85ParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1591)
			p.EnvironmentName()
		}
		p.SetState(1593)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserIS {
			{
				p.SetState(1592)
				p.Match(Cobol85ParserIS)
			}

		}
		{
			p.SetState(1595)
			p.MnemonicName()
		}
		p.SetState(1597)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 82, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1596)
				p.EnvironmentSwitchNameSpecialNamesStatusPhrase()
			}

		}

	case Cobol85ParserOFF, Cobol85ParserON:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1599)
			p.EnvironmentSwitchNameSpecialNamesStatusPhrase()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IEnvironmentSwitchNameSpecialNamesStatusPhraseContext is an interface to support dynamic dispatch.
type IEnvironmentSwitchNameSpecialNamesStatusPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnvironmentSwitchNameSpecialNamesStatusPhraseContext differentiates from other interfaces.
	IsEnvironmentSwitchNameSpecialNamesStatusPhraseContext()
}

type EnvironmentSwitchNameSpecialNamesStatusPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnvironmentSwitchNameSpecialNamesStatusPhraseContext() *EnvironmentSwitchNameSpecialNamesStatusPhraseContext {
	var p = new(EnvironmentSwitchNameSpecialNamesStatusPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_environmentSwitchNameSpecialNamesStatusPhrase
	return p
}

func (*EnvironmentSwitchNameSpecialNamesStatusPhraseContext) IsEnvironmentSwitchNameSpecialNamesStatusPhraseContext() {
}

func NewEnvironmentSwitchNameSpecialNamesStatusPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnvironmentSwitchNameSpecialNamesStatusPhraseContext {
	var p = new(EnvironmentSwitchNameSpecialNamesStatusPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_environmentSwitchNameSpecialNamesStatusPhrase

	return p
}

func (s *EnvironmentSwitchNameSpecialNamesStatusPhraseContext) GetParser() antlr.Parser {
	return s.parser
}

func (s *EnvironmentSwitchNameSpecialNamesStatusPhraseContext) ON() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserON, 0)
}

func (s *EnvironmentSwitchNameSpecialNamesStatusPhraseContext) AllCondition() []IConditionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConditionContext)(nil)).Elem())
	var tst = make([]IConditionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConditionContext)
		}
	}

	return tst
}

func (s *EnvironmentSwitchNameSpecialNamesStatusPhraseContext) Condition(i int) IConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *EnvironmentSwitchNameSpecialNamesStatusPhraseContext) AllSTATUS() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserSTATUS)
}

func (s *EnvironmentSwitchNameSpecialNamesStatusPhraseContext) STATUS(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSTATUS, i)
}

func (s *EnvironmentSwitchNameSpecialNamesStatusPhraseContext) AllIS() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserIS)
}

func (s *EnvironmentSwitchNameSpecialNamesStatusPhraseContext) IS(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, i)
}

func (s *EnvironmentSwitchNameSpecialNamesStatusPhraseContext) OFF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOFF, 0)
}

func (s *EnvironmentSwitchNameSpecialNamesStatusPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnvironmentSwitchNameSpecialNamesStatusPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnvironmentSwitchNameSpecialNamesStatusPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterEnvironmentSwitchNameSpecialNamesStatusPhrase(s)
	}
}

func (s *EnvironmentSwitchNameSpecialNamesStatusPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitEnvironmentSwitchNameSpecialNamesStatusPhrase(s)
	}
}

func (p *Cobol85Parser) EnvironmentSwitchNameSpecialNamesStatusPhrase() (localctx IEnvironmentSwitchNameSpecialNamesStatusPhraseContext) {
	localctx = NewEnvironmentSwitchNameSpecialNamesStatusPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, Cobol85ParserRULE_environmentSwitchNameSpecialNamesStatusPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1638)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserON:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1602)
			p.Match(Cobol85ParserON)
		}
		p.SetState(1604)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserSTATUS {
			{
				p.SetState(1603)
				p.Match(Cobol85ParserSTATUS)
			}

		}
		p.SetState(1607)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserIS {
			{
				p.SetState(1606)
				p.Match(Cobol85ParserIS)
			}

		}
		{
			p.SetState(1609)
			p.Condition()
		}
		p.SetState(1618)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 88, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1610)
				p.Match(Cobol85ParserOFF)
			}
			p.SetState(1612)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == Cobol85ParserSTATUS {
				{
					p.SetState(1611)
					p.Match(Cobol85ParserSTATUS)
				}

			}
			p.SetState(1615)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == Cobol85ParserIS {
				{
					p.SetState(1614)
					p.Match(Cobol85ParserIS)
				}

			}
			{
				p.SetState(1617)
				p.Condition()
			}

		}

	case Cobol85ParserOFF:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1620)
			p.Match(Cobol85ParserOFF)
		}
		p.SetState(1622)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserSTATUS {
			{
				p.SetState(1621)
				p.Match(Cobol85ParserSTATUS)
			}

		}
		p.SetState(1625)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserIS {
			{
				p.SetState(1624)
				p.Match(Cobol85ParserIS)
			}

		}
		{
			p.SetState(1627)
			p.Condition()
		}
		p.SetState(1636)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 93, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1628)
				p.Match(Cobol85ParserON)
			}
			p.SetState(1630)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == Cobol85ParserSTATUS {
				{
					p.SetState(1629)
					p.Match(Cobol85ParserSTATUS)
				}

			}
			p.SetState(1633)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == Cobol85ParserIS {
				{
					p.SetState(1632)
					p.Match(Cobol85ParserIS)
				}

			}
			{
				p.SetState(1635)
				p.Condition()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IOdtClauseContext is an interface to support dynamic dispatch.
type IOdtClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOdtClauseContext differentiates from other interfaces.
	IsOdtClauseContext()
}

type OdtClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOdtClauseContext() *OdtClauseContext {
	var p = new(OdtClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_odtClause
	return p
}

func (*OdtClauseContext) IsOdtClauseContext() {}

func NewOdtClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OdtClauseContext {
	var p = new(OdtClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_odtClause

	return p
}

func (s *OdtClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *OdtClauseContext) ODT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserODT, 0)
}

func (s *OdtClauseContext) MnemonicName() IMnemonicNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMnemonicNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMnemonicNameContext)
}

func (s *OdtClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *OdtClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OdtClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OdtClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterOdtClause(s)
	}
}

func (s *OdtClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitOdtClause(s)
	}
}

func (p *Cobol85Parser) OdtClause() (localctx IOdtClauseContext) {
	localctx = NewOdtClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, Cobol85ParserRULE_odtClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1640)
		p.Match(Cobol85ParserODT)
	}
	p.SetState(1642)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(1641)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(1644)
		p.MnemonicName()
	}

	return localctx
}

// IReserveNetworkClauseContext is an interface to support dynamic dispatch.
type IReserveNetworkClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReserveNetworkClauseContext differentiates from other interfaces.
	IsReserveNetworkClauseContext()
}

type ReserveNetworkClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReserveNetworkClauseContext() *ReserveNetworkClauseContext {
	var p = new(ReserveNetworkClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reserveNetworkClause
	return p
}

func (*ReserveNetworkClauseContext) IsReserveNetworkClauseContext() {}

func NewReserveNetworkClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReserveNetworkClauseContext {
	var p = new(ReserveNetworkClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reserveNetworkClause

	return p
}

func (s *ReserveNetworkClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReserveNetworkClauseContext) RESERVE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRESERVE, 0)
}

func (s *ReserveNetworkClauseContext) NETWORK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNETWORK, 0)
}

func (s *ReserveNetworkClauseContext) WORDS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWORDS, 0)
}

func (s *ReserveNetworkClauseContext) LIST() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLIST, 0)
}

func (s *ReserveNetworkClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ReserveNetworkClauseContext) CAPABLE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCAPABLE, 0)
}

func (s *ReserveNetworkClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReserveNetworkClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReserveNetworkClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReserveNetworkClause(s)
	}
}

func (s *ReserveNetworkClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReserveNetworkClause(s)
	}
}

func (p *Cobol85Parser) ReserveNetworkClause() (localctx IReserveNetworkClauseContext) {
	localctx = NewReserveNetworkClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, Cobol85ParserRULE_reserveNetworkClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1646)
		p.Match(Cobol85ParserRESERVE)
	}
	p.SetState(1648)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserWORDS {
		{
			p.SetState(1647)
			p.Match(Cobol85ParserWORDS)
		}

	}
	p.SetState(1651)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserLIST {
		{
			p.SetState(1650)
			p.Match(Cobol85ParserLIST)
		}

	}
	p.SetState(1654)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(1653)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(1656)
		p.Match(Cobol85ParserNETWORK)
	}
	p.SetState(1658)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 99, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1657)
			p.Match(Cobol85ParserCAPABLE)
		}

	}

	return localctx
}

// ISymbolicCharactersClauseContext is an interface to support dynamic dispatch.
type ISymbolicCharactersClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSymbolicCharactersClauseContext differentiates from other interfaces.
	IsSymbolicCharactersClauseContext()
}

type SymbolicCharactersClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySymbolicCharactersClauseContext() *SymbolicCharactersClauseContext {
	var p = new(SymbolicCharactersClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_symbolicCharactersClause
	return p
}

func (*SymbolicCharactersClauseContext) IsSymbolicCharactersClauseContext() {}

func NewSymbolicCharactersClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SymbolicCharactersClauseContext {
	var p = new(SymbolicCharactersClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_symbolicCharactersClause

	return p
}

func (s *SymbolicCharactersClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SymbolicCharactersClauseContext) SYMBOLIC() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSYMBOLIC, 0)
}

func (s *SymbolicCharactersClauseContext) CHARACTERS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCHARACTERS, 0)
}

func (s *SymbolicCharactersClauseContext) AllSymbolicCharacters() []ISymbolicCharactersContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISymbolicCharactersContext)(nil)).Elem())
	var tst = make([]ISymbolicCharactersContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISymbolicCharactersContext)
		}
	}

	return tst
}

func (s *SymbolicCharactersClauseContext) SymbolicCharacters(i int) ISymbolicCharactersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolicCharactersContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISymbolicCharactersContext)
}

func (s *SymbolicCharactersClauseContext) IN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIN, 0)
}

func (s *SymbolicCharactersClauseContext) AlphabetName() IAlphabetNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlphabetNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlphabetNameContext)
}

func (s *SymbolicCharactersClauseContext) ALPHANUMERIC() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALPHANUMERIC, 0)
}

func (s *SymbolicCharactersClauseContext) NATIONAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNATIONAL, 0)
}

func (s *SymbolicCharactersClauseContext) FOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOR, 0)
}

func (s *SymbolicCharactersClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SymbolicCharactersClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SymbolicCharactersClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSymbolicCharactersClause(s)
	}
}

func (s *SymbolicCharactersClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSymbolicCharactersClause(s)
	}
}

func (p *Cobol85Parser) SymbolicCharactersClause() (localctx ISymbolicCharactersClauseContext) {
	localctx = NewSymbolicCharactersClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, Cobol85ParserRULE_symbolicCharactersClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1660)
		p.Match(Cobol85ParserSYMBOLIC)
	}
	p.SetState(1662)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCHARACTERS {
		{
			p.SetState(1661)
			p.Match(Cobol85ParserCHARACTERS)
		}

	}
	p.SetState(1668)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 102, p.GetParserRuleContext()) == 1 {
		p.SetState(1665)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserFOR {
			{
				p.SetState(1664)
				p.Match(Cobol85ParserFOR)
			}

		}
		{
			p.SetState(1667)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85ParserALPHANUMERIC || _la == Cobol85ParserNATIONAL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(1671)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1670)
				p.SymbolicCharacters()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(1673)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 103, p.GetParserRuleContext())
	}
	p.SetState(1677)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIN {
		{
			p.SetState(1675)
			p.Match(Cobol85ParserIN)
		}
		{
			p.SetState(1676)
			p.AlphabetName()
		}

	}

	return localctx
}

// ISymbolicCharactersContext is an interface to support dynamic dispatch.
type ISymbolicCharactersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSymbolicCharactersContext differentiates from other interfaces.
	IsSymbolicCharactersContext()
}

type SymbolicCharactersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySymbolicCharactersContext() *SymbolicCharactersContext {
	var p = new(SymbolicCharactersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_symbolicCharacters
	return p
}

func (*SymbolicCharactersContext) IsSymbolicCharactersContext() {}

func NewSymbolicCharactersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SymbolicCharactersContext {
	var p = new(SymbolicCharactersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_symbolicCharacters

	return p
}

func (s *SymbolicCharactersContext) GetParser() antlr.Parser { return s.parser }

func (s *SymbolicCharactersContext) AllSymbolicCharacter() []ISymbolicCharacterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISymbolicCharacterContext)(nil)).Elem())
	var tst = make([]ISymbolicCharacterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISymbolicCharacterContext)
		}
	}

	return tst
}

func (s *SymbolicCharactersContext) SymbolicCharacter(i int) ISymbolicCharacterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolicCharacterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISymbolicCharacterContext)
}

func (s *SymbolicCharactersContext) AllIntegerLiteral() []IIntegerLiteralContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem())
	var tst = make([]IIntegerLiteralContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIntegerLiteralContext)
		}
	}

	return tst
}

func (s *SymbolicCharactersContext) IntegerLiteral(i int) IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *SymbolicCharactersContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *SymbolicCharactersContext) ARE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserARE, 0)
}

func (s *SymbolicCharactersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SymbolicCharactersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SymbolicCharactersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSymbolicCharacters(s)
	}
}

func (s *SymbolicCharactersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSymbolicCharacters(s)
	}
}

func (p *Cobol85Parser) SymbolicCharacters() (localctx ISymbolicCharactersContext) {
	localctx = NewSymbolicCharactersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, Cobol85ParserRULE_symbolicCharacters)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1680)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH)|(1<<Cobol85ParserATTRIBUTE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBINARY-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-68))|(1<<(Cobol85ParserCOBOL-68))|(1<<(Cobol85ParserCOMMITMENT-68))|(1<<(Cobol85ParserCONTROL_POINT-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(Cobol85ParserCONVENTION-100))|(1<<(Cobol85ParserCRUNCH-100))|(1<<(Cobol85ParserCURSOR-100))|(1<<(Cobol85ParserDEFAULT-100))|(1<<(Cobol85ParserDEFAULT_DISPLAY-100))|(1<<(Cobol85ParserDEFINITION-100)))) != 0) || (((_la-138)&-(0x1f+1)) == 0 && ((1<<uint((_la-138)))&((1<<(Cobol85ParserDFHRESP-138))|(1<<(Cobol85ParserDFHVALUE-138))|(1<<(Cobol85ParserDISK-138))|(1<<(Cobol85ParserDONTCARE-138))|(1<<(Cobol85ParserDOUBLE-138))|(1<<(Cobol85ParserEBCDIC-138))|(1<<(Cobol85ParserEMPTY_CHECK-138)))) != 0) || (((_la-181)&-(0x1f+1)) == 0 && ((1<<uint((_la-181)))&((1<<(Cobol85ParserENTER-181))|(1<<(Cobol85ParserENTRY_PROCEDURE-181))|(1<<(Cobol85ParserERASE-181))|(1<<(Cobol85ParserEOL-181))|(1<<(Cobol85ParserEOS-181))|(1<<(Cobol85ParserESCAPE-181))|(1<<(Cobol85ParserEVENT-181))|(1<<(Cobol85ParserEXCLUSIVE-181))|(1<<(Cobol85ParserEXPORT-181))|(1<<(Cobol85ParserEXTENDED-181)))) != 0) || (((_la-213)&-(0x1f+1)) == 0 && ((1<<uint((_la-213)))&((1<<(Cobol85ParserFOREGROUND_COLOR-213))|(1<<(Cobol85ParserFOREGROUND_COLOUR-213))|(1<<(Cobol85ParserFULL-213))|(1<<(Cobol85ParserFUNCTIONNAME-213))|(1<<(Cobol85ParserFUNCTION_POINTER-213))|(1<<(Cobol85ParserGRID-213))|(1<<(Cobol85ParserHIGHLIGHT-213))|(1<<(Cobol85ParserIMPLICIT-213))|(1<<(Cobol85ParserIMPORT-213)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(Cobol85ParserINTEGER-250))|(1<<(Cobol85ParserKEPT-250))|(1<<(Cobol85ParserKEYBOARD-250))|(1<<(Cobol85ParserLANGUAGE-250))|(1<<(Cobol85ParserLB-250))|(1<<(Cobol85ParserLD-250))|(1<<(Cobol85ParserLEFTLINE-250))|(1<<(Cobol85ParserLENGTH_CHECK-250))|(1<<(Cobol85ParserLIBACCESS-250))|(1<<(Cobol85ParserLIBPARAMETER-250))|(1<<(Cobol85ParserLIBRARY-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(Cobol85ParserLIST-283))|(1<<(Cobol85ParserLOCAL-283))|(1<<(Cobol85ParserLONG_DATE-283))|(1<<(Cobol85ParserLONG_TIME-283))|(1<<(Cobol85ParserLOWER-283))|(1<<(Cobol85ParserLOWLIGHT-283))|(1<<(Cobol85ParserMMDDYYYY-283))|(1<<(Cobol85ParserNAMED-283))|(1<<(Cobol85ParserNATIONAL-283))|(1<<(Cobol85ParserNATIONAL_EDITED-283))|(1<<(Cobol85ParserNETWORK-283))|(1<<(Cobol85ParserNO_ECHO-283)))) != 0) || (((_la-317)&-(0x1f+1)) == 0 && ((1<<uint((_la-317)))&((1<<(Cobol85ParserNUMERIC_DATE-317))|(1<<(Cobol85ParserNUMERIC_TIME-317))|(1<<(Cobol85ParserODT-317))|(1<<(Cobol85ParserORDERLY-317))|(1<<(Cobol85ParserOVERLINE-317))|(1<<(Cobol85ParserOWN-317))|(1<<(Cobol85ParserPASSWORD-317)))) != 0) || (((_la-352)&-(0x1f+1)) == 0 && ((1<<uint((_la-352)))&((1<<(Cobol85ParserPORT-352))|(1<<(Cobol85ParserPRINTER-352))|(1<<(Cobol85ParserPRIVATE-352))|(1<<(Cobol85ParserPROCESS-352))|(1<<(Cobol85ParserPROGRAM-352))|(1<<(Cobol85ParserPROMPT-352))|(1<<(Cobol85ParserREADER-352))|(1<<(Cobol85ParserREMOTE-352))|(1<<(Cobol85ParserREAL-352))|(1<<(Cobol85ParserRECEIVED-352))|(1<<(Cobol85ParserRECURSIVE-352))|(1<<(Cobol85ParserREF-352)))) != 0) || (((_la-391)&-(0x1f+1)) == 0 && ((1<<uint((_la-391)))&((1<<(Cobol85ParserREMOVE-391))|(1<<(Cobol85ParserREQUIRED-391))|(1<<(Cobol85ParserREVERSE_VIDEO-391))|(1<<(Cobol85ParserSAVE-391))|(1<<(Cobol85ParserSECURE-391)))) != 0) || (((_la-431)&-(0x1f+1)) == 0 && ((1<<uint((_la-431)))&((1<<(Cobol85ParserSHARED-431))|(1<<(Cobol85ParserSHAREDBYALL-431))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-431))|(1<<(Cobol85ParserSHARING-431))|(1<<(Cobol85ParserSHORT_DATE-431)))) != 0) || (((_la-466)&-(0x1f+1)) == 0 && ((1<<uint((_la-466)))&((1<<(Cobol85ParserSYMBOL-466))|(1<<(Cobol85ParserTASK-466))|(1<<(Cobol85ParserTHREAD-466))|(1<<(Cobol85ParserTHREAD_LOCAL-466))|(1<<(Cobol85ParserTIMER-466))|(1<<(Cobol85ParserTODAYS_DATE-466))|(1<<(Cobol85ParserTODAYS_NAME-466))|(1<<(Cobol85ParserTRUNCATED-466))|(1<<(Cobol85ParserTYPEDEF-466)))) != 0) || (((_la-498)&-(0x1f+1)) == 0 && ((1<<uint((_la-498)))&((1<<(Cobol85ParserUNDERLINE-498))|(1<<(Cobol85ParserVIRTUAL-498))|(1<<(Cobol85ParserWAIT-498))|(1<<(Cobol85ParserYEAR-498))|(1<<(Cobol85ParserYYYYMMDD-498))|(1<<(Cobol85ParserYYYYDDD-498))|(1<<(Cobol85ParserZERO_FILL-498)))) != 0) || _la == Cobol85ParserIDENTIFIER {
		{
			p.SetState(1679)
			p.SymbolicCharacter()
		}

		p.SetState(1682)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1685)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserARE || _la == Cobol85ParserIS {
		{
			p.SetState(1684)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85ParserARE || _la == Cobol85ParserIS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(1688)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la-552)&-(0x1f+1)) == 0 && ((1<<uint((_la-552)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-552))|(1<<(Cobol85ParserLEVEL_NUMBER_77-552))|(1<<(Cobol85ParserLEVEL_NUMBER_88-552))|(1<<(Cobol85ParserINTEGERLITERAL-552)))) != 0) {
		{
			p.SetState(1687)
			p.IntegerLiteral()
		}

		p.SetState(1690)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IInputOutputSectionContext is an interface to support dynamic dispatch.
type IInputOutputSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInputOutputSectionContext differentiates from other interfaces.
	IsInputOutputSectionContext()
}

type InputOutputSectionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInputOutputSectionContext() *InputOutputSectionContext {
	var p = new(InputOutputSectionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_inputOutputSection
	return p
}

func (*InputOutputSectionContext) IsInputOutputSectionContext() {}

func NewInputOutputSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InputOutputSectionContext {
	var p = new(InputOutputSectionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_inputOutputSection

	return p
}

func (s *InputOutputSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *InputOutputSectionContext) INPUT_OUTPUT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINPUT_OUTPUT, 0)
}

func (s *InputOutputSectionContext) SECTION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSECTION, 0)
}

func (s *InputOutputSectionContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *InputOutputSectionContext) AllInputOutputSectionParagraph() []IInputOutputSectionParagraphContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInputOutputSectionParagraphContext)(nil)).Elem())
	var tst = make([]IInputOutputSectionParagraphContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInputOutputSectionParagraphContext)
		}
	}

	return tst
}

func (s *InputOutputSectionContext) InputOutputSectionParagraph(i int) IInputOutputSectionParagraphContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInputOutputSectionParagraphContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInputOutputSectionParagraphContext)
}

func (s *InputOutputSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InputOutputSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InputOutputSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInputOutputSection(s)
	}
}

func (s *InputOutputSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInputOutputSection(s)
	}
}

func (p *Cobol85Parser) InputOutputSection() (localctx IInputOutputSectionContext) {
	localctx = NewInputOutputSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, Cobol85ParserRULE_inputOutputSection)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1692)
		p.Match(Cobol85ParserINPUT_OUTPUT)
	}
	{
		p.SetState(1693)
		p.Match(Cobol85ParserSECTION)
	}
	{
		p.SetState(1694)
		p.Match(Cobol85ParserDOT_FS)
	}
	p.SetState(1698)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserFILE_CONTROL || _la == Cobol85ParserI_O_CONTROL {
		{
			p.SetState(1695)
			p.InputOutputSectionParagraph()
		}

		p.SetState(1700)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IInputOutputSectionParagraphContext is an interface to support dynamic dispatch.
type IInputOutputSectionParagraphContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInputOutputSectionParagraphContext differentiates from other interfaces.
	IsInputOutputSectionParagraphContext()
}

type InputOutputSectionParagraphContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInputOutputSectionParagraphContext() *InputOutputSectionParagraphContext {
	var p = new(InputOutputSectionParagraphContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_inputOutputSectionParagraph
	return p
}

func (*InputOutputSectionParagraphContext) IsInputOutputSectionParagraphContext() {}

func NewInputOutputSectionParagraphContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InputOutputSectionParagraphContext {
	var p = new(InputOutputSectionParagraphContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_inputOutputSectionParagraph

	return p
}

func (s *InputOutputSectionParagraphContext) GetParser() antlr.Parser { return s.parser }

func (s *InputOutputSectionParagraphContext) FileControlParagraph() IFileControlParagraphContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileControlParagraphContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFileControlParagraphContext)
}

func (s *InputOutputSectionParagraphContext) IoControlParagraph() IIoControlParagraphContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIoControlParagraphContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIoControlParagraphContext)
}

func (s *InputOutputSectionParagraphContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InputOutputSectionParagraphContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InputOutputSectionParagraphContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInputOutputSectionParagraph(s)
	}
}

func (s *InputOutputSectionParagraphContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInputOutputSectionParagraph(s)
	}
}

func (p *Cobol85Parser) InputOutputSectionParagraph() (localctx IInputOutputSectionParagraphContext) {
	localctx = NewInputOutputSectionParagraphContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, Cobol85ParserRULE_inputOutputSectionParagraph)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1703)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserFILE_CONTROL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1701)
			p.FileControlParagraph()
		}

	case Cobol85ParserI_O_CONTROL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1702)
			p.IoControlParagraph()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFileControlParagraphContext is an interface to support dynamic dispatch.
type IFileControlParagraphContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFileControlParagraphContext differentiates from other interfaces.
	IsFileControlParagraphContext()
}

type FileControlParagraphContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFileControlParagraphContext() *FileControlParagraphContext {
	var p = new(FileControlParagraphContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_fileControlParagraph
	return p
}

func (*FileControlParagraphContext) IsFileControlParagraphContext() {}

func NewFileControlParagraphContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FileControlParagraphContext {
	var p = new(FileControlParagraphContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_fileControlParagraph

	return p
}

func (s *FileControlParagraphContext) GetParser() antlr.Parser { return s.parser }

func (s *FileControlParagraphContext) FILE_CONTROL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFILE_CONTROL, 0)
}

func (s *FileControlParagraphContext) AllDOT_FS() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserDOT_FS)
}

func (s *FileControlParagraphContext) DOT_FS(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, i)
}

func (s *FileControlParagraphContext) AllFileControlEntry() []IFileControlEntryContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFileControlEntryContext)(nil)).Elem())
	var tst = make([]IFileControlEntryContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFileControlEntryContext)
		}
	}

	return tst
}

func (s *FileControlParagraphContext) FileControlEntry(i int) IFileControlEntryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileControlEntryContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFileControlEntryContext)
}

func (s *FileControlParagraphContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FileControlParagraphContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FileControlParagraphContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterFileControlParagraph(s)
	}
}

func (s *FileControlParagraphContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitFileControlParagraph(s)
	}
}

func (p *Cobol85Parser) FileControlParagraph() (localctx IFileControlParagraphContext) {
	localctx = NewFileControlParagraphContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, Cobol85ParserRULE_fileControlParagraph)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1705)
		p.Match(Cobol85ParserFILE_CONTROL)
	}
	p.SetState(1712)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 111, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1707)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == Cobol85ParserDOT_FS {
				{
					p.SetState(1706)
					p.Match(Cobol85ParserDOT_FS)
				}

			}
			{
				p.SetState(1709)
				p.FileControlEntry()
			}

		}
		p.SetState(1714)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 111, p.GetParserRuleContext())
	}
	{
		p.SetState(1715)
		p.Match(Cobol85ParserDOT_FS)
	}

	return localctx
}

// IFileControlEntryContext is an interface to support dynamic dispatch.
type IFileControlEntryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFileControlEntryContext differentiates from other interfaces.
	IsFileControlEntryContext()
}

type FileControlEntryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFileControlEntryContext() *FileControlEntryContext {
	var p = new(FileControlEntryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_fileControlEntry
	return p
}

func (*FileControlEntryContext) IsFileControlEntryContext() {}

func NewFileControlEntryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FileControlEntryContext {
	var p = new(FileControlEntryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_fileControlEntry

	return p
}

func (s *FileControlEntryContext) GetParser() antlr.Parser { return s.parser }

func (s *FileControlEntryContext) SelectClause() ISelectClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelectClauseContext)
}

func (s *FileControlEntryContext) AllFileControlClause() []IFileControlClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFileControlClauseContext)(nil)).Elem())
	var tst = make([]IFileControlClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFileControlClauseContext)
		}
	}

	return tst
}

func (s *FileControlEntryContext) FileControlClause(i int) IFileControlClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileControlClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFileControlClauseContext)
}

func (s *FileControlEntryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FileControlEntryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FileControlEntryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterFileControlEntry(s)
	}
}

func (s *FileControlEntryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitFileControlEntry(s)
	}
}

func (p *Cobol85Parser) FileControlEntry() (localctx IFileControlEntryContext) {
	localctx = NewFileControlEntryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, Cobol85ParserRULE_fileControlEntry)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1717)
		p.SelectClause()
	}
	p.SetState(1721)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserACCESS)|(1<<Cobol85ParserALTERNATE)|(1<<Cobol85ParserASSIGN))) != 0) || _la == Cobol85ParserBINARY || _la == Cobol85ParserFILE || _la == Cobol85ParserINDEXED || _la == Cobol85ParserLINE || (((_la-332)&-(0x1f+1)) == 0 && ((1<<uint((_la-332)))&((1<<(Cobol85ParserORGANIZATION-332))|(1<<(Cobol85ParserPADDING-332))|(1<<(Cobol85ParserPASSWORD-332)))) != 0) || (((_la-377)&-(0x1f+1)) == 0 && ((1<<uint((_la-377)))&((1<<(Cobol85ParserRECORD-377))|(1<<(Cobol85ParserRELATIVE-377))|(1<<(Cobol85ParserRESERVE-377)))) != 0) || _la == Cobol85ParserSEQUENTIAL || _la == Cobol85ParserSTATUS {
		{
			p.SetState(1718)
			p.FileControlClause()
		}

		p.SetState(1723)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISelectClauseContext is an interface to support dynamic dispatch.
type ISelectClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelectClauseContext differentiates from other interfaces.
	IsSelectClauseContext()
}

type SelectClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectClauseContext() *SelectClauseContext {
	var p = new(SelectClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_selectClause
	return p
}

func (*SelectClauseContext) IsSelectClauseContext() {}

func NewSelectClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectClauseContext {
	var p = new(SelectClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_selectClause

	return p
}

func (s *SelectClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectClauseContext) SELECT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSELECT, 0)
}

func (s *SelectClauseContext) FileName() IFileNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *SelectClauseContext) OPTIONAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOPTIONAL, 0)
}

func (s *SelectClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSelectClause(s)
	}
}

func (s *SelectClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSelectClause(s)
	}
}

func (p *Cobol85Parser) SelectClause() (localctx ISelectClauseContext) {
	localctx = NewSelectClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, Cobol85ParserRULE_selectClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1724)
		p.Match(Cobol85ParserSELECT)
	}
	p.SetState(1726)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserOPTIONAL {
		{
			p.SetState(1725)
			p.Match(Cobol85ParserOPTIONAL)
		}

	}
	{
		p.SetState(1728)
		p.FileName()
	}

	return localctx
}

// IFileControlClauseContext is an interface to support dynamic dispatch.
type IFileControlClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFileControlClauseContext differentiates from other interfaces.
	IsFileControlClauseContext()
}

type FileControlClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFileControlClauseContext() *FileControlClauseContext {
	var p = new(FileControlClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_fileControlClause
	return p
}

func (*FileControlClauseContext) IsFileControlClauseContext() {}

func NewFileControlClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FileControlClauseContext {
	var p = new(FileControlClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_fileControlClause

	return p
}

func (s *FileControlClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *FileControlClauseContext) AssignClause() IAssignClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignClauseContext)
}

func (s *FileControlClauseContext) ReserveClause() IReserveClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReserveClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReserveClauseContext)
}

func (s *FileControlClauseContext) OrganizationClause() IOrganizationClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOrganizationClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOrganizationClauseContext)
}

func (s *FileControlClauseContext) PaddingCharacterClause() IPaddingCharacterClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPaddingCharacterClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPaddingCharacterClauseContext)
}

func (s *FileControlClauseContext) RecordDelimiterClause() IRecordDelimiterClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRecordDelimiterClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRecordDelimiterClauseContext)
}

func (s *FileControlClauseContext) AccessModeClause() IAccessModeClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAccessModeClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAccessModeClauseContext)
}

func (s *FileControlClauseContext) RecordKeyClause() IRecordKeyClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRecordKeyClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRecordKeyClauseContext)
}

func (s *FileControlClauseContext) AlternateRecordKeyClause() IAlternateRecordKeyClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlternateRecordKeyClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlternateRecordKeyClauseContext)
}

func (s *FileControlClauseContext) FileStatusClause() IFileStatusClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileStatusClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFileStatusClauseContext)
}

func (s *FileControlClauseContext) PasswordClause() IPasswordClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPasswordClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPasswordClauseContext)
}

func (s *FileControlClauseContext) RelativeKeyClause() IRelativeKeyClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelativeKeyClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRelativeKeyClauseContext)
}

func (s *FileControlClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FileControlClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FileControlClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterFileControlClause(s)
	}
}

func (s *FileControlClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitFileControlClause(s)
	}
}

func (p *Cobol85Parser) FileControlClause() (localctx IFileControlClauseContext) {
	localctx = NewFileControlClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, Cobol85ParserRULE_fileControlClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1741)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 114, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1730)
			p.AssignClause()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1731)
			p.ReserveClause()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1732)
			p.OrganizationClause()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1733)
			p.PaddingCharacterClause()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1734)
			p.RecordDelimiterClause()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1735)
			p.AccessModeClause()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1736)
			p.RecordKeyClause()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1737)
			p.AlternateRecordKeyClause()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1738)
			p.FileStatusClause()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1739)
			p.PasswordClause()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1740)
			p.RelativeKeyClause()
		}

	}

	return localctx
}

// IAssignClauseContext is an interface to support dynamic dispatch.
type IAssignClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignClauseContext differentiates from other interfaces.
	IsAssignClauseContext()
}

type AssignClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignClauseContext() *AssignClauseContext {
	var p = new(AssignClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_assignClause
	return p
}

func (*AssignClauseContext) IsAssignClauseContext() {}

func NewAssignClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignClauseContext {
	var p = new(AssignClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_assignClause

	return p
}

func (s *AssignClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignClauseContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserASSIGN, 0)
}

func (s *AssignClauseContext) DISK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDISK, 0)
}

func (s *AssignClauseContext) DISPLAY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDISPLAY, 0)
}

func (s *AssignClauseContext) KEYBOARD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserKEYBOARD, 0)
}

func (s *AssignClauseContext) PORT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPORT, 0)
}

func (s *AssignClauseContext) PRINTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPRINTER, 0)
}

func (s *AssignClauseContext) READER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREADER, 0)
}

func (s *AssignClauseContext) REMOTE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREMOTE, 0)
}

func (s *AssignClauseContext) TAPE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTAPE, 0)
}

func (s *AssignClauseContext) VIRTUAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserVIRTUAL, 0)
}

func (s *AssignClauseContext) AssignmentName() IAssignmentNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignmentNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignmentNameContext)
}

func (s *AssignClauseContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *AssignClauseContext) TO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTO, 0)
}

func (s *AssignClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAssignClause(s)
	}
}

func (s *AssignClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAssignClause(s)
	}
}

func (p *Cobol85Parser) AssignClause() (localctx IAssignClauseContext) {
	localctx = NewAssignClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, Cobol85ParserRULE_assignClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1743)
		p.Match(Cobol85ParserASSIGN)
	}
	p.SetState(1745)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserTO {
		{
			p.SetState(1744)
			p.Match(Cobol85ParserTO)
		}

	}
	p.SetState(1758)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 116, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1747)
			p.Match(Cobol85ParserDISK)
		}

	case 2:
		{
			p.SetState(1748)
			p.Match(Cobol85ParserDISPLAY)
		}

	case 3:
		{
			p.SetState(1749)
			p.Match(Cobol85ParserKEYBOARD)
		}

	case 4:
		{
			p.SetState(1750)
			p.Match(Cobol85ParserPORT)
		}

	case 5:
		{
			p.SetState(1751)
			p.Match(Cobol85ParserPRINTER)
		}

	case 6:
		{
			p.SetState(1752)
			p.Match(Cobol85ParserREADER)
		}

	case 7:
		{
			p.SetState(1753)
			p.Match(Cobol85ParserREMOTE)
		}

	case 8:
		{
			p.SetState(1754)
			p.Match(Cobol85ParserTAPE)
		}

	case 9:
		{
			p.SetState(1755)
			p.Match(Cobol85ParserVIRTUAL)
		}

	case 10:
		{
			p.SetState(1756)
			p.AssignmentName()
		}

	case 11:
		{
			p.SetState(1757)
			p.Literal()
		}

	}

	return localctx
}

// IReserveClauseContext is an interface to support dynamic dispatch.
type IReserveClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReserveClauseContext differentiates from other interfaces.
	IsReserveClauseContext()
}

type ReserveClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReserveClauseContext() *ReserveClauseContext {
	var p = new(ReserveClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reserveClause
	return p
}

func (*ReserveClauseContext) IsReserveClauseContext() {}

func NewReserveClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReserveClauseContext {
	var p = new(ReserveClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reserveClause

	return p
}

func (s *ReserveClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReserveClauseContext) RESERVE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRESERVE, 0)
}

func (s *ReserveClauseContext) NO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNO, 0)
}

func (s *ReserveClauseContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ReserveClauseContext) ALTERNATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALTERNATE, 0)
}

func (s *ReserveClauseContext) AREA() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAREA, 0)
}

func (s *ReserveClauseContext) AREAS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAREAS, 0)
}

func (s *ReserveClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReserveClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReserveClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReserveClause(s)
	}
}

func (s *ReserveClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReserveClause(s)
	}
}

func (p *Cobol85Parser) ReserveClause() (localctx IReserveClauseContext) {
	localctx = NewReserveClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, Cobol85ParserRULE_reserveClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1760)
		p.Match(Cobol85ParserRESERVE)
	}
	p.SetState(1763)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserNO:
		{
			p.SetState(1761)
			p.Match(Cobol85ParserNO)
		}

	case Cobol85ParserLEVEL_NUMBER_66, Cobol85ParserLEVEL_NUMBER_77, Cobol85ParserLEVEL_NUMBER_88, Cobol85ParserINTEGERLITERAL:
		{
			p.SetState(1762)
			p.IntegerLiteral()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(1766)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 118, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1765)
			p.Match(Cobol85ParserALTERNATE)
		}

	}
	p.SetState(1769)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserAREA || _la == Cobol85ParserAREAS {
		{
			p.SetState(1768)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85ParserAREA || _la == Cobol85ParserAREAS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

	return localctx
}

// IOrganizationClauseContext is an interface to support dynamic dispatch.
type IOrganizationClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOrganizationClauseContext differentiates from other interfaces.
	IsOrganizationClauseContext()
}

type OrganizationClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrganizationClauseContext() *OrganizationClauseContext {
	var p = new(OrganizationClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_organizationClause
	return p
}

func (*OrganizationClauseContext) IsOrganizationClauseContext() {}

func NewOrganizationClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrganizationClauseContext {
	var p = new(OrganizationClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_organizationClause

	return p
}

func (s *OrganizationClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *OrganizationClauseContext) SEQUENTIAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSEQUENTIAL, 0)
}

func (s *OrganizationClauseContext) RELATIVE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRELATIVE, 0)
}

func (s *OrganizationClauseContext) INDEXED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINDEXED, 0)
}

func (s *OrganizationClauseContext) ORGANIZATION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserORGANIZATION, 0)
}

func (s *OrganizationClauseContext) LINE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLINE, 0)
}

func (s *OrganizationClauseContext) RECORD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRECORD, 0)
}

func (s *OrganizationClauseContext) BINARY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBINARY, 0)
}

func (s *OrganizationClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *OrganizationClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrganizationClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrganizationClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterOrganizationClause(s)
	}
}

func (s *OrganizationClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitOrganizationClause(s)
	}
}

func (p *Cobol85Parser) OrganizationClause() (localctx IOrganizationClauseContext) {
	localctx = NewOrganizationClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, Cobol85ParserRULE_organizationClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1775)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserORGANIZATION {
		{
			p.SetState(1771)
			p.Match(Cobol85ParserORGANIZATION)
		}
		p.SetState(1773)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserIS {
			{
				p.SetState(1772)
				p.Match(Cobol85ParserIS)
			}

		}

	}
	p.SetState(1782)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 122, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1777)
			p.Match(Cobol85ParserLINE)
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 122, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(1778)
			p.Match(Cobol85ParserRECORD)
		}
		{
			p.SetState(1779)
			p.Match(Cobol85ParserBINARY)
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 122, p.GetParserRuleContext()) == 3 {
		{
			p.SetState(1780)
			p.Match(Cobol85ParserRECORD)
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 122, p.GetParserRuleContext()) == 4 {
		{
			p.SetState(1781)
			p.Match(Cobol85ParserBINARY)
		}

	}
	{
		p.SetState(1784)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserINDEXED || _la == Cobol85ParserRELATIVE || _la == Cobol85ParserSEQUENTIAL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IPaddingCharacterClauseContext is an interface to support dynamic dispatch.
type IPaddingCharacterClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPaddingCharacterClauseContext differentiates from other interfaces.
	IsPaddingCharacterClauseContext()
}

type PaddingCharacterClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPaddingCharacterClauseContext() *PaddingCharacterClauseContext {
	var p = new(PaddingCharacterClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_paddingCharacterClause
	return p
}

func (*PaddingCharacterClauseContext) IsPaddingCharacterClauseContext() {}

func NewPaddingCharacterClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PaddingCharacterClauseContext {
	var p = new(PaddingCharacterClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_paddingCharacterClause

	return p
}

func (s *PaddingCharacterClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *PaddingCharacterClauseContext) PADDING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPADDING, 0)
}

func (s *PaddingCharacterClauseContext) QualifiedDataName() IQualifiedDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *PaddingCharacterClauseContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *PaddingCharacterClauseContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCHARACTER, 0)
}

func (s *PaddingCharacterClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *PaddingCharacterClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PaddingCharacterClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PaddingCharacterClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterPaddingCharacterClause(s)
	}
}

func (s *PaddingCharacterClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitPaddingCharacterClause(s)
	}
}

func (p *Cobol85Parser) PaddingCharacterClause() (localctx IPaddingCharacterClauseContext) {
	localctx = NewPaddingCharacterClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, Cobol85ParserRULE_paddingCharacterClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1786)
		p.Match(Cobol85ParserPADDING)
	}
	p.SetState(1788)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCHARACTER {
		{
			p.SetState(1787)
			p.Match(Cobol85ParserCHARACTER)
		}

	}
	p.SetState(1791)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(1790)
			p.Match(Cobol85ParserIS)
		}

	}
	p.SetState(1795)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 125, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1793)
			p.QualifiedDataName()
		}

	case 2:
		{
			p.SetState(1794)
			p.Literal()
		}

	}

	return localctx
}

// IRecordDelimiterClauseContext is an interface to support dynamic dispatch.
type IRecordDelimiterClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRecordDelimiterClauseContext differentiates from other interfaces.
	IsRecordDelimiterClauseContext()
}

type RecordDelimiterClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordDelimiterClauseContext() *RecordDelimiterClauseContext {
	var p = new(RecordDelimiterClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_recordDelimiterClause
	return p
}

func (*RecordDelimiterClauseContext) IsRecordDelimiterClauseContext() {}

func NewRecordDelimiterClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordDelimiterClauseContext {
	var p = new(RecordDelimiterClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_recordDelimiterClause

	return p
}

func (s *RecordDelimiterClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordDelimiterClauseContext) RECORD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRECORD, 0)
}

func (s *RecordDelimiterClauseContext) DELIMITER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDELIMITER, 0)
}

func (s *RecordDelimiterClauseContext) STANDARD_1() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSTANDARD_1, 0)
}

func (s *RecordDelimiterClauseContext) IMPLICIT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIMPLICIT, 0)
}

func (s *RecordDelimiterClauseContext) AssignmentName() IAssignmentNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignmentNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignmentNameContext)
}

func (s *RecordDelimiterClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *RecordDelimiterClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordDelimiterClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordDelimiterClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterRecordDelimiterClause(s)
	}
}

func (s *RecordDelimiterClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitRecordDelimiterClause(s)
	}
}

func (p *Cobol85Parser) RecordDelimiterClause() (localctx IRecordDelimiterClauseContext) {
	localctx = NewRecordDelimiterClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, Cobol85ParserRULE_recordDelimiterClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1797)
		p.Match(Cobol85ParserRECORD)
	}
	{
		p.SetState(1798)
		p.Match(Cobol85ParserDELIMITER)
	}
	p.SetState(1800)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(1799)
			p.Match(Cobol85ParserIS)
		}

	}
	p.SetState(1805)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 127, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1802)
			p.Match(Cobol85ParserSTANDARD_1)
		}

	case 2:
		{
			p.SetState(1803)
			p.Match(Cobol85ParserIMPLICIT)
		}

	case 3:
		{
			p.SetState(1804)
			p.AssignmentName()
		}

	}

	return localctx
}

// IAccessModeClauseContext is an interface to support dynamic dispatch.
type IAccessModeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAccessModeClauseContext differentiates from other interfaces.
	IsAccessModeClauseContext()
}

type AccessModeClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAccessModeClauseContext() *AccessModeClauseContext {
	var p = new(AccessModeClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_accessModeClause
	return p
}

func (*AccessModeClauseContext) IsAccessModeClauseContext() {}

func NewAccessModeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AccessModeClauseContext {
	var p = new(AccessModeClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_accessModeClause

	return p
}

func (s *AccessModeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AccessModeClauseContext) ACCESS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserACCESS, 0)
}

func (s *AccessModeClauseContext) SEQUENTIAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSEQUENTIAL, 0)
}

func (s *AccessModeClauseContext) RANDOM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRANDOM, 0)
}

func (s *AccessModeClauseContext) DYNAMIC() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDYNAMIC, 0)
}

func (s *AccessModeClauseContext) EXCLUSIVE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEXCLUSIVE, 0)
}

func (s *AccessModeClauseContext) MODE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMODE, 0)
}

func (s *AccessModeClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *AccessModeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AccessModeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AccessModeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAccessModeClause(s)
	}
}

func (s *AccessModeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAccessModeClause(s)
	}
}

func (p *Cobol85Parser) AccessModeClause() (localctx IAccessModeClauseContext) {
	localctx = NewAccessModeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, Cobol85ParserRULE_accessModeClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1807)
		p.Match(Cobol85ParserACCESS)
	}
	p.SetState(1809)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserMODE {
		{
			p.SetState(1808)
			p.Match(Cobol85ParserMODE)
		}

	}
	p.SetState(1812)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(1811)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(1814)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserDYNAMIC || _la == Cobol85ParserEXCLUSIVE || _la == Cobol85ParserRANDOM || _la == Cobol85ParserSEQUENTIAL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IRecordKeyClauseContext is an interface to support dynamic dispatch.
type IRecordKeyClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRecordKeyClauseContext differentiates from other interfaces.
	IsRecordKeyClauseContext()
}

type RecordKeyClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordKeyClauseContext() *RecordKeyClauseContext {
	var p = new(RecordKeyClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_recordKeyClause
	return p
}

func (*RecordKeyClauseContext) IsRecordKeyClauseContext() {}

func NewRecordKeyClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordKeyClauseContext {
	var p = new(RecordKeyClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_recordKeyClause

	return p
}

func (s *RecordKeyClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordKeyClauseContext) RECORD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRECORD, 0)
}

func (s *RecordKeyClauseContext) QualifiedDataName() IQualifiedDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *RecordKeyClauseContext) KEY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserKEY, 0)
}

func (s *RecordKeyClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *RecordKeyClauseContext) PasswordClause() IPasswordClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPasswordClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPasswordClauseContext)
}

func (s *RecordKeyClauseContext) DUPLICATES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDUPLICATES, 0)
}

func (s *RecordKeyClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWITH, 0)
}

func (s *RecordKeyClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordKeyClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordKeyClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterRecordKeyClause(s)
	}
}

func (s *RecordKeyClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitRecordKeyClause(s)
	}
}

func (p *Cobol85Parser) RecordKeyClause() (localctx IRecordKeyClauseContext) {
	localctx = NewRecordKeyClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, Cobol85ParserRULE_recordKeyClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1816)
		p.Match(Cobol85ParserRECORD)
	}
	p.SetState(1818)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserKEY {
		{
			p.SetState(1817)
			p.Match(Cobol85ParserKEY)
		}

	}
	p.SetState(1821)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(1820)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(1823)
		p.QualifiedDataName()
	}
	p.SetState(1825)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 132, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1824)
			p.PasswordClause()
		}

	}
	p.SetState(1831)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserDUPLICATES || _la == Cobol85ParserWITH {
		p.SetState(1828)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserWITH {
			{
				p.SetState(1827)
				p.Match(Cobol85ParserWITH)
			}

		}
		{
			p.SetState(1830)
			p.Match(Cobol85ParserDUPLICATES)
		}

	}

	return localctx
}

// IAlternateRecordKeyClauseContext is an interface to support dynamic dispatch.
type IAlternateRecordKeyClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlternateRecordKeyClauseContext differentiates from other interfaces.
	IsAlternateRecordKeyClauseContext()
}

type AlternateRecordKeyClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlternateRecordKeyClauseContext() *AlternateRecordKeyClauseContext {
	var p = new(AlternateRecordKeyClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_alternateRecordKeyClause
	return p
}

func (*AlternateRecordKeyClauseContext) IsAlternateRecordKeyClauseContext() {}

func NewAlternateRecordKeyClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlternateRecordKeyClauseContext {
	var p = new(AlternateRecordKeyClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_alternateRecordKeyClause

	return p
}

func (s *AlternateRecordKeyClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AlternateRecordKeyClauseContext) ALTERNATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALTERNATE, 0)
}

func (s *AlternateRecordKeyClauseContext) RECORD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRECORD, 0)
}

func (s *AlternateRecordKeyClauseContext) QualifiedDataName() IQualifiedDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *AlternateRecordKeyClauseContext) KEY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserKEY, 0)
}

func (s *AlternateRecordKeyClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *AlternateRecordKeyClauseContext) PasswordClause() IPasswordClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPasswordClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPasswordClauseContext)
}

func (s *AlternateRecordKeyClauseContext) DUPLICATES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDUPLICATES, 0)
}

func (s *AlternateRecordKeyClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWITH, 0)
}

func (s *AlternateRecordKeyClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlternateRecordKeyClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlternateRecordKeyClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAlternateRecordKeyClause(s)
	}
}

func (s *AlternateRecordKeyClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAlternateRecordKeyClause(s)
	}
}

func (p *Cobol85Parser) AlternateRecordKeyClause() (localctx IAlternateRecordKeyClauseContext) {
	localctx = NewAlternateRecordKeyClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, Cobol85ParserRULE_alternateRecordKeyClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1833)
		p.Match(Cobol85ParserALTERNATE)
	}
	{
		p.SetState(1834)
		p.Match(Cobol85ParserRECORD)
	}
	p.SetState(1836)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserKEY {
		{
			p.SetState(1835)
			p.Match(Cobol85ParserKEY)
		}

	}
	p.SetState(1839)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(1838)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(1841)
		p.QualifiedDataName()
	}
	p.SetState(1843)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 137, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1842)
			p.PasswordClause()
		}

	}
	p.SetState(1849)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserDUPLICATES || _la == Cobol85ParserWITH {
		p.SetState(1846)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserWITH {
			{
				p.SetState(1845)
				p.Match(Cobol85ParserWITH)
			}

		}
		{
			p.SetState(1848)
			p.Match(Cobol85ParserDUPLICATES)
		}

	}

	return localctx
}

// IPasswordClauseContext is an interface to support dynamic dispatch.
type IPasswordClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPasswordClauseContext differentiates from other interfaces.
	IsPasswordClauseContext()
}

type PasswordClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPasswordClauseContext() *PasswordClauseContext {
	var p = new(PasswordClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_passwordClause
	return p
}

func (*PasswordClauseContext) IsPasswordClauseContext() {}

func NewPasswordClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PasswordClauseContext {
	var p = new(PasswordClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_passwordClause

	return p
}

func (s *PasswordClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *PasswordClauseContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPASSWORD, 0)
}

func (s *PasswordClauseContext) DataName() IDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *PasswordClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *PasswordClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PasswordClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PasswordClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterPasswordClause(s)
	}
}

func (s *PasswordClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitPasswordClause(s)
	}
}

func (p *Cobol85Parser) PasswordClause() (localctx IPasswordClauseContext) {
	localctx = NewPasswordClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, Cobol85ParserRULE_passwordClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1851)
		p.Match(Cobol85ParserPASSWORD)
	}
	p.SetState(1853)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(1852)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(1855)
		p.DataName()
	}

	return localctx
}

// IFileStatusClauseContext is an interface to support dynamic dispatch.
type IFileStatusClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFileStatusClauseContext differentiates from other interfaces.
	IsFileStatusClauseContext()
}

type FileStatusClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFileStatusClauseContext() *FileStatusClauseContext {
	var p = new(FileStatusClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_fileStatusClause
	return p
}

func (*FileStatusClauseContext) IsFileStatusClauseContext() {}

func NewFileStatusClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FileStatusClauseContext {
	var p = new(FileStatusClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_fileStatusClause

	return p
}

func (s *FileStatusClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *FileStatusClauseContext) STATUS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSTATUS, 0)
}

func (s *FileStatusClauseContext) AllQualifiedDataName() []IQualifiedDataNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IQualifiedDataNameContext)(nil)).Elem())
	var tst = make([]IQualifiedDataNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IQualifiedDataNameContext)
		}
	}

	return tst
}

func (s *FileStatusClauseContext) QualifiedDataName(i int) IQualifiedDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedDataNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *FileStatusClauseContext) FILE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFILE, 0)
}

func (s *FileStatusClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *FileStatusClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FileStatusClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FileStatusClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterFileStatusClause(s)
	}
}

func (s *FileStatusClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitFileStatusClause(s)
	}
}

func (p *Cobol85Parser) FileStatusClause() (localctx IFileStatusClauseContext) {
	localctx = NewFileStatusClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, Cobol85ParserRULE_fileStatusClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1858)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFILE {
		{
			p.SetState(1857)
			p.Match(Cobol85ParserFILE)
		}

	}
	{
		p.SetState(1860)
		p.Match(Cobol85ParserSTATUS)
	}
	p.SetState(1862)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(1861)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(1864)
		p.QualifiedDataName()
	}
	p.SetState(1866)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 143, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1865)
			p.QualifiedDataName()
		}

	}

	return localctx
}

// IRelativeKeyClauseContext is an interface to support dynamic dispatch.
type IRelativeKeyClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelativeKeyClauseContext differentiates from other interfaces.
	IsRelativeKeyClauseContext()
}

type RelativeKeyClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelativeKeyClauseContext() *RelativeKeyClauseContext {
	var p = new(RelativeKeyClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_relativeKeyClause
	return p
}

func (*RelativeKeyClauseContext) IsRelativeKeyClauseContext() {}

func NewRelativeKeyClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelativeKeyClauseContext {
	var p = new(RelativeKeyClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_relativeKeyClause

	return p
}

func (s *RelativeKeyClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *RelativeKeyClauseContext) RELATIVE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRELATIVE, 0)
}

func (s *RelativeKeyClauseContext) QualifiedDataName() IQualifiedDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *RelativeKeyClauseContext) KEY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserKEY, 0)
}

func (s *RelativeKeyClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *RelativeKeyClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelativeKeyClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelativeKeyClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterRelativeKeyClause(s)
	}
}

func (s *RelativeKeyClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitRelativeKeyClause(s)
	}
}

func (p *Cobol85Parser) RelativeKeyClause() (localctx IRelativeKeyClauseContext) {
	localctx = NewRelativeKeyClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, Cobol85ParserRULE_relativeKeyClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1868)
		p.Match(Cobol85ParserRELATIVE)
	}
	p.SetState(1870)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserKEY {
		{
			p.SetState(1869)
			p.Match(Cobol85ParserKEY)
		}

	}
	p.SetState(1873)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(1872)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(1875)
		p.QualifiedDataName()
	}

	return localctx
}

// IIoControlParagraphContext is an interface to support dynamic dispatch.
type IIoControlParagraphContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIoControlParagraphContext differentiates from other interfaces.
	IsIoControlParagraphContext()
}

type IoControlParagraphContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIoControlParagraphContext() *IoControlParagraphContext {
	var p = new(IoControlParagraphContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_ioControlParagraph
	return p
}

func (*IoControlParagraphContext) IsIoControlParagraphContext() {}

func NewIoControlParagraphContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IoControlParagraphContext {
	var p = new(IoControlParagraphContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_ioControlParagraph

	return p
}

func (s *IoControlParagraphContext) GetParser() antlr.Parser { return s.parser }

func (s *IoControlParagraphContext) I_O_CONTROL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserI_O_CONTROL, 0)
}

func (s *IoControlParagraphContext) AllDOT_FS() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserDOT_FS)
}

func (s *IoControlParagraphContext) DOT_FS(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, i)
}

func (s *IoControlParagraphContext) FileName() IFileNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *IoControlParagraphContext) AllIoControlClause() []IIoControlClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIoControlClauseContext)(nil)).Elem())
	var tst = make([]IIoControlClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIoControlClauseContext)
		}
	}

	return tst
}

func (s *IoControlParagraphContext) IoControlClause(i int) IIoControlClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIoControlClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIoControlClauseContext)
}

func (s *IoControlParagraphContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IoControlParagraphContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IoControlParagraphContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterIoControlParagraph(s)
	}
}

func (s *IoControlParagraphContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitIoControlParagraph(s)
	}
}

func (p *Cobol85Parser) IoControlParagraph() (localctx IIoControlParagraphContext) {
	localctx = NewIoControlParagraphContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, Cobol85ParserRULE_ioControlParagraph)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1877)
		p.Match(Cobol85ParserI_O_CONTROL)
	}
	{
		p.SetState(1878)
		p.Match(Cobol85ParserDOT_FS)
	}
	p.SetState(1882)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 146, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1879)
			p.FileName()
		}
		{
			p.SetState(1880)
			p.Match(Cobol85ParserDOT_FS)
		}

	}
	p.SetState(1891)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCOMMITMENT || _la == Cobol85ParserMULTIPLE || _la == Cobol85ParserRERUN || _la == Cobol85ParserSAME || _la == Cobol85ParserDOT_FS {
		p.SetState(1887)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == Cobol85ParserCOMMITMENT || _la == Cobol85ParserMULTIPLE || _la == Cobol85ParserRERUN || _la == Cobol85ParserSAME {
			{
				p.SetState(1884)
				p.IoControlClause()
			}

			p.SetState(1889)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1890)
			p.Match(Cobol85ParserDOT_FS)
		}

	}

	return localctx
}

// IIoControlClauseContext is an interface to support dynamic dispatch.
type IIoControlClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIoControlClauseContext differentiates from other interfaces.
	IsIoControlClauseContext()
}

type IoControlClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIoControlClauseContext() *IoControlClauseContext {
	var p = new(IoControlClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_ioControlClause
	return p
}

func (*IoControlClauseContext) IsIoControlClauseContext() {}

func NewIoControlClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IoControlClauseContext {
	var p = new(IoControlClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_ioControlClause

	return p
}

func (s *IoControlClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *IoControlClauseContext) RerunClause() IRerunClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRerunClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRerunClauseContext)
}

func (s *IoControlClauseContext) SameClause() ISameClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISameClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISameClauseContext)
}

func (s *IoControlClauseContext) MultipleFileClause() IMultipleFileClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMultipleFileClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMultipleFileClauseContext)
}

func (s *IoControlClauseContext) CommitmentControlClause() ICommitmentControlClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICommitmentControlClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICommitmentControlClauseContext)
}

func (s *IoControlClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IoControlClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IoControlClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterIoControlClause(s)
	}
}

func (s *IoControlClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitIoControlClause(s)
	}
}

func (p *Cobol85Parser) IoControlClause() (localctx IIoControlClauseContext) {
	localctx = NewIoControlClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, Cobol85ParserRULE_ioControlClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1897)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserRERUN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1893)
			p.RerunClause()
		}

	case Cobol85ParserSAME:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1894)
			p.SameClause()
		}

	case Cobol85ParserMULTIPLE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1895)
			p.MultipleFileClause()
		}

	case Cobol85ParserCOMMITMENT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1896)
			p.CommitmentControlClause()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IRerunClauseContext is an interface to support dynamic dispatch.
type IRerunClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRerunClauseContext differentiates from other interfaces.
	IsRerunClauseContext()
}

type RerunClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRerunClauseContext() *RerunClauseContext {
	var p = new(RerunClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_rerunClause
	return p
}

func (*RerunClauseContext) IsRerunClauseContext() {}

func NewRerunClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RerunClauseContext {
	var p = new(RerunClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_rerunClause

	return p
}

func (s *RerunClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *RerunClauseContext) RERUN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRERUN, 0)
}

func (s *RerunClauseContext) EVERY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEVERY, 0)
}

func (s *RerunClauseContext) RerunEveryRecords() IRerunEveryRecordsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRerunEveryRecordsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRerunEveryRecordsContext)
}

func (s *RerunClauseContext) RerunEveryOf() IRerunEveryOfContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRerunEveryOfContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRerunEveryOfContext)
}

func (s *RerunClauseContext) RerunEveryClock() IRerunEveryClockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRerunEveryClockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRerunEveryClockContext)
}

func (s *RerunClauseContext) ON() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserON, 0)
}

func (s *RerunClauseContext) AssignmentName() IAssignmentNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignmentNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignmentNameContext)
}

func (s *RerunClauseContext) FileName() IFileNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *RerunClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RerunClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RerunClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterRerunClause(s)
	}
}

func (s *RerunClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitRerunClause(s)
	}
}

func (p *Cobol85Parser) RerunClause() (localctx IRerunClauseContext) {
	localctx = NewRerunClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, Cobol85ParserRULE_rerunClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1899)
		p.Match(Cobol85ParserRERUN)
	}
	p.SetState(1905)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserON {
		{
			p.SetState(1900)
			p.Match(Cobol85ParserON)
		}
		p.SetState(1903)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 150, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1901)
				p.AssignmentName()
			}

		case 2:
			{
				p.SetState(1902)
				p.FileName()
			}

		}

	}
	{
		p.SetState(1907)
		p.Match(Cobol85ParserEVERY)
	}
	p.SetState(1911)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 152, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1908)
			p.RerunEveryRecords()
		}

	case 2:
		{
			p.SetState(1909)
			p.RerunEveryOf()
		}

	case 3:
		{
			p.SetState(1910)
			p.RerunEveryClock()
		}

	}

	return localctx
}

// IRerunEveryRecordsContext is an interface to support dynamic dispatch.
type IRerunEveryRecordsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRerunEveryRecordsContext differentiates from other interfaces.
	IsRerunEveryRecordsContext()
}

type RerunEveryRecordsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRerunEveryRecordsContext() *RerunEveryRecordsContext {
	var p = new(RerunEveryRecordsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_rerunEveryRecords
	return p
}

func (*RerunEveryRecordsContext) IsRerunEveryRecordsContext() {}

func NewRerunEveryRecordsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RerunEveryRecordsContext {
	var p = new(RerunEveryRecordsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_rerunEveryRecords

	return p
}

func (s *RerunEveryRecordsContext) GetParser() antlr.Parser { return s.parser }

func (s *RerunEveryRecordsContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *RerunEveryRecordsContext) RECORDS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRECORDS, 0)
}

func (s *RerunEveryRecordsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RerunEveryRecordsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RerunEveryRecordsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterRerunEveryRecords(s)
	}
}

func (s *RerunEveryRecordsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitRerunEveryRecords(s)
	}
}

func (p *Cobol85Parser) RerunEveryRecords() (localctx IRerunEveryRecordsContext) {
	localctx = NewRerunEveryRecordsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, Cobol85ParserRULE_rerunEveryRecords)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1913)
		p.IntegerLiteral()
	}
	{
		p.SetState(1914)
		p.Match(Cobol85ParserRECORDS)
	}

	return localctx
}

// IRerunEveryOfContext is an interface to support dynamic dispatch.
type IRerunEveryOfContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRerunEveryOfContext differentiates from other interfaces.
	IsRerunEveryOfContext()
}

type RerunEveryOfContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRerunEveryOfContext() *RerunEveryOfContext {
	var p = new(RerunEveryOfContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_rerunEveryOf
	return p
}

func (*RerunEveryOfContext) IsRerunEveryOfContext() {}

func NewRerunEveryOfContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RerunEveryOfContext {
	var p = new(RerunEveryOfContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_rerunEveryOf

	return p
}

func (s *RerunEveryOfContext) GetParser() antlr.Parser { return s.parser }

func (s *RerunEveryOfContext) AllOF() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserOF)
}

func (s *RerunEveryOfContext) OF(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOF, i)
}

func (s *RerunEveryOfContext) FileName() IFileNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *RerunEveryOfContext) REEL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREEL, 0)
}

func (s *RerunEveryOfContext) UNIT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserUNIT, 0)
}

func (s *RerunEveryOfContext) END() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND, 0)
}

func (s *RerunEveryOfContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RerunEveryOfContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RerunEveryOfContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterRerunEveryOf(s)
	}
}

func (s *RerunEveryOfContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitRerunEveryOf(s)
	}
}

func (p *Cobol85Parser) RerunEveryOf() (localctx IRerunEveryOfContext) {
	localctx = NewRerunEveryOfContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, Cobol85ParserRULE_rerunEveryOf)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1917)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserEND {
		{
			p.SetState(1916)
			p.Match(Cobol85ParserEND)
		}

	}
	p.SetState(1920)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserOF {
		{
			p.SetState(1919)
			p.Match(Cobol85ParserOF)
		}

	}
	{
		p.SetState(1922)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserREEL || _la == Cobol85ParserUNIT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1923)
		p.Match(Cobol85ParserOF)
	}
	{
		p.SetState(1924)
		p.FileName()
	}

	return localctx
}

// IRerunEveryClockContext is an interface to support dynamic dispatch.
type IRerunEveryClockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRerunEveryClockContext differentiates from other interfaces.
	IsRerunEveryClockContext()
}

type RerunEveryClockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRerunEveryClockContext() *RerunEveryClockContext {
	var p = new(RerunEveryClockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_rerunEveryClock
	return p
}

func (*RerunEveryClockContext) IsRerunEveryClockContext() {}

func NewRerunEveryClockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RerunEveryClockContext {
	var p = new(RerunEveryClockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_rerunEveryClock

	return p
}

func (s *RerunEveryClockContext) GetParser() antlr.Parser { return s.parser }

func (s *RerunEveryClockContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *RerunEveryClockContext) CLOCK_UNITS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCLOCK_UNITS, 0)
}

func (s *RerunEveryClockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RerunEveryClockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RerunEveryClockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterRerunEveryClock(s)
	}
}

func (s *RerunEveryClockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitRerunEveryClock(s)
	}
}

func (p *Cobol85Parser) RerunEveryClock() (localctx IRerunEveryClockContext) {
	localctx = NewRerunEveryClockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, Cobol85ParserRULE_rerunEveryClock)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1926)
		p.IntegerLiteral()
	}
	p.SetState(1928)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCLOCK_UNITS {
		{
			p.SetState(1927)
			p.Match(Cobol85ParserCLOCK_UNITS)
		}

	}

	return localctx
}

// ISameClauseContext is an interface to support dynamic dispatch.
type ISameClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSameClauseContext differentiates from other interfaces.
	IsSameClauseContext()
}

type SameClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySameClauseContext() *SameClauseContext {
	var p = new(SameClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sameClause
	return p
}

func (*SameClauseContext) IsSameClauseContext() {}

func NewSameClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SameClauseContext {
	var p = new(SameClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sameClause

	return p
}

func (s *SameClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SameClauseContext) SAME() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSAME, 0)
}

func (s *SameClauseContext) AREA() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAREA, 0)
}

func (s *SameClauseContext) FOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOR, 0)
}

func (s *SameClauseContext) AllFileName() []IFileNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFileNameContext)(nil)).Elem())
	var tst = make([]IFileNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFileNameContext)
		}
	}

	return tst
}

func (s *SameClauseContext) FileName(i int) IFileNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *SameClauseContext) RECORD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRECORD, 0)
}

func (s *SameClauseContext) SORT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSORT, 0)
}

func (s *SameClauseContext) SORT_MERGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSORT_MERGE, 0)
}

func (s *SameClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SameClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SameClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSameClause(s)
	}
}

func (s *SameClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSameClause(s)
	}
}

func (p *Cobol85Parser) SameClause() (localctx ISameClauseContext) {
	localctx = NewSameClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, Cobol85ParserRULE_sameClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1930)
		p.Match(Cobol85ParserSAME)
	}
	p.SetState(1932)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserRECORD || _la == Cobol85ParserSORT || _la == Cobol85ParserSORT_MERGE {
		{
			p.SetState(1931)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85ParserRECORD || _la == Cobol85ParserSORT || _la == Cobol85ParserSORT_MERGE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(1935)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserAREA {
		{
			p.SetState(1934)
			p.Match(Cobol85ParserAREA)
		}

	}
	p.SetState(1938)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFOR {
		{
			p.SetState(1937)
			p.Match(Cobol85ParserFOR)
		}

	}
	p.SetState(1941)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1940)
				p.FileName()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(1943)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 159, p.GetParserRuleContext())
	}

	return localctx
}

// IMultipleFileClauseContext is an interface to support dynamic dispatch.
type IMultipleFileClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMultipleFileClauseContext differentiates from other interfaces.
	IsMultipleFileClauseContext()
}

type MultipleFileClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultipleFileClauseContext() *MultipleFileClauseContext {
	var p = new(MultipleFileClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_multipleFileClause
	return p
}

func (*MultipleFileClauseContext) IsMultipleFileClauseContext() {}

func NewMultipleFileClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultipleFileClauseContext {
	var p = new(MultipleFileClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_multipleFileClause

	return p
}

func (s *MultipleFileClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *MultipleFileClauseContext) MULTIPLE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMULTIPLE, 0)
}

func (s *MultipleFileClauseContext) FILE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFILE, 0)
}

func (s *MultipleFileClauseContext) TAPE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTAPE, 0)
}

func (s *MultipleFileClauseContext) CONTAINS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCONTAINS, 0)
}

func (s *MultipleFileClauseContext) AllMultipleFilePosition() []IMultipleFilePositionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMultipleFilePositionContext)(nil)).Elem())
	var tst = make([]IMultipleFilePositionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMultipleFilePositionContext)
		}
	}

	return tst
}

func (s *MultipleFileClauseContext) MultipleFilePosition(i int) IMultipleFilePositionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMultipleFilePositionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMultipleFilePositionContext)
}

func (s *MultipleFileClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultipleFileClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultipleFileClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMultipleFileClause(s)
	}
}

func (s *MultipleFileClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMultipleFileClause(s)
	}
}

func (p *Cobol85Parser) MultipleFileClause() (localctx IMultipleFileClauseContext) {
	localctx = NewMultipleFileClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, Cobol85ParserRULE_multipleFileClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1945)
		p.Match(Cobol85ParserMULTIPLE)
	}
	{
		p.SetState(1946)
		p.Match(Cobol85ParserFILE)
	}
	p.SetState(1948)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserTAPE {
		{
			p.SetState(1947)
			p.Match(Cobol85ParserTAPE)
		}

	}
	p.SetState(1951)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCONTAINS {
		{
			p.SetState(1950)
			p.Match(Cobol85ParserCONTAINS)
		}

	}
	p.SetState(1954)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1953)
				p.MultipleFilePosition()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(1956)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 162, p.GetParserRuleContext())
	}

	return localctx
}

// IMultipleFilePositionContext is an interface to support dynamic dispatch.
type IMultipleFilePositionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMultipleFilePositionContext differentiates from other interfaces.
	IsMultipleFilePositionContext()
}

type MultipleFilePositionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultipleFilePositionContext() *MultipleFilePositionContext {
	var p = new(MultipleFilePositionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_multipleFilePosition
	return p
}

func (*MultipleFilePositionContext) IsMultipleFilePositionContext() {}

func NewMultipleFilePositionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultipleFilePositionContext {
	var p = new(MultipleFilePositionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_multipleFilePosition

	return p
}

func (s *MultipleFilePositionContext) GetParser() antlr.Parser { return s.parser }

func (s *MultipleFilePositionContext) FileName() IFileNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *MultipleFilePositionContext) POSITION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPOSITION, 0)
}

func (s *MultipleFilePositionContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *MultipleFilePositionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultipleFilePositionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultipleFilePositionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMultipleFilePosition(s)
	}
}

func (s *MultipleFilePositionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMultipleFilePosition(s)
	}
}

func (p *Cobol85Parser) MultipleFilePosition() (localctx IMultipleFilePositionContext) {
	localctx = NewMultipleFilePositionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, Cobol85ParserRULE_multipleFilePosition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1958)
		p.FileName()
	}
	p.SetState(1961)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserPOSITION {
		{
			p.SetState(1959)
			p.Match(Cobol85ParserPOSITION)
		}
		{
			p.SetState(1960)
			p.IntegerLiteral()
		}

	}

	return localctx
}

// ICommitmentControlClauseContext is an interface to support dynamic dispatch.
type ICommitmentControlClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCommitmentControlClauseContext differentiates from other interfaces.
	IsCommitmentControlClauseContext()
}

type CommitmentControlClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommitmentControlClauseContext() *CommitmentControlClauseContext {
	var p = new(CommitmentControlClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_commitmentControlClause
	return p
}

func (*CommitmentControlClauseContext) IsCommitmentControlClauseContext() {}

func NewCommitmentControlClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommitmentControlClauseContext {
	var p = new(CommitmentControlClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_commitmentControlClause

	return p
}

func (s *CommitmentControlClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CommitmentControlClauseContext) COMMITMENT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMMITMENT, 0)
}

func (s *CommitmentControlClauseContext) CONTROL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCONTROL, 0)
}

func (s *CommitmentControlClauseContext) FileName() IFileNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *CommitmentControlClauseContext) FOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOR, 0)
}

func (s *CommitmentControlClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommitmentControlClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommitmentControlClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCommitmentControlClause(s)
	}
}

func (s *CommitmentControlClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCommitmentControlClause(s)
	}
}

func (p *Cobol85Parser) CommitmentControlClause() (localctx ICommitmentControlClauseContext) {
	localctx = NewCommitmentControlClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, Cobol85ParserRULE_commitmentControlClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1963)
		p.Match(Cobol85ParserCOMMITMENT)
	}
	{
		p.SetState(1964)
		p.Match(Cobol85ParserCONTROL)
	}
	p.SetState(1966)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFOR {
		{
			p.SetState(1965)
			p.Match(Cobol85ParserFOR)
		}

	}
	{
		p.SetState(1968)
		p.FileName()
	}

	return localctx
}

// IDataDivisionContext is an interface to support dynamic dispatch.
type IDataDivisionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataDivisionContext differentiates from other interfaces.
	IsDataDivisionContext()
}

type DataDivisionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataDivisionContext() *DataDivisionContext {
	var p = new(DataDivisionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataDivision
	return p
}

func (*DataDivisionContext) IsDataDivisionContext() {}

func NewDataDivisionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataDivisionContext {
	var p = new(DataDivisionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataDivision

	return p
}

func (s *DataDivisionContext) GetParser() antlr.Parser { return s.parser }

func (s *DataDivisionContext) DATA() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDATA, 0)
}

func (s *DataDivisionContext) DIVISION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDIVISION, 0)
}

func (s *DataDivisionContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *DataDivisionContext) AllDataDivisionSection() []IDataDivisionSectionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDataDivisionSectionContext)(nil)).Elem())
	var tst = make([]IDataDivisionSectionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDataDivisionSectionContext)
		}
	}

	return tst
}

func (s *DataDivisionContext) DataDivisionSection(i int) IDataDivisionSectionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataDivisionSectionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDataDivisionSectionContext)
}

func (s *DataDivisionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataDivisionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataDivisionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataDivision(s)
	}
}

func (s *DataDivisionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataDivision(s)
	}
}

func (p *Cobol85Parser) DataDivision() (localctx IDataDivisionContext) {
	localctx = NewDataDivisionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, Cobol85ParserRULE_dataDivision)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1970)
		p.Match(Cobol85ParserDATA)
	}
	{
		p.SetState(1971)
		p.Match(Cobol85ParserDIVISION)
	}
	{
		p.SetState(1972)
		p.Match(Cobol85ParserDOT_FS)
	}
	p.SetState(1976)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserCOMMUNICATION || _la == Cobol85ParserDATA_BASE || _la == Cobol85ParserFILE || _la == Cobol85ParserLINKAGE || _la == Cobol85ParserLOCAL_STORAGE || _la == Cobol85ParserPROGRAM_LIBRARY || _la == Cobol85ParserREPORT || _la == Cobol85ParserSCREEN || _la == Cobol85ParserWORKING_STORAGE {
		{
			p.SetState(1973)
			p.DataDivisionSection()
		}

		p.SetState(1978)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IDataDivisionSectionContext is an interface to support dynamic dispatch.
type IDataDivisionSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataDivisionSectionContext differentiates from other interfaces.
	IsDataDivisionSectionContext()
}

type DataDivisionSectionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataDivisionSectionContext() *DataDivisionSectionContext {
	var p = new(DataDivisionSectionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataDivisionSection
	return p
}

func (*DataDivisionSectionContext) IsDataDivisionSectionContext() {}

func NewDataDivisionSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataDivisionSectionContext {
	var p = new(DataDivisionSectionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataDivisionSection

	return p
}

func (s *DataDivisionSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *DataDivisionSectionContext) FileSection() IFileSectionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileSectionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFileSectionContext)
}

func (s *DataDivisionSectionContext) DataBaseSection() IDataBaseSectionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataBaseSectionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataBaseSectionContext)
}

func (s *DataDivisionSectionContext) WorkingStorageSection() IWorkingStorageSectionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWorkingStorageSectionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWorkingStorageSectionContext)
}

func (s *DataDivisionSectionContext) LinkageSection() ILinkageSectionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILinkageSectionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILinkageSectionContext)
}

func (s *DataDivisionSectionContext) CommunicationSection() ICommunicationSectionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICommunicationSectionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICommunicationSectionContext)
}

func (s *DataDivisionSectionContext) LocalStorageSection() ILocalStorageSectionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILocalStorageSectionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILocalStorageSectionContext)
}

func (s *DataDivisionSectionContext) ScreenSection() IScreenSectionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScreenSectionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IScreenSectionContext)
}

func (s *DataDivisionSectionContext) ReportSection() IReportSectionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportSectionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReportSectionContext)
}

func (s *DataDivisionSectionContext) ProgramLibrarySection() IProgramLibrarySectionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProgramLibrarySectionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProgramLibrarySectionContext)
}

func (s *DataDivisionSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataDivisionSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataDivisionSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataDivisionSection(s)
	}
}

func (s *DataDivisionSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataDivisionSection(s)
	}
}

func (p *Cobol85Parser) DataDivisionSection() (localctx IDataDivisionSectionContext) {
	localctx = NewDataDivisionSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, Cobol85ParserRULE_dataDivisionSection)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1988)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserFILE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1979)
			p.FileSection()
		}

	case Cobol85ParserDATA_BASE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1980)
			p.DataBaseSection()
		}

	case Cobol85ParserWORKING_STORAGE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1981)
			p.WorkingStorageSection()
		}

	case Cobol85ParserLINKAGE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1982)
			p.LinkageSection()
		}

	case Cobol85ParserCOMMUNICATION:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1983)
			p.CommunicationSection()
		}

	case Cobol85ParserLOCAL_STORAGE:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1984)
			p.LocalStorageSection()
		}

	case Cobol85ParserSCREEN:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1985)
			p.ScreenSection()
		}

	case Cobol85ParserREPORT:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1986)
			p.ReportSection()
		}

	case Cobol85ParserPROGRAM_LIBRARY:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1987)
			p.ProgramLibrarySection()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFileSectionContext is an interface to support dynamic dispatch.
type IFileSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFileSectionContext differentiates from other interfaces.
	IsFileSectionContext()
}

type FileSectionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFileSectionContext() *FileSectionContext {
	var p = new(FileSectionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_fileSection
	return p
}

func (*FileSectionContext) IsFileSectionContext() {}

func NewFileSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FileSectionContext {
	var p = new(FileSectionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_fileSection

	return p
}

func (s *FileSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *FileSectionContext) FILE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFILE, 0)
}

func (s *FileSectionContext) SECTION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSECTION, 0)
}

func (s *FileSectionContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *FileSectionContext) AllFileDescriptionEntry() []IFileDescriptionEntryContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFileDescriptionEntryContext)(nil)).Elem())
	var tst = make([]IFileDescriptionEntryContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFileDescriptionEntryContext)
		}
	}

	return tst
}

func (s *FileSectionContext) FileDescriptionEntry(i int) IFileDescriptionEntryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileDescriptionEntryContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFileDescriptionEntryContext)
}

func (s *FileSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FileSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FileSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterFileSection(s)
	}
}

func (s *FileSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitFileSection(s)
	}
}

func (p *Cobol85Parser) FileSection() (localctx IFileSectionContext) {
	localctx = NewFileSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, Cobol85ParserRULE_fileSection)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1990)
		p.Match(Cobol85ParserFILE)
	}
	{
		p.SetState(1991)
		p.Match(Cobol85ParserSECTION)
	}
	{
		p.SetState(1992)
		p.Match(Cobol85ParserDOT_FS)
	}
	p.SetState(1996)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserFD || _la == Cobol85ParserSD {
		{
			p.SetState(1993)
			p.FileDescriptionEntry()
		}

		p.SetState(1998)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IFileDescriptionEntryContext is an interface to support dynamic dispatch.
type IFileDescriptionEntryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFileDescriptionEntryContext differentiates from other interfaces.
	IsFileDescriptionEntryContext()
}

type FileDescriptionEntryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFileDescriptionEntryContext() *FileDescriptionEntryContext {
	var p = new(FileDescriptionEntryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_fileDescriptionEntry
	return p
}

func (*FileDescriptionEntryContext) IsFileDescriptionEntryContext() {}

func NewFileDescriptionEntryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FileDescriptionEntryContext {
	var p = new(FileDescriptionEntryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_fileDescriptionEntry

	return p
}

func (s *FileDescriptionEntryContext) GetParser() antlr.Parser { return s.parser }

func (s *FileDescriptionEntryContext) FileName() IFileNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *FileDescriptionEntryContext) AllDOT_FS() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserDOT_FS)
}

func (s *FileDescriptionEntryContext) DOT_FS(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, i)
}

func (s *FileDescriptionEntryContext) FD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFD, 0)
}

func (s *FileDescriptionEntryContext) SD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSD, 0)
}

func (s *FileDescriptionEntryContext) AllFileDescriptionEntryClause() []IFileDescriptionEntryClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFileDescriptionEntryClauseContext)(nil)).Elem())
	var tst = make([]IFileDescriptionEntryClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFileDescriptionEntryClauseContext)
		}
	}

	return tst
}

func (s *FileDescriptionEntryContext) FileDescriptionEntryClause(i int) IFileDescriptionEntryClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileDescriptionEntryClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFileDescriptionEntryClauseContext)
}

func (s *FileDescriptionEntryContext) AllDataDescriptionEntry() []IDataDescriptionEntryContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDataDescriptionEntryContext)(nil)).Elem())
	var tst = make([]IDataDescriptionEntryContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDataDescriptionEntryContext)
		}
	}

	return tst
}

func (s *FileDescriptionEntryContext) DataDescriptionEntry(i int) IDataDescriptionEntryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataDescriptionEntryContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDataDescriptionEntryContext)
}

func (s *FileDescriptionEntryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FileDescriptionEntryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FileDescriptionEntryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterFileDescriptionEntry(s)
	}
}

func (s *FileDescriptionEntryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitFileDescriptionEntry(s)
	}
}

func (p *Cobol85Parser) FileDescriptionEntry() (localctx IFileDescriptionEntryContext) {
	localctx = NewFileDescriptionEntryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, Cobol85ParserRULE_fileDescriptionEntry)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1999)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserFD || _la == Cobol85ParserSD) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(2000)
		p.FileName()
	}
	p.SetState(2007)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 169, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(2002)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == Cobol85ParserDOT_FS {
				{
					p.SetState(2001)
					p.Match(Cobol85ParserDOT_FS)
				}

			}
			{
				p.SetState(2004)
				p.FileDescriptionEntryClause()
			}

		}
		p.SetState(2009)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 169, p.GetParserRuleContext())
	}
	{
		p.SetState(2010)
		p.Match(Cobol85ParserDOT_FS)
	}
	p.SetState(2014)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ((_la-552)&-(0x1f+1)) == 0 && ((1<<uint((_la-552)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-552))|(1<<(Cobol85ParserLEVEL_NUMBER_77-552))|(1<<(Cobol85ParserLEVEL_NUMBER_88-552))|(1<<(Cobol85ParserINTEGERLITERAL-552))|(1<<(Cobol85ParserEXECSQLLINE-552)))) != 0 {
		{
			p.SetState(2011)
			p.DataDescriptionEntry()
		}

		p.SetState(2016)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IFileDescriptionEntryClauseContext is an interface to support dynamic dispatch.
type IFileDescriptionEntryClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFileDescriptionEntryClauseContext differentiates from other interfaces.
	IsFileDescriptionEntryClauseContext()
}

type FileDescriptionEntryClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFileDescriptionEntryClauseContext() *FileDescriptionEntryClauseContext {
	var p = new(FileDescriptionEntryClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_fileDescriptionEntryClause
	return p
}

func (*FileDescriptionEntryClauseContext) IsFileDescriptionEntryClauseContext() {}

func NewFileDescriptionEntryClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FileDescriptionEntryClauseContext {
	var p = new(FileDescriptionEntryClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_fileDescriptionEntryClause

	return p
}

func (s *FileDescriptionEntryClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *FileDescriptionEntryClauseContext) ExternalClause() IExternalClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExternalClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExternalClauseContext)
}

func (s *FileDescriptionEntryClauseContext) GlobalClause() IGlobalClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGlobalClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGlobalClauseContext)
}

func (s *FileDescriptionEntryClauseContext) BlockContainsClause() IBlockContainsClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContainsClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContainsClauseContext)
}

func (s *FileDescriptionEntryClauseContext) RecordContainsClause() IRecordContainsClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRecordContainsClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRecordContainsClauseContext)
}

func (s *FileDescriptionEntryClauseContext) LabelRecordsClause() ILabelRecordsClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabelRecordsClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabelRecordsClauseContext)
}

func (s *FileDescriptionEntryClauseContext) ValueOfClause() IValueOfClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueOfClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueOfClauseContext)
}

func (s *FileDescriptionEntryClauseContext) DataRecordsClause() IDataRecordsClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataRecordsClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataRecordsClauseContext)
}

func (s *FileDescriptionEntryClauseContext) LinageClause() ILinageClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILinageClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILinageClauseContext)
}

func (s *FileDescriptionEntryClauseContext) CodeSetClause() ICodeSetClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICodeSetClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICodeSetClauseContext)
}

func (s *FileDescriptionEntryClauseContext) ReportClause() IReportClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReportClauseContext)
}

func (s *FileDescriptionEntryClauseContext) RecordingModeClause() IRecordingModeClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRecordingModeClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRecordingModeClauseContext)
}

func (s *FileDescriptionEntryClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FileDescriptionEntryClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FileDescriptionEntryClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterFileDescriptionEntryClause(s)
	}
}

func (s *FileDescriptionEntryClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitFileDescriptionEntryClause(s)
	}
}

func (p *Cobol85Parser) FileDescriptionEntryClause() (localctx IFileDescriptionEntryClauseContext) {
	localctx = NewFileDescriptionEntryClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, Cobol85ParserRULE_fileDescriptionEntryClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2028)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 171, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2017)
			p.ExternalClause()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2018)
			p.GlobalClause()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2019)
			p.BlockContainsClause()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2020)
			p.RecordContainsClause()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2021)
			p.LabelRecordsClause()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2022)
			p.ValueOfClause()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2023)
			p.DataRecordsClause()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(2024)
			p.LinageClause()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(2025)
			p.CodeSetClause()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(2026)
			p.ReportClause()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(2027)
			p.RecordingModeClause()
		}

	}

	return localctx
}

// IExternalClauseContext is an interface to support dynamic dispatch.
type IExternalClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExternalClauseContext differentiates from other interfaces.
	IsExternalClauseContext()
}

type ExternalClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExternalClauseContext() *ExternalClauseContext {
	var p = new(ExternalClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_externalClause
	return p
}

func (*ExternalClauseContext) IsExternalClauseContext() {}

func NewExternalClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExternalClauseContext {
	var p = new(ExternalClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_externalClause

	return p
}

func (s *ExternalClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ExternalClauseContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEXTERNAL, 0)
}

func (s *ExternalClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ExternalClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExternalClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExternalClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterExternalClause(s)
	}
}

func (s *ExternalClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitExternalClause(s)
	}
}

func (p *Cobol85Parser) ExternalClause() (localctx IExternalClauseContext) {
	localctx = NewExternalClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, Cobol85ParserRULE_externalClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2031)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2030)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(2033)
		p.Match(Cobol85ParserEXTERNAL)
	}

	return localctx
}

// IGlobalClauseContext is an interface to support dynamic dispatch.
type IGlobalClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGlobalClauseContext differentiates from other interfaces.
	IsGlobalClauseContext()
}

type GlobalClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGlobalClauseContext() *GlobalClauseContext {
	var p = new(GlobalClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_globalClause
	return p
}

func (*GlobalClauseContext) IsGlobalClauseContext() {}

func NewGlobalClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GlobalClauseContext {
	var p = new(GlobalClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_globalClause

	return p
}

func (s *GlobalClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *GlobalClauseContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserGLOBAL, 0)
}

func (s *GlobalClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *GlobalClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GlobalClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GlobalClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterGlobalClause(s)
	}
}

func (s *GlobalClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitGlobalClause(s)
	}
}

func (p *Cobol85Parser) GlobalClause() (localctx IGlobalClauseContext) {
	localctx = NewGlobalClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, Cobol85ParserRULE_globalClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2036)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2035)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(2038)
		p.Match(Cobol85ParserGLOBAL)
	}

	return localctx
}

// IBlockContainsClauseContext is an interface to support dynamic dispatch.
type IBlockContainsClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlockContainsClauseContext differentiates from other interfaces.
	IsBlockContainsClauseContext()
}

type BlockContainsClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockContainsClauseContext() *BlockContainsClauseContext {
	var p = new(BlockContainsClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_blockContainsClause
	return p
}

func (*BlockContainsClauseContext) IsBlockContainsClauseContext() {}

func NewBlockContainsClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockContainsClauseContext {
	var p = new(BlockContainsClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_blockContainsClause

	return p
}

func (s *BlockContainsClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockContainsClauseContext) BLOCK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBLOCK, 0)
}

func (s *BlockContainsClauseContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *BlockContainsClauseContext) CONTAINS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCONTAINS, 0)
}

func (s *BlockContainsClauseContext) BlockContainsTo() IBlockContainsToContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContainsToContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContainsToContext)
}

func (s *BlockContainsClauseContext) RECORDS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRECORDS, 0)
}

func (s *BlockContainsClauseContext) CHARACTERS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCHARACTERS, 0)
}

func (s *BlockContainsClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockContainsClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockContainsClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterBlockContainsClause(s)
	}
}

func (s *BlockContainsClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitBlockContainsClause(s)
	}
}

func (p *Cobol85Parser) BlockContainsClause() (localctx IBlockContainsClauseContext) {
	localctx = NewBlockContainsClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, Cobol85ParserRULE_blockContainsClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2040)
		p.Match(Cobol85ParserBLOCK)
	}
	p.SetState(2042)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCONTAINS {
		{
			p.SetState(2041)
			p.Match(Cobol85ParserCONTAINS)
		}

	}
	{
		p.SetState(2044)
		p.IntegerLiteral()
	}
	p.SetState(2046)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserTO {
		{
			p.SetState(2045)
			p.BlockContainsTo()
		}

	}
	p.SetState(2049)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCHARACTERS || _la == Cobol85ParserRECORDS {
		{
			p.SetState(2048)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85ParserCHARACTERS || _la == Cobol85ParserRECORDS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

	return localctx
}

// IBlockContainsToContext is an interface to support dynamic dispatch.
type IBlockContainsToContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlockContainsToContext differentiates from other interfaces.
	IsBlockContainsToContext()
}

type BlockContainsToContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockContainsToContext() *BlockContainsToContext {
	var p = new(BlockContainsToContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_blockContainsTo
	return p
}

func (*BlockContainsToContext) IsBlockContainsToContext() {}

func NewBlockContainsToContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockContainsToContext {
	var p = new(BlockContainsToContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_blockContainsTo

	return p
}

func (s *BlockContainsToContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockContainsToContext) TO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTO, 0)
}

func (s *BlockContainsToContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *BlockContainsToContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockContainsToContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockContainsToContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterBlockContainsTo(s)
	}
}

func (s *BlockContainsToContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitBlockContainsTo(s)
	}
}

func (p *Cobol85Parser) BlockContainsTo() (localctx IBlockContainsToContext) {
	localctx = NewBlockContainsToContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, Cobol85ParserRULE_blockContainsTo)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2051)
		p.Match(Cobol85ParserTO)
	}
	{
		p.SetState(2052)
		p.IntegerLiteral()
	}

	return localctx
}

// IRecordContainsClauseContext is an interface to support dynamic dispatch.
type IRecordContainsClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRecordContainsClauseContext differentiates from other interfaces.
	IsRecordContainsClauseContext()
}

type RecordContainsClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordContainsClauseContext() *RecordContainsClauseContext {
	var p = new(RecordContainsClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_recordContainsClause
	return p
}

func (*RecordContainsClauseContext) IsRecordContainsClauseContext() {}

func NewRecordContainsClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordContainsClauseContext {
	var p = new(RecordContainsClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_recordContainsClause

	return p
}

func (s *RecordContainsClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordContainsClauseContext) RECORD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRECORD, 0)
}

func (s *RecordContainsClauseContext) RecordContainsClauseFormat1() IRecordContainsClauseFormat1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRecordContainsClauseFormat1Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRecordContainsClauseFormat1Context)
}

func (s *RecordContainsClauseContext) RecordContainsClauseFormat2() IRecordContainsClauseFormat2Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRecordContainsClauseFormat2Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRecordContainsClauseFormat2Context)
}

func (s *RecordContainsClauseContext) RecordContainsClauseFormat3() IRecordContainsClauseFormat3Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRecordContainsClauseFormat3Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRecordContainsClauseFormat3Context)
}

func (s *RecordContainsClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordContainsClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordContainsClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterRecordContainsClause(s)
	}
}

func (s *RecordContainsClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitRecordContainsClause(s)
	}
}

func (p *Cobol85Parser) RecordContainsClause() (localctx IRecordContainsClauseContext) {
	localctx = NewRecordContainsClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, Cobol85ParserRULE_recordContainsClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2054)
		p.Match(Cobol85ParserRECORD)
	}
	p.SetState(2058)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 177, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2055)
			p.RecordContainsClauseFormat1()
		}

	case 2:
		{
			p.SetState(2056)
			p.RecordContainsClauseFormat2()
		}

	case 3:
		{
			p.SetState(2057)
			p.RecordContainsClauseFormat3()
		}

	}

	return localctx
}

// IRecordContainsClauseFormat1Context is an interface to support dynamic dispatch.
type IRecordContainsClauseFormat1Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRecordContainsClauseFormat1Context differentiates from other interfaces.
	IsRecordContainsClauseFormat1Context()
}

type RecordContainsClauseFormat1Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordContainsClauseFormat1Context() *RecordContainsClauseFormat1Context {
	var p = new(RecordContainsClauseFormat1Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_recordContainsClauseFormat1
	return p
}

func (*RecordContainsClauseFormat1Context) IsRecordContainsClauseFormat1Context() {}

func NewRecordContainsClauseFormat1Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordContainsClauseFormat1Context {
	var p = new(RecordContainsClauseFormat1Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_recordContainsClauseFormat1

	return p
}

func (s *RecordContainsClauseFormat1Context) GetParser() antlr.Parser { return s.parser }

func (s *RecordContainsClauseFormat1Context) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *RecordContainsClauseFormat1Context) CONTAINS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCONTAINS, 0)
}

func (s *RecordContainsClauseFormat1Context) CHARACTERS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCHARACTERS, 0)
}

func (s *RecordContainsClauseFormat1Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordContainsClauseFormat1Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordContainsClauseFormat1Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterRecordContainsClauseFormat1(s)
	}
}

func (s *RecordContainsClauseFormat1Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitRecordContainsClauseFormat1(s)
	}
}

func (p *Cobol85Parser) RecordContainsClauseFormat1() (localctx IRecordContainsClauseFormat1Context) {
	localctx = NewRecordContainsClauseFormat1Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, Cobol85ParserRULE_recordContainsClauseFormat1)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2061)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCONTAINS {
		{
			p.SetState(2060)
			p.Match(Cobol85ParserCONTAINS)
		}

	}
	{
		p.SetState(2063)
		p.IntegerLiteral()
	}
	p.SetState(2065)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCHARACTERS {
		{
			p.SetState(2064)
			p.Match(Cobol85ParserCHARACTERS)
		}

	}

	return localctx
}

// IRecordContainsClauseFormat2Context is an interface to support dynamic dispatch.
type IRecordContainsClauseFormat2Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRecordContainsClauseFormat2Context differentiates from other interfaces.
	IsRecordContainsClauseFormat2Context()
}

type RecordContainsClauseFormat2Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordContainsClauseFormat2Context() *RecordContainsClauseFormat2Context {
	var p = new(RecordContainsClauseFormat2Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_recordContainsClauseFormat2
	return p
}

func (*RecordContainsClauseFormat2Context) IsRecordContainsClauseFormat2Context() {}

func NewRecordContainsClauseFormat2Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordContainsClauseFormat2Context {
	var p = new(RecordContainsClauseFormat2Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_recordContainsClauseFormat2

	return p
}

func (s *RecordContainsClauseFormat2Context) GetParser() antlr.Parser { return s.parser }

func (s *RecordContainsClauseFormat2Context) VARYING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserVARYING, 0)
}

func (s *RecordContainsClauseFormat2Context) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *RecordContainsClauseFormat2Context) IN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIN, 0)
}

func (s *RecordContainsClauseFormat2Context) SIZE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSIZE, 0)
}

func (s *RecordContainsClauseFormat2Context) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *RecordContainsClauseFormat2Context) DEPENDING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDEPENDING, 0)
}

func (s *RecordContainsClauseFormat2Context) QualifiedDataName() IQualifiedDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *RecordContainsClauseFormat2Context) FROM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFROM, 0)
}

func (s *RecordContainsClauseFormat2Context) RecordContainsTo() IRecordContainsToContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRecordContainsToContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRecordContainsToContext)
}

func (s *RecordContainsClauseFormat2Context) CHARACTERS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCHARACTERS, 0)
}

func (s *RecordContainsClauseFormat2Context) ON() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserON, 0)
}

func (s *RecordContainsClauseFormat2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordContainsClauseFormat2Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordContainsClauseFormat2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterRecordContainsClauseFormat2(s)
	}
}

func (s *RecordContainsClauseFormat2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitRecordContainsClauseFormat2(s)
	}
}

func (p *Cobol85Parser) RecordContainsClauseFormat2() (localctx IRecordContainsClauseFormat2Context) {
	localctx = NewRecordContainsClauseFormat2Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, Cobol85ParserRULE_recordContainsClauseFormat2)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2068)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2067)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(2070)
		p.Match(Cobol85ParserVARYING)
	}
	p.SetState(2072)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIN {
		{
			p.SetState(2071)
			p.Match(Cobol85ParserIN)
		}

	}
	p.SetState(2075)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserSIZE {
		{
			p.SetState(2074)
			p.Match(Cobol85ParserSIZE)
		}

	}
	p.SetState(2087)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFROM || (((_la-552)&-(0x1f+1)) == 0 && ((1<<uint((_la-552)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-552))|(1<<(Cobol85ParserLEVEL_NUMBER_77-552))|(1<<(Cobol85ParserLEVEL_NUMBER_88-552))|(1<<(Cobol85ParserINTEGERLITERAL-552)))) != 0) {
		p.SetState(2078)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserFROM {
			{
				p.SetState(2077)
				p.Match(Cobol85ParserFROM)
			}

		}
		{
			p.SetState(2080)
			p.IntegerLiteral()
		}
		p.SetState(2082)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserTO {
			{
				p.SetState(2081)
				p.RecordContainsTo()
			}

		}
		p.SetState(2085)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserCHARACTERS {
			{
				p.SetState(2084)
				p.Match(Cobol85ParserCHARACTERS)
			}

		}

	}
	p.SetState(2094)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserDEPENDING {
		{
			p.SetState(2089)
			p.Match(Cobol85ParserDEPENDING)
		}
		p.SetState(2091)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserON {
			{
				p.SetState(2090)
				p.Match(Cobol85ParserON)
			}

		}
		{
			p.SetState(2093)
			p.QualifiedDataName()
		}

	}

	return localctx
}

// IRecordContainsClauseFormat3Context is an interface to support dynamic dispatch.
type IRecordContainsClauseFormat3Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRecordContainsClauseFormat3Context differentiates from other interfaces.
	IsRecordContainsClauseFormat3Context()
}

type RecordContainsClauseFormat3Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordContainsClauseFormat3Context() *RecordContainsClauseFormat3Context {
	var p = new(RecordContainsClauseFormat3Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_recordContainsClauseFormat3
	return p
}

func (*RecordContainsClauseFormat3Context) IsRecordContainsClauseFormat3Context() {}

func NewRecordContainsClauseFormat3Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordContainsClauseFormat3Context {
	var p = new(RecordContainsClauseFormat3Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_recordContainsClauseFormat3

	return p
}

func (s *RecordContainsClauseFormat3Context) GetParser() antlr.Parser { return s.parser }

func (s *RecordContainsClauseFormat3Context) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *RecordContainsClauseFormat3Context) RecordContainsTo() IRecordContainsToContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRecordContainsToContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRecordContainsToContext)
}

func (s *RecordContainsClauseFormat3Context) CONTAINS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCONTAINS, 0)
}

func (s *RecordContainsClauseFormat3Context) CHARACTERS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCHARACTERS, 0)
}

func (s *RecordContainsClauseFormat3Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordContainsClauseFormat3Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordContainsClauseFormat3Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterRecordContainsClauseFormat3(s)
	}
}

func (s *RecordContainsClauseFormat3Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitRecordContainsClauseFormat3(s)
	}
}

func (p *Cobol85Parser) RecordContainsClauseFormat3() (localctx IRecordContainsClauseFormat3Context) {
	localctx = NewRecordContainsClauseFormat3Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, Cobol85ParserRULE_recordContainsClauseFormat3)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2097)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCONTAINS {
		{
			p.SetState(2096)
			p.Match(Cobol85ParserCONTAINS)
		}

	}
	{
		p.SetState(2099)
		p.IntegerLiteral()
	}
	{
		p.SetState(2100)
		p.RecordContainsTo()
	}
	p.SetState(2102)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCHARACTERS {
		{
			p.SetState(2101)
			p.Match(Cobol85ParserCHARACTERS)
		}

	}

	return localctx
}

// IRecordContainsToContext is an interface to support dynamic dispatch.
type IRecordContainsToContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRecordContainsToContext differentiates from other interfaces.
	IsRecordContainsToContext()
}

type RecordContainsToContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordContainsToContext() *RecordContainsToContext {
	var p = new(RecordContainsToContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_recordContainsTo
	return p
}

func (*RecordContainsToContext) IsRecordContainsToContext() {}

func NewRecordContainsToContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordContainsToContext {
	var p = new(RecordContainsToContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_recordContainsTo

	return p
}

func (s *RecordContainsToContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordContainsToContext) TO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTO, 0)
}

func (s *RecordContainsToContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *RecordContainsToContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordContainsToContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordContainsToContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterRecordContainsTo(s)
	}
}

func (s *RecordContainsToContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitRecordContainsTo(s)
	}
}

func (p *Cobol85Parser) RecordContainsTo() (localctx IRecordContainsToContext) {
	localctx = NewRecordContainsToContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, Cobol85ParserRULE_recordContainsTo)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2104)
		p.Match(Cobol85ParserTO)
	}
	{
		p.SetState(2105)
		p.IntegerLiteral()
	}

	return localctx
}

// ILabelRecordsClauseContext is an interface to support dynamic dispatch.
type ILabelRecordsClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLabelRecordsClauseContext differentiates from other interfaces.
	IsLabelRecordsClauseContext()
}

type LabelRecordsClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLabelRecordsClauseContext() *LabelRecordsClauseContext {
	var p = new(LabelRecordsClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_labelRecordsClause
	return p
}

func (*LabelRecordsClauseContext) IsLabelRecordsClauseContext() {}

func NewLabelRecordsClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LabelRecordsClauseContext {
	var p = new(LabelRecordsClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_labelRecordsClause

	return p
}

func (s *LabelRecordsClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LabelRecordsClauseContext) LABEL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLABEL, 0)
}

func (s *LabelRecordsClauseContext) RECORD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRECORD, 0)
}

func (s *LabelRecordsClauseContext) RECORDS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRECORDS, 0)
}

func (s *LabelRecordsClauseContext) OMITTED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOMITTED, 0)
}

func (s *LabelRecordsClauseContext) STANDARD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSTANDARD, 0)
}

func (s *LabelRecordsClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *LabelRecordsClauseContext) ARE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserARE, 0)
}

func (s *LabelRecordsClauseContext) AllDataName() []IDataNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDataNameContext)(nil)).Elem())
	var tst = make([]IDataNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDataNameContext)
		}
	}

	return tst
}

func (s *LabelRecordsClauseContext) DataName(i int) IDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *LabelRecordsClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelRecordsClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LabelRecordsClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLabelRecordsClause(s)
	}
}

func (s *LabelRecordsClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLabelRecordsClause(s)
	}
}

func (p *Cobol85Parser) LabelRecordsClause() (localctx ILabelRecordsClauseContext) {
	localctx = NewLabelRecordsClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, Cobol85ParserRULE_labelRecordsClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2107)
		p.Match(Cobol85ParserLABEL)
	}
	p.SetState(2116)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserRECORD:
		{
			p.SetState(2108)
			p.Match(Cobol85ParserRECORD)
		}
		p.SetState(2110)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserIS {
			{
				p.SetState(2109)
				p.Match(Cobol85ParserIS)
			}

		}

	case Cobol85ParserRECORDS:
		{
			p.SetState(2112)
			p.Match(Cobol85ParserRECORDS)
		}
		p.SetState(2114)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserARE {
			{
				p.SetState(2113)
				p.Match(Cobol85ParserARE)
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(2125)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserOMITTED:
		{
			p.SetState(2118)
			p.Match(Cobol85ParserOMITTED)
		}

	case Cobol85ParserSTANDARD:
		{
			p.SetState(2119)
			p.Match(Cobol85ParserSTANDARD)
		}

	case Cobol85ParserABORT, Cobol85ParserAS, Cobol85ParserASCII, Cobol85ParserASSOCIATED_DATA, Cobol85ParserASSOCIATED_DATA_LENGTH, Cobol85ParserATTRIBUTE, Cobol85ParserAUTO, Cobol85ParserAUTO_SKIP, Cobol85ParserBACKGROUND_COLOR, Cobol85ParserBACKGROUND_COLOUR, Cobol85ParserBEEP, Cobol85ParserBELL, Cobol85ParserBINARY, Cobol85ParserBIT, Cobol85ParserBLINK, Cobol85ParserBOUNDS, Cobol85ParserCAPABLE, Cobol85ParserCCSVERSION, Cobol85ParserCHANGED, Cobol85ParserCHANNEL, Cobol85ParserCLOSE_DISPOSITION, Cobol85ParserCOBOL, Cobol85ParserCOMMITMENT, Cobol85ParserCONTROL_POINT, Cobol85ParserCONVENTION, Cobol85ParserCRUNCH, Cobol85ParserCURSOR, Cobol85ParserDEFAULT, Cobol85ParserDEFAULT_DISPLAY, Cobol85ParserDEFINITION, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserDISK, Cobol85ParserDONTCARE, Cobol85ParserDOUBLE, Cobol85ParserEBCDIC, Cobol85ParserEMPTY_CHECK, Cobol85ParserENTER, Cobol85ParserENTRY_PROCEDURE, Cobol85ParserERASE, Cobol85ParserEOL, Cobol85ParserEOS, Cobol85ParserESCAPE, Cobol85ParserEVENT, Cobol85ParserEXCLUSIVE, Cobol85ParserEXPORT, Cobol85ParserEXTENDED, Cobol85ParserFOREGROUND_COLOR, Cobol85ParserFOREGROUND_COLOUR, Cobol85ParserFULL, Cobol85ParserFUNCTIONNAME, Cobol85ParserFUNCTION_POINTER, Cobol85ParserGRID, Cobol85ParserHIGHLIGHT, Cobol85ParserIMPLICIT, Cobol85ParserIMPORT, Cobol85ParserINTEGER, Cobol85ParserKEPT, Cobol85ParserKEYBOARD, Cobol85ParserLANGUAGE, Cobol85ParserLB, Cobol85ParserLD, Cobol85ParserLEFTLINE, Cobol85ParserLENGTH_CHECK, Cobol85ParserLIBACCESS, Cobol85ParserLIBPARAMETER, Cobol85ParserLIBRARY, Cobol85ParserLIST, Cobol85ParserLOCAL, Cobol85ParserLONG_DATE, Cobol85ParserLONG_TIME, Cobol85ParserLOWER, Cobol85ParserLOWLIGHT, Cobol85ParserMMDDYYYY, Cobol85ParserNAMED, Cobol85ParserNATIONAL, Cobol85ParserNATIONAL_EDITED, Cobol85ParserNETWORK, Cobol85ParserNO_ECHO, Cobol85ParserNUMERIC_DATE, Cobol85ParserNUMERIC_TIME, Cobol85ParserODT, Cobol85ParserORDERLY, Cobol85ParserOVERLINE, Cobol85ParserOWN, Cobol85ParserPASSWORD, Cobol85ParserPORT, Cobol85ParserPRINTER, Cobol85ParserPRIVATE, Cobol85ParserPROCESS, Cobol85ParserPROGRAM, Cobol85ParserPROMPT, Cobol85ParserREADER, Cobol85ParserREMOTE, Cobol85ParserREAL, Cobol85ParserRECEIVED, Cobol85ParserRECURSIVE, Cobol85ParserREF, Cobol85ParserREMOVE, Cobol85ParserREQUIRED, Cobol85ParserREVERSE_VIDEO, Cobol85ParserSAVE, Cobol85ParserSECURE, Cobol85ParserSHARED, Cobol85ParserSHAREDBYALL, Cobol85ParserSHAREDBYRUNUNIT, Cobol85ParserSHARING, Cobol85ParserSHORT_DATE, Cobol85ParserSYMBOL, Cobol85ParserTASK, Cobol85ParserTHREAD, Cobol85ParserTHREAD_LOCAL, Cobol85ParserTIMER, Cobol85ParserTODAYS_DATE, Cobol85ParserTODAYS_NAME, Cobol85ParserTRUNCATED, Cobol85ParserTYPEDEF, Cobol85ParserUNDERLINE, Cobol85ParserVIRTUAL, Cobol85ParserWAIT, Cobol85ParserYEAR, Cobol85ParserYYYYMMDD, Cobol85ParserYYYYDDD, Cobol85ParserZERO_FILL, Cobol85ParserIDENTIFIER:
		p.SetState(2121)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH)|(1<<Cobol85ParserATTRIBUTE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBINARY-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-68))|(1<<(Cobol85ParserCOBOL-68))|(1<<(Cobol85ParserCOMMITMENT-68))|(1<<(Cobol85ParserCONTROL_POINT-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(Cobol85ParserCONVENTION-100))|(1<<(Cobol85ParserCRUNCH-100))|(1<<(Cobol85ParserCURSOR-100))|(1<<(Cobol85ParserDEFAULT-100))|(1<<(Cobol85ParserDEFAULT_DISPLAY-100))|(1<<(Cobol85ParserDEFINITION-100)))) != 0) || (((_la-138)&-(0x1f+1)) == 0 && ((1<<uint((_la-138)))&((1<<(Cobol85ParserDFHRESP-138))|(1<<(Cobol85ParserDFHVALUE-138))|(1<<(Cobol85ParserDISK-138))|(1<<(Cobol85ParserDONTCARE-138))|(1<<(Cobol85ParserDOUBLE-138))|(1<<(Cobol85ParserEBCDIC-138))|(1<<(Cobol85ParserEMPTY_CHECK-138)))) != 0) || (((_la-181)&-(0x1f+1)) == 0 && ((1<<uint((_la-181)))&((1<<(Cobol85ParserENTER-181))|(1<<(Cobol85ParserENTRY_PROCEDURE-181))|(1<<(Cobol85ParserERASE-181))|(1<<(Cobol85ParserEOL-181))|(1<<(Cobol85ParserEOS-181))|(1<<(Cobol85ParserESCAPE-181))|(1<<(Cobol85ParserEVENT-181))|(1<<(Cobol85ParserEXCLUSIVE-181))|(1<<(Cobol85ParserEXPORT-181))|(1<<(Cobol85ParserEXTENDED-181)))) != 0) || (((_la-213)&-(0x1f+1)) == 0 && ((1<<uint((_la-213)))&((1<<(Cobol85ParserFOREGROUND_COLOR-213))|(1<<(Cobol85ParserFOREGROUND_COLOUR-213))|(1<<(Cobol85ParserFULL-213))|(1<<(Cobol85ParserFUNCTIONNAME-213))|(1<<(Cobol85ParserFUNCTION_POINTER-213))|(1<<(Cobol85ParserGRID-213))|(1<<(Cobol85ParserHIGHLIGHT-213))|(1<<(Cobol85ParserIMPLICIT-213))|(1<<(Cobol85ParserIMPORT-213)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(Cobol85ParserINTEGER-250))|(1<<(Cobol85ParserKEPT-250))|(1<<(Cobol85ParserKEYBOARD-250))|(1<<(Cobol85ParserLANGUAGE-250))|(1<<(Cobol85ParserLB-250))|(1<<(Cobol85ParserLD-250))|(1<<(Cobol85ParserLEFTLINE-250))|(1<<(Cobol85ParserLENGTH_CHECK-250))|(1<<(Cobol85ParserLIBACCESS-250))|(1<<(Cobol85ParserLIBPARAMETER-250))|(1<<(Cobol85ParserLIBRARY-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(Cobol85ParserLIST-283))|(1<<(Cobol85ParserLOCAL-283))|(1<<(Cobol85ParserLONG_DATE-283))|(1<<(Cobol85ParserLONG_TIME-283))|(1<<(Cobol85ParserLOWER-283))|(1<<(Cobol85ParserLOWLIGHT-283))|(1<<(Cobol85ParserMMDDYYYY-283))|(1<<(Cobol85ParserNAMED-283))|(1<<(Cobol85ParserNATIONAL-283))|(1<<(Cobol85ParserNATIONAL_EDITED-283))|(1<<(Cobol85ParserNETWORK-283))|(1<<(Cobol85ParserNO_ECHO-283)))) != 0) || (((_la-317)&-(0x1f+1)) == 0 && ((1<<uint((_la-317)))&((1<<(Cobol85ParserNUMERIC_DATE-317))|(1<<(Cobol85ParserNUMERIC_TIME-317))|(1<<(Cobol85ParserODT-317))|(1<<(Cobol85ParserORDERLY-317))|(1<<(Cobol85ParserOVERLINE-317))|(1<<(Cobol85ParserOWN-317))|(1<<(Cobol85ParserPASSWORD-317)))) != 0) || (((_la-352)&-(0x1f+1)) == 0 && ((1<<uint((_la-352)))&((1<<(Cobol85ParserPORT-352))|(1<<(Cobol85ParserPRINTER-352))|(1<<(Cobol85ParserPRIVATE-352))|(1<<(Cobol85ParserPROCESS-352))|(1<<(Cobol85ParserPROGRAM-352))|(1<<(Cobol85ParserPROMPT-352))|(1<<(Cobol85ParserREADER-352))|(1<<(Cobol85ParserREMOTE-352))|(1<<(Cobol85ParserREAL-352))|(1<<(Cobol85ParserRECEIVED-352))|(1<<(Cobol85ParserRECURSIVE-352))|(1<<(Cobol85ParserREF-352)))) != 0) || (((_la-391)&-(0x1f+1)) == 0 && ((1<<uint((_la-391)))&((1<<(Cobol85ParserREMOVE-391))|(1<<(Cobol85ParserREQUIRED-391))|(1<<(Cobol85ParserREVERSE_VIDEO-391))|(1<<(Cobol85ParserSAVE-391))|(1<<(Cobol85ParserSECURE-391)))) != 0) || (((_la-431)&-(0x1f+1)) == 0 && ((1<<uint((_la-431)))&((1<<(Cobol85ParserSHARED-431))|(1<<(Cobol85ParserSHAREDBYALL-431))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-431))|(1<<(Cobol85ParserSHARING-431))|(1<<(Cobol85ParserSHORT_DATE-431)))) != 0) || (((_la-466)&-(0x1f+1)) == 0 && ((1<<uint((_la-466)))&((1<<(Cobol85ParserSYMBOL-466))|(1<<(Cobol85ParserTASK-466))|(1<<(Cobol85ParserTHREAD-466))|(1<<(Cobol85ParserTHREAD_LOCAL-466))|(1<<(Cobol85ParserTIMER-466))|(1<<(Cobol85ParserTODAYS_DATE-466))|(1<<(Cobol85ParserTODAYS_NAME-466))|(1<<(Cobol85ParserTRUNCATED-466))|(1<<(Cobol85ParserTYPEDEF-466)))) != 0) || (((_la-498)&-(0x1f+1)) == 0 && ((1<<uint((_la-498)))&((1<<(Cobol85ParserUNDERLINE-498))|(1<<(Cobol85ParserVIRTUAL-498))|(1<<(Cobol85ParserWAIT-498))|(1<<(Cobol85ParserYEAR-498))|(1<<(Cobol85ParserYYYYMMDD-498))|(1<<(Cobol85ParserYYYYDDD-498))|(1<<(Cobol85ParserZERO_FILL-498)))) != 0) || _la == Cobol85ParserIDENTIFIER {
			{
				p.SetState(2120)
				p.DataName()
			}

			p.SetState(2123)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IValueOfClauseContext is an interface to support dynamic dispatch.
type IValueOfClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsValueOfClauseContext differentiates from other interfaces.
	IsValueOfClauseContext()
}

type ValueOfClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueOfClauseContext() *ValueOfClauseContext {
	var p = new(ValueOfClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_valueOfClause
	return p
}

func (*ValueOfClauseContext) IsValueOfClauseContext() {}

func NewValueOfClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueOfClauseContext {
	var p = new(ValueOfClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_valueOfClause

	return p
}

func (s *ValueOfClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueOfClauseContext) VALUE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserVALUE, 0)
}

func (s *ValueOfClauseContext) OF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOF, 0)
}

func (s *ValueOfClauseContext) AllValuePair() []IValuePairContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValuePairContext)(nil)).Elem())
	var tst = make([]IValuePairContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValuePairContext)
		}
	}

	return tst
}

func (s *ValueOfClauseContext) ValuePair(i int) IValuePairContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValuePairContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValuePairContext)
}

func (s *ValueOfClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueOfClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValueOfClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterValueOfClause(s)
	}
}

func (s *ValueOfClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitValueOfClause(s)
	}
}

func (p *Cobol85Parser) ValueOfClause() (localctx IValueOfClauseContext) {
	localctx = NewValueOfClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, Cobol85ParserRULE_valueOfClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2127)
		p.Match(Cobol85ParserVALUE)
	}
	{
		p.SetState(2128)
		p.Match(Cobol85ParserOF)
	}
	p.SetState(2130)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH)|(1<<Cobol85ParserATTRIBUTE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBINARY-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-68))|(1<<(Cobol85ParserCOBOL-68))|(1<<(Cobol85ParserCOMMITMENT-68))|(1<<(Cobol85ParserCONTROL_POINT-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(Cobol85ParserCONVENTION-100))|(1<<(Cobol85ParserCRUNCH-100))|(1<<(Cobol85ParserCURSOR-100))|(1<<(Cobol85ParserDEFAULT-100))|(1<<(Cobol85ParserDEFAULT_DISPLAY-100))|(1<<(Cobol85ParserDEFINITION-100)))) != 0) || (((_la-138)&-(0x1f+1)) == 0 && ((1<<uint((_la-138)))&((1<<(Cobol85ParserDFHRESP-138))|(1<<(Cobol85ParserDFHVALUE-138))|(1<<(Cobol85ParserDISK-138))|(1<<(Cobol85ParserDONTCARE-138))|(1<<(Cobol85ParserDOUBLE-138))|(1<<(Cobol85ParserEBCDIC-138))|(1<<(Cobol85ParserEMPTY_CHECK-138)))) != 0) || (((_la-181)&-(0x1f+1)) == 0 && ((1<<uint((_la-181)))&((1<<(Cobol85ParserENTER-181))|(1<<(Cobol85ParserENTRY_PROCEDURE-181))|(1<<(Cobol85ParserERASE-181))|(1<<(Cobol85ParserEOL-181))|(1<<(Cobol85ParserEOS-181))|(1<<(Cobol85ParserESCAPE-181))|(1<<(Cobol85ParserEVENT-181))|(1<<(Cobol85ParserEXCLUSIVE-181))|(1<<(Cobol85ParserEXPORT-181))|(1<<(Cobol85ParserEXTENDED-181)))) != 0) || (((_la-213)&-(0x1f+1)) == 0 && ((1<<uint((_la-213)))&((1<<(Cobol85ParserFOREGROUND_COLOR-213))|(1<<(Cobol85ParserFOREGROUND_COLOUR-213))|(1<<(Cobol85ParserFULL-213))|(1<<(Cobol85ParserFUNCTIONNAME-213))|(1<<(Cobol85ParserFUNCTION_POINTER-213))|(1<<(Cobol85ParserGRID-213))|(1<<(Cobol85ParserHIGHLIGHT-213))|(1<<(Cobol85ParserIMPLICIT-213))|(1<<(Cobol85ParserIMPORT-213)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(Cobol85ParserINTEGER-250))|(1<<(Cobol85ParserKEPT-250))|(1<<(Cobol85ParserKEYBOARD-250))|(1<<(Cobol85ParserLANGUAGE-250))|(1<<(Cobol85ParserLB-250))|(1<<(Cobol85ParserLD-250))|(1<<(Cobol85ParserLEFTLINE-250))|(1<<(Cobol85ParserLENGTH_CHECK-250))|(1<<(Cobol85ParserLIBACCESS-250))|(1<<(Cobol85ParserLIBPARAMETER-250))|(1<<(Cobol85ParserLIBRARY-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(Cobol85ParserLIST-283))|(1<<(Cobol85ParserLOCAL-283))|(1<<(Cobol85ParserLONG_DATE-283))|(1<<(Cobol85ParserLONG_TIME-283))|(1<<(Cobol85ParserLOWER-283))|(1<<(Cobol85ParserLOWLIGHT-283))|(1<<(Cobol85ParserMMDDYYYY-283))|(1<<(Cobol85ParserNAMED-283))|(1<<(Cobol85ParserNATIONAL-283))|(1<<(Cobol85ParserNATIONAL_EDITED-283))|(1<<(Cobol85ParserNETWORK-283))|(1<<(Cobol85ParserNO_ECHO-283)))) != 0) || (((_la-317)&-(0x1f+1)) == 0 && ((1<<uint((_la-317)))&((1<<(Cobol85ParserNUMERIC_DATE-317))|(1<<(Cobol85ParserNUMERIC_TIME-317))|(1<<(Cobol85ParserODT-317))|(1<<(Cobol85ParserORDERLY-317))|(1<<(Cobol85ParserOVERLINE-317))|(1<<(Cobol85ParserOWN-317))|(1<<(Cobol85ParserPASSWORD-317)))) != 0) || (((_la-352)&-(0x1f+1)) == 0 && ((1<<uint((_la-352)))&((1<<(Cobol85ParserPORT-352))|(1<<(Cobol85ParserPRINTER-352))|(1<<(Cobol85ParserPRIVATE-352))|(1<<(Cobol85ParserPROCESS-352))|(1<<(Cobol85ParserPROGRAM-352))|(1<<(Cobol85ParserPROMPT-352))|(1<<(Cobol85ParserREADER-352))|(1<<(Cobol85ParserREMOTE-352))|(1<<(Cobol85ParserREAL-352))|(1<<(Cobol85ParserRECEIVED-352))|(1<<(Cobol85ParserRECURSIVE-352))|(1<<(Cobol85ParserREF-352)))) != 0) || (((_la-391)&-(0x1f+1)) == 0 && ((1<<uint((_la-391)))&((1<<(Cobol85ParserREMOVE-391))|(1<<(Cobol85ParserREQUIRED-391))|(1<<(Cobol85ParserREVERSE_VIDEO-391))|(1<<(Cobol85ParserSAVE-391))|(1<<(Cobol85ParserSECURE-391)))) != 0) || (((_la-431)&-(0x1f+1)) == 0 && ((1<<uint((_la-431)))&((1<<(Cobol85ParserSHARED-431))|(1<<(Cobol85ParserSHAREDBYALL-431))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-431))|(1<<(Cobol85ParserSHARING-431))|(1<<(Cobol85ParserSHORT_DATE-431)))) != 0) || (((_la-466)&-(0x1f+1)) == 0 && ((1<<uint((_la-466)))&((1<<(Cobol85ParserSYMBOL-466))|(1<<(Cobol85ParserTASK-466))|(1<<(Cobol85ParserTHREAD-466))|(1<<(Cobol85ParserTHREAD_LOCAL-466))|(1<<(Cobol85ParserTIMER-466))|(1<<(Cobol85ParserTODAYS_DATE-466))|(1<<(Cobol85ParserTODAYS_NAME-466))|(1<<(Cobol85ParserTRUNCATED-466))|(1<<(Cobol85ParserTYPEDEF-466)))) != 0) || (((_la-498)&-(0x1f+1)) == 0 && ((1<<uint((_la-498)))&((1<<(Cobol85ParserUNDERLINE-498))|(1<<(Cobol85ParserVIRTUAL-498))|(1<<(Cobol85ParserWAIT-498))|(1<<(Cobol85ParserYEAR-498))|(1<<(Cobol85ParserYYYYMMDD-498))|(1<<(Cobol85ParserYYYYDDD-498))|(1<<(Cobol85ParserZERO_FILL-498)))) != 0) || _la == Cobol85ParserIDENTIFIER {
		{
			p.SetState(2129)
			p.ValuePair()
		}

		p.SetState(2132)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IValuePairContext is an interface to support dynamic dispatch.
type IValuePairContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsValuePairContext differentiates from other interfaces.
	IsValuePairContext()
}

type ValuePairContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValuePairContext() *ValuePairContext {
	var p = new(ValuePairContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_valuePair
	return p
}

func (*ValuePairContext) IsValuePairContext() {}

func NewValuePairContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValuePairContext {
	var p = new(ValuePairContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_valuePair

	return p
}

func (s *ValuePairContext) GetParser() antlr.Parser { return s.parser }

func (s *ValuePairContext) SystemName() ISystemNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISystemNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISystemNameContext)
}

func (s *ValuePairContext) QualifiedDataName() IQualifiedDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *ValuePairContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *ValuePairContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ValuePairContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValuePairContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValuePairContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterValuePair(s)
	}
}

func (s *ValuePairContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitValuePair(s)
	}
}

func (p *Cobol85Parser) ValuePair() (localctx IValuePairContext) {
	localctx = NewValuePairContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, Cobol85ParserRULE_valuePair)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2134)
		p.SystemName()
	}
	p.SetState(2136)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2135)
			p.Match(Cobol85ParserIS)
		}

	}
	p.SetState(2140)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 198, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2138)
			p.QualifiedDataName()
		}

	case 2:
		{
			p.SetState(2139)
			p.Literal()
		}

	}

	return localctx
}

// IDataRecordsClauseContext is an interface to support dynamic dispatch.
type IDataRecordsClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataRecordsClauseContext differentiates from other interfaces.
	IsDataRecordsClauseContext()
}

type DataRecordsClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataRecordsClauseContext() *DataRecordsClauseContext {
	var p = new(DataRecordsClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataRecordsClause
	return p
}

func (*DataRecordsClauseContext) IsDataRecordsClauseContext() {}

func NewDataRecordsClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataRecordsClauseContext {
	var p = new(DataRecordsClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataRecordsClause

	return p
}

func (s *DataRecordsClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataRecordsClauseContext) DATA() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDATA, 0)
}

func (s *DataRecordsClauseContext) RECORD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRECORD, 0)
}

func (s *DataRecordsClauseContext) RECORDS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRECORDS, 0)
}

func (s *DataRecordsClauseContext) AllDataName() []IDataNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDataNameContext)(nil)).Elem())
	var tst = make([]IDataNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDataNameContext)
		}
	}

	return tst
}

func (s *DataRecordsClauseContext) DataName(i int) IDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *DataRecordsClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *DataRecordsClauseContext) ARE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserARE, 0)
}

func (s *DataRecordsClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataRecordsClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataRecordsClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataRecordsClause(s)
	}
}

func (s *DataRecordsClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataRecordsClause(s)
	}
}

func (p *Cobol85Parser) DataRecordsClause() (localctx IDataRecordsClauseContext) {
	localctx = NewDataRecordsClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, Cobol85ParserRULE_dataRecordsClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2142)
		p.Match(Cobol85ParserDATA)
	}
	p.SetState(2151)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserRECORD:
		{
			p.SetState(2143)
			p.Match(Cobol85ParserRECORD)
		}
		p.SetState(2145)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserIS {
			{
				p.SetState(2144)
				p.Match(Cobol85ParserIS)
			}

		}

	case Cobol85ParserRECORDS:
		{
			p.SetState(2147)
			p.Match(Cobol85ParserRECORDS)
		}
		p.SetState(2149)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserARE {
			{
				p.SetState(2148)
				p.Match(Cobol85ParserARE)
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(2154)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH)|(1<<Cobol85ParserATTRIBUTE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBINARY-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-68))|(1<<(Cobol85ParserCOBOL-68))|(1<<(Cobol85ParserCOMMITMENT-68))|(1<<(Cobol85ParserCONTROL_POINT-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(Cobol85ParserCONVENTION-100))|(1<<(Cobol85ParserCRUNCH-100))|(1<<(Cobol85ParserCURSOR-100))|(1<<(Cobol85ParserDEFAULT-100))|(1<<(Cobol85ParserDEFAULT_DISPLAY-100))|(1<<(Cobol85ParserDEFINITION-100)))) != 0) || (((_la-138)&-(0x1f+1)) == 0 && ((1<<uint((_la-138)))&((1<<(Cobol85ParserDFHRESP-138))|(1<<(Cobol85ParserDFHVALUE-138))|(1<<(Cobol85ParserDISK-138))|(1<<(Cobol85ParserDONTCARE-138))|(1<<(Cobol85ParserDOUBLE-138))|(1<<(Cobol85ParserEBCDIC-138))|(1<<(Cobol85ParserEMPTY_CHECK-138)))) != 0) || (((_la-181)&-(0x1f+1)) == 0 && ((1<<uint((_la-181)))&((1<<(Cobol85ParserENTER-181))|(1<<(Cobol85ParserENTRY_PROCEDURE-181))|(1<<(Cobol85ParserERASE-181))|(1<<(Cobol85ParserEOL-181))|(1<<(Cobol85ParserEOS-181))|(1<<(Cobol85ParserESCAPE-181))|(1<<(Cobol85ParserEVENT-181))|(1<<(Cobol85ParserEXCLUSIVE-181))|(1<<(Cobol85ParserEXPORT-181))|(1<<(Cobol85ParserEXTENDED-181)))) != 0) || (((_la-213)&-(0x1f+1)) == 0 && ((1<<uint((_la-213)))&((1<<(Cobol85ParserFOREGROUND_COLOR-213))|(1<<(Cobol85ParserFOREGROUND_COLOUR-213))|(1<<(Cobol85ParserFULL-213))|(1<<(Cobol85ParserFUNCTIONNAME-213))|(1<<(Cobol85ParserFUNCTION_POINTER-213))|(1<<(Cobol85ParserGRID-213))|(1<<(Cobol85ParserHIGHLIGHT-213))|(1<<(Cobol85ParserIMPLICIT-213))|(1<<(Cobol85ParserIMPORT-213)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(Cobol85ParserINTEGER-250))|(1<<(Cobol85ParserKEPT-250))|(1<<(Cobol85ParserKEYBOARD-250))|(1<<(Cobol85ParserLANGUAGE-250))|(1<<(Cobol85ParserLB-250))|(1<<(Cobol85ParserLD-250))|(1<<(Cobol85ParserLEFTLINE-250))|(1<<(Cobol85ParserLENGTH_CHECK-250))|(1<<(Cobol85ParserLIBACCESS-250))|(1<<(Cobol85ParserLIBPARAMETER-250))|(1<<(Cobol85ParserLIBRARY-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(Cobol85ParserLIST-283))|(1<<(Cobol85ParserLOCAL-283))|(1<<(Cobol85ParserLONG_DATE-283))|(1<<(Cobol85ParserLONG_TIME-283))|(1<<(Cobol85ParserLOWER-283))|(1<<(Cobol85ParserLOWLIGHT-283))|(1<<(Cobol85ParserMMDDYYYY-283))|(1<<(Cobol85ParserNAMED-283))|(1<<(Cobol85ParserNATIONAL-283))|(1<<(Cobol85ParserNATIONAL_EDITED-283))|(1<<(Cobol85ParserNETWORK-283))|(1<<(Cobol85ParserNO_ECHO-283)))) != 0) || (((_la-317)&-(0x1f+1)) == 0 && ((1<<uint((_la-317)))&((1<<(Cobol85ParserNUMERIC_DATE-317))|(1<<(Cobol85ParserNUMERIC_TIME-317))|(1<<(Cobol85ParserODT-317))|(1<<(Cobol85ParserORDERLY-317))|(1<<(Cobol85ParserOVERLINE-317))|(1<<(Cobol85ParserOWN-317))|(1<<(Cobol85ParserPASSWORD-317)))) != 0) || (((_la-352)&-(0x1f+1)) == 0 && ((1<<uint((_la-352)))&((1<<(Cobol85ParserPORT-352))|(1<<(Cobol85ParserPRINTER-352))|(1<<(Cobol85ParserPRIVATE-352))|(1<<(Cobol85ParserPROCESS-352))|(1<<(Cobol85ParserPROGRAM-352))|(1<<(Cobol85ParserPROMPT-352))|(1<<(Cobol85ParserREADER-352))|(1<<(Cobol85ParserREMOTE-352))|(1<<(Cobol85ParserREAL-352))|(1<<(Cobol85ParserRECEIVED-352))|(1<<(Cobol85ParserRECURSIVE-352))|(1<<(Cobol85ParserREF-352)))) != 0) || (((_la-391)&-(0x1f+1)) == 0 && ((1<<uint((_la-391)))&((1<<(Cobol85ParserREMOVE-391))|(1<<(Cobol85ParserREQUIRED-391))|(1<<(Cobol85ParserREVERSE_VIDEO-391))|(1<<(Cobol85ParserSAVE-391))|(1<<(Cobol85ParserSECURE-391)))) != 0) || (((_la-431)&-(0x1f+1)) == 0 && ((1<<uint((_la-431)))&((1<<(Cobol85ParserSHARED-431))|(1<<(Cobol85ParserSHAREDBYALL-431))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-431))|(1<<(Cobol85ParserSHARING-431))|(1<<(Cobol85ParserSHORT_DATE-431)))) != 0) || (((_la-466)&-(0x1f+1)) == 0 && ((1<<uint((_la-466)))&((1<<(Cobol85ParserSYMBOL-466))|(1<<(Cobol85ParserTASK-466))|(1<<(Cobol85ParserTHREAD-466))|(1<<(Cobol85ParserTHREAD_LOCAL-466))|(1<<(Cobol85ParserTIMER-466))|(1<<(Cobol85ParserTODAYS_DATE-466))|(1<<(Cobol85ParserTODAYS_NAME-466))|(1<<(Cobol85ParserTRUNCATED-466))|(1<<(Cobol85ParserTYPEDEF-466)))) != 0) || (((_la-498)&-(0x1f+1)) == 0 && ((1<<uint((_la-498)))&((1<<(Cobol85ParserUNDERLINE-498))|(1<<(Cobol85ParserVIRTUAL-498))|(1<<(Cobol85ParserWAIT-498))|(1<<(Cobol85ParserYEAR-498))|(1<<(Cobol85ParserYYYYMMDD-498))|(1<<(Cobol85ParserYYYYDDD-498))|(1<<(Cobol85ParserZERO_FILL-498)))) != 0) || _la == Cobol85ParserIDENTIFIER {
		{
			p.SetState(2153)
			p.DataName()
		}

		p.SetState(2156)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ILinageClauseContext is an interface to support dynamic dispatch.
type ILinageClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLinageClauseContext differentiates from other interfaces.
	IsLinageClauseContext()
}

type LinageClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLinageClauseContext() *LinageClauseContext {
	var p = new(LinageClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_linageClause
	return p
}

func (*LinageClauseContext) IsLinageClauseContext() {}

func NewLinageClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LinageClauseContext {
	var p = new(LinageClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_linageClause

	return p
}

func (s *LinageClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LinageClauseContext) LINAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLINAGE, 0)
}

func (s *LinageClauseContext) DataName() IDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *LinageClauseContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *LinageClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *LinageClauseContext) LINES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLINES, 0)
}

func (s *LinageClauseContext) AllLinageAt() []ILinageAtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILinageAtContext)(nil)).Elem())
	var tst = make([]ILinageAtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILinageAtContext)
		}
	}

	return tst
}

func (s *LinageClauseContext) LinageAt(i int) ILinageAtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILinageAtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILinageAtContext)
}

func (s *LinageClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LinageClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LinageClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLinageClause(s)
	}
}

func (s *LinageClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLinageClause(s)
	}
}

func (p *Cobol85Parser) LinageClause() (localctx ILinageClauseContext) {
	localctx = NewLinageClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, Cobol85ParserRULE_linageClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2158)
		p.Match(Cobol85ParserLINAGE)
	}
	p.SetState(2160)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2159)
			p.Match(Cobol85ParserIS)
		}

	}
	p.SetState(2164)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserABORT, Cobol85ParserAS, Cobol85ParserASCII, Cobol85ParserASSOCIATED_DATA, Cobol85ParserASSOCIATED_DATA_LENGTH, Cobol85ParserATTRIBUTE, Cobol85ParserAUTO, Cobol85ParserAUTO_SKIP, Cobol85ParserBACKGROUND_COLOR, Cobol85ParserBACKGROUND_COLOUR, Cobol85ParserBEEP, Cobol85ParserBELL, Cobol85ParserBINARY, Cobol85ParserBIT, Cobol85ParserBLINK, Cobol85ParserBOUNDS, Cobol85ParserCAPABLE, Cobol85ParserCCSVERSION, Cobol85ParserCHANGED, Cobol85ParserCHANNEL, Cobol85ParserCLOSE_DISPOSITION, Cobol85ParserCOBOL, Cobol85ParserCOMMITMENT, Cobol85ParserCONTROL_POINT, Cobol85ParserCONVENTION, Cobol85ParserCRUNCH, Cobol85ParserCURSOR, Cobol85ParserDEFAULT, Cobol85ParserDEFAULT_DISPLAY, Cobol85ParserDEFINITION, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserDISK, Cobol85ParserDONTCARE, Cobol85ParserDOUBLE, Cobol85ParserEBCDIC, Cobol85ParserEMPTY_CHECK, Cobol85ParserENTER, Cobol85ParserENTRY_PROCEDURE, Cobol85ParserERASE, Cobol85ParserEOL, Cobol85ParserEOS, Cobol85ParserESCAPE, Cobol85ParserEVENT, Cobol85ParserEXCLUSIVE, Cobol85ParserEXPORT, Cobol85ParserEXTENDED, Cobol85ParserFOREGROUND_COLOR, Cobol85ParserFOREGROUND_COLOUR, Cobol85ParserFULL, Cobol85ParserFUNCTIONNAME, Cobol85ParserFUNCTION_POINTER, Cobol85ParserGRID, Cobol85ParserHIGHLIGHT, Cobol85ParserIMPLICIT, Cobol85ParserIMPORT, Cobol85ParserINTEGER, Cobol85ParserKEPT, Cobol85ParserKEYBOARD, Cobol85ParserLANGUAGE, Cobol85ParserLB, Cobol85ParserLD, Cobol85ParserLEFTLINE, Cobol85ParserLENGTH_CHECK, Cobol85ParserLIBACCESS, Cobol85ParserLIBPARAMETER, Cobol85ParserLIBRARY, Cobol85ParserLIST, Cobol85ParserLOCAL, Cobol85ParserLONG_DATE, Cobol85ParserLONG_TIME, Cobol85ParserLOWER, Cobol85ParserLOWLIGHT, Cobol85ParserMMDDYYYY, Cobol85ParserNAMED, Cobol85ParserNATIONAL, Cobol85ParserNATIONAL_EDITED, Cobol85ParserNETWORK, Cobol85ParserNO_ECHO, Cobol85ParserNUMERIC_DATE, Cobol85ParserNUMERIC_TIME, Cobol85ParserODT, Cobol85ParserORDERLY, Cobol85ParserOVERLINE, Cobol85ParserOWN, Cobol85ParserPASSWORD, Cobol85ParserPORT, Cobol85ParserPRINTER, Cobol85ParserPRIVATE, Cobol85ParserPROCESS, Cobol85ParserPROGRAM, Cobol85ParserPROMPT, Cobol85ParserREADER, Cobol85ParserREMOTE, Cobol85ParserREAL, Cobol85ParserRECEIVED, Cobol85ParserRECURSIVE, Cobol85ParserREF, Cobol85ParserREMOVE, Cobol85ParserREQUIRED, Cobol85ParserREVERSE_VIDEO, Cobol85ParserSAVE, Cobol85ParserSECURE, Cobol85ParserSHARED, Cobol85ParserSHAREDBYALL, Cobol85ParserSHAREDBYRUNUNIT, Cobol85ParserSHARING, Cobol85ParserSHORT_DATE, Cobol85ParserSYMBOL, Cobol85ParserTASK, Cobol85ParserTHREAD, Cobol85ParserTHREAD_LOCAL, Cobol85ParserTIMER, Cobol85ParserTODAYS_DATE, Cobol85ParserTODAYS_NAME, Cobol85ParserTRUNCATED, Cobol85ParserTYPEDEF, Cobol85ParserUNDERLINE, Cobol85ParserVIRTUAL, Cobol85ParserWAIT, Cobol85ParserYEAR, Cobol85ParserYYYYMMDD, Cobol85ParserYYYYDDD, Cobol85ParserZERO_FILL, Cobol85ParserIDENTIFIER:
		{
			p.SetState(2162)
			p.DataName()
		}

	case Cobol85ParserLEVEL_NUMBER_66, Cobol85ParserLEVEL_NUMBER_77, Cobol85ParserLEVEL_NUMBER_88, Cobol85ParserINTEGERLITERAL:
		{
			p.SetState(2163)
			p.IntegerLiteral()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(2167)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 205, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2166)
			p.Match(Cobol85ParserLINES)
		}

	}
	p.SetState(2172)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserAT || _la == Cobol85ParserBOTTOM || _la == Cobol85ParserFOOTING || _la == Cobol85ParserLINES || _la == Cobol85ParserTOP || _la == Cobol85ParserWITH {
		{
			p.SetState(2169)
			p.LinageAt()
		}

		p.SetState(2174)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ILinageAtContext is an interface to support dynamic dispatch.
type ILinageAtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLinageAtContext differentiates from other interfaces.
	IsLinageAtContext()
}

type LinageAtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLinageAtContext() *LinageAtContext {
	var p = new(LinageAtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_linageAt
	return p
}

func (*LinageAtContext) IsLinageAtContext() {}

func NewLinageAtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LinageAtContext {
	var p = new(LinageAtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_linageAt

	return p
}

func (s *LinageAtContext) GetParser() antlr.Parser { return s.parser }

func (s *LinageAtContext) LinageFootingAt() ILinageFootingAtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILinageFootingAtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILinageFootingAtContext)
}

func (s *LinageAtContext) LinageLinesAtTop() ILinageLinesAtTopContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILinageLinesAtTopContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILinageLinesAtTopContext)
}

func (s *LinageAtContext) LinageLinesAtBottom() ILinageLinesAtBottomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILinageLinesAtBottomContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILinageLinesAtBottomContext)
}

func (s *LinageAtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LinageAtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LinageAtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLinageAt(s)
	}
}

func (s *LinageAtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLinageAt(s)
	}
}

func (p *Cobol85Parser) LinageAt() (localctx ILinageAtContext) {
	localctx = NewLinageAtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, Cobol85ParserRULE_linageAt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2178)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 207, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2175)
			p.LinageFootingAt()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2176)
			p.LinageLinesAtTop()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2177)
			p.LinageLinesAtBottom()
		}

	}

	return localctx
}

// ILinageFootingAtContext is an interface to support dynamic dispatch.
type ILinageFootingAtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLinageFootingAtContext differentiates from other interfaces.
	IsLinageFootingAtContext()
}

type LinageFootingAtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLinageFootingAtContext() *LinageFootingAtContext {
	var p = new(LinageFootingAtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_linageFootingAt
	return p
}

func (*LinageFootingAtContext) IsLinageFootingAtContext() {}

func NewLinageFootingAtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LinageFootingAtContext {
	var p = new(LinageFootingAtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_linageFootingAt

	return p
}

func (s *LinageFootingAtContext) GetParser() antlr.Parser { return s.parser }

func (s *LinageFootingAtContext) FOOTING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOOTING, 0)
}

func (s *LinageFootingAtContext) DataName() IDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *LinageFootingAtContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *LinageFootingAtContext) WITH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWITH, 0)
}

func (s *LinageFootingAtContext) AT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAT, 0)
}

func (s *LinageFootingAtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LinageFootingAtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LinageFootingAtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLinageFootingAt(s)
	}
}

func (s *LinageFootingAtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLinageFootingAt(s)
	}
}

func (p *Cobol85Parser) LinageFootingAt() (localctx ILinageFootingAtContext) {
	localctx = NewLinageFootingAtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, Cobol85ParserRULE_linageFootingAt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2181)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserWITH {
		{
			p.SetState(2180)
			p.Match(Cobol85ParserWITH)
		}

	}
	{
		p.SetState(2183)
		p.Match(Cobol85ParserFOOTING)
	}
	p.SetState(2185)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserAT {
		{
			p.SetState(2184)
			p.Match(Cobol85ParserAT)
		}

	}
	p.SetState(2189)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserABORT, Cobol85ParserAS, Cobol85ParserASCII, Cobol85ParserASSOCIATED_DATA, Cobol85ParserASSOCIATED_DATA_LENGTH, Cobol85ParserATTRIBUTE, Cobol85ParserAUTO, Cobol85ParserAUTO_SKIP, Cobol85ParserBACKGROUND_COLOR, Cobol85ParserBACKGROUND_COLOUR, Cobol85ParserBEEP, Cobol85ParserBELL, Cobol85ParserBINARY, Cobol85ParserBIT, Cobol85ParserBLINK, Cobol85ParserBOUNDS, Cobol85ParserCAPABLE, Cobol85ParserCCSVERSION, Cobol85ParserCHANGED, Cobol85ParserCHANNEL, Cobol85ParserCLOSE_DISPOSITION, Cobol85ParserCOBOL, Cobol85ParserCOMMITMENT, Cobol85ParserCONTROL_POINT, Cobol85ParserCONVENTION, Cobol85ParserCRUNCH, Cobol85ParserCURSOR, Cobol85ParserDEFAULT, Cobol85ParserDEFAULT_DISPLAY, Cobol85ParserDEFINITION, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserDISK, Cobol85ParserDONTCARE, Cobol85ParserDOUBLE, Cobol85ParserEBCDIC, Cobol85ParserEMPTY_CHECK, Cobol85ParserENTER, Cobol85ParserENTRY_PROCEDURE, Cobol85ParserERASE, Cobol85ParserEOL, Cobol85ParserEOS, Cobol85ParserESCAPE, Cobol85ParserEVENT, Cobol85ParserEXCLUSIVE, Cobol85ParserEXPORT, Cobol85ParserEXTENDED, Cobol85ParserFOREGROUND_COLOR, Cobol85ParserFOREGROUND_COLOUR, Cobol85ParserFULL, Cobol85ParserFUNCTIONNAME, Cobol85ParserFUNCTION_POINTER, Cobol85ParserGRID, Cobol85ParserHIGHLIGHT, Cobol85ParserIMPLICIT, Cobol85ParserIMPORT, Cobol85ParserINTEGER, Cobol85ParserKEPT, Cobol85ParserKEYBOARD, Cobol85ParserLANGUAGE, Cobol85ParserLB, Cobol85ParserLD, Cobol85ParserLEFTLINE, Cobol85ParserLENGTH_CHECK, Cobol85ParserLIBACCESS, Cobol85ParserLIBPARAMETER, Cobol85ParserLIBRARY, Cobol85ParserLIST, Cobol85ParserLOCAL, Cobol85ParserLONG_DATE, Cobol85ParserLONG_TIME, Cobol85ParserLOWER, Cobol85ParserLOWLIGHT, Cobol85ParserMMDDYYYY, Cobol85ParserNAMED, Cobol85ParserNATIONAL, Cobol85ParserNATIONAL_EDITED, Cobol85ParserNETWORK, Cobol85ParserNO_ECHO, Cobol85ParserNUMERIC_DATE, Cobol85ParserNUMERIC_TIME, Cobol85ParserODT, Cobol85ParserORDERLY, Cobol85ParserOVERLINE, Cobol85ParserOWN, Cobol85ParserPASSWORD, Cobol85ParserPORT, Cobol85ParserPRINTER, Cobol85ParserPRIVATE, Cobol85ParserPROCESS, Cobol85ParserPROGRAM, Cobol85ParserPROMPT, Cobol85ParserREADER, Cobol85ParserREMOTE, Cobol85ParserREAL, Cobol85ParserRECEIVED, Cobol85ParserRECURSIVE, Cobol85ParserREF, Cobol85ParserREMOVE, Cobol85ParserREQUIRED, Cobol85ParserREVERSE_VIDEO, Cobol85ParserSAVE, Cobol85ParserSECURE, Cobol85ParserSHARED, Cobol85ParserSHAREDBYALL, Cobol85ParserSHAREDBYRUNUNIT, Cobol85ParserSHARING, Cobol85ParserSHORT_DATE, Cobol85ParserSYMBOL, Cobol85ParserTASK, Cobol85ParserTHREAD, Cobol85ParserTHREAD_LOCAL, Cobol85ParserTIMER, Cobol85ParserTODAYS_DATE, Cobol85ParserTODAYS_NAME, Cobol85ParserTRUNCATED, Cobol85ParserTYPEDEF, Cobol85ParserUNDERLINE, Cobol85ParserVIRTUAL, Cobol85ParserWAIT, Cobol85ParserYEAR, Cobol85ParserYYYYMMDD, Cobol85ParserYYYYDDD, Cobol85ParserZERO_FILL, Cobol85ParserIDENTIFIER:
		{
			p.SetState(2187)
			p.DataName()
		}

	case Cobol85ParserLEVEL_NUMBER_66, Cobol85ParserLEVEL_NUMBER_77, Cobol85ParserLEVEL_NUMBER_88, Cobol85ParserINTEGERLITERAL:
		{
			p.SetState(2188)
			p.IntegerLiteral()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ILinageLinesAtTopContext is an interface to support dynamic dispatch.
type ILinageLinesAtTopContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLinageLinesAtTopContext differentiates from other interfaces.
	IsLinageLinesAtTopContext()
}

type LinageLinesAtTopContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLinageLinesAtTopContext() *LinageLinesAtTopContext {
	var p = new(LinageLinesAtTopContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_linageLinesAtTop
	return p
}

func (*LinageLinesAtTopContext) IsLinageLinesAtTopContext() {}

func NewLinageLinesAtTopContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LinageLinesAtTopContext {
	var p = new(LinageLinesAtTopContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_linageLinesAtTop

	return p
}

func (s *LinageLinesAtTopContext) GetParser() antlr.Parser { return s.parser }

func (s *LinageLinesAtTopContext) TOP() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTOP, 0)
}

func (s *LinageLinesAtTopContext) DataName() IDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *LinageLinesAtTopContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *LinageLinesAtTopContext) LINES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLINES, 0)
}

func (s *LinageLinesAtTopContext) AT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAT, 0)
}

func (s *LinageLinesAtTopContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LinageLinesAtTopContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LinageLinesAtTopContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLinageLinesAtTop(s)
	}
}

func (s *LinageLinesAtTopContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLinageLinesAtTop(s)
	}
}

func (p *Cobol85Parser) LinageLinesAtTop() (localctx ILinageLinesAtTopContext) {
	localctx = NewLinageLinesAtTopContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, Cobol85ParserRULE_linageLinesAtTop)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2192)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserLINES {
		{
			p.SetState(2191)
			p.Match(Cobol85ParserLINES)
		}

	}
	p.SetState(2195)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserAT {
		{
			p.SetState(2194)
			p.Match(Cobol85ParserAT)
		}

	}
	{
		p.SetState(2197)
		p.Match(Cobol85ParserTOP)
	}
	p.SetState(2200)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserABORT, Cobol85ParserAS, Cobol85ParserASCII, Cobol85ParserASSOCIATED_DATA, Cobol85ParserASSOCIATED_DATA_LENGTH, Cobol85ParserATTRIBUTE, Cobol85ParserAUTO, Cobol85ParserAUTO_SKIP, Cobol85ParserBACKGROUND_COLOR, Cobol85ParserBACKGROUND_COLOUR, Cobol85ParserBEEP, Cobol85ParserBELL, Cobol85ParserBINARY, Cobol85ParserBIT, Cobol85ParserBLINK, Cobol85ParserBOUNDS, Cobol85ParserCAPABLE, Cobol85ParserCCSVERSION, Cobol85ParserCHANGED, Cobol85ParserCHANNEL, Cobol85ParserCLOSE_DISPOSITION, Cobol85ParserCOBOL, Cobol85ParserCOMMITMENT, Cobol85ParserCONTROL_POINT, Cobol85ParserCONVENTION, Cobol85ParserCRUNCH, Cobol85ParserCURSOR, Cobol85ParserDEFAULT, Cobol85ParserDEFAULT_DISPLAY, Cobol85ParserDEFINITION, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserDISK, Cobol85ParserDONTCARE, Cobol85ParserDOUBLE, Cobol85ParserEBCDIC, Cobol85ParserEMPTY_CHECK, Cobol85ParserENTER, Cobol85ParserENTRY_PROCEDURE, Cobol85ParserERASE, Cobol85ParserEOL, Cobol85ParserEOS, Cobol85ParserESCAPE, Cobol85ParserEVENT, Cobol85ParserEXCLUSIVE, Cobol85ParserEXPORT, Cobol85ParserEXTENDED, Cobol85ParserFOREGROUND_COLOR, Cobol85ParserFOREGROUND_COLOUR, Cobol85ParserFULL, Cobol85ParserFUNCTIONNAME, Cobol85ParserFUNCTION_POINTER, Cobol85ParserGRID, Cobol85ParserHIGHLIGHT, Cobol85ParserIMPLICIT, Cobol85ParserIMPORT, Cobol85ParserINTEGER, Cobol85ParserKEPT, Cobol85ParserKEYBOARD, Cobol85ParserLANGUAGE, Cobol85ParserLB, Cobol85ParserLD, Cobol85ParserLEFTLINE, Cobol85ParserLENGTH_CHECK, Cobol85ParserLIBACCESS, Cobol85ParserLIBPARAMETER, Cobol85ParserLIBRARY, Cobol85ParserLIST, Cobol85ParserLOCAL, Cobol85ParserLONG_DATE, Cobol85ParserLONG_TIME, Cobol85ParserLOWER, Cobol85ParserLOWLIGHT, Cobol85ParserMMDDYYYY, Cobol85ParserNAMED, Cobol85ParserNATIONAL, Cobol85ParserNATIONAL_EDITED, Cobol85ParserNETWORK, Cobol85ParserNO_ECHO, Cobol85ParserNUMERIC_DATE, Cobol85ParserNUMERIC_TIME, Cobol85ParserODT, Cobol85ParserORDERLY, Cobol85ParserOVERLINE, Cobol85ParserOWN, Cobol85ParserPASSWORD, Cobol85ParserPORT, Cobol85ParserPRINTER, Cobol85ParserPRIVATE, Cobol85ParserPROCESS, Cobol85ParserPROGRAM, Cobol85ParserPROMPT, Cobol85ParserREADER, Cobol85ParserREMOTE, Cobol85ParserREAL, Cobol85ParserRECEIVED, Cobol85ParserRECURSIVE, Cobol85ParserREF, Cobol85ParserREMOVE, Cobol85ParserREQUIRED, Cobol85ParserREVERSE_VIDEO, Cobol85ParserSAVE, Cobol85ParserSECURE, Cobol85ParserSHARED, Cobol85ParserSHAREDBYALL, Cobol85ParserSHAREDBYRUNUNIT, Cobol85ParserSHARING, Cobol85ParserSHORT_DATE, Cobol85ParserSYMBOL, Cobol85ParserTASK, Cobol85ParserTHREAD, Cobol85ParserTHREAD_LOCAL, Cobol85ParserTIMER, Cobol85ParserTODAYS_DATE, Cobol85ParserTODAYS_NAME, Cobol85ParserTRUNCATED, Cobol85ParserTYPEDEF, Cobol85ParserUNDERLINE, Cobol85ParserVIRTUAL, Cobol85ParserWAIT, Cobol85ParserYEAR, Cobol85ParserYYYYMMDD, Cobol85ParserYYYYDDD, Cobol85ParserZERO_FILL, Cobol85ParserIDENTIFIER:
		{
			p.SetState(2198)
			p.DataName()
		}

	case Cobol85ParserLEVEL_NUMBER_66, Cobol85ParserLEVEL_NUMBER_77, Cobol85ParserLEVEL_NUMBER_88, Cobol85ParserINTEGERLITERAL:
		{
			p.SetState(2199)
			p.IntegerLiteral()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ILinageLinesAtBottomContext is an interface to support dynamic dispatch.
type ILinageLinesAtBottomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLinageLinesAtBottomContext differentiates from other interfaces.
	IsLinageLinesAtBottomContext()
}

type LinageLinesAtBottomContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLinageLinesAtBottomContext() *LinageLinesAtBottomContext {
	var p = new(LinageLinesAtBottomContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_linageLinesAtBottom
	return p
}

func (*LinageLinesAtBottomContext) IsLinageLinesAtBottomContext() {}

func NewLinageLinesAtBottomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LinageLinesAtBottomContext {
	var p = new(LinageLinesAtBottomContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_linageLinesAtBottom

	return p
}

func (s *LinageLinesAtBottomContext) GetParser() antlr.Parser { return s.parser }

func (s *LinageLinesAtBottomContext) BOTTOM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBOTTOM, 0)
}

func (s *LinageLinesAtBottomContext) DataName() IDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *LinageLinesAtBottomContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *LinageLinesAtBottomContext) LINES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLINES, 0)
}

func (s *LinageLinesAtBottomContext) AT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAT, 0)
}

func (s *LinageLinesAtBottomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LinageLinesAtBottomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LinageLinesAtBottomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLinageLinesAtBottom(s)
	}
}

func (s *LinageLinesAtBottomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLinageLinesAtBottom(s)
	}
}

func (p *Cobol85Parser) LinageLinesAtBottom() (localctx ILinageLinesAtBottomContext) {
	localctx = NewLinageLinesAtBottomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, Cobol85ParserRULE_linageLinesAtBottom)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2203)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserLINES {
		{
			p.SetState(2202)
			p.Match(Cobol85ParserLINES)
		}

	}
	p.SetState(2206)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserAT {
		{
			p.SetState(2205)
			p.Match(Cobol85ParserAT)
		}

	}
	{
		p.SetState(2208)
		p.Match(Cobol85ParserBOTTOM)
	}
	p.SetState(2211)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserABORT, Cobol85ParserAS, Cobol85ParserASCII, Cobol85ParserASSOCIATED_DATA, Cobol85ParserASSOCIATED_DATA_LENGTH, Cobol85ParserATTRIBUTE, Cobol85ParserAUTO, Cobol85ParserAUTO_SKIP, Cobol85ParserBACKGROUND_COLOR, Cobol85ParserBACKGROUND_COLOUR, Cobol85ParserBEEP, Cobol85ParserBELL, Cobol85ParserBINARY, Cobol85ParserBIT, Cobol85ParserBLINK, Cobol85ParserBOUNDS, Cobol85ParserCAPABLE, Cobol85ParserCCSVERSION, Cobol85ParserCHANGED, Cobol85ParserCHANNEL, Cobol85ParserCLOSE_DISPOSITION, Cobol85ParserCOBOL, Cobol85ParserCOMMITMENT, Cobol85ParserCONTROL_POINT, Cobol85ParserCONVENTION, Cobol85ParserCRUNCH, Cobol85ParserCURSOR, Cobol85ParserDEFAULT, Cobol85ParserDEFAULT_DISPLAY, Cobol85ParserDEFINITION, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserDISK, Cobol85ParserDONTCARE, Cobol85ParserDOUBLE, Cobol85ParserEBCDIC, Cobol85ParserEMPTY_CHECK, Cobol85ParserENTER, Cobol85ParserENTRY_PROCEDURE, Cobol85ParserERASE, Cobol85ParserEOL, Cobol85ParserEOS, Cobol85ParserESCAPE, Cobol85ParserEVENT, Cobol85ParserEXCLUSIVE, Cobol85ParserEXPORT, Cobol85ParserEXTENDED, Cobol85ParserFOREGROUND_COLOR, Cobol85ParserFOREGROUND_COLOUR, Cobol85ParserFULL, Cobol85ParserFUNCTIONNAME, Cobol85ParserFUNCTION_POINTER, Cobol85ParserGRID, Cobol85ParserHIGHLIGHT, Cobol85ParserIMPLICIT, Cobol85ParserIMPORT, Cobol85ParserINTEGER, Cobol85ParserKEPT, Cobol85ParserKEYBOARD, Cobol85ParserLANGUAGE, Cobol85ParserLB, Cobol85ParserLD, Cobol85ParserLEFTLINE, Cobol85ParserLENGTH_CHECK, Cobol85ParserLIBACCESS, Cobol85ParserLIBPARAMETER, Cobol85ParserLIBRARY, Cobol85ParserLIST, Cobol85ParserLOCAL, Cobol85ParserLONG_DATE, Cobol85ParserLONG_TIME, Cobol85ParserLOWER, Cobol85ParserLOWLIGHT, Cobol85ParserMMDDYYYY, Cobol85ParserNAMED, Cobol85ParserNATIONAL, Cobol85ParserNATIONAL_EDITED, Cobol85ParserNETWORK, Cobol85ParserNO_ECHO, Cobol85ParserNUMERIC_DATE, Cobol85ParserNUMERIC_TIME, Cobol85ParserODT, Cobol85ParserORDERLY, Cobol85ParserOVERLINE, Cobol85ParserOWN, Cobol85ParserPASSWORD, Cobol85ParserPORT, Cobol85ParserPRINTER, Cobol85ParserPRIVATE, Cobol85ParserPROCESS, Cobol85ParserPROGRAM, Cobol85ParserPROMPT, Cobol85ParserREADER, Cobol85ParserREMOTE, Cobol85ParserREAL, Cobol85ParserRECEIVED, Cobol85ParserRECURSIVE, Cobol85ParserREF, Cobol85ParserREMOVE, Cobol85ParserREQUIRED, Cobol85ParserREVERSE_VIDEO, Cobol85ParserSAVE, Cobol85ParserSECURE, Cobol85ParserSHARED, Cobol85ParserSHAREDBYALL, Cobol85ParserSHAREDBYRUNUNIT, Cobol85ParserSHARING, Cobol85ParserSHORT_DATE, Cobol85ParserSYMBOL, Cobol85ParserTASK, Cobol85ParserTHREAD, Cobol85ParserTHREAD_LOCAL, Cobol85ParserTIMER, Cobol85ParserTODAYS_DATE, Cobol85ParserTODAYS_NAME, Cobol85ParserTRUNCATED, Cobol85ParserTYPEDEF, Cobol85ParserUNDERLINE, Cobol85ParserVIRTUAL, Cobol85ParserWAIT, Cobol85ParserYEAR, Cobol85ParserYYYYMMDD, Cobol85ParserYYYYDDD, Cobol85ParserZERO_FILL, Cobol85ParserIDENTIFIER:
		{
			p.SetState(2209)
			p.DataName()
		}

	case Cobol85ParserLEVEL_NUMBER_66, Cobol85ParserLEVEL_NUMBER_77, Cobol85ParserLEVEL_NUMBER_88, Cobol85ParserINTEGERLITERAL:
		{
			p.SetState(2210)
			p.IntegerLiteral()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IRecordingModeClauseContext is an interface to support dynamic dispatch.
type IRecordingModeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRecordingModeClauseContext differentiates from other interfaces.
	IsRecordingModeClauseContext()
}

type RecordingModeClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordingModeClauseContext() *RecordingModeClauseContext {
	var p = new(RecordingModeClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_recordingModeClause
	return p
}

func (*RecordingModeClauseContext) IsRecordingModeClauseContext() {}

func NewRecordingModeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordingModeClauseContext {
	var p = new(RecordingModeClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_recordingModeClause

	return p
}

func (s *RecordingModeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordingModeClauseContext) RECORDING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRECORDING, 0)
}

func (s *RecordingModeClauseContext) ModeStatement() IModeStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModeStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModeStatementContext)
}

func (s *RecordingModeClauseContext) MODE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMODE, 0)
}

func (s *RecordingModeClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *RecordingModeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordingModeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordingModeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterRecordingModeClause(s)
	}
}

func (s *RecordingModeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitRecordingModeClause(s)
	}
}

func (p *Cobol85Parser) RecordingModeClause() (localctx IRecordingModeClauseContext) {
	localctx = NewRecordingModeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, Cobol85ParserRULE_recordingModeClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2213)
		p.Match(Cobol85ParserRECORDING)
	}
	p.SetState(2215)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserMODE {
		{
			p.SetState(2214)
			p.Match(Cobol85ParserMODE)
		}

	}
	p.SetState(2218)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2217)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(2220)
		p.ModeStatement()
	}

	return localctx
}

// IModeStatementContext is an interface to support dynamic dispatch.
type IModeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModeStatementContext differentiates from other interfaces.
	IsModeStatementContext()
}

type ModeStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModeStatementContext() *ModeStatementContext {
	var p = new(ModeStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_modeStatement
	return p
}

func (*ModeStatementContext) IsModeStatementContext() {}

func NewModeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModeStatementContext {
	var p = new(ModeStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_modeStatement

	return p
}

func (s *ModeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ModeStatementContext) CobolWord() ICobolWordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICobolWordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *ModeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterModeStatement(s)
	}
}

func (s *ModeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitModeStatement(s)
	}
}

func (p *Cobol85Parser) ModeStatement() (localctx IModeStatementContext) {
	localctx = NewModeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, Cobol85ParserRULE_modeStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2222)
		p.CobolWord()
	}

	return localctx
}

// ICodeSetClauseContext is an interface to support dynamic dispatch.
type ICodeSetClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCodeSetClauseContext differentiates from other interfaces.
	IsCodeSetClauseContext()
}

type CodeSetClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCodeSetClauseContext() *CodeSetClauseContext {
	var p = new(CodeSetClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_codeSetClause
	return p
}

func (*CodeSetClauseContext) IsCodeSetClauseContext() {}

func NewCodeSetClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CodeSetClauseContext {
	var p = new(CodeSetClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_codeSetClause

	return p
}

func (s *CodeSetClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CodeSetClauseContext) CODE_SET() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCODE_SET, 0)
}

func (s *CodeSetClauseContext) AlphabetName() IAlphabetNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlphabetNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlphabetNameContext)
}

func (s *CodeSetClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *CodeSetClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CodeSetClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CodeSetClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCodeSetClause(s)
	}
}

func (s *CodeSetClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCodeSetClause(s)
	}
}

func (p *Cobol85Parser) CodeSetClause() (localctx ICodeSetClauseContext) {
	localctx = NewCodeSetClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, Cobol85ParserRULE_codeSetClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2224)
		p.Match(Cobol85ParserCODE_SET)
	}
	p.SetState(2226)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2225)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(2228)
		p.AlphabetName()
	}

	return localctx
}

// IReportClauseContext is an interface to support dynamic dispatch.
type IReportClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportClauseContext differentiates from other interfaces.
	IsReportClauseContext()
}

type ReportClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportClauseContext() *ReportClauseContext {
	var p = new(ReportClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportClause
	return p
}

func (*ReportClauseContext) IsReportClauseContext() {}

func NewReportClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportClauseContext {
	var p = new(ReportClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportClause

	return p
}

func (s *ReportClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportClauseContext) REPORT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREPORT, 0)
}

func (s *ReportClauseContext) REPORTS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREPORTS, 0)
}

func (s *ReportClauseContext) AllReportName() []IReportNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IReportNameContext)(nil)).Elem())
	var tst = make([]IReportNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IReportNameContext)
		}
	}

	return tst
}

func (s *ReportClauseContext) ReportName(i int) IReportNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IReportNameContext)
}

func (s *ReportClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ReportClauseContext) ARE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserARE, 0)
}

func (s *ReportClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportClause(s)
	}
}

func (s *ReportClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportClause(s)
	}
}

func (p *Cobol85Parser) ReportClause() (localctx IReportClauseContext) {
	localctx = NewReportClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, Cobol85ParserRULE_reportClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2238)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserREPORT:
		{
			p.SetState(2230)
			p.Match(Cobol85ParserREPORT)
		}
		p.SetState(2232)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserIS {
			{
				p.SetState(2231)
				p.Match(Cobol85ParserIS)
			}

		}

	case Cobol85ParserREPORTS:
		{
			p.SetState(2234)
			p.Match(Cobol85ParserREPORTS)
		}
		p.SetState(2236)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserARE {
			{
				p.SetState(2235)
				p.Match(Cobol85ParserARE)
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(2241)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH)|(1<<Cobol85ParserATTRIBUTE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBINARY-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-68))|(1<<(Cobol85ParserCOBOL-68))|(1<<(Cobol85ParserCOMMITMENT-68))|(1<<(Cobol85ParserCONTROL_POINT-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(Cobol85ParserCONVENTION-100))|(1<<(Cobol85ParserCRUNCH-100))|(1<<(Cobol85ParserCURSOR-100))|(1<<(Cobol85ParserDEFAULT-100))|(1<<(Cobol85ParserDEFAULT_DISPLAY-100))|(1<<(Cobol85ParserDEFINITION-100)))) != 0) || (((_la-138)&-(0x1f+1)) == 0 && ((1<<uint((_la-138)))&((1<<(Cobol85ParserDFHRESP-138))|(1<<(Cobol85ParserDFHVALUE-138))|(1<<(Cobol85ParserDISK-138))|(1<<(Cobol85ParserDONTCARE-138))|(1<<(Cobol85ParserDOUBLE-138))|(1<<(Cobol85ParserEBCDIC-138))|(1<<(Cobol85ParserEMPTY_CHECK-138)))) != 0) || (((_la-181)&-(0x1f+1)) == 0 && ((1<<uint((_la-181)))&((1<<(Cobol85ParserENTER-181))|(1<<(Cobol85ParserENTRY_PROCEDURE-181))|(1<<(Cobol85ParserERASE-181))|(1<<(Cobol85ParserEOL-181))|(1<<(Cobol85ParserEOS-181))|(1<<(Cobol85ParserESCAPE-181))|(1<<(Cobol85ParserEVENT-181))|(1<<(Cobol85ParserEXCLUSIVE-181))|(1<<(Cobol85ParserEXPORT-181))|(1<<(Cobol85ParserEXTENDED-181)))) != 0) || (((_la-213)&-(0x1f+1)) == 0 && ((1<<uint((_la-213)))&((1<<(Cobol85ParserFOREGROUND_COLOR-213))|(1<<(Cobol85ParserFOREGROUND_COLOUR-213))|(1<<(Cobol85ParserFULL-213))|(1<<(Cobol85ParserFUNCTIONNAME-213))|(1<<(Cobol85ParserFUNCTION_POINTER-213))|(1<<(Cobol85ParserGRID-213))|(1<<(Cobol85ParserHIGHLIGHT-213))|(1<<(Cobol85ParserIMPLICIT-213))|(1<<(Cobol85ParserIMPORT-213)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(Cobol85ParserINTEGER-250))|(1<<(Cobol85ParserKEPT-250))|(1<<(Cobol85ParserKEYBOARD-250))|(1<<(Cobol85ParserLANGUAGE-250))|(1<<(Cobol85ParserLB-250))|(1<<(Cobol85ParserLD-250))|(1<<(Cobol85ParserLEFTLINE-250))|(1<<(Cobol85ParserLENGTH_CHECK-250))|(1<<(Cobol85ParserLIBACCESS-250))|(1<<(Cobol85ParserLIBPARAMETER-250))|(1<<(Cobol85ParserLIBRARY-250))|(1<<(Cobol85ParserLINAGE_COUNTER-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(Cobol85ParserLIST-283))|(1<<(Cobol85ParserLOCAL-283))|(1<<(Cobol85ParserLONG_DATE-283))|(1<<(Cobol85ParserLONG_TIME-283))|(1<<(Cobol85ParserLOWER-283))|(1<<(Cobol85ParserLOWLIGHT-283))|(1<<(Cobol85ParserMMDDYYYY-283))|(1<<(Cobol85ParserNAMED-283))|(1<<(Cobol85ParserNATIONAL-283))|(1<<(Cobol85ParserNATIONAL_EDITED-283))|(1<<(Cobol85ParserNETWORK-283))|(1<<(Cobol85ParserNO_ECHO-283)))) != 0) || (((_la-317)&-(0x1f+1)) == 0 && ((1<<uint((_la-317)))&((1<<(Cobol85ParserNUMERIC_DATE-317))|(1<<(Cobol85ParserNUMERIC_TIME-317))|(1<<(Cobol85ParserODT-317))|(1<<(Cobol85ParserORDERLY-317))|(1<<(Cobol85ParserOVERLINE-317))|(1<<(Cobol85ParserOWN-317))|(1<<(Cobol85ParserPASSWORD-317)))) != 0) || (((_la-352)&-(0x1f+1)) == 0 && ((1<<uint((_la-352)))&((1<<(Cobol85ParserPORT-352))|(1<<(Cobol85ParserPRINTER-352))|(1<<(Cobol85ParserPRIVATE-352))|(1<<(Cobol85ParserPROCESS-352))|(1<<(Cobol85ParserPROGRAM-352))|(1<<(Cobol85ParserPROMPT-352))|(1<<(Cobol85ParserREADER-352))|(1<<(Cobol85ParserREMOTE-352))|(1<<(Cobol85ParserREAL-352))|(1<<(Cobol85ParserRECEIVED-352))|(1<<(Cobol85ParserRECURSIVE-352))|(1<<(Cobol85ParserREF-352)))) != 0) || (((_la-391)&-(0x1f+1)) == 0 && ((1<<uint((_la-391)))&((1<<(Cobol85ParserREMOVE-391))|(1<<(Cobol85ParserREQUIRED-391))|(1<<(Cobol85ParserREVERSE_VIDEO-391))|(1<<(Cobol85ParserSAVE-391))|(1<<(Cobol85ParserSECURE-391)))) != 0) || (((_la-431)&-(0x1f+1)) == 0 && ((1<<uint((_la-431)))&((1<<(Cobol85ParserSHARED-431))|(1<<(Cobol85ParserSHAREDBYALL-431))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-431))|(1<<(Cobol85ParserSHARING-431))|(1<<(Cobol85ParserSHORT_DATE-431)))) != 0) || (((_la-466)&-(0x1f+1)) == 0 && ((1<<uint((_la-466)))&((1<<(Cobol85ParserSYMBOL-466))|(1<<(Cobol85ParserTASK-466))|(1<<(Cobol85ParserTHREAD-466))|(1<<(Cobol85ParserTHREAD_LOCAL-466))|(1<<(Cobol85ParserTIMER-466))|(1<<(Cobol85ParserTODAYS_DATE-466))|(1<<(Cobol85ParserTODAYS_NAME-466))|(1<<(Cobol85ParserTRUNCATED-466))|(1<<(Cobol85ParserTYPEDEF-466)))) != 0) || (((_la-498)&-(0x1f+1)) == 0 && ((1<<uint((_la-498)))&((1<<(Cobol85ParserUNDERLINE-498))|(1<<(Cobol85ParserVIRTUAL-498))|(1<<(Cobol85ParserWAIT-498))|(1<<(Cobol85ParserYEAR-498))|(1<<(Cobol85ParserYYYYMMDD-498))|(1<<(Cobol85ParserYYYYDDD-498))|(1<<(Cobol85ParserZERO_FILL-498)))) != 0) || (((_la-552)&-(0x1f+1)) == 0 && ((1<<uint((_la-552)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-552))|(1<<(Cobol85ParserLEVEL_NUMBER_77-552))|(1<<(Cobol85ParserLEVEL_NUMBER_88-552))|(1<<(Cobol85ParserINTEGERLITERAL-552))|(1<<(Cobol85ParserIDENTIFIER-552)))) != 0) {
		{
			p.SetState(2240)
			p.ReportName()
		}

		p.SetState(2243)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IDataBaseSectionContext is an interface to support dynamic dispatch.
type IDataBaseSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataBaseSectionContext differentiates from other interfaces.
	IsDataBaseSectionContext()
}

type DataBaseSectionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataBaseSectionContext() *DataBaseSectionContext {
	var p = new(DataBaseSectionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataBaseSection
	return p
}

func (*DataBaseSectionContext) IsDataBaseSectionContext() {}

func NewDataBaseSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataBaseSectionContext {
	var p = new(DataBaseSectionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataBaseSection

	return p
}

func (s *DataBaseSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *DataBaseSectionContext) DATA_BASE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDATA_BASE, 0)
}

func (s *DataBaseSectionContext) SECTION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSECTION, 0)
}

func (s *DataBaseSectionContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *DataBaseSectionContext) AllDataBaseSectionEntry() []IDataBaseSectionEntryContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDataBaseSectionEntryContext)(nil)).Elem())
	var tst = make([]IDataBaseSectionEntryContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDataBaseSectionEntryContext)
		}
	}

	return tst
}

func (s *DataBaseSectionContext) DataBaseSectionEntry(i int) IDataBaseSectionEntryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataBaseSectionEntryContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDataBaseSectionEntryContext)
}

func (s *DataBaseSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataBaseSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataBaseSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataBaseSection(s)
	}
}

func (s *DataBaseSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataBaseSection(s)
	}
}

func (p *Cobol85Parser) DataBaseSection() (localctx IDataBaseSectionContext) {
	localctx = NewDataBaseSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, Cobol85ParserRULE_dataBaseSection)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2245)
		p.Match(Cobol85ParserDATA_BASE)
	}
	{
		p.SetState(2246)
		p.Match(Cobol85ParserSECTION)
	}
	{
		p.SetState(2247)
		p.Match(Cobol85ParserDOT_FS)
	}
	p.SetState(2251)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ((_la-552)&-(0x1f+1)) == 0 && ((1<<uint((_la-552)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-552))|(1<<(Cobol85ParserLEVEL_NUMBER_77-552))|(1<<(Cobol85ParserLEVEL_NUMBER_88-552))|(1<<(Cobol85ParserINTEGERLITERAL-552)))) != 0 {
		{
			p.SetState(2248)
			p.DataBaseSectionEntry()
		}

		p.SetState(2253)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IDataBaseSectionEntryContext is an interface to support dynamic dispatch.
type IDataBaseSectionEntryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataBaseSectionEntryContext differentiates from other interfaces.
	IsDataBaseSectionEntryContext()
}

type DataBaseSectionEntryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataBaseSectionEntryContext() *DataBaseSectionEntryContext {
	var p = new(DataBaseSectionEntryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataBaseSectionEntry
	return p
}

func (*DataBaseSectionEntryContext) IsDataBaseSectionEntryContext() {}

func NewDataBaseSectionEntryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataBaseSectionEntryContext {
	var p = new(DataBaseSectionEntryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataBaseSectionEntry

	return p
}

func (s *DataBaseSectionEntryContext) GetParser() antlr.Parser { return s.parser }

func (s *DataBaseSectionEntryContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *DataBaseSectionEntryContext) AllLiteral() []ILiteralContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILiteralContext)(nil)).Elem())
	var tst = make([]ILiteralContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILiteralContext)
		}
	}

	return tst
}

func (s *DataBaseSectionEntryContext) Literal(i int) ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *DataBaseSectionEntryContext) INVOKE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINVOKE, 0)
}

func (s *DataBaseSectionEntryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataBaseSectionEntryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataBaseSectionEntryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataBaseSectionEntry(s)
	}
}

func (s *DataBaseSectionEntryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataBaseSectionEntry(s)
	}
}

func (p *Cobol85Parser) DataBaseSectionEntry() (localctx IDataBaseSectionEntryContext) {
	localctx = NewDataBaseSectionEntryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, Cobol85ParserRULE_dataBaseSectionEntry)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2254)
		p.IntegerLiteral()
	}
	{
		p.SetState(2255)
		p.Literal()
	}
	{
		p.SetState(2256)
		p.Match(Cobol85ParserINVOKE)
	}
	{
		p.SetState(2257)
		p.Literal()
	}

	return localctx
}

// IWorkingStorageSectionContext is an interface to support dynamic dispatch.
type IWorkingStorageSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWorkingStorageSectionContext differentiates from other interfaces.
	IsWorkingStorageSectionContext()
}

type WorkingStorageSectionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWorkingStorageSectionContext() *WorkingStorageSectionContext {
	var p = new(WorkingStorageSectionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_workingStorageSection
	return p
}

func (*WorkingStorageSectionContext) IsWorkingStorageSectionContext() {}

func NewWorkingStorageSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WorkingStorageSectionContext {
	var p = new(WorkingStorageSectionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_workingStorageSection

	return p
}

func (s *WorkingStorageSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *WorkingStorageSectionContext) WORKING_STORAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWORKING_STORAGE, 0)
}

func (s *WorkingStorageSectionContext) SECTION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSECTION, 0)
}

func (s *WorkingStorageSectionContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *WorkingStorageSectionContext) AllDataDescriptionEntry() []IDataDescriptionEntryContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDataDescriptionEntryContext)(nil)).Elem())
	var tst = make([]IDataDescriptionEntryContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDataDescriptionEntryContext)
		}
	}

	return tst
}

func (s *WorkingStorageSectionContext) DataDescriptionEntry(i int) IDataDescriptionEntryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataDescriptionEntryContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDataDescriptionEntryContext)
}

func (s *WorkingStorageSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WorkingStorageSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WorkingStorageSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterWorkingStorageSection(s)
	}
}

func (s *WorkingStorageSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitWorkingStorageSection(s)
	}
}

func (p *Cobol85Parser) WorkingStorageSection() (localctx IWorkingStorageSectionContext) {
	localctx = NewWorkingStorageSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, Cobol85ParserRULE_workingStorageSection)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2259)
		p.Match(Cobol85ParserWORKING_STORAGE)
	}
	{
		p.SetState(2260)
		p.Match(Cobol85ParserSECTION)
	}
	{
		p.SetState(2261)
		p.Match(Cobol85ParserDOT_FS)
	}
	p.SetState(2265)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ((_la-552)&-(0x1f+1)) == 0 && ((1<<uint((_la-552)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-552))|(1<<(Cobol85ParserLEVEL_NUMBER_77-552))|(1<<(Cobol85ParserLEVEL_NUMBER_88-552))|(1<<(Cobol85ParserINTEGERLITERAL-552))|(1<<(Cobol85ParserEXECSQLLINE-552)))) != 0 {
		{
			p.SetState(2262)
			p.DataDescriptionEntry()
		}

		p.SetState(2267)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ILinkageSectionContext is an interface to support dynamic dispatch.
type ILinkageSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLinkageSectionContext differentiates from other interfaces.
	IsLinkageSectionContext()
}

type LinkageSectionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLinkageSectionContext() *LinkageSectionContext {
	var p = new(LinkageSectionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_linkageSection
	return p
}

func (*LinkageSectionContext) IsLinkageSectionContext() {}

func NewLinkageSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LinkageSectionContext {
	var p = new(LinkageSectionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_linkageSection

	return p
}

func (s *LinkageSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *LinkageSectionContext) LINKAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLINKAGE, 0)
}

func (s *LinkageSectionContext) SECTION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSECTION, 0)
}

func (s *LinkageSectionContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *LinkageSectionContext) AllDataDescriptionEntry() []IDataDescriptionEntryContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDataDescriptionEntryContext)(nil)).Elem())
	var tst = make([]IDataDescriptionEntryContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDataDescriptionEntryContext)
		}
	}

	return tst
}

func (s *LinkageSectionContext) DataDescriptionEntry(i int) IDataDescriptionEntryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataDescriptionEntryContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDataDescriptionEntryContext)
}

func (s *LinkageSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LinkageSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LinkageSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLinkageSection(s)
	}
}

func (s *LinkageSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLinkageSection(s)
	}
}

func (p *Cobol85Parser) LinkageSection() (localctx ILinkageSectionContext) {
	localctx = NewLinkageSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, Cobol85ParserRULE_linkageSection)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2268)
		p.Match(Cobol85ParserLINKAGE)
	}
	{
		p.SetState(2269)
		p.Match(Cobol85ParserSECTION)
	}
	{
		p.SetState(2270)
		p.Match(Cobol85ParserDOT_FS)
	}
	p.SetState(2274)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ((_la-552)&-(0x1f+1)) == 0 && ((1<<uint((_la-552)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-552))|(1<<(Cobol85ParserLEVEL_NUMBER_77-552))|(1<<(Cobol85ParserLEVEL_NUMBER_88-552))|(1<<(Cobol85ParserINTEGERLITERAL-552))|(1<<(Cobol85ParserEXECSQLLINE-552)))) != 0 {
		{
			p.SetState(2271)
			p.DataDescriptionEntry()
		}

		p.SetState(2276)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ICommunicationSectionContext is an interface to support dynamic dispatch.
type ICommunicationSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCommunicationSectionContext differentiates from other interfaces.
	IsCommunicationSectionContext()
}

type CommunicationSectionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommunicationSectionContext() *CommunicationSectionContext {
	var p = new(CommunicationSectionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_communicationSection
	return p
}

func (*CommunicationSectionContext) IsCommunicationSectionContext() {}

func NewCommunicationSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommunicationSectionContext {
	var p = new(CommunicationSectionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_communicationSection

	return p
}

func (s *CommunicationSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *CommunicationSectionContext) COMMUNICATION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMMUNICATION, 0)
}

func (s *CommunicationSectionContext) SECTION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSECTION, 0)
}

func (s *CommunicationSectionContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *CommunicationSectionContext) AllCommunicationDescriptionEntry() []ICommunicationDescriptionEntryContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICommunicationDescriptionEntryContext)(nil)).Elem())
	var tst = make([]ICommunicationDescriptionEntryContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICommunicationDescriptionEntryContext)
		}
	}

	return tst
}

func (s *CommunicationSectionContext) CommunicationDescriptionEntry(i int) ICommunicationDescriptionEntryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICommunicationDescriptionEntryContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICommunicationDescriptionEntryContext)
}

func (s *CommunicationSectionContext) AllDataDescriptionEntry() []IDataDescriptionEntryContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDataDescriptionEntryContext)(nil)).Elem())
	var tst = make([]IDataDescriptionEntryContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDataDescriptionEntryContext)
		}
	}

	return tst
}

func (s *CommunicationSectionContext) DataDescriptionEntry(i int) IDataDescriptionEntryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataDescriptionEntryContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDataDescriptionEntryContext)
}

func (s *CommunicationSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommunicationSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommunicationSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCommunicationSection(s)
	}
}

func (s *CommunicationSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCommunicationSection(s)
	}
}

func (p *Cobol85Parser) CommunicationSection() (localctx ICommunicationSectionContext) {
	localctx = NewCommunicationSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, Cobol85ParserRULE_communicationSection)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2277)
		p.Match(Cobol85ParserCOMMUNICATION)
	}
	{
		p.SetState(2278)
		p.Match(Cobol85ParserSECTION)
	}
	{
		p.SetState(2279)
		p.Match(Cobol85ParserDOT_FS)
	}
	p.SetState(2284)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserCD || (((_la-552)&-(0x1f+1)) == 0 && ((1<<uint((_la-552)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-552))|(1<<(Cobol85ParserLEVEL_NUMBER_77-552))|(1<<(Cobol85ParserLEVEL_NUMBER_88-552))|(1<<(Cobol85ParserINTEGERLITERAL-552))|(1<<(Cobol85ParserEXECSQLLINE-552)))) != 0) {
		p.SetState(2282)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case Cobol85ParserCD:
			{
				p.SetState(2280)
				p.CommunicationDescriptionEntry()
			}

		case Cobol85ParserLEVEL_NUMBER_66, Cobol85ParserLEVEL_NUMBER_77, Cobol85ParserLEVEL_NUMBER_88, Cobol85ParserINTEGERLITERAL, Cobol85ParserEXECSQLLINE:
			{
				p.SetState(2281)
				p.DataDescriptionEntry()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(2286)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ICommunicationDescriptionEntryContext is an interface to support dynamic dispatch.
type ICommunicationDescriptionEntryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCommunicationDescriptionEntryContext differentiates from other interfaces.
	IsCommunicationDescriptionEntryContext()
}

type CommunicationDescriptionEntryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommunicationDescriptionEntryContext() *CommunicationDescriptionEntryContext {
	var p = new(CommunicationDescriptionEntryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_communicationDescriptionEntry
	return p
}

func (*CommunicationDescriptionEntryContext) IsCommunicationDescriptionEntryContext() {}

func NewCommunicationDescriptionEntryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommunicationDescriptionEntryContext {
	var p = new(CommunicationDescriptionEntryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_communicationDescriptionEntry

	return p
}

func (s *CommunicationDescriptionEntryContext) GetParser() antlr.Parser { return s.parser }

func (s *CommunicationDescriptionEntryContext) CommunicationDescriptionEntryFormat1() ICommunicationDescriptionEntryFormat1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICommunicationDescriptionEntryFormat1Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICommunicationDescriptionEntryFormat1Context)
}

func (s *CommunicationDescriptionEntryContext) CommunicationDescriptionEntryFormat2() ICommunicationDescriptionEntryFormat2Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICommunicationDescriptionEntryFormat2Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICommunicationDescriptionEntryFormat2Context)
}

func (s *CommunicationDescriptionEntryContext) CommunicationDescriptionEntryFormat3() ICommunicationDescriptionEntryFormat3Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICommunicationDescriptionEntryFormat3Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICommunicationDescriptionEntryFormat3Context)
}

func (s *CommunicationDescriptionEntryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommunicationDescriptionEntryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommunicationDescriptionEntryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCommunicationDescriptionEntry(s)
	}
}

func (s *CommunicationDescriptionEntryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCommunicationDescriptionEntry(s)
	}
}

func (p *Cobol85Parser) CommunicationDescriptionEntry() (localctx ICommunicationDescriptionEntryContext) {
	localctx = NewCommunicationDescriptionEntryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, Cobol85ParserRULE_communicationDescriptionEntry)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2290)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 229, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2287)
			p.CommunicationDescriptionEntryFormat1()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2288)
			p.CommunicationDescriptionEntryFormat2()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2289)
			p.CommunicationDescriptionEntryFormat3()
		}

	}

	return localctx
}

// ICommunicationDescriptionEntryFormat1Context is an interface to support dynamic dispatch.
type ICommunicationDescriptionEntryFormat1Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCommunicationDescriptionEntryFormat1Context differentiates from other interfaces.
	IsCommunicationDescriptionEntryFormat1Context()
}

type CommunicationDescriptionEntryFormat1Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommunicationDescriptionEntryFormat1Context() *CommunicationDescriptionEntryFormat1Context {
	var p = new(CommunicationDescriptionEntryFormat1Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_communicationDescriptionEntryFormat1
	return p
}

func (*CommunicationDescriptionEntryFormat1Context) IsCommunicationDescriptionEntryFormat1Context() {}

func NewCommunicationDescriptionEntryFormat1Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommunicationDescriptionEntryFormat1Context {
	var p = new(CommunicationDescriptionEntryFormat1Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_communicationDescriptionEntryFormat1

	return p
}

func (s *CommunicationDescriptionEntryFormat1Context) GetParser() antlr.Parser { return s.parser }

func (s *CommunicationDescriptionEntryFormat1Context) CD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCD, 0)
}

func (s *CommunicationDescriptionEntryFormat1Context) CdName() ICdNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICdNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICdNameContext)
}

func (s *CommunicationDescriptionEntryFormat1Context) INPUT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINPUT, 0)
}

func (s *CommunicationDescriptionEntryFormat1Context) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *CommunicationDescriptionEntryFormat1Context) FOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOR, 0)
}

func (s *CommunicationDescriptionEntryFormat1Context) INITIAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINITIAL, 0)
}

func (s *CommunicationDescriptionEntryFormat1Context) AllDataDescName() []IDataDescNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDataDescNameContext)(nil)).Elem())
	var tst = make([]IDataDescNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDataDescNameContext)
		}
	}

	return tst
}

func (s *CommunicationDescriptionEntryFormat1Context) DataDescName(i int) IDataDescNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataDescNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDataDescNameContext)
}

func (s *CommunicationDescriptionEntryFormat1Context) AllSymbolicQueueClause() []ISymbolicQueueClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISymbolicQueueClauseContext)(nil)).Elem())
	var tst = make([]ISymbolicQueueClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISymbolicQueueClauseContext)
		}
	}

	return tst
}

func (s *CommunicationDescriptionEntryFormat1Context) SymbolicQueueClause(i int) ISymbolicQueueClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolicQueueClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISymbolicQueueClauseContext)
}

func (s *CommunicationDescriptionEntryFormat1Context) AllSymbolicSubQueueClause() []ISymbolicSubQueueClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISymbolicSubQueueClauseContext)(nil)).Elem())
	var tst = make([]ISymbolicSubQueueClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISymbolicSubQueueClauseContext)
		}
	}

	return tst
}

func (s *CommunicationDescriptionEntryFormat1Context) SymbolicSubQueueClause(i int) ISymbolicSubQueueClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolicSubQueueClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISymbolicSubQueueClauseContext)
}

func (s *CommunicationDescriptionEntryFormat1Context) AllMessageDateClause() []IMessageDateClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMessageDateClauseContext)(nil)).Elem())
	var tst = make([]IMessageDateClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMessageDateClauseContext)
		}
	}

	return tst
}

func (s *CommunicationDescriptionEntryFormat1Context) MessageDateClause(i int) IMessageDateClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMessageDateClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMessageDateClauseContext)
}

func (s *CommunicationDescriptionEntryFormat1Context) AllMessageTimeClause() []IMessageTimeClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMessageTimeClauseContext)(nil)).Elem())
	var tst = make([]IMessageTimeClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMessageTimeClauseContext)
		}
	}

	return tst
}

func (s *CommunicationDescriptionEntryFormat1Context) MessageTimeClause(i int) IMessageTimeClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMessageTimeClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMessageTimeClauseContext)
}

func (s *CommunicationDescriptionEntryFormat1Context) AllSymbolicSourceClause() []ISymbolicSourceClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISymbolicSourceClauseContext)(nil)).Elem())
	var tst = make([]ISymbolicSourceClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISymbolicSourceClauseContext)
		}
	}

	return tst
}

func (s *CommunicationDescriptionEntryFormat1Context) SymbolicSourceClause(i int) ISymbolicSourceClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolicSourceClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISymbolicSourceClauseContext)
}

func (s *CommunicationDescriptionEntryFormat1Context) AllTextLengthClause() []ITextLengthClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITextLengthClauseContext)(nil)).Elem())
	var tst = make([]ITextLengthClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITextLengthClauseContext)
		}
	}

	return tst
}

func (s *CommunicationDescriptionEntryFormat1Context) TextLengthClause(i int) ITextLengthClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITextLengthClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITextLengthClauseContext)
}

func (s *CommunicationDescriptionEntryFormat1Context) AllEndKeyClause() []IEndKeyClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEndKeyClauseContext)(nil)).Elem())
	var tst = make([]IEndKeyClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEndKeyClauseContext)
		}
	}

	return tst
}

func (s *CommunicationDescriptionEntryFormat1Context) EndKeyClause(i int) IEndKeyClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndKeyClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEndKeyClauseContext)
}

func (s *CommunicationDescriptionEntryFormat1Context) AllStatusKeyClause() []IStatusKeyClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatusKeyClauseContext)(nil)).Elem())
	var tst = make([]IStatusKeyClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatusKeyClauseContext)
		}
	}

	return tst
}

func (s *CommunicationDescriptionEntryFormat1Context) StatusKeyClause(i int) IStatusKeyClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatusKeyClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatusKeyClauseContext)
}

func (s *CommunicationDescriptionEntryFormat1Context) AllMessageCountClause() []IMessageCountClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMessageCountClauseContext)(nil)).Elem())
	var tst = make([]IMessageCountClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMessageCountClauseContext)
		}
	}

	return tst
}

func (s *CommunicationDescriptionEntryFormat1Context) MessageCountClause(i int) IMessageCountClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMessageCountClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMessageCountClauseContext)
}

func (s *CommunicationDescriptionEntryFormat1Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommunicationDescriptionEntryFormat1Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommunicationDescriptionEntryFormat1Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCommunicationDescriptionEntryFormat1(s)
	}
}

func (s *CommunicationDescriptionEntryFormat1Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCommunicationDescriptionEntryFormat1(s)
	}
}

func (p *Cobol85Parser) CommunicationDescriptionEntryFormat1() (localctx ICommunicationDescriptionEntryFormat1Context) {
	localctx = NewCommunicationDescriptionEntryFormat1Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, Cobol85ParserRULE_communicationDescriptionEntryFormat1)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2292)
		p.Match(Cobol85ParserCD)
	}
	{
		p.SetState(2293)
		p.CdName()
	}
	p.SetState(2295)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFOR {
		{
			p.SetState(2294)
			p.Match(Cobol85ParserFOR)
		}

	}
	p.SetState(2298)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserINITIAL {
		{
			p.SetState(2297)
			p.Match(Cobol85ParserINITIAL)
		}

	}
	{
		p.SetState(2300)
		p.Match(Cobol85ParserINPUT)
	}
	p.SetState(2315)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH)|(1<<Cobol85ParserATTRIBUTE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBINARY-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-68))|(1<<(Cobol85ParserCOBOL-68))|(1<<(Cobol85ParserCOMMITMENT-68))|(1<<(Cobol85ParserCONTROL_POINT-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(Cobol85ParserCONVENTION-100))|(1<<(Cobol85ParserCOUNT-100))|(1<<(Cobol85ParserCRUNCH-100))|(1<<(Cobol85ParserCURSOR-100))|(1<<(Cobol85ParserDEFAULT-100))|(1<<(Cobol85ParserDEFAULT_DISPLAY-100))|(1<<(Cobol85ParserDEFINITION-100)))) != 0) || (((_la-138)&-(0x1f+1)) == 0 && ((1<<uint((_la-138)))&((1<<(Cobol85ParserDFHRESP-138))|(1<<(Cobol85ParserDFHVALUE-138))|(1<<(Cobol85ParserDISK-138))|(1<<(Cobol85ParserDONTCARE-138))|(1<<(Cobol85ParserDOUBLE-138))|(1<<(Cobol85ParserEBCDIC-138))|(1<<(Cobol85ParserEMPTY_CHECK-138))|(1<<(Cobol85ParserEND-138)))) != 0) || (((_la-181)&-(0x1f+1)) == 0 && ((1<<uint((_la-181)))&((1<<(Cobol85ParserENTER-181))|(1<<(Cobol85ParserENTRY_PROCEDURE-181))|(1<<(Cobol85ParserERASE-181))|(1<<(Cobol85ParserEOL-181))|(1<<(Cobol85ParserEOS-181))|(1<<(Cobol85ParserESCAPE-181))|(1<<(Cobol85ParserEVENT-181))|(1<<(Cobol85ParserEXCLUSIVE-181))|(1<<(Cobol85ParserEXPORT-181))|(1<<(Cobol85ParserEXTENDED-181))|(1<<(Cobol85ParserFILLER-181)))) != 0) || (((_la-213)&-(0x1f+1)) == 0 && ((1<<uint((_la-213)))&((1<<(Cobol85ParserFOREGROUND_COLOR-213))|(1<<(Cobol85ParserFOREGROUND_COLOUR-213))|(1<<(Cobol85ParserFULL-213))|(1<<(Cobol85ParserFUNCTIONNAME-213))|(1<<(Cobol85ParserFUNCTION_POINTER-213))|(1<<(Cobol85ParserGRID-213))|(1<<(Cobol85ParserHIGHLIGHT-213))|(1<<(Cobol85ParserIMPLICIT-213))|(1<<(Cobol85ParserIMPORT-213)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(Cobol85ParserINTEGER-250))|(1<<(Cobol85ParserKEPT-250))|(1<<(Cobol85ParserKEYBOARD-250))|(1<<(Cobol85ParserLANGUAGE-250))|(1<<(Cobol85ParserLB-250))|(1<<(Cobol85ParserLD-250))|(1<<(Cobol85ParserLEFTLINE-250))|(1<<(Cobol85ParserLENGTH_CHECK-250))|(1<<(Cobol85ParserLIBACCESS-250))|(1<<(Cobol85ParserLIBPARAMETER-250))|(1<<(Cobol85ParserLIBRARY-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(Cobol85ParserLIST-283))|(1<<(Cobol85ParserLOCAL-283))|(1<<(Cobol85ParserLONG_DATE-283))|(1<<(Cobol85ParserLONG_TIME-283))|(1<<(Cobol85ParserLOWER-283))|(1<<(Cobol85ParserLOWLIGHT-283))|(1<<(Cobol85ParserMESSAGE-283))|(1<<(Cobol85ParserMMDDYYYY-283))|(1<<(Cobol85ParserNAMED-283))|(1<<(Cobol85ParserNATIONAL-283))|(1<<(Cobol85ParserNATIONAL_EDITED-283))|(1<<(Cobol85ParserNETWORK-283))|(1<<(Cobol85ParserNO_ECHO-283)))) != 0) || (((_la-317)&-(0x1f+1)) == 0 && ((1<<uint((_la-317)))&((1<<(Cobol85ParserNUMERIC_DATE-317))|(1<<(Cobol85ParserNUMERIC_TIME-317))|(1<<(Cobol85ParserODT-317))|(1<<(Cobol85ParserORDERLY-317))|(1<<(Cobol85ParserOVERLINE-317))|(1<<(Cobol85ParserOWN-317))|(1<<(Cobol85ParserPASSWORD-317)))) != 0) || (((_la-352)&-(0x1f+1)) == 0 && ((1<<uint((_la-352)))&((1<<(Cobol85ParserPORT-352))|(1<<(Cobol85ParserPRINTER-352))|(1<<(Cobol85ParserPRIVATE-352))|(1<<(Cobol85ParserPROCESS-352))|(1<<(Cobol85ParserPROGRAM-352))|(1<<(Cobol85ParserPROMPT-352))|(1<<(Cobol85ParserQUEUE-352))|(1<<(Cobol85ParserREADER-352))|(1<<(Cobol85ParserREMOTE-352))|(1<<(Cobol85ParserREAL-352))|(1<<(Cobol85ParserRECEIVED-352))|(1<<(Cobol85ParserRECURSIVE-352))|(1<<(Cobol85ParserREF-352)))) != 0) || (((_la-391)&-(0x1f+1)) == 0 && ((1<<uint((_la-391)))&((1<<(Cobol85ParserREMOVE-391))|(1<<(Cobol85ParserREQUIRED-391))|(1<<(Cobol85ParserREVERSE_VIDEO-391))|(1<<(Cobol85ParserSAVE-391))|(1<<(Cobol85ParserSECURE-391)))) != 0) || (((_la-431)&-(0x1f+1)) == 0 && ((1<<uint((_la-431)))&((1<<(Cobol85ParserSHARED-431))|(1<<(Cobol85ParserSHAREDBYALL-431))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-431))|(1<<(Cobol85ParserSHARING-431))|(1<<(Cobol85ParserSHORT_DATE-431))|(1<<(Cobol85ParserSOURCE-431))|(1<<(Cobol85ParserSTATUS-431))|(1<<(Cobol85ParserSUB_QUEUE_1-431))|(1<<(Cobol85ParserSUB_QUEUE_2-431))|(1<<(Cobol85ParserSUB_QUEUE_3-431)))) != 0) || (((_la-466)&-(0x1f+1)) == 0 && ((1<<uint((_la-466)))&((1<<(Cobol85ParserSYMBOL-466))|(1<<(Cobol85ParserSYMBOLIC-466))|(1<<(Cobol85ParserTASK-466))|(1<<(Cobol85ParserTEXT-466))|(1<<(Cobol85ParserTHREAD-466))|(1<<(Cobol85ParserTHREAD_LOCAL-466))|(1<<(Cobol85ParserTIMER-466))|(1<<(Cobol85ParserTODAYS_DATE-466))|(1<<(Cobol85ParserTODAYS_NAME-466))|(1<<(Cobol85ParserTRUNCATED-466))|(1<<(Cobol85ParserTYPEDEF-466)))) != 0) || (((_la-498)&-(0x1f+1)) == 0 && ((1<<uint((_la-498)))&((1<<(Cobol85ParserUNDERLINE-498))|(1<<(Cobol85ParserVIRTUAL-498))|(1<<(Cobol85ParserWAIT-498))|(1<<(Cobol85ParserYEAR-498))|(1<<(Cobol85ParserYYYYMMDD-498))|(1<<(Cobol85ParserYYYYDDD-498))|(1<<(Cobol85ParserZERO_FILL-498)))) != 0) || _la == Cobol85ParserIDENTIFIER {
		p.SetState(2313)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case Cobol85ParserCOUNT, Cobol85ParserEND, Cobol85ParserMESSAGE, Cobol85ParserQUEUE, Cobol85ParserSOURCE, Cobol85ParserSTATUS, Cobol85ParserSUB_QUEUE_1, Cobol85ParserSUB_QUEUE_2, Cobol85ParserSUB_QUEUE_3, Cobol85ParserSYMBOLIC, Cobol85ParserTEXT:
			p.SetState(2310)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 232, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(2301)
					p.SymbolicQueueClause()
				}

			case 2:
				{
					p.SetState(2302)
					p.SymbolicSubQueueClause()
				}

			case 3:
				{
					p.SetState(2303)
					p.MessageDateClause()
				}

			case 4:
				{
					p.SetState(2304)
					p.MessageTimeClause()
				}

			case 5:
				{
					p.SetState(2305)
					p.SymbolicSourceClause()
				}

			case 6:
				{
					p.SetState(2306)
					p.TextLengthClause()
				}

			case 7:
				{
					p.SetState(2307)
					p.EndKeyClause()
				}

			case 8:
				{
					p.SetState(2308)
					p.StatusKeyClause()
				}

			case 9:
				{
					p.SetState(2309)
					p.MessageCountClause()
				}

			}

		case Cobol85ParserABORT, Cobol85ParserAS, Cobol85ParserASCII, Cobol85ParserASSOCIATED_DATA, Cobol85ParserASSOCIATED_DATA_LENGTH, Cobol85ParserATTRIBUTE, Cobol85ParserAUTO, Cobol85ParserAUTO_SKIP, Cobol85ParserBACKGROUND_COLOR, Cobol85ParserBACKGROUND_COLOUR, Cobol85ParserBEEP, Cobol85ParserBELL, Cobol85ParserBINARY, Cobol85ParserBIT, Cobol85ParserBLINK, Cobol85ParserBOUNDS, Cobol85ParserCAPABLE, Cobol85ParserCCSVERSION, Cobol85ParserCHANGED, Cobol85ParserCHANNEL, Cobol85ParserCLOSE_DISPOSITION, Cobol85ParserCOBOL, Cobol85ParserCOMMITMENT, Cobol85ParserCONTROL_POINT, Cobol85ParserCONVENTION, Cobol85ParserCRUNCH, Cobol85ParserCURSOR, Cobol85ParserDEFAULT, Cobol85ParserDEFAULT_DISPLAY, Cobol85ParserDEFINITION, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserDISK, Cobol85ParserDONTCARE, Cobol85ParserDOUBLE, Cobol85ParserEBCDIC, Cobol85ParserEMPTY_CHECK, Cobol85ParserENTER, Cobol85ParserENTRY_PROCEDURE, Cobol85ParserERASE, Cobol85ParserEOL, Cobol85ParserEOS, Cobol85ParserESCAPE, Cobol85ParserEVENT, Cobol85ParserEXCLUSIVE, Cobol85ParserEXPORT, Cobol85ParserEXTENDED, Cobol85ParserFILLER, Cobol85ParserFOREGROUND_COLOR, Cobol85ParserFOREGROUND_COLOUR, Cobol85ParserFULL, Cobol85ParserFUNCTIONNAME, Cobol85ParserFUNCTION_POINTER, Cobol85ParserGRID, Cobol85ParserHIGHLIGHT, Cobol85ParserIMPLICIT, Cobol85ParserIMPORT, Cobol85ParserINTEGER, Cobol85ParserKEPT, Cobol85ParserKEYBOARD, Cobol85ParserLANGUAGE, Cobol85ParserLB, Cobol85ParserLD, Cobol85ParserLEFTLINE, Cobol85ParserLENGTH_CHECK, Cobol85ParserLIBACCESS, Cobol85ParserLIBPARAMETER, Cobol85ParserLIBRARY, Cobol85ParserLIST, Cobol85ParserLOCAL, Cobol85ParserLONG_DATE, Cobol85ParserLONG_TIME, Cobol85ParserLOWER, Cobol85ParserLOWLIGHT, Cobol85ParserMMDDYYYY, Cobol85ParserNAMED, Cobol85ParserNATIONAL, Cobol85ParserNATIONAL_EDITED, Cobol85ParserNETWORK, Cobol85ParserNO_ECHO, Cobol85ParserNUMERIC_DATE, Cobol85ParserNUMERIC_TIME, Cobol85ParserODT, Cobol85ParserORDERLY, Cobol85ParserOVERLINE, Cobol85ParserOWN, Cobol85ParserPASSWORD, Cobol85ParserPORT, Cobol85ParserPRINTER, Cobol85ParserPRIVATE, Cobol85ParserPROCESS, Cobol85ParserPROGRAM, Cobol85ParserPROMPT, Cobol85ParserREADER, Cobol85ParserREMOTE, Cobol85ParserREAL, Cobol85ParserRECEIVED, Cobol85ParserRECURSIVE, Cobol85ParserREF, Cobol85ParserREMOVE, Cobol85ParserREQUIRED, Cobol85ParserREVERSE_VIDEO, Cobol85ParserSAVE, Cobol85ParserSECURE, Cobol85ParserSHARED, Cobol85ParserSHAREDBYALL, Cobol85ParserSHAREDBYRUNUNIT, Cobol85ParserSHARING, Cobol85ParserSHORT_DATE, Cobol85ParserSYMBOL, Cobol85ParserTASK, Cobol85ParserTHREAD, Cobol85ParserTHREAD_LOCAL, Cobol85ParserTIMER, Cobol85ParserTODAYS_DATE, Cobol85ParserTODAYS_NAME, Cobol85ParserTRUNCATED, Cobol85ParserTYPEDEF, Cobol85ParserUNDERLINE, Cobol85ParserVIRTUAL, Cobol85ParserWAIT, Cobol85ParserYEAR, Cobol85ParserYYYYMMDD, Cobol85ParserYYYYDDD, Cobol85ParserZERO_FILL, Cobol85ParserIDENTIFIER:
			{
				p.SetState(2312)
				p.DataDescName()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(2317)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2318)
		p.Match(Cobol85ParserDOT_FS)
	}

	return localctx
}

// ICommunicationDescriptionEntryFormat2Context is an interface to support dynamic dispatch.
type ICommunicationDescriptionEntryFormat2Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCommunicationDescriptionEntryFormat2Context differentiates from other interfaces.
	IsCommunicationDescriptionEntryFormat2Context()
}

type CommunicationDescriptionEntryFormat2Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommunicationDescriptionEntryFormat2Context() *CommunicationDescriptionEntryFormat2Context {
	var p = new(CommunicationDescriptionEntryFormat2Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_communicationDescriptionEntryFormat2
	return p
}

func (*CommunicationDescriptionEntryFormat2Context) IsCommunicationDescriptionEntryFormat2Context() {}

func NewCommunicationDescriptionEntryFormat2Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommunicationDescriptionEntryFormat2Context {
	var p = new(CommunicationDescriptionEntryFormat2Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_communicationDescriptionEntryFormat2

	return p
}

func (s *CommunicationDescriptionEntryFormat2Context) GetParser() antlr.Parser { return s.parser }

func (s *CommunicationDescriptionEntryFormat2Context) CD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCD, 0)
}

func (s *CommunicationDescriptionEntryFormat2Context) CdName() ICdNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICdNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICdNameContext)
}

func (s *CommunicationDescriptionEntryFormat2Context) OUTPUT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOUTPUT, 0)
}

func (s *CommunicationDescriptionEntryFormat2Context) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *CommunicationDescriptionEntryFormat2Context) FOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOR, 0)
}

func (s *CommunicationDescriptionEntryFormat2Context) AllDestinationCountClause() []IDestinationCountClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDestinationCountClauseContext)(nil)).Elem())
	var tst = make([]IDestinationCountClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDestinationCountClauseContext)
		}
	}

	return tst
}

func (s *CommunicationDescriptionEntryFormat2Context) DestinationCountClause(i int) IDestinationCountClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDestinationCountClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDestinationCountClauseContext)
}

func (s *CommunicationDescriptionEntryFormat2Context) AllTextLengthClause() []ITextLengthClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITextLengthClauseContext)(nil)).Elem())
	var tst = make([]ITextLengthClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITextLengthClauseContext)
		}
	}

	return tst
}

func (s *CommunicationDescriptionEntryFormat2Context) TextLengthClause(i int) ITextLengthClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITextLengthClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITextLengthClauseContext)
}

func (s *CommunicationDescriptionEntryFormat2Context) AllStatusKeyClause() []IStatusKeyClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatusKeyClauseContext)(nil)).Elem())
	var tst = make([]IStatusKeyClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatusKeyClauseContext)
		}
	}

	return tst
}

func (s *CommunicationDescriptionEntryFormat2Context) StatusKeyClause(i int) IStatusKeyClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatusKeyClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatusKeyClauseContext)
}

func (s *CommunicationDescriptionEntryFormat2Context) AllDestinationTableClause() []IDestinationTableClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDestinationTableClauseContext)(nil)).Elem())
	var tst = make([]IDestinationTableClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDestinationTableClauseContext)
		}
	}

	return tst
}

func (s *CommunicationDescriptionEntryFormat2Context) DestinationTableClause(i int) IDestinationTableClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDestinationTableClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDestinationTableClauseContext)
}

func (s *CommunicationDescriptionEntryFormat2Context) AllErrorKeyClause() []IErrorKeyClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IErrorKeyClauseContext)(nil)).Elem())
	var tst = make([]IErrorKeyClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IErrorKeyClauseContext)
		}
	}

	return tst
}

func (s *CommunicationDescriptionEntryFormat2Context) ErrorKeyClause(i int) IErrorKeyClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IErrorKeyClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IErrorKeyClauseContext)
}

func (s *CommunicationDescriptionEntryFormat2Context) AllSymbolicDestinationClause() []ISymbolicDestinationClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISymbolicDestinationClauseContext)(nil)).Elem())
	var tst = make([]ISymbolicDestinationClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISymbolicDestinationClauseContext)
		}
	}

	return tst
}

func (s *CommunicationDescriptionEntryFormat2Context) SymbolicDestinationClause(i int) ISymbolicDestinationClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolicDestinationClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISymbolicDestinationClauseContext)
}

func (s *CommunicationDescriptionEntryFormat2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommunicationDescriptionEntryFormat2Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommunicationDescriptionEntryFormat2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCommunicationDescriptionEntryFormat2(s)
	}
}

func (s *CommunicationDescriptionEntryFormat2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCommunicationDescriptionEntryFormat2(s)
	}
}

func (p *Cobol85Parser) CommunicationDescriptionEntryFormat2() (localctx ICommunicationDescriptionEntryFormat2Context) {
	localctx = NewCommunicationDescriptionEntryFormat2Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, Cobol85ParserRULE_communicationDescriptionEntryFormat2)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2320)
		p.Match(Cobol85ParserCD)
	}
	{
		p.SetState(2321)
		p.CdName()
	}
	p.SetState(2323)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFOR {
		{
			p.SetState(2322)
			p.Match(Cobol85ParserFOR)
		}

	}
	{
		p.SetState(2325)
		p.Match(Cobol85ParserOUTPUT)
	}
	p.SetState(2334)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserDESTINATION || _la == Cobol85ParserERROR || (((_la-457)&-(0x1f+1)) == 0 && ((1<<uint((_la-457)))&((1<<(Cobol85ParserSTATUS-457))|(1<<(Cobol85ParserSYMBOLIC-457))|(1<<(Cobol85ParserTEXT-457)))) != 0) {
		p.SetState(2332)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 236, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(2326)
				p.DestinationCountClause()
			}

		case 2:
			{
				p.SetState(2327)
				p.TextLengthClause()
			}

		case 3:
			{
				p.SetState(2328)
				p.StatusKeyClause()
			}

		case 4:
			{
				p.SetState(2329)
				p.DestinationTableClause()
			}

		case 5:
			{
				p.SetState(2330)
				p.ErrorKeyClause()
			}

		case 6:
			{
				p.SetState(2331)
				p.SymbolicDestinationClause()
			}

		}

		p.SetState(2336)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2337)
		p.Match(Cobol85ParserDOT_FS)
	}

	return localctx
}

// ICommunicationDescriptionEntryFormat3Context is an interface to support dynamic dispatch.
type ICommunicationDescriptionEntryFormat3Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCommunicationDescriptionEntryFormat3Context differentiates from other interfaces.
	IsCommunicationDescriptionEntryFormat3Context()
}

type CommunicationDescriptionEntryFormat3Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommunicationDescriptionEntryFormat3Context() *CommunicationDescriptionEntryFormat3Context {
	var p = new(CommunicationDescriptionEntryFormat3Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_communicationDescriptionEntryFormat3
	return p
}

func (*CommunicationDescriptionEntryFormat3Context) IsCommunicationDescriptionEntryFormat3Context() {}

func NewCommunicationDescriptionEntryFormat3Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommunicationDescriptionEntryFormat3Context {
	var p = new(CommunicationDescriptionEntryFormat3Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_communicationDescriptionEntryFormat3

	return p
}

func (s *CommunicationDescriptionEntryFormat3Context) GetParser() antlr.Parser { return s.parser }

func (s *CommunicationDescriptionEntryFormat3Context) CD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCD, 0)
}

func (s *CommunicationDescriptionEntryFormat3Context) CdName() ICdNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICdNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICdNameContext)
}

func (s *CommunicationDescriptionEntryFormat3Context) INITIAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINITIAL, 0)
}

func (s *CommunicationDescriptionEntryFormat3Context) I_O() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserI_O, 0)
}

func (s *CommunicationDescriptionEntryFormat3Context) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *CommunicationDescriptionEntryFormat3Context) FOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOR, 0)
}

func (s *CommunicationDescriptionEntryFormat3Context) AllDataDescName() []IDataDescNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDataDescNameContext)(nil)).Elem())
	var tst = make([]IDataDescNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDataDescNameContext)
		}
	}

	return tst
}

func (s *CommunicationDescriptionEntryFormat3Context) DataDescName(i int) IDataDescNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataDescNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDataDescNameContext)
}

func (s *CommunicationDescriptionEntryFormat3Context) AllMessageDateClause() []IMessageDateClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMessageDateClauseContext)(nil)).Elem())
	var tst = make([]IMessageDateClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMessageDateClauseContext)
		}
	}

	return tst
}

func (s *CommunicationDescriptionEntryFormat3Context) MessageDateClause(i int) IMessageDateClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMessageDateClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMessageDateClauseContext)
}

func (s *CommunicationDescriptionEntryFormat3Context) AllMessageTimeClause() []IMessageTimeClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMessageTimeClauseContext)(nil)).Elem())
	var tst = make([]IMessageTimeClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMessageTimeClauseContext)
		}
	}

	return tst
}

func (s *CommunicationDescriptionEntryFormat3Context) MessageTimeClause(i int) IMessageTimeClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMessageTimeClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMessageTimeClauseContext)
}

func (s *CommunicationDescriptionEntryFormat3Context) AllSymbolicTerminalClause() []ISymbolicTerminalClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISymbolicTerminalClauseContext)(nil)).Elem())
	var tst = make([]ISymbolicTerminalClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISymbolicTerminalClauseContext)
		}
	}

	return tst
}

func (s *CommunicationDescriptionEntryFormat3Context) SymbolicTerminalClause(i int) ISymbolicTerminalClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolicTerminalClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISymbolicTerminalClauseContext)
}

func (s *CommunicationDescriptionEntryFormat3Context) AllTextLengthClause() []ITextLengthClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITextLengthClauseContext)(nil)).Elem())
	var tst = make([]ITextLengthClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITextLengthClauseContext)
		}
	}

	return tst
}

func (s *CommunicationDescriptionEntryFormat3Context) TextLengthClause(i int) ITextLengthClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITextLengthClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITextLengthClauseContext)
}

func (s *CommunicationDescriptionEntryFormat3Context) AllEndKeyClause() []IEndKeyClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEndKeyClauseContext)(nil)).Elem())
	var tst = make([]IEndKeyClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEndKeyClauseContext)
		}
	}

	return tst
}

func (s *CommunicationDescriptionEntryFormat3Context) EndKeyClause(i int) IEndKeyClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndKeyClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEndKeyClauseContext)
}

func (s *CommunicationDescriptionEntryFormat3Context) AllStatusKeyClause() []IStatusKeyClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatusKeyClauseContext)(nil)).Elem())
	var tst = make([]IStatusKeyClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatusKeyClauseContext)
		}
	}

	return tst
}

func (s *CommunicationDescriptionEntryFormat3Context) StatusKeyClause(i int) IStatusKeyClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatusKeyClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatusKeyClauseContext)
}

func (s *CommunicationDescriptionEntryFormat3Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommunicationDescriptionEntryFormat3Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommunicationDescriptionEntryFormat3Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCommunicationDescriptionEntryFormat3(s)
	}
}

func (s *CommunicationDescriptionEntryFormat3Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCommunicationDescriptionEntryFormat3(s)
	}
}

func (p *Cobol85Parser) CommunicationDescriptionEntryFormat3() (localctx ICommunicationDescriptionEntryFormat3Context) {
	localctx = NewCommunicationDescriptionEntryFormat3Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, Cobol85ParserRULE_communicationDescriptionEntryFormat3)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2339)
		p.Match(Cobol85ParserCD)
	}
	{
		p.SetState(2340)
		p.CdName()
	}
	p.SetState(2342)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFOR {
		{
			p.SetState(2341)
			p.Match(Cobol85ParserFOR)
		}

	}
	{
		p.SetState(2344)
		p.Match(Cobol85ParserINITIAL)
	}
	{
		p.SetState(2345)
		p.Match(Cobol85ParserI_O)
	}
	p.SetState(2357)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH)|(1<<Cobol85ParserATTRIBUTE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBINARY-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-68))|(1<<(Cobol85ParserCOBOL-68))|(1<<(Cobol85ParserCOMMITMENT-68))|(1<<(Cobol85ParserCONTROL_POINT-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(Cobol85ParserCONVENTION-100))|(1<<(Cobol85ParserCRUNCH-100))|(1<<(Cobol85ParserCURSOR-100))|(1<<(Cobol85ParserDEFAULT-100))|(1<<(Cobol85ParserDEFAULT_DISPLAY-100))|(1<<(Cobol85ParserDEFINITION-100)))) != 0) || (((_la-138)&-(0x1f+1)) == 0 && ((1<<uint((_la-138)))&((1<<(Cobol85ParserDFHRESP-138))|(1<<(Cobol85ParserDFHVALUE-138))|(1<<(Cobol85ParserDISK-138))|(1<<(Cobol85ParserDONTCARE-138))|(1<<(Cobol85ParserDOUBLE-138))|(1<<(Cobol85ParserEBCDIC-138))|(1<<(Cobol85ParserEMPTY_CHECK-138))|(1<<(Cobol85ParserEND-138)))) != 0) || (((_la-181)&-(0x1f+1)) == 0 && ((1<<uint((_la-181)))&((1<<(Cobol85ParserENTER-181))|(1<<(Cobol85ParserENTRY_PROCEDURE-181))|(1<<(Cobol85ParserERASE-181))|(1<<(Cobol85ParserEOL-181))|(1<<(Cobol85ParserEOS-181))|(1<<(Cobol85ParserESCAPE-181))|(1<<(Cobol85ParserEVENT-181))|(1<<(Cobol85ParserEXCLUSIVE-181))|(1<<(Cobol85ParserEXPORT-181))|(1<<(Cobol85ParserEXTENDED-181))|(1<<(Cobol85ParserFILLER-181)))) != 0) || (((_la-213)&-(0x1f+1)) == 0 && ((1<<uint((_la-213)))&((1<<(Cobol85ParserFOREGROUND_COLOR-213))|(1<<(Cobol85ParserFOREGROUND_COLOUR-213))|(1<<(Cobol85ParserFULL-213))|(1<<(Cobol85ParserFUNCTIONNAME-213))|(1<<(Cobol85ParserFUNCTION_POINTER-213))|(1<<(Cobol85ParserGRID-213))|(1<<(Cobol85ParserHIGHLIGHT-213))|(1<<(Cobol85ParserIMPLICIT-213))|(1<<(Cobol85ParserIMPORT-213)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(Cobol85ParserINTEGER-250))|(1<<(Cobol85ParserKEPT-250))|(1<<(Cobol85ParserKEYBOARD-250))|(1<<(Cobol85ParserLANGUAGE-250))|(1<<(Cobol85ParserLB-250))|(1<<(Cobol85ParserLD-250))|(1<<(Cobol85ParserLEFTLINE-250))|(1<<(Cobol85ParserLENGTH_CHECK-250))|(1<<(Cobol85ParserLIBACCESS-250))|(1<<(Cobol85ParserLIBPARAMETER-250))|(1<<(Cobol85ParserLIBRARY-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(Cobol85ParserLIST-283))|(1<<(Cobol85ParserLOCAL-283))|(1<<(Cobol85ParserLONG_DATE-283))|(1<<(Cobol85ParserLONG_TIME-283))|(1<<(Cobol85ParserLOWER-283))|(1<<(Cobol85ParserLOWLIGHT-283))|(1<<(Cobol85ParserMESSAGE-283))|(1<<(Cobol85ParserMMDDYYYY-283))|(1<<(Cobol85ParserNAMED-283))|(1<<(Cobol85ParserNATIONAL-283))|(1<<(Cobol85ParserNATIONAL_EDITED-283))|(1<<(Cobol85ParserNETWORK-283))|(1<<(Cobol85ParserNO_ECHO-283)))) != 0) || (((_la-317)&-(0x1f+1)) == 0 && ((1<<uint((_la-317)))&((1<<(Cobol85ParserNUMERIC_DATE-317))|(1<<(Cobol85ParserNUMERIC_TIME-317))|(1<<(Cobol85ParserODT-317))|(1<<(Cobol85ParserORDERLY-317))|(1<<(Cobol85ParserOVERLINE-317))|(1<<(Cobol85ParserOWN-317))|(1<<(Cobol85ParserPASSWORD-317)))) != 0) || (((_la-352)&-(0x1f+1)) == 0 && ((1<<uint((_la-352)))&((1<<(Cobol85ParserPORT-352))|(1<<(Cobol85ParserPRINTER-352))|(1<<(Cobol85ParserPRIVATE-352))|(1<<(Cobol85ParserPROCESS-352))|(1<<(Cobol85ParserPROGRAM-352))|(1<<(Cobol85ParserPROMPT-352))|(1<<(Cobol85ParserREADER-352))|(1<<(Cobol85ParserREMOTE-352))|(1<<(Cobol85ParserREAL-352))|(1<<(Cobol85ParserRECEIVED-352))|(1<<(Cobol85ParserRECURSIVE-352))|(1<<(Cobol85ParserREF-352)))) != 0) || (((_la-391)&-(0x1f+1)) == 0 && ((1<<uint((_la-391)))&((1<<(Cobol85ParserREMOVE-391))|(1<<(Cobol85ParserREQUIRED-391))|(1<<(Cobol85ParserREVERSE_VIDEO-391))|(1<<(Cobol85ParserSAVE-391))|(1<<(Cobol85ParserSECURE-391)))) != 0) || (((_la-431)&-(0x1f+1)) == 0 && ((1<<uint((_la-431)))&((1<<(Cobol85ParserSHARED-431))|(1<<(Cobol85ParserSHAREDBYALL-431))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-431))|(1<<(Cobol85ParserSHARING-431))|(1<<(Cobol85ParserSHORT_DATE-431))|(1<<(Cobol85ParserSTATUS-431)))) != 0) || (((_la-466)&-(0x1f+1)) == 0 && ((1<<uint((_la-466)))&((1<<(Cobol85ParserSYMBOL-466))|(1<<(Cobol85ParserSYMBOLIC-466))|(1<<(Cobol85ParserTASK-466))|(1<<(Cobol85ParserTERMINAL-466))|(1<<(Cobol85ParserTEXT-466))|(1<<(Cobol85ParserTHREAD-466))|(1<<(Cobol85ParserTHREAD_LOCAL-466))|(1<<(Cobol85ParserTIMER-466))|(1<<(Cobol85ParserTODAYS_DATE-466))|(1<<(Cobol85ParserTODAYS_NAME-466))|(1<<(Cobol85ParserTRUNCATED-466))|(1<<(Cobol85ParserTYPEDEF-466)))) != 0) || (((_la-498)&-(0x1f+1)) == 0 && ((1<<uint((_la-498)))&((1<<(Cobol85ParserUNDERLINE-498))|(1<<(Cobol85ParserVIRTUAL-498))|(1<<(Cobol85ParserWAIT-498))|(1<<(Cobol85ParserYEAR-498))|(1<<(Cobol85ParserYYYYMMDD-498))|(1<<(Cobol85ParserYYYYDDD-498))|(1<<(Cobol85ParserZERO_FILL-498)))) != 0) || _la == Cobol85ParserIDENTIFIER {
		p.SetState(2355)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case Cobol85ParserEND, Cobol85ParserMESSAGE, Cobol85ParserSTATUS, Cobol85ParserSYMBOLIC, Cobol85ParserTERMINAL, Cobol85ParserTEXT:
			p.SetState(2352)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 239, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(2346)
					p.MessageDateClause()
				}

			case 2:
				{
					p.SetState(2347)
					p.MessageTimeClause()
				}

			case 3:
				{
					p.SetState(2348)
					p.SymbolicTerminalClause()
				}

			case 4:
				{
					p.SetState(2349)
					p.TextLengthClause()
				}

			case 5:
				{
					p.SetState(2350)
					p.EndKeyClause()
				}

			case 6:
				{
					p.SetState(2351)
					p.StatusKeyClause()
				}

			}

		case Cobol85ParserABORT, Cobol85ParserAS, Cobol85ParserASCII, Cobol85ParserASSOCIATED_DATA, Cobol85ParserASSOCIATED_DATA_LENGTH, Cobol85ParserATTRIBUTE, Cobol85ParserAUTO, Cobol85ParserAUTO_SKIP, Cobol85ParserBACKGROUND_COLOR, Cobol85ParserBACKGROUND_COLOUR, Cobol85ParserBEEP, Cobol85ParserBELL, Cobol85ParserBINARY, Cobol85ParserBIT, Cobol85ParserBLINK, Cobol85ParserBOUNDS, Cobol85ParserCAPABLE, Cobol85ParserCCSVERSION, Cobol85ParserCHANGED, Cobol85ParserCHANNEL, Cobol85ParserCLOSE_DISPOSITION, Cobol85ParserCOBOL, Cobol85ParserCOMMITMENT, Cobol85ParserCONTROL_POINT, Cobol85ParserCONVENTION, Cobol85ParserCRUNCH, Cobol85ParserCURSOR, Cobol85ParserDEFAULT, Cobol85ParserDEFAULT_DISPLAY, Cobol85ParserDEFINITION, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserDISK, Cobol85ParserDONTCARE, Cobol85ParserDOUBLE, Cobol85ParserEBCDIC, Cobol85ParserEMPTY_CHECK, Cobol85ParserENTER, Cobol85ParserENTRY_PROCEDURE, Cobol85ParserERASE, Cobol85ParserEOL, Cobol85ParserEOS, Cobol85ParserESCAPE, Cobol85ParserEVENT, Cobol85ParserEXCLUSIVE, Cobol85ParserEXPORT, Cobol85ParserEXTENDED, Cobol85ParserFILLER, Cobol85ParserFOREGROUND_COLOR, Cobol85ParserFOREGROUND_COLOUR, Cobol85ParserFULL, Cobol85ParserFUNCTIONNAME, Cobol85ParserFUNCTION_POINTER, Cobol85ParserGRID, Cobol85ParserHIGHLIGHT, Cobol85ParserIMPLICIT, Cobol85ParserIMPORT, Cobol85ParserINTEGER, Cobol85ParserKEPT, Cobol85ParserKEYBOARD, Cobol85ParserLANGUAGE, Cobol85ParserLB, Cobol85ParserLD, Cobol85ParserLEFTLINE, Cobol85ParserLENGTH_CHECK, Cobol85ParserLIBACCESS, Cobol85ParserLIBPARAMETER, Cobol85ParserLIBRARY, Cobol85ParserLIST, Cobol85ParserLOCAL, Cobol85ParserLONG_DATE, Cobol85ParserLONG_TIME, Cobol85ParserLOWER, Cobol85ParserLOWLIGHT, Cobol85ParserMMDDYYYY, Cobol85ParserNAMED, Cobol85ParserNATIONAL, Cobol85ParserNATIONAL_EDITED, Cobol85ParserNETWORK, Cobol85ParserNO_ECHO, Cobol85ParserNUMERIC_DATE, Cobol85ParserNUMERIC_TIME, Cobol85ParserODT, Cobol85ParserORDERLY, Cobol85ParserOVERLINE, Cobol85ParserOWN, Cobol85ParserPASSWORD, Cobol85ParserPORT, Cobol85ParserPRINTER, Cobol85ParserPRIVATE, Cobol85ParserPROCESS, Cobol85ParserPROGRAM, Cobol85ParserPROMPT, Cobol85ParserREADER, Cobol85ParserREMOTE, Cobol85ParserREAL, Cobol85ParserRECEIVED, Cobol85ParserRECURSIVE, Cobol85ParserREF, Cobol85ParserREMOVE, Cobol85ParserREQUIRED, Cobol85ParserREVERSE_VIDEO, Cobol85ParserSAVE, Cobol85ParserSECURE, Cobol85ParserSHARED, Cobol85ParserSHAREDBYALL, Cobol85ParserSHAREDBYRUNUNIT, Cobol85ParserSHARING, Cobol85ParserSHORT_DATE, Cobol85ParserSYMBOL, Cobol85ParserTASK, Cobol85ParserTHREAD, Cobol85ParserTHREAD_LOCAL, Cobol85ParserTIMER, Cobol85ParserTODAYS_DATE, Cobol85ParserTODAYS_NAME, Cobol85ParserTRUNCATED, Cobol85ParserTYPEDEF, Cobol85ParserUNDERLINE, Cobol85ParserVIRTUAL, Cobol85ParserWAIT, Cobol85ParserYEAR, Cobol85ParserYYYYMMDD, Cobol85ParserYYYYDDD, Cobol85ParserZERO_FILL, Cobol85ParserIDENTIFIER:
			{
				p.SetState(2354)
				p.DataDescName()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(2359)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2360)
		p.Match(Cobol85ParserDOT_FS)
	}

	return localctx
}

// IDestinationCountClauseContext is an interface to support dynamic dispatch.
type IDestinationCountClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDestinationCountClauseContext differentiates from other interfaces.
	IsDestinationCountClauseContext()
}

type DestinationCountClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDestinationCountClauseContext() *DestinationCountClauseContext {
	var p = new(DestinationCountClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_destinationCountClause
	return p
}

func (*DestinationCountClauseContext) IsDestinationCountClauseContext() {}

func NewDestinationCountClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DestinationCountClauseContext {
	var p = new(DestinationCountClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_destinationCountClause

	return p
}

func (s *DestinationCountClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DestinationCountClauseContext) DESTINATION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDESTINATION, 0)
}

func (s *DestinationCountClauseContext) COUNT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOUNT, 0)
}

func (s *DestinationCountClauseContext) DataDescName() IDataDescNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataDescNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataDescNameContext)
}

func (s *DestinationCountClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *DestinationCountClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DestinationCountClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DestinationCountClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDestinationCountClause(s)
	}
}

func (s *DestinationCountClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDestinationCountClause(s)
	}
}

func (p *Cobol85Parser) DestinationCountClause() (localctx IDestinationCountClauseContext) {
	localctx = NewDestinationCountClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, Cobol85ParserRULE_destinationCountClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2362)
		p.Match(Cobol85ParserDESTINATION)
	}
	{
		p.SetState(2363)
		p.Match(Cobol85ParserCOUNT)
	}
	p.SetState(2365)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2364)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(2367)
		p.DataDescName()
	}

	return localctx
}

// IDestinationTableClauseContext is an interface to support dynamic dispatch.
type IDestinationTableClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDestinationTableClauseContext differentiates from other interfaces.
	IsDestinationTableClauseContext()
}

type DestinationTableClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDestinationTableClauseContext() *DestinationTableClauseContext {
	var p = new(DestinationTableClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_destinationTableClause
	return p
}

func (*DestinationTableClauseContext) IsDestinationTableClauseContext() {}

func NewDestinationTableClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DestinationTableClauseContext {
	var p = new(DestinationTableClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_destinationTableClause

	return p
}

func (s *DestinationTableClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DestinationTableClauseContext) DESTINATION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDESTINATION, 0)
}

func (s *DestinationTableClauseContext) TABLE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTABLE, 0)
}

func (s *DestinationTableClauseContext) OCCURS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOCCURS, 0)
}

func (s *DestinationTableClauseContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *DestinationTableClauseContext) TIMES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTIMES, 0)
}

func (s *DestinationTableClauseContext) INDEXED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINDEXED, 0)
}

func (s *DestinationTableClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBY, 0)
}

func (s *DestinationTableClauseContext) AllIndexName() []IIndexNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIndexNameContext)(nil)).Elem())
	var tst = make([]IIndexNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIndexNameContext)
		}
	}

	return tst
}

func (s *DestinationTableClauseContext) IndexName(i int) IIndexNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIndexNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIndexNameContext)
}

func (s *DestinationTableClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DestinationTableClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DestinationTableClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDestinationTableClause(s)
	}
}

func (s *DestinationTableClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDestinationTableClause(s)
	}
}

func (p *Cobol85Parser) DestinationTableClause() (localctx IDestinationTableClauseContext) {
	localctx = NewDestinationTableClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, Cobol85ParserRULE_destinationTableClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2369)
		p.Match(Cobol85ParserDESTINATION)
	}
	{
		p.SetState(2370)
		p.Match(Cobol85ParserTABLE)
	}
	{
		p.SetState(2371)
		p.Match(Cobol85ParserOCCURS)
	}
	{
		p.SetState(2372)
		p.IntegerLiteral()
	}
	{
		p.SetState(2373)
		p.Match(Cobol85ParserTIMES)
	}
	p.SetState(2381)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserINDEXED {
		{
			p.SetState(2374)
			p.Match(Cobol85ParserINDEXED)
		}
		{
			p.SetState(2375)
			p.Match(Cobol85ParserBY)
		}
		p.SetState(2377)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH)|(1<<Cobol85ParserATTRIBUTE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBINARY-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-68))|(1<<(Cobol85ParserCOBOL-68))|(1<<(Cobol85ParserCOMMITMENT-68))|(1<<(Cobol85ParserCONTROL_POINT-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(Cobol85ParserCONVENTION-100))|(1<<(Cobol85ParserCRUNCH-100))|(1<<(Cobol85ParserCURSOR-100))|(1<<(Cobol85ParserDEFAULT-100))|(1<<(Cobol85ParserDEFAULT_DISPLAY-100))|(1<<(Cobol85ParserDEFINITION-100)))) != 0) || (((_la-138)&-(0x1f+1)) == 0 && ((1<<uint((_la-138)))&((1<<(Cobol85ParserDFHRESP-138))|(1<<(Cobol85ParserDFHVALUE-138))|(1<<(Cobol85ParserDISK-138))|(1<<(Cobol85ParserDONTCARE-138))|(1<<(Cobol85ParserDOUBLE-138))|(1<<(Cobol85ParserEBCDIC-138))|(1<<(Cobol85ParserEMPTY_CHECK-138)))) != 0) || (((_la-181)&-(0x1f+1)) == 0 && ((1<<uint((_la-181)))&((1<<(Cobol85ParserENTER-181))|(1<<(Cobol85ParserENTRY_PROCEDURE-181))|(1<<(Cobol85ParserERASE-181))|(1<<(Cobol85ParserEOL-181))|(1<<(Cobol85ParserEOS-181))|(1<<(Cobol85ParserESCAPE-181))|(1<<(Cobol85ParserEVENT-181))|(1<<(Cobol85ParserEXCLUSIVE-181))|(1<<(Cobol85ParserEXPORT-181))|(1<<(Cobol85ParserEXTENDED-181)))) != 0) || (((_la-213)&-(0x1f+1)) == 0 && ((1<<uint((_la-213)))&((1<<(Cobol85ParserFOREGROUND_COLOR-213))|(1<<(Cobol85ParserFOREGROUND_COLOUR-213))|(1<<(Cobol85ParserFULL-213))|(1<<(Cobol85ParserFUNCTIONNAME-213))|(1<<(Cobol85ParserFUNCTION_POINTER-213))|(1<<(Cobol85ParserGRID-213))|(1<<(Cobol85ParserHIGHLIGHT-213))|(1<<(Cobol85ParserIMPLICIT-213))|(1<<(Cobol85ParserIMPORT-213)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(Cobol85ParserINTEGER-250))|(1<<(Cobol85ParserKEPT-250))|(1<<(Cobol85ParserKEYBOARD-250))|(1<<(Cobol85ParserLANGUAGE-250))|(1<<(Cobol85ParserLB-250))|(1<<(Cobol85ParserLD-250))|(1<<(Cobol85ParserLEFTLINE-250))|(1<<(Cobol85ParserLENGTH_CHECK-250))|(1<<(Cobol85ParserLIBACCESS-250))|(1<<(Cobol85ParserLIBPARAMETER-250))|(1<<(Cobol85ParserLIBRARY-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(Cobol85ParserLIST-283))|(1<<(Cobol85ParserLOCAL-283))|(1<<(Cobol85ParserLONG_DATE-283))|(1<<(Cobol85ParserLONG_TIME-283))|(1<<(Cobol85ParserLOWER-283))|(1<<(Cobol85ParserLOWLIGHT-283))|(1<<(Cobol85ParserMMDDYYYY-283))|(1<<(Cobol85ParserNAMED-283))|(1<<(Cobol85ParserNATIONAL-283))|(1<<(Cobol85ParserNATIONAL_EDITED-283))|(1<<(Cobol85ParserNETWORK-283))|(1<<(Cobol85ParserNO_ECHO-283)))) != 0) || (((_la-317)&-(0x1f+1)) == 0 && ((1<<uint((_la-317)))&((1<<(Cobol85ParserNUMERIC_DATE-317))|(1<<(Cobol85ParserNUMERIC_TIME-317))|(1<<(Cobol85ParserODT-317))|(1<<(Cobol85ParserORDERLY-317))|(1<<(Cobol85ParserOVERLINE-317))|(1<<(Cobol85ParserOWN-317))|(1<<(Cobol85ParserPASSWORD-317)))) != 0) || (((_la-352)&-(0x1f+1)) == 0 && ((1<<uint((_la-352)))&((1<<(Cobol85ParserPORT-352))|(1<<(Cobol85ParserPRINTER-352))|(1<<(Cobol85ParserPRIVATE-352))|(1<<(Cobol85ParserPROCESS-352))|(1<<(Cobol85ParserPROGRAM-352))|(1<<(Cobol85ParserPROMPT-352))|(1<<(Cobol85ParserREADER-352))|(1<<(Cobol85ParserREMOTE-352))|(1<<(Cobol85ParserREAL-352))|(1<<(Cobol85ParserRECEIVED-352))|(1<<(Cobol85ParserRECURSIVE-352))|(1<<(Cobol85ParserREF-352)))) != 0) || (((_la-391)&-(0x1f+1)) == 0 && ((1<<uint((_la-391)))&((1<<(Cobol85ParserREMOVE-391))|(1<<(Cobol85ParserREQUIRED-391))|(1<<(Cobol85ParserREVERSE_VIDEO-391))|(1<<(Cobol85ParserSAVE-391))|(1<<(Cobol85ParserSECURE-391)))) != 0) || (((_la-431)&-(0x1f+1)) == 0 && ((1<<uint((_la-431)))&((1<<(Cobol85ParserSHARED-431))|(1<<(Cobol85ParserSHAREDBYALL-431))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-431))|(1<<(Cobol85ParserSHARING-431))|(1<<(Cobol85ParserSHORT_DATE-431)))) != 0) || (((_la-466)&-(0x1f+1)) == 0 && ((1<<uint((_la-466)))&((1<<(Cobol85ParserSYMBOL-466))|(1<<(Cobol85ParserTASK-466))|(1<<(Cobol85ParserTHREAD-466))|(1<<(Cobol85ParserTHREAD_LOCAL-466))|(1<<(Cobol85ParserTIMER-466))|(1<<(Cobol85ParserTODAYS_DATE-466))|(1<<(Cobol85ParserTODAYS_NAME-466))|(1<<(Cobol85ParserTRUNCATED-466))|(1<<(Cobol85ParserTYPEDEF-466)))) != 0) || (((_la-498)&-(0x1f+1)) == 0 && ((1<<uint((_la-498)))&((1<<(Cobol85ParserUNDERLINE-498))|(1<<(Cobol85ParserVIRTUAL-498))|(1<<(Cobol85ParserWAIT-498))|(1<<(Cobol85ParserYEAR-498))|(1<<(Cobol85ParserYYYYMMDD-498))|(1<<(Cobol85ParserYYYYDDD-498))|(1<<(Cobol85ParserZERO_FILL-498)))) != 0) || _la == Cobol85ParserIDENTIFIER {
			{
				p.SetState(2376)
				p.IndexName()
			}

			p.SetState(2379)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// IEndKeyClauseContext is an interface to support dynamic dispatch.
type IEndKeyClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEndKeyClauseContext differentiates from other interfaces.
	IsEndKeyClauseContext()
}

type EndKeyClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEndKeyClauseContext() *EndKeyClauseContext {
	var p = new(EndKeyClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_endKeyClause
	return p
}

func (*EndKeyClauseContext) IsEndKeyClauseContext() {}

func NewEndKeyClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EndKeyClauseContext {
	var p = new(EndKeyClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_endKeyClause

	return p
}

func (s *EndKeyClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *EndKeyClauseContext) END() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND, 0)
}

func (s *EndKeyClauseContext) KEY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserKEY, 0)
}

func (s *EndKeyClauseContext) DataDescName() IDataDescNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataDescNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataDescNameContext)
}

func (s *EndKeyClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *EndKeyClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EndKeyClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EndKeyClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterEndKeyClause(s)
	}
}

func (s *EndKeyClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitEndKeyClause(s)
	}
}

func (p *Cobol85Parser) EndKeyClause() (localctx IEndKeyClauseContext) {
	localctx = NewEndKeyClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, Cobol85ParserRULE_endKeyClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2383)
		p.Match(Cobol85ParserEND)
	}
	{
		p.SetState(2384)
		p.Match(Cobol85ParserKEY)
	}
	p.SetState(2386)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2385)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(2388)
		p.DataDescName()
	}

	return localctx
}

// IErrorKeyClauseContext is an interface to support dynamic dispatch.
type IErrorKeyClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsErrorKeyClauseContext differentiates from other interfaces.
	IsErrorKeyClauseContext()
}

type ErrorKeyClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyErrorKeyClauseContext() *ErrorKeyClauseContext {
	var p = new(ErrorKeyClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_errorKeyClause
	return p
}

func (*ErrorKeyClauseContext) IsErrorKeyClauseContext() {}

func NewErrorKeyClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ErrorKeyClauseContext {
	var p = new(ErrorKeyClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_errorKeyClause

	return p
}

func (s *ErrorKeyClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ErrorKeyClauseContext) ERROR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserERROR, 0)
}

func (s *ErrorKeyClauseContext) KEY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserKEY, 0)
}

func (s *ErrorKeyClauseContext) DataDescName() IDataDescNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataDescNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataDescNameContext)
}

func (s *ErrorKeyClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ErrorKeyClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ErrorKeyClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ErrorKeyClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterErrorKeyClause(s)
	}
}

func (s *ErrorKeyClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitErrorKeyClause(s)
	}
}

func (p *Cobol85Parser) ErrorKeyClause() (localctx IErrorKeyClauseContext) {
	localctx = NewErrorKeyClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, Cobol85ParserRULE_errorKeyClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2390)
		p.Match(Cobol85ParserERROR)
	}
	{
		p.SetState(2391)
		p.Match(Cobol85ParserKEY)
	}
	p.SetState(2393)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2392)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(2395)
		p.DataDescName()
	}

	return localctx
}

// IMessageCountClauseContext is an interface to support dynamic dispatch.
type IMessageCountClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMessageCountClauseContext differentiates from other interfaces.
	IsMessageCountClauseContext()
}

type MessageCountClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMessageCountClauseContext() *MessageCountClauseContext {
	var p = new(MessageCountClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_messageCountClause
	return p
}

func (*MessageCountClauseContext) IsMessageCountClauseContext() {}

func NewMessageCountClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MessageCountClauseContext {
	var p = new(MessageCountClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_messageCountClause

	return p
}

func (s *MessageCountClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *MessageCountClauseContext) COUNT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOUNT, 0)
}

func (s *MessageCountClauseContext) DataDescName() IDataDescNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataDescNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataDescNameContext)
}

func (s *MessageCountClauseContext) MESSAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMESSAGE, 0)
}

func (s *MessageCountClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *MessageCountClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MessageCountClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MessageCountClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMessageCountClause(s)
	}
}

func (s *MessageCountClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMessageCountClause(s)
	}
}

func (p *Cobol85Parser) MessageCountClause() (localctx IMessageCountClauseContext) {
	localctx = NewMessageCountClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, Cobol85ParserRULE_messageCountClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2398)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserMESSAGE {
		{
			p.SetState(2397)
			p.Match(Cobol85ParserMESSAGE)
		}

	}
	{
		p.SetState(2400)
		p.Match(Cobol85ParserCOUNT)
	}
	p.SetState(2402)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2401)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(2404)
		p.DataDescName()
	}

	return localctx
}

// IMessageDateClauseContext is an interface to support dynamic dispatch.
type IMessageDateClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMessageDateClauseContext differentiates from other interfaces.
	IsMessageDateClauseContext()
}

type MessageDateClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMessageDateClauseContext() *MessageDateClauseContext {
	var p = new(MessageDateClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_messageDateClause
	return p
}

func (*MessageDateClauseContext) IsMessageDateClauseContext() {}

func NewMessageDateClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MessageDateClauseContext {
	var p = new(MessageDateClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_messageDateClause

	return p
}

func (s *MessageDateClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *MessageDateClauseContext) MESSAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMESSAGE, 0)
}

func (s *MessageDateClauseContext) DATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDATE, 0)
}

func (s *MessageDateClauseContext) DataDescName() IDataDescNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataDescNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataDescNameContext)
}

func (s *MessageDateClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *MessageDateClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MessageDateClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MessageDateClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMessageDateClause(s)
	}
}

func (s *MessageDateClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMessageDateClause(s)
	}
}

func (p *Cobol85Parser) MessageDateClause() (localctx IMessageDateClauseContext) {
	localctx = NewMessageDateClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, Cobol85ParserRULE_messageDateClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2406)
		p.Match(Cobol85ParserMESSAGE)
	}
	{
		p.SetState(2407)
		p.Match(Cobol85ParserDATE)
	}
	p.SetState(2409)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2408)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(2411)
		p.DataDescName()
	}

	return localctx
}

// IMessageTimeClauseContext is an interface to support dynamic dispatch.
type IMessageTimeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMessageTimeClauseContext differentiates from other interfaces.
	IsMessageTimeClauseContext()
}

type MessageTimeClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMessageTimeClauseContext() *MessageTimeClauseContext {
	var p = new(MessageTimeClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_messageTimeClause
	return p
}

func (*MessageTimeClauseContext) IsMessageTimeClauseContext() {}

func NewMessageTimeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MessageTimeClauseContext {
	var p = new(MessageTimeClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_messageTimeClause

	return p
}

func (s *MessageTimeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *MessageTimeClauseContext) MESSAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMESSAGE, 0)
}

func (s *MessageTimeClauseContext) TIME() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTIME, 0)
}

func (s *MessageTimeClauseContext) DataDescName() IDataDescNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataDescNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataDescNameContext)
}

func (s *MessageTimeClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *MessageTimeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MessageTimeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MessageTimeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMessageTimeClause(s)
	}
}

func (s *MessageTimeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMessageTimeClause(s)
	}
}

func (p *Cobol85Parser) MessageTimeClause() (localctx IMessageTimeClauseContext) {
	localctx = NewMessageTimeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, Cobol85ParserRULE_messageTimeClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2413)
		p.Match(Cobol85ParserMESSAGE)
	}
	{
		p.SetState(2414)
		p.Match(Cobol85ParserTIME)
	}
	p.SetState(2416)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2415)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(2418)
		p.DataDescName()
	}

	return localctx
}

// IStatusKeyClauseContext is an interface to support dynamic dispatch.
type IStatusKeyClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatusKeyClauseContext differentiates from other interfaces.
	IsStatusKeyClauseContext()
}

type StatusKeyClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatusKeyClauseContext() *StatusKeyClauseContext {
	var p = new(StatusKeyClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_statusKeyClause
	return p
}

func (*StatusKeyClauseContext) IsStatusKeyClauseContext() {}

func NewStatusKeyClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatusKeyClauseContext {
	var p = new(StatusKeyClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_statusKeyClause

	return p
}

func (s *StatusKeyClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *StatusKeyClauseContext) STATUS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSTATUS, 0)
}

func (s *StatusKeyClauseContext) KEY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserKEY, 0)
}

func (s *StatusKeyClauseContext) DataDescName() IDataDescNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataDescNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataDescNameContext)
}

func (s *StatusKeyClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *StatusKeyClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatusKeyClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatusKeyClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterStatusKeyClause(s)
	}
}

func (s *StatusKeyClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitStatusKeyClause(s)
	}
}

func (p *Cobol85Parser) StatusKeyClause() (localctx IStatusKeyClauseContext) {
	localctx = NewStatusKeyClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, Cobol85ParserRULE_statusKeyClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2420)
		p.Match(Cobol85ParserSTATUS)
	}
	{
		p.SetState(2421)
		p.Match(Cobol85ParserKEY)
	}
	p.SetState(2423)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2422)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(2425)
		p.DataDescName()
	}

	return localctx
}

// ISymbolicDestinationClauseContext is an interface to support dynamic dispatch.
type ISymbolicDestinationClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSymbolicDestinationClauseContext differentiates from other interfaces.
	IsSymbolicDestinationClauseContext()
}

type SymbolicDestinationClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySymbolicDestinationClauseContext() *SymbolicDestinationClauseContext {
	var p = new(SymbolicDestinationClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_symbolicDestinationClause
	return p
}

func (*SymbolicDestinationClauseContext) IsSymbolicDestinationClauseContext() {}

func NewSymbolicDestinationClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SymbolicDestinationClauseContext {
	var p = new(SymbolicDestinationClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_symbolicDestinationClause

	return p
}

func (s *SymbolicDestinationClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SymbolicDestinationClauseContext) DESTINATION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDESTINATION, 0)
}

func (s *SymbolicDestinationClauseContext) DataDescName() IDataDescNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataDescNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataDescNameContext)
}

func (s *SymbolicDestinationClauseContext) SYMBOLIC() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSYMBOLIC, 0)
}

func (s *SymbolicDestinationClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *SymbolicDestinationClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SymbolicDestinationClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SymbolicDestinationClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSymbolicDestinationClause(s)
	}
}

func (s *SymbolicDestinationClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSymbolicDestinationClause(s)
	}
}

func (p *Cobol85Parser) SymbolicDestinationClause() (localctx ISymbolicDestinationClauseContext) {
	localctx = NewSymbolicDestinationClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, Cobol85ParserRULE_symbolicDestinationClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2428)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserSYMBOLIC {
		{
			p.SetState(2427)
			p.Match(Cobol85ParserSYMBOLIC)
		}

	}
	{
		p.SetState(2430)
		p.Match(Cobol85ParserDESTINATION)
	}
	p.SetState(2432)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2431)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(2434)
		p.DataDescName()
	}

	return localctx
}

// ISymbolicQueueClauseContext is an interface to support dynamic dispatch.
type ISymbolicQueueClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSymbolicQueueClauseContext differentiates from other interfaces.
	IsSymbolicQueueClauseContext()
}

type SymbolicQueueClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySymbolicQueueClauseContext() *SymbolicQueueClauseContext {
	var p = new(SymbolicQueueClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_symbolicQueueClause
	return p
}

func (*SymbolicQueueClauseContext) IsSymbolicQueueClauseContext() {}

func NewSymbolicQueueClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SymbolicQueueClauseContext {
	var p = new(SymbolicQueueClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_symbolicQueueClause

	return p
}

func (s *SymbolicQueueClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SymbolicQueueClauseContext) QUEUE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserQUEUE, 0)
}

func (s *SymbolicQueueClauseContext) DataDescName() IDataDescNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataDescNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataDescNameContext)
}

func (s *SymbolicQueueClauseContext) SYMBOLIC() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSYMBOLIC, 0)
}

func (s *SymbolicQueueClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *SymbolicQueueClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SymbolicQueueClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SymbolicQueueClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSymbolicQueueClause(s)
	}
}

func (s *SymbolicQueueClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSymbolicQueueClause(s)
	}
}

func (p *Cobol85Parser) SymbolicQueueClause() (localctx ISymbolicQueueClauseContext) {
	localctx = NewSymbolicQueueClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, Cobol85ParserRULE_symbolicQueueClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2437)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserSYMBOLIC {
		{
			p.SetState(2436)
			p.Match(Cobol85ParserSYMBOLIC)
		}

	}
	{
		p.SetState(2439)
		p.Match(Cobol85ParserQUEUE)
	}
	p.SetState(2441)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2440)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(2443)
		p.DataDescName()
	}

	return localctx
}

// ISymbolicSourceClauseContext is an interface to support dynamic dispatch.
type ISymbolicSourceClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSymbolicSourceClauseContext differentiates from other interfaces.
	IsSymbolicSourceClauseContext()
}

type SymbolicSourceClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySymbolicSourceClauseContext() *SymbolicSourceClauseContext {
	var p = new(SymbolicSourceClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_symbolicSourceClause
	return p
}

func (*SymbolicSourceClauseContext) IsSymbolicSourceClauseContext() {}

func NewSymbolicSourceClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SymbolicSourceClauseContext {
	var p = new(SymbolicSourceClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_symbolicSourceClause

	return p
}

func (s *SymbolicSourceClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SymbolicSourceClauseContext) SOURCE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSOURCE, 0)
}

func (s *SymbolicSourceClauseContext) DataDescName() IDataDescNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataDescNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataDescNameContext)
}

func (s *SymbolicSourceClauseContext) SYMBOLIC() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSYMBOLIC, 0)
}

func (s *SymbolicSourceClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *SymbolicSourceClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SymbolicSourceClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SymbolicSourceClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSymbolicSourceClause(s)
	}
}

func (s *SymbolicSourceClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSymbolicSourceClause(s)
	}
}

func (p *Cobol85Parser) SymbolicSourceClause() (localctx ISymbolicSourceClauseContext) {
	localctx = NewSymbolicSourceClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, Cobol85ParserRULE_symbolicSourceClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2446)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserSYMBOLIC {
		{
			p.SetState(2445)
			p.Match(Cobol85ParserSYMBOLIC)
		}

	}
	{
		p.SetState(2448)
		p.Match(Cobol85ParserSOURCE)
	}
	p.SetState(2450)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2449)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(2452)
		p.DataDescName()
	}

	return localctx
}

// ISymbolicTerminalClauseContext is an interface to support dynamic dispatch.
type ISymbolicTerminalClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSymbolicTerminalClauseContext differentiates from other interfaces.
	IsSymbolicTerminalClauseContext()
}

type SymbolicTerminalClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySymbolicTerminalClauseContext() *SymbolicTerminalClauseContext {
	var p = new(SymbolicTerminalClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_symbolicTerminalClause
	return p
}

func (*SymbolicTerminalClauseContext) IsSymbolicTerminalClauseContext() {}

func NewSymbolicTerminalClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SymbolicTerminalClauseContext {
	var p = new(SymbolicTerminalClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_symbolicTerminalClause

	return p
}

func (s *SymbolicTerminalClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SymbolicTerminalClauseContext) TERMINAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTERMINAL, 0)
}

func (s *SymbolicTerminalClauseContext) DataDescName() IDataDescNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataDescNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataDescNameContext)
}

func (s *SymbolicTerminalClauseContext) SYMBOLIC() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSYMBOLIC, 0)
}

func (s *SymbolicTerminalClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *SymbolicTerminalClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SymbolicTerminalClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SymbolicTerminalClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSymbolicTerminalClause(s)
	}
}

func (s *SymbolicTerminalClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSymbolicTerminalClause(s)
	}
}

func (p *Cobol85Parser) SymbolicTerminalClause() (localctx ISymbolicTerminalClauseContext) {
	localctx = NewSymbolicTerminalClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, Cobol85ParserRULE_symbolicTerminalClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2455)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserSYMBOLIC {
		{
			p.SetState(2454)
			p.Match(Cobol85ParserSYMBOLIC)
		}

	}
	{
		p.SetState(2457)
		p.Match(Cobol85ParserTERMINAL)
	}
	p.SetState(2459)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2458)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(2461)
		p.DataDescName()
	}

	return localctx
}

// ISymbolicSubQueueClauseContext is an interface to support dynamic dispatch.
type ISymbolicSubQueueClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSymbolicSubQueueClauseContext differentiates from other interfaces.
	IsSymbolicSubQueueClauseContext()
}

type SymbolicSubQueueClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySymbolicSubQueueClauseContext() *SymbolicSubQueueClauseContext {
	var p = new(SymbolicSubQueueClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_symbolicSubQueueClause
	return p
}

func (*SymbolicSubQueueClauseContext) IsSymbolicSubQueueClauseContext() {}

func NewSymbolicSubQueueClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SymbolicSubQueueClauseContext {
	var p = new(SymbolicSubQueueClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_symbolicSubQueueClause

	return p
}

func (s *SymbolicSubQueueClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SymbolicSubQueueClauseContext) DataDescName() IDataDescNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataDescNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataDescNameContext)
}

func (s *SymbolicSubQueueClauseContext) SUB_QUEUE_1() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSUB_QUEUE_1, 0)
}

func (s *SymbolicSubQueueClauseContext) SUB_QUEUE_2() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSUB_QUEUE_2, 0)
}

func (s *SymbolicSubQueueClauseContext) SUB_QUEUE_3() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSUB_QUEUE_3, 0)
}

func (s *SymbolicSubQueueClauseContext) SYMBOLIC() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSYMBOLIC, 0)
}

func (s *SymbolicSubQueueClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *SymbolicSubQueueClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SymbolicSubQueueClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SymbolicSubQueueClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSymbolicSubQueueClause(s)
	}
}

func (s *SymbolicSubQueueClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSymbolicSubQueueClause(s)
	}
}

func (p *Cobol85Parser) SymbolicSubQueueClause() (localctx ISymbolicSubQueueClauseContext) {
	localctx = NewSymbolicSubQueueClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, Cobol85ParserRULE_symbolicSubQueueClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2464)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserSYMBOLIC {
		{
			p.SetState(2463)
			p.Match(Cobol85ParserSYMBOLIC)
		}

	}
	{
		p.SetState(2466)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-460)&-(0x1f+1)) == 0 && ((1<<uint((_la-460)))&((1<<(Cobol85ParserSUB_QUEUE_1-460))|(1<<(Cobol85ParserSUB_QUEUE_2-460))|(1<<(Cobol85ParserSUB_QUEUE_3-460)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(2468)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2467)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(2470)
		p.DataDescName()
	}

	return localctx
}

// ITextLengthClauseContext is an interface to support dynamic dispatch.
type ITextLengthClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTextLengthClauseContext differentiates from other interfaces.
	IsTextLengthClauseContext()
}

type TextLengthClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTextLengthClauseContext() *TextLengthClauseContext {
	var p = new(TextLengthClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_textLengthClause
	return p
}

func (*TextLengthClauseContext) IsTextLengthClauseContext() {}

func NewTextLengthClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TextLengthClauseContext {
	var p = new(TextLengthClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_textLengthClause

	return p
}

func (s *TextLengthClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *TextLengthClauseContext) TEXT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTEXT, 0)
}

func (s *TextLengthClauseContext) LENGTH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLENGTH, 0)
}

func (s *TextLengthClauseContext) DataDescName() IDataDescNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataDescNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataDescNameContext)
}

func (s *TextLengthClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *TextLengthClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TextLengthClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TextLengthClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterTextLengthClause(s)
	}
}

func (s *TextLengthClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitTextLengthClause(s)
	}
}

func (p *Cobol85Parser) TextLengthClause() (localctx ITextLengthClauseContext) {
	localctx = NewTextLengthClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, Cobol85ParserRULE_textLengthClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2472)
		p.Match(Cobol85ParserTEXT)
	}
	{
		p.SetState(2473)
		p.Match(Cobol85ParserLENGTH)
	}
	p.SetState(2475)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2474)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(2477)
		p.DataDescName()
	}

	return localctx
}

// ILocalStorageSectionContext is an interface to support dynamic dispatch.
type ILocalStorageSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLocalStorageSectionContext differentiates from other interfaces.
	IsLocalStorageSectionContext()
}

type LocalStorageSectionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLocalStorageSectionContext() *LocalStorageSectionContext {
	var p = new(LocalStorageSectionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_localStorageSection
	return p
}

func (*LocalStorageSectionContext) IsLocalStorageSectionContext() {}

func NewLocalStorageSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LocalStorageSectionContext {
	var p = new(LocalStorageSectionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_localStorageSection

	return p
}

func (s *LocalStorageSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *LocalStorageSectionContext) LOCAL_STORAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLOCAL_STORAGE, 0)
}

func (s *LocalStorageSectionContext) SECTION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSECTION, 0)
}

func (s *LocalStorageSectionContext) AllDOT_FS() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserDOT_FS)
}

func (s *LocalStorageSectionContext) DOT_FS(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, i)
}

func (s *LocalStorageSectionContext) LD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLD, 0)
}

func (s *LocalStorageSectionContext) LocalName() ILocalNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILocalNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILocalNameContext)
}

func (s *LocalStorageSectionContext) AllDataDescriptionEntry() []IDataDescriptionEntryContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDataDescriptionEntryContext)(nil)).Elem())
	var tst = make([]IDataDescriptionEntryContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDataDescriptionEntryContext)
		}
	}

	return tst
}

func (s *LocalStorageSectionContext) DataDescriptionEntry(i int) IDataDescriptionEntryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataDescriptionEntryContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDataDescriptionEntryContext)
}

func (s *LocalStorageSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LocalStorageSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LocalStorageSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLocalStorageSection(s)
	}
}

func (s *LocalStorageSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLocalStorageSection(s)
	}
}

func (p *Cobol85Parser) LocalStorageSection() (localctx ILocalStorageSectionContext) {
	localctx = NewLocalStorageSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, Cobol85ParserRULE_localStorageSection)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2479)
		p.Match(Cobol85ParserLOCAL_STORAGE)
	}
	{
		p.SetState(2480)
		p.Match(Cobol85ParserSECTION)
	}
	{
		p.SetState(2481)
		p.Match(Cobol85ParserDOT_FS)
	}
	p.SetState(2486)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserLD {
		{
			p.SetState(2482)
			p.Match(Cobol85ParserLD)
		}
		{
			p.SetState(2483)
			p.LocalName()
		}
		{
			p.SetState(2484)
			p.Match(Cobol85ParserDOT_FS)
		}

	}
	p.SetState(2491)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ((_la-552)&-(0x1f+1)) == 0 && ((1<<uint((_la-552)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-552))|(1<<(Cobol85ParserLEVEL_NUMBER_77-552))|(1<<(Cobol85ParserLEVEL_NUMBER_88-552))|(1<<(Cobol85ParserINTEGERLITERAL-552))|(1<<(Cobol85ParserEXECSQLLINE-552)))) != 0 {
		{
			p.SetState(2488)
			p.DataDescriptionEntry()
		}

		p.SetState(2493)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IScreenSectionContext is an interface to support dynamic dispatch.
type IScreenSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenSectionContext differentiates from other interfaces.
	IsScreenSectionContext()
}

type ScreenSectionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenSectionContext() *ScreenSectionContext {
	var p = new(ScreenSectionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenSection
	return p
}

func (*ScreenSectionContext) IsScreenSectionContext() {}

func NewScreenSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenSectionContext {
	var p = new(ScreenSectionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenSection

	return p
}

func (s *ScreenSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenSectionContext) SCREEN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSCREEN, 0)
}

func (s *ScreenSectionContext) SECTION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSECTION, 0)
}

func (s *ScreenSectionContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *ScreenSectionContext) AllScreenDescriptionEntry() []IScreenDescriptionEntryContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IScreenDescriptionEntryContext)(nil)).Elem())
	var tst = make([]IScreenDescriptionEntryContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IScreenDescriptionEntryContext)
		}
	}

	return tst
}

func (s *ScreenSectionContext) ScreenDescriptionEntry(i int) IScreenDescriptionEntryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScreenDescriptionEntryContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionEntryContext)
}

func (s *ScreenSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenSection(s)
	}
}

func (s *ScreenSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenSection(s)
	}
}

func (p *Cobol85Parser) ScreenSection() (localctx IScreenSectionContext) {
	localctx = NewScreenSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, Cobol85ParserRULE_screenSection)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2494)
		p.Match(Cobol85ParserSCREEN)
	}
	{
		p.SetState(2495)
		p.Match(Cobol85ParserSECTION)
	}
	{
		p.SetState(2496)
		p.Match(Cobol85ParserDOT_FS)
	}
	p.SetState(2500)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserINTEGERLITERAL {
		{
			p.SetState(2497)
			p.ScreenDescriptionEntry()
		}

		p.SetState(2502)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IScreenDescriptionEntryContext is an interface to support dynamic dispatch.
type IScreenDescriptionEntryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionEntryContext differentiates from other interfaces.
	IsScreenDescriptionEntryContext()
}

type ScreenDescriptionEntryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionEntryContext() *ScreenDescriptionEntryContext {
	var p = new(ScreenDescriptionEntryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionEntry
	return p
}

func (*ScreenDescriptionEntryContext) IsScreenDescriptionEntryContext() {}

func NewScreenDescriptionEntryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionEntryContext {
	var p = new(ScreenDescriptionEntryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionEntry

	return p
}

func (s *ScreenDescriptionEntryContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionEntryContext) INTEGERLITERAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINTEGERLITERAL, 0)
}

func (s *ScreenDescriptionEntryContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *ScreenDescriptionEntryContext) FILLER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFILLER, 0)
}

func (s *ScreenDescriptionEntryContext) ScreenName() IScreenNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScreenNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IScreenNameContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionBlankClause() []IScreenDescriptionBlankClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IScreenDescriptionBlankClauseContext)(nil)).Elem())
	var tst = make([]IScreenDescriptionBlankClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IScreenDescriptionBlankClauseContext)
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionBlankClause(i int) IScreenDescriptionBlankClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScreenDescriptionBlankClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionBlankClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionBellClause() []IScreenDescriptionBellClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IScreenDescriptionBellClauseContext)(nil)).Elem())
	var tst = make([]IScreenDescriptionBellClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IScreenDescriptionBellClauseContext)
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionBellClause(i int) IScreenDescriptionBellClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScreenDescriptionBellClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionBellClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionBlinkClause() []IScreenDescriptionBlinkClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IScreenDescriptionBlinkClauseContext)(nil)).Elem())
	var tst = make([]IScreenDescriptionBlinkClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IScreenDescriptionBlinkClauseContext)
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionBlinkClause(i int) IScreenDescriptionBlinkClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScreenDescriptionBlinkClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionBlinkClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionEraseClause() []IScreenDescriptionEraseClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IScreenDescriptionEraseClauseContext)(nil)).Elem())
	var tst = make([]IScreenDescriptionEraseClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IScreenDescriptionEraseClauseContext)
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionEraseClause(i int) IScreenDescriptionEraseClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScreenDescriptionEraseClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionEraseClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionLightClause() []IScreenDescriptionLightClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IScreenDescriptionLightClauseContext)(nil)).Elem())
	var tst = make([]IScreenDescriptionLightClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IScreenDescriptionLightClauseContext)
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionLightClause(i int) IScreenDescriptionLightClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScreenDescriptionLightClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionLightClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionGridClause() []IScreenDescriptionGridClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IScreenDescriptionGridClauseContext)(nil)).Elem())
	var tst = make([]IScreenDescriptionGridClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IScreenDescriptionGridClauseContext)
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionGridClause(i int) IScreenDescriptionGridClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScreenDescriptionGridClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionGridClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionReverseVideoClause() []IScreenDescriptionReverseVideoClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IScreenDescriptionReverseVideoClauseContext)(nil)).Elem())
	var tst = make([]IScreenDescriptionReverseVideoClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IScreenDescriptionReverseVideoClauseContext)
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionReverseVideoClause(i int) IScreenDescriptionReverseVideoClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScreenDescriptionReverseVideoClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionReverseVideoClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionUnderlineClause() []IScreenDescriptionUnderlineClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IScreenDescriptionUnderlineClauseContext)(nil)).Elem())
	var tst = make([]IScreenDescriptionUnderlineClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IScreenDescriptionUnderlineClauseContext)
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionUnderlineClause(i int) IScreenDescriptionUnderlineClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScreenDescriptionUnderlineClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionUnderlineClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionSizeClause() []IScreenDescriptionSizeClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IScreenDescriptionSizeClauseContext)(nil)).Elem())
	var tst = make([]IScreenDescriptionSizeClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IScreenDescriptionSizeClauseContext)
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionSizeClause(i int) IScreenDescriptionSizeClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScreenDescriptionSizeClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionSizeClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionLineClause() []IScreenDescriptionLineClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IScreenDescriptionLineClauseContext)(nil)).Elem())
	var tst = make([]IScreenDescriptionLineClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IScreenDescriptionLineClauseContext)
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionLineClause(i int) IScreenDescriptionLineClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScreenDescriptionLineClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionLineClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionColumnClause() []IScreenDescriptionColumnClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IScreenDescriptionColumnClauseContext)(nil)).Elem())
	var tst = make([]IScreenDescriptionColumnClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IScreenDescriptionColumnClauseContext)
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionColumnClause(i int) IScreenDescriptionColumnClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScreenDescriptionColumnClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionColumnClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionForegroundColorClause() []IScreenDescriptionForegroundColorClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IScreenDescriptionForegroundColorClauseContext)(nil)).Elem())
	var tst = make([]IScreenDescriptionForegroundColorClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IScreenDescriptionForegroundColorClauseContext)
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionForegroundColorClause(i int) IScreenDescriptionForegroundColorClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScreenDescriptionForegroundColorClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionForegroundColorClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionBackgroundColorClause() []IScreenDescriptionBackgroundColorClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IScreenDescriptionBackgroundColorClauseContext)(nil)).Elem())
	var tst = make([]IScreenDescriptionBackgroundColorClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IScreenDescriptionBackgroundColorClauseContext)
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionBackgroundColorClause(i int) IScreenDescriptionBackgroundColorClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScreenDescriptionBackgroundColorClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionBackgroundColorClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionControlClause() []IScreenDescriptionControlClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IScreenDescriptionControlClauseContext)(nil)).Elem())
	var tst = make([]IScreenDescriptionControlClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IScreenDescriptionControlClauseContext)
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionControlClause(i int) IScreenDescriptionControlClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScreenDescriptionControlClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionControlClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionValueClause() []IScreenDescriptionValueClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IScreenDescriptionValueClauseContext)(nil)).Elem())
	var tst = make([]IScreenDescriptionValueClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IScreenDescriptionValueClauseContext)
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionValueClause(i int) IScreenDescriptionValueClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScreenDescriptionValueClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionValueClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionPictureClause() []IScreenDescriptionPictureClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IScreenDescriptionPictureClauseContext)(nil)).Elem())
	var tst = make([]IScreenDescriptionPictureClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IScreenDescriptionPictureClauseContext)
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionPictureClause(i int) IScreenDescriptionPictureClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScreenDescriptionPictureClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionPictureClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionUsageClause() []IScreenDescriptionUsageClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IScreenDescriptionUsageClauseContext)(nil)).Elem())
	var tst = make([]IScreenDescriptionUsageClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IScreenDescriptionUsageClauseContext)
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionUsageClause(i int) IScreenDescriptionUsageClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScreenDescriptionUsageClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionUsageClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionBlankWhenZeroClause() []IScreenDescriptionBlankWhenZeroClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IScreenDescriptionBlankWhenZeroClauseContext)(nil)).Elem())
	var tst = make([]IScreenDescriptionBlankWhenZeroClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IScreenDescriptionBlankWhenZeroClauseContext)
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionBlankWhenZeroClause(i int) IScreenDescriptionBlankWhenZeroClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScreenDescriptionBlankWhenZeroClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionBlankWhenZeroClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionJustifiedClause() []IScreenDescriptionJustifiedClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IScreenDescriptionJustifiedClauseContext)(nil)).Elem())
	var tst = make([]IScreenDescriptionJustifiedClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IScreenDescriptionJustifiedClauseContext)
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionJustifiedClause(i int) IScreenDescriptionJustifiedClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScreenDescriptionJustifiedClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionJustifiedClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionSignClause() []IScreenDescriptionSignClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IScreenDescriptionSignClauseContext)(nil)).Elem())
	var tst = make([]IScreenDescriptionSignClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IScreenDescriptionSignClauseContext)
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionSignClause(i int) IScreenDescriptionSignClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScreenDescriptionSignClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionSignClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionAutoClause() []IScreenDescriptionAutoClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IScreenDescriptionAutoClauseContext)(nil)).Elem())
	var tst = make([]IScreenDescriptionAutoClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IScreenDescriptionAutoClauseContext)
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionAutoClause(i int) IScreenDescriptionAutoClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScreenDescriptionAutoClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionAutoClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionSecureClause() []IScreenDescriptionSecureClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IScreenDescriptionSecureClauseContext)(nil)).Elem())
	var tst = make([]IScreenDescriptionSecureClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IScreenDescriptionSecureClauseContext)
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionSecureClause(i int) IScreenDescriptionSecureClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScreenDescriptionSecureClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionSecureClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionRequiredClause() []IScreenDescriptionRequiredClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IScreenDescriptionRequiredClauseContext)(nil)).Elem())
	var tst = make([]IScreenDescriptionRequiredClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IScreenDescriptionRequiredClauseContext)
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionRequiredClause(i int) IScreenDescriptionRequiredClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScreenDescriptionRequiredClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionRequiredClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionPromptClause() []IScreenDescriptionPromptClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IScreenDescriptionPromptClauseContext)(nil)).Elem())
	var tst = make([]IScreenDescriptionPromptClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IScreenDescriptionPromptClauseContext)
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionPromptClause(i int) IScreenDescriptionPromptClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScreenDescriptionPromptClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionPromptClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionFullClause() []IScreenDescriptionFullClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IScreenDescriptionFullClauseContext)(nil)).Elem())
	var tst = make([]IScreenDescriptionFullClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IScreenDescriptionFullClauseContext)
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionFullClause(i int) IScreenDescriptionFullClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScreenDescriptionFullClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionFullClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionZeroFillClause() []IScreenDescriptionZeroFillClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IScreenDescriptionZeroFillClauseContext)(nil)).Elem())
	var tst = make([]IScreenDescriptionZeroFillClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IScreenDescriptionZeroFillClauseContext)
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionZeroFillClause(i int) IScreenDescriptionZeroFillClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScreenDescriptionZeroFillClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionZeroFillClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionFromClause() []IScreenDescriptionFromClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IScreenDescriptionFromClauseContext)(nil)).Elem())
	var tst = make([]IScreenDescriptionFromClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IScreenDescriptionFromClauseContext)
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionFromClause(i int) IScreenDescriptionFromClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScreenDescriptionFromClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionFromClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionUsingClause() []IScreenDescriptionUsingClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IScreenDescriptionUsingClauseContext)(nil)).Elem())
	var tst = make([]IScreenDescriptionUsingClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IScreenDescriptionUsingClauseContext)
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionUsingClause(i int) IScreenDescriptionUsingClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScreenDescriptionUsingClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionUsingClauseContext)
}

func (s *ScreenDescriptionEntryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionEntryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionEntryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionEntry(s)
	}
}

func (s *ScreenDescriptionEntryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionEntry(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionEntry() (localctx IScreenDescriptionEntryContext) {
	localctx = NewScreenDescriptionEntryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, Cobol85ParserRULE_screenDescriptionEntry)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2503)
		p.Match(Cobol85ParserINTEGERLITERAL)
	}
	p.SetState(2506)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 266, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2504)
			p.Match(Cobol85ParserFILLER)
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 266, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(2505)
			p.ScreenName()
		}

	}
	p.SetState(2540)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBLANK-33))|(1<<(Cobol85ParserBLINK-33)))) != 0) || (((_la-73)&-(0x1f+1)) == 0 && ((1<<uint((_la-73)))&((1<<(Cobol85ParserCOL-73))|(1<<(Cobol85ParserCOLUMN-73))|(1<<(Cobol85ParserCONTROL-73)))) != 0) || _la == Cobol85ParserEMPTY_CHECK || _la == Cobol85ParserERASE || (((_la-213)&-(0x1f+1)) == 0 && ((1<<uint((_la-213)))&((1<<(Cobol85ParserFOREGROUND_COLOR-213))|(1<<(Cobol85ParserFOREGROUND_COLOUR-213))|(1<<(Cobol85ParserFROM-213))|(1<<(Cobol85ParserFULL-213))|(1<<(Cobol85ParserGRID-213))|(1<<(Cobol85ParserHIGHLIGHT-213)))) != 0) || (((_la-255)&-(0x1f+1)) == 0 && ((1<<uint((_la-255)))&((1<<(Cobol85ParserJUST-255))|(1<<(Cobol85ParserJUSTIFIED-255))|(1<<(Cobol85ParserLEADING-255))|(1<<(Cobol85ParserLEFTLINE-255))|(1<<(Cobol85ParserLENGTH_CHECK-255))|(1<<(Cobol85ParserLINE-255)))) != 0) || _la == Cobol85ParserLOWLIGHT || _la == Cobol85ParserNO_ECHO || (((_la-336)&-(0x1f+1)) == 0 && ((1<<uint((_la-336)))&((1<<(Cobol85ParserOVERLINE-336))|(1<<(Cobol85ParserPIC-336))|(1<<(Cobol85ParserPICTURE-336))|(1<<(Cobol85ParserPROMPT-336)))) != 0) || (((_la-398)&-(0x1f+1)) == 0 && ((1<<uint((_la-398)))&((1<<(Cobol85ParserREQUIRED-398))|(1<<(Cobol85ParserREVERSE_VIDEO-398))|(1<<(Cobol85ParserSECURE-398)))) != 0) || _la == Cobol85ParserSIGN || _la == Cobol85ParserSIZE || (((_la-493)&-(0x1f+1)) == 0 && ((1<<uint((_la-493)))&((1<<(Cobol85ParserTRAILING-493))|(1<<(Cobol85ParserUNDERLINE-493))|(1<<(Cobol85ParserUSAGE-493))|(1<<(Cobol85ParserUSING-493))|(1<<(Cobol85ParserVALUE-493))|(1<<(Cobol85ParserZERO_FILL-493)))) != 0) {
		p.SetState(2538)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 268, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(2508)
				p.ScreenDescriptionBlankClause()
			}

		case 2:
			{
				p.SetState(2509)
				p.ScreenDescriptionBellClause()
			}

		case 3:
			{
				p.SetState(2510)
				p.ScreenDescriptionBlinkClause()
			}

		case 4:
			{
				p.SetState(2511)
				p.ScreenDescriptionEraseClause()
			}

		case 5:
			{
				p.SetState(2512)
				p.ScreenDescriptionLightClause()
			}

		case 6:
			{
				p.SetState(2513)
				p.ScreenDescriptionGridClause()
			}

		case 7:
			{
				p.SetState(2514)
				p.ScreenDescriptionReverseVideoClause()
			}

		case 8:
			{
				p.SetState(2515)
				p.ScreenDescriptionUnderlineClause()
			}

		case 9:
			{
				p.SetState(2516)
				p.ScreenDescriptionSizeClause()
			}

		case 10:
			{
				p.SetState(2517)
				p.ScreenDescriptionLineClause()
			}

		case 11:
			{
				p.SetState(2518)
				p.ScreenDescriptionColumnClause()
			}

		case 12:
			{
				p.SetState(2519)
				p.ScreenDescriptionForegroundColorClause()
			}

		case 13:
			{
				p.SetState(2520)
				p.ScreenDescriptionBackgroundColorClause()
			}

		case 14:
			{
				p.SetState(2521)
				p.ScreenDescriptionControlClause()
			}

		case 15:
			{
				p.SetState(2522)
				p.ScreenDescriptionValueClause()
			}

		case 16:
			{
				p.SetState(2523)
				p.ScreenDescriptionPictureClause()
			}

		case 17:
			p.SetState(2526)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case Cobol85ParserFROM:
				{
					p.SetState(2524)
					p.ScreenDescriptionFromClause()
				}

			case Cobol85ParserUSING:
				{
					p.SetState(2525)
					p.ScreenDescriptionUsingClause()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		case 18:
			{
				p.SetState(2528)
				p.ScreenDescriptionUsageClause()
			}

		case 19:
			{
				p.SetState(2529)
				p.ScreenDescriptionBlankWhenZeroClause()
			}

		case 20:
			{
				p.SetState(2530)
				p.ScreenDescriptionJustifiedClause()
			}

		case 21:
			{
				p.SetState(2531)
				p.ScreenDescriptionSignClause()
			}

		case 22:
			{
				p.SetState(2532)
				p.ScreenDescriptionAutoClause()
			}

		case 23:
			{
				p.SetState(2533)
				p.ScreenDescriptionSecureClause()
			}

		case 24:
			{
				p.SetState(2534)
				p.ScreenDescriptionRequiredClause()
			}

		case 25:
			{
				p.SetState(2535)
				p.ScreenDescriptionPromptClause()
			}

		case 26:
			{
				p.SetState(2536)
				p.ScreenDescriptionFullClause()
			}

		case 27:
			{
				p.SetState(2537)
				p.ScreenDescriptionZeroFillClause()
			}

		}

		p.SetState(2542)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2543)
		p.Match(Cobol85ParserDOT_FS)
	}

	return localctx
}

// IScreenDescriptionBlankClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionBlankClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionBlankClauseContext differentiates from other interfaces.
	IsScreenDescriptionBlankClauseContext()
}

type ScreenDescriptionBlankClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionBlankClauseContext() *ScreenDescriptionBlankClauseContext {
	var p = new(ScreenDescriptionBlankClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionBlankClause
	return p
}

func (*ScreenDescriptionBlankClauseContext) IsScreenDescriptionBlankClauseContext() {}

func NewScreenDescriptionBlankClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionBlankClauseContext {
	var p = new(ScreenDescriptionBlankClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionBlankClause

	return p
}

func (s *ScreenDescriptionBlankClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionBlankClauseContext) BLANK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBLANK, 0)
}

func (s *ScreenDescriptionBlankClauseContext) SCREEN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSCREEN, 0)
}

func (s *ScreenDescriptionBlankClauseContext) LINE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLINE, 0)
}

func (s *ScreenDescriptionBlankClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionBlankClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionBlankClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionBlankClause(s)
	}
}

func (s *ScreenDescriptionBlankClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionBlankClause(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionBlankClause() (localctx IScreenDescriptionBlankClauseContext) {
	localctx = NewScreenDescriptionBlankClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, Cobol85ParserRULE_screenDescriptionBlankClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2545)
		p.Match(Cobol85ParserBLANK)
	}
	{
		p.SetState(2546)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserLINE || _la == Cobol85ParserSCREEN) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IScreenDescriptionBellClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionBellClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionBellClauseContext differentiates from other interfaces.
	IsScreenDescriptionBellClauseContext()
}

type ScreenDescriptionBellClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionBellClauseContext() *ScreenDescriptionBellClauseContext {
	var p = new(ScreenDescriptionBellClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionBellClause
	return p
}

func (*ScreenDescriptionBellClauseContext) IsScreenDescriptionBellClauseContext() {}

func NewScreenDescriptionBellClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionBellClauseContext {
	var p = new(ScreenDescriptionBellClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionBellClause

	return p
}

func (s *ScreenDescriptionBellClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionBellClauseContext) BELL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBELL, 0)
}

func (s *ScreenDescriptionBellClauseContext) BEEP() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBEEP, 0)
}

func (s *ScreenDescriptionBellClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionBellClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionBellClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionBellClause(s)
	}
}

func (s *ScreenDescriptionBellClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionBellClause(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionBellClause() (localctx IScreenDescriptionBellClauseContext) {
	localctx = NewScreenDescriptionBellClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, Cobol85ParserRULE_screenDescriptionBellClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2548)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserBEEP || _la == Cobol85ParserBELL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IScreenDescriptionBlinkClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionBlinkClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionBlinkClauseContext differentiates from other interfaces.
	IsScreenDescriptionBlinkClauseContext()
}

type ScreenDescriptionBlinkClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionBlinkClauseContext() *ScreenDescriptionBlinkClauseContext {
	var p = new(ScreenDescriptionBlinkClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionBlinkClause
	return p
}

func (*ScreenDescriptionBlinkClauseContext) IsScreenDescriptionBlinkClauseContext() {}

func NewScreenDescriptionBlinkClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionBlinkClauseContext {
	var p = new(ScreenDescriptionBlinkClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionBlinkClause

	return p
}

func (s *ScreenDescriptionBlinkClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionBlinkClauseContext) BLINK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBLINK, 0)
}

func (s *ScreenDescriptionBlinkClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionBlinkClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionBlinkClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionBlinkClause(s)
	}
}

func (s *ScreenDescriptionBlinkClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionBlinkClause(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionBlinkClause() (localctx IScreenDescriptionBlinkClauseContext) {
	localctx = NewScreenDescriptionBlinkClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, Cobol85ParserRULE_screenDescriptionBlinkClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2550)
		p.Match(Cobol85ParserBLINK)
	}

	return localctx
}

// IScreenDescriptionEraseClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionEraseClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionEraseClauseContext differentiates from other interfaces.
	IsScreenDescriptionEraseClauseContext()
}

type ScreenDescriptionEraseClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionEraseClauseContext() *ScreenDescriptionEraseClauseContext {
	var p = new(ScreenDescriptionEraseClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionEraseClause
	return p
}

func (*ScreenDescriptionEraseClauseContext) IsScreenDescriptionEraseClauseContext() {}

func NewScreenDescriptionEraseClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionEraseClauseContext {
	var p = new(ScreenDescriptionEraseClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionEraseClause

	return p
}

func (s *ScreenDescriptionEraseClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionEraseClauseContext) ERASE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserERASE, 0)
}

func (s *ScreenDescriptionEraseClauseContext) EOL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEOL, 0)
}

func (s *ScreenDescriptionEraseClauseContext) EOS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEOS, 0)
}

func (s *ScreenDescriptionEraseClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionEraseClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionEraseClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionEraseClause(s)
	}
}

func (s *ScreenDescriptionEraseClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionEraseClause(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionEraseClause() (localctx IScreenDescriptionEraseClauseContext) {
	localctx = NewScreenDescriptionEraseClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, Cobol85ParserRULE_screenDescriptionEraseClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2552)
		p.Match(Cobol85ParserERASE)
	}
	{
		p.SetState(2553)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserEOL || _la == Cobol85ParserEOS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IScreenDescriptionLightClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionLightClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionLightClauseContext differentiates from other interfaces.
	IsScreenDescriptionLightClauseContext()
}

type ScreenDescriptionLightClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionLightClauseContext() *ScreenDescriptionLightClauseContext {
	var p = new(ScreenDescriptionLightClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionLightClause
	return p
}

func (*ScreenDescriptionLightClauseContext) IsScreenDescriptionLightClauseContext() {}

func NewScreenDescriptionLightClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionLightClauseContext {
	var p = new(ScreenDescriptionLightClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionLightClause

	return p
}

func (s *ScreenDescriptionLightClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionLightClauseContext) HIGHLIGHT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserHIGHLIGHT, 0)
}

func (s *ScreenDescriptionLightClauseContext) LOWLIGHT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLOWLIGHT, 0)
}

func (s *ScreenDescriptionLightClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionLightClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionLightClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionLightClause(s)
	}
}

func (s *ScreenDescriptionLightClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionLightClause(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionLightClause() (localctx IScreenDescriptionLightClauseContext) {
	localctx = NewScreenDescriptionLightClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, Cobol85ParserRULE_screenDescriptionLightClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2555)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserHIGHLIGHT || _la == Cobol85ParserLOWLIGHT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IScreenDescriptionGridClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionGridClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionGridClauseContext differentiates from other interfaces.
	IsScreenDescriptionGridClauseContext()
}

type ScreenDescriptionGridClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionGridClauseContext() *ScreenDescriptionGridClauseContext {
	var p = new(ScreenDescriptionGridClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionGridClause
	return p
}

func (*ScreenDescriptionGridClauseContext) IsScreenDescriptionGridClauseContext() {}

func NewScreenDescriptionGridClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionGridClauseContext {
	var p = new(ScreenDescriptionGridClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionGridClause

	return p
}

func (s *ScreenDescriptionGridClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionGridClauseContext) GRID() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserGRID, 0)
}

func (s *ScreenDescriptionGridClauseContext) LEFTLINE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLEFTLINE, 0)
}

func (s *ScreenDescriptionGridClauseContext) OVERLINE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOVERLINE, 0)
}

func (s *ScreenDescriptionGridClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionGridClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionGridClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionGridClause(s)
	}
}

func (s *ScreenDescriptionGridClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionGridClause(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionGridClause() (localctx IScreenDescriptionGridClauseContext) {
	localctx = NewScreenDescriptionGridClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, Cobol85ParserRULE_screenDescriptionGridClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2557)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserGRID || _la == Cobol85ParserLEFTLINE || _la == Cobol85ParserOVERLINE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IScreenDescriptionReverseVideoClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionReverseVideoClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionReverseVideoClauseContext differentiates from other interfaces.
	IsScreenDescriptionReverseVideoClauseContext()
}

type ScreenDescriptionReverseVideoClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionReverseVideoClauseContext() *ScreenDescriptionReverseVideoClauseContext {
	var p = new(ScreenDescriptionReverseVideoClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionReverseVideoClause
	return p
}

func (*ScreenDescriptionReverseVideoClauseContext) IsScreenDescriptionReverseVideoClauseContext() {}

func NewScreenDescriptionReverseVideoClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionReverseVideoClauseContext {
	var p = new(ScreenDescriptionReverseVideoClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionReverseVideoClause

	return p
}

func (s *ScreenDescriptionReverseVideoClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionReverseVideoClauseContext) REVERSE_VIDEO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREVERSE_VIDEO, 0)
}

func (s *ScreenDescriptionReverseVideoClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionReverseVideoClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionReverseVideoClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionReverseVideoClause(s)
	}
}

func (s *ScreenDescriptionReverseVideoClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionReverseVideoClause(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionReverseVideoClause() (localctx IScreenDescriptionReverseVideoClauseContext) {
	localctx = NewScreenDescriptionReverseVideoClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, Cobol85ParserRULE_screenDescriptionReverseVideoClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2559)
		p.Match(Cobol85ParserREVERSE_VIDEO)
	}

	return localctx
}

// IScreenDescriptionUnderlineClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionUnderlineClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionUnderlineClauseContext differentiates from other interfaces.
	IsScreenDescriptionUnderlineClauseContext()
}

type ScreenDescriptionUnderlineClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionUnderlineClauseContext() *ScreenDescriptionUnderlineClauseContext {
	var p = new(ScreenDescriptionUnderlineClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionUnderlineClause
	return p
}

func (*ScreenDescriptionUnderlineClauseContext) IsScreenDescriptionUnderlineClauseContext() {}

func NewScreenDescriptionUnderlineClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionUnderlineClauseContext {
	var p = new(ScreenDescriptionUnderlineClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionUnderlineClause

	return p
}

func (s *ScreenDescriptionUnderlineClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionUnderlineClauseContext) UNDERLINE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserUNDERLINE, 0)
}

func (s *ScreenDescriptionUnderlineClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionUnderlineClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionUnderlineClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionUnderlineClause(s)
	}
}

func (s *ScreenDescriptionUnderlineClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionUnderlineClause(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionUnderlineClause() (localctx IScreenDescriptionUnderlineClauseContext) {
	localctx = NewScreenDescriptionUnderlineClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, Cobol85ParserRULE_screenDescriptionUnderlineClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2561)
		p.Match(Cobol85ParserUNDERLINE)
	}

	return localctx
}

// IScreenDescriptionSizeClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionSizeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionSizeClauseContext differentiates from other interfaces.
	IsScreenDescriptionSizeClauseContext()
}

type ScreenDescriptionSizeClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionSizeClauseContext() *ScreenDescriptionSizeClauseContext {
	var p = new(ScreenDescriptionSizeClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionSizeClause
	return p
}

func (*ScreenDescriptionSizeClauseContext) IsScreenDescriptionSizeClauseContext() {}

func NewScreenDescriptionSizeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionSizeClauseContext {
	var p = new(ScreenDescriptionSizeClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionSizeClause

	return p
}

func (s *ScreenDescriptionSizeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionSizeClauseContext) SIZE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSIZE, 0)
}

func (s *ScreenDescriptionSizeClauseContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ScreenDescriptionSizeClauseContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ScreenDescriptionSizeClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ScreenDescriptionSizeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionSizeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionSizeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionSizeClause(s)
	}
}

func (s *ScreenDescriptionSizeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionSizeClause(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionSizeClause() (localctx IScreenDescriptionSizeClauseContext) {
	localctx = NewScreenDescriptionSizeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, Cobol85ParserRULE_screenDescriptionSizeClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2563)
		p.Match(Cobol85ParserSIZE)
	}
	p.SetState(2565)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2564)
			p.Match(Cobol85ParserIS)
		}

	}
	p.SetState(2569)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 271, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2567)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(2568)
			p.IntegerLiteral()
		}

	}

	return localctx
}

// IScreenDescriptionLineClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionLineClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionLineClauseContext differentiates from other interfaces.
	IsScreenDescriptionLineClauseContext()
}

type ScreenDescriptionLineClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionLineClauseContext() *ScreenDescriptionLineClauseContext {
	var p = new(ScreenDescriptionLineClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionLineClause
	return p
}

func (*ScreenDescriptionLineClauseContext) IsScreenDescriptionLineClauseContext() {}

func NewScreenDescriptionLineClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionLineClauseContext {
	var p = new(ScreenDescriptionLineClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionLineClause

	return p
}

func (s *ScreenDescriptionLineClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionLineClauseContext) LINE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLINE, 0)
}

func (s *ScreenDescriptionLineClauseContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ScreenDescriptionLineClauseContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ScreenDescriptionLineClauseContext) PLUS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPLUS, 0)
}

func (s *ScreenDescriptionLineClauseContext) PLUSCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPLUSCHAR, 0)
}

func (s *ScreenDescriptionLineClauseContext) MINUSCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMINUSCHAR, 0)
}

func (s *ScreenDescriptionLineClauseContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNUMBER, 0)
}

func (s *ScreenDescriptionLineClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ScreenDescriptionLineClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionLineClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionLineClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionLineClause(s)
	}
}

func (s *ScreenDescriptionLineClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionLineClause(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionLineClause() (localctx IScreenDescriptionLineClauseContext) {
	localctx = NewScreenDescriptionLineClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, Cobol85ParserRULE_screenDescriptionLineClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2571)
		p.Match(Cobol85ParserLINE)
	}
	p.SetState(2579)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS || _la == Cobol85ParserNUMBER || _la == Cobol85ParserPLUS || _la == Cobol85ParserMINUSCHAR || _la == Cobol85ParserPLUSCHAR {
		p.SetState(2573)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserNUMBER {
			{
				p.SetState(2572)
				p.Match(Cobol85ParserNUMBER)
			}

		}
		p.SetState(2576)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserIS {
			{
				p.SetState(2575)
				p.Match(Cobol85ParserIS)
			}

		}
		{
			p.SetState(2578)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85ParserPLUS || _la == Cobol85ParserMINUSCHAR || _la == Cobol85ParserPLUSCHAR) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(2583)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 275, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2581)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(2582)
			p.IntegerLiteral()
		}

	}

	return localctx
}

// IScreenDescriptionColumnClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionColumnClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionColumnClauseContext differentiates from other interfaces.
	IsScreenDescriptionColumnClauseContext()
}

type ScreenDescriptionColumnClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionColumnClauseContext() *ScreenDescriptionColumnClauseContext {
	var p = new(ScreenDescriptionColumnClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionColumnClause
	return p
}

func (*ScreenDescriptionColumnClauseContext) IsScreenDescriptionColumnClauseContext() {}

func NewScreenDescriptionColumnClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionColumnClauseContext {
	var p = new(ScreenDescriptionColumnClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionColumnClause

	return p
}

func (s *ScreenDescriptionColumnClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionColumnClauseContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOLUMN, 0)
}

func (s *ScreenDescriptionColumnClauseContext) COL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOL, 0)
}

func (s *ScreenDescriptionColumnClauseContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ScreenDescriptionColumnClauseContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ScreenDescriptionColumnClauseContext) PLUS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPLUS, 0)
}

func (s *ScreenDescriptionColumnClauseContext) PLUSCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPLUSCHAR, 0)
}

func (s *ScreenDescriptionColumnClauseContext) MINUSCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMINUSCHAR, 0)
}

func (s *ScreenDescriptionColumnClauseContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNUMBER, 0)
}

func (s *ScreenDescriptionColumnClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ScreenDescriptionColumnClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionColumnClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionColumnClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionColumnClause(s)
	}
}

func (s *ScreenDescriptionColumnClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionColumnClause(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionColumnClause() (localctx IScreenDescriptionColumnClauseContext) {
	localctx = NewScreenDescriptionColumnClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, Cobol85ParserRULE_screenDescriptionColumnClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2585)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserCOL || _la == Cobol85ParserCOLUMN) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(2593)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS || _la == Cobol85ParserNUMBER || _la == Cobol85ParserPLUS || _la == Cobol85ParserMINUSCHAR || _la == Cobol85ParserPLUSCHAR {
		p.SetState(2587)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserNUMBER {
			{
				p.SetState(2586)
				p.Match(Cobol85ParserNUMBER)
			}

		}
		p.SetState(2590)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserIS {
			{
				p.SetState(2589)
				p.Match(Cobol85ParserIS)
			}

		}
		{
			p.SetState(2592)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85ParserPLUS || _la == Cobol85ParserMINUSCHAR || _la == Cobol85ParserPLUSCHAR) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(2597)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 279, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2595)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(2596)
			p.IntegerLiteral()
		}

	}

	return localctx
}

// IScreenDescriptionForegroundColorClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionForegroundColorClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionForegroundColorClauseContext differentiates from other interfaces.
	IsScreenDescriptionForegroundColorClauseContext()
}

type ScreenDescriptionForegroundColorClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionForegroundColorClauseContext() *ScreenDescriptionForegroundColorClauseContext {
	var p = new(ScreenDescriptionForegroundColorClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionForegroundColorClause
	return p
}

func (*ScreenDescriptionForegroundColorClauseContext) IsScreenDescriptionForegroundColorClauseContext() {
}

func NewScreenDescriptionForegroundColorClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionForegroundColorClauseContext {
	var p = new(ScreenDescriptionForegroundColorClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionForegroundColorClause

	return p
}

func (s *ScreenDescriptionForegroundColorClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionForegroundColorClauseContext) FOREGROUND_COLOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOREGROUND_COLOR, 0)
}

func (s *ScreenDescriptionForegroundColorClauseContext) FOREGROUND_COLOUR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOREGROUND_COLOUR, 0)
}

func (s *ScreenDescriptionForegroundColorClauseContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ScreenDescriptionForegroundColorClauseContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ScreenDescriptionForegroundColorClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ScreenDescriptionForegroundColorClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionForegroundColorClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionForegroundColorClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionForegroundColorClause(s)
	}
}

func (s *ScreenDescriptionForegroundColorClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionForegroundColorClause(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionForegroundColorClause() (localctx IScreenDescriptionForegroundColorClauseContext) {
	localctx = NewScreenDescriptionForegroundColorClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, Cobol85ParserRULE_screenDescriptionForegroundColorClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2599)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserFOREGROUND_COLOR || _la == Cobol85ParserFOREGROUND_COLOUR) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(2601)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2600)
			p.Match(Cobol85ParserIS)
		}

	}
	p.SetState(2605)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 281, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2603)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(2604)
			p.IntegerLiteral()
		}

	}

	return localctx
}

// IScreenDescriptionBackgroundColorClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionBackgroundColorClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionBackgroundColorClauseContext differentiates from other interfaces.
	IsScreenDescriptionBackgroundColorClauseContext()
}

type ScreenDescriptionBackgroundColorClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionBackgroundColorClauseContext() *ScreenDescriptionBackgroundColorClauseContext {
	var p = new(ScreenDescriptionBackgroundColorClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionBackgroundColorClause
	return p
}

func (*ScreenDescriptionBackgroundColorClauseContext) IsScreenDescriptionBackgroundColorClauseContext() {
}

func NewScreenDescriptionBackgroundColorClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionBackgroundColorClauseContext {
	var p = new(ScreenDescriptionBackgroundColorClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionBackgroundColorClause

	return p
}

func (s *ScreenDescriptionBackgroundColorClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionBackgroundColorClauseContext) BACKGROUND_COLOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBACKGROUND_COLOR, 0)
}

func (s *ScreenDescriptionBackgroundColorClauseContext) BACKGROUND_COLOUR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBACKGROUND_COLOUR, 0)
}

func (s *ScreenDescriptionBackgroundColorClauseContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ScreenDescriptionBackgroundColorClauseContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ScreenDescriptionBackgroundColorClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ScreenDescriptionBackgroundColorClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionBackgroundColorClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionBackgroundColorClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionBackgroundColorClause(s)
	}
}

func (s *ScreenDescriptionBackgroundColorClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionBackgroundColorClause(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionBackgroundColorClause() (localctx IScreenDescriptionBackgroundColorClauseContext) {
	localctx = NewScreenDescriptionBackgroundColorClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, Cobol85ParserRULE_screenDescriptionBackgroundColorClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2607)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserBACKGROUND_COLOR || _la == Cobol85ParserBACKGROUND_COLOUR) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(2609)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2608)
			p.Match(Cobol85ParserIS)
		}

	}
	p.SetState(2613)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 283, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2611)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(2612)
			p.IntegerLiteral()
		}

	}

	return localctx
}

// IScreenDescriptionControlClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionControlClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionControlClauseContext differentiates from other interfaces.
	IsScreenDescriptionControlClauseContext()
}

type ScreenDescriptionControlClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionControlClauseContext() *ScreenDescriptionControlClauseContext {
	var p = new(ScreenDescriptionControlClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionControlClause
	return p
}

func (*ScreenDescriptionControlClauseContext) IsScreenDescriptionControlClauseContext() {}

func NewScreenDescriptionControlClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionControlClauseContext {
	var p = new(ScreenDescriptionControlClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionControlClause

	return p
}

func (s *ScreenDescriptionControlClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionControlClauseContext) CONTROL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCONTROL, 0)
}

func (s *ScreenDescriptionControlClauseContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ScreenDescriptionControlClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ScreenDescriptionControlClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionControlClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionControlClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionControlClause(s)
	}
}

func (s *ScreenDescriptionControlClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionControlClause(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionControlClause() (localctx IScreenDescriptionControlClauseContext) {
	localctx = NewScreenDescriptionControlClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 286, Cobol85ParserRULE_screenDescriptionControlClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2615)
		p.Match(Cobol85ParserCONTROL)
	}
	p.SetState(2617)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2616)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(2619)
		p.Identifier()
	}

	return localctx
}

// IScreenDescriptionValueClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionValueClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionValueClauseContext differentiates from other interfaces.
	IsScreenDescriptionValueClauseContext()
}

type ScreenDescriptionValueClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionValueClauseContext() *ScreenDescriptionValueClauseContext {
	var p = new(ScreenDescriptionValueClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionValueClause
	return p
}

func (*ScreenDescriptionValueClauseContext) IsScreenDescriptionValueClauseContext() {}

func NewScreenDescriptionValueClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionValueClauseContext {
	var p = new(ScreenDescriptionValueClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionValueClause

	return p
}

func (s *ScreenDescriptionValueClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionValueClauseContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *ScreenDescriptionValueClauseContext) VALUE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserVALUE, 0)
}

func (s *ScreenDescriptionValueClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ScreenDescriptionValueClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionValueClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionValueClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionValueClause(s)
	}
}

func (s *ScreenDescriptionValueClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionValueClause(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionValueClause() (localctx IScreenDescriptionValueClauseContext) {
	localctx = NewScreenDescriptionValueClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 288, Cobol85ParserRULE_screenDescriptionValueClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2621)
		p.Match(Cobol85ParserVALUE)
	}
	p.SetState(2623)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2622)
			p.Match(Cobol85ParserIS)
		}

	}

	{
		p.SetState(2625)
		p.Literal()
	}

	return localctx
}

// IScreenDescriptionPictureClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionPictureClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionPictureClauseContext differentiates from other interfaces.
	IsScreenDescriptionPictureClauseContext()
}

type ScreenDescriptionPictureClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionPictureClauseContext() *ScreenDescriptionPictureClauseContext {
	var p = new(ScreenDescriptionPictureClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionPictureClause
	return p
}

func (*ScreenDescriptionPictureClauseContext) IsScreenDescriptionPictureClauseContext() {}

func NewScreenDescriptionPictureClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionPictureClauseContext {
	var p = new(ScreenDescriptionPictureClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionPictureClause

	return p
}

func (s *ScreenDescriptionPictureClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionPictureClauseContext) PictureString() IPictureStringContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPictureStringContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPictureStringContext)
}

func (s *ScreenDescriptionPictureClauseContext) PICTURE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPICTURE, 0)
}

func (s *ScreenDescriptionPictureClauseContext) PIC() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPIC, 0)
}

func (s *ScreenDescriptionPictureClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ScreenDescriptionPictureClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionPictureClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionPictureClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionPictureClause(s)
	}
}

func (s *ScreenDescriptionPictureClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionPictureClause(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionPictureClause() (localctx IScreenDescriptionPictureClauseContext) {
	localctx = NewScreenDescriptionPictureClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 290, Cobol85ParserRULE_screenDescriptionPictureClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2627)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserPIC || _la == Cobol85ParserPICTURE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(2629)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2628)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(2631)
		p.PictureString()
	}

	return localctx
}

// IScreenDescriptionFromClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionFromClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionFromClauseContext differentiates from other interfaces.
	IsScreenDescriptionFromClauseContext()
}

type ScreenDescriptionFromClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionFromClauseContext() *ScreenDescriptionFromClauseContext {
	var p = new(ScreenDescriptionFromClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionFromClause
	return p
}

func (*ScreenDescriptionFromClauseContext) IsScreenDescriptionFromClauseContext() {}

func NewScreenDescriptionFromClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionFromClauseContext {
	var p = new(ScreenDescriptionFromClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionFromClause

	return p
}

func (s *ScreenDescriptionFromClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionFromClauseContext) FROM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFROM, 0)
}

func (s *ScreenDescriptionFromClauseContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ScreenDescriptionFromClauseContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *ScreenDescriptionFromClauseContext) ScreenDescriptionToClause() IScreenDescriptionToClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScreenDescriptionToClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionToClauseContext)
}

func (s *ScreenDescriptionFromClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionFromClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionFromClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionFromClause(s)
	}
}

func (s *ScreenDescriptionFromClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionFromClause(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionFromClause() (localctx IScreenDescriptionFromClauseContext) {
	localctx = NewScreenDescriptionFromClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 292, Cobol85ParserRULE_screenDescriptionFromClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2633)
		p.Match(Cobol85ParserFROM)
	}
	p.SetState(2636)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 287, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2634)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(2635)
			p.Literal()
		}

	}
	p.SetState(2639)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserTO {
		{
			p.SetState(2638)
			p.ScreenDescriptionToClause()
		}

	}

	return localctx
}

// IScreenDescriptionToClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionToClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionToClauseContext differentiates from other interfaces.
	IsScreenDescriptionToClauseContext()
}

type ScreenDescriptionToClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionToClauseContext() *ScreenDescriptionToClauseContext {
	var p = new(ScreenDescriptionToClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionToClause
	return p
}

func (*ScreenDescriptionToClauseContext) IsScreenDescriptionToClauseContext() {}

func NewScreenDescriptionToClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionToClauseContext {
	var p = new(ScreenDescriptionToClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionToClause

	return p
}

func (s *ScreenDescriptionToClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionToClauseContext) TO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTO, 0)
}

func (s *ScreenDescriptionToClauseContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ScreenDescriptionToClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionToClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionToClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionToClause(s)
	}
}

func (s *ScreenDescriptionToClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionToClause(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionToClause() (localctx IScreenDescriptionToClauseContext) {
	localctx = NewScreenDescriptionToClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 294, Cobol85ParserRULE_screenDescriptionToClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2641)
		p.Match(Cobol85ParserTO)
	}
	{
		p.SetState(2642)
		p.Identifier()
	}

	return localctx
}

// IScreenDescriptionUsingClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionUsingClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionUsingClauseContext differentiates from other interfaces.
	IsScreenDescriptionUsingClauseContext()
}

type ScreenDescriptionUsingClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionUsingClauseContext() *ScreenDescriptionUsingClauseContext {
	var p = new(ScreenDescriptionUsingClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionUsingClause
	return p
}

func (*ScreenDescriptionUsingClauseContext) IsScreenDescriptionUsingClauseContext() {}

func NewScreenDescriptionUsingClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionUsingClauseContext {
	var p = new(ScreenDescriptionUsingClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionUsingClause

	return p
}

func (s *ScreenDescriptionUsingClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionUsingClauseContext) USING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserUSING, 0)
}

func (s *ScreenDescriptionUsingClauseContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ScreenDescriptionUsingClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionUsingClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionUsingClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionUsingClause(s)
	}
}

func (s *ScreenDescriptionUsingClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionUsingClause(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionUsingClause() (localctx IScreenDescriptionUsingClauseContext) {
	localctx = NewScreenDescriptionUsingClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 296, Cobol85ParserRULE_screenDescriptionUsingClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2644)
		p.Match(Cobol85ParserUSING)
	}
	{
		p.SetState(2645)
		p.Identifier()
	}

	return localctx
}

// IScreenDescriptionUsageClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionUsageClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionUsageClauseContext differentiates from other interfaces.
	IsScreenDescriptionUsageClauseContext()
}

type ScreenDescriptionUsageClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionUsageClauseContext() *ScreenDescriptionUsageClauseContext {
	var p = new(ScreenDescriptionUsageClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionUsageClause
	return p
}

func (*ScreenDescriptionUsageClauseContext) IsScreenDescriptionUsageClauseContext() {}

func NewScreenDescriptionUsageClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionUsageClauseContext {
	var p = new(ScreenDescriptionUsageClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionUsageClause

	return p
}

func (s *ScreenDescriptionUsageClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionUsageClauseContext) DISPLAY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDISPLAY, 0)
}

func (s *ScreenDescriptionUsageClauseContext) DISPLAY_1() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDISPLAY_1, 0)
}

func (s *ScreenDescriptionUsageClauseContext) USAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserUSAGE, 0)
}

func (s *ScreenDescriptionUsageClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ScreenDescriptionUsageClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionUsageClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionUsageClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionUsageClause(s)
	}
}

func (s *ScreenDescriptionUsageClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionUsageClause(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionUsageClause() (localctx IScreenDescriptionUsageClauseContext) {
	localctx = NewScreenDescriptionUsageClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 298, Cobol85ParserRULE_screenDescriptionUsageClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2647)
		p.Match(Cobol85ParserUSAGE)
	}
	p.SetState(2649)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2648)
			p.Match(Cobol85ParserIS)
		}

	}

	{
		p.SetState(2651)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserDISPLAY || _la == Cobol85ParserDISPLAY_1) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IScreenDescriptionBlankWhenZeroClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionBlankWhenZeroClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionBlankWhenZeroClauseContext differentiates from other interfaces.
	IsScreenDescriptionBlankWhenZeroClauseContext()
}

type ScreenDescriptionBlankWhenZeroClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionBlankWhenZeroClauseContext() *ScreenDescriptionBlankWhenZeroClauseContext {
	var p = new(ScreenDescriptionBlankWhenZeroClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionBlankWhenZeroClause
	return p
}

func (*ScreenDescriptionBlankWhenZeroClauseContext) IsScreenDescriptionBlankWhenZeroClauseContext() {}

func NewScreenDescriptionBlankWhenZeroClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionBlankWhenZeroClauseContext {
	var p = new(ScreenDescriptionBlankWhenZeroClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionBlankWhenZeroClause

	return p
}

func (s *ScreenDescriptionBlankWhenZeroClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionBlankWhenZeroClauseContext) BLANK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBLANK, 0)
}

func (s *ScreenDescriptionBlankWhenZeroClauseContext) ZERO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserZERO, 0)
}

func (s *ScreenDescriptionBlankWhenZeroClauseContext) WHEN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWHEN, 0)
}

func (s *ScreenDescriptionBlankWhenZeroClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionBlankWhenZeroClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionBlankWhenZeroClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionBlankWhenZeroClause(s)
	}
}

func (s *ScreenDescriptionBlankWhenZeroClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionBlankWhenZeroClause(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionBlankWhenZeroClause() (localctx IScreenDescriptionBlankWhenZeroClauseContext) {
	localctx = NewScreenDescriptionBlankWhenZeroClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 300, Cobol85ParserRULE_screenDescriptionBlankWhenZeroClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2653)
		p.Match(Cobol85ParserBLANK)
	}
	p.SetState(2655)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserWHEN {
		{
			p.SetState(2654)
			p.Match(Cobol85ParserWHEN)
		}

	}
	{
		p.SetState(2657)
		p.Match(Cobol85ParserZERO)
	}

	return localctx
}

// IScreenDescriptionJustifiedClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionJustifiedClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionJustifiedClauseContext differentiates from other interfaces.
	IsScreenDescriptionJustifiedClauseContext()
}

type ScreenDescriptionJustifiedClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionJustifiedClauseContext() *ScreenDescriptionJustifiedClauseContext {
	var p = new(ScreenDescriptionJustifiedClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionJustifiedClause
	return p
}

func (*ScreenDescriptionJustifiedClauseContext) IsScreenDescriptionJustifiedClauseContext() {}

func NewScreenDescriptionJustifiedClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionJustifiedClauseContext {
	var p = new(ScreenDescriptionJustifiedClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionJustifiedClause

	return p
}

func (s *ScreenDescriptionJustifiedClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionJustifiedClauseContext) JUSTIFIED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserJUSTIFIED, 0)
}

func (s *ScreenDescriptionJustifiedClauseContext) JUST() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserJUST, 0)
}

func (s *ScreenDescriptionJustifiedClauseContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRIGHT, 0)
}

func (s *ScreenDescriptionJustifiedClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionJustifiedClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionJustifiedClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionJustifiedClause(s)
	}
}

func (s *ScreenDescriptionJustifiedClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionJustifiedClause(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionJustifiedClause() (localctx IScreenDescriptionJustifiedClauseContext) {
	localctx = NewScreenDescriptionJustifiedClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 302, Cobol85ParserRULE_screenDescriptionJustifiedClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2659)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserJUST || _la == Cobol85ParserJUSTIFIED) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(2661)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserRIGHT {
		{
			p.SetState(2660)
			p.Match(Cobol85ParserRIGHT)
		}

	}

	return localctx
}

// IScreenDescriptionSignClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionSignClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionSignClauseContext differentiates from other interfaces.
	IsScreenDescriptionSignClauseContext()
}

type ScreenDescriptionSignClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionSignClauseContext() *ScreenDescriptionSignClauseContext {
	var p = new(ScreenDescriptionSignClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionSignClause
	return p
}

func (*ScreenDescriptionSignClauseContext) IsScreenDescriptionSignClauseContext() {}

func NewScreenDescriptionSignClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionSignClauseContext {
	var p = new(ScreenDescriptionSignClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionSignClause

	return p
}

func (s *ScreenDescriptionSignClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionSignClauseContext) LEADING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLEADING, 0)
}

func (s *ScreenDescriptionSignClauseContext) TRAILING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTRAILING, 0)
}

func (s *ScreenDescriptionSignClauseContext) SIGN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSIGN, 0)
}

func (s *ScreenDescriptionSignClauseContext) SEPARATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSEPARATE, 0)
}

func (s *ScreenDescriptionSignClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ScreenDescriptionSignClauseContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCHARACTER, 0)
}

func (s *ScreenDescriptionSignClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionSignClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionSignClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionSignClause(s)
	}
}

func (s *ScreenDescriptionSignClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionSignClause(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionSignClause() (localctx IScreenDescriptionSignClauseContext) {
	localctx = NewScreenDescriptionSignClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 304, Cobol85ParserRULE_screenDescriptionSignClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2667)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserSIGN {
		{
			p.SetState(2663)
			p.Match(Cobol85ParserSIGN)
		}
		p.SetState(2665)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserIS {
			{
				p.SetState(2664)
				p.Match(Cobol85ParserIS)
			}

		}

	}
	{
		p.SetState(2669)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserLEADING || _la == Cobol85ParserTRAILING) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(2674)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserSEPARATE {
		{
			p.SetState(2670)
			p.Match(Cobol85ParserSEPARATE)
		}
		p.SetState(2672)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserCHARACTER {
			{
				p.SetState(2671)
				p.Match(Cobol85ParserCHARACTER)
			}

		}

	}

	return localctx
}

// IScreenDescriptionAutoClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionAutoClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionAutoClauseContext differentiates from other interfaces.
	IsScreenDescriptionAutoClauseContext()
}

type ScreenDescriptionAutoClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionAutoClauseContext() *ScreenDescriptionAutoClauseContext {
	var p = new(ScreenDescriptionAutoClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionAutoClause
	return p
}

func (*ScreenDescriptionAutoClauseContext) IsScreenDescriptionAutoClauseContext() {}

func NewScreenDescriptionAutoClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionAutoClauseContext {
	var p = new(ScreenDescriptionAutoClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionAutoClause

	return p
}

func (s *ScreenDescriptionAutoClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionAutoClauseContext) AUTO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAUTO, 0)
}

func (s *ScreenDescriptionAutoClauseContext) AUTO_SKIP() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAUTO_SKIP, 0)
}

func (s *ScreenDescriptionAutoClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionAutoClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionAutoClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionAutoClause(s)
	}
}

func (s *ScreenDescriptionAutoClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionAutoClause(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionAutoClause() (localctx IScreenDescriptionAutoClauseContext) {
	localctx = NewScreenDescriptionAutoClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 306, Cobol85ParserRULE_screenDescriptionAutoClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2676)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserAUTO || _la == Cobol85ParserAUTO_SKIP) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IScreenDescriptionSecureClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionSecureClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionSecureClauseContext differentiates from other interfaces.
	IsScreenDescriptionSecureClauseContext()
}

type ScreenDescriptionSecureClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionSecureClauseContext() *ScreenDescriptionSecureClauseContext {
	var p = new(ScreenDescriptionSecureClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionSecureClause
	return p
}

func (*ScreenDescriptionSecureClauseContext) IsScreenDescriptionSecureClauseContext() {}

func NewScreenDescriptionSecureClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionSecureClauseContext {
	var p = new(ScreenDescriptionSecureClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionSecureClause

	return p
}

func (s *ScreenDescriptionSecureClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionSecureClauseContext) SECURE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSECURE, 0)
}

func (s *ScreenDescriptionSecureClauseContext) NO_ECHO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNO_ECHO, 0)
}

func (s *ScreenDescriptionSecureClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionSecureClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionSecureClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionSecureClause(s)
	}
}

func (s *ScreenDescriptionSecureClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionSecureClause(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionSecureClause() (localctx IScreenDescriptionSecureClauseContext) {
	localctx = NewScreenDescriptionSecureClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 308, Cobol85ParserRULE_screenDescriptionSecureClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2678)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserNO_ECHO || _la == Cobol85ParserSECURE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IScreenDescriptionRequiredClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionRequiredClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionRequiredClauseContext differentiates from other interfaces.
	IsScreenDescriptionRequiredClauseContext()
}

type ScreenDescriptionRequiredClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionRequiredClauseContext() *ScreenDescriptionRequiredClauseContext {
	var p = new(ScreenDescriptionRequiredClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionRequiredClause
	return p
}

func (*ScreenDescriptionRequiredClauseContext) IsScreenDescriptionRequiredClauseContext() {}

func NewScreenDescriptionRequiredClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionRequiredClauseContext {
	var p = new(ScreenDescriptionRequiredClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionRequiredClause

	return p
}

func (s *ScreenDescriptionRequiredClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionRequiredClauseContext) REQUIRED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREQUIRED, 0)
}

func (s *ScreenDescriptionRequiredClauseContext) EMPTY_CHECK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEMPTY_CHECK, 0)
}

func (s *ScreenDescriptionRequiredClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionRequiredClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionRequiredClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionRequiredClause(s)
	}
}

func (s *ScreenDescriptionRequiredClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionRequiredClause(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionRequiredClause() (localctx IScreenDescriptionRequiredClauseContext) {
	localctx = NewScreenDescriptionRequiredClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 310, Cobol85ParserRULE_screenDescriptionRequiredClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2680)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserEMPTY_CHECK || _la == Cobol85ParserREQUIRED) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IScreenDescriptionPromptClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionPromptClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionPromptClauseContext differentiates from other interfaces.
	IsScreenDescriptionPromptClauseContext()
}

type ScreenDescriptionPromptClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionPromptClauseContext() *ScreenDescriptionPromptClauseContext {
	var p = new(ScreenDescriptionPromptClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionPromptClause
	return p
}

func (*ScreenDescriptionPromptClauseContext) IsScreenDescriptionPromptClauseContext() {}

func NewScreenDescriptionPromptClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionPromptClauseContext {
	var p = new(ScreenDescriptionPromptClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionPromptClause

	return p
}

func (s *ScreenDescriptionPromptClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionPromptClauseContext) PROMPT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPROMPT, 0)
}

func (s *ScreenDescriptionPromptClauseContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ScreenDescriptionPromptClauseContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *ScreenDescriptionPromptClauseContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCHARACTER, 0)
}

func (s *ScreenDescriptionPromptClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ScreenDescriptionPromptClauseContext) ScreenDescriptionPromptOccursClause() IScreenDescriptionPromptOccursClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScreenDescriptionPromptOccursClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionPromptOccursClauseContext)
}

func (s *ScreenDescriptionPromptClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionPromptClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionPromptClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionPromptClause(s)
	}
}

func (s *ScreenDescriptionPromptClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionPromptClause(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionPromptClause() (localctx IScreenDescriptionPromptClauseContext) {
	localctx = NewScreenDescriptionPromptClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 312, Cobol85ParserRULE_screenDescriptionPromptClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2682)
		p.Match(Cobol85ParserPROMPT)
	}
	p.SetState(2684)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCHARACTER {
		{
			p.SetState(2683)
			p.Match(Cobol85ParserCHARACTER)
		}

	}
	p.SetState(2687)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2686)
			p.Match(Cobol85ParserIS)
		}

	}
	p.SetState(2691)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 298, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2689)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(2690)
			p.Literal()
		}

	}
	p.SetState(2694)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserOCCURS {
		{
			p.SetState(2693)
			p.ScreenDescriptionPromptOccursClause()
		}

	}

	return localctx
}

// IScreenDescriptionPromptOccursClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionPromptOccursClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionPromptOccursClauseContext differentiates from other interfaces.
	IsScreenDescriptionPromptOccursClauseContext()
}

type ScreenDescriptionPromptOccursClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionPromptOccursClauseContext() *ScreenDescriptionPromptOccursClauseContext {
	var p = new(ScreenDescriptionPromptOccursClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionPromptOccursClause
	return p
}

func (*ScreenDescriptionPromptOccursClauseContext) IsScreenDescriptionPromptOccursClauseContext() {}

func NewScreenDescriptionPromptOccursClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionPromptOccursClauseContext {
	var p = new(ScreenDescriptionPromptOccursClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionPromptOccursClause

	return p
}

func (s *ScreenDescriptionPromptOccursClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionPromptOccursClauseContext) OCCURS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOCCURS, 0)
}

func (s *ScreenDescriptionPromptOccursClauseContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ScreenDescriptionPromptOccursClauseContext) TIMES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTIMES, 0)
}

func (s *ScreenDescriptionPromptOccursClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionPromptOccursClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionPromptOccursClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionPromptOccursClause(s)
	}
}

func (s *ScreenDescriptionPromptOccursClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionPromptOccursClause(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionPromptOccursClause() (localctx IScreenDescriptionPromptOccursClauseContext) {
	localctx = NewScreenDescriptionPromptOccursClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 314, Cobol85ParserRULE_screenDescriptionPromptOccursClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2696)
		p.Match(Cobol85ParserOCCURS)
	}
	{
		p.SetState(2697)
		p.IntegerLiteral()
	}
	p.SetState(2699)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserTIMES {
		{
			p.SetState(2698)
			p.Match(Cobol85ParserTIMES)
		}

	}

	return localctx
}

// IScreenDescriptionFullClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionFullClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionFullClauseContext differentiates from other interfaces.
	IsScreenDescriptionFullClauseContext()
}

type ScreenDescriptionFullClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionFullClauseContext() *ScreenDescriptionFullClauseContext {
	var p = new(ScreenDescriptionFullClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionFullClause
	return p
}

func (*ScreenDescriptionFullClauseContext) IsScreenDescriptionFullClauseContext() {}

func NewScreenDescriptionFullClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionFullClauseContext {
	var p = new(ScreenDescriptionFullClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionFullClause

	return p
}

func (s *ScreenDescriptionFullClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionFullClauseContext) FULL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFULL, 0)
}

func (s *ScreenDescriptionFullClauseContext) LENGTH_CHECK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLENGTH_CHECK, 0)
}

func (s *ScreenDescriptionFullClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionFullClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionFullClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionFullClause(s)
	}
}

func (s *ScreenDescriptionFullClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionFullClause(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionFullClause() (localctx IScreenDescriptionFullClauseContext) {
	localctx = NewScreenDescriptionFullClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 316, Cobol85ParserRULE_screenDescriptionFullClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2701)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserFULL || _la == Cobol85ParserLENGTH_CHECK) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IScreenDescriptionZeroFillClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionZeroFillClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionZeroFillClauseContext differentiates from other interfaces.
	IsScreenDescriptionZeroFillClauseContext()
}

type ScreenDescriptionZeroFillClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionZeroFillClauseContext() *ScreenDescriptionZeroFillClauseContext {
	var p = new(ScreenDescriptionZeroFillClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionZeroFillClause
	return p
}

func (*ScreenDescriptionZeroFillClauseContext) IsScreenDescriptionZeroFillClauseContext() {}

func NewScreenDescriptionZeroFillClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionZeroFillClauseContext {
	var p = new(ScreenDescriptionZeroFillClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionZeroFillClause

	return p
}

func (s *ScreenDescriptionZeroFillClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionZeroFillClauseContext) ZERO_FILL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserZERO_FILL, 0)
}

func (s *ScreenDescriptionZeroFillClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionZeroFillClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionZeroFillClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionZeroFillClause(s)
	}
}

func (s *ScreenDescriptionZeroFillClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionZeroFillClause(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionZeroFillClause() (localctx IScreenDescriptionZeroFillClauseContext) {
	localctx = NewScreenDescriptionZeroFillClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 318, Cobol85ParserRULE_screenDescriptionZeroFillClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2703)
		p.Match(Cobol85ParserZERO_FILL)
	}

	return localctx
}

// IReportSectionContext is an interface to support dynamic dispatch.
type IReportSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportSectionContext differentiates from other interfaces.
	IsReportSectionContext()
}

type ReportSectionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportSectionContext() *ReportSectionContext {
	var p = new(ReportSectionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportSection
	return p
}

func (*ReportSectionContext) IsReportSectionContext() {}

func NewReportSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportSectionContext {
	var p = new(ReportSectionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportSection

	return p
}

func (s *ReportSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportSectionContext) REPORT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREPORT, 0)
}

func (s *ReportSectionContext) SECTION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSECTION, 0)
}

func (s *ReportSectionContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *ReportSectionContext) AllReportDescription() []IReportDescriptionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IReportDescriptionContext)(nil)).Elem())
	var tst = make([]IReportDescriptionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IReportDescriptionContext)
		}
	}

	return tst
}

func (s *ReportSectionContext) ReportDescription(i int) IReportDescriptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportDescriptionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IReportDescriptionContext)
}

func (s *ReportSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportSection(s)
	}
}

func (s *ReportSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportSection(s)
	}
}

func (p *Cobol85Parser) ReportSection() (localctx IReportSectionContext) {
	localctx = NewReportSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 320, Cobol85ParserRULE_reportSection)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2705)
		p.Match(Cobol85ParserREPORT)
	}
	{
		p.SetState(2706)
		p.Match(Cobol85ParserSECTION)
	}
	{
		p.SetState(2707)
		p.Match(Cobol85ParserDOT_FS)
	}
	p.SetState(2711)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserRD {
		{
			p.SetState(2708)
			p.ReportDescription()
		}

		p.SetState(2713)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IReportDescriptionContext is an interface to support dynamic dispatch.
type IReportDescriptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportDescriptionContext differentiates from other interfaces.
	IsReportDescriptionContext()
}

type ReportDescriptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportDescriptionContext() *ReportDescriptionContext {
	var p = new(ReportDescriptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportDescription
	return p
}

func (*ReportDescriptionContext) IsReportDescriptionContext() {}

func NewReportDescriptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportDescriptionContext {
	var p = new(ReportDescriptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportDescription

	return p
}

func (s *ReportDescriptionContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportDescriptionContext) ReportDescriptionEntry() IReportDescriptionEntryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportDescriptionEntryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReportDescriptionEntryContext)
}

func (s *ReportDescriptionContext) AllReportGroupDescriptionEntry() []IReportGroupDescriptionEntryContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IReportGroupDescriptionEntryContext)(nil)).Elem())
	var tst = make([]IReportGroupDescriptionEntryContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IReportGroupDescriptionEntryContext)
		}
	}

	return tst
}

func (s *ReportDescriptionContext) ReportGroupDescriptionEntry(i int) IReportGroupDescriptionEntryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportGroupDescriptionEntryContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IReportGroupDescriptionEntryContext)
}

func (s *ReportDescriptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportDescriptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportDescriptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportDescription(s)
	}
}

func (s *ReportDescriptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportDescription(s)
	}
}

func (p *Cobol85Parser) ReportDescription() (localctx IReportDescriptionContext) {
	localctx = NewReportDescriptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 322, Cobol85ParserRULE_reportDescription)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2714)
		p.ReportDescriptionEntry()
	}
	p.SetState(2716)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la-552)&-(0x1f+1)) == 0 && ((1<<uint((_la-552)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-552))|(1<<(Cobol85ParserLEVEL_NUMBER_77-552))|(1<<(Cobol85ParserLEVEL_NUMBER_88-552))|(1<<(Cobol85ParserINTEGERLITERAL-552)))) != 0) {
		{
			p.SetState(2715)
			p.ReportGroupDescriptionEntry()
		}

		p.SetState(2718)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IReportDescriptionEntryContext is an interface to support dynamic dispatch.
type IReportDescriptionEntryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportDescriptionEntryContext differentiates from other interfaces.
	IsReportDescriptionEntryContext()
}

type ReportDescriptionEntryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportDescriptionEntryContext() *ReportDescriptionEntryContext {
	var p = new(ReportDescriptionEntryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportDescriptionEntry
	return p
}

func (*ReportDescriptionEntryContext) IsReportDescriptionEntryContext() {}

func NewReportDescriptionEntryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportDescriptionEntryContext {
	var p = new(ReportDescriptionEntryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportDescriptionEntry

	return p
}

func (s *ReportDescriptionEntryContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportDescriptionEntryContext) RD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRD, 0)
}

func (s *ReportDescriptionEntryContext) ReportName() IReportNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReportNameContext)
}

func (s *ReportDescriptionEntryContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *ReportDescriptionEntryContext) ReportDescriptionGlobalClause() IReportDescriptionGlobalClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportDescriptionGlobalClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReportDescriptionGlobalClauseContext)
}

func (s *ReportDescriptionEntryContext) ReportDescriptionPageLimitClause() IReportDescriptionPageLimitClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportDescriptionPageLimitClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReportDescriptionPageLimitClauseContext)
}

func (s *ReportDescriptionEntryContext) ReportDescriptionHeadingClause() IReportDescriptionHeadingClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportDescriptionHeadingClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReportDescriptionHeadingClauseContext)
}

func (s *ReportDescriptionEntryContext) ReportDescriptionFirstDetailClause() IReportDescriptionFirstDetailClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportDescriptionFirstDetailClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReportDescriptionFirstDetailClauseContext)
}

func (s *ReportDescriptionEntryContext) ReportDescriptionLastDetailClause() IReportDescriptionLastDetailClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportDescriptionLastDetailClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReportDescriptionLastDetailClauseContext)
}

func (s *ReportDescriptionEntryContext) ReportDescriptionFootingClause() IReportDescriptionFootingClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportDescriptionFootingClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReportDescriptionFootingClauseContext)
}

func (s *ReportDescriptionEntryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportDescriptionEntryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportDescriptionEntryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportDescriptionEntry(s)
	}
}

func (s *ReportDescriptionEntryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportDescriptionEntry(s)
	}
}

func (p *Cobol85Parser) ReportDescriptionEntry() (localctx IReportDescriptionEntryContext) {
	localctx = NewReportDescriptionEntryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 324, Cobol85ParserRULE_reportDescriptionEntry)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2720)
		p.Match(Cobol85ParserRD)
	}
	{
		p.SetState(2721)
		p.ReportName()
	}
	p.SetState(2723)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserGLOBAL || _la == Cobol85ParserIS {
		{
			p.SetState(2722)
			p.ReportDescriptionGlobalClause()
		}

	}
	p.SetState(2738)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserPAGE {
		{
			p.SetState(2725)
			p.ReportDescriptionPageLimitClause()
		}
		p.SetState(2727)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserHEADING {
			{
				p.SetState(2726)
				p.ReportDescriptionHeadingClause()
			}

		}
		p.SetState(2730)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserFIRST {
			{
				p.SetState(2729)
				p.ReportDescriptionFirstDetailClause()
			}

		}
		p.SetState(2733)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserLAST {
			{
				p.SetState(2732)
				p.ReportDescriptionLastDetailClause()
			}

		}
		p.SetState(2736)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserFOOTING {
			{
				p.SetState(2735)
				p.ReportDescriptionFootingClause()
			}

		}

	}
	{
		p.SetState(2740)
		p.Match(Cobol85ParserDOT_FS)
	}

	return localctx
}

// IReportDescriptionGlobalClauseContext is an interface to support dynamic dispatch.
type IReportDescriptionGlobalClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportDescriptionGlobalClauseContext differentiates from other interfaces.
	IsReportDescriptionGlobalClauseContext()
}

type ReportDescriptionGlobalClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportDescriptionGlobalClauseContext() *ReportDescriptionGlobalClauseContext {
	var p = new(ReportDescriptionGlobalClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportDescriptionGlobalClause
	return p
}

func (*ReportDescriptionGlobalClauseContext) IsReportDescriptionGlobalClauseContext() {}

func NewReportDescriptionGlobalClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportDescriptionGlobalClauseContext {
	var p = new(ReportDescriptionGlobalClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportDescriptionGlobalClause

	return p
}

func (s *ReportDescriptionGlobalClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportDescriptionGlobalClauseContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserGLOBAL, 0)
}

func (s *ReportDescriptionGlobalClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ReportDescriptionGlobalClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportDescriptionGlobalClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportDescriptionGlobalClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportDescriptionGlobalClause(s)
	}
}

func (s *ReportDescriptionGlobalClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportDescriptionGlobalClause(s)
	}
}

func (p *Cobol85Parser) ReportDescriptionGlobalClause() (localctx IReportDescriptionGlobalClauseContext) {
	localctx = NewReportDescriptionGlobalClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 326, Cobol85ParserRULE_reportDescriptionGlobalClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2743)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2742)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(2745)
		p.Match(Cobol85ParserGLOBAL)
	}

	return localctx
}

// IReportDescriptionPageLimitClauseContext is an interface to support dynamic dispatch.
type IReportDescriptionPageLimitClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportDescriptionPageLimitClauseContext differentiates from other interfaces.
	IsReportDescriptionPageLimitClauseContext()
}

type ReportDescriptionPageLimitClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportDescriptionPageLimitClauseContext() *ReportDescriptionPageLimitClauseContext {
	var p = new(ReportDescriptionPageLimitClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportDescriptionPageLimitClause
	return p
}

func (*ReportDescriptionPageLimitClauseContext) IsReportDescriptionPageLimitClauseContext() {}

func NewReportDescriptionPageLimitClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportDescriptionPageLimitClauseContext {
	var p = new(ReportDescriptionPageLimitClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportDescriptionPageLimitClause

	return p
}

func (s *ReportDescriptionPageLimitClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportDescriptionPageLimitClauseContext) PAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPAGE, 0)
}

func (s *ReportDescriptionPageLimitClauseContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ReportDescriptionPageLimitClauseContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLIMIT, 0)
}

func (s *ReportDescriptionPageLimitClauseContext) LIMITS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLIMITS, 0)
}

func (s *ReportDescriptionPageLimitClauseContext) LINE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLINE, 0)
}

func (s *ReportDescriptionPageLimitClauseContext) LINES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLINES, 0)
}

func (s *ReportDescriptionPageLimitClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ReportDescriptionPageLimitClauseContext) ARE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserARE, 0)
}

func (s *ReportDescriptionPageLimitClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportDescriptionPageLimitClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportDescriptionPageLimitClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportDescriptionPageLimitClause(s)
	}
}

func (s *ReportDescriptionPageLimitClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportDescriptionPageLimitClause(s)
	}
}

func (p *Cobol85Parser) ReportDescriptionPageLimitClause() (localctx IReportDescriptionPageLimitClauseContext) {
	localctx = NewReportDescriptionPageLimitClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 328, Cobol85ParserRULE_reportDescriptionPageLimitClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2747)
		p.Match(Cobol85ParserPAGE)
	}
	p.SetState(2756)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserLIMIT:
		{
			p.SetState(2748)
			p.Match(Cobol85ParserLIMIT)
		}
		p.SetState(2750)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserIS {
			{
				p.SetState(2749)
				p.Match(Cobol85ParserIS)
			}

		}

	case Cobol85ParserLIMITS:
		{
			p.SetState(2752)
			p.Match(Cobol85ParserLIMITS)
		}
		p.SetState(2754)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserARE {
			{
				p.SetState(2753)
				p.Match(Cobol85ParserARE)
			}

		}

	case Cobol85ParserLEVEL_NUMBER_66, Cobol85ParserLEVEL_NUMBER_77, Cobol85ParserLEVEL_NUMBER_88, Cobol85ParserINTEGERLITERAL:

	default:
	}
	{
		p.SetState(2758)
		p.IntegerLiteral()
	}
	p.SetState(2760)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserLINE || _la == Cobol85ParserLINES {
		{
			p.SetState(2759)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85ParserLINE || _la == Cobol85ParserLINES) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

	return localctx
}

// IReportDescriptionHeadingClauseContext is an interface to support dynamic dispatch.
type IReportDescriptionHeadingClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportDescriptionHeadingClauseContext differentiates from other interfaces.
	IsReportDescriptionHeadingClauseContext()
}

type ReportDescriptionHeadingClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportDescriptionHeadingClauseContext() *ReportDescriptionHeadingClauseContext {
	var p = new(ReportDescriptionHeadingClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportDescriptionHeadingClause
	return p
}

func (*ReportDescriptionHeadingClauseContext) IsReportDescriptionHeadingClauseContext() {}

func NewReportDescriptionHeadingClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportDescriptionHeadingClauseContext {
	var p = new(ReportDescriptionHeadingClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportDescriptionHeadingClause

	return p
}

func (s *ReportDescriptionHeadingClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportDescriptionHeadingClauseContext) HEADING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserHEADING, 0)
}

func (s *ReportDescriptionHeadingClauseContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ReportDescriptionHeadingClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportDescriptionHeadingClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportDescriptionHeadingClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportDescriptionHeadingClause(s)
	}
}

func (s *ReportDescriptionHeadingClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportDescriptionHeadingClause(s)
	}
}

func (p *Cobol85Parser) ReportDescriptionHeadingClause() (localctx IReportDescriptionHeadingClauseContext) {
	localctx = NewReportDescriptionHeadingClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 330, Cobol85ParserRULE_reportDescriptionHeadingClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2762)
		p.Match(Cobol85ParserHEADING)
	}
	{
		p.SetState(2763)
		p.IntegerLiteral()
	}

	return localctx
}

// IReportDescriptionFirstDetailClauseContext is an interface to support dynamic dispatch.
type IReportDescriptionFirstDetailClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportDescriptionFirstDetailClauseContext differentiates from other interfaces.
	IsReportDescriptionFirstDetailClauseContext()
}

type ReportDescriptionFirstDetailClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportDescriptionFirstDetailClauseContext() *ReportDescriptionFirstDetailClauseContext {
	var p = new(ReportDescriptionFirstDetailClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportDescriptionFirstDetailClause
	return p
}

func (*ReportDescriptionFirstDetailClauseContext) IsReportDescriptionFirstDetailClauseContext() {}

func NewReportDescriptionFirstDetailClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportDescriptionFirstDetailClauseContext {
	var p = new(ReportDescriptionFirstDetailClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportDescriptionFirstDetailClause

	return p
}

func (s *ReportDescriptionFirstDetailClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportDescriptionFirstDetailClauseContext) FIRST() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFIRST, 0)
}

func (s *ReportDescriptionFirstDetailClauseContext) DETAIL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDETAIL, 0)
}

func (s *ReportDescriptionFirstDetailClauseContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ReportDescriptionFirstDetailClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportDescriptionFirstDetailClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportDescriptionFirstDetailClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportDescriptionFirstDetailClause(s)
	}
}

func (s *ReportDescriptionFirstDetailClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportDescriptionFirstDetailClause(s)
	}
}

func (p *Cobol85Parser) ReportDescriptionFirstDetailClause() (localctx IReportDescriptionFirstDetailClauseContext) {
	localctx = NewReportDescriptionFirstDetailClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 332, Cobol85ParserRULE_reportDescriptionFirstDetailClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2765)
		p.Match(Cobol85ParserFIRST)
	}
	{
		p.SetState(2766)
		p.Match(Cobol85ParserDETAIL)
	}
	{
		p.SetState(2767)
		p.IntegerLiteral()
	}

	return localctx
}

// IReportDescriptionLastDetailClauseContext is an interface to support dynamic dispatch.
type IReportDescriptionLastDetailClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportDescriptionLastDetailClauseContext differentiates from other interfaces.
	IsReportDescriptionLastDetailClauseContext()
}

type ReportDescriptionLastDetailClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportDescriptionLastDetailClauseContext() *ReportDescriptionLastDetailClauseContext {
	var p = new(ReportDescriptionLastDetailClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportDescriptionLastDetailClause
	return p
}

func (*ReportDescriptionLastDetailClauseContext) IsReportDescriptionLastDetailClauseContext() {}

func NewReportDescriptionLastDetailClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportDescriptionLastDetailClauseContext {
	var p = new(ReportDescriptionLastDetailClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportDescriptionLastDetailClause

	return p
}

func (s *ReportDescriptionLastDetailClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportDescriptionLastDetailClauseContext) LAST() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLAST, 0)
}

func (s *ReportDescriptionLastDetailClauseContext) DETAIL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDETAIL, 0)
}

func (s *ReportDescriptionLastDetailClauseContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ReportDescriptionLastDetailClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportDescriptionLastDetailClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportDescriptionLastDetailClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportDescriptionLastDetailClause(s)
	}
}

func (s *ReportDescriptionLastDetailClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportDescriptionLastDetailClause(s)
	}
}

func (p *Cobol85Parser) ReportDescriptionLastDetailClause() (localctx IReportDescriptionLastDetailClauseContext) {
	localctx = NewReportDescriptionLastDetailClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 334, Cobol85ParserRULE_reportDescriptionLastDetailClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2769)
		p.Match(Cobol85ParserLAST)
	}
	{
		p.SetState(2770)
		p.Match(Cobol85ParserDETAIL)
	}
	{
		p.SetState(2771)
		p.IntegerLiteral()
	}

	return localctx
}

// IReportDescriptionFootingClauseContext is an interface to support dynamic dispatch.
type IReportDescriptionFootingClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportDescriptionFootingClauseContext differentiates from other interfaces.
	IsReportDescriptionFootingClauseContext()
}

type ReportDescriptionFootingClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportDescriptionFootingClauseContext() *ReportDescriptionFootingClauseContext {
	var p = new(ReportDescriptionFootingClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportDescriptionFootingClause
	return p
}

func (*ReportDescriptionFootingClauseContext) IsReportDescriptionFootingClauseContext() {}

func NewReportDescriptionFootingClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportDescriptionFootingClauseContext {
	var p = new(ReportDescriptionFootingClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportDescriptionFootingClause

	return p
}

func (s *ReportDescriptionFootingClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportDescriptionFootingClauseContext) FOOTING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOOTING, 0)
}

func (s *ReportDescriptionFootingClauseContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ReportDescriptionFootingClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportDescriptionFootingClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportDescriptionFootingClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportDescriptionFootingClause(s)
	}
}

func (s *ReportDescriptionFootingClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportDescriptionFootingClause(s)
	}
}

func (p *Cobol85Parser) ReportDescriptionFootingClause() (localctx IReportDescriptionFootingClauseContext) {
	localctx = NewReportDescriptionFootingClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 336, Cobol85ParserRULE_reportDescriptionFootingClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2773)
		p.Match(Cobol85ParserFOOTING)
	}
	{
		p.SetState(2774)
		p.IntegerLiteral()
	}

	return localctx
}

// IReportGroupDescriptionEntryContext is an interface to support dynamic dispatch.
type IReportGroupDescriptionEntryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupDescriptionEntryContext differentiates from other interfaces.
	IsReportGroupDescriptionEntryContext()
}

type ReportGroupDescriptionEntryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupDescriptionEntryContext() *ReportGroupDescriptionEntryContext {
	var p = new(ReportGroupDescriptionEntryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupDescriptionEntry
	return p
}

func (*ReportGroupDescriptionEntryContext) IsReportGroupDescriptionEntryContext() {}

func NewReportGroupDescriptionEntryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupDescriptionEntryContext {
	var p = new(ReportGroupDescriptionEntryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupDescriptionEntry

	return p
}

func (s *ReportGroupDescriptionEntryContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupDescriptionEntryContext) ReportGroupDescriptionEntryFormat1() IReportGroupDescriptionEntryFormat1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportGroupDescriptionEntryFormat1Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReportGroupDescriptionEntryFormat1Context)
}

func (s *ReportGroupDescriptionEntryContext) ReportGroupDescriptionEntryFormat2() IReportGroupDescriptionEntryFormat2Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportGroupDescriptionEntryFormat2Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReportGroupDescriptionEntryFormat2Context)
}

func (s *ReportGroupDescriptionEntryContext) ReportGroupDescriptionEntryFormat3() IReportGroupDescriptionEntryFormat3Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportGroupDescriptionEntryFormat3Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReportGroupDescriptionEntryFormat3Context)
}

func (s *ReportGroupDescriptionEntryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupDescriptionEntryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupDescriptionEntryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupDescriptionEntry(s)
	}
}

func (s *ReportGroupDescriptionEntryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupDescriptionEntry(s)
	}
}

func (p *Cobol85Parser) ReportGroupDescriptionEntry() (localctx IReportGroupDescriptionEntryContext) {
	localctx = NewReportGroupDescriptionEntryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 338, Cobol85ParserRULE_reportGroupDescriptionEntry)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2779)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 314, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2776)
			p.ReportGroupDescriptionEntryFormat1()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2777)
			p.ReportGroupDescriptionEntryFormat2()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2778)
			p.ReportGroupDescriptionEntryFormat3()
		}

	}

	return localctx
}

// IReportGroupDescriptionEntryFormat1Context is an interface to support dynamic dispatch.
type IReportGroupDescriptionEntryFormat1Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupDescriptionEntryFormat1Context differentiates from other interfaces.
	IsReportGroupDescriptionEntryFormat1Context()
}

type ReportGroupDescriptionEntryFormat1Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupDescriptionEntryFormat1Context() *ReportGroupDescriptionEntryFormat1Context {
	var p = new(ReportGroupDescriptionEntryFormat1Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupDescriptionEntryFormat1
	return p
}

func (*ReportGroupDescriptionEntryFormat1Context) IsReportGroupDescriptionEntryFormat1Context() {}

func NewReportGroupDescriptionEntryFormat1Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupDescriptionEntryFormat1Context {
	var p = new(ReportGroupDescriptionEntryFormat1Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupDescriptionEntryFormat1

	return p
}

func (s *ReportGroupDescriptionEntryFormat1Context) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupDescriptionEntryFormat1Context) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ReportGroupDescriptionEntryFormat1Context) DataName() IDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *ReportGroupDescriptionEntryFormat1Context) ReportGroupTypeClause() IReportGroupTypeClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportGroupTypeClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReportGroupTypeClauseContext)
}

func (s *ReportGroupDescriptionEntryFormat1Context) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *ReportGroupDescriptionEntryFormat1Context) ReportGroupLineNumberClause() IReportGroupLineNumberClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportGroupLineNumberClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReportGroupLineNumberClauseContext)
}

func (s *ReportGroupDescriptionEntryFormat1Context) ReportGroupNextGroupClause() IReportGroupNextGroupClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportGroupNextGroupClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReportGroupNextGroupClauseContext)
}

func (s *ReportGroupDescriptionEntryFormat1Context) ReportGroupUsageClause() IReportGroupUsageClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportGroupUsageClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReportGroupUsageClauseContext)
}

func (s *ReportGroupDescriptionEntryFormat1Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupDescriptionEntryFormat1Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupDescriptionEntryFormat1Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupDescriptionEntryFormat1(s)
	}
}

func (s *ReportGroupDescriptionEntryFormat1Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupDescriptionEntryFormat1(s)
	}
}

func (p *Cobol85Parser) ReportGroupDescriptionEntryFormat1() (localctx IReportGroupDescriptionEntryFormat1Context) {
	localctx = NewReportGroupDescriptionEntryFormat1Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 340, Cobol85ParserRULE_reportGroupDescriptionEntryFormat1)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2781)
		p.IntegerLiteral()
	}
	{
		p.SetState(2782)
		p.DataName()
	}
	p.SetState(2784)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS || _la == Cobol85ParserLINE || _la == Cobol85ParserNUMBER || _la == Cobol85ParserPLUS || (((_la-552)&-(0x1f+1)) == 0 && ((1<<uint((_la-552)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-552))|(1<<(Cobol85ParserLEVEL_NUMBER_77-552))|(1<<(Cobol85ParserLEVEL_NUMBER_88-552))|(1<<(Cobol85ParserINTEGERLITERAL-552)))) != 0) {
		{
			p.SetState(2783)
			p.ReportGroupLineNumberClause()
		}

	}
	p.SetState(2787)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserNEXT {
		{
			p.SetState(2786)
			p.ReportGroupNextGroupClause()
		}

	}
	{
		p.SetState(2789)
		p.ReportGroupTypeClause()
	}
	p.SetState(2791)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserDISPLAY || _la == Cobol85ParserDISPLAY_1 || _la == Cobol85ParserUSAGE {
		{
			p.SetState(2790)
			p.ReportGroupUsageClause()
		}

	}
	{
		p.SetState(2793)
		p.Match(Cobol85ParserDOT_FS)
	}

	return localctx
}

// IReportGroupDescriptionEntryFormat2Context is an interface to support dynamic dispatch.
type IReportGroupDescriptionEntryFormat2Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupDescriptionEntryFormat2Context differentiates from other interfaces.
	IsReportGroupDescriptionEntryFormat2Context()
}

type ReportGroupDescriptionEntryFormat2Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupDescriptionEntryFormat2Context() *ReportGroupDescriptionEntryFormat2Context {
	var p = new(ReportGroupDescriptionEntryFormat2Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupDescriptionEntryFormat2
	return p
}

func (*ReportGroupDescriptionEntryFormat2Context) IsReportGroupDescriptionEntryFormat2Context() {}

func NewReportGroupDescriptionEntryFormat2Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupDescriptionEntryFormat2Context {
	var p = new(ReportGroupDescriptionEntryFormat2Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupDescriptionEntryFormat2

	return p
}

func (s *ReportGroupDescriptionEntryFormat2Context) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupDescriptionEntryFormat2Context) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ReportGroupDescriptionEntryFormat2Context) ReportGroupUsageClause() IReportGroupUsageClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportGroupUsageClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReportGroupUsageClauseContext)
}

func (s *ReportGroupDescriptionEntryFormat2Context) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *ReportGroupDescriptionEntryFormat2Context) DataName() IDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *ReportGroupDescriptionEntryFormat2Context) ReportGroupLineNumberClause() IReportGroupLineNumberClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportGroupLineNumberClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReportGroupLineNumberClauseContext)
}

func (s *ReportGroupDescriptionEntryFormat2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupDescriptionEntryFormat2Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupDescriptionEntryFormat2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupDescriptionEntryFormat2(s)
	}
}

func (s *ReportGroupDescriptionEntryFormat2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupDescriptionEntryFormat2(s)
	}
}

func (p *Cobol85Parser) ReportGroupDescriptionEntryFormat2() (localctx IReportGroupDescriptionEntryFormat2Context) {
	localctx = NewReportGroupDescriptionEntryFormat2Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 342, Cobol85ParserRULE_reportGroupDescriptionEntryFormat2)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2795)
		p.IntegerLiteral()
	}
	p.SetState(2797)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH)|(1<<Cobol85ParserATTRIBUTE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBINARY-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-68))|(1<<(Cobol85ParserCOBOL-68))|(1<<(Cobol85ParserCOMMITMENT-68))|(1<<(Cobol85ParserCONTROL_POINT-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(Cobol85ParserCONVENTION-100))|(1<<(Cobol85ParserCRUNCH-100))|(1<<(Cobol85ParserCURSOR-100))|(1<<(Cobol85ParserDEFAULT-100))|(1<<(Cobol85ParserDEFAULT_DISPLAY-100))|(1<<(Cobol85ParserDEFINITION-100)))) != 0) || (((_la-138)&-(0x1f+1)) == 0 && ((1<<uint((_la-138)))&((1<<(Cobol85ParserDFHRESP-138))|(1<<(Cobol85ParserDFHVALUE-138))|(1<<(Cobol85ParserDISK-138))|(1<<(Cobol85ParserDONTCARE-138))|(1<<(Cobol85ParserDOUBLE-138))|(1<<(Cobol85ParserEBCDIC-138))|(1<<(Cobol85ParserEMPTY_CHECK-138)))) != 0) || (((_la-181)&-(0x1f+1)) == 0 && ((1<<uint((_la-181)))&((1<<(Cobol85ParserENTER-181))|(1<<(Cobol85ParserENTRY_PROCEDURE-181))|(1<<(Cobol85ParserERASE-181))|(1<<(Cobol85ParserEOL-181))|(1<<(Cobol85ParserEOS-181))|(1<<(Cobol85ParserESCAPE-181))|(1<<(Cobol85ParserEVENT-181))|(1<<(Cobol85ParserEXCLUSIVE-181))|(1<<(Cobol85ParserEXPORT-181))|(1<<(Cobol85ParserEXTENDED-181)))) != 0) || (((_la-213)&-(0x1f+1)) == 0 && ((1<<uint((_la-213)))&((1<<(Cobol85ParserFOREGROUND_COLOR-213))|(1<<(Cobol85ParserFOREGROUND_COLOUR-213))|(1<<(Cobol85ParserFULL-213))|(1<<(Cobol85ParserFUNCTIONNAME-213))|(1<<(Cobol85ParserFUNCTION_POINTER-213))|(1<<(Cobol85ParserGRID-213))|(1<<(Cobol85ParserHIGHLIGHT-213))|(1<<(Cobol85ParserIMPLICIT-213))|(1<<(Cobol85ParserIMPORT-213)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(Cobol85ParserINTEGER-250))|(1<<(Cobol85ParserKEPT-250))|(1<<(Cobol85ParserKEYBOARD-250))|(1<<(Cobol85ParserLANGUAGE-250))|(1<<(Cobol85ParserLB-250))|(1<<(Cobol85ParserLD-250))|(1<<(Cobol85ParserLEFTLINE-250))|(1<<(Cobol85ParserLENGTH_CHECK-250))|(1<<(Cobol85ParserLIBACCESS-250))|(1<<(Cobol85ParserLIBPARAMETER-250))|(1<<(Cobol85ParserLIBRARY-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(Cobol85ParserLIST-283))|(1<<(Cobol85ParserLOCAL-283))|(1<<(Cobol85ParserLONG_DATE-283))|(1<<(Cobol85ParserLONG_TIME-283))|(1<<(Cobol85ParserLOWER-283))|(1<<(Cobol85ParserLOWLIGHT-283))|(1<<(Cobol85ParserMMDDYYYY-283))|(1<<(Cobol85ParserNAMED-283))|(1<<(Cobol85ParserNATIONAL-283))|(1<<(Cobol85ParserNATIONAL_EDITED-283))|(1<<(Cobol85ParserNETWORK-283))|(1<<(Cobol85ParserNO_ECHO-283)))) != 0) || (((_la-317)&-(0x1f+1)) == 0 && ((1<<uint((_la-317)))&((1<<(Cobol85ParserNUMERIC_DATE-317))|(1<<(Cobol85ParserNUMERIC_TIME-317))|(1<<(Cobol85ParserODT-317))|(1<<(Cobol85ParserORDERLY-317))|(1<<(Cobol85ParserOVERLINE-317))|(1<<(Cobol85ParserOWN-317))|(1<<(Cobol85ParserPASSWORD-317)))) != 0) || (((_la-352)&-(0x1f+1)) == 0 && ((1<<uint((_la-352)))&((1<<(Cobol85ParserPORT-352))|(1<<(Cobol85ParserPRINTER-352))|(1<<(Cobol85ParserPRIVATE-352))|(1<<(Cobol85ParserPROCESS-352))|(1<<(Cobol85ParserPROGRAM-352))|(1<<(Cobol85ParserPROMPT-352))|(1<<(Cobol85ParserREADER-352))|(1<<(Cobol85ParserREMOTE-352))|(1<<(Cobol85ParserREAL-352))|(1<<(Cobol85ParserRECEIVED-352))|(1<<(Cobol85ParserRECURSIVE-352))|(1<<(Cobol85ParserREF-352)))) != 0) || (((_la-391)&-(0x1f+1)) == 0 && ((1<<uint((_la-391)))&((1<<(Cobol85ParserREMOVE-391))|(1<<(Cobol85ParserREQUIRED-391))|(1<<(Cobol85ParserREVERSE_VIDEO-391))|(1<<(Cobol85ParserSAVE-391))|(1<<(Cobol85ParserSECURE-391)))) != 0) || (((_la-431)&-(0x1f+1)) == 0 && ((1<<uint((_la-431)))&((1<<(Cobol85ParserSHARED-431))|(1<<(Cobol85ParserSHAREDBYALL-431))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-431))|(1<<(Cobol85ParserSHARING-431))|(1<<(Cobol85ParserSHORT_DATE-431)))) != 0) || (((_la-466)&-(0x1f+1)) == 0 && ((1<<uint((_la-466)))&((1<<(Cobol85ParserSYMBOL-466))|(1<<(Cobol85ParserTASK-466))|(1<<(Cobol85ParserTHREAD-466))|(1<<(Cobol85ParserTHREAD_LOCAL-466))|(1<<(Cobol85ParserTIMER-466))|(1<<(Cobol85ParserTODAYS_DATE-466))|(1<<(Cobol85ParserTODAYS_NAME-466))|(1<<(Cobol85ParserTRUNCATED-466))|(1<<(Cobol85ParserTYPEDEF-466)))) != 0) || (((_la-498)&-(0x1f+1)) == 0 && ((1<<uint((_la-498)))&((1<<(Cobol85ParserUNDERLINE-498))|(1<<(Cobol85ParserVIRTUAL-498))|(1<<(Cobol85ParserWAIT-498))|(1<<(Cobol85ParserYEAR-498))|(1<<(Cobol85ParserYYYYMMDD-498))|(1<<(Cobol85ParserYYYYDDD-498))|(1<<(Cobol85ParserZERO_FILL-498)))) != 0) || _la == Cobol85ParserIDENTIFIER {
		{
			p.SetState(2796)
			p.DataName()
		}

	}
	p.SetState(2800)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS || _la == Cobol85ParserLINE || _la == Cobol85ParserNUMBER || _la == Cobol85ParserPLUS || (((_la-552)&-(0x1f+1)) == 0 && ((1<<uint((_la-552)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-552))|(1<<(Cobol85ParserLEVEL_NUMBER_77-552))|(1<<(Cobol85ParserLEVEL_NUMBER_88-552))|(1<<(Cobol85ParserINTEGERLITERAL-552)))) != 0) {
		{
			p.SetState(2799)
			p.ReportGroupLineNumberClause()
		}

	}
	{
		p.SetState(2802)
		p.ReportGroupUsageClause()
	}
	{
		p.SetState(2803)
		p.Match(Cobol85ParserDOT_FS)
	}

	return localctx
}

// IReportGroupDescriptionEntryFormat3Context is an interface to support dynamic dispatch.
type IReportGroupDescriptionEntryFormat3Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupDescriptionEntryFormat3Context differentiates from other interfaces.
	IsReportGroupDescriptionEntryFormat3Context()
}

type ReportGroupDescriptionEntryFormat3Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupDescriptionEntryFormat3Context() *ReportGroupDescriptionEntryFormat3Context {
	var p = new(ReportGroupDescriptionEntryFormat3Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupDescriptionEntryFormat3
	return p
}

func (*ReportGroupDescriptionEntryFormat3Context) IsReportGroupDescriptionEntryFormat3Context() {}

func NewReportGroupDescriptionEntryFormat3Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupDescriptionEntryFormat3Context {
	var p = new(ReportGroupDescriptionEntryFormat3Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupDescriptionEntryFormat3

	return p
}

func (s *ReportGroupDescriptionEntryFormat3Context) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupDescriptionEntryFormat3Context) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ReportGroupDescriptionEntryFormat3Context) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *ReportGroupDescriptionEntryFormat3Context) DataName() IDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *ReportGroupDescriptionEntryFormat3Context) AllReportGroupPictureClause() []IReportGroupPictureClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IReportGroupPictureClauseContext)(nil)).Elem())
	var tst = make([]IReportGroupPictureClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IReportGroupPictureClauseContext)
		}
	}

	return tst
}

func (s *ReportGroupDescriptionEntryFormat3Context) ReportGroupPictureClause(i int) IReportGroupPictureClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportGroupPictureClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IReportGroupPictureClauseContext)
}

func (s *ReportGroupDescriptionEntryFormat3Context) AllReportGroupUsageClause() []IReportGroupUsageClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IReportGroupUsageClauseContext)(nil)).Elem())
	var tst = make([]IReportGroupUsageClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IReportGroupUsageClauseContext)
		}
	}

	return tst
}

func (s *ReportGroupDescriptionEntryFormat3Context) ReportGroupUsageClause(i int) IReportGroupUsageClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportGroupUsageClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IReportGroupUsageClauseContext)
}

func (s *ReportGroupDescriptionEntryFormat3Context) AllReportGroupSignClause() []IReportGroupSignClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IReportGroupSignClauseContext)(nil)).Elem())
	var tst = make([]IReportGroupSignClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IReportGroupSignClauseContext)
		}
	}

	return tst
}

func (s *ReportGroupDescriptionEntryFormat3Context) ReportGroupSignClause(i int) IReportGroupSignClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportGroupSignClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IReportGroupSignClauseContext)
}

func (s *ReportGroupDescriptionEntryFormat3Context) AllReportGroupJustifiedClause() []IReportGroupJustifiedClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IReportGroupJustifiedClauseContext)(nil)).Elem())
	var tst = make([]IReportGroupJustifiedClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IReportGroupJustifiedClauseContext)
		}
	}

	return tst
}

func (s *ReportGroupDescriptionEntryFormat3Context) ReportGroupJustifiedClause(i int) IReportGroupJustifiedClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportGroupJustifiedClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IReportGroupJustifiedClauseContext)
}

func (s *ReportGroupDescriptionEntryFormat3Context) AllReportGroupBlankWhenZeroClause() []IReportGroupBlankWhenZeroClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IReportGroupBlankWhenZeroClauseContext)(nil)).Elem())
	var tst = make([]IReportGroupBlankWhenZeroClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IReportGroupBlankWhenZeroClauseContext)
		}
	}

	return tst
}

func (s *ReportGroupDescriptionEntryFormat3Context) ReportGroupBlankWhenZeroClause(i int) IReportGroupBlankWhenZeroClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportGroupBlankWhenZeroClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IReportGroupBlankWhenZeroClauseContext)
}

func (s *ReportGroupDescriptionEntryFormat3Context) AllReportGroupLineNumberClause() []IReportGroupLineNumberClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IReportGroupLineNumberClauseContext)(nil)).Elem())
	var tst = make([]IReportGroupLineNumberClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IReportGroupLineNumberClauseContext)
		}
	}

	return tst
}

func (s *ReportGroupDescriptionEntryFormat3Context) ReportGroupLineNumberClause(i int) IReportGroupLineNumberClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportGroupLineNumberClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IReportGroupLineNumberClauseContext)
}

func (s *ReportGroupDescriptionEntryFormat3Context) AllReportGroupColumnNumberClause() []IReportGroupColumnNumberClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IReportGroupColumnNumberClauseContext)(nil)).Elem())
	var tst = make([]IReportGroupColumnNumberClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IReportGroupColumnNumberClauseContext)
		}
	}

	return tst
}

func (s *ReportGroupDescriptionEntryFormat3Context) ReportGroupColumnNumberClause(i int) IReportGroupColumnNumberClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportGroupColumnNumberClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IReportGroupColumnNumberClauseContext)
}

func (s *ReportGroupDescriptionEntryFormat3Context) AllReportGroupIndicateClause() []IReportGroupIndicateClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IReportGroupIndicateClauseContext)(nil)).Elem())
	var tst = make([]IReportGroupIndicateClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IReportGroupIndicateClauseContext)
		}
	}

	return tst
}

func (s *ReportGroupDescriptionEntryFormat3Context) ReportGroupIndicateClause(i int) IReportGroupIndicateClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportGroupIndicateClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IReportGroupIndicateClauseContext)
}

func (s *ReportGroupDescriptionEntryFormat3Context) AllReportGroupSourceClause() []IReportGroupSourceClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IReportGroupSourceClauseContext)(nil)).Elem())
	var tst = make([]IReportGroupSourceClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IReportGroupSourceClauseContext)
		}
	}

	return tst
}

func (s *ReportGroupDescriptionEntryFormat3Context) ReportGroupSourceClause(i int) IReportGroupSourceClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportGroupSourceClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IReportGroupSourceClauseContext)
}

func (s *ReportGroupDescriptionEntryFormat3Context) AllReportGroupValueClause() []IReportGroupValueClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IReportGroupValueClauseContext)(nil)).Elem())
	var tst = make([]IReportGroupValueClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IReportGroupValueClauseContext)
		}
	}

	return tst
}

func (s *ReportGroupDescriptionEntryFormat3Context) ReportGroupValueClause(i int) IReportGroupValueClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportGroupValueClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IReportGroupValueClauseContext)
}

func (s *ReportGroupDescriptionEntryFormat3Context) AllReportGroupSumClause() []IReportGroupSumClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IReportGroupSumClauseContext)(nil)).Elem())
	var tst = make([]IReportGroupSumClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IReportGroupSumClauseContext)
		}
	}

	return tst
}

func (s *ReportGroupDescriptionEntryFormat3Context) ReportGroupSumClause(i int) IReportGroupSumClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportGroupSumClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IReportGroupSumClauseContext)
}

func (s *ReportGroupDescriptionEntryFormat3Context) AllReportGroupResetClause() []IReportGroupResetClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IReportGroupResetClauseContext)(nil)).Elem())
	var tst = make([]IReportGroupResetClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IReportGroupResetClauseContext)
		}
	}

	return tst
}

func (s *ReportGroupDescriptionEntryFormat3Context) ReportGroupResetClause(i int) IReportGroupResetClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportGroupResetClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IReportGroupResetClauseContext)
}

func (s *ReportGroupDescriptionEntryFormat3Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupDescriptionEntryFormat3Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupDescriptionEntryFormat3Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupDescriptionEntryFormat3(s)
	}
}

func (s *ReportGroupDescriptionEntryFormat3Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupDescriptionEntryFormat3(s)
	}
}

func (p *Cobol85Parser) ReportGroupDescriptionEntryFormat3() (localctx IReportGroupDescriptionEntryFormat3Context) {
	localctx = NewReportGroupDescriptionEntryFormat3Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 344, Cobol85ParserRULE_reportGroupDescriptionEntryFormat3)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2805)
		p.IntegerLiteral()
	}
	p.SetState(2807)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH)|(1<<Cobol85ParserATTRIBUTE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBINARY-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-68))|(1<<(Cobol85ParserCOBOL-68))|(1<<(Cobol85ParserCOMMITMENT-68))|(1<<(Cobol85ParserCONTROL_POINT-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(Cobol85ParserCONVENTION-100))|(1<<(Cobol85ParserCRUNCH-100))|(1<<(Cobol85ParserCURSOR-100))|(1<<(Cobol85ParserDEFAULT-100))|(1<<(Cobol85ParserDEFAULT_DISPLAY-100))|(1<<(Cobol85ParserDEFINITION-100)))) != 0) || (((_la-138)&-(0x1f+1)) == 0 && ((1<<uint((_la-138)))&((1<<(Cobol85ParserDFHRESP-138))|(1<<(Cobol85ParserDFHVALUE-138))|(1<<(Cobol85ParserDISK-138))|(1<<(Cobol85ParserDONTCARE-138))|(1<<(Cobol85ParserDOUBLE-138))|(1<<(Cobol85ParserEBCDIC-138))|(1<<(Cobol85ParserEMPTY_CHECK-138)))) != 0) || (((_la-181)&-(0x1f+1)) == 0 && ((1<<uint((_la-181)))&((1<<(Cobol85ParserENTER-181))|(1<<(Cobol85ParserENTRY_PROCEDURE-181))|(1<<(Cobol85ParserERASE-181))|(1<<(Cobol85ParserEOL-181))|(1<<(Cobol85ParserEOS-181))|(1<<(Cobol85ParserESCAPE-181))|(1<<(Cobol85ParserEVENT-181))|(1<<(Cobol85ParserEXCLUSIVE-181))|(1<<(Cobol85ParserEXPORT-181))|(1<<(Cobol85ParserEXTENDED-181)))) != 0) || (((_la-213)&-(0x1f+1)) == 0 && ((1<<uint((_la-213)))&((1<<(Cobol85ParserFOREGROUND_COLOR-213))|(1<<(Cobol85ParserFOREGROUND_COLOUR-213))|(1<<(Cobol85ParserFULL-213))|(1<<(Cobol85ParserFUNCTIONNAME-213))|(1<<(Cobol85ParserFUNCTION_POINTER-213))|(1<<(Cobol85ParserGRID-213))|(1<<(Cobol85ParserHIGHLIGHT-213))|(1<<(Cobol85ParserIMPLICIT-213))|(1<<(Cobol85ParserIMPORT-213)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(Cobol85ParserINTEGER-250))|(1<<(Cobol85ParserKEPT-250))|(1<<(Cobol85ParserKEYBOARD-250))|(1<<(Cobol85ParserLANGUAGE-250))|(1<<(Cobol85ParserLB-250))|(1<<(Cobol85ParserLD-250))|(1<<(Cobol85ParserLEFTLINE-250))|(1<<(Cobol85ParserLENGTH_CHECK-250))|(1<<(Cobol85ParserLIBACCESS-250))|(1<<(Cobol85ParserLIBPARAMETER-250))|(1<<(Cobol85ParserLIBRARY-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(Cobol85ParserLIST-283))|(1<<(Cobol85ParserLOCAL-283))|(1<<(Cobol85ParserLONG_DATE-283))|(1<<(Cobol85ParserLONG_TIME-283))|(1<<(Cobol85ParserLOWER-283))|(1<<(Cobol85ParserLOWLIGHT-283))|(1<<(Cobol85ParserMMDDYYYY-283))|(1<<(Cobol85ParserNAMED-283))|(1<<(Cobol85ParserNATIONAL-283))|(1<<(Cobol85ParserNATIONAL_EDITED-283))|(1<<(Cobol85ParserNETWORK-283))|(1<<(Cobol85ParserNO_ECHO-283)))) != 0) || (((_la-317)&-(0x1f+1)) == 0 && ((1<<uint((_la-317)))&((1<<(Cobol85ParserNUMERIC_DATE-317))|(1<<(Cobol85ParserNUMERIC_TIME-317))|(1<<(Cobol85ParserODT-317))|(1<<(Cobol85ParserORDERLY-317))|(1<<(Cobol85ParserOVERLINE-317))|(1<<(Cobol85ParserOWN-317))|(1<<(Cobol85ParserPASSWORD-317)))) != 0) || (((_la-352)&-(0x1f+1)) == 0 && ((1<<uint((_la-352)))&((1<<(Cobol85ParserPORT-352))|(1<<(Cobol85ParserPRINTER-352))|(1<<(Cobol85ParserPRIVATE-352))|(1<<(Cobol85ParserPROCESS-352))|(1<<(Cobol85ParserPROGRAM-352))|(1<<(Cobol85ParserPROMPT-352))|(1<<(Cobol85ParserREADER-352))|(1<<(Cobol85ParserREMOTE-352))|(1<<(Cobol85ParserREAL-352))|(1<<(Cobol85ParserRECEIVED-352))|(1<<(Cobol85ParserRECURSIVE-352))|(1<<(Cobol85ParserREF-352)))) != 0) || (((_la-391)&-(0x1f+1)) == 0 && ((1<<uint((_la-391)))&((1<<(Cobol85ParserREMOVE-391))|(1<<(Cobol85ParserREQUIRED-391))|(1<<(Cobol85ParserREVERSE_VIDEO-391))|(1<<(Cobol85ParserSAVE-391))|(1<<(Cobol85ParserSECURE-391)))) != 0) || (((_la-431)&-(0x1f+1)) == 0 && ((1<<uint((_la-431)))&((1<<(Cobol85ParserSHARED-431))|(1<<(Cobol85ParserSHAREDBYALL-431))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-431))|(1<<(Cobol85ParserSHARING-431))|(1<<(Cobol85ParserSHORT_DATE-431)))) != 0) || (((_la-466)&-(0x1f+1)) == 0 && ((1<<uint((_la-466)))&((1<<(Cobol85ParserSYMBOL-466))|(1<<(Cobol85ParserTASK-466))|(1<<(Cobol85ParserTHREAD-466))|(1<<(Cobol85ParserTHREAD_LOCAL-466))|(1<<(Cobol85ParserTIMER-466))|(1<<(Cobol85ParserTODAYS_DATE-466))|(1<<(Cobol85ParserTODAYS_NAME-466))|(1<<(Cobol85ParserTRUNCATED-466))|(1<<(Cobol85ParserTYPEDEF-466)))) != 0) || (((_la-498)&-(0x1f+1)) == 0 && ((1<<uint((_la-498)))&((1<<(Cobol85ParserUNDERLINE-498))|(1<<(Cobol85ParserVIRTUAL-498))|(1<<(Cobol85ParserWAIT-498))|(1<<(Cobol85ParserYEAR-498))|(1<<(Cobol85ParserYYYYMMDD-498))|(1<<(Cobol85ParserYYYYDDD-498))|(1<<(Cobol85ParserZERO_FILL-498)))) != 0) || _la == Cobol85ParserIDENTIFIER {
		{
			p.SetState(2806)
			p.DataName()
		}

	}
	p.SetState(2825)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserBLANK || _la == Cobol85ParserCOLUMN || _la == Cobol85ParserDISPLAY || _la == Cobol85ParserDISPLAY_1 || (((_la-227)&-(0x1f+1)) == 0 && ((1<<uint((_la-227)))&((1<<(Cobol85ParserGROUP-227))|(1<<(Cobol85ParserIS-227))|(1<<(Cobol85ParserJUST-227))|(1<<(Cobol85ParserJUSTIFIED-227)))) != 0) || _la == Cobol85ParserLINE || _la == Cobol85ParserNUMBER || _la == Cobol85ParserPIC || _la == Cobol85ParserPICTURE || _la == Cobol85ParserPLUS || _la == Cobol85ParserRESET || (((_la-438)&-(0x1f+1)) == 0 && ((1<<uint((_la-438)))&((1<<(Cobol85ParserSIGN-438))|(1<<(Cobol85ParserSOURCE-438))|(1<<(Cobol85ParserSUM-438)))) != 0) || _la == Cobol85ParserUSAGE || _la == Cobol85ParserVALUE || (((_la-552)&-(0x1f+1)) == 0 && ((1<<uint((_la-552)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-552))|(1<<(Cobol85ParserLEVEL_NUMBER_77-552))|(1<<(Cobol85ParserLEVEL_NUMBER_88-552))|(1<<(Cobol85ParserINTEGERLITERAL-552)))) != 0) {
		p.SetState(2823)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case Cobol85ParserPIC, Cobol85ParserPICTURE:
			{
				p.SetState(2809)
				p.ReportGroupPictureClause()
			}

		case Cobol85ParserDISPLAY, Cobol85ParserDISPLAY_1, Cobol85ParserUSAGE:
			{
				p.SetState(2810)
				p.ReportGroupUsageClause()
			}

		case Cobol85ParserSIGN:
			{
				p.SetState(2811)
				p.ReportGroupSignClause()
			}

		case Cobol85ParserJUST, Cobol85ParserJUSTIFIED:
			{
				p.SetState(2812)
				p.ReportGroupJustifiedClause()
			}

		case Cobol85ParserBLANK:
			{
				p.SetState(2813)
				p.ReportGroupBlankWhenZeroClause()
			}

		case Cobol85ParserIS, Cobol85ParserLINE, Cobol85ParserNUMBER, Cobol85ParserPLUS, Cobol85ParserLEVEL_NUMBER_66, Cobol85ParserLEVEL_NUMBER_77, Cobol85ParserLEVEL_NUMBER_88, Cobol85ParserINTEGERLITERAL:
			{
				p.SetState(2814)
				p.ReportGroupLineNumberClause()
			}

		case Cobol85ParserCOLUMN:
			{
				p.SetState(2815)
				p.ReportGroupColumnNumberClause()
			}

		case Cobol85ParserRESET, Cobol85ParserSOURCE, Cobol85ParserSUM, Cobol85ParserVALUE:
			p.SetState(2820)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case Cobol85ParserSOURCE:
				{
					p.SetState(2816)
					p.ReportGroupSourceClause()
				}

			case Cobol85ParserVALUE:
				{
					p.SetState(2817)
					p.ReportGroupValueClause()
				}

			case Cobol85ParserSUM:
				{
					p.SetState(2818)
					p.ReportGroupSumClause()
				}

			case Cobol85ParserRESET:
				{
					p.SetState(2819)
					p.ReportGroupResetClause()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		case Cobol85ParserGROUP:
			{
				p.SetState(2822)
				p.ReportGroupIndicateClause()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(2827)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2828)
		p.Match(Cobol85ParserDOT_FS)
	}

	return localctx
}

// IReportGroupBlankWhenZeroClauseContext is an interface to support dynamic dispatch.
type IReportGroupBlankWhenZeroClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupBlankWhenZeroClauseContext differentiates from other interfaces.
	IsReportGroupBlankWhenZeroClauseContext()
}

type ReportGroupBlankWhenZeroClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupBlankWhenZeroClauseContext() *ReportGroupBlankWhenZeroClauseContext {
	var p = new(ReportGroupBlankWhenZeroClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupBlankWhenZeroClause
	return p
}

func (*ReportGroupBlankWhenZeroClauseContext) IsReportGroupBlankWhenZeroClauseContext() {}

func NewReportGroupBlankWhenZeroClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupBlankWhenZeroClauseContext {
	var p = new(ReportGroupBlankWhenZeroClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupBlankWhenZeroClause

	return p
}

func (s *ReportGroupBlankWhenZeroClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupBlankWhenZeroClauseContext) BLANK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBLANK, 0)
}

func (s *ReportGroupBlankWhenZeroClauseContext) ZERO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserZERO, 0)
}

func (s *ReportGroupBlankWhenZeroClauseContext) WHEN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWHEN, 0)
}

func (s *ReportGroupBlankWhenZeroClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupBlankWhenZeroClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupBlankWhenZeroClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupBlankWhenZeroClause(s)
	}
}

func (s *ReportGroupBlankWhenZeroClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupBlankWhenZeroClause(s)
	}
}

func (p *Cobol85Parser) ReportGroupBlankWhenZeroClause() (localctx IReportGroupBlankWhenZeroClauseContext) {
	localctx = NewReportGroupBlankWhenZeroClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 346, Cobol85ParserRULE_reportGroupBlankWhenZeroClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2830)
		p.Match(Cobol85ParserBLANK)
	}
	p.SetState(2832)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserWHEN {
		{
			p.SetState(2831)
			p.Match(Cobol85ParserWHEN)
		}

	}
	{
		p.SetState(2834)
		p.Match(Cobol85ParserZERO)
	}

	return localctx
}

// IReportGroupColumnNumberClauseContext is an interface to support dynamic dispatch.
type IReportGroupColumnNumberClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupColumnNumberClauseContext differentiates from other interfaces.
	IsReportGroupColumnNumberClauseContext()
}

type ReportGroupColumnNumberClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupColumnNumberClauseContext() *ReportGroupColumnNumberClauseContext {
	var p = new(ReportGroupColumnNumberClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupColumnNumberClause
	return p
}

func (*ReportGroupColumnNumberClauseContext) IsReportGroupColumnNumberClauseContext() {}

func NewReportGroupColumnNumberClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupColumnNumberClauseContext {
	var p = new(ReportGroupColumnNumberClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupColumnNumberClause

	return p
}

func (s *ReportGroupColumnNumberClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupColumnNumberClauseContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOLUMN, 0)
}

func (s *ReportGroupColumnNumberClauseContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ReportGroupColumnNumberClauseContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNUMBER, 0)
}

func (s *ReportGroupColumnNumberClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ReportGroupColumnNumberClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupColumnNumberClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupColumnNumberClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupColumnNumberClause(s)
	}
}

func (s *ReportGroupColumnNumberClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupColumnNumberClause(s)
	}
}

func (p *Cobol85Parser) ReportGroupColumnNumberClause() (localctx IReportGroupColumnNumberClauseContext) {
	localctx = NewReportGroupColumnNumberClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 348, Cobol85ParserRULE_reportGroupColumnNumberClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2836)
		p.Match(Cobol85ParserCOLUMN)
	}
	p.SetState(2838)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserNUMBER {
		{
			p.SetState(2837)
			p.Match(Cobol85ParserNUMBER)
		}

	}
	p.SetState(2841)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2840)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(2843)
		p.IntegerLiteral()
	}

	return localctx
}

// IReportGroupIndicateClauseContext is an interface to support dynamic dispatch.
type IReportGroupIndicateClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupIndicateClauseContext differentiates from other interfaces.
	IsReportGroupIndicateClauseContext()
}

type ReportGroupIndicateClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupIndicateClauseContext() *ReportGroupIndicateClauseContext {
	var p = new(ReportGroupIndicateClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupIndicateClause
	return p
}

func (*ReportGroupIndicateClauseContext) IsReportGroupIndicateClauseContext() {}

func NewReportGroupIndicateClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupIndicateClauseContext {
	var p = new(ReportGroupIndicateClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupIndicateClause

	return p
}

func (s *ReportGroupIndicateClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupIndicateClauseContext) GROUP() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserGROUP, 0)
}

func (s *ReportGroupIndicateClauseContext) INDICATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINDICATE, 0)
}

func (s *ReportGroupIndicateClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupIndicateClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupIndicateClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupIndicateClause(s)
	}
}

func (s *ReportGroupIndicateClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupIndicateClause(s)
	}
}

func (p *Cobol85Parser) ReportGroupIndicateClause() (localctx IReportGroupIndicateClauseContext) {
	localctx = NewReportGroupIndicateClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 350, Cobol85ParserRULE_reportGroupIndicateClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2845)
		p.Match(Cobol85ParserGROUP)
	}
	p.SetState(2847)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserINDICATE {
		{
			p.SetState(2846)
			p.Match(Cobol85ParserINDICATE)
		}

	}

	return localctx
}

// IReportGroupJustifiedClauseContext is an interface to support dynamic dispatch.
type IReportGroupJustifiedClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupJustifiedClauseContext differentiates from other interfaces.
	IsReportGroupJustifiedClauseContext()
}

type ReportGroupJustifiedClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupJustifiedClauseContext() *ReportGroupJustifiedClauseContext {
	var p = new(ReportGroupJustifiedClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupJustifiedClause
	return p
}

func (*ReportGroupJustifiedClauseContext) IsReportGroupJustifiedClauseContext() {}

func NewReportGroupJustifiedClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupJustifiedClauseContext {
	var p = new(ReportGroupJustifiedClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupJustifiedClause

	return p
}

func (s *ReportGroupJustifiedClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupJustifiedClauseContext) JUSTIFIED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserJUSTIFIED, 0)
}

func (s *ReportGroupJustifiedClauseContext) JUST() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserJUST, 0)
}

func (s *ReportGroupJustifiedClauseContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRIGHT, 0)
}

func (s *ReportGroupJustifiedClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupJustifiedClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupJustifiedClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupJustifiedClause(s)
	}
}

func (s *ReportGroupJustifiedClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupJustifiedClause(s)
	}
}

func (p *Cobol85Parser) ReportGroupJustifiedClause() (localctx IReportGroupJustifiedClauseContext) {
	localctx = NewReportGroupJustifiedClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 352, Cobol85ParserRULE_reportGroupJustifiedClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2849)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserJUST || _la == Cobol85ParserJUSTIFIED) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(2851)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserRIGHT {
		{
			p.SetState(2850)
			p.Match(Cobol85ParserRIGHT)
		}

	}

	return localctx
}

// IReportGroupLineNumberClauseContext is an interface to support dynamic dispatch.
type IReportGroupLineNumberClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupLineNumberClauseContext differentiates from other interfaces.
	IsReportGroupLineNumberClauseContext()
}

type ReportGroupLineNumberClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupLineNumberClauseContext() *ReportGroupLineNumberClauseContext {
	var p = new(ReportGroupLineNumberClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupLineNumberClause
	return p
}

func (*ReportGroupLineNumberClauseContext) IsReportGroupLineNumberClauseContext() {}

func NewReportGroupLineNumberClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupLineNumberClauseContext {
	var p = new(ReportGroupLineNumberClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupLineNumberClause

	return p
}

func (s *ReportGroupLineNumberClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupLineNumberClauseContext) ReportGroupLineNumberNextPage() IReportGroupLineNumberNextPageContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportGroupLineNumberNextPageContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReportGroupLineNumberNextPageContext)
}

func (s *ReportGroupLineNumberClauseContext) ReportGroupLineNumberPlus() IReportGroupLineNumberPlusContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportGroupLineNumberPlusContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReportGroupLineNumberPlusContext)
}

func (s *ReportGroupLineNumberClauseContext) LINE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLINE, 0)
}

func (s *ReportGroupLineNumberClauseContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNUMBER, 0)
}

func (s *ReportGroupLineNumberClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ReportGroupLineNumberClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupLineNumberClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupLineNumberClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupLineNumberClause(s)
	}
}

func (s *ReportGroupLineNumberClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupLineNumberClause(s)
	}
}

func (p *Cobol85Parser) ReportGroupLineNumberClause() (localctx IReportGroupLineNumberClauseContext) {
	localctx = NewReportGroupLineNumberClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 354, Cobol85ParserRULE_reportGroupLineNumberClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2854)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserLINE {
		{
			p.SetState(2853)
			p.Match(Cobol85ParserLINE)
		}

	}
	p.SetState(2857)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserNUMBER {
		{
			p.SetState(2856)
			p.Match(Cobol85ParserNUMBER)
		}

	}
	p.SetState(2860)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2859)
			p.Match(Cobol85ParserIS)
		}

	}
	p.SetState(2864)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserLEVEL_NUMBER_66, Cobol85ParserLEVEL_NUMBER_77, Cobol85ParserLEVEL_NUMBER_88, Cobol85ParserINTEGERLITERAL:
		{
			p.SetState(2862)
			p.ReportGroupLineNumberNextPage()
		}

	case Cobol85ParserPLUS:
		{
			p.SetState(2863)
			p.ReportGroupLineNumberPlus()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IReportGroupLineNumberNextPageContext is an interface to support dynamic dispatch.
type IReportGroupLineNumberNextPageContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupLineNumberNextPageContext differentiates from other interfaces.
	IsReportGroupLineNumberNextPageContext()
}

type ReportGroupLineNumberNextPageContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupLineNumberNextPageContext() *ReportGroupLineNumberNextPageContext {
	var p = new(ReportGroupLineNumberNextPageContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupLineNumberNextPage
	return p
}

func (*ReportGroupLineNumberNextPageContext) IsReportGroupLineNumberNextPageContext() {}

func NewReportGroupLineNumberNextPageContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupLineNumberNextPageContext {
	var p = new(ReportGroupLineNumberNextPageContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupLineNumberNextPage

	return p
}

func (s *ReportGroupLineNumberNextPageContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupLineNumberNextPageContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ReportGroupLineNumberNextPageContext) NEXT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNEXT, 0)
}

func (s *ReportGroupLineNumberNextPageContext) PAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPAGE, 0)
}

func (s *ReportGroupLineNumberNextPageContext) ON() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserON, 0)
}

func (s *ReportGroupLineNumberNextPageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupLineNumberNextPageContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupLineNumberNextPageContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupLineNumberNextPage(s)
	}
}

func (s *ReportGroupLineNumberNextPageContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupLineNumberNextPage(s)
	}
}

func (p *Cobol85Parser) ReportGroupLineNumberNextPage() (localctx IReportGroupLineNumberNextPageContext) {
	localctx = NewReportGroupLineNumberNextPageContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 356, Cobol85ParserRULE_reportGroupLineNumberNextPage)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2866)
		p.IntegerLiteral()
	}
	p.SetState(2872)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 334, p.GetParserRuleContext()) == 1 {
		p.SetState(2868)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserON {
			{
				p.SetState(2867)
				p.Match(Cobol85ParserON)
			}

		}
		{
			p.SetState(2870)
			p.Match(Cobol85ParserNEXT)
		}
		{
			p.SetState(2871)
			p.Match(Cobol85ParserPAGE)
		}

	}

	return localctx
}

// IReportGroupLineNumberPlusContext is an interface to support dynamic dispatch.
type IReportGroupLineNumberPlusContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupLineNumberPlusContext differentiates from other interfaces.
	IsReportGroupLineNumberPlusContext()
}

type ReportGroupLineNumberPlusContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupLineNumberPlusContext() *ReportGroupLineNumberPlusContext {
	var p = new(ReportGroupLineNumberPlusContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupLineNumberPlus
	return p
}

func (*ReportGroupLineNumberPlusContext) IsReportGroupLineNumberPlusContext() {}

func NewReportGroupLineNumberPlusContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupLineNumberPlusContext {
	var p = new(ReportGroupLineNumberPlusContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupLineNumberPlus

	return p
}

func (s *ReportGroupLineNumberPlusContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupLineNumberPlusContext) PLUS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPLUS, 0)
}

func (s *ReportGroupLineNumberPlusContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ReportGroupLineNumberPlusContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupLineNumberPlusContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupLineNumberPlusContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupLineNumberPlus(s)
	}
}

func (s *ReportGroupLineNumberPlusContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupLineNumberPlus(s)
	}
}

func (p *Cobol85Parser) ReportGroupLineNumberPlus() (localctx IReportGroupLineNumberPlusContext) {
	localctx = NewReportGroupLineNumberPlusContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 358, Cobol85ParserRULE_reportGroupLineNumberPlus)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2874)
		p.Match(Cobol85ParserPLUS)
	}
	{
		p.SetState(2875)
		p.IntegerLiteral()
	}

	return localctx
}

// IReportGroupNextGroupClauseContext is an interface to support dynamic dispatch.
type IReportGroupNextGroupClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupNextGroupClauseContext differentiates from other interfaces.
	IsReportGroupNextGroupClauseContext()
}

type ReportGroupNextGroupClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupNextGroupClauseContext() *ReportGroupNextGroupClauseContext {
	var p = new(ReportGroupNextGroupClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupNextGroupClause
	return p
}

func (*ReportGroupNextGroupClauseContext) IsReportGroupNextGroupClauseContext() {}

func NewReportGroupNextGroupClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupNextGroupClauseContext {
	var p = new(ReportGroupNextGroupClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupNextGroupClause

	return p
}

func (s *ReportGroupNextGroupClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupNextGroupClauseContext) NEXT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNEXT, 0)
}

func (s *ReportGroupNextGroupClauseContext) GROUP() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserGROUP, 0)
}

func (s *ReportGroupNextGroupClauseContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ReportGroupNextGroupClauseContext) ReportGroupNextGroupNextPage() IReportGroupNextGroupNextPageContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportGroupNextGroupNextPageContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReportGroupNextGroupNextPageContext)
}

func (s *ReportGroupNextGroupClauseContext) ReportGroupNextGroupPlus() IReportGroupNextGroupPlusContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportGroupNextGroupPlusContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReportGroupNextGroupPlusContext)
}

func (s *ReportGroupNextGroupClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ReportGroupNextGroupClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupNextGroupClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupNextGroupClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupNextGroupClause(s)
	}
}

func (s *ReportGroupNextGroupClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupNextGroupClause(s)
	}
}

func (p *Cobol85Parser) ReportGroupNextGroupClause() (localctx IReportGroupNextGroupClauseContext) {
	localctx = NewReportGroupNextGroupClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 360, Cobol85ParserRULE_reportGroupNextGroupClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2877)
		p.Match(Cobol85ParserNEXT)
	}
	{
		p.SetState(2878)
		p.Match(Cobol85ParserGROUP)
	}
	p.SetState(2880)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2879)
			p.Match(Cobol85ParserIS)
		}

	}
	p.SetState(2885)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserLEVEL_NUMBER_66, Cobol85ParserLEVEL_NUMBER_77, Cobol85ParserLEVEL_NUMBER_88, Cobol85ParserINTEGERLITERAL:
		{
			p.SetState(2882)
			p.IntegerLiteral()
		}

	case Cobol85ParserNEXT:
		{
			p.SetState(2883)
			p.ReportGroupNextGroupNextPage()
		}

	case Cobol85ParserPLUS:
		{
			p.SetState(2884)
			p.ReportGroupNextGroupPlus()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IReportGroupNextGroupPlusContext is an interface to support dynamic dispatch.
type IReportGroupNextGroupPlusContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupNextGroupPlusContext differentiates from other interfaces.
	IsReportGroupNextGroupPlusContext()
}

type ReportGroupNextGroupPlusContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupNextGroupPlusContext() *ReportGroupNextGroupPlusContext {
	var p = new(ReportGroupNextGroupPlusContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupNextGroupPlus
	return p
}

func (*ReportGroupNextGroupPlusContext) IsReportGroupNextGroupPlusContext() {}

func NewReportGroupNextGroupPlusContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupNextGroupPlusContext {
	var p = new(ReportGroupNextGroupPlusContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupNextGroupPlus

	return p
}

func (s *ReportGroupNextGroupPlusContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupNextGroupPlusContext) PLUS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPLUS, 0)
}

func (s *ReportGroupNextGroupPlusContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ReportGroupNextGroupPlusContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupNextGroupPlusContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupNextGroupPlusContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupNextGroupPlus(s)
	}
}

func (s *ReportGroupNextGroupPlusContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupNextGroupPlus(s)
	}
}

func (p *Cobol85Parser) ReportGroupNextGroupPlus() (localctx IReportGroupNextGroupPlusContext) {
	localctx = NewReportGroupNextGroupPlusContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 362, Cobol85ParserRULE_reportGroupNextGroupPlus)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2887)
		p.Match(Cobol85ParserPLUS)
	}
	{
		p.SetState(2888)
		p.IntegerLiteral()
	}

	return localctx
}

// IReportGroupNextGroupNextPageContext is an interface to support dynamic dispatch.
type IReportGroupNextGroupNextPageContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupNextGroupNextPageContext differentiates from other interfaces.
	IsReportGroupNextGroupNextPageContext()
}

type ReportGroupNextGroupNextPageContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupNextGroupNextPageContext() *ReportGroupNextGroupNextPageContext {
	var p = new(ReportGroupNextGroupNextPageContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupNextGroupNextPage
	return p
}

func (*ReportGroupNextGroupNextPageContext) IsReportGroupNextGroupNextPageContext() {}

func NewReportGroupNextGroupNextPageContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupNextGroupNextPageContext {
	var p = new(ReportGroupNextGroupNextPageContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupNextGroupNextPage

	return p
}

func (s *ReportGroupNextGroupNextPageContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupNextGroupNextPageContext) NEXT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNEXT, 0)
}

func (s *ReportGroupNextGroupNextPageContext) PAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPAGE, 0)
}

func (s *ReportGroupNextGroupNextPageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupNextGroupNextPageContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupNextGroupNextPageContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupNextGroupNextPage(s)
	}
}

func (s *ReportGroupNextGroupNextPageContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupNextGroupNextPage(s)
	}
}

func (p *Cobol85Parser) ReportGroupNextGroupNextPage() (localctx IReportGroupNextGroupNextPageContext) {
	localctx = NewReportGroupNextGroupNextPageContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 364, Cobol85ParserRULE_reportGroupNextGroupNextPage)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2890)
		p.Match(Cobol85ParserNEXT)
	}
	{
		p.SetState(2891)
		p.Match(Cobol85ParserPAGE)
	}

	return localctx
}

// IReportGroupPictureClauseContext is an interface to support dynamic dispatch.
type IReportGroupPictureClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupPictureClauseContext differentiates from other interfaces.
	IsReportGroupPictureClauseContext()
}

type ReportGroupPictureClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupPictureClauseContext() *ReportGroupPictureClauseContext {
	var p = new(ReportGroupPictureClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupPictureClause
	return p
}

func (*ReportGroupPictureClauseContext) IsReportGroupPictureClauseContext() {}

func NewReportGroupPictureClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupPictureClauseContext {
	var p = new(ReportGroupPictureClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupPictureClause

	return p
}

func (s *ReportGroupPictureClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupPictureClauseContext) PictureString() IPictureStringContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPictureStringContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPictureStringContext)
}

func (s *ReportGroupPictureClauseContext) PICTURE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPICTURE, 0)
}

func (s *ReportGroupPictureClauseContext) PIC() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPIC, 0)
}

func (s *ReportGroupPictureClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ReportGroupPictureClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupPictureClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupPictureClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupPictureClause(s)
	}
}

func (s *ReportGroupPictureClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupPictureClause(s)
	}
}

func (p *Cobol85Parser) ReportGroupPictureClause() (localctx IReportGroupPictureClauseContext) {
	localctx = NewReportGroupPictureClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 366, Cobol85ParserRULE_reportGroupPictureClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2893)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserPIC || _la == Cobol85ParserPICTURE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(2895)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2894)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(2897)
		p.PictureString()
	}

	return localctx
}

// IReportGroupResetClauseContext is an interface to support dynamic dispatch.
type IReportGroupResetClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupResetClauseContext differentiates from other interfaces.
	IsReportGroupResetClauseContext()
}

type ReportGroupResetClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupResetClauseContext() *ReportGroupResetClauseContext {
	var p = new(ReportGroupResetClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupResetClause
	return p
}

func (*ReportGroupResetClauseContext) IsReportGroupResetClauseContext() {}

func NewReportGroupResetClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupResetClauseContext {
	var p = new(ReportGroupResetClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupResetClause

	return p
}

func (s *ReportGroupResetClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupResetClauseContext) RESET() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRESET, 0)
}

func (s *ReportGroupResetClauseContext) FINAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFINAL, 0)
}

func (s *ReportGroupResetClauseContext) DataName() IDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *ReportGroupResetClauseContext) ON() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserON, 0)
}

func (s *ReportGroupResetClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupResetClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupResetClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupResetClause(s)
	}
}

func (s *ReportGroupResetClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupResetClause(s)
	}
}

func (p *Cobol85Parser) ReportGroupResetClause() (localctx IReportGroupResetClauseContext) {
	localctx = NewReportGroupResetClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 368, Cobol85ParserRULE_reportGroupResetClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2899)
		p.Match(Cobol85ParserRESET)
	}
	p.SetState(2901)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserON {
		{
			p.SetState(2900)
			p.Match(Cobol85ParserON)
		}

	}
	p.SetState(2905)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserFINAL:
		{
			p.SetState(2903)
			p.Match(Cobol85ParserFINAL)
		}

	case Cobol85ParserABORT, Cobol85ParserAS, Cobol85ParserASCII, Cobol85ParserASSOCIATED_DATA, Cobol85ParserASSOCIATED_DATA_LENGTH, Cobol85ParserATTRIBUTE, Cobol85ParserAUTO, Cobol85ParserAUTO_SKIP, Cobol85ParserBACKGROUND_COLOR, Cobol85ParserBACKGROUND_COLOUR, Cobol85ParserBEEP, Cobol85ParserBELL, Cobol85ParserBINARY, Cobol85ParserBIT, Cobol85ParserBLINK, Cobol85ParserBOUNDS, Cobol85ParserCAPABLE, Cobol85ParserCCSVERSION, Cobol85ParserCHANGED, Cobol85ParserCHANNEL, Cobol85ParserCLOSE_DISPOSITION, Cobol85ParserCOBOL, Cobol85ParserCOMMITMENT, Cobol85ParserCONTROL_POINT, Cobol85ParserCONVENTION, Cobol85ParserCRUNCH, Cobol85ParserCURSOR, Cobol85ParserDEFAULT, Cobol85ParserDEFAULT_DISPLAY, Cobol85ParserDEFINITION, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserDISK, Cobol85ParserDONTCARE, Cobol85ParserDOUBLE, Cobol85ParserEBCDIC, Cobol85ParserEMPTY_CHECK, Cobol85ParserENTER, Cobol85ParserENTRY_PROCEDURE, Cobol85ParserERASE, Cobol85ParserEOL, Cobol85ParserEOS, Cobol85ParserESCAPE, Cobol85ParserEVENT, Cobol85ParserEXCLUSIVE, Cobol85ParserEXPORT, Cobol85ParserEXTENDED, Cobol85ParserFOREGROUND_COLOR, Cobol85ParserFOREGROUND_COLOUR, Cobol85ParserFULL, Cobol85ParserFUNCTIONNAME, Cobol85ParserFUNCTION_POINTER, Cobol85ParserGRID, Cobol85ParserHIGHLIGHT, Cobol85ParserIMPLICIT, Cobol85ParserIMPORT, Cobol85ParserINTEGER, Cobol85ParserKEPT, Cobol85ParserKEYBOARD, Cobol85ParserLANGUAGE, Cobol85ParserLB, Cobol85ParserLD, Cobol85ParserLEFTLINE, Cobol85ParserLENGTH_CHECK, Cobol85ParserLIBACCESS, Cobol85ParserLIBPARAMETER, Cobol85ParserLIBRARY, Cobol85ParserLIST, Cobol85ParserLOCAL, Cobol85ParserLONG_DATE, Cobol85ParserLONG_TIME, Cobol85ParserLOWER, Cobol85ParserLOWLIGHT, Cobol85ParserMMDDYYYY, Cobol85ParserNAMED, Cobol85ParserNATIONAL, Cobol85ParserNATIONAL_EDITED, Cobol85ParserNETWORK, Cobol85ParserNO_ECHO, Cobol85ParserNUMERIC_DATE, Cobol85ParserNUMERIC_TIME, Cobol85ParserODT, Cobol85ParserORDERLY, Cobol85ParserOVERLINE, Cobol85ParserOWN, Cobol85ParserPASSWORD, Cobol85ParserPORT, Cobol85ParserPRINTER, Cobol85ParserPRIVATE, Cobol85ParserPROCESS, Cobol85ParserPROGRAM, Cobol85ParserPROMPT, Cobol85ParserREADER, Cobol85ParserREMOTE, Cobol85ParserREAL, Cobol85ParserRECEIVED, Cobol85ParserRECURSIVE, Cobol85ParserREF, Cobol85ParserREMOVE, Cobol85ParserREQUIRED, Cobol85ParserREVERSE_VIDEO, Cobol85ParserSAVE, Cobol85ParserSECURE, Cobol85ParserSHARED, Cobol85ParserSHAREDBYALL, Cobol85ParserSHAREDBYRUNUNIT, Cobol85ParserSHARING, Cobol85ParserSHORT_DATE, Cobol85ParserSYMBOL, Cobol85ParserTASK, Cobol85ParserTHREAD, Cobol85ParserTHREAD_LOCAL, Cobol85ParserTIMER, Cobol85ParserTODAYS_DATE, Cobol85ParserTODAYS_NAME, Cobol85ParserTRUNCATED, Cobol85ParserTYPEDEF, Cobol85ParserUNDERLINE, Cobol85ParserVIRTUAL, Cobol85ParserWAIT, Cobol85ParserYEAR, Cobol85ParserYYYYMMDD, Cobol85ParserYYYYDDD, Cobol85ParserZERO_FILL, Cobol85ParserIDENTIFIER:
		{
			p.SetState(2904)
			p.DataName()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IReportGroupSignClauseContext is an interface to support dynamic dispatch.
type IReportGroupSignClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupSignClauseContext differentiates from other interfaces.
	IsReportGroupSignClauseContext()
}

type ReportGroupSignClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupSignClauseContext() *ReportGroupSignClauseContext {
	var p = new(ReportGroupSignClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupSignClause
	return p
}

func (*ReportGroupSignClauseContext) IsReportGroupSignClauseContext() {}

func NewReportGroupSignClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupSignClauseContext {
	var p = new(ReportGroupSignClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupSignClause

	return p
}

func (s *ReportGroupSignClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupSignClauseContext) SIGN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSIGN, 0)
}

func (s *ReportGroupSignClauseContext) SEPARATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSEPARATE, 0)
}

func (s *ReportGroupSignClauseContext) LEADING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLEADING, 0)
}

func (s *ReportGroupSignClauseContext) TRAILING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTRAILING, 0)
}

func (s *ReportGroupSignClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ReportGroupSignClauseContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCHARACTER, 0)
}

func (s *ReportGroupSignClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupSignClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupSignClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupSignClause(s)
	}
}

func (s *ReportGroupSignClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupSignClause(s)
	}
}

func (p *Cobol85Parser) ReportGroupSignClause() (localctx IReportGroupSignClauseContext) {
	localctx = NewReportGroupSignClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 370, Cobol85ParserRULE_reportGroupSignClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2907)
		p.Match(Cobol85ParserSIGN)
	}
	p.SetState(2909)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2908)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(2911)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserLEADING || _la == Cobol85ParserTRAILING) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(2912)
		p.Match(Cobol85ParserSEPARATE)
	}
	p.SetState(2914)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCHARACTER {
		{
			p.SetState(2913)
			p.Match(Cobol85ParserCHARACTER)
		}

	}

	return localctx
}

// IReportGroupSourceClauseContext is an interface to support dynamic dispatch.
type IReportGroupSourceClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupSourceClauseContext differentiates from other interfaces.
	IsReportGroupSourceClauseContext()
}

type ReportGroupSourceClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupSourceClauseContext() *ReportGroupSourceClauseContext {
	var p = new(ReportGroupSourceClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupSourceClause
	return p
}

func (*ReportGroupSourceClauseContext) IsReportGroupSourceClauseContext() {}

func NewReportGroupSourceClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupSourceClauseContext {
	var p = new(ReportGroupSourceClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupSourceClause

	return p
}

func (s *ReportGroupSourceClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupSourceClauseContext) SOURCE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSOURCE, 0)
}

func (s *ReportGroupSourceClauseContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ReportGroupSourceClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ReportGroupSourceClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupSourceClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupSourceClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupSourceClause(s)
	}
}

func (s *ReportGroupSourceClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupSourceClause(s)
	}
}

func (p *Cobol85Parser) ReportGroupSourceClause() (localctx IReportGroupSourceClauseContext) {
	localctx = NewReportGroupSourceClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 372, Cobol85ParserRULE_reportGroupSourceClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2916)
		p.Match(Cobol85ParserSOURCE)
	}
	p.SetState(2918)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2917)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(2920)
		p.Identifier()
	}

	return localctx
}

// IReportGroupSumClauseContext is an interface to support dynamic dispatch.
type IReportGroupSumClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupSumClauseContext differentiates from other interfaces.
	IsReportGroupSumClauseContext()
}

type ReportGroupSumClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupSumClauseContext() *ReportGroupSumClauseContext {
	var p = new(ReportGroupSumClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupSumClause
	return p
}

func (*ReportGroupSumClauseContext) IsReportGroupSumClauseContext() {}

func NewReportGroupSumClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupSumClauseContext {
	var p = new(ReportGroupSumClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupSumClause

	return p
}

func (s *ReportGroupSumClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupSumClauseContext) SUM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSUM, 0)
}

func (s *ReportGroupSumClauseContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *ReportGroupSumClauseContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ReportGroupSumClauseContext) UPON() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserUPON, 0)
}

func (s *ReportGroupSumClauseContext) AllDataName() []IDataNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDataNameContext)(nil)).Elem())
	var tst = make([]IDataNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDataNameContext)
		}
	}

	return tst
}

func (s *ReportGroupSumClauseContext) DataName(i int) IDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *ReportGroupSumClauseContext) AllCOMMACHAR() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserCOMMACHAR)
}

func (s *ReportGroupSumClauseContext) COMMACHAR(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMMACHAR, i)
}

func (s *ReportGroupSumClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupSumClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupSumClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupSumClause(s)
	}
}

func (s *ReportGroupSumClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupSumClause(s)
	}
}

func (p *Cobol85Parser) ReportGroupSumClause() (localctx IReportGroupSumClauseContext) {
	localctx = NewReportGroupSumClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 374, Cobol85ParserRULE_reportGroupSumClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2922)
		p.Match(Cobol85ParserSUM)
	}
	{
		p.SetState(2923)
		p.Identifier()
	}
	p.SetState(2930)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 344, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(2925)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == Cobol85ParserCOMMACHAR {
				{
					p.SetState(2924)
					p.Match(Cobol85ParserCOMMACHAR)
				}

			}
			{
				p.SetState(2927)
				p.Identifier()
			}

		}
		p.SetState(2932)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 344, p.GetParserRuleContext())
	}
	p.SetState(2944)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserUPON {
		{
			p.SetState(2933)
			p.Match(Cobol85ParserUPON)
		}
		{
			p.SetState(2934)
			p.DataName()
		}
		p.SetState(2941)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH)|(1<<Cobol85ParserATTRIBUTE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBINARY-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-68))|(1<<(Cobol85ParserCOBOL-68))|(1<<(Cobol85ParserCOMMITMENT-68))|(1<<(Cobol85ParserCONTROL_POINT-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(Cobol85ParserCONVENTION-100))|(1<<(Cobol85ParserCRUNCH-100))|(1<<(Cobol85ParserCURSOR-100))|(1<<(Cobol85ParserDEFAULT-100))|(1<<(Cobol85ParserDEFAULT_DISPLAY-100))|(1<<(Cobol85ParserDEFINITION-100)))) != 0) || (((_la-138)&-(0x1f+1)) == 0 && ((1<<uint((_la-138)))&((1<<(Cobol85ParserDFHRESP-138))|(1<<(Cobol85ParserDFHVALUE-138))|(1<<(Cobol85ParserDISK-138))|(1<<(Cobol85ParserDONTCARE-138))|(1<<(Cobol85ParserDOUBLE-138))|(1<<(Cobol85ParserEBCDIC-138))|(1<<(Cobol85ParserEMPTY_CHECK-138)))) != 0) || (((_la-181)&-(0x1f+1)) == 0 && ((1<<uint((_la-181)))&((1<<(Cobol85ParserENTER-181))|(1<<(Cobol85ParserENTRY_PROCEDURE-181))|(1<<(Cobol85ParserERASE-181))|(1<<(Cobol85ParserEOL-181))|(1<<(Cobol85ParserEOS-181))|(1<<(Cobol85ParserESCAPE-181))|(1<<(Cobol85ParserEVENT-181))|(1<<(Cobol85ParserEXCLUSIVE-181))|(1<<(Cobol85ParserEXPORT-181))|(1<<(Cobol85ParserEXTENDED-181)))) != 0) || (((_la-213)&-(0x1f+1)) == 0 && ((1<<uint((_la-213)))&((1<<(Cobol85ParserFOREGROUND_COLOR-213))|(1<<(Cobol85ParserFOREGROUND_COLOUR-213))|(1<<(Cobol85ParserFULL-213))|(1<<(Cobol85ParserFUNCTIONNAME-213))|(1<<(Cobol85ParserFUNCTION_POINTER-213))|(1<<(Cobol85ParserGRID-213))|(1<<(Cobol85ParserHIGHLIGHT-213))|(1<<(Cobol85ParserIMPLICIT-213))|(1<<(Cobol85ParserIMPORT-213)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(Cobol85ParserINTEGER-250))|(1<<(Cobol85ParserKEPT-250))|(1<<(Cobol85ParserKEYBOARD-250))|(1<<(Cobol85ParserLANGUAGE-250))|(1<<(Cobol85ParserLB-250))|(1<<(Cobol85ParserLD-250))|(1<<(Cobol85ParserLEFTLINE-250))|(1<<(Cobol85ParserLENGTH_CHECK-250))|(1<<(Cobol85ParserLIBACCESS-250))|(1<<(Cobol85ParserLIBPARAMETER-250))|(1<<(Cobol85ParserLIBRARY-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(Cobol85ParserLIST-283))|(1<<(Cobol85ParserLOCAL-283))|(1<<(Cobol85ParserLONG_DATE-283))|(1<<(Cobol85ParserLONG_TIME-283))|(1<<(Cobol85ParserLOWER-283))|(1<<(Cobol85ParserLOWLIGHT-283))|(1<<(Cobol85ParserMMDDYYYY-283))|(1<<(Cobol85ParserNAMED-283))|(1<<(Cobol85ParserNATIONAL-283))|(1<<(Cobol85ParserNATIONAL_EDITED-283))|(1<<(Cobol85ParserNETWORK-283))|(1<<(Cobol85ParserNO_ECHO-283)))) != 0) || (((_la-317)&-(0x1f+1)) == 0 && ((1<<uint((_la-317)))&((1<<(Cobol85ParserNUMERIC_DATE-317))|(1<<(Cobol85ParserNUMERIC_TIME-317))|(1<<(Cobol85ParserODT-317))|(1<<(Cobol85ParserORDERLY-317))|(1<<(Cobol85ParserOVERLINE-317))|(1<<(Cobol85ParserOWN-317))|(1<<(Cobol85ParserPASSWORD-317)))) != 0) || (((_la-352)&-(0x1f+1)) == 0 && ((1<<uint((_la-352)))&((1<<(Cobol85ParserPORT-352))|(1<<(Cobol85ParserPRINTER-352))|(1<<(Cobol85ParserPRIVATE-352))|(1<<(Cobol85ParserPROCESS-352))|(1<<(Cobol85ParserPROGRAM-352))|(1<<(Cobol85ParserPROMPT-352))|(1<<(Cobol85ParserREADER-352))|(1<<(Cobol85ParserREMOTE-352))|(1<<(Cobol85ParserREAL-352))|(1<<(Cobol85ParserRECEIVED-352))|(1<<(Cobol85ParserRECURSIVE-352))|(1<<(Cobol85ParserREF-352)))) != 0) || (((_la-391)&-(0x1f+1)) == 0 && ((1<<uint((_la-391)))&((1<<(Cobol85ParserREMOVE-391))|(1<<(Cobol85ParserREQUIRED-391))|(1<<(Cobol85ParserREVERSE_VIDEO-391))|(1<<(Cobol85ParserSAVE-391))|(1<<(Cobol85ParserSECURE-391)))) != 0) || (((_la-431)&-(0x1f+1)) == 0 && ((1<<uint((_la-431)))&((1<<(Cobol85ParserSHARED-431))|(1<<(Cobol85ParserSHAREDBYALL-431))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-431))|(1<<(Cobol85ParserSHARING-431))|(1<<(Cobol85ParserSHORT_DATE-431)))) != 0) || (((_la-466)&-(0x1f+1)) == 0 && ((1<<uint((_la-466)))&((1<<(Cobol85ParserSYMBOL-466))|(1<<(Cobol85ParserTASK-466))|(1<<(Cobol85ParserTHREAD-466))|(1<<(Cobol85ParserTHREAD_LOCAL-466))|(1<<(Cobol85ParserTIMER-466))|(1<<(Cobol85ParserTODAYS_DATE-466))|(1<<(Cobol85ParserTODAYS_NAME-466))|(1<<(Cobol85ParserTRUNCATED-466))|(1<<(Cobol85ParserTYPEDEF-466)))) != 0) || (((_la-498)&-(0x1f+1)) == 0 && ((1<<uint((_la-498)))&((1<<(Cobol85ParserUNDERLINE-498))|(1<<(Cobol85ParserVIRTUAL-498))|(1<<(Cobol85ParserWAIT-498))|(1<<(Cobol85ParserYEAR-498))|(1<<(Cobol85ParserYYYYMMDD-498))|(1<<(Cobol85ParserYYYYDDD-498))|(1<<(Cobol85ParserZERO_FILL-498))|(1<<(Cobol85ParserCOMMACHAR-498)))) != 0) || _la == Cobol85ParserIDENTIFIER {
			p.SetState(2936)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == Cobol85ParserCOMMACHAR {
				{
					p.SetState(2935)
					p.Match(Cobol85ParserCOMMACHAR)
				}

			}
			{
				p.SetState(2938)
				p.DataName()
			}

			p.SetState(2943)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// IReportGroupTypeClauseContext is an interface to support dynamic dispatch.
type IReportGroupTypeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupTypeClauseContext differentiates from other interfaces.
	IsReportGroupTypeClauseContext()
}

type ReportGroupTypeClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupTypeClauseContext() *ReportGroupTypeClauseContext {
	var p = new(ReportGroupTypeClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupTypeClause
	return p
}

func (*ReportGroupTypeClauseContext) IsReportGroupTypeClauseContext() {}

func NewReportGroupTypeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupTypeClauseContext {
	var p = new(ReportGroupTypeClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupTypeClause

	return p
}

func (s *ReportGroupTypeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupTypeClauseContext) TYPE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTYPE, 0)
}

func (s *ReportGroupTypeClauseContext) ReportGroupTypeReportHeading() IReportGroupTypeReportHeadingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportGroupTypeReportHeadingContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReportGroupTypeReportHeadingContext)
}

func (s *ReportGroupTypeClauseContext) ReportGroupTypePageHeading() IReportGroupTypePageHeadingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportGroupTypePageHeadingContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReportGroupTypePageHeadingContext)
}

func (s *ReportGroupTypeClauseContext) ReportGroupTypeControlHeading() IReportGroupTypeControlHeadingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportGroupTypeControlHeadingContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReportGroupTypeControlHeadingContext)
}

func (s *ReportGroupTypeClauseContext) ReportGroupTypeDetail() IReportGroupTypeDetailContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportGroupTypeDetailContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReportGroupTypeDetailContext)
}

func (s *ReportGroupTypeClauseContext) ReportGroupTypeControlFooting() IReportGroupTypeControlFootingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportGroupTypeControlFootingContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReportGroupTypeControlFootingContext)
}

func (s *ReportGroupTypeClauseContext) ReportGroupTypePageFooting() IReportGroupTypePageFootingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportGroupTypePageFootingContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReportGroupTypePageFootingContext)
}

func (s *ReportGroupTypeClauseContext) ReportGroupTypeReportFooting() IReportGroupTypeReportFootingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportGroupTypeReportFootingContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReportGroupTypeReportFootingContext)
}

func (s *ReportGroupTypeClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ReportGroupTypeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupTypeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupTypeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupTypeClause(s)
	}
}

func (s *ReportGroupTypeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupTypeClause(s)
	}
}

func (p *Cobol85Parser) ReportGroupTypeClause() (localctx IReportGroupTypeClauseContext) {
	localctx = NewReportGroupTypeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 376, Cobol85ParserRULE_reportGroupTypeClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2946)
		p.Match(Cobol85ParserTYPE)
	}
	p.SetState(2948)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2947)
			p.Match(Cobol85ParserIS)
		}

	}
	p.SetState(2957)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 349, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2950)
			p.ReportGroupTypeReportHeading()
		}

	case 2:
		{
			p.SetState(2951)
			p.ReportGroupTypePageHeading()
		}

	case 3:
		{
			p.SetState(2952)
			p.ReportGroupTypeControlHeading()
		}

	case 4:
		{
			p.SetState(2953)
			p.ReportGroupTypeDetail()
		}

	case 5:
		{
			p.SetState(2954)
			p.ReportGroupTypeControlFooting()
		}

	case 6:
		{
			p.SetState(2955)
			p.ReportGroupTypePageFooting()
		}

	case 7:
		{
			p.SetState(2956)
			p.ReportGroupTypeReportFooting()
		}

	}

	return localctx
}

// IReportGroupTypeReportHeadingContext is an interface to support dynamic dispatch.
type IReportGroupTypeReportHeadingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupTypeReportHeadingContext differentiates from other interfaces.
	IsReportGroupTypeReportHeadingContext()
}

type ReportGroupTypeReportHeadingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupTypeReportHeadingContext() *ReportGroupTypeReportHeadingContext {
	var p = new(ReportGroupTypeReportHeadingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupTypeReportHeading
	return p
}

func (*ReportGroupTypeReportHeadingContext) IsReportGroupTypeReportHeadingContext() {}

func NewReportGroupTypeReportHeadingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupTypeReportHeadingContext {
	var p = new(ReportGroupTypeReportHeadingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupTypeReportHeading

	return p
}

func (s *ReportGroupTypeReportHeadingContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupTypeReportHeadingContext) REPORT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREPORT, 0)
}

func (s *ReportGroupTypeReportHeadingContext) HEADING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserHEADING, 0)
}

func (s *ReportGroupTypeReportHeadingContext) RH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRH, 0)
}

func (s *ReportGroupTypeReportHeadingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupTypeReportHeadingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupTypeReportHeadingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupTypeReportHeading(s)
	}
}

func (s *ReportGroupTypeReportHeadingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupTypeReportHeading(s)
	}
}

func (p *Cobol85Parser) ReportGroupTypeReportHeading() (localctx IReportGroupTypeReportHeadingContext) {
	localctx = NewReportGroupTypeReportHeadingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 378, Cobol85ParserRULE_reportGroupTypeReportHeading)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2962)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserREPORT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2959)
			p.Match(Cobol85ParserREPORT)
		}
		{
			p.SetState(2960)
			p.Match(Cobol85ParserHEADING)
		}

	case Cobol85ParserRH:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2961)
			p.Match(Cobol85ParserRH)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IReportGroupTypePageHeadingContext is an interface to support dynamic dispatch.
type IReportGroupTypePageHeadingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupTypePageHeadingContext differentiates from other interfaces.
	IsReportGroupTypePageHeadingContext()
}

type ReportGroupTypePageHeadingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupTypePageHeadingContext() *ReportGroupTypePageHeadingContext {
	var p = new(ReportGroupTypePageHeadingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupTypePageHeading
	return p
}

func (*ReportGroupTypePageHeadingContext) IsReportGroupTypePageHeadingContext() {}

func NewReportGroupTypePageHeadingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupTypePageHeadingContext {
	var p = new(ReportGroupTypePageHeadingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupTypePageHeading

	return p
}

func (s *ReportGroupTypePageHeadingContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupTypePageHeadingContext) PAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPAGE, 0)
}

func (s *ReportGroupTypePageHeadingContext) HEADING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserHEADING, 0)
}

func (s *ReportGroupTypePageHeadingContext) PH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPH, 0)
}

func (s *ReportGroupTypePageHeadingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupTypePageHeadingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupTypePageHeadingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupTypePageHeading(s)
	}
}

func (s *ReportGroupTypePageHeadingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupTypePageHeading(s)
	}
}

func (p *Cobol85Parser) ReportGroupTypePageHeading() (localctx IReportGroupTypePageHeadingContext) {
	localctx = NewReportGroupTypePageHeadingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 380, Cobol85ParserRULE_reportGroupTypePageHeading)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2967)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserPAGE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2964)
			p.Match(Cobol85ParserPAGE)
		}
		{
			p.SetState(2965)
			p.Match(Cobol85ParserHEADING)
		}

	case Cobol85ParserPH:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2966)
			p.Match(Cobol85ParserPH)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IReportGroupTypeControlHeadingContext is an interface to support dynamic dispatch.
type IReportGroupTypeControlHeadingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupTypeControlHeadingContext differentiates from other interfaces.
	IsReportGroupTypeControlHeadingContext()
}

type ReportGroupTypeControlHeadingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupTypeControlHeadingContext() *ReportGroupTypeControlHeadingContext {
	var p = new(ReportGroupTypeControlHeadingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupTypeControlHeading
	return p
}

func (*ReportGroupTypeControlHeadingContext) IsReportGroupTypeControlHeadingContext() {}

func NewReportGroupTypeControlHeadingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupTypeControlHeadingContext {
	var p = new(ReportGroupTypeControlHeadingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupTypeControlHeading

	return p
}

func (s *ReportGroupTypeControlHeadingContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupTypeControlHeadingContext) CONTROL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCONTROL, 0)
}

func (s *ReportGroupTypeControlHeadingContext) HEADING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserHEADING, 0)
}

func (s *ReportGroupTypeControlHeadingContext) CH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCH, 0)
}

func (s *ReportGroupTypeControlHeadingContext) FINAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFINAL, 0)
}

func (s *ReportGroupTypeControlHeadingContext) DataName() IDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *ReportGroupTypeControlHeadingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupTypeControlHeadingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupTypeControlHeadingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupTypeControlHeading(s)
	}
}

func (s *ReportGroupTypeControlHeadingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupTypeControlHeading(s)
	}
}

func (p *Cobol85Parser) ReportGroupTypeControlHeading() (localctx IReportGroupTypeControlHeadingContext) {
	localctx = NewReportGroupTypeControlHeadingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 382, Cobol85ParserRULE_reportGroupTypeControlHeading)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2972)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserCONTROL:
		{
			p.SetState(2969)
			p.Match(Cobol85ParserCONTROL)
		}
		{
			p.SetState(2970)
			p.Match(Cobol85ParserHEADING)
		}

	case Cobol85ParserCH:
		{
			p.SetState(2971)
			p.Match(Cobol85ParserCH)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(2976)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserFINAL:
		{
			p.SetState(2974)
			p.Match(Cobol85ParserFINAL)
		}

	case Cobol85ParserABORT, Cobol85ParserAS, Cobol85ParserASCII, Cobol85ParserASSOCIATED_DATA, Cobol85ParserASSOCIATED_DATA_LENGTH, Cobol85ParserATTRIBUTE, Cobol85ParserAUTO, Cobol85ParserAUTO_SKIP, Cobol85ParserBACKGROUND_COLOR, Cobol85ParserBACKGROUND_COLOUR, Cobol85ParserBEEP, Cobol85ParserBELL, Cobol85ParserBINARY, Cobol85ParserBIT, Cobol85ParserBLINK, Cobol85ParserBOUNDS, Cobol85ParserCAPABLE, Cobol85ParserCCSVERSION, Cobol85ParserCHANGED, Cobol85ParserCHANNEL, Cobol85ParserCLOSE_DISPOSITION, Cobol85ParserCOBOL, Cobol85ParserCOMMITMENT, Cobol85ParserCONTROL_POINT, Cobol85ParserCONVENTION, Cobol85ParserCRUNCH, Cobol85ParserCURSOR, Cobol85ParserDEFAULT, Cobol85ParserDEFAULT_DISPLAY, Cobol85ParserDEFINITION, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserDISK, Cobol85ParserDONTCARE, Cobol85ParserDOUBLE, Cobol85ParserEBCDIC, Cobol85ParserEMPTY_CHECK, Cobol85ParserENTER, Cobol85ParserENTRY_PROCEDURE, Cobol85ParserERASE, Cobol85ParserEOL, Cobol85ParserEOS, Cobol85ParserESCAPE, Cobol85ParserEVENT, Cobol85ParserEXCLUSIVE, Cobol85ParserEXPORT, Cobol85ParserEXTENDED, Cobol85ParserFOREGROUND_COLOR, Cobol85ParserFOREGROUND_COLOUR, Cobol85ParserFULL, Cobol85ParserFUNCTIONNAME, Cobol85ParserFUNCTION_POINTER, Cobol85ParserGRID, Cobol85ParserHIGHLIGHT, Cobol85ParserIMPLICIT, Cobol85ParserIMPORT, Cobol85ParserINTEGER, Cobol85ParserKEPT, Cobol85ParserKEYBOARD, Cobol85ParserLANGUAGE, Cobol85ParserLB, Cobol85ParserLD, Cobol85ParserLEFTLINE, Cobol85ParserLENGTH_CHECK, Cobol85ParserLIBACCESS, Cobol85ParserLIBPARAMETER, Cobol85ParserLIBRARY, Cobol85ParserLIST, Cobol85ParserLOCAL, Cobol85ParserLONG_DATE, Cobol85ParserLONG_TIME, Cobol85ParserLOWER, Cobol85ParserLOWLIGHT, Cobol85ParserMMDDYYYY, Cobol85ParserNAMED, Cobol85ParserNATIONAL, Cobol85ParserNATIONAL_EDITED, Cobol85ParserNETWORK, Cobol85ParserNO_ECHO, Cobol85ParserNUMERIC_DATE, Cobol85ParserNUMERIC_TIME, Cobol85ParserODT, Cobol85ParserORDERLY, Cobol85ParserOVERLINE, Cobol85ParserOWN, Cobol85ParserPASSWORD, Cobol85ParserPORT, Cobol85ParserPRINTER, Cobol85ParserPRIVATE, Cobol85ParserPROCESS, Cobol85ParserPROGRAM, Cobol85ParserPROMPT, Cobol85ParserREADER, Cobol85ParserREMOTE, Cobol85ParserREAL, Cobol85ParserRECEIVED, Cobol85ParserRECURSIVE, Cobol85ParserREF, Cobol85ParserREMOVE, Cobol85ParserREQUIRED, Cobol85ParserREVERSE_VIDEO, Cobol85ParserSAVE, Cobol85ParserSECURE, Cobol85ParserSHARED, Cobol85ParserSHAREDBYALL, Cobol85ParserSHAREDBYRUNUNIT, Cobol85ParserSHARING, Cobol85ParserSHORT_DATE, Cobol85ParserSYMBOL, Cobol85ParserTASK, Cobol85ParserTHREAD, Cobol85ParserTHREAD_LOCAL, Cobol85ParserTIMER, Cobol85ParserTODAYS_DATE, Cobol85ParserTODAYS_NAME, Cobol85ParserTRUNCATED, Cobol85ParserTYPEDEF, Cobol85ParserUNDERLINE, Cobol85ParserVIRTUAL, Cobol85ParserWAIT, Cobol85ParserYEAR, Cobol85ParserYYYYMMDD, Cobol85ParserYYYYDDD, Cobol85ParserZERO_FILL, Cobol85ParserIDENTIFIER:
		{
			p.SetState(2975)
			p.DataName()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IReportGroupTypeDetailContext is an interface to support dynamic dispatch.
type IReportGroupTypeDetailContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupTypeDetailContext differentiates from other interfaces.
	IsReportGroupTypeDetailContext()
}

type ReportGroupTypeDetailContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupTypeDetailContext() *ReportGroupTypeDetailContext {
	var p = new(ReportGroupTypeDetailContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupTypeDetail
	return p
}

func (*ReportGroupTypeDetailContext) IsReportGroupTypeDetailContext() {}

func NewReportGroupTypeDetailContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupTypeDetailContext {
	var p = new(ReportGroupTypeDetailContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupTypeDetail

	return p
}

func (s *ReportGroupTypeDetailContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupTypeDetailContext) DETAIL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDETAIL, 0)
}

func (s *ReportGroupTypeDetailContext) DE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDE, 0)
}

func (s *ReportGroupTypeDetailContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupTypeDetailContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupTypeDetailContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupTypeDetail(s)
	}
}

func (s *ReportGroupTypeDetailContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupTypeDetail(s)
	}
}

func (p *Cobol85Parser) ReportGroupTypeDetail() (localctx IReportGroupTypeDetailContext) {
	localctx = NewReportGroupTypeDetailContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 384, Cobol85ParserRULE_reportGroupTypeDetail)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2978)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserDE || _la == Cobol85ParserDETAIL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IReportGroupTypeControlFootingContext is an interface to support dynamic dispatch.
type IReportGroupTypeControlFootingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupTypeControlFootingContext differentiates from other interfaces.
	IsReportGroupTypeControlFootingContext()
}

type ReportGroupTypeControlFootingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupTypeControlFootingContext() *ReportGroupTypeControlFootingContext {
	var p = new(ReportGroupTypeControlFootingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupTypeControlFooting
	return p
}

func (*ReportGroupTypeControlFootingContext) IsReportGroupTypeControlFootingContext() {}

func NewReportGroupTypeControlFootingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupTypeControlFootingContext {
	var p = new(ReportGroupTypeControlFootingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupTypeControlFooting

	return p
}

func (s *ReportGroupTypeControlFootingContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupTypeControlFootingContext) CONTROL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCONTROL, 0)
}

func (s *ReportGroupTypeControlFootingContext) FOOTING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOOTING, 0)
}

func (s *ReportGroupTypeControlFootingContext) CF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCF, 0)
}

func (s *ReportGroupTypeControlFootingContext) FINAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFINAL, 0)
}

func (s *ReportGroupTypeControlFootingContext) DataName() IDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *ReportGroupTypeControlFootingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupTypeControlFootingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupTypeControlFootingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupTypeControlFooting(s)
	}
}

func (s *ReportGroupTypeControlFootingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupTypeControlFooting(s)
	}
}

func (p *Cobol85Parser) ReportGroupTypeControlFooting() (localctx IReportGroupTypeControlFootingContext) {
	localctx = NewReportGroupTypeControlFootingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 386, Cobol85ParserRULE_reportGroupTypeControlFooting)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2983)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserCONTROL:
		{
			p.SetState(2980)
			p.Match(Cobol85ParserCONTROL)
		}
		{
			p.SetState(2981)
			p.Match(Cobol85ParserFOOTING)
		}

	case Cobol85ParserCF:
		{
			p.SetState(2982)
			p.Match(Cobol85ParserCF)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(2987)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserFINAL:
		{
			p.SetState(2985)
			p.Match(Cobol85ParserFINAL)
		}

	case Cobol85ParserABORT, Cobol85ParserAS, Cobol85ParserASCII, Cobol85ParserASSOCIATED_DATA, Cobol85ParserASSOCIATED_DATA_LENGTH, Cobol85ParserATTRIBUTE, Cobol85ParserAUTO, Cobol85ParserAUTO_SKIP, Cobol85ParserBACKGROUND_COLOR, Cobol85ParserBACKGROUND_COLOUR, Cobol85ParserBEEP, Cobol85ParserBELL, Cobol85ParserBINARY, Cobol85ParserBIT, Cobol85ParserBLINK, Cobol85ParserBOUNDS, Cobol85ParserCAPABLE, Cobol85ParserCCSVERSION, Cobol85ParserCHANGED, Cobol85ParserCHANNEL, Cobol85ParserCLOSE_DISPOSITION, Cobol85ParserCOBOL, Cobol85ParserCOMMITMENT, Cobol85ParserCONTROL_POINT, Cobol85ParserCONVENTION, Cobol85ParserCRUNCH, Cobol85ParserCURSOR, Cobol85ParserDEFAULT, Cobol85ParserDEFAULT_DISPLAY, Cobol85ParserDEFINITION, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserDISK, Cobol85ParserDONTCARE, Cobol85ParserDOUBLE, Cobol85ParserEBCDIC, Cobol85ParserEMPTY_CHECK, Cobol85ParserENTER, Cobol85ParserENTRY_PROCEDURE, Cobol85ParserERASE, Cobol85ParserEOL, Cobol85ParserEOS, Cobol85ParserESCAPE, Cobol85ParserEVENT, Cobol85ParserEXCLUSIVE, Cobol85ParserEXPORT, Cobol85ParserEXTENDED, Cobol85ParserFOREGROUND_COLOR, Cobol85ParserFOREGROUND_COLOUR, Cobol85ParserFULL, Cobol85ParserFUNCTIONNAME, Cobol85ParserFUNCTION_POINTER, Cobol85ParserGRID, Cobol85ParserHIGHLIGHT, Cobol85ParserIMPLICIT, Cobol85ParserIMPORT, Cobol85ParserINTEGER, Cobol85ParserKEPT, Cobol85ParserKEYBOARD, Cobol85ParserLANGUAGE, Cobol85ParserLB, Cobol85ParserLD, Cobol85ParserLEFTLINE, Cobol85ParserLENGTH_CHECK, Cobol85ParserLIBACCESS, Cobol85ParserLIBPARAMETER, Cobol85ParserLIBRARY, Cobol85ParserLIST, Cobol85ParserLOCAL, Cobol85ParserLONG_DATE, Cobol85ParserLONG_TIME, Cobol85ParserLOWER, Cobol85ParserLOWLIGHT, Cobol85ParserMMDDYYYY, Cobol85ParserNAMED, Cobol85ParserNATIONAL, Cobol85ParserNATIONAL_EDITED, Cobol85ParserNETWORK, Cobol85ParserNO_ECHO, Cobol85ParserNUMERIC_DATE, Cobol85ParserNUMERIC_TIME, Cobol85ParserODT, Cobol85ParserORDERLY, Cobol85ParserOVERLINE, Cobol85ParserOWN, Cobol85ParserPASSWORD, Cobol85ParserPORT, Cobol85ParserPRINTER, Cobol85ParserPRIVATE, Cobol85ParserPROCESS, Cobol85ParserPROGRAM, Cobol85ParserPROMPT, Cobol85ParserREADER, Cobol85ParserREMOTE, Cobol85ParserREAL, Cobol85ParserRECEIVED, Cobol85ParserRECURSIVE, Cobol85ParserREF, Cobol85ParserREMOVE, Cobol85ParserREQUIRED, Cobol85ParserREVERSE_VIDEO, Cobol85ParserSAVE, Cobol85ParserSECURE, Cobol85ParserSHARED, Cobol85ParserSHAREDBYALL, Cobol85ParserSHAREDBYRUNUNIT, Cobol85ParserSHARING, Cobol85ParserSHORT_DATE, Cobol85ParserSYMBOL, Cobol85ParserTASK, Cobol85ParserTHREAD, Cobol85ParserTHREAD_LOCAL, Cobol85ParserTIMER, Cobol85ParserTODAYS_DATE, Cobol85ParserTODAYS_NAME, Cobol85ParserTRUNCATED, Cobol85ParserTYPEDEF, Cobol85ParserUNDERLINE, Cobol85ParserVIRTUAL, Cobol85ParserWAIT, Cobol85ParserYEAR, Cobol85ParserYYYYMMDD, Cobol85ParserYYYYDDD, Cobol85ParserZERO_FILL, Cobol85ParserIDENTIFIER:
		{
			p.SetState(2986)
			p.DataName()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IReportGroupUsageClauseContext is an interface to support dynamic dispatch.
type IReportGroupUsageClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupUsageClauseContext differentiates from other interfaces.
	IsReportGroupUsageClauseContext()
}

type ReportGroupUsageClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupUsageClauseContext() *ReportGroupUsageClauseContext {
	var p = new(ReportGroupUsageClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupUsageClause
	return p
}

func (*ReportGroupUsageClauseContext) IsReportGroupUsageClauseContext() {}

func NewReportGroupUsageClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupUsageClauseContext {
	var p = new(ReportGroupUsageClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupUsageClause

	return p
}

func (s *ReportGroupUsageClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupUsageClauseContext) DISPLAY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDISPLAY, 0)
}

func (s *ReportGroupUsageClauseContext) DISPLAY_1() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDISPLAY_1, 0)
}

func (s *ReportGroupUsageClauseContext) USAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserUSAGE, 0)
}

func (s *ReportGroupUsageClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ReportGroupUsageClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupUsageClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupUsageClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupUsageClause(s)
	}
}

func (s *ReportGroupUsageClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupUsageClause(s)
	}
}

func (p *Cobol85Parser) ReportGroupUsageClause() (localctx IReportGroupUsageClauseContext) {
	localctx = NewReportGroupUsageClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 388, Cobol85ParserRULE_reportGroupUsageClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2993)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserUSAGE {
		{
			p.SetState(2989)
			p.Match(Cobol85ParserUSAGE)
		}
		p.SetState(2991)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserIS {
			{
				p.SetState(2990)
				p.Match(Cobol85ParserIS)
			}

		}

	}
	{
		p.SetState(2995)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserDISPLAY || _la == Cobol85ParserDISPLAY_1) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IReportGroupTypePageFootingContext is an interface to support dynamic dispatch.
type IReportGroupTypePageFootingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupTypePageFootingContext differentiates from other interfaces.
	IsReportGroupTypePageFootingContext()
}

type ReportGroupTypePageFootingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupTypePageFootingContext() *ReportGroupTypePageFootingContext {
	var p = new(ReportGroupTypePageFootingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupTypePageFooting
	return p
}

func (*ReportGroupTypePageFootingContext) IsReportGroupTypePageFootingContext() {}

func NewReportGroupTypePageFootingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupTypePageFootingContext {
	var p = new(ReportGroupTypePageFootingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupTypePageFooting

	return p
}

func (s *ReportGroupTypePageFootingContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupTypePageFootingContext) PAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPAGE, 0)
}

func (s *ReportGroupTypePageFootingContext) FOOTING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOOTING, 0)
}

func (s *ReportGroupTypePageFootingContext) PF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPF, 0)
}

func (s *ReportGroupTypePageFootingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupTypePageFootingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupTypePageFootingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupTypePageFooting(s)
	}
}

func (s *ReportGroupTypePageFootingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupTypePageFooting(s)
	}
}

func (p *Cobol85Parser) ReportGroupTypePageFooting() (localctx IReportGroupTypePageFootingContext) {
	localctx = NewReportGroupTypePageFootingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 390, Cobol85ParserRULE_reportGroupTypePageFooting)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3000)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserPAGE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2997)
			p.Match(Cobol85ParserPAGE)
		}
		{
			p.SetState(2998)
			p.Match(Cobol85ParserFOOTING)
		}

	case Cobol85ParserPF:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2999)
			p.Match(Cobol85ParserPF)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IReportGroupTypeReportFootingContext is an interface to support dynamic dispatch.
type IReportGroupTypeReportFootingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupTypeReportFootingContext differentiates from other interfaces.
	IsReportGroupTypeReportFootingContext()
}

type ReportGroupTypeReportFootingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupTypeReportFootingContext() *ReportGroupTypeReportFootingContext {
	var p = new(ReportGroupTypeReportFootingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupTypeReportFooting
	return p
}

func (*ReportGroupTypeReportFootingContext) IsReportGroupTypeReportFootingContext() {}

func NewReportGroupTypeReportFootingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupTypeReportFootingContext {
	var p = new(ReportGroupTypeReportFootingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupTypeReportFooting

	return p
}

func (s *ReportGroupTypeReportFootingContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupTypeReportFootingContext) REPORT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREPORT, 0)
}

func (s *ReportGroupTypeReportFootingContext) FOOTING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOOTING, 0)
}

func (s *ReportGroupTypeReportFootingContext) RF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRF, 0)
}

func (s *ReportGroupTypeReportFootingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupTypeReportFootingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupTypeReportFootingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupTypeReportFooting(s)
	}
}

func (s *ReportGroupTypeReportFootingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupTypeReportFooting(s)
	}
}

func (p *Cobol85Parser) ReportGroupTypeReportFooting() (localctx IReportGroupTypeReportFootingContext) {
	localctx = NewReportGroupTypeReportFootingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 392, Cobol85ParserRULE_reportGroupTypeReportFooting)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3005)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserREPORT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3002)
			p.Match(Cobol85ParserREPORT)
		}
		{
			p.SetState(3003)
			p.Match(Cobol85ParserFOOTING)
		}

	case Cobol85ParserRF:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3004)
			p.Match(Cobol85ParserRF)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IReportGroupValueClauseContext is an interface to support dynamic dispatch.
type IReportGroupValueClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupValueClauseContext differentiates from other interfaces.
	IsReportGroupValueClauseContext()
}

type ReportGroupValueClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupValueClauseContext() *ReportGroupValueClauseContext {
	var p = new(ReportGroupValueClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupValueClause
	return p
}

func (*ReportGroupValueClauseContext) IsReportGroupValueClauseContext() {}

func NewReportGroupValueClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupValueClauseContext {
	var p = new(ReportGroupValueClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupValueClause

	return p
}

func (s *ReportGroupValueClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupValueClauseContext) VALUE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserVALUE, 0)
}

func (s *ReportGroupValueClauseContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *ReportGroupValueClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ReportGroupValueClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupValueClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupValueClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupValueClause(s)
	}
}

func (s *ReportGroupValueClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupValueClause(s)
	}
}

func (p *Cobol85Parser) ReportGroupValueClause() (localctx IReportGroupValueClauseContext) {
	localctx = NewReportGroupValueClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 394, Cobol85ParserRULE_reportGroupValueClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3007)
		p.Match(Cobol85ParserVALUE)
	}
	p.SetState(3009)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(3008)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(3011)
		p.Literal()
	}

	return localctx
}

// IProgramLibrarySectionContext is an interface to support dynamic dispatch.
type IProgramLibrarySectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProgramLibrarySectionContext differentiates from other interfaces.
	IsProgramLibrarySectionContext()
}

type ProgramLibrarySectionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProgramLibrarySectionContext() *ProgramLibrarySectionContext {
	var p = new(ProgramLibrarySectionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_programLibrarySection
	return p
}

func (*ProgramLibrarySectionContext) IsProgramLibrarySectionContext() {}

func NewProgramLibrarySectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProgramLibrarySectionContext {
	var p = new(ProgramLibrarySectionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_programLibrarySection

	return p
}

func (s *ProgramLibrarySectionContext) GetParser() antlr.Parser { return s.parser }

func (s *ProgramLibrarySectionContext) PROGRAM_LIBRARY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPROGRAM_LIBRARY, 0)
}

func (s *ProgramLibrarySectionContext) SECTION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSECTION, 0)
}

func (s *ProgramLibrarySectionContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *ProgramLibrarySectionContext) AllLibraryDescriptionEntry() []ILibraryDescriptionEntryContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILibraryDescriptionEntryContext)(nil)).Elem())
	var tst = make([]ILibraryDescriptionEntryContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILibraryDescriptionEntryContext)
		}
	}

	return tst
}

func (s *ProgramLibrarySectionContext) LibraryDescriptionEntry(i int) ILibraryDescriptionEntryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibraryDescriptionEntryContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILibraryDescriptionEntryContext)
}

func (s *ProgramLibrarySectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProgramLibrarySectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProgramLibrarySectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterProgramLibrarySection(s)
	}
}

func (s *ProgramLibrarySectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitProgramLibrarySection(s)
	}
}

func (p *Cobol85Parser) ProgramLibrarySection() (localctx IProgramLibrarySectionContext) {
	localctx = NewProgramLibrarySectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 396, Cobol85ParserRULE_programLibrarySection)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3013)
		p.Match(Cobol85ParserPROGRAM_LIBRARY)
	}
	{
		p.SetState(3014)
		p.Match(Cobol85ParserSECTION)
	}
	{
		p.SetState(3015)
		p.Match(Cobol85ParserDOT_FS)
	}
	p.SetState(3019)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserLB || _la == Cobol85ParserLD {
		{
			p.SetState(3016)
			p.LibraryDescriptionEntry()
		}

		p.SetState(3021)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ILibraryDescriptionEntryContext is an interface to support dynamic dispatch.
type ILibraryDescriptionEntryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibraryDescriptionEntryContext differentiates from other interfaces.
	IsLibraryDescriptionEntryContext()
}

type LibraryDescriptionEntryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibraryDescriptionEntryContext() *LibraryDescriptionEntryContext {
	var p = new(LibraryDescriptionEntryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_libraryDescriptionEntry
	return p
}

func (*LibraryDescriptionEntryContext) IsLibraryDescriptionEntryContext() {}

func NewLibraryDescriptionEntryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LibraryDescriptionEntryContext {
	var p = new(LibraryDescriptionEntryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_libraryDescriptionEntry

	return p
}

func (s *LibraryDescriptionEntryContext) GetParser() antlr.Parser { return s.parser }

func (s *LibraryDescriptionEntryContext) LibraryDescriptionEntryFormat1() ILibraryDescriptionEntryFormat1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibraryDescriptionEntryFormat1Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILibraryDescriptionEntryFormat1Context)
}

func (s *LibraryDescriptionEntryContext) LibraryDescriptionEntryFormat2() ILibraryDescriptionEntryFormat2Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibraryDescriptionEntryFormat2Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILibraryDescriptionEntryFormat2Context)
}

func (s *LibraryDescriptionEntryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LibraryDescriptionEntryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LibraryDescriptionEntryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLibraryDescriptionEntry(s)
	}
}

func (s *LibraryDescriptionEntryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLibraryDescriptionEntry(s)
	}
}

func (p *Cobol85Parser) LibraryDescriptionEntry() (localctx ILibraryDescriptionEntryContext) {
	localctx = NewLibraryDescriptionEntryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 398, Cobol85ParserRULE_libraryDescriptionEntry)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3024)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserLD:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3022)
			p.LibraryDescriptionEntryFormat1()
		}

	case Cobol85ParserLB:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3023)
			p.LibraryDescriptionEntryFormat2()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ILibraryDescriptionEntryFormat1Context is an interface to support dynamic dispatch.
type ILibraryDescriptionEntryFormat1Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibraryDescriptionEntryFormat1Context differentiates from other interfaces.
	IsLibraryDescriptionEntryFormat1Context()
}

type LibraryDescriptionEntryFormat1Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibraryDescriptionEntryFormat1Context() *LibraryDescriptionEntryFormat1Context {
	var p = new(LibraryDescriptionEntryFormat1Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_libraryDescriptionEntryFormat1
	return p
}

func (*LibraryDescriptionEntryFormat1Context) IsLibraryDescriptionEntryFormat1Context() {}

func NewLibraryDescriptionEntryFormat1Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LibraryDescriptionEntryFormat1Context {
	var p = new(LibraryDescriptionEntryFormat1Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_libraryDescriptionEntryFormat1

	return p
}

func (s *LibraryDescriptionEntryFormat1Context) GetParser() antlr.Parser { return s.parser }

func (s *LibraryDescriptionEntryFormat1Context) LD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLD, 0)
}

func (s *LibraryDescriptionEntryFormat1Context) LibraryName() ILibraryNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibraryNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILibraryNameContext)
}

func (s *LibraryDescriptionEntryFormat1Context) EXPORT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEXPORT, 0)
}

func (s *LibraryDescriptionEntryFormat1Context) LibraryAttributeClauseFormat1() ILibraryAttributeClauseFormat1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibraryAttributeClauseFormat1Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILibraryAttributeClauseFormat1Context)
}

func (s *LibraryDescriptionEntryFormat1Context) LibraryEntryProcedureClauseFormat1() ILibraryEntryProcedureClauseFormat1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibraryEntryProcedureClauseFormat1Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILibraryEntryProcedureClauseFormat1Context)
}

func (s *LibraryDescriptionEntryFormat1Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LibraryDescriptionEntryFormat1Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LibraryDescriptionEntryFormat1Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLibraryDescriptionEntryFormat1(s)
	}
}

func (s *LibraryDescriptionEntryFormat1Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLibraryDescriptionEntryFormat1(s)
	}
}

func (p *Cobol85Parser) LibraryDescriptionEntryFormat1() (localctx ILibraryDescriptionEntryFormat1Context) {
	localctx = NewLibraryDescriptionEntryFormat1Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 400, Cobol85ParserRULE_libraryDescriptionEntryFormat1)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3026)
		p.Match(Cobol85ParserLD)
	}
	{
		p.SetState(3027)
		p.LibraryName()
	}
	{
		p.SetState(3028)
		p.Match(Cobol85ParserEXPORT)
	}
	p.SetState(3030)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserATTRIBUTE {
		{
			p.SetState(3029)
			p.LibraryAttributeClauseFormat1()
		}

	}
	p.SetState(3033)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserENTRY_PROCEDURE {
		{
			p.SetState(3032)
			p.LibraryEntryProcedureClauseFormat1()
		}

	}

	return localctx
}

// ILibraryDescriptionEntryFormat2Context is an interface to support dynamic dispatch.
type ILibraryDescriptionEntryFormat2Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibraryDescriptionEntryFormat2Context differentiates from other interfaces.
	IsLibraryDescriptionEntryFormat2Context()
}

type LibraryDescriptionEntryFormat2Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibraryDescriptionEntryFormat2Context() *LibraryDescriptionEntryFormat2Context {
	var p = new(LibraryDescriptionEntryFormat2Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_libraryDescriptionEntryFormat2
	return p
}

func (*LibraryDescriptionEntryFormat2Context) IsLibraryDescriptionEntryFormat2Context() {}

func NewLibraryDescriptionEntryFormat2Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LibraryDescriptionEntryFormat2Context {
	var p = new(LibraryDescriptionEntryFormat2Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_libraryDescriptionEntryFormat2

	return p
}

func (s *LibraryDescriptionEntryFormat2Context) GetParser() antlr.Parser { return s.parser }

func (s *LibraryDescriptionEntryFormat2Context) LB() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLB, 0)
}

func (s *LibraryDescriptionEntryFormat2Context) LibraryName() ILibraryNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibraryNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILibraryNameContext)
}

func (s *LibraryDescriptionEntryFormat2Context) IMPORT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIMPORT, 0)
}

func (s *LibraryDescriptionEntryFormat2Context) LibraryIsGlobalClause() ILibraryIsGlobalClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibraryIsGlobalClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILibraryIsGlobalClauseContext)
}

func (s *LibraryDescriptionEntryFormat2Context) LibraryIsCommonClause() ILibraryIsCommonClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibraryIsCommonClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILibraryIsCommonClauseContext)
}

func (s *LibraryDescriptionEntryFormat2Context) AllLibraryAttributeClauseFormat2() []ILibraryAttributeClauseFormat2Context {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILibraryAttributeClauseFormat2Context)(nil)).Elem())
	var tst = make([]ILibraryAttributeClauseFormat2Context, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILibraryAttributeClauseFormat2Context)
		}
	}

	return tst
}

func (s *LibraryDescriptionEntryFormat2Context) LibraryAttributeClauseFormat2(i int) ILibraryAttributeClauseFormat2Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibraryAttributeClauseFormat2Context)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILibraryAttributeClauseFormat2Context)
}

func (s *LibraryDescriptionEntryFormat2Context) AllLibraryEntryProcedureClauseFormat2() []ILibraryEntryProcedureClauseFormat2Context {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILibraryEntryProcedureClauseFormat2Context)(nil)).Elem())
	var tst = make([]ILibraryEntryProcedureClauseFormat2Context, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILibraryEntryProcedureClauseFormat2Context)
		}
	}

	return tst
}

func (s *LibraryDescriptionEntryFormat2Context) LibraryEntryProcedureClauseFormat2(i int) ILibraryEntryProcedureClauseFormat2Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibraryEntryProcedureClauseFormat2Context)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILibraryEntryProcedureClauseFormat2Context)
}

func (s *LibraryDescriptionEntryFormat2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LibraryDescriptionEntryFormat2Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LibraryDescriptionEntryFormat2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLibraryDescriptionEntryFormat2(s)
	}
}

func (s *LibraryDescriptionEntryFormat2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLibraryDescriptionEntryFormat2(s)
	}
}

func (p *Cobol85Parser) LibraryDescriptionEntryFormat2() (localctx ILibraryDescriptionEntryFormat2Context) {
	localctx = NewLibraryDescriptionEntryFormat2Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 402, Cobol85ParserRULE_libraryDescriptionEntryFormat2)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3035)
		p.Match(Cobol85ParserLB)
	}
	{
		p.SetState(3036)
		p.LibraryName()
	}
	{
		p.SetState(3037)
		p.Match(Cobol85ParserIMPORT)
	}
	p.SetState(3039)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 365, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3038)
			p.LibraryIsGlobalClause()
		}

	}
	p.SetState(3042)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCOMMON || _la == Cobol85ParserIS {
		{
			p.SetState(3041)
			p.LibraryIsCommonClause()
		}

	}
	p.SetState(3048)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserATTRIBUTE || _la == Cobol85ParserENTRY_PROCEDURE {
		p.SetState(3046)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case Cobol85ParserATTRIBUTE:
			{
				p.SetState(3044)
				p.LibraryAttributeClauseFormat2()
			}

		case Cobol85ParserENTRY_PROCEDURE:
			{
				p.SetState(3045)
				p.LibraryEntryProcedureClauseFormat2()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(3050)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ILibraryAttributeClauseFormat1Context is an interface to support dynamic dispatch.
type ILibraryAttributeClauseFormat1Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibraryAttributeClauseFormat1Context differentiates from other interfaces.
	IsLibraryAttributeClauseFormat1Context()
}

type LibraryAttributeClauseFormat1Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibraryAttributeClauseFormat1Context() *LibraryAttributeClauseFormat1Context {
	var p = new(LibraryAttributeClauseFormat1Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_libraryAttributeClauseFormat1
	return p
}

func (*LibraryAttributeClauseFormat1Context) IsLibraryAttributeClauseFormat1Context() {}

func NewLibraryAttributeClauseFormat1Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LibraryAttributeClauseFormat1Context {
	var p = new(LibraryAttributeClauseFormat1Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_libraryAttributeClauseFormat1

	return p
}

func (s *LibraryAttributeClauseFormat1Context) GetParser() antlr.Parser { return s.parser }

func (s *LibraryAttributeClauseFormat1Context) ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserATTRIBUTE, 0)
}

func (s *LibraryAttributeClauseFormat1Context) SHARING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSHARING, 0)
}

func (s *LibraryAttributeClauseFormat1Context) DONTCARE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDONTCARE, 0)
}

func (s *LibraryAttributeClauseFormat1Context) PRIVATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPRIVATE, 0)
}

func (s *LibraryAttributeClauseFormat1Context) SHAREDBYRUNUNIT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSHAREDBYRUNUNIT, 0)
}

func (s *LibraryAttributeClauseFormat1Context) SHAREDBYALL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSHAREDBYALL, 0)
}

func (s *LibraryAttributeClauseFormat1Context) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *LibraryAttributeClauseFormat1Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LibraryAttributeClauseFormat1Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LibraryAttributeClauseFormat1Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLibraryAttributeClauseFormat1(s)
	}
}

func (s *LibraryAttributeClauseFormat1Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLibraryAttributeClauseFormat1(s)
	}
}

func (p *Cobol85Parser) LibraryAttributeClauseFormat1() (localctx ILibraryAttributeClauseFormat1Context) {
	localctx = NewLibraryAttributeClauseFormat1Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 404, Cobol85ParserRULE_libraryAttributeClauseFormat1)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3051)
		p.Match(Cobol85ParserATTRIBUTE)
	}
	p.SetState(3057)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserSHARING {
		{
			p.SetState(3052)
			p.Match(Cobol85ParserSHARING)
		}
		p.SetState(3054)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserIS {
			{
				p.SetState(3053)
				p.Match(Cobol85ParserIS)
			}

		}
		{
			p.SetState(3056)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85ParserDONTCARE || _la == Cobol85ParserPRIVATE || _la == Cobol85ParserSHAREDBYALL || _la == Cobol85ParserSHAREDBYRUNUNIT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

	return localctx
}

// ILibraryAttributeClauseFormat2Context is an interface to support dynamic dispatch.
type ILibraryAttributeClauseFormat2Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibraryAttributeClauseFormat2Context differentiates from other interfaces.
	IsLibraryAttributeClauseFormat2Context()
}

type LibraryAttributeClauseFormat2Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibraryAttributeClauseFormat2Context() *LibraryAttributeClauseFormat2Context {
	var p = new(LibraryAttributeClauseFormat2Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_libraryAttributeClauseFormat2
	return p
}

func (*LibraryAttributeClauseFormat2Context) IsLibraryAttributeClauseFormat2Context() {}

func NewLibraryAttributeClauseFormat2Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LibraryAttributeClauseFormat2Context {
	var p = new(LibraryAttributeClauseFormat2Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_libraryAttributeClauseFormat2

	return p
}

func (s *LibraryAttributeClauseFormat2Context) GetParser() antlr.Parser { return s.parser }

func (s *LibraryAttributeClauseFormat2Context) ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserATTRIBUTE, 0)
}

func (s *LibraryAttributeClauseFormat2Context) LibraryAttributeFunction() ILibraryAttributeFunctionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibraryAttributeFunctionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILibraryAttributeFunctionContext)
}

func (s *LibraryAttributeClauseFormat2Context) LIBACCESS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLIBACCESS, 0)
}

func (s *LibraryAttributeClauseFormat2Context) LibraryAttributeParameter() ILibraryAttributeParameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibraryAttributeParameterContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILibraryAttributeParameterContext)
}

func (s *LibraryAttributeClauseFormat2Context) LibraryAttributeTitle() ILibraryAttributeTitleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibraryAttributeTitleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILibraryAttributeTitleContext)
}

func (s *LibraryAttributeClauseFormat2Context) BYFUNCTION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBYFUNCTION, 0)
}

func (s *LibraryAttributeClauseFormat2Context) BYTITLE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBYTITLE, 0)
}

func (s *LibraryAttributeClauseFormat2Context) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *LibraryAttributeClauseFormat2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LibraryAttributeClauseFormat2Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LibraryAttributeClauseFormat2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLibraryAttributeClauseFormat2(s)
	}
}

func (s *LibraryAttributeClauseFormat2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLibraryAttributeClauseFormat2(s)
	}
}

func (p *Cobol85Parser) LibraryAttributeClauseFormat2() (localctx ILibraryAttributeClauseFormat2Context) {
	localctx = NewLibraryAttributeClauseFormat2Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 406, Cobol85ParserRULE_libraryAttributeClauseFormat2)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3059)
		p.Match(Cobol85ParserATTRIBUTE)
	}
	p.SetState(3061)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFUNCTIONNAME {
		{
			p.SetState(3060)
			p.LibraryAttributeFunction()
		}

	}
	p.SetState(3068)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserLIBACCESS {
		{
			p.SetState(3063)
			p.Match(Cobol85ParserLIBACCESS)
		}
		p.SetState(3065)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserIS {
			{
				p.SetState(3064)
				p.Match(Cobol85ParserIS)
			}

		}
		{
			p.SetState(3067)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85ParserBYFUNCTION || _la == Cobol85ParserBYTITLE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(3071)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserLIBPARAMETER {
		{
			p.SetState(3070)
			p.LibraryAttributeParameter()
		}

	}
	p.SetState(3074)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserTITLE {
		{
			p.SetState(3073)
			p.LibraryAttributeTitle()
		}

	}

	return localctx
}

// ILibraryAttributeFunctionContext is an interface to support dynamic dispatch.
type ILibraryAttributeFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibraryAttributeFunctionContext differentiates from other interfaces.
	IsLibraryAttributeFunctionContext()
}

type LibraryAttributeFunctionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibraryAttributeFunctionContext() *LibraryAttributeFunctionContext {
	var p = new(LibraryAttributeFunctionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_libraryAttributeFunction
	return p
}

func (*LibraryAttributeFunctionContext) IsLibraryAttributeFunctionContext() {}

func NewLibraryAttributeFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LibraryAttributeFunctionContext {
	var p = new(LibraryAttributeFunctionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_libraryAttributeFunction

	return p
}

func (s *LibraryAttributeFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *LibraryAttributeFunctionContext) FUNCTIONNAME() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFUNCTIONNAME, 0)
}

func (s *LibraryAttributeFunctionContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *LibraryAttributeFunctionContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *LibraryAttributeFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LibraryAttributeFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LibraryAttributeFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLibraryAttributeFunction(s)
	}
}

func (s *LibraryAttributeFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLibraryAttributeFunction(s)
	}
}

func (p *Cobol85Parser) LibraryAttributeFunction() (localctx ILibraryAttributeFunctionContext) {
	localctx = NewLibraryAttributeFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 408, Cobol85ParserRULE_libraryAttributeFunction)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3076)
		p.Match(Cobol85ParserFUNCTIONNAME)
	}
	{
		p.SetState(3077)
		p.Match(Cobol85ParserIS)
	}
	{
		p.SetState(3078)
		p.Literal()
	}

	return localctx
}

// ILibraryAttributeParameterContext is an interface to support dynamic dispatch.
type ILibraryAttributeParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibraryAttributeParameterContext differentiates from other interfaces.
	IsLibraryAttributeParameterContext()
}

type LibraryAttributeParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibraryAttributeParameterContext() *LibraryAttributeParameterContext {
	var p = new(LibraryAttributeParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_libraryAttributeParameter
	return p
}

func (*LibraryAttributeParameterContext) IsLibraryAttributeParameterContext() {}

func NewLibraryAttributeParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LibraryAttributeParameterContext {
	var p = new(LibraryAttributeParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_libraryAttributeParameter

	return p
}

func (s *LibraryAttributeParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *LibraryAttributeParameterContext) LIBPARAMETER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLIBPARAMETER, 0)
}

func (s *LibraryAttributeParameterContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *LibraryAttributeParameterContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *LibraryAttributeParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LibraryAttributeParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LibraryAttributeParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLibraryAttributeParameter(s)
	}
}

func (s *LibraryAttributeParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLibraryAttributeParameter(s)
	}
}

func (p *Cobol85Parser) LibraryAttributeParameter() (localctx ILibraryAttributeParameterContext) {
	localctx = NewLibraryAttributeParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 410, Cobol85ParserRULE_libraryAttributeParameter)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3080)
		p.Match(Cobol85ParserLIBPARAMETER)
	}
	p.SetState(3082)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(3081)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(3084)
		p.Literal()
	}

	return localctx
}

// ILibraryAttributeTitleContext is an interface to support dynamic dispatch.
type ILibraryAttributeTitleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibraryAttributeTitleContext differentiates from other interfaces.
	IsLibraryAttributeTitleContext()
}

type LibraryAttributeTitleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibraryAttributeTitleContext() *LibraryAttributeTitleContext {
	var p = new(LibraryAttributeTitleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_libraryAttributeTitle
	return p
}

func (*LibraryAttributeTitleContext) IsLibraryAttributeTitleContext() {}

func NewLibraryAttributeTitleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LibraryAttributeTitleContext {
	var p = new(LibraryAttributeTitleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_libraryAttributeTitle

	return p
}

func (s *LibraryAttributeTitleContext) GetParser() antlr.Parser { return s.parser }

func (s *LibraryAttributeTitleContext) TITLE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTITLE, 0)
}

func (s *LibraryAttributeTitleContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *LibraryAttributeTitleContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *LibraryAttributeTitleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LibraryAttributeTitleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LibraryAttributeTitleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLibraryAttributeTitle(s)
	}
}

func (s *LibraryAttributeTitleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLibraryAttributeTitle(s)
	}
}

func (p *Cobol85Parser) LibraryAttributeTitle() (localctx ILibraryAttributeTitleContext) {
	localctx = NewLibraryAttributeTitleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 412, Cobol85ParserRULE_libraryAttributeTitle)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3086)
		p.Match(Cobol85ParserTITLE)
	}
	p.SetState(3088)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(3087)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(3090)
		p.Literal()
	}

	return localctx
}

// ILibraryEntryProcedureClauseFormat1Context is an interface to support dynamic dispatch.
type ILibraryEntryProcedureClauseFormat1Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibraryEntryProcedureClauseFormat1Context differentiates from other interfaces.
	IsLibraryEntryProcedureClauseFormat1Context()
}

type LibraryEntryProcedureClauseFormat1Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibraryEntryProcedureClauseFormat1Context() *LibraryEntryProcedureClauseFormat1Context {
	var p = new(LibraryEntryProcedureClauseFormat1Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_libraryEntryProcedureClauseFormat1
	return p
}

func (*LibraryEntryProcedureClauseFormat1Context) IsLibraryEntryProcedureClauseFormat1Context() {}

func NewLibraryEntryProcedureClauseFormat1Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LibraryEntryProcedureClauseFormat1Context {
	var p = new(LibraryEntryProcedureClauseFormat1Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_libraryEntryProcedureClauseFormat1

	return p
}

func (s *LibraryEntryProcedureClauseFormat1Context) GetParser() antlr.Parser { return s.parser }

func (s *LibraryEntryProcedureClauseFormat1Context) ENTRY_PROCEDURE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserENTRY_PROCEDURE, 0)
}

func (s *LibraryEntryProcedureClauseFormat1Context) ProgramName() IProgramNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProgramNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProgramNameContext)
}

func (s *LibraryEntryProcedureClauseFormat1Context) LibraryEntryProcedureForClause() ILibraryEntryProcedureForClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibraryEntryProcedureForClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILibraryEntryProcedureForClauseContext)
}

func (s *LibraryEntryProcedureClauseFormat1Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LibraryEntryProcedureClauseFormat1Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LibraryEntryProcedureClauseFormat1Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLibraryEntryProcedureClauseFormat1(s)
	}
}

func (s *LibraryEntryProcedureClauseFormat1Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLibraryEntryProcedureClauseFormat1(s)
	}
}

func (p *Cobol85Parser) LibraryEntryProcedureClauseFormat1() (localctx ILibraryEntryProcedureClauseFormat1Context) {
	localctx = NewLibraryEntryProcedureClauseFormat1Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 414, Cobol85ParserRULE_libraryEntryProcedureClauseFormat1)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3092)
		p.Match(Cobol85ParserENTRY_PROCEDURE)
	}
	{
		p.SetState(3093)
		p.ProgramName()
	}
	p.SetState(3095)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFOR {
		{
			p.SetState(3094)
			p.LibraryEntryProcedureForClause()
		}

	}

	return localctx
}

// ILibraryEntryProcedureClauseFormat2Context is an interface to support dynamic dispatch.
type ILibraryEntryProcedureClauseFormat2Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibraryEntryProcedureClauseFormat2Context differentiates from other interfaces.
	IsLibraryEntryProcedureClauseFormat2Context()
}

type LibraryEntryProcedureClauseFormat2Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibraryEntryProcedureClauseFormat2Context() *LibraryEntryProcedureClauseFormat2Context {
	var p = new(LibraryEntryProcedureClauseFormat2Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_libraryEntryProcedureClauseFormat2
	return p
}

func (*LibraryEntryProcedureClauseFormat2Context) IsLibraryEntryProcedureClauseFormat2Context() {}

func NewLibraryEntryProcedureClauseFormat2Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LibraryEntryProcedureClauseFormat2Context {
	var p = new(LibraryEntryProcedureClauseFormat2Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_libraryEntryProcedureClauseFormat2

	return p
}

func (s *LibraryEntryProcedureClauseFormat2Context) GetParser() antlr.Parser { return s.parser }

func (s *LibraryEntryProcedureClauseFormat2Context) ENTRY_PROCEDURE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserENTRY_PROCEDURE, 0)
}

func (s *LibraryEntryProcedureClauseFormat2Context) ProgramName() IProgramNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProgramNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProgramNameContext)
}

func (s *LibraryEntryProcedureClauseFormat2Context) LibraryEntryProcedureForClause() ILibraryEntryProcedureForClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibraryEntryProcedureForClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILibraryEntryProcedureForClauseContext)
}

func (s *LibraryEntryProcedureClauseFormat2Context) LibraryEntryProcedureWithClause() ILibraryEntryProcedureWithClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibraryEntryProcedureWithClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILibraryEntryProcedureWithClauseContext)
}

func (s *LibraryEntryProcedureClauseFormat2Context) LibraryEntryProcedureUsingClause() ILibraryEntryProcedureUsingClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibraryEntryProcedureUsingClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILibraryEntryProcedureUsingClauseContext)
}

func (s *LibraryEntryProcedureClauseFormat2Context) LibraryEntryProcedureGivingClause() ILibraryEntryProcedureGivingClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibraryEntryProcedureGivingClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILibraryEntryProcedureGivingClauseContext)
}

func (s *LibraryEntryProcedureClauseFormat2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LibraryEntryProcedureClauseFormat2Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LibraryEntryProcedureClauseFormat2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLibraryEntryProcedureClauseFormat2(s)
	}
}

func (s *LibraryEntryProcedureClauseFormat2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLibraryEntryProcedureClauseFormat2(s)
	}
}

func (p *Cobol85Parser) LibraryEntryProcedureClauseFormat2() (localctx ILibraryEntryProcedureClauseFormat2Context) {
	localctx = NewLibraryEntryProcedureClauseFormat2Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 416, Cobol85ParserRULE_libraryEntryProcedureClauseFormat2)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3097)
		p.Match(Cobol85ParserENTRY_PROCEDURE)
	}
	{
		p.SetState(3098)
		p.ProgramName()
	}
	p.SetState(3100)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFOR {
		{
			p.SetState(3099)
			p.LibraryEntryProcedureForClause()
		}

	}
	p.SetState(3103)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserWITH {
		{
			p.SetState(3102)
			p.LibraryEntryProcedureWithClause()
		}

	}
	p.SetState(3106)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserUSING {
		{
			p.SetState(3105)
			p.LibraryEntryProcedureUsingClause()
		}

	}
	p.SetState(3109)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserGIVING {
		{
			p.SetState(3108)
			p.LibraryEntryProcedureGivingClause()
		}

	}

	return localctx
}

// ILibraryEntryProcedureForClauseContext is an interface to support dynamic dispatch.
type ILibraryEntryProcedureForClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibraryEntryProcedureForClauseContext differentiates from other interfaces.
	IsLibraryEntryProcedureForClauseContext()
}

type LibraryEntryProcedureForClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibraryEntryProcedureForClauseContext() *LibraryEntryProcedureForClauseContext {
	var p = new(LibraryEntryProcedureForClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_libraryEntryProcedureForClause
	return p
}

func (*LibraryEntryProcedureForClauseContext) IsLibraryEntryProcedureForClauseContext() {}

func NewLibraryEntryProcedureForClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LibraryEntryProcedureForClauseContext {
	var p = new(LibraryEntryProcedureForClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_libraryEntryProcedureForClause

	return p
}

func (s *LibraryEntryProcedureForClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LibraryEntryProcedureForClauseContext) FOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOR, 0)
}

func (s *LibraryEntryProcedureForClauseContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *LibraryEntryProcedureForClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LibraryEntryProcedureForClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LibraryEntryProcedureForClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLibraryEntryProcedureForClause(s)
	}
}

func (s *LibraryEntryProcedureForClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLibraryEntryProcedureForClause(s)
	}
}

func (p *Cobol85Parser) LibraryEntryProcedureForClause() (localctx ILibraryEntryProcedureForClauseContext) {
	localctx = NewLibraryEntryProcedureForClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 418, Cobol85ParserRULE_libraryEntryProcedureForClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3111)
		p.Match(Cobol85ParserFOR)
	}
	{
		p.SetState(3112)
		p.Literal()
	}

	return localctx
}

// ILibraryEntryProcedureGivingClauseContext is an interface to support dynamic dispatch.
type ILibraryEntryProcedureGivingClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibraryEntryProcedureGivingClauseContext differentiates from other interfaces.
	IsLibraryEntryProcedureGivingClauseContext()
}

type LibraryEntryProcedureGivingClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibraryEntryProcedureGivingClauseContext() *LibraryEntryProcedureGivingClauseContext {
	var p = new(LibraryEntryProcedureGivingClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_libraryEntryProcedureGivingClause
	return p
}

func (*LibraryEntryProcedureGivingClauseContext) IsLibraryEntryProcedureGivingClauseContext() {}

func NewLibraryEntryProcedureGivingClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LibraryEntryProcedureGivingClauseContext {
	var p = new(LibraryEntryProcedureGivingClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_libraryEntryProcedureGivingClause

	return p
}

func (s *LibraryEntryProcedureGivingClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LibraryEntryProcedureGivingClauseContext) GIVING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserGIVING, 0)
}

func (s *LibraryEntryProcedureGivingClauseContext) DataName() IDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *LibraryEntryProcedureGivingClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LibraryEntryProcedureGivingClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LibraryEntryProcedureGivingClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLibraryEntryProcedureGivingClause(s)
	}
}

func (s *LibraryEntryProcedureGivingClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLibraryEntryProcedureGivingClause(s)
	}
}

func (p *Cobol85Parser) LibraryEntryProcedureGivingClause() (localctx ILibraryEntryProcedureGivingClauseContext) {
	localctx = NewLibraryEntryProcedureGivingClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 420, Cobol85ParserRULE_libraryEntryProcedureGivingClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3114)
		p.Match(Cobol85ParserGIVING)
	}
	{
		p.SetState(3115)
		p.DataName()
	}

	return localctx
}

// ILibraryEntryProcedureUsingClauseContext is an interface to support dynamic dispatch.
type ILibraryEntryProcedureUsingClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibraryEntryProcedureUsingClauseContext differentiates from other interfaces.
	IsLibraryEntryProcedureUsingClauseContext()
}

type LibraryEntryProcedureUsingClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibraryEntryProcedureUsingClauseContext() *LibraryEntryProcedureUsingClauseContext {
	var p = new(LibraryEntryProcedureUsingClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_libraryEntryProcedureUsingClause
	return p
}

func (*LibraryEntryProcedureUsingClauseContext) IsLibraryEntryProcedureUsingClauseContext() {}

func NewLibraryEntryProcedureUsingClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LibraryEntryProcedureUsingClauseContext {
	var p = new(LibraryEntryProcedureUsingClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_libraryEntryProcedureUsingClause

	return p
}

func (s *LibraryEntryProcedureUsingClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LibraryEntryProcedureUsingClauseContext) USING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserUSING, 0)
}

func (s *LibraryEntryProcedureUsingClauseContext) AllLibraryEntryProcedureUsingName() []ILibraryEntryProcedureUsingNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILibraryEntryProcedureUsingNameContext)(nil)).Elem())
	var tst = make([]ILibraryEntryProcedureUsingNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILibraryEntryProcedureUsingNameContext)
		}
	}

	return tst
}

func (s *LibraryEntryProcedureUsingClauseContext) LibraryEntryProcedureUsingName(i int) ILibraryEntryProcedureUsingNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibraryEntryProcedureUsingNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILibraryEntryProcedureUsingNameContext)
}

func (s *LibraryEntryProcedureUsingClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LibraryEntryProcedureUsingClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LibraryEntryProcedureUsingClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLibraryEntryProcedureUsingClause(s)
	}
}

func (s *LibraryEntryProcedureUsingClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLibraryEntryProcedureUsingClause(s)
	}
}

func (p *Cobol85Parser) LibraryEntryProcedureUsingClause() (localctx ILibraryEntryProcedureUsingClauseContext) {
	localctx = NewLibraryEntryProcedureUsingClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 422, Cobol85ParserRULE_libraryEntryProcedureUsingClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3117)
		p.Match(Cobol85ParserUSING)
	}
	p.SetState(3119)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(3118)
				p.LibraryEntryProcedureUsingName()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(3121)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 383, p.GetParserRuleContext())
	}

	return localctx
}

// ILibraryEntryProcedureUsingNameContext is an interface to support dynamic dispatch.
type ILibraryEntryProcedureUsingNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibraryEntryProcedureUsingNameContext differentiates from other interfaces.
	IsLibraryEntryProcedureUsingNameContext()
}

type LibraryEntryProcedureUsingNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibraryEntryProcedureUsingNameContext() *LibraryEntryProcedureUsingNameContext {
	var p = new(LibraryEntryProcedureUsingNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_libraryEntryProcedureUsingName
	return p
}

func (*LibraryEntryProcedureUsingNameContext) IsLibraryEntryProcedureUsingNameContext() {}

func NewLibraryEntryProcedureUsingNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LibraryEntryProcedureUsingNameContext {
	var p = new(LibraryEntryProcedureUsingNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_libraryEntryProcedureUsingName

	return p
}

func (s *LibraryEntryProcedureUsingNameContext) GetParser() antlr.Parser { return s.parser }

func (s *LibraryEntryProcedureUsingNameContext) DataName() IDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *LibraryEntryProcedureUsingNameContext) FileName() IFileNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *LibraryEntryProcedureUsingNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LibraryEntryProcedureUsingNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LibraryEntryProcedureUsingNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLibraryEntryProcedureUsingName(s)
	}
}

func (s *LibraryEntryProcedureUsingNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLibraryEntryProcedureUsingName(s)
	}
}

func (p *Cobol85Parser) LibraryEntryProcedureUsingName() (localctx ILibraryEntryProcedureUsingNameContext) {
	localctx = NewLibraryEntryProcedureUsingNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 424, Cobol85ParserRULE_libraryEntryProcedureUsingName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3125)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 384, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3123)
			p.DataName()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3124)
			p.FileName()
		}

	}

	return localctx
}

// ILibraryEntryProcedureWithClauseContext is an interface to support dynamic dispatch.
type ILibraryEntryProcedureWithClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibraryEntryProcedureWithClauseContext differentiates from other interfaces.
	IsLibraryEntryProcedureWithClauseContext()
}

type LibraryEntryProcedureWithClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibraryEntryProcedureWithClauseContext() *LibraryEntryProcedureWithClauseContext {
	var p = new(LibraryEntryProcedureWithClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_libraryEntryProcedureWithClause
	return p
}

func (*LibraryEntryProcedureWithClauseContext) IsLibraryEntryProcedureWithClauseContext() {}

func NewLibraryEntryProcedureWithClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LibraryEntryProcedureWithClauseContext {
	var p = new(LibraryEntryProcedureWithClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_libraryEntryProcedureWithClause

	return p
}

func (s *LibraryEntryProcedureWithClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LibraryEntryProcedureWithClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWITH, 0)
}

func (s *LibraryEntryProcedureWithClauseContext) AllLibraryEntryProcedureWithName() []ILibraryEntryProcedureWithNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILibraryEntryProcedureWithNameContext)(nil)).Elem())
	var tst = make([]ILibraryEntryProcedureWithNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILibraryEntryProcedureWithNameContext)
		}
	}

	return tst
}

func (s *LibraryEntryProcedureWithClauseContext) LibraryEntryProcedureWithName(i int) ILibraryEntryProcedureWithNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibraryEntryProcedureWithNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILibraryEntryProcedureWithNameContext)
}

func (s *LibraryEntryProcedureWithClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LibraryEntryProcedureWithClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LibraryEntryProcedureWithClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLibraryEntryProcedureWithClause(s)
	}
}

func (s *LibraryEntryProcedureWithClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLibraryEntryProcedureWithClause(s)
	}
}

func (p *Cobol85Parser) LibraryEntryProcedureWithClause() (localctx ILibraryEntryProcedureWithClauseContext) {
	localctx = NewLibraryEntryProcedureWithClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 426, Cobol85ParserRULE_libraryEntryProcedureWithClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3127)
		p.Match(Cobol85ParserWITH)
	}
	p.SetState(3129)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(3128)
				p.LibraryEntryProcedureWithName()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(3131)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 385, p.GetParserRuleContext())
	}

	return localctx
}

// ILibraryEntryProcedureWithNameContext is an interface to support dynamic dispatch.
type ILibraryEntryProcedureWithNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibraryEntryProcedureWithNameContext differentiates from other interfaces.
	IsLibraryEntryProcedureWithNameContext()
}

type LibraryEntryProcedureWithNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibraryEntryProcedureWithNameContext() *LibraryEntryProcedureWithNameContext {
	var p = new(LibraryEntryProcedureWithNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_libraryEntryProcedureWithName
	return p
}

func (*LibraryEntryProcedureWithNameContext) IsLibraryEntryProcedureWithNameContext() {}

func NewLibraryEntryProcedureWithNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LibraryEntryProcedureWithNameContext {
	var p = new(LibraryEntryProcedureWithNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_libraryEntryProcedureWithName

	return p
}

func (s *LibraryEntryProcedureWithNameContext) GetParser() antlr.Parser { return s.parser }

func (s *LibraryEntryProcedureWithNameContext) LocalName() ILocalNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILocalNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILocalNameContext)
}

func (s *LibraryEntryProcedureWithNameContext) FileName() IFileNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *LibraryEntryProcedureWithNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LibraryEntryProcedureWithNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LibraryEntryProcedureWithNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLibraryEntryProcedureWithName(s)
	}
}

func (s *LibraryEntryProcedureWithNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLibraryEntryProcedureWithName(s)
	}
}

func (p *Cobol85Parser) LibraryEntryProcedureWithName() (localctx ILibraryEntryProcedureWithNameContext) {
	localctx = NewLibraryEntryProcedureWithNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 428, Cobol85ParserRULE_libraryEntryProcedureWithName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3135)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 386, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3133)
			p.LocalName()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3134)
			p.FileName()
		}

	}

	return localctx
}

// ILibraryIsCommonClauseContext is an interface to support dynamic dispatch.
type ILibraryIsCommonClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibraryIsCommonClauseContext differentiates from other interfaces.
	IsLibraryIsCommonClauseContext()
}

type LibraryIsCommonClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibraryIsCommonClauseContext() *LibraryIsCommonClauseContext {
	var p = new(LibraryIsCommonClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_libraryIsCommonClause
	return p
}

func (*LibraryIsCommonClauseContext) IsLibraryIsCommonClauseContext() {}

func NewLibraryIsCommonClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LibraryIsCommonClauseContext {
	var p = new(LibraryIsCommonClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_libraryIsCommonClause

	return p
}

func (s *LibraryIsCommonClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LibraryIsCommonClauseContext) COMMON() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMMON, 0)
}

func (s *LibraryIsCommonClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *LibraryIsCommonClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LibraryIsCommonClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LibraryIsCommonClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLibraryIsCommonClause(s)
	}
}

func (s *LibraryIsCommonClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLibraryIsCommonClause(s)
	}
}

func (p *Cobol85Parser) LibraryIsCommonClause() (localctx ILibraryIsCommonClauseContext) {
	localctx = NewLibraryIsCommonClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 430, Cobol85ParserRULE_libraryIsCommonClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3138)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(3137)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(3140)
		p.Match(Cobol85ParserCOMMON)
	}

	return localctx
}

// ILibraryIsGlobalClauseContext is an interface to support dynamic dispatch.
type ILibraryIsGlobalClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibraryIsGlobalClauseContext differentiates from other interfaces.
	IsLibraryIsGlobalClauseContext()
}

type LibraryIsGlobalClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibraryIsGlobalClauseContext() *LibraryIsGlobalClauseContext {
	var p = new(LibraryIsGlobalClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_libraryIsGlobalClause
	return p
}

func (*LibraryIsGlobalClauseContext) IsLibraryIsGlobalClauseContext() {}

func NewLibraryIsGlobalClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LibraryIsGlobalClauseContext {
	var p = new(LibraryIsGlobalClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_libraryIsGlobalClause

	return p
}

func (s *LibraryIsGlobalClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LibraryIsGlobalClauseContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserGLOBAL, 0)
}

func (s *LibraryIsGlobalClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *LibraryIsGlobalClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LibraryIsGlobalClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LibraryIsGlobalClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLibraryIsGlobalClause(s)
	}
}

func (s *LibraryIsGlobalClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLibraryIsGlobalClause(s)
	}
}

func (p *Cobol85Parser) LibraryIsGlobalClause() (localctx ILibraryIsGlobalClauseContext) {
	localctx = NewLibraryIsGlobalClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 432, Cobol85ParserRULE_libraryIsGlobalClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3143)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(3142)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(3145)
		p.Match(Cobol85ParserGLOBAL)
	}

	return localctx
}

// IDataDescriptionEntryContext is an interface to support dynamic dispatch.
type IDataDescriptionEntryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataDescriptionEntryContext differentiates from other interfaces.
	IsDataDescriptionEntryContext()
}

type DataDescriptionEntryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataDescriptionEntryContext() *DataDescriptionEntryContext {
	var p = new(DataDescriptionEntryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataDescriptionEntry
	return p
}

func (*DataDescriptionEntryContext) IsDataDescriptionEntryContext() {}

func NewDataDescriptionEntryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataDescriptionEntryContext {
	var p = new(DataDescriptionEntryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataDescriptionEntry

	return p
}

func (s *DataDescriptionEntryContext) GetParser() antlr.Parser { return s.parser }

func (s *DataDescriptionEntryContext) DataDescriptionEntryFormat1() IDataDescriptionEntryFormat1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataDescriptionEntryFormat1Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataDescriptionEntryFormat1Context)
}

func (s *DataDescriptionEntryContext) DataDescriptionEntryFormat2() IDataDescriptionEntryFormat2Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataDescriptionEntryFormat2Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataDescriptionEntryFormat2Context)
}

func (s *DataDescriptionEntryContext) DataDescriptionEntryFormat3() IDataDescriptionEntryFormat3Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataDescriptionEntryFormat3Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataDescriptionEntryFormat3Context)
}

func (s *DataDescriptionEntryContext) DataDescriptionEntryExecSql() IDataDescriptionEntryExecSqlContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataDescriptionEntryExecSqlContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataDescriptionEntryExecSqlContext)
}

func (s *DataDescriptionEntryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataDescriptionEntryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataDescriptionEntryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataDescriptionEntry(s)
	}
}

func (s *DataDescriptionEntryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataDescriptionEntry(s)
	}
}

func (p *Cobol85Parser) DataDescriptionEntry() (localctx IDataDescriptionEntryContext) {
	localctx = NewDataDescriptionEntryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 434, Cobol85ParserRULE_dataDescriptionEntry)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3151)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserLEVEL_NUMBER_77, Cobol85ParserINTEGERLITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3147)
			p.DataDescriptionEntryFormat1()
		}

	case Cobol85ParserLEVEL_NUMBER_66:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3148)
			p.DataDescriptionEntryFormat2()
		}

	case Cobol85ParserLEVEL_NUMBER_88:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3149)
			p.DataDescriptionEntryFormat3()
		}

	case Cobol85ParserEXECSQLLINE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3150)
			p.DataDescriptionEntryExecSql()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDataDescriptionEntryFormat1Context is an interface to support dynamic dispatch.
type IDataDescriptionEntryFormat1Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataDescriptionEntryFormat1Context differentiates from other interfaces.
	IsDataDescriptionEntryFormat1Context()
}

type DataDescriptionEntryFormat1Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataDescriptionEntryFormat1Context() *DataDescriptionEntryFormat1Context {
	var p = new(DataDescriptionEntryFormat1Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataDescriptionEntryFormat1
	return p
}

func (*DataDescriptionEntryFormat1Context) IsDataDescriptionEntryFormat1Context() {}

func NewDataDescriptionEntryFormat1Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataDescriptionEntryFormat1Context {
	var p = new(DataDescriptionEntryFormat1Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataDescriptionEntryFormat1

	return p
}

func (s *DataDescriptionEntryFormat1Context) GetParser() antlr.Parser { return s.parser }

func (s *DataDescriptionEntryFormat1Context) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *DataDescriptionEntryFormat1Context) INTEGERLITERAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINTEGERLITERAL, 0)
}

func (s *DataDescriptionEntryFormat1Context) LEVEL_NUMBER_77() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLEVEL_NUMBER_77, 0)
}

func (s *DataDescriptionEntryFormat1Context) FILLER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFILLER, 0)
}

func (s *DataDescriptionEntryFormat1Context) DataName() IDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *DataDescriptionEntryFormat1Context) AllDataRedefinesClause() []IDataRedefinesClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDataRedefinesClauseContext)(nil)).Elem())
	var tst = make([]IDataRedefinesClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDataRedefinesClauseContext)
		}
	}

	return tst
}

func (s *DataDescriptionEntryFormat1Context) DataRedefinesClause(i int) IDataRedefinesClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataRedefinesClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDataRedefinesClauseContext)
}

func (s *DataDescriptionEntryFormat1Context) AllDataIntegerStringClause() []IDataIntegerStringClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDataIntegerStringClauseContext)(nil)).Elem())
	var tst = make([]IDataIntegerStringClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDataIntegerStringClauseContext)
		}
	}

	return tst
}

func (s *DataDescriptionEntryFormat1Context) DataIntegerStringClause(i int) IDataIntegerStringClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataIntegerStringClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDataIntegerStringClauseContext)
}

func (s *DataDescriptionEntryFormat1Context) AllDataExternalClause() []IDataExternalClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDataExternalClauseContext)(nil)).Elem())
	var tst = make([]IDataExternalClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDataExternalClauseContext)
		}
	}

	return tst
}

func (s *DataDescriptionEntryFormat1Context) DataExternalClause(i int) IDataExternalClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataExternalClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDataExternalClauseContext)
}

func (s *DataDescriptionEntryFormat1Context) AllDataGlobalClause() []IDataGlobalClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDataGlobalClauseContext)(nil)).Elem())
	var tst = make([]IDataGlobalClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDataGlobalClauseContext)
		}
	}

	return tst
}

func (s *DataDescriptionEntryFormat1Context) DataGlobalClause(i int) IDataGlobalClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataGlobalClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDataGlobalClauseContext)
}

func (s *DataDescriptionEntryFormat1Context) AllDataTypeDefClause() []IDataTypeDefClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDataTypeDefClauseContext)(nil)).Elem())
	var tst = make([]IDataTypeDefClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDataTypeDefClauseContext)
		}
	}

	return tst
}

func (s *DataDescriptionEntryFormat1Context) DataTypeDefClause(i int) IDataTypeDefClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataTypeDefClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDataTypeDefClauseContext)
}

func (s *DataDescriptionEntryFormat1Context) AllDataThreadLocalClause() []IDataThreadLocalClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDataThreadLocalClauseContext)(nil)).Elem())
	var tst = make([]IDataThreadLocalClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDataThreadLocalClauseContext)
		}
	}

	return tst
}

func (s *DataDescriptionEntryFormat1Context) DataThreadLocalClause(i int) IDataThreadLocalClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataThreadLocalClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDataThreadLocalClauseContext)
}

func (s *DataDescriptionEntryFormat1Context) AllDataPictureClause() []IDataPictureClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDataPictureClauseContext)(nil)).Elem())
	var tst = make([]IDataPictureClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDataPictureClauseContext)
		}
	}

	return tst
}

func (s *DataDescriptionEntryFormat1Context) DataPictureClause(i int) IDataPictureClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataPictureClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDataPictureClauseContext)
}

func (s *DataDescriptionEntryFormat1Context) AllDataCommonOwnLocalClause() []IDataCommonOwnLocalClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDataCommonOwnLocalClauseContext)(nil)).Elem())
	var tst = make([]IDataCommonOwnLocalClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDataCommonOwnLocalClauseContext)
		}
	}

	return tst
}

func (s *DataDescriptionEntryFormat1Context) DataCommonOwnLocalClause(i int) IDataCommonOwnLocalClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataCommonOwnLocalClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDataCommonOwnLocalClauseContext)
}

func (s *DataDescriptionEntryFormat1Context) AllDataTypeClause() []IDataTypeClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDataTypeClauseContext)(nil)).Elem())
	var tst = make([]IDataTypeClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDataTypeClauseContext)
		}
	}

	return tst
}

func (s *DataDescriptionEntryFormat1Context) DataTypeClause(i int) IDataTypeClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataTypeClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDataTypeClauseContext)
}

func (s *DataDescriptionEntryFormat1Context) AllDataUsingClause() []IDataUsingClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDataUsingClauseContext)(nil)).Elem())
	var tst = make([]IDataUsingClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDataUsingClauseContext)
		}
	}

	return tst
}

func (s *DataDescriptionEntryFormat1Context) DataUsingClause(i int) IDataUsingClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataUsingClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDataUsingClauseContext)
}

func (s *DataDescriptionEntryFormat1Context) AllDataUsageClause() []IDataUsageClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDataUsageClauseContext)(nil)).Elem())
	var tst = make([]IDataUsageClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDataUsageClauseContext)
		}
	}

	return tst
}

func (s *DataDescriptionEntryFormat1Context) DataUsageClause(i int) IDataUsageClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataUsageClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDataUsageClauseContext)
}

func (s *DataDescriptionEntryFormat1Context) AllDataValueClause() []IDataValueClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDataValueClauseContext)(nil)).Elem())
	var tst = make([]IDataValueClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDataValueClauseContext)
		}
	}

	return tst
}

func (s *DataDescriptionEntryFormat1Context) DataValueClause(i int) IDataValueClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataValueClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDataValueClauseContext)
}

func (s *DataDescriptionEntryFormat1Context) AllDataReceivedByClause() []IDataReceivedByClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDataReceivedByClauseContext)(nil)).Elem())
	var tst = make([]IDataReceivedByClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDataReceivedByClauseContext)
		}
	}

	return tst
}

func (s *DataDescriptionEntryFormat1Context) DataReceivedByClause(i int) IDataReceivedByClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataReceivedByClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDataReceivedByClauseContext)
}

func (s *DataDescriptionEntryFormat1Context) AllDataOccursClause() []IDataOccursClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDataOccursClauseContext)(nil)).Elem())
	var tst = make([]IDataOccursClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDataOccursClauseContext)
		}
	}

	return tst
}

func (s *DataDescriptionEntryFormat1Context) DataOccursClause(i int) IDataOccursClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataOccursClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDataOccursClauseContext)
}

func (s *DataDescriptionEntryFormat1Context) AllDataSignClause() []IDataSignClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDataSignClauseContext)(nil)).Elem())
	var tst = make([]IDataSignClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDataSignClauseContext)
		}
	}

	return tst
}

func (s *DataDescriptionEntryFormat1Context) DataSignClause(i int) IDataSignClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataSignClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDataSignClauseContext)
}

func (s *DataDescriptionEntryFormat1Context) AllDataSynchronizedClause() []IDataSynchronizedClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDataSynchronizedClauseContext)(nil)).Elem())
	var tst = make([]IDataSynchronizedClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDataSynchronizedClauseContext)
		}
	}

	return tst
}

func (s *DataDescriptionEntryFormat1Context) DataSynchronizedClause(i int) IDataSynchronizedClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataSynchronizedClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDataSynchronizedClauseContext)
}

func (s *DataDescriptionEntryFormat1Context) AllDataJustifiedClause() []IDataJustifiedClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDataJustifiedClauseContext)(nil)).Elem())
	var tst = make([]IDataJustifiedClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDataJustifiedClauseContext)
		}
	}

	return tst
}

func (s *DataDescriptionEntryFormat1Context) DataJustifiedClause(i int) IDataJustifiedClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataJustifiedClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDataJustifiedClauseContext)
}

func (s *DataDescriptionEntryFormat1Context) AllDataBlankWhenZeroClause() []IDataBlankWhenZeroClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDataBlankWhenZeroClauseContext)(nil)).Elem())
	var tst = make([]IDataBlankWhenZeroClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDataBlankWhenZeroClauseContext)
		}
	}

	return tst
}

func (s *DataDescriptionEntryFormat1Context) DataBlankWhenZeroClause(i int) IDataBlankWhenZeroClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataBlankWhenZeroClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDataBlankWhenZeroClauseContext)
}

func (s *DataDescriptionEntryFormat1Context) AllDataWithLowerBoundsClause() []IDataWithLowerBoundsClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDataWithLowerBoundsClauseContext)(nil)).Elem())
	var tst = make([]IDataWithLowerBoundsClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDataWithLowerBoundsClauseContext)
		}
	}

	return tst
}

func (s *DataDescriptionEntryFormat1Context) DataWithLowerBoundsClause(i int) IDataWithLowerBoundsClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataWithLowerBoundsClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDataWithLowerBoundsClauseContext)
}

func (s *DataDescriptionEntryFormat1Context) AllDataAlignedClause() []IDataAlignedClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDataAlignedClauseContext)(nil)).Elem())
	var tst = make([]IDataAlignedClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDataAlignedClauseContext)
		}
	}

	return tst
}

func (s *DataDescriptionEntryFormat1Context) DataAlignedClause(i int) IDataAlignedClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataAlignedClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDataAlignedClauseContext)
}

func (s *DataDescriptionEntryFormat1Context) AllDataRecordAreaClause() []IDataRecordAreaClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDataRecordAreaClauseContext)(nil)).Elem())
	var tst = make([]IDataRecordAreaClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDataRecordAreaClauseContext)
		}
	}

	return tst
}

func (s *DataDescriptionEntryFormat1Context) DataRecordAreaClause(i int) IDataRecordAreaClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataRecordAreaClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDataRecordAreaClauseContext)
}

func (s *DataDescriptionEntryFormat1Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataDescriptionEntryFormat1Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataDescriptionEntryFormat1Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataDescriptionEntryFormat1(s)
	}
}

func (s *DataDescriptionEntryFormat1Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataDescriptionEntryFormat1(s)
	}
}

func (p *Cobol85Parser) DataDescriptionEntryFormat1() (localctx IDataDescriptionEntryFormat1Context) {
	localctx = NewDataDescriptionEntryFormat1Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 436, Cobol85ParserRULE_dataDescriptionEntryFormat1)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3153)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserLEVEL_NUMBER_77 || _la == Cobol85ParserINTEGERLITERAL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(3156)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 390, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3154)
			p.Match(Cobol85ParserFILLER)
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 390, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(3155)
			p.DataName()
		}

	}
	p.SetState(3181)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserALIGNED)|(1<<Cobol85ParserALL)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH)|(1<<Cobol85ParserATTRIBUTE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBINARY-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLANK-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserBY-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-68))|(1<<(Cobol85ParserCOBOL-68))|(1<<(Cobol85ParserCOMMITMENT-68))|(1<<(Cobol85ParserCOMMON-68))|(1<<(Cobol85ParserCOMP-68))|(1<<(Cobol85ParserCOMP_1-68))|(1<<(Cobol85ParserCOMP_2-68))|(1<<(Cobol85ParserCOMP_3-68))|(1<<(Cobol85ParserCOMP_4-68))|(1<<(Cobol85ParserCOMP_5-68))|(1<<(Cobol85ParserCOMPUTATIONAL-68))|(1<<(Cobol85ParserCOMPUTATIONAL_1-68))|(1<<(Cobol85ParserCOMPUTATIONAL_2-68))|(1<<(Cobol85ParserCOMPUTATIONAL_3-68))|(1<<(Cobol85ParserCOMPUTATIONAL_4-68))|(1<<(Cobol85ParserCOMPUTATIONAL_5-68))|(1<<(Cobol85ParserCONTENT-68))|(1<<(Cobol85ParserCONTROL_POINT-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(Cobol85ParserCONVENTION-100))|(1<<(Cobol85ParserCRUNCH-100))|(1<<(Cobol85ParserCURSOR-100))|(1<<(Cobol85ParserDATE-100))|(1<<(Cobol85ParserDEFAULT-100))|(1<<(Cobol85ParserDEFAULT_DISPLAY-100))|(1<<(Cobol85ParserDEFINITION-100)))) != 0) || (((_la-138)&-(0x1f+1)) == 0 && ((1<<uint((_la-138)))&((1<<(Cobol85ParserDFHRESP-138))|(1<<(Cobol85ParserDFHVALUE-138))|(1<<(Cobol85ParserDISK-138))|(1<<(Cobol85ParserDISPLAY-138))|(1<<(Cobol85ParserDISPLAY_1-138))|(1<<(Cobol85ParserDONTCARE-138))|(1<<(Cobol85ParserDOUBLE-138))|(1<<(Cobol85ParserEBCDIC-138))|(1<<(Cobol85ParserEMPTY_CHECK-138)))) != 0) || (((_la-181)&-(0x1f+1)) == 0 && ((1<<uint((_la-181)))&((1<<(Cobol85ParserENTER-181))|(1<<(Cobol85ParserENTRY_PROCEDURE-181))|(1<<(Cobol85ParserERASE-181))|(1<<(Cobol85ParserEOL-181))|(1<<(Cobol85ParserEOS-181))|(1<<(Cobol85ParserESCAPE-181))|(1<<(Cobol85ParserEVENT-181))|(1<<(Cobol85ParserEXCLUSIVE-181))|(1<<(Cobol85ParserEXPORT-181))|(1<<(Cobol85ParserEXTENDED-181))|(1<<(Cobol85ParserEXTERNAL-181))|(1<<(Cobol85ParserFALSE-181)))) != 0) || (((_la-213)&-(0x1f+1)) == 0 && ((1<<uint((_la-213)))&((1<<(Cobol85ParserFOREGROUND_COLOR-213))|(1<<(Cobol85ParserFOREGROUND_COLOUR-213))|(1<<(Cobol85ParserFULL-213))|(1<<(Cobol85ParserFUNCTIONNAME-213))|(1<<(Cobol85ParserFUNCTION_POINTER-213))|(1<<(Cobol85ParserGLOBAL-213))|(1<<(Cobol85ParserGRID-213))|(1<<(Cobol85ParserHIGHLIGHT-213))|(1<<(Cobol85ParserHIGH_VALUE-213))|(1<<(Cobol85ParserHIGH_VALUES-213))|(1<<(Cobol85ParserIMPLICIT-213))|(1<<(Cobol85ParserIMPORT-213))|(1<<(Cobol85ParserINDEX-213)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(Cobol85ParserINTEGER-250))|(1<<(Cobol85ParserIS-250))|(1<<(Cobol85ParserJUST-250))|(1<<(Cobol85ParserJUSTIFIED-250))|(1<<(Cobol85ParserKANJI-250))|(1<<(Cobol85ParserKEPT-250))|(1<<(Cobol85ParserKEYBOARD-250))|(1<<(Cobol85ParserLANGUAGE-250))|(1<<(Cobol85ParserLB-250))|(1<<(Cobol85ParserLD-250))|(1<<(Cobol85ParserLEADING-250))|(1<<(Cobol85ParserLEFTLINE-250))|(1<<(Cobol85ParserLENGTH_CHECK-250))|(1<<(Cobol85ParserLIBACCESS-250))|(1<<(Cobol85ParserLIBPARAMETER-250))|(1<<(Cobol85ParserLIBRARY-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(Cobol85ParserLIST-283))|(1<<(Cobol85ParserLOCAL-283))|(1<<(Cobol85ParserLOCK-283))|(1<<(Cobol85ParserLONG_DATE-283))|(1<<(Cobol85ParserLONG_TIME-283))|(1<<(Cobol85ParserLOWER-283))|(1<<(Cobol85ParserLOWLIGHT-283))|(1<<(Cobol85ParserLOW_VALUE-283))|(1<<(Cobol85ParserLOW_VALUES-283))|(1<<(Cobol85ParserMMDDYYYY-283))|(1<<(Cobol85ParserNAMED-283))|(1<<(Cobol85ParserNATIONAL-283))|(1<<(Cobol85ParserNATIONAL_EDITED-283))|(1<<(Cobol85ParserNETWORK-283))|(1<<(Cobol85ParserNO_ECHO-283))|(1<<(Cobol85ParserNULL-283))|(1<<(Cobol85ParserNULLS-283)))) != 0) || (((_la-317)&-(0x1f+1)) == 0 && ((1<<uint((_la-317)))&((1<<(Cobol85ParserNUMERIC_DATE-317))|(1<<(Cobol85ParserNUMERIC_TIME-317))|(1<<(Cobol85ParserOCCURS-317))|(1<<(Cobol85ParserODT-317))|(1<<(Cobol85ParserORDERLY-317))|(1<<(Cobol85ParserOVERLINE-317))|(1<<(Cobol85ParserOWN-317))|(1<<(Cobol85ParserPACKED_DECIMAL-317))|(1<<(Cobol85ParserPASSWORD-317))|(1<<(Cobol85ParserPIC-317))|(1<<(Cobol85ParserPICTURE-317)))) != 0) || (((_la-349)&-(0x1f+1)) == 0 && ((1<<uint((_la-349)))&((1<<(Cobol85ParserPOINTER-349))|(1<<(Cobol85ParserPORT-349))|(1<<(Cobol85ParserPRINTER-349))|(1<<(Cobol85ParserPRIVATE-349))|(1<<(Cobol85ParserPROCEDURE_POINTER-349))|(1<<(Cobol85ParserPROCESS-349))|(1<<(Cobol85ParserPROGRAM-349))|(1<<(Cobol85ParserPROMPT-349))|(1<<(Cobol85ParserQUOTE-349))|(1<<(Cobol85ParserQUOTES-349))|(1<<(Cobol85ParserREADER-349))|(1<<(Cobol85ParserREMOTE-349))|(1<<(Cobol85ParserREAL-349))|(1<<(Cobol85ParserRECEIVED-349))|(1<<(Cobol85ParserRECORD-349))|(1<<(Cobol85ParserRECURSIVE-349)))) != 0) || (((_la-381)&-(0x1f+1)) == 0 && ((1<<uint((_la-381)))&((1<<(Cobol85ParserREDEFINES-381))|(1<<(Cobol85ParserREF-381))|(1<<(Cobol85ParserREFERENCE-381))|(1<<(Cobol85ParserREMOVE-381))|(1<<(Cobol85ParserREQUIRED-381))|(1<<(Cobol85ParserREVERSE_VIDEO-381)))) != 0) || (((_la-415)&-(0x1f+1)) == 0 && ((1<<uint((_la-415)))&((1<<(Cobol85ParserSAVE-415))|(1<<(Cobol85ParserSECURE-415))|(1<<(Cobol85ParserSHARED-415))|(1<<(Cobol85ParserSHAREDBYALL-415))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-415))|(1<<(Cobol85ParserSHARING-415))|(1<<(Cobol85ParserSHORT_DATE-415))|(1<<(Cobol85ParserSIGN-415)))) != 0) || (((_la-450)&-(0x1f+1)) == 0 && ((1<<uint((_la-450)))&((1<<(Cobol85ParserSPACE-450))|(1<<(Cobol85ParserSPACES-450))|(1<<(Cobol85ParserSTRING-450))|(1<<(Cobol85ParserSYMBOL-450))|(1<<(Cobol85ParserSYNC-450))|(1<<(Cobol85ParserSYNCHRONIZED-450))|(1<<(Cobol85ParserTASK-450))|(1<<(Cobol85ParserTHREAD-450)))) != 0) || (((_la-482)&-(0x1f+1)) == 0 && ((1<<uint((_la-482)))&((1<<(Cobol85ParserTHREAD_LOCAL-482))|(1<<(Cobol85ParserTIMER-482))|(1<<(Cobol85ParserTODAYS_DATE-482))|(1<<(Cobol85ParserTODAYS_NAME-482))|(1<<(Cobol85ParserTRAILING-482))|(1<<(Cobol85ParserTRUE-482))|(1<<(Cobol85ParserTRUNCATED-482))|(1<<(Cobol85ParserTYPE-482))|(1<<(Cobol85ParserTYPEDEF-482))|(1<<(Cobol85ParserUNDERLINE-482))|(1<<(Cobol85ParserUSAGE-482))|(1<<(Cobol85ParserUSING-482))|(1<<(Cobol85ParserVALUE-482))|(1<<(Cobol85ParserVALUES-482))|(1<<(Cobol85ParserVIRTUAL-482))|(1<<(Cobol85ParserWAIT-482)))) != 0) || (((_la-514)&-(0x1f+1)) == 0 && ((1<<uint((_la-514)))&((1<<(Cobol85ParserWITH-514))|(1<<(Cobol85ParserYEAR-514))|(1<<(Cobol85ParserYYYYMMDD-514))|(1<<(Cobol85ParserYYYYDDD-514))|(1<<(Cobol85ParserZERO-514))|(1<<(Cobol85ParserZERO_FILL-514))|(1<<(Cobol85ParserZEROS-514))|(1<<(Cobol85ParserZEROES-514)))) != 0) || (((_la-551)&-(0x1f+1)) == 0 && ((1<<uint((_la-551)))&((1<<(Cobol85ParserNONNUMERICLITERAL-551))|(1<<(Cobol85ParserLEVEL_NUMBER_66-551))|(1<<(Cobol85ParserLEVEL_NUMBER_77-551))|(1<<(Cobol85ParserLEVEL_NUMBER_88-551))|(1<<(Cobol85ParserINTEGERLITERAL-551))|(1<<(Cobol85ParserNUMERICLITERAL-551))|(1<<(Cobol85ParserIDENTIFIER-551)))) != 0) {
		p.SetState(3179)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 391, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(3158)
				p.DataRedefinesClause()
			}

		case 2:
			{
				p.SetState(3159)
				p.DataIntegerStringClause()
			}

		case 3:
			{
				p.SetState(3160)
				p.DataExternalClause()
			}

		case 4:
			{
				p.SetState(3161)
				p.DataGlobalClause()
			}

		case 5:
			{
				p.SetState(3162)
				p.DataTypeDefClause()
			}

		case 6:
			{
				p.SetState(3163)
				p.DataThreadLocalClause()
			}

		case 7:
			{
				p.SetState(3164)
				p.DataPictureClause()
			}

		case 8:
			{
				p.SetState(3165)
				p.DataCommonOwnLocalClause()
			}

		case 9:
			{
				p.SetState(3166)
				p.DataTypeClause()
			}

		case 10:
			{
				p.SetState(3167)
				p.DataUsingClause()
			}

		case 11:
			{
				p.SetState(3168)
				p.DataUsageClause()
			}

		case 12:
			{
				p.SetState(3169)
				p.DataValueClause()
			}

		case 13:
			{
				p.SetState(3170)
				p.DataReceivedByClause()
			}

		case 14:
			{
				p.SetState(3171)
				p.DataOccursClause()
			}

		case 15:
			{
				p.SetState(3172)
				p.DataSignClause()
			}

		case 16:
			{
				p.SetState(3173)
				p.DataSynchronizedClause()
			}

		case 17:
			{
				p.SetState(3174)
				p.DataJustifiedClause()
			}

		case 18:
			{
				p.SetState(3175)
				p.DataBlankWhenZeroClause()
			}

		case 19:
			{
				p.SetState(3176)
				p.DataWithLowerBoundsClause()
			}

		case 20:
			{
				p.SetState(3177)
				p.DataAlignedClause()
			}

		case 21:
			{
				p.SetState(3178)
				p.DataRecordAreaClause()
			}

		}

		p.SetState(3183)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3184)
		p.Match(Cobol85ParserDOT_FS)
	}

	return localctx
}

// IDataDescriptionEntryFormat2Context is an interface to support dynamic dispatch.
type IDataDescriptionEntryFormat2Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataDescriptionEntryFormat2Context differentiates from other interfaces.
	IsDataDescriptionEntryFormat2Context()
}

type DataDescriptionEntryFormat2Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataDescriptionEntryFormat2Context() *DataDescriptionEntryFormat2Context {
	var p = new(DataDescriptionEntryFormat2Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataDescriptionEntryFormat2
	return p
}

func (*DataDescriptionEntryFormat2Context) IsDataDescriptionEntryFormat2Context() {}

func NewDataDescriptionEntryFormat2Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataDescriptionEntryFormat2Context {
	var p = new(DataDescriptionEntryFormat2Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataDescriptionEntryFormat2

	return p
}

func (s *DataDescriptionEntryFormat2Context) GetParser() antlr.Parser { return s.parser }

func (s *DataDescriptionEntryFormat2Context) LEVEL_NUMBER_66() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLEVEL_NUMBER_66, 0)
}

func (s *DataDescriptionEntryFormat2Context) DataName() IDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *DataDescriptionEntryFormat2Context) DataRenamesClause() IDataRenamesClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataRenamesClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataRenamesClauseContext)
}

func (s *DataDescriptionEntryFormat2Context) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *DataDescriptionEntryFormat2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataDescriptionEntryFormat2Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataDescriptionEntryFormat2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataDescriptionEntryFormat2(s)
	}
}

func (s *DataDescriptionEntryFormat2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataDescriptionEntryFormat2(s)
	}
}

func (p *Cobol85Parser) DataDescriptionEntryFormat2() (localctx IDataDescriptionEntryFormat2Context) {
	localctx = NewDataDescriptionEntryFormat2Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 438, Cobol85ParserRULE_dataDescriptionEntryFormat2)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3186)
		p.Match(Cobol85ParserLEVEL_NUMBER_66)
	}
	{
		p.SetState(3187)
		p.DataName()
	}
	{
		p.SetState(3188)
		p.DataRenamesClause()
	}
	{
		p.SetState(3189)
		p.Match(Cobol85ParserDOT_FS)
	}

	return localctx
}

// IDataDescriptionEntryFormat3Context is an interface to support dynamic dispatch.
type IDataDescriptionEntryFormat3Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataDescriptionEntryFormat3Context differentiates from other interfaces.
	IsDataDescriptionEntryFormat3Context()
}

type DataDescriptionEntryFormat3Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataDescriptionEntryFormat3Context() *DataDescriptionEntryFormat3Context {
	var p = new(DataDescriptionEntryFormat3Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataDescriptionEntryFormat3
	return p
}

func (*DataDescriptionEntryFormat3Context) IsDataDescriptionEntryFormat3Context() {}

func NewDataDescriptionEntryFormat3Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataDescriptionEntryFormat3Context {
	var p = new(DataDescriptionEntryFormat3Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataDescriptionEntryFormat3

	return p
}

func (s *DataDescriptionEntryFormat3Context) GetParser() antlr.Parser { return s.parser }

func (s *DataDescriptionEntryFormat3Context) LEVEL_NUMBER_88() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLEVEL_NUMBER_88, 0)
}

func (s *DataDescriptionEntryFormat3Context) ConditionName() IConditionNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditionNameContext)
}

func (s *DataDescriptionEntryFormat3Context) DataValueClause() IDataValueClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataValueClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataValueClauseContext)
}

func (s *DataDescriptionEntryFormat3Context) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *DataDescriptionEntryFormat3Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataDescriptionEntryFormat3Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataDescriptionEntryFormat3Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataDescriptionEntryFormat3(s)
	}
}

func (s *DataDescriptionEntryFormat3Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataDescriptionEntryFormat3(s)
	}
}

func (p *Cobol85Parser) DataDescriptionEntryFormat3() (localctx IDataDescriptionEntryFormat3Context) {
	localctx = NewDataDescriptionEntryFormat3Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 440, Cobol85ParserRULE_dataDescriptionEntryFormat3)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3191)
		p.Match(Cobol85ParserLEVEL_NUMBER_88)
	}
	{
		p.SetState(3192)
		p.ConditionName()
	}
	{
		p.SetState(3193)
		p.DataValueClause()
	}
	{
		p.SetState(3194)
		p.Match(Cobol85ParserDOT_FS)
	}

	return localctx
}

// IDataDescriptionEntryExecSqlContext is an interface to support dynamic dispatch.
type IDataDescriptionEntryExecSqlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataDescriptionEntryExecSqlContext differentiates from other interfaces.
	IsDataDescriptionEntryExecSqlContext()
}

type DataDescriptionEntryExecSqlContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataDescriptionEntryExecSqlContext() *DataDescriptionEntryExecSqlContext {
	var p = new(DataDescriptionEntryExecSqlContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataDescriptionEntryExecSql
	return p
}

func (*DataDescriptionEntryExecSqlContext) IsDataDescriptionEntryExecSqlContext() {}

func NewDataDescriptionEntryExecSqlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataDescriptionEntryExecSqlContext {
	var p = new(DataDescriptionEntryExecSqlContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataDescriptionEntryExecSql

	return p
}

func (s *DataDescriptionEntryExecSqlContext) GetParser() antlr.Parser { return s.parser }

func (s *DataDescriptionEntryExecSqlContext) AllEXECSQLLINE() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserEXECSQLLINE)
}

func (s *DataDescriptionEntryExecSqlContext) EXECSQLLINE(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEXECSQLLINE, i)
}

func (s *DataDescriptionEntryExecSqlContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *DataDescriptionEntryExecSqlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataDescriptionEntryExecSqlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataDescriptionEntryExecSqlContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataDescriptionEntryExecSql(s)
	}
}

func (s *DataDescriptionEntryExecSqlContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataDescriptionEntryExecSql(s)
	}
}

func (p *Cobol85Parser) DataDescriptionEntryExecSql() (localctx IDataDescriptionEntryExecSqlContext) {
	localctx = NewDataDescriptionEntryExecSqlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 442, Cobol85ParserRULE_dataDescriptionEntryExecSql)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3197)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(3196)
				p.Match(Cobol85ParserEXECSQLLINE)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(3199)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 393, p.GetParserRuleContext())
	}
	p.SetState(3202)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserDOT_FS {
		{
			p.SetState(3201)
			p.Match(Cobol85ParserDOT_FS)
		}

	}

	return localctx
}

// IDataAlignedClauseContext is an interface to support dynamic dispatch.
type IDataAlignedClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataAlignedClauseContext differentiates from other interfaces.
	IsDataAlignedClauseContext()
}

type DataAlignedClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataAlignedClauseContext() *DataAlignedClauseContext {
	var p = new(DataAlignedClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataAlignedClause
	return p
}

func (*DataAlignedClauseContext) IsDataAlignedClauseContext() {}

func NewDataAlignedClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataAlignedClauseContext {
	var p = new(DataAlignedClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataAlignedClause

	return p
}

func (s *DataAlignedClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataAlignedClauseContext) ALIGNED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALIGNED, 0)
}

func (s *DataAlignedClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataAlignedClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataAlignedClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataAlignedClause(s)
	}
}

func (s *DataAlignedClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataAlignedClause(s)
	}
}

func (p *Cobol85Parser) DataAlignedClause() (localctx IDataAlignedClauseContext) {
	localctx = NewDataAlignedClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 444, Cobol85ParserRULE_dataAlignedClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3204)
		p.Match(Cobol85ParserALIGNED)
	}

	return localctx
}

// IDataBlankWhenZeroClauseContext is an interface to support dynamic dispatch.
type IDataBlankWhenZeroClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataBlankWhenZeroClauseContext differentiates from other interfaces.
	IsDataBlankWhenZeroClauseContext()
}

type DataBlankWhenZeroClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataBlankWhenZeroClauseContext() *DataBlankWhenZeroClauseContext {
	var p = new(DataBlankWhenZeroClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataBlankWhenZeroClause
	return p
}

func (*DataBlankWhenZeroClauseContext) IsDataBlankWhenZeroClauseContext() {}

func NewDataBlankWhenZeroClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataBlankWhenZeroClauseContext {
	var p = new(DataBlankWhenZeroClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataBlankWhenZeroClause

	return p
}

func (s *DataBlankWhenZeroClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataBlankWhenZeroClauseContext) BLANK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBLANK, 0)
}

func (s *DataBlankWhenZeroClauseContext) ZERO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserZERO, 0)
}

func (s *DataBlankWhenZeroClauseContext) ZEROS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserZEROS, 0)
}

func (s *DataBlankWhenZeroClauseContext) ZEROES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserZEROES, 0)
}

func (s *DataBlankWhenZeroClauseContext) WHEN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWHEN, 0)
}

func (s *DataBlankWhenZeroClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataBlankWhenZeroClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataBlankWhenZeroClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataBlankWhenZeroClause(s)
	}
}

func (s *DataBlankWhenZeroClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataBlankWhenZeroClause(s)
	}
}

func (p *Cobol85Parser) DataBlankWhenZeroClause() (localctx IDataBlankWhenZeroClauseContext) {
	localctx = NewDataBlankWhenZeroClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 446, Cobol85ParserRULE_dataBlankWhenZeroClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3206)
		p.Match(Cobol85ParserBLANK)
	}
	p.SetState(3208)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserWHEN {
		{
			p.SetState(3207)
			p.Match(Cobol85ParserWHEN)
		}

	}
	{
		p.SetState(3210)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-521)&-(0x1f+1)) == 0 && ((1<<uint((_la-521)))&((1<<(Cobol85ParserZERO-521))|(1<<(Cobol85ParserZEROS-521))|(1<<(Cobol85ParserZEROES-521)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IDataCommonOwnLocalClauseContext is an interface to support dynamic dispatch.
type IDataCommonOwnLocalClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataCommonOwnLocalClauseContext differentiates from other interfaces.
	IsDataCommonOwnLocalClauseContext()
}

type DataCommonOwnLocalClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataCommonOwnLocalClauseContext() *DataCommonOwnLocalClauseContext {
	var p = new(DataCommonOwnLocalClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataCommonOwnLocalClause
	return p
}

func (*DataCommonOwnLocalClauseContext) IsDataCommonOwnLocalClauseContext() {}

func NewDataCommonOwnLocalClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataCommonOwnLocalClauseContext {
	var p = new(DataCommonOwnLocalClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataCommonOwnLocalClause

	return p
}

func (s *DataCommonOwnLocalClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataCommonOwnLocalClauseContext) COMMON() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMMON, 0)
}

func (s *DataCommonOwnLocalClauseContext) OWN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOWN, 0)
}

func (s *DataCommonOwnLocalClauseContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLOCAL, 0)
}

func (s *DataCommonOwnLocalClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataCommonOwnLocalClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataCommonOwnLocalClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataCommonOwnLocalClause(s)
	}
}

func (s *DataCommonOwnLocalClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataCommonOwnLocalClause(s)
	}
}

func (p *Cobol85Parser) DataCommonOwnLocalClause() (localctx IDataCommonOwnLocalClauseContext) {
	localctx = NewDataCommonOwnLocalClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 448, Cobol85ParserRULE_dataCommonOwnLocalClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3212)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserCOMMON || _la == Cobol85ParserLOCAL || _la == Cobol85ParserOWN) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IDataExternalClauseContext is an interface to support dynamic dispatch.
type IDataExternalClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataExternalClauseContext differentiates from other interfaces.
	IsDataExternalClauseContext()
}

type DataExternalClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataExternalClauseContext() *DataExternalClauseContext {
	var p = new(DataExternalClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataExternalClause
	return p
}

func (*DataExternalClauseContext) IsDataExternalClauseContext() {}

func NewDataExternalClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataExternalClauseContext {
	var p = new(DataExternalClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataExternalClause

	return p
}

func (s *DataExternalClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataExternalClauseContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEXTERNAL, 0)
}

func (s *DataExternalClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *DataExternalClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBY, 0)
}

func (s *DataExternalClauseContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *DataExternalClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataExternalClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataExternalClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataExternalClause(s)
	}
}

func (s *DataExternalClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataExternalClause(s)
	}
}

func (p *Cobol85Parser) DataExternalClause() (localctx IDataExternalClauseContext) {
	localctx = NewDataExternalClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 450, Cobol85ParserRULE_dataExternalClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3215)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(3214)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(3217)
		p.Match(Cobol85ParserEXTERNAL)
	}
	p.SetState(3220)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 397, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3218)
			p.Match(Cobol85ParserBY)
		}
		{
			p.SetState(3219)
			p.Literal()
		}

	}

	return localctx
}

// IDataGlobalClauseContext is an interface to support dynamic dispatch.
type IDataGlobalClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataGlobalClauseContext differentiates from other interfaces.
	IsDataGlobalClauseContext()
}

type DataGlobalClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataGlobalClauseContext() *DataGlobalClauseContext {
	var p = new(DataGlobalClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataGlobalClause
	return p
}

func (*DataGlobalClauseContext) IsDataGlobalClauseContext() {}

func NewDataGlobalClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataGlobalClauseContext {
	var p = new(DataGlobalClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataGlobalClause

	return p
}

func (s *DataGlobalClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataGlobalClauseContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserGLOBAL, 0)
}

func (s *DataGlobalClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *DataGlobalClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataGlobalClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataGlobalClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataGlobalClause(s)
	}
}

func (s *DataGlobalClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataGlobalClause(s)
	}
}

func (p *Cobol85Parser) DataGlobalClause() (localctx IDataGlobalClauseContext) {
	localctx = NewDataGlobalClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 452, Cobol85ParserRULE_dataGlobalClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3223)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(3222)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(3225)
		p.Match(Cobol85ParserGLOBAL)
	}

	return localctx
}

// IDataIntegerStringClauseContext is an interface to support dynamic dispatch.
type IDataIntegerStringClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataIntegerStringClauseContext differentiates from other interfaces.
	IsDataIntegerStringClauseContext()
}

type DataIntegerStringClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataIntegerStringClauseContext() *DataIntegerStringClauseContext {
	var p = new(DataIntegerStringClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataIntegerStringClause
	return p
}

func (*DataIntegerStringClauseContext) IsDataIntegerStringClauseContext() {}

func NewDataIntegerStringClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataIntegerStringClauseContext {
	var p = new(DataIntegerStringClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataIntegerStringClause

	return p
}

func (s *DataIntegerStringClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataIntegerStringClauseContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINTEGER, 0)
}

func (s *DataIntegerStringClauseContext) STRING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSTRING, 0)
}

func (s *DataIntegerStringClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataIntegerStringClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataIntegerStringClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataIntegerStringClause(s)
	}
}

func (s *DataIntegerStringClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataIntegerStringClause(s)
	}
}

func (p *Cobol85Parser) DataIntegerStringClause() (localctx IDataIntegerStringClauseContext) {
	localctx = NewDataIntegerStringClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 454, Cobol85ParserRULE_dataIntegerStringClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3227)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserINTEGER || _la == Cobol85ParserSTRING) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IDataJustifiedClauseContext is an interface to support dynamic dispatch.
type IDataJustifiedClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataJustifiedClauseContext differentiates from other interfaces.
	IsDataJustifiedClauseContext()
}

type DataJustifiedClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataJustifiedClauseContext() *DataJustifiedClauseContext {
	var p = new(DataJustifiedClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataJustifiedClause
	return p
}

func (*DataJustifiedClauseContext) IsDataJustifiedClauseContext() {}

func NewDataJustifiedClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataJustifiedClauseContext {
	var p = new(DataJustifiedClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataJustifiedClause

	return p
}

func (s *DataJustifiedClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataJustifiedClauseContext) JUSTIFIED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserJUSTIFIED, 0)
}

func (s *DataJustifiedClauseContext) JUST() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserJUST, 0)
}

func (s *DataJustifiedClauseContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRIGHT, 0)
}

func (s *DataJustifiedClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataJustifiedClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataJustifiedClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataJustifiedClause(s)
	}
}

func (s *DataJustifiedClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataJustifiedClause(s)
	}
}

func (p *Cobol85Parser) DataJustifiedClause() (localctx IDataJustifiedClauseContext) {
	localctx = NewDataJustifiedClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 456, Cobol85ParserRULE_dataJustifiedClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3229)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserJUST || _la == Cobol85ParserJUSTIFIED) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(3231)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserRIGHT {
		{
			p.SetState(3230)
			p.Match(Cobol85ParserRIGHT)
		}

	}

	return localctx
}

// IDataOccursClauseContext is an interface to support dynamic dispatch.
type IDataOccursClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataOccursClauseContext differentiates from other interfaces.
	IsDataOccursClauseContext()
}

type DataOccursClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataOccursClauseContext() *DataOccursClauseContext {
	var p = new(DataOccursClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataOccursClause
	return p
}

func (*DataOccursClauseContext) IsDataOccursClauseContext() {}

func NewDataOccursClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataOccursClauseContext {
	var p = new(DataOccursClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataOccursClause

	return p
}

func (s *DataOccursClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataOccursClauseContext) OCCURS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOCCURS, 0)
}

func (s *DataOccursClauseContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *DataOccursClauseContext) DataOccursTo() IDataOccursToContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataOccursToContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataOccursToContext)
}

func (s *DataOccursClauseContext) TIMES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTIMES, 0)
}

func (s *DataOccursClauseContext) DEPENDING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDEPENDING, 0)
}

func (s *DataOccursClauseContext) QualifiedDataName() IQualifiedDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *DataOccursClauseContext) AllDataOccursSort() []IDataOccursSortContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDataOccursSortContext)(nil)).Elem())
	var tst = make([]IDataOccursSortContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDataOccursSortContext)
		}
	}

	return tst
}

func (s *DataOccursClauseContext) DataOccursSort(i int) IDataOccursSortContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataOccursSortContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDataOccursSortContext)
}

func (s *DataOccursClauseContext) INDEXED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINDEXED, 0)
}

func (s *DataOccursClauseContext) ON() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserON, 0)
}

func (s *DataOccursClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBY, 0)
}

func (s *DataOccursClauseContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLOCAL, 0)
}

func (s *DataOccursClauseContext) AllIndexName() []IIndexNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIndexNameContext)(nil)).Elem())
	var tst = make([]IIndexNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIndexNameContext)
		}
	}

	return tst
}

func (s *DataOccursClauseContext) IndexName(i int) IIndexNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIndexNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIndexNameContext)
}

func (s *DataOccursClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataOccursClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataOccursClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataOccursClause(s)
	}
}

func (s *DataOccursClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataOccursClause(s)
	}
}

func (p *Cobol85Parser) DataOccursClause() (localctx IDataOccursClauseContext) {
	localctx = NewDataOccursClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 458, Cobol85ParserRULE_dataOccursClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3233)
		p.Match(Cobol85ParserOCCURS)
	}
	{
		p.SetState(3234)
		p.IntegerLiteral()
	}
	p.SetState(3236)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserTO {
		{
			p.SetState(3235)
			p.DataOccursTo()
		}

	}
	p.SetState(3239)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserTIMES {
		{
			p.SetState(3238)
			p.Match(Cobol85ParserTIMES)
		}

	}
	p.SetState(3246)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserDEPENDING {
		{
			p.SetState(3241)
			p.Match(Cobol85ParserDEPENDING)
		}
		p.SetState(3243)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserON {
			{
				p.SetState(3242)
				p.Match(Cobol85ParserON)
			}

		}
		{
			p.SetState(3245)
			p.QualifiedDataName()
		}

	}
	p.SetState(3251)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserASCENDING || _la == Cobol85ParserDESCENDING {
		{
			p.SetState(3248)
			p.DataOccursSort()
		}

		p.SetState(3253)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(3266)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserINDEXED {
		{
			p.SetState(3254)
			p.Match(Cobol85ParserINDEXED)
		}
		p.SetState(3256)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserBY {
			{
				p.SetState(3255)
				p.Match(Cobol85ParserBY)
			}

		}
		p.SetState(3259)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 406, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3258)
				p.Match(Cobol85ParserLOCAL)
			}

		}
		p.SetState(3262)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(3261)
					p.IndexName()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(3264)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 407, p.GetParserRuleContext())
		}

	}

	return localctx
}

// IDataOccursToContext is an interface to support dynamic dispatch.
type IDataOccursToContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataOccursToContext differentiates from other interfaces.
	IsDataOccursToContext()
}

type DataOccursToContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataOccursToContext() *DataOccursToContext {
	var p = new(DataOccursToContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataOccursTo
	return p
}

func (*DataOccursToContext) IsDataOccursToContext() {}

func NewDataOccursToContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataOccursToContext {
	var p = new(DataOccursToContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataOccursTo

	return p
}

func (s *DataOccursToContext) GetParser() antlr.Parser { return s.parser }

func (s *DataOccursToContext) TO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTO, 0)
}

func (s *DataOccursToContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *DataOccursToContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataOccursToContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataOccursToContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataOccursTo(s)
	}
}

func (s *DataOccursToContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataOccursTo(s)
	}
}

func (p *Cobol85Parser) DataOccursTo() (localctx IDataOccursToContext) {
	localctx = NewDataOccursToContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 460, Cobol85ParserRULE_dataOccursTo)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3268)
		p.Match(Cobol85ParserTO)
	}
	{
		p.SetState(3269)
		p.IntegerLiteral()
	}

	return localctx
}

// IDataOccursSortContext is an interface to support dynamic dispatch.
type IDataOccursSortContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataOccursSortContext differentiates from other interfaces.
	IsDataOccursSortContext()
}

type DataOccursSortContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataOccursSortContext() *DataOccursSortContext {
	var p = new(DataOccursSortContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataOccursSort
	return p
}

func (*DataOccursSortContext) IsDataOccursSortContext() {}

func NewDataOccursSortContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataOccursSortContext {
	var p = new(DataOccursSortContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataOccursSort

	return p
}

func (s *DataOccursSortContext) GetParser() antlr.Parser { return s.parser }

func (s *DataOccursSortContext) ASCENDING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserASCENDING, 0)
}

func (s *DataOccursSortContext) DESCENDING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDESCENDING, 0)
}

func (s *DataOccursSortContext) KEY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserKEY, 0)
}

func (s *DataOccursSortContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *DataOccursSortContext) AllQualifiedDataName() []IQualifiedDataNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IQualifiedDataNameContext)(nil)).Elem())
	var tst = make([]IQualifiedDataNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IQualifiedDataNameContext)
		}
	}

	return tst
}

func (s *DataOccursSortContext) QualifiedDataName(i int) IQualifiedDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedDataNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *DataOccursSortContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataOccursSortContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataOccursSortContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataOccursSort(s)
	}
}

func (s *DataOccursSortContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataOccursSort(s)
	}
}

func (p *Cobol85Parser) DataOccursSort() (localctx IDataOccursSortContext) {
	localctx = NewDataOccursSortContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 462, Cobol85ParserRULE_dataOccursSort)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3271)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserASCENDING || _la == Cobol85ParserDESCENDING) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(3273)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserKEY {
		{
			p.SetState(3272)
			p.Match(Cobol85ParserKEY)
		}

	}
	p.SetState(3276)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(3275)
			p.Match(Cobol85ParserIS)
		}

	}
	p.SetState(3279)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(3278)
				p.QualifiedDataName()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(3281)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 411, p.GetParserRuleContext())
	}

	return localctx
}

// IDataPictureClauseContext is an interface to support dynamic dispatch.
type IDataPictureClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataPictureClauseContext differentiates from other interfaces.
	IsDataPictureClauseContext()
}

type DataPictureClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataPictureClauseContext() *DataPictureClauseContext {
	var p = new(DataPictureClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataPictureClause
	return p
}

func (*DataPictureClauseContext) IsDataPictureClauseContext() {}

func NewDataPictureClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataPictureClauseContext {
	var p = new(DataPictureClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataPictureClause

	return p
}

func (s *DataPictureClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataPictureClauseContext) PictureString() IPictureStringContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPictureStringContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPictureStringContext)
}

func (s *DataPictureClauseContext) PICTURE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPICTURE, 0)
}

func (s *DataPictureClauseContext) PIC() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPIC, 0)
}

func (s *DataPictureClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *DataPictureClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataPictureClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataPictureClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataPictureClause(s)
	}
}

func (s *DataPictureClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataPictureClause(s)
	}
}

func (p *Cobol85Parser) DataPictureClause() (localctx IDataPictureClauseContext) {
	localctx = NewDataPictureClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 464, Cobol85ParserRULE_dataPictureClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3283)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserPIC || _la == Cobol85ParserPICTURE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(3285)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(3284)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(3287)
		p.PictureString()
	}

	return localctx
}

// IPictureStringContext is an interface to support dynamic dispatch.
type IPictureStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPictureStringContext differentiates from other interfaces.
	IsPictureStringContext()
}

type PictureStringContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPictureStringContext() *PictureStringContext {
	var p = new(PictureStringContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_pictureString
	return p
}

func (*PictureStringContext) IsPictureStringContext() {}

func NewPictureStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PictureStringContext {
	var p = new(PictureStringContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_pictureString

	return p
}

func (s *PictureStringContext) GetParser() antlr.Parser { return s.parser }

func (s *PictureStringContext) AllPictureChars() []IPictureCharsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPictureCharsContext)(nil)).Elem())
	var tst = make([]IPictureCharsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPictureCharsContext)
		}
	}

	return tst
}

func (s *PictureStringContext) PictureChars(i int) IPictureCharsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPictureCharsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPictureCharsContext)
}

func (s *PictureStringContext) AllPictureCardinality() []IPictureCardinalityContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPictureCardinalityContext)(nil)).Elem())
	var tst = make([]IPictureCardinalityContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPictureCardinalityContext)
		}
	}

	return tst
}

func (s *PictureStringContext) PictureCardinality(i int) IPictureCardinalityContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPictureCardinalityContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPictureCardinalityContext)
}

func (s *PictureStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PictureStringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PictureStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterPictureString(s)
	}
}

func (s *PictureStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitPictureString(s)
	}
}

func (p *Cobol85Parser) PictureString() (localctx IPictureStringContext) {
	localctx = NewPictureStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 466, Cobol85ParserRULE_pictureString)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3297)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			p.SetState(3290)
			p.GetErrorHandler().Sync(p)
			_alt = 1
			for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				switch _alt {
				case 1:
					{
						p.SetState(3289)
						p.PictureChars()
					}

				default:
					panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				}

				p.SetState(3292)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 413, p.GetParserRuleContext())
			}
			p.SetState(3295)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 414, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(3294)
					p.PictureCardinality()
				}

			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(3299)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 415, p.GetParserRuleContext())
	}

	return localctx
}

// IPictureCharsContext is an interface to support dynamic dispatch.
type IPictureCharsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPictureCharsContext differentiates from other interfaces.
	IsPictureCharsContext()
}

type PictureCharsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPictureCharsContext() *PictureCharsContext {
	var p = new(PictureCharsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_pictureChars
	return p
}

func (*PictureCharsContext) IsPictureCharsContext() {}

func NewPictureCharsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PictureCharsContext {
	var p = new(PictureCharsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_pictureChars

	return p
}

func (s *PictureCharsContext) GetParser() antlr.Parser { return s.parser }

func (s *PictureCharsContext) DOLLARCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOLLARCHAR, 0)
}

func (s *PictureCharsContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIDENTIFIER, 0)
}

func (s *PictureCharsContext) NUMERICLITERAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNUMERICLITERAL, 0)
}

func (s *PictureCharsContext) SLASHCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSLASHCHAR, 0)
}

func (s *PictureCharsContext) COMMACHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMMACHAR, 0)
}

func (s *PictureCharsContext) DOT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT, 0)
}

func (s *PictureCharsContext) COLONCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOLONCHAR, 0)
}

func (s *PictureCharsContext) ASTERISKCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserASTERISKCHAR, 0)
}

func (s *PictureCharsContext) DOUBLEASTERISKCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOUBLEASTERISKCHAR, 0)
}

func (s *PictureCharsContext) LPARENCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLPARENCHAR, 0)
}

func (s *PictureCharsContext) RPARENCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRPARENCHAR, 0)
}

func (s *PictureCharsContext) PLUSCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPLUSCHAR, 0)
}

func (s *PictureCharsContext) MINUSCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMINUSCHAR, 0)
}

func (s *PictureCharsContext) LESSTHANCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLESSTHANCHAR, 0)
}

func (s *PictureCharsContext) MORETHANCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMORETHANCHAR, 0)
}

func (s *PictureCharsContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *PictureCharsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PictureCharsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PictureCharsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterPictureChars(s)
	}
}

func (s *PictureCharsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitPictureChars(s)
	}
}

func (p *Cobol85Parser) PictureChars() (localctx IPictureCharsContext) {
	localctx = NewPictureCharsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 468, Cobol85ParserRULE_pictureChars)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3317)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserDOLLARCHAR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3301)
			p.Match(Cobol85ParserDOLLARCHAR)
		}

	case Cobol85ParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3302)
			p.Match(Cobol85ParserIDENTIFIER)
		}

	case Cobol85ParserNUMERICLITERAL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3303)
			p.Match(Cobol85ParserNUMERICLITERAL)
		}

	case Cobol85ParserSLASHCHAR:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3304)
			p.Match(Cobol85ParserSLASHCHAR)
		}

	case Cobol85ParserCOMMACHAR:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3305)
			p.Match(Cobol85ParserCOMMACHAR)
		}

	case Cobol85ParserDOT:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(3306)
			p.Match(Cobol85ParserDOT)
		}

	case Cobol85ParserCOLONCHAR:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(3307)
			p.Match(Cobol85ParserCOLONCHAR)
		}

	case Cobol85ParserASTERISKCHAR:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(3308)
			p.Match(Cobol85ParserASTERISKCHAR)
		}

	case Cobol85ParserDOUBLEASTERISKCHAR:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(3309)
			p.Match(Cobol85ParserDOUBLEASTERISKCHAR)
		}

	case Cobol85ParserLPARENCHAR:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(3310)
			p.Match(Cobol85ParserLPARENCHAR)
		}

	case Cobol85ParserRPARENCHAR:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(3311)
			p.Match(Cobol85ParserRPARENCHAR)
		}

	case Cobol85ParserPLUSCHAR:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(3312)
			p.Match(Cobol85ParserPLUSCHAR)
		}

	case Cobol85ParserMINUSCHAR:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(3313)
			p.Match(Cobol85ParserMINUSCHAR)
		}

	case Cobol85ParserLESSTHANCHAR:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(3314)
			p.Match(Cobol85ParserLESSTHANCHAR)
		}

	case Cobol85ParserMORETHANCHAR:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(3315)
			p.Match(Cobol85ParserMORETHANCHAR)
		}

	case Cobol85ParserLEVEL_NUMBER_66, Cobol85ParserLEVEL_NUMBER_77, Cobol85ParserLEVEL_NUMBER_88, Cobol85ParserINTEGERLITERAL:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(3316)
			p.IntegerLiteral()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPictureCardinalityContext is an interface to support dynamic dispatch.
type IPictureCardinalityContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPictureCardinalityContext differentiates from other interfaces.
	IsPictureCardinalityContext()
}

type PictureCardinalityContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPictureCardinalityContext() *PictureCardinalityContext {
	var p = new(PictureCardinalityContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_pictureCardinality
	return p
}

func (*PictureCardinalityContext) IsPictureCardinalityContext() {}

func NewPictureCardinalityContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PictureCardinalityContext {
	var p = new(PictureCardinalityContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_pictureCardinality

	return p
}

func (s *PictureCardinalityContext) GetParser() antlr.Parser { return s.parser }

func (s *PictureCardinalityContext) LPARENCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLPARENCHAR, 0)
}

func (s *PictureCardinalityContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *PictureCardinalityContext) RPARENCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRPARENCHAR, 0)
}

func (s *PictureCardinalityContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PictureCardinalityContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PictureCardinalityContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterPictureCardinality(s)
	}
}

func (s *PictureCardinalityContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitPictureCardinality(s)
	}
}

func (p *Cobol85Parser) PictureCardinality() (localctx IPictureCardinalityContext) {
	localctx = NewPictureCardinalityContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 470, Cobol85ParserRULE_pictureCardinality)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3319)
		p.Match(Cobol85ParserLPARENCHAR)
	}
	{
		p.SetState(3320)
		p.IntegerLiteral()
	}
	{
		p.SetState(3321)
		p.Match(Cobol85ParserRPARENCHAR)
	}

	return localctx
}

// IDataReceivedByClauseContext is an interface to support dynamic dispatch.
type IDataReceivedByClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataReceivedByClauseContext differentiates from other interfaces.
	IsDataReceivedByClauseContext()
}

type DataReceivedByClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataReceivedByClauseContext() *DataReceivedByClauseContext {
	var p = new(DataReceivedByClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataReceivedByClause
	return p
}

func (*DataReceivedByClauseContext) IsDataReceivedByClauseContext() {}

func NewDataReceivedByClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataReceivedByClauseContext {
	var p = new(DataReceivedByClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataReceivedByClause

	return p
}

func (s *DataReceivedByClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataReceivedByClauseContext) CONTENT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCONTENT, 0)
}

func (s *DataReceivedByClauseContext) REFERENCE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREFERENCE, 0)
}

func (s *DataReceivedByClauseContext) REF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREF, 0)
}

func (s *DataReceivedByClauseContext) RECEIVED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRECEIVED, 0)
}

func (s *DataReceivedByClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBY, 0)
}

func (s *DataReceivedByClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataReceivedByClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataReceivedByClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataReceivedByClause(s)
	}
}

func (s *DataReceivedByClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataReceivedByClause(s)
	}
}

func (p *Cobol85Parser) DataReceivedByClause() (localctx IDataReceivedByClauseContext) {
	localctx = NewDataReceivedByClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 472, Cobol85ParserRULE_dataReceivedByClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3324)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserRECEIVED {
		{
			p.SetState(3323)
			p.Match(Cobol85ParserRECEIVED)
		}

	}
	p.SetState(3327)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserBY {
		{
			p.SetState(3326)
			p.Match(Cobol85ParserBY)
		}

	}
	{
		p.SetState(3329)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserCONTENT || _la == Cobol85ParserREF || _la == Cobol85ParserREFERENCE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IDataRecordAreaClauseContext is an interface to support dynamic dispatch.
type IDataRecordAreaClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataRecordAreaClauseContext differentiates from other interfaces.
	IsDataRecordAreaClauseContext()
}

type DataRecordAreaClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataRecordAreaClauseContext() *DataRecordAreaClauseContext {
	var p = new(DataRecordAreaClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataRecordAreaClause
	return p
}

func (*DataRecordAreaClauseContext) IsDataRecordAreaClauseContext() {}

func NewDataRecordAreaClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataRecordAreaClauseContext {
	var p = new(DataRecordAreaClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataRecordAreaClause

	return p
}

func (s *DataRecordAreaClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataRecordAreaClauseContext) RECORD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRECORD, 0)
}

func (s *DataRecordAreaClauseContext) AREA() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAREA, 0)
}

func (s *DataRecordAreaClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataRecordAreaClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataRecordAreaClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataRecordAreaClause(s)
	}
}

func (s *DataRecordAreaClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataRecordAreaClause(s)
	}
}

func (p *Cobol85Parser) DataRecordAreaClause() (localctx IDataRecordAreaClauseContext) {
	localctx = NewDataRecordAreaClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 474, Cobol85ParserRULE_dataRecordAreaClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3331)
		p.Match(Cobol85ParserRECORD)
	}
	{
		p.SetState(3332)
		p.Match(Cobol85ParserAREA)
	}

	return localctx
}

// IDataRedefinesClauseContext is an interface to support dynamic dispatch.
type IDataRedefinesClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataRedefinesClauseContext differentiates from other interfaces.
	IsDataRedefinesClauseContext()
}

type DataRedefinesClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataRedefinesClauseContext() *DataRedefinesClauseContext {
	var p = new(DataRedefinesClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataRedefinesClause
	return p
}

func (*DataRedefinesClauseContext) IsDataRedefinesClauseContext() {}

func NewDataRedefinesClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataRedefinesClauseContext {
	var p = new(DataRedefinesClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataRedefinesClause

	return p
}

func (s *DataRedefinesClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataRedefinesClauseContext) REDEFINES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREDEFINES, 0)
}

func (s *DataRedefinesClauseContext) DataName() IDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *DataRedefinesClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataRedefinesClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataRedefinesClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataRedefinesClause(s)
	}
}

func (s *DataRedefinesClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataRedefinesClause(s)
	}
}

func (p *Cobol85Parser) DataRedefinesClause() (localctx IDataRedefinesClauseContext) {
	localctx = NewDataRedefinesClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 476, Cobol85ParserRULE_dataRedefinesClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3334)
		p.Match(Cobol85ParserREDEFINES)
	}
	{
		p.SetState(3335)
		p.DataName()
	}

	return localctx
}

// IDataRenamesClauseContext is an interface to support dynamic dispatch.
type IDataRenamesClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataRenamesClauseContext differentiates from other interfaces.
	IsDataRenamesClauseContext()
}

type DataRenamesClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataRenamesClauseContext() *DataRenamesClauseContext {
	var p = new(DataRenamesClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataRenamesClause
	return p
}

func (*DataRenamesClauseContext) IsDataRenamesClauseContext() {}

func NewDataRenamesClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataRenamesClauseContext {
	var p = new(DataRenamesClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataRenamesClause

	return p
}

func (s *DataRenamesClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataRenamesClauseContext) RENAMES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRENAMES, 0)
}

func (s *DataRenamesClauseContext) AllQualifiedDataName() []IQualifiedDataNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IQualifiedDataNameContext)(nil)).Elem())
	var tst = make([]IQualifiedDataNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IQualifiedDataNameContext)
		}
	}

	return tst
}

func (s *DataRenamesClauseContext) QualifiedDataName(i int) IQualifiedDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedDataNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *DataRenamesClauseContext) THROUGH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHROUGH, 0)
}

func (s *DataRenamesClauseContext) THRU() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHRU, 0)
}

func (s *DataRenamesClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataRenamesClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataRenamesClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataRenamesClause(s)
	}
}

func (s *DataRenamesClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataRenamesClause(s)
	}
}

func (p *Cobol85Parser) DataRenamesClause() (localctx IDataRenamesClauseContext) {
	localctx = NewDataRenamesClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 478, Cobol85ParserRULE_dataRenamesClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3337)
		p.Match(Cobol85ParserRENAMES)
	}
	{
		p.SetState(3338)
		p.QualifiedDataName()
	}
	p.SetState(3341)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserTHROUGH || _la == Cobol85ParserTHRU {
		{
			p.SetState(3339)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85ParserTHROUGH || _la == Cobol85ParserTHRU) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(3340)
			p.QualifiedDataName()
		}

	}

	return localctx
}

// IDataSignClauseContext is an interface to support dynamic dispatch.
type IDataSignClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataSignClauseContext differentiates from other interfaces.
	IsDataSignClauseContext()
}

type DataSignClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataSignClauseContext() *DataSignClauseContext {
	var p = new(DataSignClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataSignClause
	return p
}

func (*DataSignClauseContext) IsDataSignClauseContext() {}

func NewDataSignClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataSignClauseContext {
	var p = new(DataSignClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataSignClause

	return p
}

func (s *DataSignClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataSignClauseContext) LEADING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLEADING, 0)
}

func (s *DataSignClauseContext) TRAILING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTRAILING, 0)
}

func (s *DataSignClauseContext) SIGN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSIGN, 0)
}

func (s *DataSignClauseContext) SEPARATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSEPARATE, 0)
}

func (s *DataSignClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *DataSignClauseContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCHARACTER, 0)
}

func (s *DataSignClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataSignClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataSignClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataSignClause(s)
	}
}

func (s *DataSignClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataSignClause(s)
	}
}

func (p *Cobol85Parser) DataSignClause() (localctx IDataSignClauseContext) {
	localctx = NewDataSignClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 480, Cobol85ParserRULE_dataSignClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3347)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserSIGN {
		{
			p.SetState(3343)
			p.Match(Cobol85ParserSIGN)
		}
		p.SetState(3345)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserIS {
			{
				p.SetState(3344)
				p.Match(Cobol85ParserIS)
			}

		}

	}
	{
		p.SetState(3349)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserLEADING || _la == Cobol85ParserTRAILING) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(3354)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserSEPARATE {
		{
			p.SetState(3350)
			p.Match(Cobol85ParserSEPARATE)
		}
		p.SetState(3352)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserCHARACTER {
			{
				p.SetState(3351)
				p.Match(Cobol85ParserCHARACTER)
			}

		}

	}

	return localctx
}

// IDataSynchronizedClauseContext is an interface to support dynamic dispatch.
type IDataSynchronizedClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataSynchronizedClauseContext differentiates from other interfaces.
	IsDataSynchronizedClauseContext()
}

type DataSynchronizedClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataSynchronizedClauseContext() *DataSynchronizedClauseContext {
	var p = new(DataSynchronizedClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataSynchronizedClause
	return p
}

func (*DataSynchronizedClauseContext) IsDataSynchronizedClauseContext() {}

func NewDataSynchronizedClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataSynchronizedClauseContext {
	var p = new(DataSynchronizedClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataSynchronizedClause

	return p
}

func (s *DataSynchronizedClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataSynchronizedClauseContext) SYNCHRONIZED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSYNCHRONIZED, 0)
}

func (s *DataSynchronizedClauseContext) SYNC() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSYNC, 0)
}

func (s *DataSynchronizedClauseContext) LEFT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLEFT, 0)
}

func (s *DataSynchronizedClauseContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRIGHT, 0)
}

func (s *DataSynchronizedClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataSynchronizedClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataSynchronizedClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataSynchronizedClause(s)
	}
}

func (s *DataSynchronizedClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataSynchronizedClause(s)
	}
}

func (p *Cobol85Parser) DataSynchronizedClause() (localctx IDataSynchronizedClauseContext) {
	localctx = NewDataSynchronizedClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 482, Cobol85ParserRULE_dataSynchronizedClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3356)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserSYNC || _la == Cobol85ParserSYNCHRONIZED) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(3358)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserLEFT || _la == Cobol85ParserRIGHT {
		{
			p.SetState(3357)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85ParserLEFT || _la == Cobol85ParserRIGHT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

	return localctx
}

// IDataThreadLocalClauseContext is an interface to support dynamic dispatch.
type IDataThreadLocalClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataThreadLocalClauseContext differentiates from other interfaces.
	IsDataThreadLocalClauseContext()
}

type DataThreadLocalClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataThreadLocalClauseContext() *DataThreadLocalClauseContext {
	var p = new(DataThreadLocalClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataThreadLocalClause
	return p
}

func (*DataThreadLocalClauseContext) IsDataThreadLocalClauseContext() {}

func NewDataThreadLocalClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataThreadLocalClauseContext {
	var p = new(DataThreadLocalClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataThreadLocalClause

	return p
}

func (s *DataThreadLocalClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataThreadLocalClauseContext) THREAD_LOCAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHREAD_LOCAL, 0)
}

func (s *DataThreadLocalClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *DataThreadLocalClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataThreadLocalClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataThreadLocalClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataThreadLocalClause(s)
	}
}

func (s *DataThreadLocalClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataThreadLocalClause(s)
	}
}

func (p *Cobol85Parser) DataThreadLocalClause() (localctx IDataThreadLocalClauseContext) {
	localctx = NewDataThreadLocalClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 484, Cobol85ParserRULE_dataThreadLocalClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3361)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(3360)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(3363)
		p.Match(Cobol85ParserTHREAD_LOCAL)
	}

	return localctx
}

// IDataTypeClauseContext is an interface to support dynamic dispatch.
type IDataTypeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataTypeClauseContext differentiates from other interfaces.
	IsDataTypeClauseContext()
}

type DataTypeClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataTypeClauseContext() *DataTypeClauseContext {
	var p = new(DataTypeClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataTypeClause
	return p
}

func (*DataTypeClauseContext) IsDataTypeClauseContext() {}

func NewDataTypeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataTypeClauseContext {
	var p = new(DataTypeClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataTypeClause

	return p
}

func (s *DataTypeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataTypeClauseContext) TYPE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTYPE, 0)
}

func (s *DataTypeClauseContext) SHORT_DATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSHORT_DATE, 0)
}

func (s *DataTypeClauseContext) LONG_DATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLONG_DATE, 0)
}

func (s *DataTypeClauseContext) NUMERIC_DATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNUMERIC_DATE, 0)
}

func (s *DataTypeClauseContext) NUMERIC_TIME() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNUMERIC_TIME, 0)
}

func (s *DataTypeClauseContext) LONG_TIME() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLONG_TIME, 0)
}

func (s *DataTypeClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *DataTypeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataTypeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataTypeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataTypeClause(s)
	}
}

func (s *DataTypeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataTypeClause(s)
	}
}

func (p *Cobol85Parser) DataTypeClause() (localctx IDataTypeClauseContext) {
	localctx = NewDataTypeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 486, Cobol85ParserRULE_dataTypeClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3365)
		p.Match(Cobol85ParserTYPE)
	}
	p.SetState(3367)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(3366)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(3369)
		_la = p.GetTokenStream().LA(1)

		if !((((_la-287)&-(0x1f+1)) == 0 && ((1<<uint((_la-287)))&((1<<(Cobol85ParserLONG_DATE-287))|(1<<(Cobol85ParserLONG_TIME-287))|(1<<(Cobol85ParserNUMERIC_DATE-287)))) != 0) || _la == Cobol85ParserNUMERIC_TIME || _la == Cobol85ParserSHORT_DATE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IDataTypeDefClauseContext is an interface to support dynamic dispatch.
type IDataTypeDefClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataTypeDefClauseContext differentiates from other interfaces.
	IsDataTypeDefClauseContext()
}

type DataTypeDefClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataTypeDefClauseContext() *DataTypeDefClauseContext {
	var p = new(DataTypeDefClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataTypeDefClause
	return p
}

func (*DataTypeDefClauseContext) IsDataTypeDefClauseContext() {}

func NewDataTypeDefClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataTypeDefClauseContext {
	var p = new(DataTypeDefClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataTypeDefClause

	return p
}

func (s *DataTypeDefClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataTypeDefClauseContext) TYPEDEF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTYPEDEF, 0)
}

func (s *DataTypeDefClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *DataTypeDefClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataTypeDefClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataTypeDefClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataTypeDefClause(s)
	}
}

func (s *DataTypeDefClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataTypeDefClause(s)
	}
}

func (p *Cobol85Parser) DataTypeDefClause() (localctx IDataTypeDefClauseContext) {
	localctx = NewDataTypeDefClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 488, Cobol85ParserRULE_dataTypeDefClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3372)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(3371)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(3374)
		p.Match(Cobol85ParserTYPEDEF)
	}

	return localctx
}

// IDataUsageClauseContext is an interface to support dynamic dispatch.
type IDataUsageClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataUsageClauseContext differentiates from other interfaces.
	IsDataUsageClauseContext()
}

type DataUsageClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataUsageClauseContext() *DataUsageClauseContext {
	var p = new(DataUsageClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataUsageClause
	return p
}

func (*DataUsageClauseContext) IsDataUsageClauseContext() {}

func NewDataUsageClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataUsageClauseContext {
	var p = new(DataUsageClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataUsageClause

	return p
}

func (s *DataUsageClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataUsageClauseContext) BINARY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBINARY, 0)
}

func (s *DataUsageClauseContext) BIT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBIT, 0)
}

func (s *DataUsageClauseContext) COMP() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMP, 0)
}

func (s *DataUsageClauseContext) COMP_1() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMP_1, 0)
}

func (s *DataUsageClauseContext) COMP_2() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMP_2, 0)
}

func (s *DataUsageClauseContext) COMP_3() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMP_3, 0)
}

func (s *DataUsageClauseContext) COMP_4() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMP_4, 0)
}

func (s *DataUsageClauseContext) COMP_5() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMP_5, 0)
}

func (s *DataUsageClauseContext) COMPUTATIONAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMPUTATIONAL, 0)
}

func (s *DataUsageClauseContext) COMPUTATIONAL_1() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMPUTATIONAL_1, 0)
}

func (s *DataUsageClauseContext) COMPUTATIONAL_2() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMPUTATIONAL_2, 0)
}

func (s *DataUsageClauseContext) COMPUTATIONAL_3() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMPUTATIONAL_3, 0)
}

func (s *DataUsageClauseContext) COMPUTATIONAL_4() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMPUTATIONAL_4, 0)
}

func (s *DataUsageClauseContext) COMPUTATIONAL_5() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMPUTATIONAL_5, 0)
}

func (s *DataUsageClauseContext) CONTROL_POINT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCONTROL_POINT, 0)
}

func (s *DataUsageClauseContext) DATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDATE, 0)
}

func (s *DataUsageClauseContext) DISPLAY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDISPLAY, 0)
}

func (s *DataUsageClauseContext) DISPLAY_1() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDISPLAY_1, 0)
}

func (s *DataUsageClauseContext) DOUBLE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOUBLE, 0)
}

func (s *DataUsageClauseContext) EVENT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEVENT, 0)
}

func (s *DataUsageClauseContext) FUNCTION_POINTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFUNCTION_POINTER, 0)
}

func (s *DataUsageClauseContext) INDEX() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINDEX, 0)
}

func (s *DataUsageClauseContext) KANJI() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserKANJI, 0)
}

func (s *DataUsageClauseContext) LOCK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLOCK, 0)
}

func (s *DataUsageClauseContext) NATIONAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNATIONAL, 0)
}

func (s *DataUsageClauseContext) PACKED_DECIMAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPACKED_DECIMAL, 0)
}

func (s *DataUsageClauseContext) POINTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPOINTER, 0)
}

func (s *DataUsageClauseContext) PROCEDURE_POINTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPROCEDURE_POINTER, 0)
}

func (s *DataUsageClauseContext) REAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREAL, 0)
}

func (s *DataUsageClauseContext) TASK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTASK, 0)
}

func (s *DataUsageClauseContext) USAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserUSAGE, 0)
}

func (s *DataUsageClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *DataUsageClauseContext) TRUNCATED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTRUNCATED, 0)
}

func (s *DataUsageClauseContext) EXTENDED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEXTENDED, 0)
}

func (s *DataUsageClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataUsageClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataUsageClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataUsageClause(s)
	}
}

func (s *DataUsageClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataUsageClause(s)
	}
}

func (p *Cobol85Parser) DataUsageClause() (localctx IDataUsageClauseContext) {
	localctx = NewDataUsageClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 490, Cobol85ParserRULE_dataUsageClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3380)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserUSAGE {
		{
			p.SetState(3376)
			p.Match(Cobol85ParserUSAGE)
		}
		p.SetState(3378)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserIS {
			{
				p.SetState(3377)
				p.Match(Cobol85ParserIS)
			}

		}

	}
	p.SetState(3415)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserBINARY:
		{
			p.SetState(3382)
			p.Match(Cobol85ParserBINARY)
		}
		p.SetState(3384)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 430, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3383)
				_la = p.GetTokenStream().LA(1)

				if !(_la == Cobol85ParserEXTENDED || _la == Cobol85ParserTRUNCATED) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}

	case Cobol85ParserBIT:
		{
			p.SetState(3386)
			p.Match(Cobol85ParserBIT)
		}

	case Cobol85ParserCOMP:
		{
			p.SetState(3387)
			p.Match(Cobol85ParserCOMP)
		}

	case Cobol85ParserCOMP_1:
		{
			p.SetState(3388)
			p.Match(Cobol85ParserCOMP_1)
		}

	case Cobol85ParserCOMP_2:
		{
			p.SetState(3389)
			p.Match(Cobol85ParserCOMP_2)
		}

	case Cobol85ParserCOMP_3:
		{
			p.SetState(3390)
			p.Match(Cobol85ParserCOMP_3)
		}

	case Cobol85ParserCOMP_4:
		{
			p.SetState(3391)
			p.Match(Cobol85ParserCOMP_4)
		}

	case Cobol85ParserCOMP_5:
		{
			p.SetState(3392)
			p.Match(Cobol85ParserCOMP_5)
		}

	case Cobol85ParserCOMPUTATIONAL:
		{
			p.SetState(3393)
			p.Match(Cobol85ParserCOMPUTATIONAL)
		}

	case Cobol85ParserCOMPUTATIONAL_1:
		{
			p.SetState(3394)
			p.Match(Cobol85ParserCOMPUTATIONAL_1)
		}

	case Cobol85ParserCOMPUTATIONAL_2:
		{
			p.SetState(3395)
			p.Match(Cobol85ParserCOMPUTATIONAL_2)
		}

	case Cobol85ParserCOMPUTATIONAL_3:
		{
			p.SetState(3396)
			p.Match(Cobol85ParserCOMPUTATIONAL_3)
		}

	case Cobol85ParserCOMPUTATIONAL_4:
		{
			p.SetState(3397)
			p.Match(Cobol85ParserCOMPUTATIONAL_4)
		}

	case Cobol85ParserCOMPUTATIONAL_5:
		{
			p.SetState(3398)
			p.Match(Cobol85ParserCOMPUTATIONAL_5)
		}

	case Cobol85ParserCONTROL_POINT:
		{
			p.SetState(3399)
			p.Match(Cobol85ParserCONTROL_POINT)
		}

	case Cobol85ParserDATE:
		{
			p.SetState(3400)
			p.Match(Cobol85ParserDATE)
		}

	case Cobol85ParserDISPLAY:
		{
			p.SetState(3401)
			p.Match(Cobol85ParserDISPLAY)
		}

	case Cobol85ParserDISPLAY_1:
		{
			p.SetState(3402)
			p.Match(Cobol85ParserDISPLAY_1)
		}

	case Cobol85ParserDOUBLE:
		{
			p.SetState(3403)
			p.Match(Cobol85ParserDOUBLE)
		}

	case Cobol85ParserEVENT:
		{
			p.SetState(3404)
			p.Match(Cobol85ParserEVENT)
		}

	case Cobol85ParserFUNCTION_POINTER:
		{
			p.SetState(3405)
			p.Match(Cobol85ParserFUNCTION_POINTER)
		}

	case Cobol85ParserINDEX:
		{
			p.SetState(3406)
			p.Match(Cobol85ParserINDEX)
		}

	case Cobol85ParserKANJI:
		{
			p.SetState(3407)
			p.Match(Cobol85ParserKANJI)
		}

	case Cobol85ParserLOCK:
		{
			p.SetState(3408)
			p.Match(Cobol85ParserLOCK)
		}

	case Cobol85ParserNATIONAL:
		{
			p.SetState(3409)
			p.Match(Cobol85ParserNATIONAL)
		}

	case Cobol85ParserPACKED_DECIMAL:
		{
			p.SetState(3410)
			p.Match(Cobol85ParserPACKED_DECIMAL)
		}

	case Cobol85ParserPOINTER:
		{
			p.SetState(3411)
			p.Match(Cobol85ParserPOINTER)
		}

	case Cobol85ParserPROCEDURE_POINTER:
		{
			p.SetState(3412)
			p.Match(Cobol85ParserPROCEDURE_POINTER)
		}

	case Cobol85ParserREAL:
		{
			p.SetState(3413)
			p.Match(Cobol85ParserREAL)
		}

	case Cobol85ParserTASK:
		{
			p.SetState(3414)
			p.Match(Cobol85ParserTASK)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDataUsingClauseContext is an interface to support dynamic dispatch.
type IDataUsingClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataUsingClauseContext differentiates from other interfaces.
	IsDataUsingClauseContext()
}

type DataUsingClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataUsingClauseContext() *DataUsingClauseContext {
	var p = new(DataUsingClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataUsingClause
	return p
}

func (*DataUsingClauseContext) IsDataUsingClauseContext() {}

func NewDataUsingClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataUsingClauseContext {
	var p = new(DataUsingClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataUsingClause

	return p
}

func (s *DataUsingClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataUsingClauseContext) USING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserUSING, 0)
}

func (s *DataUsingClauseContext) LANGUAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLANGUAGE, 0)
}

func (s *DataUsingClauseContext) CONVENTION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCONVENTION, 0)
}

func (s *DataUsingClauseContext) CobolWord() ICobolWordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICobolWordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *DataUsingClauseContext) DataName() IDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *DataUsingClauseContext) OF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOF, 0)
}

func (s *DataUsingClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataUsingClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataUsingClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataUsingClause(s)
	}
}

func (s *DataUsingClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataUsingClause(s)
	}
}

func (p *Cobol85Parser) DataUsingClause() (localctx IDataUsingClauseContext) {
	localctx = NewDataUsingClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 492, Cobol85ParserRULE_dataUsingClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3417)
		p.Match(Cobol85ParserUSING)
	}
	{
		p.SetState(3418)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserCONVENTION || _la == Cobol85ParserLANGUAGE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(3420)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserOF {
		{
			p.SetState(3419)
			p.Match(Cobol85ParserOF)
		}

	}
	p.SetState(3424)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 433, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(3422)
			p.CobolWord()
		}

	case 2:
		{
			p.SetState(3423)
			p.DataName()
		}

	}

	return localctx
}

// IDataValueClauseContext is an interface to support dynamic dispatch.
type IDataValueClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataValueClauseContext differentiates from other interfaces.
	IsDataValueClauseContext()
}

type DataValueClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataValueClauseContext() *DataValueClauseContext {
	var p = new(DataValueClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataValueClause
	return p
}

func (*DataValueClauseContext) IsDataValueClauseContext() {}

func NewDataValueClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataValueClauseContext {
	var p = new(DataValueClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataValueClause

	return p
}

func (s *DataValueClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataValueClauseContext) AllDataValueInterval() []IDataValueIntervalContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDataValueIntervalContext)(nil)).Elem())
	var tst = make([]IDataValueIntervalContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDataValueIntervalContext)
		}
	}

	return tst
}

func (s *DataValueClauseContext) DataValueInterval(i int) IDataValueIntervalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataValueIntervalContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDataValueIntervalContext)
}

func (s *DataValueClauseContext) VALUE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserVALUE, 0)
}

func (s *DataValueClauseContext) VALUES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserVALUES, 0)
}

func (s *DataValueClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *DataValueClauseContext) ARE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserARE, 0)
}

func (s *DataValueClauseContext) AllCOMMACHAR() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserCOMMACHAR)
}

func (s *DataValueClauseContext) COMMACHAR(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMMACHAR, i)
}

func (s *DataValueClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataValueClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataValueClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataValueClause(s)
	}
}

func (s *DataValueClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataValueClause(s)
	}
}

func (p *Cobol85Parser) DataValueClause() (localctx IDataValueClauseContext) {
	localctx = NewDataValueClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 494, Cobol85ParserRULE_dataValueClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3434)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserVALUE:
		{
			p.SetState(3426)
			p.Match(Cobol85ParserVALUE)
		}
		p.SetState(3428)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserIS {
			{
				p.SetState(3427)
				p.Match(Cobol85ParserIS)
			}

		}

	case Cobol85ParserVALUES:
		{
			p.SetState(3430)
			p.Match(Cobol85ParserVALUES)
		}
		p.SetState(3432)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserARE {
			{
				p.SetState(3431)
				p.Match(Cobol85ParserARE)
			}

		}

	case Cobol85ParserABORT, Cobol85ParserALL, Cobol85ParserAS, Cobol85ParserASCII, Cobol85ParserASSOCIATED_DATA, Cobol85ParserASSOCIATED_DATA_LENGTH, Cobol85ParserATTRIBUTE, Cobol85ParserAUTO, Cobol85ParserAUTO_SKIP, Cobol85ParserBACKGROUND_COLOR, Cobol85ParserBACKGROUND_COLOUR, Cobol85ParserBEEP, Cobol85ParserBELL, Cobol85ParserBINARY, Cobol85ParserBIT, Cobol85ParserBLINK, Cobol85ParserBOUNDS, Cobol85ParserCAPABLE, Cobol85ParserCCSVERSION, Cobol85ParserCHANGED, Cobol85ParserCHANNEL, Cobol85ParserCLOSE_DISPOSITION, Cobol85ParserCOBOL, Cobol85ParserCOMMITMENT, Cobol85ParserCONTROL_POINT, Cobol85ParserCONVENTION, Cobol85ParserCRUNCH, Cobol85ParserCURSOR, Cobol85ParserDEFAULT, Cobol85ParserDEFAULT_DISPLAY, Cobol85ParserDEFINITION, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserDISK, Cobol85ParserDONTCARE, Cobol85ParserDOUBLE, Cobol85ParserEBCDIC, Cobol85ParserEMPTY_CHECK, Cobol85ParserENTER, Cobol85ParserENTRY_PROCEDURE, Cobol85ParserERASE, Cobol85ParserEOL, Cobol85ParserEOS, Cobol85ParserESCAPE, Cobol85ParserEVENT, Cobol85ParserEXCLUSIVE, Cobol85ParserEXPORT, Cobol85ParserEXTENDED, Cobol85ParserFALSE, Cobol85ParserFOREGROUND_COLOR, Cobol85ParserFOREGROUND_COLOUR, Cobol85ParserFULL, Cobol85ParserFUNCTIONNAME, Cobol85ParserFUNCTION_POINTER, Cobol85ParserGRID, Cobol85ParserHIGHLIGHT, Cobol85ParserHIGH_VALUE, Cobol85ParserHIGH_VALUES, Cobol85ParserIMPLICIT, Cobol85ParserIMPORT, Cobol85ParserINTEGER, Cobol85ParserKEPT, Cobol85ParserKEYBOARD, Cobol85ParserLANGUAGE, Cobol85ParserLB, Cobol85ParserLD, Cobol85ParserLEFTLINE, Cobol85ParserLENGTH_CHECK, Cobol85ParserLIBACCESS, Cobol85ParserLIBPARAMETER, Cobol85ParserLIBRARY, Cobol85ParserLIST, Cobol85ParserLOCAL, Cobol85ParserLONG_DATE, Cobol85ParserLONG_TIME, Cobol85ParserLOWER, Cobol85ParserLOWLIGHT, Cobol85ParserLOW_VALUE, Cobol85ParserLOW_VALUES, Cobol85ParserMMDDYYYY, Cobol85ParserNAMED, Cobol85ParserNATIONAL, Cobol85ParserNATIONAL_EDITED, Cobol85ParserNETWORK, Cobol85ParserNO_ECHO, Cobol85ParserNULL, Cobol85ParserNULLS, Cobol85ParserNUMERIC_DATE, Cobol85ParserNUMERIC_TIME, Cobol85ParserODT, Cobol85ParserORDERLY, Cobol85ParserOVERLINE, Cobol85ParserOWN, Cobol85ParserPASSWORD, Cobol85ParserPORT, Cobol85ParserPRINTER, Cobol85ParserPRIVATE, Cobol85ParserPROCESS, Cobol85ParserPROGRAM, Cobol85ParserPROMPT, Cobol85ParserQUOTE, Cobol85ParserQUOTES, Cobol85ParserREADER, Cobol85ParserREMOTE, Cobol85ParserREAL, Cobol85ParserRECEIVED, Cobol85ParserRECURSIVE, Cobol85ParserREF, Cobol85ParserREMOVE, Cobol85ParserREQUIRED, Cobol85ParserREVERSE_VIDEO, Cobol85ParserSAVE, Cobol85ParserSECURE, Cobol85ParserSHARED, Cobol85ParserSHAREDBYALL, Cobol85ParserSHAREDBYRUNUNIT, Cobol85ParserSHARING, Cobol85ParserSHORT_DATE, Cobol85ParserSPACE, Cobol85ParserSPACES, Cobol85ParserSYMBOL, Cobol85ParserTASK, Cobol85ParserTHREAD, Cobol85ParserTHREAD_LOCAL, Cobol85ParserTIMER, Cobol85ParserTODAYS_DATE, Cobol85ParserTODAYS_NAME, Cobol85ParserTRUE, Cobol85ParserTRUNCATED, Cobol85ParserTYPEDEF, Cobol85ParserUNDERLINE, Cobol85ParserVIRTUAL, Cobol85ParserWAIT, Cobol85ParserYEAR, Cobol85ParserYYYYMMDD, Cobol85ParserYYYYDDD, Cobol85ParserZERO, Cobol85ParserZERO_FILL, Cobol85ParserZEROS, Cobol85ParserZEROES, Cobol85ParserNONNUMERICLITERAL, Cobol85ParserLEVEL_NUMBER_66, Cobol85ParserLEVEL_NUMBER_77, Cobol85ParserLEVEL_NUMBER_88, Cobol85ParserINTEGERLITERAL, Cobol85ParserNUMERICLITERAL, Cobol85ParserIDENTIFIER:

	default:
	}
	{
		p.SetState(3436)
		p.DataValueInterval()
	}
	p.SetState(3443)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 438, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(3438)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == Cobol85ParserCOMMACHAR {
				{
					p.SetState(3437)
					p.Match(Cobol85ParserCOMMACHAR)
				}

			}
			{
				p.SetState(3440)
				p.DataValueInterval()
			}

		}
		p.SetState(3445)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 438, p.GetParserRuleContext())
	}

	return localctx
}

// IDataValueIntervalContext is an interface to support dynamic dispatch.
type IDataValueIntervalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataValueIntervalContext differentiates from other interfaces.
	IsDataValueIntervalContext()
}

type DataValueIntervalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataValueIntervalContext() *DataValueIntervalContext {
	var p = new(DataValueIntervalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataValueInterval
	return p
}

func (*DataValueIntervalContext) IsDataValueIntervalContext() {}

func NewDataValueIntervalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataValueIntervalContext {
	var p = new(DataValueIntervalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataValueInterval

	return p
}

func (s *DataValueIntervalContext) GetParser() antlr.Parser { return s.parser }

func (s *DataValueIntervalContext) DataValueIntervalFrom() IDataValueIntervalFromContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataValueIntervalFromContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataValueIntervalFromContext)
}

func (s *DataValueIntervalContext) DataValueIntervalTo() IDataValueIntervalToContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataValueIntervalToContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataValueIntervalToContext)
}

func (s *DataValueIntervalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataValueIntervalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataValueIntervalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataValueInterval(s)
	}
}

func (s *DataValueIntervalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataValueInterval(s)
	}
}

func (p *Cobol85Parser) DataValueInterval() (localctx IDataValueIntervalContext) {
	localctx = NewDataValueIntervalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 496, Cobol85ParserRULE_dataValueInterval)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3446)
		p.DataValueIntervalFrom()
	}
	p.SetState(3448)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserTHROUGH || _la == Cobol85ParserTHRU {
		{
			p.SetState(3447)
			p.DataValueIntervalTo()
		}

	}

	return localctx
}

// IDataValueIntervalFromContext is an interface to support dynamic dispatch.
type IDataValueIntervalFromContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataValueIntervalFromContext differentiates from other interfaces.
	IsDataValueIntervalFromContext()
}

type DataValueIntervalFromContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataValueIntervalFromContext() *DataValueIntervalFromContext {
	var p = new(DataValueIntervalFromContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataValueIntervalFrom
	return p
}

func (*DataValueIntervalFromContext) IsDataValueIntervalFromContext() {}

func NewDataValueIntervalFromContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataValueIntervalFromContext {
	var p = new(DataValueIntervalFromContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataValueIntervalFrom

	return p
}

func (s *DataValueIntervalFromContext) GetParser() antlr.Parser { return s.parser }

func (s *DataValueIntervalFromContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *DataValueIntervalFromContext) CobolWord() ICobolWordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICobolWordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *DataValueIntervalFromContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataValueIntervalFromContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataValueIntervalFromContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataValueIntervalFrom(s)
	}
}

func (s *DataValueIntervalFromContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataValueIntervalFrom(s)
	}
}

func (p *Cobol85Parser) DataValueIntervalFrom() (localctx IDataValueIntervalFromContext) {
	localctx = NewDataValueIntervalFromContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 498, Cobol85ParserRULE_dataValueIntervalFrom)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3452)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 440, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3450)
			p.Literal()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3451)
			p.CobolWord()
		}

	}

	return localctx
}

// IDataValueIntervalToContext is an interface to support dynamic dispatch.
type IDataValueIntervalToContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataValueIntervalToContext differentiates from other interfaces.
	IsDataValueIntervalToContext()
}

type DataValueIntervalToContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataValueIntervalToContext() *DataValueIntervalToContext {
	var p = new(DataValueIntervalToContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataValueIntervalTo
	return p
}

func (*DataValueIntervalToContext) IsDataValueIntervalToContext() {}

func NewDataValueIntervalToContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataValueIntervalToContext {
	var p = new(DataValueIntervalToContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataValueIntervalTo

	return p
}

func (s *DataValueIntervalToContext) GetParser() antlr.Parser { return s.parser }

func (s *DataValueIntervalToContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *DataValueIntervalToContext) THROUGH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHROUGH, 0)
}

func (s *DataValueIntervalToContext) THRU() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHRU, 0)
}

func (s *DataValueIntervalToContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataValueIntervalToContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataValueIntervalToContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataValueIntervalTo(s)
	}
}

func (s *DataValueIntervalToContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataValueIntervalTo(s)
	}
}

func (p *Cobol85Parser) DataValueIntervalTo() (localctx IDataValueIntervalToContext) {
	localctx = NewDataValueIntervalToContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 500, Cobol85ParserRULE_dataValueIntervalTo)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3454)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserTHROUGH || _la == Cobol85ParserTHRU) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(3455)
		p.Literal()
	}

	return localctx
}

// IDataWithLowerBoundsClauseContext is an interface to support dynamic dispatch.
type IDataWithLowerBoundsClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataWithLowerBoundsClauseContext differentiates from other interfaces.
	IsDataWithLowerBoundsClauseContext()
}

type DataWithLowerBoundsClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataWithLowerBoundsClauseContext() *DataWithLowerBoundsClauseContext {
	var p = new(DataWithLowerBoundsClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataWithLowerBoundsClause
	return p
}

func (*DataWithLowerBoundsClauseContext) IsDataWithLowerBoundsClauseContext() {}

func NewDataWithLowerBoundsClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataWithLowerBoundsClauseContext {
	var p = new(DataWithLowerBoundsClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataWithLowerBoundsClause

	return p
}

func (s *DataWithLowerBoundsClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataWithLowerBoundsClauseContext) LOWER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLOWER, 0)
}

func (s *DataWithLowerBoundsClauseContext) BOUNDS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBOUNDS, 0)
}

func (s *DataWithLowerBoundsClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWITH, 0)
}

func (s *DataWithLowerBoundsClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataWithLowerBoundsClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataWithLowerBoundsClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataWithLowerBoundsClause(s)
	}
}

func (s *DataWithLowerBoundsClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataWithLowerBoundsClause(s)
	}
}

func (p *Cobol85Parser) DataWithLowerBoundsClause() (localctx IDataWithLowerBoundsClauseContext) {
	localctx = NewDataWithLowerBoundsClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 502, Cobol85ParserRULE_dataWithLowerBoundsClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3458)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserWITH {
		{
			p.SetState(3457)
			p.Match(Cobol85ParserWITH)
		}

	}
	{
		p.SetState(3460)
		p.Match(Cobol85ParserLOWER)
	}
	{
		p.SetState(3461)
		p.Match(Cobol85ParserBOUNDS)
	}

	return localctx
}

// IProcedureDivisionContext is an interface to support dynamic dispatch.
type IProcedureDivisionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedureDivisionContext differentiates from other interfaces.
	IsProcedureDivisionContext()
}

type ProcedureDivisionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureDivisionContext() *ProcedureDivisionContext {
	var p = new(ProcedureDivisionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_procedureDivision
	return p
}

func (*ProcedureDivisionContext) IsProcedureDivisionContext() {}

func NewProcedureDivisionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureDivisionContext {
	var p = new(ProcedureDivisionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_procedureDivision

	return p
}

func (s *ProcedureDivisionContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureDivisionContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPROCEDURE, 0)
}

func (s *ProcedureDivisionContext) DIVISION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDIVISION, 0)
}

func (s *ProcedureDivisionContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *ProcedureDivisionContext) ProcedureDivisionBody() IProcedureDivisionBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedureDivisionBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedureDivisionBodyContext)
}

func (s *ProcedureDivisionContext) ProcedureDivisionUsingClause() IProcedureDivisionUsingClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedureDivisionUsingClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedureDivisionUsingClauseContext)
}

func (s *ProcedureDivisionContext) ProcedureDivisionGivingClause() IProcedureDivisionGivingClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedureDivisionGivingClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedureDivisionGivingClauseContext)
}

func (s *ProcedureDivisionContext) ProcedureDeclaratives() IProcedureDeclarativesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedureDeclarativesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedureDeclarativesContext)
}

func (s *ProcedureDivisionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureDivisionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureDivisionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterProcedureDivision(s)
	}
}

func (s *ProcedureDivisionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitProcedureDivision(s)
	}
}

func (p *Cobol85Parser) ProcedureDivision() (localctx IProcedureDivisionContext) {
	localctx = NewProcedureDivisionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 504, Cobol85ParserRULE_procedureDivision)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3463)
		p.Match(Cobol85ParserPROCEDURE)
	}
	{
		p.SetState(3464)
		p.Match(Cobol85ParserDIVISION)
	}
	p.SetState(3466)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCHAINING || _la == Cobol85ParserUSING {
		{
			p.SetState(3465)
			p.ProcedureDivisionUsingClause()
		}

	}
	p.SetState(3469)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserGIVING || _la == Cobol85ParserRETURNING {
		{
			p.SetState(3468)
			p.ProcedureDivisionGivingClause()
		}

	}
	{
		p.SetState(3471)
		p.Match(Cobol85ParserDOT_FS)
	}
	p.SetState(3473)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserDECLARATIVES {
		{
			p.SetState(3472)
			p.ProcedureDeclaratives()
		}

	}
	{
		p.SetState(3475)
		p.ProcedureDivisionBody()
	}

	return localctx
}

// IProcedureDivisionUsingClauseContext is an interface to support dynamic dispatch.
type IProcedureDivisionUsingClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedureDivisionUsingClauseContext differentiates from other interfaces.
	IsProcedureDivisionUsingClauseContext()
}

type ProcedureDivisionUsingClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureDivisionUsingClauseContext() *ProcedureDivisionUsingClauseContext {
	var p = new(ProcedureDivisionUsingClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_procedureDivisionUsingClause
	return p
}

func (*ProcedureDivisionUsingClauseContext) IsProcedureDivisionUsingClauseContext() {}

func NewProcedureDivisionUsingClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureDivisionUsingClauseContext {
	var p = new(ProcedureDivisionUsingClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_procedureDivisionUsingClause

	return p
}

func (s *ProcedureDivisionUsingClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureDivisionUsingClauseContext) USING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserUSING, 0)
}

func (s *ProcedureDivisionUsingClauseContext) CHAINING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCHAINING, 0)
}

func (s *ProcedureDivisionUsingClauseContext) AllProcedureDivisionUsingParameter() []IProcedureDivisionUsingParameterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IProcedureDivisionUsingParameterContext)(nil)).Elem())
	var tst = make([]IProcedureDivisionUsingParameterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IProcedureDivisionUsingParameterContext)
		}
	}

	return tst
}

func (s *ProcedureDivisionUsingClauseContext) ProcedureDivisionUsingParameter(i int) IProcedureDivisionUsingParameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedureDivisionUsingParameterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IProcedureDivisionUsingParameterContext)
}

func (s *ProcedureDivisionUsingClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureDivisionUsingClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureDivisionUsingClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterProcedureDivisionUsingClause(s)
	}
}

func (s *ProcedureDivisionUsingClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitProcedureDivisionUsingClause(s)
	}
}

func (p *Cobol85Parser) ProcedureDivisionUsingClause() (localctx IProcedureDivisionUsingClauseContext) {
	localctx = NewProcedureDivisionUsingClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 506, Cobol85ParserRULE_procedureDivisionUsingClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3477)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserCHAINING || _la == Cobol85ParserUSING) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(3479)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserADDRESS)|(1<<Cobol85ParserANY)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH)|(1<<Cobol85ParserATTRIBUTE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBINARY-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserBY-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-68))|(1<<(Cobol85ParserCOBOL-68))|(1<<(Cobol85ParserCOMMITMENT-68))|(1<<(Cobol85ParserCONTROL_POINT-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(Cobol85ParserCONVENTION-100))|(1<<(Cobol85ParserCRUNCH-100))|(1<<(Cobol85ParserCURSOR-100))|(1<<(Cobol85ParserDATE-100))|(1<<(Cobol85ParserDAY-100))|(1<<(Cobol85ParserDAY_OF_WEEK-100))|(1<<(Cobol85ParserDEBUG_CONTENTS-100))|(1<<(Cobol85ParserDEBUG_ITEM-100))|(1<<(Cobol85ParserDEBUG_LINE-100))|(1<<(Cobol85ParserDEBUG_NAME-100))|(1<<(Cobol85ParserDEBUG_SUB_1-100))|(1<<(Cobol85ParserDEBUG_SUB_2-100))|(1<<(Cobol85ParserDEBUG_SUB_3-100))|(1<<(Cobol85ParserDEFAULT-100))|(1<<(Cobol85ParserDEFAULT_DISPLAY-100))|(1<<(Cobol85ParserDEFINITION-100)))) != 0) || (((_la-138)&-(0x1f+1)) == 0 && ((1<<uint((_la-138)))&((1<<(Cobol85ParserDFHRESP-138))|(1<<(Cobol85ParserDFHVALUE-138))|(1<<(Cobol85ParserDISK-138))|(1<<(Cobol85ParserDONTCARE-138))|(1<<(Cobol85ParserDOUBLE-138))|(1<<(Cobol85ParserEBCDIC-138))|(1<<(Cobol85ParserEMPTY_CHECK-138)))) != 0) || (((_la-181)&-(0x1f+1)) == 0 && ((1<<uint((_la-181)))&((1<<(Cobol85ParserENTER-181))|(1<<(Cobol85ParserENTRY_PROCEDURE-181))|(1<<(Cobol85ParserERASE-181))|(1<<(Cobol85ParserEOL-181))|(1<<(Cobol85ParserEOS-181))|(1<<(Cobol85ParserESCAPE-181))|(1<<(Cobol85ParserEVENT-181))|(1<<(Cobol85ParserEXCLUSIVE-181))|(1<<(Cobol85ParserEXPORT-181))|(1<<(Cobol85ParserEXTENDED-181)))) != 0) || (((_la-213)&-(0x1f+1)) == 0 && ((1<<uint((_la-213)))&((1<<(Cobol85ParserFOREGROUND_COLOR-213))|(1<<(Cobol85ParserFOREGROUND_COLOUR-213))|(1<<(Cobol85ParserFULL-213))|(1<<(Cobol85ParserFUNCTION-213))|(1<<(Cobol85ParserFUNCTIONNAME-213))|(1<<(Cobol85ParserFUNCTION_POINTER-213))|(1<<(Cobol85ParserGRID-213))|(1<<(Cobol85ParserHIGHLIGHT-213))|(1<<(Cobol85ParserIMPLICIT-213))|(1<<(Cobol85ParserIMPORT-213)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(Cobol85ParserINTEGER-250))|(1<<(Cobol85ParserKEPT-250))|(1<<(Cobol85ParserKEYBOARD-250))|(1<<(Cobol85ParserLANGUAGE-250))|(1<<(Cobol85ParserLB-250))|(1<<(Cobol85ParserLD-250))|(1<<(Cobol85ParserLEFTLINE-250))|(1<<(Cobol85ParserLENGTH-250))|(1<<(Cobol85ParserLENGTH_CHECK-250))|(1<<(Cobol85ParserLIBACCESS-250))|(1<<(Cobol85ParserLIBPARAMETER-250))|(1<<(Cobol85ParserLIBRARY-250))|(1<<(Cobol85ParserLINAGE_COUNTER-250))|(1<<(Cobol85ParserLINE_COUNTER-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(Cobol85ParserLIST-283))|(1<<(Cobol85ParserLOCAL-283))|(1<<(Cobol85ParserLONG_DATE-283))|(1<<(Cobol85ParserLONG_TIME-283))|(1<<(Cobol85ParserLOWER-283))|(1<<(Cobol85ParserLOWLIGHT-283))|(1<<(Cobol85ParserMMDDYYYY-283))|(1<<(Cobol85ParserNAMED-283))|(1<<(Cobol85ParserNATIONAL-283))|(1<<(Cobol85ParserNATIONAL_EDITED-283))|(1<<(Cobol85ParserNETWORK-283))|(1<<(Cobol85ParserNO_ECHO-283)))) != 0) || (((_la-317)&-(0x1f+1)) == 0 && ((1<<uint((_la-317)))&((1<<(Cobol85ParserNUMERIC_DATE-317))|(1<<(Cobol85ParserNUMERIC_TIME-317))|(1<<(Cobol85ParserODT-317))|(1<<(Cobol85ParserOPTIONAL-317))|(1<<(Cobol85ParserORDERLY-317))|(1<<(Cobol85ParserOVERLINE-317))|(1<<(Cobol85ParserOWN-317))|(1<<(Cobol85ParserPAGE_COUNTER-317))|(1<<(Cobol85ParserPASSWORD-317)))) != 0) || (((_la-352)&-(0x1f+1)) == 0 && ((1<<uint((_la-352)))&((1<<(Cobol85ParserPORT-352))|(1<<(Cobol85ParserPRINTER-352))|(1<<(Cobol85ParserPRIVATE-352))|(1<<(Cobol85ParserPROCESS-352))|(1<<(Cobol85ParserPROGRAM-352))|(1<<(Cobol85ParserPROMPT-352))|(1<<(Cobol85ParserREADER-352))|(1<<(Cobol85ParserREMOTE-352))|(1<<(Cobol85ParserREAL-352))|(1<<(Cobol85ParserRECEIVED-352))|(1<<(Cobol85ParserRECURSIVE-352))|(1<<(Cobol85ParserREF-352)))) != 0) || (((_la-384)&-(0x1f+1)) == 0 && ((1<<uint((_la-384)))&((1<<(Cobol85ParserREFERENCE-384))|(1<<(Cobol85ParserREMOVE-384))|(1<<(Cobol85ParserREQUIRED-384))|(1<<(Cobol85ParserREVERSE_VIDEO-384))|(1<<(Cobol85ParserRETURN_CODE-384))|(1<<(Cobol85ParserSAVE-384)))) != 0) || (((_la-420)&-(0x1f+1)) == 0 && ((1<<uint((_la-420)))&((1<<(Cobol85ParserSECURE-420))|(1<<(Cobol85ParserSHARED-420))|(1<<(Cobol85ParserSHAREDBYALL-420))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-420))|(1<<(Cobol85ParserSHARING-420))|(1<<(Cobol85ParserSHIFT_IN-420))|(1<<(Cobol85ParserSHIFT_OUT-420))|(1<<(Cobol85ParserSHORT_DATE-420))|(1<<(Cobol85ParserSORT_CONTROL-420))|(1<<(Cobol85ParserSORT_CORE_SIZE-420))|(1<<(Cobol85ParserSORT_FILE_SIZE-420))|(1<<(Cobol85ParserSORT_MESSAGE-420))|(1<<(Cobol85ParserSORT_MODE_SIZE-420))|(1<<(Cobol85ParserSORT_RETURN-420)))) != 0) || (((_la-466)&-(0x1f+1)) == 0 && ((1<<uint((_la-466)))&((1<<(Cobol85ParserSYMBOL-466))|(1<<(Cobol85ParserTALLY-466))|(1<<(Cobol85ParserTASK-466))|(1<<(Cobol85ParserTHREAD-466))|(1<<(Cobol85ParserTHREAD_LOCAL-466))|(1<<(Cobol85ParserTIME-466))|(1<<(Cobol85ParserTIMER-466))|(1<<(Cobol85ParserTODAYS_DATE-466))|(1<<(Cobol85ParserTODAYS_NAME-466))|(1<<(Cobol85ParserTRUNCATED-466))|(1<<(Cobol85ParserTYPEDEF-466)))) != 0) || (((_la-498)&-(0x1f+1)) == 0 && ((1<<uint((_la-498)))&((1<<(Cobol85ParserUNDERLINE-498))|(1<<(Cobol85ParserVALUE-498))|(1<<(Cobol85ParserVIRTUAL-498))|(1<<(Cobol85ParserWAIT-498))|(1<<(Cobol85ParserWHEN_COMPILED-498))|(1<<(Cobol85ParserYEAR-498))|(1<<(Cobol85ParserYYYYMMDD-498))|(1<<(Cobol85ParserYYYYDDD-498))|(1<<(Cobol85ParserZERO_FILL-498)))) != 0) || (((_la-552)&-(0x1f+1)) == 0 && ((1<<uint((_la-552)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-552))|(1<<(Cobol85ParserLEVEL_NUMBER_77-552))|(1<<(Cobol85ParserLEVEL_NUMBER_88-552))|(1<<(Cobol85ParserINTEGERLITERAL-552))|(1<<(Cobol85ParserIDENTIFIER-552)))) != 0) {
		{
			p.SetState(3478)
			p.ProcedureDivisionUsingParameter()
		}

		p.SetState(3481)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IProcedureDivisionGivingClauseContext is an interface to support dynamic dispatch.
type IProcedureDivisionGivingClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedureDivisionGivingClauseContext differentiates from other interfaces.
	IsProcedureDivisionGivingClauseContext()
}

type ProcedureDivisionGivingClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureDivisionGivingClauseContext() *ProcedureDivisionGivingClauseContext {
	var p = new(ProcedureDivisionGivingClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_procedureDivisionGivingClause
	return p
}

func (*ProcedureDivisionGivingClauseContext) IsProcedureDivisionGivingClauseContext() {}

func NewProcedureDivisionGivingClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureDivisionGivingClauseContext {
	var p = new(ProcedureDivisionGivingClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_procedureDivisionGivingClause

	return p
}

func (s *ProcedureDivisionGivingClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureDivisionGivingClauseContext) DataName() IDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *ProcedureDivisionGivingClauseContext) GIVING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserGIVING, 0)
}

func (s *ProcedureDivisionGivingClauseContext) RETURNING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRETURNING, 0)
}

func (s *ProcedureDivisionGivingClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureDivisionGivingClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureDivisionGivingClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterProcedureDivisionGivingClause(s)
	}
}

func (s *ProcedureDivisionGivingClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitProcedureDivisionGivingClause(s)
	}
}

func (p *Cobol85Parser) ProcedureDivisionGivingClause() (localctx IProcedureDivisionGivingClauseContext) {
	localctx = NewProcedureDivisionGivingClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 508, Cobol85ParserRULE_procedureDivisionGivingClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3483)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserGIVING || _la == Cobol85ParserRETURNING) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(3484)
		p.DataName()
	}

	return localctx
}

// IProcedureDivisionUsingParameterContext is an interface to support dynamic dispatch.
type IProcedureDivisionUsingParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedureDivisionUsingParameterContext differentiates from other interfaces.
	IsProcedureDivisionUsingParameterContext()
}

type ProcedureDivisionUsingParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureDivisionUsingParameterContext() *ProcedureDivisionUsingParameterContext {
	var p = new(ProcedureDivisionUsingParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_procedureDivisionUsingParameter
	return p
}

func (*ProcedureDivisionUsingParameterContext) IsProcedureDivisionUsingParameterContext() {}

func NewProcedureDivisionUsingParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureDivisionUsingParameterContext {
	var p = new(ProcedureDivisionUsingParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_procedureDivisionUsingParameter

	return p
}

func (s *ProcedureDivisionUsingParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureDivisionUsingParameterContext) ProcedureDivisionByReferencePhrase() IProcedureDivisionByReferencePhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedureDivisionByReferencePhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedureDivisionByReferencePhraseContext)
}

func (s *ProcedureDivisionUsingParameterContext) ProcedureDivisionByValuePhrase() IProcedureDivisionByValuePhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedureDivisionByValuePhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedureDivisionByValuePhraseContext)
}

func (s *ProcedureDivisionUsingParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureDivisionUsingParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureDivisionUsingParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterProcedureDivisionUsingParameter(s)
	}
}

func (s *ProcedureDivisionUsingParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitProcedureDivisionUsingParameter(s)
	}
}

func (p *Cobol85Parser) ProcedureDivisionUsingParameter() (localctx IProcedureDivisionUsingParameterContext) {
	localctx = NewProcedureDivisionUsingParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 510, Cobol85ParserRULE_procedureDivisionUsingParameter)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3488)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 446, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3486)
			p.ProcedureDivisionByReferencePhrase()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3487)
			p.ProcedureDivisionByValuePhrase()
		}

	}

	return localctx
}

// IProcedureDivisionByReferencePhraseContext is an interface to support dynamic dispatch.
type IProcedureDivisionByReferencePhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedureDivisionByReferencePhraseContext differentiates from other interfaces.
	IsProcedureDivisionByReferencePhraseContext()
}

type ProcedureDivisionByReferencePhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureDivisionByReferencePhraseContext() *ProcedureDivisionByReferencePhraseContext {
	var p = new(ProcedureDivisionByReferencePhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_procedureDivisionByReferencePhrase
	return p
}

func (*ProcedureDivisionByReferencePhraseContext) IsProcedureDivisionByReferencePhraseContext() {}

func NewProcedureDivisionByReferencePhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureDivisionByReferencePhraseContext {
	var p = new(ProcedureDivisionByReferencePhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_procedureDivisionByReferencePhrase

	return p
}

func (s *ProcedureDivisionByReferencePhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureDivisionByReferencePhraseContext) REFERENCE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREFERENCE, 0)
}

func (s *ProcedureDivisionByReferencePhraseContext) AllProcedureDivisionByReference() []IProcedureDivisionByReferenceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IProcedureDivisionByReferenceContext)(nil)).Elem())
	var tst = make([]IProcedureDivisionByReferenceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IProcedureDivisionByReferenceContext)
		}
	}

	return tst
}

func (s *ProcedureDivisionByReferencePhraseContext) ProcedureDivisionByReference(i int) IProcedureDivisionByReferenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedureDivisionByReferenceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IProcedureDivisionByReferenceContext)
}

func (s *ProcedureDivisionByReferencePhraseContext) BY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBY, 0)
}

func (s *ProcedureDivisionByReferencePhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureDivisionByReferencePhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureDivisionByReferencePhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterProcedureDivisionByReferencePhrase(s)
	}
}

func (s *ProcedureDivisionByReferencePhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitProcedureDivisionByReferencePhrase(s)
	}
}

func (p *Cobol85Parser) ProcedureDivisionByReferencePhrase() (localctx IProcedureDivisionByReferencePhraseContext) {
	localctx = NewProcedureDivisionByReferencePhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 512, Cobol85ParserRULE_procedureDivisionByReferencePhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3494)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserBY || _la == Cobol85ParserREFERENCE {
		p.SetState(3491)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserBY {
			{
				p.SetState(3490)
				p.Match(Cobol85ParserBY)
			}

		}
		{
			p.SetState(3493)
			p.Match(Cobol85ParserREFERENCE)
		}

	}
	p.SetState(3497)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(3496)
				p.ProcedureDivisionByReference()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(3499)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 449, p.GetParserRuleContext())
	}

	return localctx
}

// IProcedureDivisionByReferenceContext is an interface to support dynamic dispatch.
type IProcedureDivisionByReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedureDivisionByReferenceContext differentiates from other interfaces.
	IsProcedureDivisionByReferenceContext()
}

type ProcedureDivisionByReferenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureDivisionByReferenceContext() *ProcedureDivisionByReferenceContext {
	var p = new(ProcedureDivisionByReferenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_procedureDivisionByReference
	return p
}

func (*ProcedureDivisionByReferenceContext) IsProcedureDivisionByReferenceContext() {}

func NewProcedureDivisionByReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureDivisionByReferenceContext {
	var p = new(ProcedureDivisionByReferenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_procedureDivisionByReference

	return p
}

func (s *ProcedureDivisionByReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureDivisionByReferenceContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ProcedureDivisionByReferenceContext) FileName() IFileNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *ProcedureDivisionByReferenceContext) OPTIONAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOPTIONAL, 0)
}

func (s *ProcedureDivisionByReferenceContext) ANY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserANY, 0)
}

func (s *ProcedureDivisionByReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureDivisionByReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureDivisionByReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterProcedureDivisionByReference(s)
	}
}

func (s *ProcedureDivisionByReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitProcedureDivisionByReference(s)
	}
}

func (p *Cobol85Parser) ProcedureDivisionByReference() (localctx IProcedureDivisionByReferenceContext) {
	localctx = NewProcedureDivisionByReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 514, Cobol85ParserRULE_procedureDivisionByReference)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3509)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserABORT, Cobol85ParserADDRESS, Cobol85ParserAS, Cobol85ParserASCII, Cobol85ParserASSOCIATED_DATA, Cobol85ParserASSOCIATED_DATA_LENGTH, Cobol85ParserATTRIBUTE, Cobol85ParserAUTO, Cobol85ParserAUTO_SKIP, Cobol85ParserBACKGROUND_COLOR, Cobol85ParserBACKGROUND_COLOUR, Cobol85ParserBEEP, Cobol85ParserBELL, Cobol85ParserBINARY, Cobol85ParserBIT, Cobol85ParserBLINK, Cobol85ParserBOUNDS, Cobol85ParserCAPABLE, Cobol85ParserCCSVERSION, Cobol85ParserCHANGED, Cobol85ParserCHANNEL, Cobol85ParserCLOSE_DISPOSITION, Cobol85ParserCOBOL, Cobol85ParserCOMMITMENT, Cobol85ParserCONTROL_POINT, Cobol85ParserCONVENTION, Cobol85ParserCRUNCH, Cobol85ParserCURSOR, Cobol85ParserDATE, Cobol85ParserDAY, Cobol85ParserDAY_OF_WEEK, Cobol85ParserDEBUG_CONTENTS, Cobol85ParserDEBUG_ITEM, Cobol85ParserDEBUG_LINE, Cobol85ParserDEBUG_NAME, Cobol85ParserDEBUG_SUB_1, Cobol85ParserDEBUG_SUB_2, Cobol85ParserDEBUG_SUB_3, Cobol85ParserDEFAULT, Cobol85ParserDEFAULT_DISPLAY, Cobol85ParserDEFINITION, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserDISK, Cobol85ParserDONTCARE, Cobol85ParserDOUBLE, Cobol85ParserEBCDIC, Cobol85ParserEMPTY_CHECK, Cobol85ParserENTER, Cobol85ParserENTRY_PROCEDURE, Cobol85ParserERASE, Cobol85ParserEOL, Cobol85ParserEOS, Cobol85ParserESCAPE, Cobol85ParserEVENT, Cobol85ParserEXCLUSIVE, Cobol85ParserEXPORT, Cobol85ParserEXTENDED, Cobol85ParserFOREGROUND_COLOR, Cobol85ParserFOREGROUND_COLOUR, Cobol85ParserFULL, Cobol85ParserFUNCTION, Cobol85ParserFUNCTIONNAME, Cobol85ParserFUNCTION_POINTER, Cobol85ParserGRID, Cobol85ParserHIGHLIGHT, Cobol85ParserIMPLICIT, Cobol85ParserIMPORT, Cobol85ParserINTEGER, Cobol85ParserKEPT, Cobol85ParserKEYBOARD, Cobol85ParserLANGUAGE, Cobol85ParserLB, Cobol85ParserLD, Cobol85ParserLEFTLINE, Cobol85ParserLENGTH, Cobol85ParserLENGTH_CHECK, Cobol85ParserLIBACCESS, Cobol85ParserLIBPARAMETER, Cobol85ParserLIBRARY, Cobol85ParserLINAGE_COUNTER, Cobol85ParserLINE_COUNTER, Cobol85ParserLIST, Cobol85ParserLOCAL, Cobol85ParserLONG_DATE, Cobol85ParserLONG_TIME, Cobol85ParserLOWER, Cobol85ParserLOWLIGHT, Cobol85ParserMMDDYYYY, Cobol85ParserNAMED, Cobol85ParserNATIONAL, Cobol85ParserNATIONAL_EDITED, Cobol85ParserNETWORK, Cobol85ParserNO_ECHO, Cobol85ParserNUMERIC_DATE, Cobol85ParserNUMERIC_TIME, Cobol85ParserODT, Cobol85ParserOPTIONAL, Cobol85ParserORDERLY, Cobol85ParserOVERLINE, Cobol85ParserOWN, Cobol85ParserPAGE_COUNTER, Cobol85ParserPASSWORD, Cobol85ParserPORT, Cobol85ParserPRINTER, Cobol85ParserPRIVATE, Cobol85ParserPROCESS, Cobol85ParserPROGRAM, Cobol85ParserPROMPT, Cobol85ParserREADER, Cobol85ParserREMOTE, Cobol85ParserREAL, Cobol85ParserRECEIVED, Cobol85ParserRECURSIVE, Cobol85ParserREF, Cobol85ParserREMOVE, Cobol85ParserREQUIRED, Cobol85ParserREVERSE_VIDEO, Cobol85ParserRETURN_CODE, Cobol85ParserSAVE, Cobol85ParserSECURE, Cobol85ParserSHARED, Cobol85ParserSHAREDBYALL, Cobol85ParserSHAREDBYRUNUNIT, Cobol85ParserSHARING, Cobol85ParserSHIFT_IN, Cobol85ParserSHIFT_OUT, Cobol85ParserSHORT_DATE, Cobol85ParserSORT_CONTROL, Cobol85ParserSORT_CORE_SIZE, Cobol85ParserSORT_FILE_SIZE, Cobol85ParserSORT_MESSAGE, Cobol85ParserSORT_MODE_SIZE, Cobol85ParserSORT_RETURN, Cobol85ParserSYMBOL, Cobol85ParserTALLY, Cobol85ParserTASK, Cobol85ParserTHREAD, Cobol85ParserTHREAD_LOCAL, Cobol85ParserTIME, Cobol85ParserTIMER, Cobol85ParserTODAYS_DATE, Cobol85ParserTODAYS_NAME, Cobol85ParserTRUNCATED, Cobol85ParserTYPEDEF, Cobol85ParserUNDERLINE, Cobol85ParserVIRTUAL, Cobol85ParserWAIT, Cobol85ParserWHEN_COMPILED, Cobol85ParserYEAR, Cobol85ParserYYYYMMDD, Cobol85ParserYYYYDDD, Cobol85ParserZERO_FILL, Cobol85ParserLEVEL_NUMBER_66, Cobol85ParserLEVEL_NUMBER_77, Cobol85ParserLEVEL_NUMBER_88, Cobol85ParserINTEGERLITERAL, Cobol85ParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(3502)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserOPTIONAL {
			{
				p.SetState(3501)
				p.Match(Cobol85ParserOPTIONAL)
			}

		}
		p.SetState(3506)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 451, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(3504)
				p.Identifier()
			}

		case 2:
			{
				p.SetState(3505)
				p.FileName()
			}

		}

	case Cobol85ParserANY:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3508)
			p.Match(Cobol85ParserANY)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IProcedureDivisionByValuePhraseContext is an interface to support dynamic dispatch.
type IProcedureDivisionByValuePhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedureDivisionByValuePhraseContext differentiates from other interfaces.
	IsProcedureDivisionByValuePhraseContext()
}

type ProcedureDivisionByValuePhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureDivisionByValuePhraseContext() *ProcedureDivisionByValuePhraseContext {
	var p = new(ProcedureDivisionByValuePhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_procedureDivisionByValuePhrase
	return p
}

func (*ProcedureDivisionByValuePhraseContext) IsProcedureDivisionByValuePhraseContext() {}

func NewProcedureDivisionByValuePhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureDivisionByValuePhraseContext {
	var p = new(ProcedureDivisionByValuePhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_procedureDivisionByValuePhrase

	return p
}

func (s *ProcedureDivisionByValuePhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureDivisionByValuePhraseContext) VALUE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserVALUE, 0)
}

func (s *ProcedureDivisionByValuePhraseContext) BY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBY, 0)
}

func (s *ProcedureDivisionByValuePhraseContext) AllProcedureDivisionByValue() []IProcedureDivisionByValueContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IProcedureDivisionByValueContext)(nil)).Elem())
	var tst = make([]IProcedureDivisionByValueContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IProcedureDivisionByValueContext)
		}
	}

	return tst
}

func (s *ProcedureDivisionByValuePhraseContext) ProcedureDivisionByValue(i int) IProcedureDivisionByValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedureDivisionByValueContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IProcedureDivisionByValueContext)
}

func (s *ProcedureDivisionByValuePhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureDivisionByValuePhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureDivisionByValuePhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterProcedureDivisionByValuePhrase(s)
	}
}

func (s *ProcedureDivisionByValuePhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitProcedureDivisionByValuePhrase(s)
	}
}

func (p *Cobol85Parser) ProcedureDivisionByValuePhrase() (localctx IProcedureDivisionByValuePhraseContext) {
	localctx = NewProcedureDivisionByValuePhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 516, Cobol85ParserRULE_procedureDivisionByValuePhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3512)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserBY {
		{
			p.SetState(3511)
			p.Match(Cobol85ParserBY)
		}

	}
	{
		p.SetState(3514)
		p.Match(Cobol85ParserVALUE)
	}
	p.SetState(3516)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(3515)
				p.ProcedureDivisionByValue()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(3518)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 454, p.GetParserRuleContext())
	}

	return localctx
}

// IProcedureDivisionByValueContext is an interface to support dynamic dispatch.
type IProcedureDivisionByValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedureDivisionByValueContext differentiates from other interfaces.
	IsProcedureDivisionByValueContext()
}

type ProcedureDivisionByValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureDivisionByValueContext() *ProcedureDivisionByValueContext {
	var p = new(ProcedureDivisionByValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_procedureDivisionByValue
	return p
}

func (*ProcedureDivisionByValueContext) IsProcedureDivisionByValueContext() {}

func NewProcedureDivisionByValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureDivisionByValueContext {
	var p = new(ProcedureDivisionByValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_procedureDivisionByValue

	return p
}

func (s *ProcedureDivisionByValueContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureDivisionByValueContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ProcedureDivisionByValueContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *ProcedureDivisionByValueContext) ANY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserANY, 0)
}

func (s *ProcedureDivisionByValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureDivisionByValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureDivisionByValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterProcedureDivisionByValue(s)
	}
}

func (s *ProcedureDivisionByValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitProcedureDivisionByValue(s)
	}
}

func (p *Cobol85Parser) ProcedureDivisionByValue() (localctx IProcedureDivisionByValueContext) {
	localctx = NewProcedureDivisionByValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 518, Cobol85ParserRULE_procedureDivisionByValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3523)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 455, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3520)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3521)
			p.Literal()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3522)
			p.Match(Cobol85ParserANY)
		}

	}

	return localctx
}

// IProcedureDeclarativesContext is an interface to support dynamic dispatch.
type IProcedureDeclarativesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedureDeclarativesContext differentiates from other interfaces.
	IsProcedureDeclarativesContext()
}

type ProcedureDeclarativesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureDeclarativesContext() *ProcedureDeclarativesContext {
	var p = new(ProcedureDeclarativesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_procedureDeclaratives
	return p
}

func (*ProcedureDeclarativesContext) IsProcedureDeclarativesContext() {}

func NewProcedureDeclarativesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureDeclarativesContext {
	var p = new(ProcedureDeclarativesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_procedureDeclaratives

	return p
}

func (s *ProcedureDeclarativesContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureDeclarativesContext) AllDECLARATIVES() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserDECLARATIVES)
}

func (s *ProcedureDeclarativesContext) DECLARATIVES(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDECLARATIVES, i)
}

func (s *ProcedureDeclarativesContext) AllDOT_FS() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserDOT_FS)
}

func (s *ProcedureDeclarativesContext) DOT_FS(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, i)
}

func (s *ProcedureDeclarativesContext) END() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND, 0)
}

func (s *ProcedureDeclarativesContext) AllProcedureDeclarative() []IProcedureDeclarativeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IProcedureDeclarativeContext)(nil)).Elem())
	var tst = make([]IProcedureDeclarativeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IProcedureDeclarativeContext)
		}
	}

	return tst
}

func (s *ProcedureDeclarativesContext) ProcedureDeclarative(i int) IProcedureDeclarativeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedureDeclarativeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IProcedureDeclarativeContext)
}

func (s *ProcedureDeclarativesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureDeclarativesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureDeclarativesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterProcedureDeclaratives(s)
	}
}

func (s *ProcedureDeclarativesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitProcedureDeclaratives(s)
	}
}

func (p *Cobol85Parser) ProcedureDeclaratives() (localctx IProcedureDeclarativesContext) {
	localctx = NewProcedureDeclarativesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 520, Cobol85ParserRULE_procedureDeclaratives)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3525)
		p.Match(Cobol85ParserDECLARATIVES)
	}
	{
		p.SetState(3526)
		p.Match(Cobol85ParserDOT_FS)
	}
	p.SetState(3528)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH)|(1<<Cobol85ParserATTRIBUTE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBINARY-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-68))|(1<<(Cobol85ParserCOBOL-68))|(1<<(Cobol85ParserCOMMITMENT-68))|(1<<(Cobol85ParserCONTROL_POINT-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(Cobol85ParserCONVENTION-100))|(1<<(Cobol85ParserCRUNCH-100))|(1<<(Cobol85ParserCURSOR-100))|(1<<(Cobol85ParserDEFAULT-100))|(1<<(Cobol85ParserDEFAULT_DISPLAY-100))|(1<<(Cobol85ParserDEFINITION-100)))) != 0) || (((_la-138)&-(0x1f+1)) == 0 && ((1<<uint((_la-138)))&((1<<(Cobol85ParserDFHRESP-138))|(1<<(Cobol85ParserDFHVALUE-138))|(1<<(Cobol85ParserDISK-138))|(1<<(Cobol85ParserDONTCARE-138))|(1<<(Cobol85ParserDOUBLE-138))|(1<<(Cobol85ParserEBCDIC-138))|(1<<(Cobol85ParserEMPTY_CHECK-138)))) != 0) || (((_la-181)&-(0x1f+1)) == 0 && ((1<<uint((_la-181)))&((1<<(Cobol85ParserENTER-181))|(1<<(Cobol85ParserENTRY_PROCEDURE-181))|(1<<(Cobol85ParserERASE-181))|(1<<(Cobol85ParserEOL-181))|(1<<(Cobol85ParserEOS-181))|(1<<(Cobol85ParserESCAPE-181))|(1<<(Cobol85ParserEVENT-181))|(1<<(Cobol85ParserEXCLUSIVE-181))|(1<<(Cobol85ParserEXPORT-181))|(1<<(Cobol85ParserEXTENDED-181)))) != 0) || (((_la-213)&-(0x1f+1)) == 0 && ((1<<uint((_la-213)))&((1<<(Cobol85ParserFOREGROUND_COLOR-213))|(1<<(Cobol85ParserFOREGROUND_COLOUR-213))|(1<<(Cobol85ParserFULL-213))|(1<<(Cobol85ParserFUNCTIONNAME-213))|(1<<(Cobol85ParserFUNCTION_POINTER-213))|(1<<(Cobol85ParserGRID-213))|(1<<(Cobol85ParserHIGHLIGHT-213))|(1<<(Cobol85ParserIMPLICIT-213))|(1<<(Cobol85ParserIMPORT-213)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(Cobol85ParserINTEGER-250))|(1<<(Cobol85ParserKEPT-250))|(1<<(Cobol85ParserKEYBOARD-250))|(1<<(Cobol85ParserLANGUAGE-250))|(1<<(Cobol85ParserLB-250))|(1<<(Cobol85ParserLD-250))|(1<<(Cobol85ParserLEFTLINE-250))|(1<<(Cobol85ParserLENGTH_CHECK-250))|(1<<(Cobol85ParserLIBACCESS-250))|(1<<(Cobol85ParserLIBPARAMETER-250))|(1<<(Cobol85ParserLIBRARY-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(Cobol85ParserLIST-283))|(1<<(Cobol85ParserLOCAL-283))|(1<<(Cobol85ParserLONG_DATE-283))|(1<<(Cobol85ParserLONG_TIME-283))|(1<<(Cobol85ParserLOWER-283))|(1<<(Cobol85ParserLOWLIGHT-283))|(1<<(Cobol85ParserMMDDYYYY-283))|(1<<(Cobol85ParserNAMED-283))|(1<<(Cobol85ParserNATIONAL-283))|(1<<(Cobol85ParserNATIONAL_EDITED-283))|(1<<(Cobol85ParserNETWORK-283))|(1<<(Cobol85ParserNO_ECHO-283)))) != 0) || (((_la-317)&-(0x1f+1)) == 0 && ((1<<uint((_la-317)))&((1<<(Cobol85ParserNUMERIC_DATE-317))|(1<<(Cobol85ParserNUMERIC_TIME-317))|(1<<(Cobol85ParserODT-317))|(1<<(Cobol85ParserORDERLY-317))|(1<<(Cobol85ParserOVERLINE-317))|(1<<(Cobol85ParserOWN-317))|(1<<(Cobol85ParserPASSWORD-317)))) != 0) || (((_la-352)&-(0x1f+1)) == 0 && ((1<<uint((_la-352)))&((1<<(Cobol85ParserPORT-352))|(1<<(Cobol85ParserPRINTER-352))|(1<<(Cobol85ParserPRIVATE-352))|(1<<(Cobol85ParserPROCESS-352))|(1<<(Cobol85ParserPROGRAM-352))|(1<<(Cobol85ParserPROMPT-352))|(1<<(Cobol85ParserREADER-352))|(1<<(Cobol85ParserREMOTE-352))|(1<<(Cobol85ParserREAL-352))|(1<<(Cobol85ParserRECEIVED-352))|(1<<(Cobol85ParserRECURSIVE-352))|(1<<(Cobol85ParserREF-352)))) != 0) || (((_la-391)&-(0x1f+1)) == 0 && ((1<<uint((_la-391)))&((1<<(Cobol85ParserREMOVE-391))|(1<<(Cobol85ParserREQUIRED-391))|(1<<(Cobol85ParserREVERSE_VIDEO-391))|(1<<(Cobol85ParserSAVE-391))|(1<<(Cobol85ParserSECURE-391)))) != 0) || (((_la-431)&-(0x1f+1)) == 0 && ((1<<uint((_la-431)))&((1<<(Cobol85ParserSHARED-431))|(1<<(Cobol85ParserSHAREDBYALL-431))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-431))|(1<<(Cobol85ParserSHARING-431))|(1<<(Cobol85ParserSHORT_DATE-431)))) != 0) || (((_la-466)&-(0x1f+1)) == 0 && ((1<<uint((_la-466)))&((1<<(Cobol85ParserSYMBOL-466))|(1<<(Cobol85ParserTASK-466))|(1<<(Cobol85ParserTHREAD-466))|(1<<(Cobol85ParserTHREAD_LOCAL-466))|(1<<(Cobol85ParserTIMER-466))|(1<<(Cobol85ParserTODAYS_DATE-466))|(1<<(Cobol85ParserTODAYS_NAME-466))|(1<<(Cobol85ParserTRUNCATED-466))|(1<<(Cobol85ParserTYPEDEF-466)))) != 0) || (((_la-498)&-(0x1f+1)) == 0 && ((1<<uint((_la-498)))&((1<<(Cobol85ParserUNDERLINE-498))|(1<<(Cobol85ParserVIRTUAL-498))|(1<<(Cobol85ParserWAIT-498))|(1<<(Cobol85ParserYEAR-498))|(1<<(Cobol85ParserYYYYMMDD-498))|(1<<(Cobol85ParserYYYYDDD-498))|(1<<(Cobol85ParserZERO_FILL-498)))) != 0) || (((_la-552)&-(0x1f+1)) == 0 && ((1<<uint((_la-552)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-552))|(1<<(Cobol85ParserLEVEL_NUMBER_77-552))|(1<<(Cobol85ParserLEVEL_NUMBER_88-552))|(1<<(Cobol85ParserINTEGERLITERAL-552))|(1<<(Cobol85ParserIDENTIFIER-552)))) != 0) {
		{
			p.SetState(3527)
			p.ProcedureDeclarative()
		}

		p.SetState(3530)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3532)
		p.Match(Cobol85ParserEND)
	}
	{
		p.SetState(3533)
		p.Match(Cobol85ParserDECLARATIVES)
	}
	{
		p.SetState(3534)
		p.Match(Cobol85ParserDOT_FS)
	}

	return localctx
}

// IProcedureDeclarativeContext is an interface to support dynamic dispatch.
type IProcedureDeclarativeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedureDeclarativeContext differentiates from other interfaces.
	IsProcedureDeclarativeContext()
}

type ProcedureDeclarativeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureDeclarativeContext() *ProcedureDeclarativeContext {
	var p = new(ProcedureDeclarativeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_procedureDeclarative
	return p
}

func (*ProcedureDeclarativeContext) IsProcedureDeclarativeContext() {}

func NewProcedureDeclarativeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureDeclarativeContext {
	var p = new(ProcedureDeclarativeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_procedureDeclarative

	return p
}

func (s *ProcedureDeclarativeContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureDeclarativeContext) ProcedureSectionHeader() IProcedureSectionHeaderContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedureSectionHeaderContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedureSectionHeaderContext)
}

func (s *ProcedureDeclarativeContext) AllDOT_FS() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserDOT_FS)
}

func (s *ProcedureDeclarativeContext) DOT_FS(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, i)
}

func (s *ProcedureDeclarativeContext) UseStatement() IUseStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUseStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUseStatementContext)
}

func (s *ProcedureDeclarativeContext) Paragraphs() IParagraphsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParagraphsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParagraphsContext)
}

func (s *ProcedureDeclarativeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureDeclarativeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureDeclarativeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterProcedureDeclarative(s)
	}
}

func (s *ProcedureDeclarativeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitProcedureDeclarative(s)
	}
}

func (p *Cobol85Parser) ProcedureDeclarative() (localctx IProcedureDeclarativeContext) {
	localctx = NewProcedureDeclarativeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 522, Cobol85ParserRULE_procedureDeclarative)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3536)
		p.ProcedureSectionHeader()
	}
	{
		p.SetState(3537)
		p.Match(Cobol85ParserDOT_FS)
	}
	{
		p.SetState(3538)
		p.UseStatement()
	}
	{
		p.SetState(3539)
		p.Match(Cobol85ParserDOT_FS)
	}
	{
		p.SetState(3540)
		p.Paragraphs()
	}

	return localctx
}

// IProcedureSectionHeaderContext is an interface to support dynamic dispatch.
type IProcedureSectionHeaderContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedureSectionHeaderContext differentiates from other interfaces.
	IsProcedureSectionHeaderContext()
}

type ProcedureSectionHeaderContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureSectionHeaderContext() *ProcedureSectionHeaderContext {
	var p = new(ProcedureSectionHeaderContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_procedureSectionHeader
	return p
}

func (*ProcedureSectionHeaderContext) IsProcedureSectionHeaderContext() {}

func NewProcedureSectionHeaderContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureSectionHeaderContext {
	var p = new(ProcedureSectionHeaderContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_procedureSectionHeader

	return p
}

func (s *ProcedureSectionHeaderContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureSectionHeaderContext) SectionName() ISectionNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISectionNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISectionNameContext)
}

func (s *ProcedureSectionHeaderContext) SECTION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSECTION, 0)
}

func (s *ProcedureSectionHeaderContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ProcedureSectionHeaderContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureSectionHeaderContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureSectionHeaderContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterProcedureSectionHeader(s)
	}
}

func (s *ProcedureSectionHeaderContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitProcedureSectionHeader(s)
	}
}

func (p *Cobol85Parser) ProcedureSectionHeader() (localctx IProcedureSectionHeaderContext) {
	localctx = NewProcedureSectionHeaderContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 524, Cobol85ParserRULE_procedureSectionHeader)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3542)
		p.SectionName()
	}
	{
		p.SetState(3543)
		p.Match(Cobol85ParserSECTION)
	}
	p.SetState(3545)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la-552)&-(0x1f+1)) == 0 && ((1<<uint((_la-552)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-552))|(1<<(Cobol85ParserLEVEL_NUMBER_77-552))|(1<<(Cobol85ParserLEVEL_NUMBER_88-552))|(1<<(Cobol85ParserINTEGERLITERAL-552)))) != 0 {
		{
			p.SetState(3544)
			p.IntegerLiteral()
		}

	}

	return localctx
}

// IProcedureDivisionBodyContext is an interface to support dynamic dispatch.
type IProcedureDivisionBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedureDivisionBodyContext differentiates from other interfaces.
	IsProcedureDivisionBodyContext()
}

type ProcedureDivisionBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureDivisionBodyContext() *ProcedureDivisionBodyContext {
	var p = new(ProcedureDivisionBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_procedureDivisionBody
	return p
}

func (*ProcedureDivisionBodyContext) IsProcedureDivisionBodyContext() {}

func NewProcedureDivisionBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureDivisionBodyContext {
	var p = new(ProcedureDivisionBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_procedureDivisionBody

	return p
}

func (s *ProcedureDivisionBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureDivisionBodyContext) Paragraphs() IParagraphsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParagraphsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParagraphsContext)
}

func (s *ProcedureDivisionBodyContext) AllProcedureSection() []IProcedureSectionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IProcedureSectionContext)(nil)).Elem())
	var tst = make([]IProcedureSectionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IProcedureSectionContext)
		}
	}

	return tst
}

func (s *ProcedureDivisionBodyContext) ProcedureSection(i int) IProcedureSectionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedureSectionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IProcedureSectionContext)
}

func (s *ProcedureDivisionBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureDivisionBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureDivisionBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterProcedureDivisionBody(s)
	}
}

func (s *ProcedureDivisionBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitProcedureDivisionBody(s)
	}
}

func (p *Cobol85Parser) ProcedureDivisionBody() (localctx IProcedureDivisionBodyContext) {
	localctx = NewProcedureDivisionBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 526, Cobol85ParserRULE_procedureDivisionBody)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3547)
		p.Paragraphs()
	}
	p.SetState(3551)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH)|(1<<Cobol85ParserATTRIBUTE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBINARY-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-68))|(1<<(Cobol85ParserCOBOL-68))|(1<<(Cobol85ParserCOMMITMENT-68))|(1<<(Cobol85ParserCONTROL_POINT-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(Cobol85ParserCONVENTION-100))|(1<<(Cobol85ParserCRUNCH-100))|(1<<(Cobol85ParserCURSOR-100))|(1<<(Cobol85ParserDEFAULT-100))|(1<<(Cobol85ParserDEFAULT_DISPLAY-100))|(1<<(Cobol85ParserDEFINITION-100)))) != 0) || (((_la-138)&-(0x1f+1)) == 0 && ((1<<uint((_la-138)))&((1<<(Cobol85ParserDFHRESP-138))|(1<<(Cobol85ParserDFHVALUE-138))|(1<<(Cobol85ParserDISK-138))|(1<<(Cobol85ParserDONTCARE-138))|(1<<(Cobol85ParserDOUBLE-138))|(1<<(Cobol85ParserEBCDIC-138))|(1<<(Cobol85ParserEMPTY_CHECK-138)))) != 0) || (((_la-181)&-(0x1f+1)) == 0 && ((1<<uint((_la-181)))&((1<<(Cobol85ParserENTER-181))|(1<<(Cobol85ParserENTRY_PROCEDURE-181))|(1<<(Cobol85ParserERASE-181))|(1<<(Cobol85ParserEOL-181))|(1<<(Cobol85ParserEOS-181))|(1<<(Cobol85ParserESCAPE-181))|(1<<(Cobol85ParserEVENT-181))|(1<<(Cobol85ParserEXCLUSIVE-181))|(1<<(Cobol85ParserEXPORT-181))|(1<<(Cobol85ParserEXTENDED-181)))) != 0) || (((_la-213)&-(0x1f+1)) == 0 && ((1<<uint((_la-213)))&((1<<(Cobol85ParserFOREGROUND_COLOR-213))|(1<<(Cobol85ParserFOREGROUND_COLOUR-213))|(1<<(Cobol85ParserFULL-213))|(1<<(Cobol85ParserFUNCTIONNAME-213))|(1<<(Cobol85ParserFUNCTION_POINTER-213))|(1<<(Cobol85ParserGRID-213))|(1<<(Cobol85ParserHIGHLIGHT-213))|(1<<(Cobol85ParserIMPLICIT-213))|(1<<(Cobol85ParserIMPORT-213)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(Cobol85ParserINTEGER-250))|(1<<(Cobol85ParserKEPT-250))|(1<<(Cobol85ParserKEYBOARD-250))|(1<<(Cobol85ParserLANGUAGE-250))|(1<<(Cobol85ParserLB-250))|(1<<(Cobol85ParserLD-250))|(1<<(Cobol85ParserLEFTLINE-250))|(1<<(Cobol85ParserLENGTH_CHECK-250))|(1<<(Cobol85ParserLIBACCESS-250))|(1<<(Cobol85ParserLIBPARAMETER-250))|(1<<(Cobol85ParserLIBRARY-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(Cobol85ParserLIST-283))|(1<<(Cobol85ParserLOCAL-283))|(1<<(Cobol85ParserLONG_DATE-283))|(1<<(Cobol85ParserLONG_TIME-283))|(1<<(Cobol85ParserLOWER-283))|(1<<(Cobol85ParserLOWLIGHT-283))|(1<<(Cobol85ParserMMDDYYYY-283))|(1<<(Cobol85ParserNAMED-283))|(1<<(Cobol85ParserNATIONAL-283))|(1<<(Cobol85ParserNATIONAL_EDITED-283))|(1<<(Cobol85ParserNETWORK-283))|(1<<(Cobol85ParserNO_ECHO-283)))) != 0) || (((_la-317)&-(0x1f+1)) == 0 && ((1<<uint((_la-317)))&((1<<(Cobol85ParserNUMERIC_DATE-317))|(1<<(Cobol85ParserNUMERIC_TIME-317))|(1<<(Cobol85ParserODT-317))|(1<<(Cobol85ParserORDERLY-317))|(1<<(Cobol85ParserOVERLINE-317))|(1<<(Cobol85ParserOWN-317))|(1<<(Cobol85ParserPASSWORD-317)))) != 0) || (((_la-352)&-(0x1f+1)) == 0 && ((1<<uint((_la-352)))&((1<<(Cobol85ParserPORT-352))|(1<<(Cobol85ParserPRINTER-352))|(1<<(Cobol85ParserPRIVATE-352))|(1<<(Cobol85ParserPROCESS-352))|(1<<(Cobol85ParserPROGRAM-352))|(1<<(Cobol85ParserPROMPT-352))|(1<<(Cobol85ParserREADER-352))|(1<<(Cobol85ParserREMOTE-352))|(1<<(Cobol85ParserREAL-352))|(1<<(Cobol85ParserRECEIVED-352))|(1<<(Cobol85ParserRECURSIVE-352))|(1<<(Cobol85ParserREF-352)))) != 0) || (((_la-391)&-(0x1f+1)) == 0 && ((1<<uint((_la-391)))&((1<<(Cobol85ParserREMOVE-391))|(1<<(Cobol85ParserREQUIRED-391))|(1<<(Cobol85ParserREVERSE_VIDEO-391))|(1<<(Cobol85ParserSAVE-391))|(1<<(Cobol85ParserSECURE-391)))) != 0) || (((_la-431)&-(0x1f+1)) == 0 && ((1<<uint((_la-431)))&((1<<(Cobol85ParserSHARED-431))|(1<<(Cobol85ParserSHAREDBYALL-431))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-431))|(1<<(Cobol85ParserSHARING-431))|(1<<(Cobol85ParserSHORT_DATE-431)))) != 0) || (((_la-466)&-(0x1f+1)) == 0 && ((1<<uint((_la-466)))&((1<<(Cobol85ParserSYMBOL-466))|(1<<(Cobol85ParserTASK-466))|(1<<(Cobol85ParserTHREAD-466))|(1<<(Cobol85ParserTHREAD_LOCAL-466))|(1<<(Cobol85ParserTIMER-466))|(1<<(Cobol85ParserTODAYS_DATE-466))|(1<<(Cobol85ParserTODAYS_NAME-466))|(1<<(Cobol85ParserTRUNCATED-466))|(1<<(Cobol85ParserTYPEDEF-466)))) != 0) || (((_la-498)&-(0x1f+1)) == 0 && ((1<<uint((_la-498)))&((1<<(Cobol85ParserUNDERLINE-498))|(1<<(Cobol85ParserVIRTUAL-498))|(1<<(Cobol85ParserWAIT-498))|(1<<(Cobol85ParserYEAR-498))|(1<<(Cobol85ParserYYYYMMDD-498))|(1<<(Cobol85ParserYYYYDDD-498))|(1<<(Cobol85ParserZERO_FILL-498)))) != 0) || (((_la-552)&-(0x1f+1)) == 0 && ((1<<uint((_la-552)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-552))|(1<<(Cobol85ParserLEVEL_NUMBER_77-552))|(1<<(Cobol85ParserLEVEL_NUMBER_88-552))|(1<<(Cobol85ParserINTEGERLITERAL-552))|(1<<(Cobol85ParserIDENTIFIER-552)))) != 0) {
		{
			p.SetState(3548)
			p.ProcedureSection()
		}

		p.SetState(3553)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IProcedureSectionContext is an interface to support dynamic dispatch.
type IProcedureSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedureSectionContext differentiates from other interfaces.
	IsProcedureSectionContext()
}

type ProcedureSectionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureSectionContext() *ProcedureSectionContext {
	var p = new(ProcedureSectionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_procedureSection
	return p
}

func (*ProcedureSectionContext) IsProcedureSectionContext() {}

func NewProcedureSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureSectionContext {
	var p = new(ProcedureSectionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_procedureSection

	return p
}

func (s *ProcedureSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureSectionContext) ProcedureSectionHeader() IProcedureSectionHeaderContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedureSectionHeaderContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedureSectionHeaderContext)
}

func (s *ProcedureSectionContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *ProcedureSectionContext) Paragraphs() IParagraphsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParagraphsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParagraphsContext)
}

func (s *ProcedureSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterProcedureSection(s)
	}
}

func (s *ProcedureSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitProcedureSection(s)
	}
}

func (p *Cobol85Parser) ProcedureSection() (localctx IProcedureSectionContext) {
	localctx = NewProcedureSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 528, Cobol85ParserRULE_procedureSection)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3554)
		p.ProcedureSectionHeader()
	}
	{
		p.SetState(3555)
		p.Match(Cobol85ParserDOT_FS)
	}
	{
		p.SetState(3556)
		p.Paragraphs()
	}

	return localctx
}

// IParagraphsContext is an interface to support dynamic dispatch.
type IParagraphsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParagraphsContext differentiates from other interfaces.
	IsParagraphsContext()
}

type ParagraphsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParagraphsContext() *ParagraphsContext {
	var p = new(ParagraphsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_paragraphs
	return p
}

func (*ParagraphsContext) IsParagraphsContext() {}

func NewParagraphsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParagraphsContext {
	var p = new(ParagraphsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_paragraphs

	return p
}

func (s *ParagraphsContext) GetParser() antlr.Parser { return s.parser }

func (s *ParagraphsContext) AllSentence() []ISentenceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISentenceContext)(nil)).Elem())
	var tst = make([]ISentenceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISentenceContext)
		}
	}

	return tst
}

func (s *ParagraphsContext) Sentence(i int) ISentenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISentenceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISentenceContext)
}

func (s *ParagraphsContext) AllParagraph() []IParagraphContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IParagraphContext)(nil)).Elem())
	var tst = make([]IParagraphContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IParagraphContext)
		}
	}

	return tst
}

func (s *ParagraphsContext) Paragraph(i int) IParagraphContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParagraphContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IParagraphContext)
}

func (s *ParagraphsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParagraphsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParagraphsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterParagraphs(s)
	}
}

func (s *ParagraphsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitParagraphs(s)
	}
}

func (p *Cobol85Parser) Paragraphs() (localctx IParagraphsContext) {
	localctx = NewParagraphsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 530, Cobol85ParserRULE_paragraphs)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3561)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserACCEPT)|(1<<Cobol85ParserADD)|(1<<Cobol85ParserALTER))) != 0) || (((_la-52)&-(0x1f+1)) == 0 && ((1<<uint((_la-52)))&((1<<(Cobol85ParserCALL-52))|(1<<(Cobol85ParserCANCEL-52))|(1<<(Cobol85ParserCLOSE-52)))) != 0) || _la == Cobol85ParserCOMPUTE || _la == Cobol85ParserCONTINUE || (((_la-131)&-(0x1f+1)) == 0 && ((1<<uint((_la-131)))&((1<<(Cobol85ParserDELETE-131))|(1<<(Cobol85ParserDISABLE-131))|(1<<(Cobol85ParserDISPLAY-131))|(1<<(Cobol85ParserDIVIDE-131))|(1<<(Cobol85ParserENABLE-131)))) != 0) || (((_la-182)&-(0x1f+1)) == 0 && ((1<<uint((_la-182)))&((1<<(Cobol85ParserENTRY-182))|(1<<(Cobol85ParserEVALUATE-182))|(1<<(Cobol85ParserEXHIBIT-182))|(1<<(Cobol85ParserEXIT-182)))) != 0) || (((_la-220)&-(0x1f+1)) == 0 && ((1<<uint((_la-220)))&((1<<(Cobol85ParserGENERATE-220))|(1<<(Cobol85ParserGOBACK-220))|(1<<(Cobol85ParserGO-220))|(1<<(Cobol85ParserIF-220))|(1<<(Cobol85ParserINITIALIZE-220))|(1<<(Cobol85ParserINITIATE-220))|(1<<(Cobol85ParserINSPECT-220)))) != 0) || (((_la-294)&-(0x1f+1)) == 0 && ((1<<uint((_la-294)))&((1<<(Cobol85ParserMERGE-294))|(1<<(Cobol85ParserMOVE-294))|(1<<(Cobol85ParserMULTIPLY-294)))) != 0) || _la == Cobol85ParserOPEN || _la == Cobol85ParserPERFORM || (((_la-365)&-(0x1f+1)) == 0 && ((1<<uint((_la-365)))&((1<<(Cobol85ParserPURGE-365))|(1<<(Cobol85ParserREAD-365))|(1<<(Cobol85ParserRECEIVE-365))|(1<<(Cobol85ParserRELEASE-365)))) != 0) || (((_la-403)&-(0x1f+1)) == 0 && ((1<<uint((_la-403)))&((1<<(Cobol85ParserRETURN-403))|(1<<(Cobol85ParserREWRITE-403))|(1<<(Cobol85ParserSEARCH-403))|(1<<(Cobol85ParserSEND-403))|(1<<(Cobol85ParserSET-403)))) != 0) || (((_la-440)&-(0x1f+1)) == 0 && ((1<<uint((_la-440)))&((1<<(Cobol85ParserSORT-440))|(1<<(Cobol85ParserSTART-440))|(1<<(Cobol85ParserSTOP-440))|(1<<(Cobol85ParserSTRING-440))|(1<<(Cobol85ParserSUBTRACT-440)))) != 0) || _la == Cobol85ParserTERMINATE || _la == Cobol85ParserUNSTRING || _la == Cobol85ParserWRITE || _la == Cobol85ParserDOT_FS || (((_la-559)&-(0x1f+1)) == 0 && ((1<<uint((_la-559)))&((1<<(Cobol85ParserEXECCICSLINE-559))|(1<<(Cobol85ParserEXECSQLIMSLINE-559))|(1<<(Cobol85ParserEXECSQLLINE-559)))) != 0) {
		{
			p.SetState(3558)
			p.Sentence()
		}

		p.SetState(3563)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(3567)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 460, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3564)
				p.Paragraph()
			}

		}
		p.SetState(3569)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 460, p.GetParserRuleContext())
	}

	return localctx
}

// IParagraphContext is an interface to support dynamic dispatch.
type IParagraphContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParagraphContext differentiates from other interfaces.
	IsParagraphContext()
}

type ParagraphContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParagraphContext() *ParagraphContext {
	var p = new(ParagraphContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_paragraph
	return p
}

func (*ParagraphContext) IsParagraphContext() {}

func NewParagraphContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParagraphContext {
	var p = new(ParagraphContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_paragraph

	return p
}

func (s *ParagraphContext) GetParser() antlr.Parser { return s.parser }

func (s *ParagraphContext) ParagraphName() IParagraphNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParagraphNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParagraphNameContext)
}

func (s *ParagraphContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *ParagraphContext) AlteredGoTo() IAlteredGoToContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlteredGoToContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlteredGoToContext)
}

func (s *ParagraphContext) AllSentence() []ISentenceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISentenceContext)(nil)).Elem())
	var tst = make([]ISentenceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISentenceContext)
		}
	}

	return tst
}

func (s *ParagraphContext) Sentence(i int) ISentenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISentenceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISentenceContext)
}

func (s *ParagraphContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParagraphContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParagraphContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterParagraph(s)
	}
}

func (s *ParagraphContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitParagraph(s)
	}
}

func (p *Cobol85Parser) Paragraph() (localctx IParagraphContext) {
	localctx = NewParagraphContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 532, Cobol85ParserRULE_paragraph)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3570)
		p.ParagraphName()
	}
	{
		p.SetState(3571)
		p.Match(Cobol85ParserDOT_FS)
	}
	p.SetState(3579)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 462, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(3572)
			p.AlteredGoTo()
		}

	case 2:
		p.SetState(3576)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserACCEPT)|(1<<Cobol85ParserADD)|(1<<Cobol85ParserALTER))) != 0) || (((_la-52)&-(0x1f+1)) == 0 && ((1<<uint((_la-52)))&((1<<(Cobol85ParserCALL-52))|(1<<(Cobol85ParserCANCEL-52))|(1<<(Cobol85ParserCLOSE-52)))) != 0) || _la == Cobol85ParserCOMPUTE || _la == Cobol85ParserCONTINUE || (((_la-131)&-(0x1f+1)) == 0 && ((1<<uint((_la-131)))&((1<<(Cobol85ParserDELETE-131))|(1<<(Cobol85ParserDISABLE-131))|(1<<(Cobol85ParserDISPLAY-131))|(1<<(Cobol85ParserDIVIDE-131))|(1<<(Cobol85ParserENABLE-131)))) != 0) || (((_la-182)&-(0x1f+1)) == 0 && ((1<<uint((_la-182)))&((1<<(Cobol85ParserENTRY-182))|(1<<(Cobol85ParserEVALUATE-182))|(1<<(Cobol85ParserEXHIBIT-182))|(1<<(Cobol85ParserEXIT-182)))) != 0) || (((_la-220)&-(0x1f+1)) == 0 && ((1<<uint((_la-220)))&((1<<(Cobol85ParserGENERATE-220))|(1<<(Cobol85ParserGOBACK-220))|(1<<(Cobol85ParserGO-220))|(1<<(Cobol85ParserIF-220))|(1<<(Cobol85ParserINITIALIZE-220))|(1<<(Cobol85ParserINITIATE-220))|(1<<(Cobol85ParserINSPECT-220)))) != 0) || (((_la-294)&-(0x1f+1)) == 0 && ((1<<uint((_la-294)))&((1<<(Cobol85ParserMERGE-294))|(1<<(Cobol85ParserMOVE-294))|(1<<(Cobol85ParserMULTIPLY-294)))) != 0) || _la == Cobol85ParserOPEN || _la == Cobol85ParserPERFORM || (((_la-365)&-(0x1f+1)) == 0 && ((1<<uint((_la-365)))&((1<<(Cobol85ParserPURGE-365))|(1<<(Cobol85ParserREAD-365))|(1<<(Cobol85ParserRECEIVE-365))|(1<<(Cobol85ParserRELEASE-365)))) != 0) || (((_la-403)&-(0x1f+1)) == 0 && ((1<<uint((_la-403)))&((1<<(Cobol85ParserRETURN-403))|(1<<(Cobol85ParserREWRITE-403))|(1<<(Cobol85ParserSEARCH-403))|(1<<(Cobol85ParserSEND-403))|(1<<(Cobol85ParserSET-403)))) != 0) || (((_la-440)&-(0x1f+1)) == 0 && ((1<<uint((_la-440)))&((1<<(Cobol85ParserSORT-440))|(1<<(Cobol85ParserSTART-440))|(1<<(Cobol85ParserSTOP-440))|(1<<(Cobol85ParserSTRING-440))|(1<<(Cobol85ParserSUBTRACT-440)))) != 0) || _la == Cobol85ParserTERMINATE || _la == Cobol85ParserUNSTRING || _la == Cobol85ParserWRITE || _la == Cobol85ParserDOT_FS || (((_la-559)&-(0x1f+1)) == 0 && ((1<<uint((_la-559)))&((1<<(Cobol85ParserEXECCICSLINE-559))|(1<<(Cobol85ParserEXECSQLIMSLINE-559))|(1<<(Cobol85ParserEXECSQLLINE-559)))) != 0) {
			{
				p.SetState(3573)
				p.Sentence()
			}

			p.SetState(3578)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// ISentenceContext is an interface to support dynamic dispatch.
type ISentenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSentenceContext differentiates from other interfaces.
	IsSentenceContext()
}

type SentenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySentenceContext() *SentenceContext {
	var p = new(SentenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sentence
	return p
}

func (*SentenceContext) IsSentenceContext() {}

func NewSentenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SentenceContext {
	var p = new(SentenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sentence

	return p
}

func (s *SentenceContext) GetParser() antlr.Parser { return s.parser }

func (s *SentenceContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *SentenceContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *SentenceContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *SentenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SentenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SentenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSentence(s)
	}
}

func (s *SentenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSentence(s)
	}
}

func (p *Cobol85Parser) Sentence() (localctx ISentenceContext) {
	localctx = NewSentenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 534, Cobol85ParserRULE_sentence)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3584)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserACCEPT)|(1<<Cobol85ParserADD)|(1<<Cobol85ParserALTER))) != 0) || (((_la-52)&-(0x1f+1)) == 0 && ((1<<uint((_la-52)))&((1<<(Cobol85ParserCALL-52))|(1<<(Cobol85ParserCANCEL-52))|(1<<(Cobol85ParserCLOSE-52)))) != 0) || _la == Cobol85ParserCOMPUTE || _la == Cobol85ParserCONTINUE || (((_la-131)&-(0x1f+1)) == 0 && ((1<<uint((_la-131)))&((1<<(Cobol85ParserDELETE-131))|(1<<(Cobol85ParserDISABLE-131))|(1<<(Cobol85ParserDISPLAY-131))|(1<<(Cobol85ParserDIVIDE-131))|(1<<(Cobol85ParserENABLE-131)))) != 0) || (((_la-182)&-(0x1f+1)) == 0 && ((1<<uint((_la-182)))&((1<<(Cobol85ParserENTRY-182))|(1<<(Cobol85ParserEVALUATE-182))|(1<<(Cobol85ParserEXHIBIT-182))|(1<<(Cobol85ParserEXIT-182)))) != 0) || (((_la-220)&-(0x1f+1)) == 0 && ((1<<uint((_la-220)))&((1<<(Cobol85ParserGENERATE-220))|(1<<(Cobol85ParserGOBACK-220))|(1<<(Cobol85ParserGO-220))|(1<<(Cobol85ParserIF-220))|(1<<(Cobol85ParserINITIALIZE-220))|(1<<(Cobol85ParserINITIATE-220))|(1<<(Cobol85ParserINSPECT-220)))) != 0) || (((_la-294)&-(0x1f+1)) == 0 && ((1<<uint((_la-294)))&((1<<(Cobol85ParserMERGE-294))|(1<<(Cobol85ParserMOVE-294))|(1<<(Cobol85ParserMULTIPLY-294)))) != 0) || _la == Cobol85ParserOPEN || _la == Cobol85ParserPERFORM || (((_la-365)&-(0x1f+1)) == 0 && ((1<<uint((_la-365)))&((1<<(Cobol85ParserPURGE-365))|(1<<(Cobol85ParserREAD-365))|(1<<(Cobol85ParserRECEIVE-365))|(1<<(Cobol85ParserRELEASE-365)))) != 0) || (((_la-403)&-(0x1f+1)) == 0 && ((1<<uint((_la-403)))&((1<<(Cobol85ParserRETURN-403))|(1<<(Cobol85ParserREWRITE-403))|(1<<(Cobol85ParserSEARCH-403))|(1<<(Cobol85ParserSEND-403))|(1<<(Cobol85ParserSET-403)))) != 0) || (((_la-440)&-(0x1f+1)) == 0 && ((1<<uint((_la-440)))&((1<<(Cobol85ParserSORT-440))|(1<<(Cobol85ParserSTART-440))|(1<<(Cobol85ParserSTOP-440))|(1<<(Cobol85ParserSTRING-440))|(1<<(Cobol85ParserSUBTRACT-440)))) != 0) || _la == Cobol85ParserTERMINATE || _la == Cobol85ParserUNSTRING || _la == Cobol85ParserWRITE || (((_la-559)&-(0x1f+1)) == 0 && ((1<<uint((_la-559)))&((1<<(Cobol85ParserEXECCICSLINE-559))|(1<<(Cobol85ParserEXECSQLIMSLINE-559))|(1<<(Cobol85ParserEXECSQLLINE-559)))) != 0) {
		{
			p.SetState(3581)
			p.Statement()
		}

		p.SetState(3586)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3587)
		p.Match(Cobol85ParserDOT_FS)
	}

	return localctx
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_statement
	return p
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) AcceptStatement() IAcceptStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcceptStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcceptStatementContext)
}

func (s *StatementContext) AddStatement() IAddStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAddStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAddStatementContext)
}

func (s *StatementContext) AlterStatement() IAlterStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlterStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlterStatementContext)
}

func (s *StatementContext) CallStatement() ICallStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICallStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICallStatementContext)
}

func (s *StatementContext) CancelStatement() ICancelStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICancelStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICancelStatementContext)
}

func (s *StatementContext) CloseStatement() ICloseStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICloseStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICloseStatementContext)
}

func (s *StatementContext) ComputeStatement() IComputeStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComputeStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComputeStatementContext)
}

func (s *StatementContext) ContinueStatement() IContinueStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IContinueStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IContinueStatementContext)
}

func (s *StatementContext) DeleteStatement() IDeleteStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeleteStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeleteStatementContext)
}

func (s *StatementContext) DisableStatement() IDisableStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDisableStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDisableStatementContext)
}

func (s *StatementContext) DisplayStatement() IDisplayStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDisplayStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDisplayStatementContext)
}

func (s *StatementContext) DivideStatement() IDivideStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDivideStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDivideStatementContext)
}

func (s *StatementContext) EnableStatement() IEnableStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnableStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnableStatementContext)
}

func (s *StatementContext) EntryStatement() IEntryStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEntryStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEntryStatementContext)
}

func (s *StatementContext) EvaluateStatement() IEvaluateStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvaluateStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEvaluateStatementContext)
}

func (s *StatementContext) ExhibitStatement() IExhibitStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExhibitStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExhibitStatementContext)
}

func (s *StatementContext) ExecCicsStatement() IExecCicsStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExecCicsStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExecCicsStatementContext)
}

func (s *StatementContext) ExecSqlStatement() IExecSqlStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExecSqlStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExecSqlStatementContext)
}

func (s *StatementContext) ExecSqlImsStatement() IExecSqlImsStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExecSqlImsStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExecSqlImsStatementContext)
}

func (s *StatementContext) ExitStatement() IExitStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExitStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExitStatementContext)
}

func (s *StatementContext) GenerateStatement() IGenerateStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenerateStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenerateStatementContext)
}

func (s *StatementContext) GobackStatement() IGobackStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGobackStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGobackStatementContext)
}

func (s *StatementContext) GoToStatement() IGoToStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGoToStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGoToStatementContext)
}

func (s *StatementContext) IfStatement() IIfStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIfStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIfStatementContext)
}

func (s *StatementContext) InitializeStatement() IInitializeStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInitializeStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInitializeStatementContext)
}

func (s *StatementContext) InitiateStatement() IInitiateStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInitiateStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInitiateStatementContext)
}

func (s *StatementContext) InspectStatement() IInspectStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInspectStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInspectStatementContext)
}

func (s *StatementContext) MergeStatement() IMergeStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMergeStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMergeStatementContext)
}

func (s *StatementContext) MoveStatement() IMoveStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMoveStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMoveStatementContext)
}

func (s *StatementContext) MultiplyStatement() IMultiplyStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMultiplyStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMultiplyStatementContext)
}

func (s *StatementContext) OpenStatement() IOpenStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOpenStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOpenStatementContext)
}

func (s *StatementContext) PerformStatement() IPerformStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPerformStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPerformStatementContext)
}

func (s *StatementContext) PurgeStatement() IPurgeStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPurgeStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPurgeStatementContext)
}

func (s *StatementContext) ReadStatement() IReadStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReadStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReadStatementContext)
}

func (s *StatementContext) ReceiveStatement() IReceiveStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReceiveStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReceiveStatementContext)
}

func (s *StatementContext) ReleaseStatement() IReleaseStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReleaseStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReleaseStatementContext)
}

func (s *StatementContext) ReturnStatement() IReturnStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReturnStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReturnStatementContext)
}

func (s *StatementContext) RewriteStatement() IRewriteStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRewriteStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRewriteStatementContext)
}

func (s *StatementContext) SearchStatement() ISearchStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISearchStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISearchStatementContext)
}

func (s *StatementContext) SendStatement() ISendStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISendStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISendStatementContext)
}

func (s *StatementContext) SetStatement() ISetStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISetStatementContext)
}

func (s *StatementContext) SortStatement() ISortStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISortStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISortStatementContext)
}

func (s *StatementContext) StartStatement() IStartStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStartStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStartStatementContext)
}

func (s *StatementContext) StopStatement() IStopStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStopStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStopStatementContext)
}

func (s *StatementContext) StringStatement() IStringStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStringStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStringStatementContext)
}

func (s *StatementContext) SubtractStatement() ISubtractStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtractStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtractStatementContext)
}

func (s *StatementContext) TerminateStatement() ITerminateStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITerminateStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITerminateStatementContext)
}

func (s *StatementContext) UnstringStatement() IUnstringStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnstringStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnstringStatementContext)
}

func (s *StatementContext) WriteStatement() IWriteStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWriteStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWriteStatementContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterStatement(s)
	}
}

func (s *StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitStatement(s)
	}
}

func (p *Cobol85Parser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 536, Cobol85ParserRULE_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3638)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserACCEPT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3589)
			p.AcceptStatement()
		}

	case Cobol85ParserADD:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3590)
			p.AddStatement()
		}

	case Cobol85ParserALTER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3591)
			p.AlterStatement()
		}

	case Cobol85ParserCALL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3592)
			p.CallStatement()
		}

	case Cobol85ParserCANCEL:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3593)
			p.CancelStatement()
		}

	case Cobol85ParserCLOSE:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(3594)
			p.CloseStatement()
		}

	case Cobol85ParserCOMPUTE:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(3595)
			p.ComputeStatement()
		}

	case Cobol85ParserCONTINUE:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(3596)
			p.ContinueStatement()
		}

	case Cobol85ParserDELETE:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(3597)
			p.DeleteStatement()
		}

	case Cobol85ParserDISABLE:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(3598)
			p.DisableStatement()
		}

	case Cobol85ParserDISPLAY:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(3599)
			p.DisplayStatement()
		}

	case Cobol85ParserDIVIDE:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(3600)
			p.DivideStatement()
		}

	case Cobol85ParserENABLE:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(3601)
			p.EnableStatement()
		}

	case Cobol85ParserENTRY:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(3602)
			p.EntryStatement()
		}

	case Cobol85ParserEVALUATE:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(3603)
			p.EvaluateStatement()
		}

	case Cobol85ParserEXHIBIT:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(3604)
			p.ExhibitStatement()
		}

	case Cobol85ParserEXECCICSLINE:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(3605)
			p.ExecCicsStatement()
		}

	case Cobol85ParserEXECSQLLINE:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(3606)
			p.ExecSqlStatement()
		}

	case Cobol85ParserEXECSQLIMSLINE:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(3607)
			p.ExecSqlImsStatement()
		}

	case Cobol85ParserEXIT:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(3608)
			p.ExitStatement()
		}

	case Cobol85ParserGENERATE:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(3609)
			p.GenerateStatement()
		}

	case Cobol85ParserGOBACK:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(3610)
			p.GobackStatement()
		}

	case Cobol85ParserGO:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(3611)
			p.GoToStatement()
		}

	case Cobol85ParserIF:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(3612)
			p.IfStatement()
		}

	case Cobol85ParserINITIALIZE:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(3613)
			p.InitializeStatement()
		}

	case Cobol85ParserINITIATE:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(3614)
			p.InitiateStatement()
		}

	case Cobol85ParserINSPECT:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(3615)
			p.InspectStatement()
		}

	case Cobol85ParserMERGE:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(3616)
			p.MergeStatement()
		}

	case Cobol85ParserMOVE:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(3617)
			p.MoveStatement()
		}

	case Cobol85ParserMULTIPLY:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(3618)
			p.MultiplyStatement()
		}

	case Cobol85ParserOPEN:
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(3619)
			p.OpenStatement()
		}

	case Cobol85ParserPERFORM:
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(3620)
			p.PerformStatement()
		}

	case Cobol85ParserPURGE:
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(3621)
			p.PurgeStatement()
		}

	case Cobol85ParserREAD:
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(3622)
			p.ReadStatement()
		}

	case Cobol85ParserRECEIVE:
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(3623)
			p.ReceiveStatement()
		}

	case Cobol85ParserRELEASE:
		p.EnterOuterAlt(localctx, 36)
		{
			p.SetState(3624)
			p.ReleaseStatement()
		}

	case Cobol85ParserRETURN:
		p.EnterOuterAlt(localctx, 37)
		{
			p.SetState(3625)
			p.ReturnStatement()
		}

	case Cobol85ParserREWRITE:
		p.EnterOuterAlt(localctx, 38)
		{
			p.SetState(3626)
			p.RewriteStatement()
		}

	case Cobol85ParserSEARCH:
		p.EnterOuterAlt(localctx, 39)
		{
			p.SetState(3627)
			p.SearchStatement()
		}

	case Cobol85ParserSEND:
		p.EnterOuterAlt(localctx, 40)
		{
			p.SetState(3628)
			p.SendStatement()
		}

	case Cobol85ParserSET:
		p.EnterOuterAlt(localctx, 41)
		{
			p.SetState(3629)
			p.SetStatement()
		}

	case Cobol85ParserSORT:
		p.EnterOuterAlt(localctx, 42)
		{
			p.SetState(3630)
			p.SortStatement()
		}

	case Cobol85ParserSTART:
		p.EnterOuterAlt(localctx, 43)
		{
			p.SetState(3631)
			p.StartStatement()
		}

	case Cobol85ParserSTOP:
		p.EnterOuterAlt(localctx, 44)
		{
			p.SetState(3632)
			p.StopStatement()
		}

	case Cobol85ParserSTRING:
		p.EnterOuterAlt(localctx, 45)
		{
			p.SetState(3633)
			p.StringStatement()
		}

	case Cobol85ParserSUBTRACT:
		p.EnterOuterAlt(localctx, 46)
		{
			p.SetState(3634)
			p.SubtractStatement()
		}

	case Cobol85ParserTERMINATE:
		p.EnterOuterAlt(localctx, 47)
		{
			p.SetState(3635)
			p.TerminateStatement()
		}

	case Cobol85ParserUNSTRING:
		p.EnterOuterAlt(localctx, 48)
		{
			p.SetState(3636)
			p.UnstringStatement()
		}

	case Cobol85ParserWRITE:
		p.EnterOuterAlt(localctx, 49)
		{
			p.SetState(3637)
			p.WriteStatement()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAcceptStatementContext is an interface to support dynamic dispatch.
type IAcceptStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcceptStatementContext differentiates from other interfaces.
	IsAcceptStatementContext()
}

type AcceptStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcceptStatementContext() *AcceptStatementContext {
	var p = new(AcceptStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_acceptStatement
	return p
}

func (*AcceptStatementContext) IsAcceptStatementContext() {}

func NewAcceptStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcceptStatementContext {
	var p = new(AcceptStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_acceptStatement

	return p
}

func (s *AcceptStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AcceptStatementContext) ACCEPT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserACCEPT, 0)
}

func (s *AcceptStatementContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AcceptStatementContext) AcceptFromDateStatement() IAcceptFromDateStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcceptFromDateStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcceptFromDateStatementContext)
}

func (s *AcceptStatementContext) AcceptFromEscapeKeyStatement() IAcceptFromEscapeKeyStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcceptFromEscapeKeyStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcceptFromEscapeKeyStatementContext)
}

func (s *AcceptStatementContext) AcceptFromMnemonicStatement() IAcceptFromMnemonicStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcceptFromMnemonicStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcceptFromMnemonicStatementContext)
}

func (s *AcceptStatementContext) AcceptMessageCountStatement() IAcceptMessageCountStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcceptMessageCountStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcceptMessageCountStatementContext)
}

func (s *AcceptStatementContext) OnExceptionClause() IOnExceptionClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOnExceptionClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOnExceptionClauseContext)
}

func (s *AcceptStatementContext) NotOnExceptionClause() INotOnExceptionClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INotOnExceptionClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INotOnExceptionClauseContext)
}

func (s *AcceptStatementContext) END_ACCEPT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND_ACCEPT, 0)
}

func (s *AcceptStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcceptStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcceptStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAcceptStatement(s)
	}
}

func (s *AcceptStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAcceptStatement(s)
	}
}

func (p *Cobol85Parser) AcceptStatement() (localctx IAcceptStatementContext) {
	localctx = NewAcceptStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 538, Cobol85ParserRULE_acceptStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3640)
		p.Match(Cobol85ParserACCEPT)
	}
	{
		p.SetState(3641)
		p.Identifier()
	}
	p.SetState(3646)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 465, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3642)
			p.AcceptFromDateStatement()
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 465, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(3643)
			p.AcceptFromEscapeKeyStatement()
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 465, p.GetParserRuleContext()) == 3 {
		{
			p.SetState(3644)
			p.AcceptFromMnemonicStatement()
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 465, p.GetParserRuleContext()) == 4 {
		{
			p.SetState(3645)
			p.AcceptMessageCountStatement()
		}

	}
	p.SetState(3649)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 466, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3648)
			p.OnExceptionClause()
		}

	}
	p.SetState(3652)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 467, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3651)
			p.NotOnExceptionClause()
		}

	}
	p.SetState(3655)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 468, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3654)
			p.Match(Cobol85ParserEND_ACCEPT)
		}

	}

	return localctx
}

// IAcceptFromDateStatementContext is an interface to support dynamic dispatch.
type IAcceptFromDateStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcceptFromDateStatementContext differentiates from other interfaces.
	IsAcceptFromDateStatementContext()
}

type AcceptFromDateStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcceptFromDateStatementContext() *AcceptFromDateStatementContext {
	var p = new(AcceptFromDateStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_acceptFromDateStatement
	return p
}

func (*AcceptFromDateStatementContext) IsAcceptFromDateStatementContext() {}

func NewAcceptFromDateStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcceptFromDateStatementContext {
	var p = new(AcceptFromDateStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_acceptFromDateStatement

	return p
}

func (s *AcceptFromDateStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AcceptFromDateStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFROM, 0)
}

func (s *AcceptFromDateStatementContext) DATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDATE, 0)
}

func (s *AcceptFromDateStatementContext) DAY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDAY, 0)
}

func (s *AcceptFromDateStatementContext) DAY_OF_WEEK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDAY_OF_WEEK, 0)
}

func (s *AcceptFromDateStatementContext) TIME() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTIME, 0)
}

func (s *AcceptFromDateStatementContext) TIMER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTIMER, 0)
}

func (s *AcceptFromDateStatementContext) TODAYS_DATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTODAYS_DATE, 0)
}

func (s *AcceptFromDateStatementContext) TODAYS_NAME() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTODAYS_NAME, 0)
}

func (s *AcceptFromDateStatementContext) YEAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserYEAR, 0)
}

func (s *AcceptFromDateStatementContext) YYYYMMDD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserYYYYMMDD, 0)
}

func (s *AcceptFromDateStatementContext) YYYYDDD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserYYYYDDD, 0)
}

func (s *AcceptFromDateStatementContext) MMDDYYYY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMMDDYYYY, 0)
}

func (s *AcceptFromDateStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcceptFromDateStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcceptFromDateStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAcceptFromDateStatement(s)
	}
}

func (s *AcceptFromDateStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAcceptFromDateStatement(s)
	}
}

func (p *Cobol85Parser) AcceptFromDateStatement() (localctx IAcceptFromDateStatementContext) {
	localctx = NewAcceptFromDateStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 540, Cobol85ParserRULE_acceptFromDateStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3657)
		p.Match(Cobol85ParserFROM)
	}
	p.SetState(3677)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserDATE:
		{
			p.SetState(3658)
			p.Match(Cobol85ParserDATE)
		}
		p.SetState(3660)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserYYYYMMDD {
			{
				p.SetState(3659)
				p.Match(Cobol85ParserYYYYMMDD)
			}

		}

	case Cobol85ParserDAY:
		{
			p.SetState(3662)
			p.Match(Cobol85ParserDAY)
		}
		p.SetState(3664)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserYYYYDDD {
			{
				p.SetState(3663)
				p.Match(Cobol85ParserYYYYDDD)
			}

		}

	case Cobol85ParserDAY_OF_WEEK:
		{
			p.SetState(3666)
			p.Match(Cobol85ParserDAY_OF_WEEK)
		}

	case Cobol85ParserTIME:
		{
			p.SetState(3667)
			p.Match(Cobol85ParserTIME)
		}

	case Cobol85ParserTIMER:
		{
			p.SetState(3668)
			p.Match(Cobol85ParserTIMER)
		}

	case Cobol85ParserTODAYS_DATE:
		{
			p.SetState(3669)
			p.Match(Cobol85ParserTODAYS_DATE)
		}
		p.SetState(3671)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserMMDDYYYY {
			{
				p.SetState(3670)
				p.Match(Cobol85ParserMMDDYYYY)
			}

		}

	case Cobol85ParserTODAYS_NAME:
		{
			p.SetState(3673)
			p.Match(Cobol85ParserTODAYS_NAME)
		}

	case Cobol85ParserYEAR:
		{
			p.SetState(3674)
			p.Match(Cobol85ParserYEAR)
		}

	case Cobol85ParserYYYYMMDD:
		{
			p.SetState(3675)
			p.Match(Cobol85ParserYYYYMMDD)
		}

	case Cobol85ParserYYYYDDD:
		{
			p.SetState(3676)
			p.Match(Cobol85ParserYYYYDDD)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAcceptFromMnemonicStatementContext is an interface to support dynamic dispatch.
type IAcceptFromMnemonicStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcceptFromMnemonicStatementContext differentiates from other interfaces.
	IsAcceptFromMnemonicStatementContext()
}

type AcceptFromMnemonicStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcceptFromMnemonicStatementContext() *AcceptFromMnemonicStatementContext {
	var p = new(AcceptFromMnemonicStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_acceptFromMnemonicStatement
	return p
}

func (*AcceptFromMnemonicStatementContext) IsAcceptFromMnemonicStatementContext() {}

func NewAcceptFromMnemonicStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcceptFromMnemonicStatementContext {
	var p = new(AcceptFromMnemonicStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_acceptFromMnemonicStatement

	return p
}

func (s *AcceptFromMnemonicStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AcceptFromMnemonicStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFROM, 0)
}

func (s *AcceptFromMnemonicStatementContext) MnemonicName() IMnemonicNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMnemonicNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMnemonicNameContext)
}

func (s *AcceptFromMnemonicStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcceptFromMnemonicStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcceptFromMnemonicStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAcceptFromMnemonicStatement(s)
	}
}

func (s *AcceptFromMnemonicStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAcceptFromMnemonicStatement(s)
	}
}

func (p *Cobol85Parser) AcceptFromMnemonicStatement() (localctx IAcceptFromMnemonicStatementContext) {
	localctx = NewAcceptFromMnemonicStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 542, Cobol85ParserRULE_acceptFromMnemonicStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3679)
		p.Match(Cobol85ParserFROM)
	}
	{
		p.SetState(3680)
		p.MnemonicName()
	}

	return localctx
}

// IAcceptFromEscapeKeyStatementContext is an interface to support dynamic dispatch.
type IAcceptFromEscapeKeyStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcceptFromEscapeKeyStatementContext differentiates from other interfaces.
	IsAcceptFromEscapeKeyStatementContext()
}

type AcceptFromEscapeKeyStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcceptFromEscapeKeyStatementContext() *AcceptFromEscapeKeyStatementContext {
	var p = new(AcceptFromEscapeKeyStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_acceptFromEscapeKeyStatement
	return p
}

func (*AcceptFromEscapeKeyStatementContext) IsAcceptFromEscapeKeyStatementContext() {}

func NewAcceptFromEscapeKeyStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcceptFromEscapeKeyStatementContext {
	var p = new(AcceptFromEscapeKeyStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_acceptFromEscapeKeyStatement

	return p
}

func (s *AcceptFromEscapeKeyStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AcceptFromEscapeKeyStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFROM, 0)
}

func (s *AcceptFromEscapeKeyStatementContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserESCAPE, 0)
}

func (s *AcceptFromEscapeKeyStatementContext) KEY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserKEY, 0)
}

func (s *AcceptFromEscapeKeyStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcceptFromEscapeKeyStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcceptFromEscapeKeyStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAcceptFromEscapeKeyStatement(s)
	}
}

func (s *AcceptFromEscapeKeyStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAcceptFromEscapeKeyStatement(s)
	}
}

func (p *Cobol85Parser) AcceptFromEscapeKeyStatement() (localctx IAcceptFromEscapeKeyStatementContext) {
	localctx = NewAcceptFromEscapeKeyStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 544, Cobol85ParserRULE_acceptFromEscapeKeyStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3682)
		p.Match(Cobol85ParserFROM)
	}
	{
		p.SetState(3683)
		p.Match(Cobol85ParserESCAPE)
	}
	{
		p.SetState(3684)
		p.Match(Cobol85ParserKEY)
	}

	return localctx
}

// IAcceptMessageCountStatementContext is an interface to support dynamic dispatch.
type IAcceptMessageCountStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcceptMessageCountStatementContext differentiates from other interfaces.
	IsAcceptMessageCountStatementContext()
}

type AcceptMessageCountStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcceptMessageCountStatementContext() *AcceptMessageCountStatementContext {
	var p = new(AcceptMessageCountStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_acceptMessageCountStatement
	return p
}

func (*AcceptMessageCountStatementContext) IsAcceptMessageCountStatementContext() {}

func NewAcceptMessageCountStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcceptMessageCountStatementContext {
	var p = new(AcceptMessageCountStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_acceptMessageCountStatement

	return p
}

func (s *AcceptMessageCountStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AcceptMessageCountStatementContext) COUNT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOUNT, 0)
}

func (s *AcceptMessageCountStatementContext) MESSAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMESSAGE, 0)
}

func (s *AcceptMessageCountStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcceptMessageCountStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcceptMessageCountStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAcceptMessageCountStatement(s)
	}
}

func (s *AcceptMessageCountStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAcceptMessageCountStatement(s)
	}
}

func (p *Cobol85Parser) AcceptMessageCountStatement() (localctx IAcceptMessageCountStatementContext) {
	localctx = NewAcceptMessageCountStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 546, Cobol85ParserRULE_acceptMessageCountStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3687)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserMESSAGE {
		{
			p.SetState(3686)
			p.Match(Cobol85ParserMESSAGE)
		}

	}
	{
		p.SetState(3689)
		p.Match(Cobol85ParserCOUNT)
	}

	return localctx
}

// IAddStatementContext is an interface to support dynamic dispatch.
type IAddStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAddStatementContext differentiates from other interfaces.
	IsAddStatementContext()
}

type AddStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddStatementContext() *AddStatementContext {
	var p = new(AddStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_addStatement
	return p
}

func (*AddStatementContext) IsAddStatementContext() {}

func NewAddStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddStatementContext {
	var p = new(AddStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_addStatement

	return p
}

func (s *AddStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AddStatementContext) ADD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserADD, 0)
}

func (s *AddStatementContext) AddToStatement() IAddToStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAddToStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAddToStatementContext)
}

func (s *AddStatementContext) AddToGivingStatement() IAddToGivingStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAddToGivingStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAddToGivingStatementContext)
}

func (s *AddStatementContext) AddCorrespondingStatement() IAddCorrespondingStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAddCorrespondingStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAddCorrespondingStatementContext)
}

func (s *AddStatementContext) OnSizeErrorPhrase() IOnSizeErrorPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOnSizeErrorPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOnSizeErrorPhraseContext)
}

func (s *AddStatementContext) NotOnSizeErrorPhrase() INotOnSizeErrorPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INotOnSizeErrorPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INotOnSizeErrorPhraseContext)
}

func (s *AddStatementContext) END_ADD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND_ADD, 0)
}

func (s *AddStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAddStatement(s)
	}
}

func (s *AddStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAddStatement(s)
	}
}

func (p *Cobol85Parser) AddStatement() (localctx IAddStatementContext) {
	localctx = NewAddStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 548, Cobol85ParserRULE_addStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3691)
		p.Match(Cobol85ParserADD)
	}
	p.SetState(3695)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 474, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(3692)
			p.AddToStatement()
		}

	case 2:
		{
			p.SetState(3693)
			p.AddToGivingStatement()
		}

	case 3:
		{
			p.SetState(3694)
			p.AddCorrespondingStatement()
		}

	}
	p.SetState(3698)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 475, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3697)
			p.OnSizeErrorPhrase()
		}

	}
	p.SetState(3701)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 476, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3700)
			p.NotOnSizeErrorPhrase()
		}

	}
	p.SetState(3704)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 477, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3703)
			p.Match(Cobol85ParserEND_ADD)
		}

	}

	return localctx
}

// IAddToStatementContext is an interface to support dynamic dispatch.
type IAddToStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAddToStatementContext differentiates from other interfaces.
	IsAddToStatementContext()
}

type AddToStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddToStatementContext() *AddToStatementContext {
	var p = new(AddToStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_addToStatement
	return p
}

func (*AddToStatementContext) IsAddToStatementContext() {}

func NewAddToStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddToStatementContext {
	var p = new(AddToStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_addToStatement

	return p
}

func (s *AddToStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AddToStatementContext) TO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTO, 0)
}

func (s *AddToStatementContext) AllAddFrom() []IAddFromContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAddFromContext)(nil)).Elem())
	var tst = make([]IAddFromContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAddFromContext)
		}
	}

	return tst
}

func (s *AddToStatementContext) AddFrom(i int) IAddFromContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAddFromContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAddFromContext)
}

func (s *AddToStatementContext) AllAddTo() []IAddToContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAddToContext)(nil)).Elem())
	var tst = make([]IAddToContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAddToContext)
		}
	}

	return tst
}

func (s *AddToStatementContext) AddTo(i int) IAddToContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAddToContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAddToContext)
}

func (s *AddToStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddToStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddToStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAddToStatement(s)
	}
}

func (s *AddToStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAddToStatement(s)
	}
}

func (p *Cobol85Parser) AddToStatement() (localctx IAddToStatementContext) {
	localctx = NewAddToStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 550, Cobol85ParserRULE_addToStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3707)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserADDRESS)|(1<<Cobol85ParserALL)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH)|(1<<Cobol85ParserATTRIBUTE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBINARY-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-68))|(1<<(Cobol85ParserCOBOL-68))|(1<<(Cobol85ParserCOMMITMENT-68))|(1<<(Cobol85ParserCONTROL_POINT-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(Cobol85ParserCONVENTION-100))|(1<<(Cobol85ParserCRUNCH-100))|(1<<(Cobol85ParserCURSOR-100))|(1<<(Cobol85ParserDATE-100))|(1<<(Cobol85ParserDAY-100))|(1<<(Cobol85ParserDAY_OF_WEEK-100))|(1<<(Cobol85ParserDEBUG_CONTENTS-100))|(1<<(Cobol85ParserDEBUG_ITEM-100))|(1<<(Cobol85ParserDEBUG_LINE-100))|(1<<(Cobol85ParserDEBUG_NAME-100))|(1<<(Cobol85ParserDEBUG_SUB_1-100))|(1<<(Cobol85ParserDEBUG_SUB_2-100))|(1<<(Cobol85ParserDEBUG_SUB_3-100))|(1<<(Cobol85ParserDEFAULT-100))|(1<<(Cobol85ParserDEFAULT_DISPLAY-100))|(1<<(Cobol85ParserDEFINITION-100)))) != 0) || (((_la-138)&-(0x1f+1)) == 0 && ((1<<uint((_la-138)))&((1<<(Cobol85ParserDFHRESP-138))|(1<<(Cobol85ParserDFHVALUE-138))|(1<<(Cobol85ParserDISK-138))|(1<<(Cobol85ParserDONTCARE-138))|(1<<(Cobol85ParserDOUBLE-138))|(1<<(Cobol85ParserEBCDIC-138))|(1<<(Cobol85ParserEMPTY_CHECK-138)))) != 0) || (((_la-181)&-(0x1f+1)) == 0 && ((1<<uint((_la-181)))&((1<<(Cobol85ParserENTER-181))|(1<<(Cobol85ParserENTRY_PROCEDURE-181))|(1<<(Cobol85ParserERASE-181))|(1<<(Cobol85ParserEOL-181))|(1<<(Cobol85ParserEOS-181))|(1<<(Cobol85ParserESCAPE-181))|(1<<(Cobol85ParserEVENT-181))|(1<<(Cobol85ParserEXCLUSIVE-181))|(1<<(Cobol85ParserEXPORT-181))|(1<<(Cobol85ParserEXTENDED-181))|(1<<(Cobol85ParserFALSE-181)))) != 0) || (((_la-213)&-(0x1f+1)) == 0 && ((1<<uint((_la-213)))&((1<<(Cobol85ParserFOREGROUND_COLOR-213))|(1<<(Cobol85ParserFOREGROUND_COLOUR-213))|(1<<(Cobol85ParserFULL-213))|(1<<(Cobol85ParserFUNCTION-213))|(1<<(Cobol85ParserFUNCTIONNAME-213))|(1<<(Cobol85ParserFUNCTION_POINTER-213))|(1<<(Cobol85ParserGRID-213))|(1<<(Cobol85ParserHIGHLIGHT-213))|(1<<(Cobol85ParserHIGH_VALUE-213))|(1<<(Cobol85ParserHIGH_VALUES-213))|(1<<(Cobol85ParserIMPLICIT-213))|(1<<(Cobol85ParserIMPORT-213)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(Cobol85ParserINTEGER-250))|(1<<(Cobol85ParserKEPT-250))|(1<<(Cobol85ParserKEYBOARD-250))|(1<<(Cobol85ParserLANGUAGE-250))|(1<<(Cobol85ParserLB-250))|(1<<(Cobol85ParserLD-250))|(1<<(Cobol85ParserLEFTLINE-250))|(1<<(Cobol85ParserLENGTH-250))|(1<<(Cobol85ParserLENGTH_CHECK-250))|(1<<(Cobol85ParserLIBACCESS-250))|(1<<(Cobol85ParserLIBPARAMETER-250))|(1<<(Cobol85ParserLIBRARY-250))|(1<<(Cobol85ParserLINAGE_COUNTER-250))|(1<<(Cobol85ParserLINE_COUNTER-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(Cobol85ParserLIST-283))|(1<<(Cobol85ParserLOCAL-283))|(1<<(Cobol85ParserLONG_DATE-283))|(1<<(Cobol85ParserLONG_TIME-283))|(1<<(Cobol85ParserLOWER-283))|(1<<(Cobol85ParserLOWLIGHT-283))|(1<<(Cobol85ParserLOW_VALUE-283))|(1<<(Cobol85ParserLOW_VALUES-283))|(1<<(Cobol85ParserMMDDYYYY-283))|(1<<(Cobol85ParserNAMED-283))|(1<<(Cobol85ParserNATIONAL-283))|(1<<(Cobol85ParserNATIONAL_EDITED-283))|(1<<(Cobol85ParserNETWORK-283))|(1<<(Cobol85ParserNO_ECHO-283))|(1<<(Cobol85ParserNULL-283))|(1<<(Cobol85ParserNULLS-283)))) != 0) || (((_la-317)&-(0x1f+1)) == 0 && ((1<<uint((_la-317)))&((1<<(Cobol85ParserNUMERIC_DATE-317))|(1<<(Cobol85ParserNUMERIC_TIME-317))|(1<<(Cobol85ParserODT-317))|(1<<(Cobol85ParserORDERLY-317))|(1<<(Cobol85ParserOVERLINE-317))|(1<<(Cobol85ParserOWN-317))|(1<<(Cobol85ParserPAGE_COUNTER-317))|(1<<(Cobol85ParserPASSWORD-317)))) != 0) || (((_la-352)&-(0x1f+1)) == 0 && ((1<<uint((_la-352)))&((1<<(Cobol85ParserPORT-352))|(1<<(Cobol85ParserPRINTER-352))|(1<<(Cobol85ParserPRIVATE-352))|(1<<(Cobol85ParserPROCESS-352))|(1<<(Cobol85ParserPROGRAM-352))|(1<<(Cobol85ParserPROMPT-352))|(1<<(Cobol85ParserQUOTE-352))|(1<<(Cobol85ParserQUOTES-352))|(1<<(Cobol85ParserREADER-352))|(1<<(Cobol85ParserREMOTE-352))|(1<<(Cobol85ParserREAL-352))|(1<<(Cobol85ParserRECEIVED-352))|(1<<(Cobol85ParserRECURSIVE-352))|(1<<(Cobol85ParserREF-352)))) != 0) || (((_la-391)&-(0x1f+1)) == 0 && ((1<<uint((_la-391)))&((1<<(Cobol85ParserREMOVE-391))|(1<<(Cobol85ParserREQUIRED-391))|(1<<(Cobol85ParserREVERSE_VIDEO-391))|(1<<(Cobol85ParserRETURN_CODE-391))|(1<<(Cobol85ParserSAVE-391))|(1<<(Cobol85ParserSECURE-391)))) != 0) || (((_la-431)&-(0x1f+1)) == 0 && ((1<<uint((_la-431)))&((1<<(Cobol85ParserSHARED-431))|(1<<(Cobol85ParserSHAREDBYALL-431))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-431))|(1<<(Cobol85ParserSHARING-431))|(1<<(Cobol85ParserSHIFT_IN-431))|(1<<(Cobol85ParserSHIFT_OUT-431))|(1<<(Cobol85ParserSHORT_DATE-431))|(1<<(Cobol85ParserSORT_CONTROL-431))|(1<<(Cobol85ParserSORT_CORE_SIZE-431))|(1<<(Cobol85ParserSORT_FILE_SIZE-431))|(1<<(Cobol85ParserSORT_MESSAGE-431))|(1<<(Cobol85ParserSORT_MODE_SIZE-431))|(1<<(Cobol85ParserSORT_RETURN-431))|(1<<(Cobol85ParserSPACE-431))|(1<<(Cobol85ParserSPACES-431)))) != 0) || (((_la-466)&-(0x1f+1)) == 0 && ((1<<uint((_la-466)))&((1<<(Cobol85ParserSYMBOL-466))|(1<<(Cobol85ParserTALLY-466))|(1<<(Cobol85ParserTASK-466))|(1<<(Cobol85ParserTHREAD-466))|(1<<(Cobol85ParserTHREAD_LOCAL-466))|(1<<(Cobol85ParserTIME-466))|(1<<(Cobol85ParserTIMER-466))|(1<<(Cobol85ParserTODAYS_DATE-466))|(1<<(Cobol85ParserTODAYS_NAME-466))|(1<<(Cobol85ParserTRUE-466))|(1<<(Cobol85ParserTRUNCATED-466))|(1<<(Cobol85ParserTYPEDEF-466)))) != 0) || (((_la-498)&-(0x1f+1)) == 0 && ((1<<uint((_la-498)))&((1<<(Cobol85ParserUNDERLINE-498))|(1<<(Cobol85ParserVIRTUAL-498))|(1<<(Cobol85ParserWAIT-498))|(1<<(Cobol85ParserWHEN_COMPILED-498))|(1<<(Cobol85ParserYEAR-498))|(1<<(Cobol85ParserYYYYMMDD-498))|(1<<(Cobol85ParserYYYYDDD-498))|(1<<(Cobol85ParserZERO-498))|(1<<(Cobol85ParserZERO_FILL-498))|(1<<(Cobol85ParserZEROS-498))|(1<<(Cobol85ParserZEROES-498)))) != 0) || (((_la-551)&-(0x1f+1)) == 0 && ((1<<uint((_la-551)))&((1<<(Cobol85ParserNONNUMERICLITERAL-551))|(1<<(Cobol85ParserLEVEL_NUMBER_66-551))|(1<<(Cobol85ParserLEVEL_NUMBER_77-551))|(1<<(Cobol85ParserLEVEL_NUMBER_88-551))|(1<<(Cobol85ParserINTEGERLITERAL-551))|(1<<(Cobol85ParserNUMERICLITERAL-551))|(1<<(Cobol85ParserIDENTIFIER-551)))) != 0) {
		{
			p.SetState(3706)
			p.AddFrom()
		}

		p.SetState(3709)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3711)
		p.Match(Cobol85ParserTO)
	}
	p.SetState(3713)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserADDRESS)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH)|(1<<Cobol85ParserATTRIBUTE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBINARY-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-68))|(1<<(Cobol85ParserCOBOL-68))|(1<<(Cobol85ParserCOMMITMENT-68))|(1<<(Cobol85ParserCONTROL_POINT-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(Cobol85ParserCONVENTION-100))|(1<<(Cobol85ParserCRUNCH-100))|(1<<(Cobol85ParserCURSOR-100))|(1<<(Cobol85ParserDATE-100))|(1<<(Cobol85ParserDAY-100))|(1<<(Cobol85ParserDAY_OF_WEEK-100))|(1<<(Cobol85ParserDEBUG_CONTENTS-100))|(1<<(Cobol85ParserDEBUG_ITEM-100))|(1<<(Cobol85ParserDEBUG_LINE-100))|(1<<(Cobol85ParserDEBUG_NAME-100))|(1<<(Cobol85ParserDEBUG_SUB_1-100))|(1<<(Cobol85ParserDEBUG_SUB_2-100))|(1<<(Cobol85ParserDEBUG_SUB_3-100))|(1<<(Cobol85ParserDEFAULT-100))|(1<<(Cobol85ParserDEFAULT_DISPLAY-100))|(1<<(Cobol85ParserDEFINITION-100)))) != 0) || (((_la-138)&-(0x1f+1)) == 0 && ((1<<uint((_la-138)))&((1<<(Cobol85ParserDFHRESP-138))|(1<<(Cobol85ParserDFHVALUE-138))|(1<<(Cobol85ParserDISK-138))|(1<<(Cobol85ParserDONTCARE-138))|(1<<(Cobol85ParserDOUBLE-138))|(1<<(Cobol85ParserEBCDIC-138))|(1<<(Cobol85ParserEMPTY_CHECK-138)))) != 0) || (((_la-181)&-(0x1f+1)) == 0 && ((1<<uint((_la-181)))&((1<<(Cobol85ParserENTER-181))|(1<<(Cobol85ParserENTRY_PROCEDURE-181))|(1<<(Cobol85ParserERASE-181))|(1<<(Cobol85ParserEOL-181))|(1<<(Cobol85ParserEOS-181))|(1<<(Cobol85ParserESCAPE-181))|(1<<(Cobol85ParserEVENT-181))|(1<<(Cobol85ParserEXCLUSIVE-181))|(1<<(Cobol85ParserEXPORT-181))|(1<<(Cobol85ParserEXTENDED-181)))) != 0) || (((_la-213)&-(0x1f+1)) == 0 && ((1<<uint((_la-213)))&((1<<(Cobol85ParserFOREGROUND_COLOR-213))|(1<<(Cobol85ParserFOREGROUND_COLOUR-213))|(1<<(Cobol85ParserFULL-213))|(1<<(Cobol85ParserFUNCTION-213))|(1<<(Cobol85ParserFUNCTIONNAME-213))|(1<<(Cobol85ParserFUNCTION_POINTER-213))|(1<<(Cobol85ParserGRID-213))|(1<<(Cobol85ParserHIGHLIGHT-213))|(1<<(Cobol85ParserIMPLICIT-213))|(1<<(Cobol85ParserIMPORT-213)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(Cobol85ParserINTEGER-250))|(1<<(Cobol85ParserKEPT-250))|(1<<(Cobol85ParserKEYBOARD-250))|(1<<(Cobol85ParserLANGUAGE-250))|(1<<(Cobol85ParserLB-250))|(1<<(Cobol85ParserLD-250))|(1<<(Cobol85ParserLEFTLINE-250))|(1<<(Cobol85ParserLENGTH-250))|(1<<(Cobol85ParserLENGTH_CHECK-250))|(1<<(Cobol85ParserLIBACCESS-250))|(1<<(Cobol85ParserLIBPARAMETER-250))|(1<<(Cobol85ParserLIBRARY-250))|(1<<(Cobol85ParserLINAGE_COUNTER-250))|(1<<(Cobol85ParserLINE_COUNTER-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(Cobol85ParserLIST-283))|(1<<(Cobol85ParserLOCAL-283))|(1<<(Cobol85ParserLONG_DATE-283))|(1<<(Cobol85ParserLONG_TIME-283))|(1<<(Cobol85ParserLOWER-283))|(1<<(Cobol85ParserLOWLIGHT-283))|(1<<(Cobol85ParserMMDDYYYY-283))|(1<<(Cobol85ParserNAMED-283))|(1<<(Cobol85ParserNATIONAL-283))|(1<<(Cobol85ParserNATIONAL_EDITED-283))|(1<<(Cobol85ParserNETWORK-283))|(1<<(Cobol85ParserNO_ECHO-283)))) != 0) || (((_la-317)&-(0x1f+1)) == 0 && ((1<<uint((_la-317)))&((1<<(Cobol85ParserNUMERIC_DATE-317))|(1<<(Cobol85ParserNUMERIC_TIME-317))|(1<<(Cobol85ParserODT-317))|(1<<(Cobol85ParserORDERLY-317))|(1<<(Cobol85ParserOVERLINE-317))|(1<<(Cobol85ParserOWN-317))|(1<<(Cobol85ParserPAGE_COUNTER-317))|(1<<(Cobol85ParserPASSWORD-317)))) != 0) || (((_la-352)&-(0x1f+1)) == 0 && ((1<<uint((_la-352)))&((1<<(Cobol85ParserPORT-352))|(1<<(Cobol85ParserPRINTER-352))|(1<<(Cobol85ParserPRIVATE-352))|(1<<(Cobol85ParserPROCESS-352))|(1<<(Cobol85ParserPROGRAM-352))|(1<<(Cobol85ParserPROMPT-352))|(1<<(Cobol85ParserREADER-352))|(1<<(Cobol85ParserREMOTE-352))|(1<<(Cobol85ParserREAL-352))|(1<<(Cobol85ParserRECEIVED-352))|(1<<(Cobol85ParserRECURSIVE-352))|(1<<(Cobol85ParserREF-352)))) != 0) || (((_la-391)&-(0x1f+1)) == 0 && ((1<<uint((_la-391)))&((1<<(Cobol85ParserREMOVE-391))|(1<<(Cobol85ParserREQUIRED-391))|(1<<(Cobol85ParserREVERSE_VIDEO-391))|(1<<(Cobol85ParserRETURN_CODE-391))|(1<<(Cobol85ParserSAVE-391))|(1<<(Cobol85ParserSECURE-391)))) != 0) || (((_la-431)&-(0x1f+1)) == 0 && ((1<<uint((_la-431)))&((1<<(Cobol85ParserSHARED-431))|(1<<(Cobol85ParserSHAREDBYALL-431))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-431))|(1<<(Cobol85ParserSHARING-431))|(1<<(Cobol85ParserSHIFT_IN-431))|(1<<(Cobol85ParserSHIFT_OUT-431))|(1<<(Cobol85ParserSHORT_DATE-431))|(1<<(Cobol85ParserSORT_CONTROL-431))|(1<<(Cobol85ParserSORT_CORE_SIZE-431))|(1<<(Cobol85ParserSORT_FILE_SIZE-431))|(1<<(Cobol85ParserSORT_MESSAGE-431))|(1<<(Cobol85ParserSORT_MODE_SIZE-431))|(1<<(Cobol85ParserSORT_RETURN-431)))) != 0) || (((_la-466)&-(0x1f+1)) == 0 && ((1<<uint((_la-466)))&((1<<(Cobol85ParserSYMBOL-466))|(1<<(Cobol85ParserTALLY-466))|(1<<(Cobol85ParserTASK-466))|(1<<(Cobol85ParserTHREAD-466))|(1<<(Cobol85ParserTHREAD_LOCAL-466))|(1<<(Cobol85ParserTIME-466))|(1<<(Cobol85ParserTIMER-466))|(1<<(Cobol85ParserTODAYS_DATE-466))|(1<<(Cobol85ParserTODAYS_NAME-466))|(1<<(Cobol85ParserTRUNCATED-466))|(1<<(Cobol85ParserTYPEDEF-466)))) != 0) || (((_la-498)&-(0x1f+1)) == 0 && ((1<<uint((_la-498)))&((1<<(Cobol85ParserUNDERLINE-498))|(1<<(Cobol85ParserVIRTUAL-498))|(1<<(Cobol85ParserWAIT-498))|(1<<(Cobol85ParserWHEN_COMPILED-498))|(1<<(Cobol85ParserYEAR-498))|(1<<(Cobol85ParserYYYYMMDD-498))|(1<<(Cobol85ParserYYYYDDD-498))|(1<<(Cobol85ParserZERO_FILL-498)))) != 0) || (((_la-552)&-(0x1f+1)) == 0 && ((1<<uint((_la-552)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-552))|(1<<(Cobol85ParserLEVEL_NUMBER_77-552))|(1<<(Cobol85ParserLEVEL_NUMBER_88-552))|(1<<(Cobol85ParserINTEGERLITERAL-552))|(1<<(Cobol85ParserIDENTIFIER-552)))) != 0) {
		{
			p.SetState(3712)
			p.AddTo()
		}

		p.SetState(3715)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IAddToGivingStatementContext is an interface to support dynamic dispatch.
type IAddToGivingStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAddToGivingStatementContext differentiates from other interfaces.
	IsAddToGivingStatementContext()
}

type AddToGivingStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddToGivingStatementContext() *AddToGivingStatementContext {
	var p = new(AddToGivingStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_addToGivingStatement
	return p
}

func (*AddToGivingStatementContext) IsAddToGivingStatementContext() {}

func NewAddToGivingStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddToGivingStatementContext {
	var p = new(AddToGivingStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_addToGivingStatement

	return p
}

func (s *AddToGivingStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AddToGivingStatementContext) GIVING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserGIVING, 0)
}

func (s *AddToGivingStatementContext) AllAddFrom() []IAddFromContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAddFromContext)(nil)).Elem())
	var tst = make([]IAddFromContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAddFromContext)
		}
	}

	return tst
}

func (s *AddToGivingStatementContext) AddFrom(i int) IAddFromContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAddFromContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAddFromContext)
}

func (s *AddToGivingStatementContext) TO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTO, 0)
}

func (s *AddToGivingStatementContext) AllAddGiving() []IAddGivingContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAddGivingContext)(nil)).Elem())
	var tst = make([]IAddGivingContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAddGivingContext)
		}
	}

	return tst
}

func (s *AddToGivingStatementContext) AddGiving(i int) IAddGivingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAddGivingContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAddGivingContext)
}

func (s *AddToGivingStatementContext) AllAddToGiving() []IAddToGivingContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAddToGivingContext)(nil)).Elem())
	var tst = make([]IAddToGivingContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAddToGivingContext)
		}
	}

	return tst
}

func (s *AddToGivingStatementContext) AddToGiving(i int) IAddToGivingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAddToGivingContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAddToGivingContext)
}

func (s *AddToGivingStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddToGivingStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddToGivingStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAddToGivingStatement(s)
	}
}

func (s *AddToGivingStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAddToGivingStatement(s)
	}
}

func (p *Cobol85Parser) AddToGivingStatement() (localctx IAddToGivingStatementContext) {
	localctx = NewAddToGivingStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 552, Cobol85ParserRULE_addToGivingStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3718)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserADDRESS)|(1<<Cobol85ParserALL)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH)|(1<<Cobol85ParserATTRIBUTE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBINARY-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-68))|(1<<(Cobol85ParserCOBOL-68))|(1<<(Cobol85ParserCOMMITMENT-68))|(1<<(Cobol85ParserCONTROL_POINT-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(Cobol85ParserCONVENTION-100))|(1<<(Cobol85ParserCRUNCH-100))|(1<<(Cobol85ParserCURSOR-100))|(1<<(Cobol85ParserDATE-100))|(1<<(Cobol85ParserDAY-100))|(1<<(Cobol85ParserDAY_OF_WEEK-100))|(1<<(Cobol85ParserDEBUG_CONTENTS-100))|(1<<(Cobol85ParserDEBUG_ITEM-100))|(1<<(Cobol85ParserDEBUG_LINE-100))|(1<<(Cobol85ParserDEBUG_NAME-100))|(1<<(Cobol85ParserDEBUG_SUB_1-100))|(1<<(Cobol85ParserDEBUG_SUB_2-100))|(1<<(Cobol85ParserDEBUG_SUB_3-100))|(1<<(Cobol85ParserDEFAULT-100))|(1<<(Cobol85ParserDEFAULT_DISPLAY-100))|(1<<(Cobol85ParserDEFINITION-100)))) != 0) || (((_la-138)&-(0x1f+1)) == 0 && ((1<<uint((_la-138)))&((1<<(Cobol85ParserDFHRESP-138))|(1<<(Cobol85ParserDFHVALUE-138))|(1<<(Cobol85ParserDISK-138))|(1<<(Cobol85ParserDONTCARE-138))|(1<<(Cobol85ParserDOUBLE-138))|(1<<(Cobol85ParserEBCDIC-138))|(1<<(Cobol85ParserEMPTY_CHECK-138)))) != 0) || (((_la-181)&-(0x1f+1)) == 0 && ((1<<uint((_la-181)))&((1<<(Cobol85ParserENTER-181))|(1<<(Cobol85ParserENTRY_PROCEDURE-181))|(1<<(Cobol85ParserERASE-181))|(1<<(Cobol85ParserEOL-181))|(1<<(Cobol85ParserEOS-181))|(1<<(Cobol85ParserESCAPE-181))|(1<<(Cobol85ParserEVENT-181))|(1<<(Cobol85ParserEXCLUSIVE-181))|(1<<(Cobol85ParserEXPORT-181))|(1<<(Cobol85ParserEXTENDED-181))|(1<<(Cobol85ParserFALSE-181)))) != 0) || (((_la-213)&-(0x1f+1)) == 0 && ((1<<uint((_la-213)))&((1<<(Cobol85ParserFOREGROUND_COLOR-213))|(1<<(Cobol85ParserFOREGROUND_COLOUR-213))|(1<<(Cobol85ParserFULL-213))|(1<<(Cobol85ParserFUNCTION-213))|(1<<(Cobol85ParserFUNCTIONNAME-213))|(1<<(Cobol85ParserFUNCTION_POINTER-213))|(1<<(Cobol85ParserGRID-213))|(1<<(Cobol85ParserHIGHLIGHT-213))|(1<<(Cobol85ParserHIGH_VALUE-213))|(1<<(Cobol85ParserHIGH_VALUES-213))|(1<<(Cobol85ParserIMPLICIT-213))|(1<<(Cobol85ParserIMPORT-213)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(Cobol85ParserINTEGER-250))|(1<<(Cobol85ParserKEPT-250))|(1<<(Cobol85ParserKEYBOARD-250))|(1<<(Cobol85ParserLANGUAGE-250))|(1<<(Cobol85ParserLB-250))|(1<<(Cobol85ParserLD-250))|(1<<(Cobol85ParserLEFTLINE-250))|(1<<(Cobol85ParserLENGTH-250))|(1<<(Cobol85ParserLENGTH_CHECK-250))|(1<<(Cobol85ParserLIBACCESS-250))|(1<<(Cobol85ParserLIBPARAMETER-250))|(1<<(Cobol85ParserLIBRARY-250))|(1<<(Cobol85ParserLINAGE_COUNTER-250))|(1<<(Cobol85ParserLINE_COUNTER-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(Cobol85ParserLIST-283))|(1<<(Cobol85ParserLOCAL-283))|(1<<(Cobol85ParserLONG_DATE-283))|(1<<(Cobol85ParserLONG_TIME-283))|(1<<(Cobol85ParserLOWER-283))|(1<<(Cobol85ParserLOWLIGHT-283))|(1<<(Cobol85ParserLOW_VALUE-283))|(1<<(Cobol85ParserLOW_VALUES-283))|(1<<(Cobol85ParserMMDDYYYY-283))|(1<<(Cobol85ParserNAMED-283))|(1<<(Cobol85ParserNATIONAL-283))|(1<<(Cobol85ParserNATIONAL_EDITED-283))|(1<<(Cobol85ParserNETWORK-283))|(1<<(Cobol85ParserNO_ECHO-283))|(1<<(Cobol85ParserNULL-283))|(1<<(Cobol85ParserNULLS-283)))) != 0) || (((_la-317)&-(0x1f+1)) == 0 && ((1<<uint((_la-317)))&((1<<(Cobol85ParserNUMERIC_DATE-317))|(1<<(Cobol85ParserNUMERIC_TIME-317))|(1<<(Cobol85ParserODT-317))|(1<<(Cobol85ParserORDERLY-317))|(1<<(Cobol85ParserOVERLINE-317))|(1<<(Cobol85ParserOWN-317))|(1<<(Cobol85ParserPAGE_COUNTER-317))|(1<<(Cobol85ParserPASSWORD-317)))) != 0) || (((_la-352)&-(0x1f+1)) == 0 && ((1<<uint((_la-352)))&((1<<(Cobol85ParserPORT-352))|(1<<(Cobol85ParserPRINTER-352))|(1<<(Cobol85ParserPRIVATE-352))|(1<<(Cobol85ParserPROCESS-352))|(1<<(Cobol85ParserPROGRAM-352))|(1<<(Cobol85ParserPROMPT-352))|(1<<(Cobol85ParserQUOTE-352))|(1<<(Cobol85ParserQUOTES-352))|(1<<(Cobol85ParserREADER-352))|(1<<(Cobol85ParserREMOTE-352))|(1<<(Cobol85ParserREAL-352))|(1<<(Cobol85ParserRECEIVED-352))|(1<<(Cobol85ParserRECURSIVE-352))|(1<<(Cobol85ParserREF-352)))) != 0) || (((_la-391)&-(0x1f+1)) == 0 && ((1<<uint((_la-391)))&((1<<(Cobol85ParserREMOVE-391))|(1<<(Cobol85ParserREQUIRED-391))|(1<<(Cobol85ParserREVERSE_VIDEO-391))|(1<<(Cobol85ParserRETURN_CODE-391))|(1<<(Cobol85ParserSAVE-391))|(1<<(Cobol85ParserSECURE-391)))) != 0) || (((_la-431)&-(0x1f+1)) == 0 && ((1<<uint((_la-431)))&((1<<(Cobol85ParserSHARED-431))|(1<<(Cobol85ParserSHAREDBYALL-431))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-431))|(1<<(Cobol85ParserSHARING-431))|(1<<(Cobol85ParserSHIFT_IN-431))|(1<<(Cobol85ParserSHIFT_OUT-431))|(1<<(Cobol85ParserSHORT_DATE-431))|(1<<(Cobol85ParserSORT_CONTROL-431))|(1<<(Cobol85ParserSORT_CORE_SIZE-431))|(1<<(Cobol85ParserSORT_FILE_SIZE-431))|(1<<(Cobol85ParserSORT_MESSAGE-431))|(1<<(Cobol85ParserSORT_MODE_SIZE-431))|(1<<(Cobol85ParserSORT_RETURN-431))|(1<<(Cobol85ParserSPACE-431))|(1<<(Cobol85ParserSPACES-431)))) != 0) || (((_la-466)&-(0x1f+1)) == 0 && ((1<<uint((_la-466)))&((1<<(Cobol85ParserSYMBOL-466))|(1<<(Cobol85ParserTALLY-466))|(1<<(Cobol85ParserTASK-466))|(1<<(Cobol85ParserTHREAD-466))|(1<<(Cobol85ParserTHREAD_LOCAL-466))|(1<<(Cobol85ParserTIME-466))|(1<<(Cobol85ParserTIMER-466))|(1<<(Cobol85ParserTODAYS_DATE-466))|(1<<(Cobol85ParserTODAYS_NAME-466))|(1<<(Cobol85ParserTRUE-466))|(1<<(Cobol85ParserTRUNCATED-466))|(1<<(Cobol85ParserTYPEDEF-466)))) != 0) || (((_la-498)&-(0x1f+1)) == 0 && ((1<<uint((_la-498)))&((1<<(Cobol85ParserUNDERLINE-498))|(1<<(Cobol85ParserVIRTUAL-498))|(1<<(Cobol85ParserWAIT-498))|(1<<(Cobol85ParserWHEN_COMPILED-498))|(1<<(Cobol85ParserYEAR-498))|(1<<(Cobol85ParserYYYYMMDD-498))|(1<<(Cobol85ParserYYYYDDD-498))|(1<<(Cobol85ParserZERO-498))|(1<<(Cobol85ParserZERO_FILL-498))|(1<<(Cobol85ParserZEROS-498))|(1<<(Cobol85ParserZEROES-498)))) != 0) || (((_la-551)&-(0x1f+1)) == 0 && ((1<<uint((_la-551)))&((1<<(Cobol85ParserNONNUMERICLITERAL-551))|(1<<(Cobol85ParserLEVEL_NUMBER_66-551))|(1<<(Cobol85ParserLEVEL_NUMBER_77-551))|(1<<(Cobol85ParserLEVEL_NUMBER_88-551))|(1<<(Cobol85ParserINTEGERLITERAL-551))|(1<<(Cobol85ParserNUMERICLITERAL-551))|(1<<(Cobol85ParserIDENTIFIER-551)))) != 0) {
		{
			p.SetState(3717)
			p.AddFrom()
		}

		p.SetState(3720)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(3728)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserTO {
		{
			p.SetState(3722)
			p.Match(Cobol85ParserTO)
		}
		p.SetState(3724)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserADDRESS)|(1<<Cobol85ParserALL)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH)|(1<<Cobol85ParserATTRIBUTE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBINARY-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-68))|(1<<(Cobol85ParserCOBOL-68))|(1<<(Cobol85ParserCOMMITMENT-68))|(1<<(Cobol85ParserCONTROL_POINT-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(Cobol85ParserCONVENTION-100))|(1<<(Cobol85ParserCRUNCH-100))|(1<<(Cobol85ParserCURSOR-100))|(1<<(Cobol85ParserDATE-100))|(1<<(Cobol85ParserDAY-100))|(1<<(Cobol85ParserDAY_OF_WEEK-100))|(1<<(Cobol85ParserDEBUG_CONTENTS-100))|(1<<(Cobol85ParserDEBUG_ITEM-100))|(1<<(Cobol85ParserDEBUG_LINE-100))|(1<<(Cobol85ParserDEBUG_NAME-100))|(1<<(Cobol85ParserDEBUG_SUB_1-100))|(1<<(Cobol85ParserDEBUG_SUB_2-100))|(1<<(Cobol85ParserDEBUG_SUB_3-100))|(1<<(Cobol85ParserDEFAULT-100))|(1<<(Cobol85ParserDEFAULT_DISPLAY-100))|(1<<(Cobol85ParserDEFINITION-100)))) != 0) || (((_la-138)&-(0x1f+1)) == 0 && ((1<<uint((_la-138)))&((1<<(Cobol85ParserDFHRESP-138))|(1<<(Cobol85ParserDFHVALUE-138))|(1<<(Cobol85ParserDISK-138))|(1<<(Cobol85ParserDONTCARE-138))|(1<<(Cobol85ParserDOUBLE-138))|(1<<(Cobol85ParserEBCDIC-138))|(1<<(Cobol85ParserEMPTY_CHECK-138)))) != 0) || (((_la-181)&-(0x1f+1)) == 0 && ((1<<uint((_la-181)))&((1<<(Cobol85ParserENTER-181))|(1<<(Cobol85ParserENTRY_PROCEDURE-181))|(1<<(Cobol85ParserERASE-181))|(1<<(Cobol85ParserEOL-181))|(1<<(Cobol85ParserEOS-181))|(1<<(Cobol85ParserESCAPE-181))|(1<<(Cobol85ParserEVENT-181))|(1<<(Cobol85ParserEXCLUSIVE-181))|(1<<(Cobol85ParserEXPORT-181))|(1<<(Cobol85ParserEXTENDED-181))|(1<<(Cobol85ParserFALSE-181)))) != 0) || (((_la-213)&-(0x1f+1)) == 0 && ((1<<uint((_la-213)))&((1<<(Cobol85ParserFOREGROUND_COLOR-213))|(1<<(Cobol85ParserFOREGROUND_COLOUR-213))|(1<<(Cobol85ParserFULL-213))|(1<<(Cobol85ParserFUNCTION-213))|(1<<(Cobol85ParserFUNCTIONNAME-213))|(1<<(Cobol85ParserFUNCTION_POINTER-213))|(1<<(Cobol85ParserGRID-213))|(1<<(Cobol85ParserHIGHLIGHT-213))|(1<<(Cobol85ParserHIGH_VALUE-213))|(1<<(Cobol85ParserHIGH_VALUES-213))|(1<<(Cobol85ParserIMPLICIT-213))|(1<<(Cobol85ParserIMPORT-213)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(Cobol85ParserINTEGER-250))|(1<<(Cobol85ParserKEPT-250))|(1<<(Cobol85ParserKEYBOARD-250))|(1<<(Cobol85ParserLANGUAGE-250))|(1<<(Cobol85ParserLB-250))|(1<<(Cobol85ParserLD-250))|(1<<(Cobol85ParserLEFTLINE-250))|(1<<(Cobol85ParserLENGTH-250))|(1<<(Cobol85ParserLENGTH_CHECK-250))|(1<<(Cobol85ParserLIBACCESS-250))|(1<<(Cobol85ParserLIBPARAMETER-250))|(1<<(Cobol85ParserLIBRARY-250))|(1<<(Cobol85ParserLINAGE_COUNTER-250))|(1<<(Cobol85ParserLINE_COUNTER-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(Cobol85ParserLIST-283))|(1<<(Cobol85ParserLOCAL-283))|(1<<(Cobol85ParserLONG_DATE-283))|(1<<(Cobol85ParserLONG_TIME-283))|(1<<(Cobol85ParserLOWER-283))|(1<<(Cobol85ParserLOWLIGHT-283))|(1<<(Cobol85ParserLOW_VALUE-283))|(1<<(Cobol85ParserLOW_VALUES-283))|(1<<(Cobol85ParserMMDDYYYY-283))|(1<<(Cobol85ParserNAMED-283))|(1<<(Cobol85ParserNATIONAL-283))|(1<<(Cobol85ParserNATIONAL_EDITED-283))|(1<<(Cobol85ParserNETWORK-283))|(1<<(Cobol85ParserNO_ECHO-283))|(1<<(Cobol85ParserNULL-283))|(1<<(Cobol85ParserNULLS-283)))) != 0) || (((_la-317)&-(0x1f+1)) == 0 && ((1<<uint((_la-317)))&((1<<(Cobol85ParserNUMERIC_DATE-317))|(1<<(Cobol85ParserNUMERIC_TIME-317))|(1<<(Cobol85ParserODT-317))|(1<<(Cobol85ParserORDERLY-317))|(1<<(Cobol85ParserOVERLINE-317))|(1<<(Cobol85ParserOWN-317))|(1<<(Cobol85ParserPAGE_COUNTER-317))|(1<<(Cobol85ParserPASSWORD-317)))) != 0) || (((_la-352)&-(0x1f+1)) == 0 && ((1<<uint((_la-352)))&((1<<(Cobol85ParserPORT-352))|(1<<(Cobol85ParserPRINTER-352))|(1<<(Cobol85ParserPRIVATE-352))|(1<<(Cobol85ParserPROCESS-352))|(1<<(Cobol85ParserPROGRAM-352))|(1<<(Cobol85ParserPROMPT-352))|(1<<(Cobol85ParserQUOTE-352))|(1<<(Cobol85ParserQUOTES-352))|(1<<(Cobol85ParserREADER-352))|(1<<(Cobol85ParserREMOTE-352))|(1<<(Cobol85ParserREAL-352))|(1<<(Cobol85ParserRECEIVED-352))|(1<<(Cobol85ParserRECURSIVE-352))|(1<<(Cobol85ParserREF-352)))) != 0) || (((_la-391)&-(0x1f+1)) == 0 && ((1<<uint((_la-391)))&((1<<(Cobol85ParserREMOVE-391))|(1<<(Cobol85ParserREQUIRED-391))|(1<<(Cobol85ParserREVERSE_VIDEO-391))|(1<<(Cobol85ParserRETURN_CODE-391))|(1<<(Cobol85ParserSAVE-391))|(1<<(Cobol85ParserSECURE-391)))) != 0) || (((_la-431)&-(0x1f+1)) == 0 && ((1<<uint((_la-431)))&((1<<(Cobol85ParserSHARED-431))|(1<<(Cobol85ParserSHAREDBYALL-431))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-431))|(1<<(Cobol85ParserSHARING-431))|(1<<(Cobol85ParserSHIFT_IN-431))|(1<<(Cobol85ParserSHIFT_OUT-431))|(1<<(Cobol85ParserSHORT_DATE-431))|(1<<(Cobol85ParserSORT_CONTROL-431))|(1<<(Cobol85ParserSORT_CORE_SIZE-431))|(1<<(Cobol85ParserSORT_FILE_SIZE-431))|(1<<(Cobol85ParserSORT_MESSAGE-431))|(1<<(Cobol85ParserSORT_MODE_SIZE-431))|(1<<(Cobol85ParserSORT_RETURN-431))|(1<<(Cobol85ParserSPACE-431))|(1<<(Cobol85ParserSPACES-431)))) != 0) || (((_la-466)&-(0x1f+1)) == 0 && ((1<<uint((_la-466)))&((1<<(Cobol85ParserSYMBOL-466))|(1<<(Cobol85ParserTALLY-466))|(1<<(Cobol85ParserTASK-466))|(1<<(Cobol85ParserTHREAD-466))|(1<<(Cobol85ParserTHREAD_LOCAL-466))|(1<<(Cobol85ParserTIME-466))|(1<<(Cobol85ParserTIMER-466))|(1<<(Cobol85ParserTODAYS_DATE-466))|(1<<(Cobol85ParserTODAYS_NAME-466))|(1<<(Cobol85ParserTRUE-466))|(1<<(Cobol85ParserTRUNCATED-466))|(1<<(Cobol85ParserTYPEDEF-466)))) != 0) || (((_la-498)&-(0x1f+1)) == 0 && ((1<<uint((_la-498)))&((1<<(Cobol85ParserUNDERLINE-498))|(1<<(Cobol85ParserVIRTUAL-498))|(1<<(Cobol85ParserWAIT-498))|(1<<(Cobol85ParserWHEN_COMPILED-498))|(1<<(Cobol85ParserYEAR-498))|(1<<(Cobol85ParserYYYYMMDD-498))|(1<<(Cobol85ParserYYYYDDD-498))|(1<<(Cobol85ParserZERO-498))|(1<<(Cobol85ParserZERO_FILL-498))|(1<<(Cobol85ParserZEROS-498))|(1<<(Cobol85ParserZEROES-498)))) != 0) || (((_la-551)&-(0x1f+1)) == 0 && ((1<<uint((_la-551)))&((1<<(Cobol85ParserNONNUMERICLITERAL-551))|(1<<(Cobol85ParserLEVEL_NUMBER_66-551))|(1<<(Cobol85ParserLEVEL_NUMBER_77-551))|(1<<(Cobol85ParserLEVEL_NUMBER_88-551))|(1<<(Cobol85ParserINTEGERLITERAL-551))|(1<<(Cobol85ParserNUMERICLITERAL-551))|(1<<(Cobol85ParserIDENTIFIER-551)))) != 0) {
			{
				p.SetState(3723)
				p.AddToGiving()
			}

			p.SetState(3726)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(3730)
		p.Match(Cobol85ParserGIVING)
	}
	p.SetState(3732)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserADDRESS)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH)|(1<<Cobol85ParserATTRIBUTE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBINARY-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-68))|(1<<(Cobol85ParserCOBOL-68))|(1<<(Cobol85ParserCOMMITMENT-68))|(1<<(Cobol85ParserCONTROL_POINT-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(Cobol85ParserCONVENTION-100))|(1<<(Cobol85ParserCRUNCH-100))|(1<<(Cobol85ParserCURSOR-100))|(1<<(Cobol85ParserDATE-100))|(1<<(Cobol85ParserDAY-100))|(1<<(Cobol85ParserDAY_OF_WEEK-100))|(1<<(Cobol85ParserDEBUG_CONTENTS-100))|(1<<(Cobol85ParserDEBUG_ITEM-100))|(1<<(Cobol85ParserDEBUG_LINE-100))|(1<<(Cobol85ParserDEBUG_NAME-100))|(1<<(Cobol85ParserDEBUG_SUB_1-100))|(1<<(Cobol85ParserDEBUG_SUB_2-100))|(1<<(Cobol85ParserDEBUG_SUB_3-100))|(1<<(Cobol85ParserDEFAULT-100))|(1<<(Cobol85ParserDEFAULT_DISPLAY-100))|(1<<(Cobol85ParserDEFINITION-100)))) != 0) || (((_la-138)&-(0x1f+1)) == 0 && ((1<<uint((_la-138)))&((1<<(Cobol85ParserDFHRESP-138))|(1<<(Cobol85ParserDFHVALUE-138))|(1<<(Cobol85ParserDISK-138))|(1<<(Cobol85ParserDONTCARE-138))|(1<<(Cobol85ParserDOUBLE-138))|(1<<(Cobol85ParserEBCDIC-138))|(1<<(Cobol85ParserEMPTY_CHECK-138)))) != 0) || (((_la-181)&-(0x1f+1)) == 0 && ((1<<uint((_la-181)))&((1<<(Cobol85ParserENTER-181))|(1<<(Cobol85ParserENTRY_PROCEDURE-181))|(1<<(Cobol85ParserERASE-181))|(1<<(Cobol85ParserEOL-181))|(1<<(Cobol85ParserEOS-181))|(1<<(Cobol85ParserESCAPE-181))|(1<<(Cobol85ParserEVENT-181))|(1<<(Cobol85ParserEXCLUSIVE-181))|(1<<(Cobol85ParserEXPORT-181))|(1<<(Cobol85ParserEXTENDED-181)))) != 0) || (((_la-213)&-(0x1f+1)) == 0 && ((1<<uint((_la-213)))&((1<<(Cobol85ParserFOREGROUND_COLOR-213))|(1<<(Cobol85ParserFOREGROUND_COLOUR-213))|(1<<(Cobol85ParserFULL-213))|(1<<(Cobol85ParserFUNCTION-213))|(1<<(Cobol85ParserFUNCTIONNAME-213))|(1<<(Cobol85ParserFUNCTION_POINTER-213))|(1<<(Cobol85ParserGRID-213))|(1<<(Cobol85ParserHIGHLIGHT-213))|(1<<(Cobol85ParserIMPLICIT-213))|(1<<(Cobol85ParserIMPORT-213)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(Cobol85ParserINTEGER-250))|(1<<(Cobol85ParserKEPT-250))|(1<<(Cobol85ParserKEYBOARD-250))|(1<<(Cobol85ParserLANGUAGE-250))|(1<<(Cobol85ParserLB-250))|(1<<(Cobol85ParserLD-250))|(1<<(Cobol85ParserLEFTLINE-250))|(1<<(Cobol85ParserLENGTH-250))|(1<<(Cobol85ParserLENGTH_CHECK-250))|(1<<(Cobol85ParserLIBACCESS-250))|(1<<(Cobol85ParserLIBPARAMETER-250))|(1<<(Cobol85ParserLIBRARY-250))|(1<<(Cobol85ParserLINAGE_COUNTER-250))|(1<<(Cobol85ParserLINE_COUNTER-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(Cobol85ParserLIST-283))|(1<<(Cobol85ParserLOCAL-283))|(1<<(Cobol85ParserLONG_DATE-283))|(1<<(Cobol85ParserLONG_TIME-283))|(1<<(Cobol85ParserLOWER-283))|(1<<(Cobol85ParserLOWLIGHT-283))|(1<<(Cobol85ParserMMDDYYYY-283))|(1<<(Cobol85ParserNAMED-283))|(1<<(Cobol85ParserNATIONAL-283))|(1<<(Cobol85ParserNATIONAL_EDITED-283))|(1<<(Cobol85ParserNETWORK-283))|(1<<(Cobol85ParserNO_ECHO-283)))) != 0) || (((_la-317)&-(0x1f+1)) == 0 && ((1<<uint((_la-317)))&((1<<(Cobol85ParserNUMERIC_DATE-317))|(1<<(Cobol85ParserNUMERIC_TIME-317))|(1<<(Cobol85ParserODT-317))|(1<<(Cobol85ParserORDERLY-317))|(1<<(Cobol85ParserOVERLINE-317))|(1<<(Cobol85ParserOWN-317))|(1<<(Cobol85ParserPAGE_COUNTER-317))|(1<<(Cobol85ParserPASSWORD-317)))) != 0) || (((_la-352)&-(0x1f+1)) == 0 && ((1<<uint((_la-352)))&((1<<(Cobol85ParserPORT-352))|(1<<(Cobol85ParserPRINTER-352))|(1<<(Cobol85ParserPRIVATE-352))|(1<<(Cobol85ParserPROCESS-352))|(1<<(Cobol85ParserPROGRAM-352))|(1<<(Cobol85ParserPROMPT-352))|(1<<(Cobol85ParserREADER-352))|(1<<(Cobol85ParserREMOTE-352))|(1<<(Cobol85ParserREAL-352))|(1<<(Cobol85ParserRECEIVED-352))|(1<<(Cobol85ParserRECURSIVE-352))|(1<<(Cobol85ParserREF-352)))) != 0) || (((_la-391)&-(0x1f+1)) == 0 && ((1<<uint((_la-391)))&((1<<(Cobol85ParserREMOVE-391))|(1<<(Cobol85ParserREQUIRED-391))|(1<<(Cobol85ParserREVERSE_VIDEO-391))|(1<<(Cobol85ParserRETURN_CODE-391))|(1<<(Cobol85ParserSAVE-391))|(1<<(Cobol85ParserSECURE-391)))) != 0) || (((_la-431)&-(0x1f+1)) == 0 && ((1<<uint((_la-431)))&((1<<(Cobol85ParserSHARED-431))|(1<<(Cobol85ParserSHAREDBYALL-431))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-431))|(1<<(Cobol85ParserSHARING-431))|(1<<(Cobol85ParserSHIFT_IN-431))|(1<<(Cobol85ParserSHIFT_OUT-431))|(1<<(Cobol85ParserSHORT_DATE-431))|(1<<(Cobol85ParserSORT_CONTROL-431))|(1<<(Cobol85ParserSORT_CORE_SIZE-431))|(1<<(Cobol85ParserSORT_FILE_SIZE-431))|(1<<(Cobol85ParserSORT_MESSAGE-431))|(1<<(Cobol85ParserSORT_MODE_SIZE-431))|(1<<(Cobol85ParserSORT_RETURN-431)))) != 0) || (((_la-466)&-(0x1f+1)) == 0 && ((1<<uint((_la-466)))&((1<<(Cobol85ParserSYMBOL-466))|(1<<(Cobol85ParserTALLY-466))|(1<<(Cobol85ParserTASK-466))|(1<<(Cobol85ParserTHREAD-466))|(1<<(Cobol85ParserTHREAD_LOCAL-466))|(1<<(Cobol85ParserTIME-466))|(1<<(Cobol85ParserTIMER-466))|(1<<(Cobol85ParserTODAYS_DATE-466))|(1<<(Cobol85ParserTODAYS_NAME-466))|(1<<(Cobol85ParserTRUNCATED-466))|(1<<(Cobol85ParserTYPEDEF-466)))) != 0) || (((_la-498)&-(0x1f+1)) == 0 && ((1<<uint((_la-498)))&((1<<(Cobol85ParserUNDERLINE-498))|(1<<(Cobol85ParserVIRTUAL-498))|(1<<(Cobol85ParserWAIT-498))|(1<<(Cobol85ParserWHEN_COMPILED-498))|(1<<(Cobol85ParserYEAR-498))|(1<<(Cobol85ParserYYYYMMDD-498))|(1<<(Cobol85ParserYYYYDDD-498))|(1<<(Cobol85ParserZERO_FILL-498)))) != 0) || (((_la-552)&-(0x1f+1)) == 0 && ((1<<uint((_la-552)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-552))|(1<<(Cobol85ParserLEVEL_NUMBER_77-552))|(1<<(Cobol85ParserLEVEL_NUMBER_88-552))|(1<<(Cobol85ParserINTEGERLITERAL-552))|(1<<(Cobol85ParserIDENTIFIER-552)))) != 0) {
		{
			p.SetState(3731)
			p.AddGiving()
		}

		p.SetState(3734)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IAddCorrespondingStatementContext is an interface to support dynamic dispatch.
type IAddCorrespondingStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAddCorrespondingStatementContext differentiates from other interfaces.
	IsAddCorrespondingStatementContext()
}

type AddCorrespondingStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddCorrespondingStatementContext() *AddCorrespondingStatementContext {
	var p = new(AddCorrespondingStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_addCorrespondingStatement
	return p
}

func (*AddCorrespondingStatementContext) IsAddCorrespondingStatementContext() {}

func NewAddCorrespondingStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddCorrespondingStatementContext {
	var p = new(AddCorrespondingStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_addCorrespondingStatement

	return p
}

func (s *AddCorrespondingStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AddCorrespondingStatementContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AddCorrespondingStatementContext) TO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTO, 0)
}

func (s *AddCorrespondingStatementContext) AddTo() IAddToContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAddToContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAddToContext)
}

func (s *AddCorrespondingStatementContext) CORRESPONDING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCORRESPONDING, 0)
}

func (s *AddCorrespondingStatementContext) CORR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCORR, 0)
}

func (s *AddCorrespondingStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddCorrespondingStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddCorrespondingStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAddCorrespondingStatement(s)
	}
}

func (s *AddCorrespondingStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAddCorrespondingStatement(s)
	}
}

func (p *Cobol85Parser) AddCorrespondingStatement() (localctx IAddCorrespondingStatementContext) {
	localctx = NewAddCorrespondingStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 554, Cobol85ParserRULE_addCorrespondingStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3736)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserCORR || _la == Cobol85ParserCORRESPONDING) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(3737)
		p.Identifier()
	}
	{
		p.SetState(3738)
		p.Match(Cobol85ParserTO)
	}
	{
		p.SetState(3739)
		p.AddTo()
	}

	return localctx
}

// IAddFromContext is an interface to support dynamic dispatch.
type IAddFromContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAddFromContext differentiates from other interfaces.
	IsAddFromContext()
}

type AddFromContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddFromContext() *AddFromContext {
	var p = new(AddFromContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_addFrom
	return p
}

func (*AddFromContext) IsAddFromContext() {}

func NewAddFromContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddFromContext {
	var p = new(AddFromContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_addFrom

	return p
}

func (s *AddFromContext) GetParser() antlr.Parser { return s.parser }

func (s *AddFromContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AddFromContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *AddFromContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddFromContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddFromContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAddFrom(s)
	}
}

func (s *AddFromContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAddFrom(s)
	}
}

func (p *Cobol85Parser) AddFrom() (localctx IAddFromContext) {
	localctx = NewAddFromContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 556, Cobol85ParserRULE_addFrom)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3743)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 484, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3741)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3742)
			p.Literal()
		}

	}

	return localctx
}

// IAddToContext is an interface to support dynamic dispatch.
type IAddToContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAddToContext differentiates from other interfaces.
	IsAddToContext()
}

type AddToContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddToContext() *AddToContext {
	var p = new(AddToContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_addTo
	return p
}

func (*AddToContext) IsAddToContext() {}

func NewAddToContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddToContext {
	var p = new(AddToContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_addTo

	return p
}

func (s *AddToContext) GetParser() antlr.Parser { return s.parser }

func (s *AddToContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AddToContext) ROUNDED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserROUNDED, 0)
}

func (s *AddToContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddToContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddToContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAddTo(s)
	}
}

func (s *AddToContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAddTo(s)
	}
}

func (p *Cobol85Parser) AddTo() (localctx IAddToContext) {
	localctx = NewAddToContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 558, Cobol85ParserRULE_addTo)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3745)
		p.Identifier()
	}
	p.SetState(3747)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserROUNDED {
		{
			p.SetState(3746)
			p.Match(Cobol85ParserROUNDED)
		}

	}

	return localctx
}

// IAddToGivingContext is an interface to support dynamic dispatch.
type IAddToGivingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAddToGivingContext differentiates from other interfaces.
	IsAddToGivingContext()
}

type AddToGivingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddToGivingContext() *AddToGivingContext {
	var p = new(AddToGivingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_addToGiving
	return p
}

func (*AddToGivingContext) IsAddToGivingContext() {}

func NewAddToGivingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddToGivingContext {
	var p = new(AddToGivingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_addToGiving

	return p
}

func (s *AddToGivingContext) GetParser() antlr.Parser { return s.parser }

func (s *AddToGivingContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AddToGivingContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *AddToGivingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddToGivingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddToGivingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAddToGiving(s)
	}
}

func (s *AddToGivingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAddToGiving(s)
	}
}

func (p *Cobol85Parser) AddToGiving() (localctx IAddToGivingContext) {
	localctx = NewAddToGivingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 560, Cobol85ParserRULE_addToGiving)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3751)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 486, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3749)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3750)
			p.Literal()
		}

	}

	return localctx
}

// IAddGivingContext is an interface to support dynamic dispatch.
type IAddGivingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAddGivingContext differentiates from other interfaces.
	IsAddGivingContext()
}

type AddGivingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddGivingContext() *AddGivingContext {
	var p = new(AddGivingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_addGiving
	return p
}

func (*AddGivingContext) IsAddGivingContext() {}

func NewAddGivingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddGivingContext {
	var p = new(AddGivingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_addGiving

	return p
}

func (s *AddGivingContext) GetParser() antlr.Parser { return s.parser }

func (s *AddGivingContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AddGivingContext) ROUNDED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserROUNDED, 0)
}

func (s *AddGivingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddGivingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddGivingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAddGiving(s)
	}
}

func (s *AddGivingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAddGiving(s)
	}
}

func (p *Cobol85Parser) AddGiving() (localctx IAddGivingContext) {
	localctx = NewAddGivingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 562, Cobol85ParserRULE_addGiving)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3753)
		p.Identifier()
	}
	p.SetState(3755)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserROUNDED {
		{
			p.SetState(3754)
			p.Match(Cobol85ParserROUNDED)
		}

	}

	return localctx
}

// IAlteredGoToContext is an interface to support dynamic dispatch.
type IAlteredGoToContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlteredGoToContext differentiates from other interfaces.
	IsAlteredGoToContext()
}

type AlteredGoToContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlteredGoToContext() *AlteredGoToContext {
	var p = new(AlteredGoToContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_alteredGoTo
	return p
}

func (*AlteredGoToContext) IsAlteredGoToContext() {}

func NewAlteredGoToContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlteredGoToContext {
	var p = new(AlteredGoToContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_alteredGoTo

	return p
}

func (s *AlteredGoToContext) GetParser() antlr.Parser { return s.parser }

func (s *AlteredGoToContext) GO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserGO, 0)
}

func (s *AlteredGoToContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *AlteredGoToContext) TO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTO, 0)
}

func (s *AlteredGoToContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlteredGoToContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlteredGoToContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAlteredGoTo(s)
	}
}

func (s *AlteredGoToContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAlteredGoTo(s)
	}
}

func (p *Cobol85Parser) AlteredGoTo() (localctx IAlteredGoToContext) {
	localctx = NewAlteredGoToContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 564, Cobol85ParserRULE_alteredGoTo)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3757)
		p.Match(Cobol85ParserGO)
	}
	p.SetState(3759)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserTO {
		{
			p.SetState(3758)
			p.Match(Cobol85ParserTO)
		}

	}
	{
		p.SetState(3761)
		p.Match(Cobol85ParserDOT_FS)
	}

	return localctx
}

// IAlterStatementContext is an interface to support dynamic dispatch.
type IAlterStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlterStatementContext differentiates from other interfaces.
	IsAlterStatementContext()
}

type AlterStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterStatementContext() *AlterStatementContext {
	var p = new(AlterStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_alterStatement
	return p
}

func (*AlterStatementContext) IsAlterStatementContext() {}

func NewAlterStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterStatementContext {
	var p = new(AlterStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_alterStatement

	return p
}

func (s *AlterStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALTER, 0)
}

func (s *AlterStatementContext) AllAlterProceedTo() []IAlterProceedToContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAlterProceedToContext)(nil)).Elem())
	var tst = make([]IAlterProceedToContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAlterProceedToContext)
		}
	}

	return tst
}

func (s *AlterStatementContext) AlterProceedTo(i int) IAlterProceedToContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlterProceedToContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAlterProceedToContext)
}

func (s *AlterStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAlterStatement(s)
	}
}

func (s *AlterStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAlterStatement(s)
	}
}

func (p *Cobol85Parser) AlterStatement() (localctx IAlterStatementContext) {
	localctx = NewAlterStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 566, Cobol85ParserRULE_alterStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3763)
		p.Match(Cobol85ParserALTER)
	}
	p.SetState(3765)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH)|(1<<Cobol85ParserATTRIBUTE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBINARY-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-68))|(1<<(Cobol85ParserCOBOL-68))|(1<<(Cobol85ParserCOMMITMENT-68))|(1<<(Cobol85ParserCONTROL_POINT-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(Cobol85ParserCONVENTION-100))|(1<<(Cobol85ParserCRUNCH-100))|(1<<(Cobol85ParserCURSOR-100))|(1<<(Cobol85ParserDEFAULT-100))|(1<<(Cobol85ParserDEFAULT_DISPLAY-100))|(1<<(Cobol85ParserDEFINITION-100)))) != 0) || (((_la-138)&-(0x1f+1)) == 0 && ((1<<uint((_la-138)))&((1<<(Cobol85ParserDFHRESP-138))|(1<<(Cobol85ParserDFHVALUE-138))|(1<<(Cobol85ParserDISK-138))|(1<<(Cobol85ParserDONTCARE-138))|(1<<(Cobol85ParserDOUBLE-138))|(1<<(Cobol85ParserEBCDIC-138))|(1<<(Cobol85ParserEMPTY_CHECK-138)))) != 0) || (((_la-181)&-(0x1f+1)) == 0 && ((1<<uint((_la-181)))&((1<<(Cobol85ParserENTER-181))|(1<<(Cobol85ParserENTRY_PROCEDURE-181))|(1<<(Cobol85ParserERASE-181))|(1<<(Cobol85ParserEOL-181))|(1<<(Cobol85ParserEOS-181))|(1<<(Cobol85ParserESCAPE-181))|(1<<(Cobol85ParserEVENT-181))|(1<<(Cobol85ParserEXCLUSIVE-181))|(1<<(Cobol85ParserEXPORT-181))|(1<<(Cobol85ParserEXTENDED-181)))) != 0) || (((_la-213)&-(0x1f+1)) == 0 && ((1<<uint((_la-213)))&((1<<(Cobol85ParserFOREGROUND_COLOR-213))|(1<<(Cobol85ParserFOREGROUND_COLOUR-213))|(1<<(Cobol85ParserFULL-213))|(1<<(Cobol85ParserFUNCTIONNAME-213))|(1<<(Cobol85ParserFUNCTION_POINTER-213))|(1<<(Cobol85ParserGRID-213))|(1<<(Cobol85ParserHIGHLIGHT-213))|(1<<(Cobol85ParserIMPLICIT-213))|(1<<(Cobol85ParserIMPORT-213)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(Cobol85ParserINTEGER-250))|(1<<(Cobol85ParserKEPT-250))|(1<<(Cobol85ParserKEYBOARD-250))|(1<<(Cobol85ParserLANGUAGE-250))|(1<<(Cobol85ParserLB-250))|(1<<(Cobol85ParserLD-250))|(1<<(Cobol85ParserLEFTLINE-250))|(1<<(Cobol85ParserLENGTH_CHECK-250))|(1<<(Cobol85ParserLIBACCESS-250))|(1<<(Cobol85ParserLIBPARAMETER-250))|(1<<(Cobol85ParserLIBRARY-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(Cobol85ParserLIST-283))|(1<<(Cobol85ParserLOCAL-283))|(1<<(Cobol85ParserLONG_DATE-283))|(1<<(Cobol85ParserLONG_TIME-283))|(1<<(Cobol85ParserLOWER-283))|(1<<(Cobol85ParserLOWLIGHT-283))|(1<<(Cobol85ParserMMDDYYYY-283))|(1<<(Cobol85ParserNAMED-283))|(1<<(Cobol85ParserNATIONAL-283))|(1<<(Cobol85ParserNATIONAL_EDITED-283))|(1<<(Cobol85ParserNETWORK-283))|(1<<(Cobol85ParserNO_ECHO-283)))) != 0) || (((_la-317)&-(0x1f+1)) == 0 && ((1<<uint((_la-317)))&((1<<(Cobol85ParserNUMERIC_DATE-317))|(1<<(Cobol85ParserNUMERIC_TIME-317))|(1<<(Cobol85ParserODT-317))|(1<<(Cobol85ParserORDERLY-317))|(1<<(Cobol85ParserOVERLINE-317))|(1<<(Cobol85ParserOWN-317))|(1<<(Cobol85ParserPASSWORD-317)))) != 0) || (((_la-352)&-(0x1f+1)) == 0 && ((1<<uint((_la-352)))&((1<<(Cobol85ParserPORT-352))|(1<<(Cobol85ParserPRINTER-352))|(1<<(Cobol85ParserPRIVATE-352))|(1<<(Cobol85ParserPROCESS-352))|(1<<(Cobol85ParserPROGRAM-352))|(1<<(Cobol85ParserPROMPT-352))|(1<<(Cobol85ParserREADER-352))|(1<<(Cobol85ParserREMOTE-352))|(1<<(Cobol85ParserREAL-352))|(1<<(Cobol85ParserRECEIVED-352))|(1<<(Cobol85ParserRECURSIVE-352))|(1<<(Cobol85ParserREF-352)))) != 0) || (((_la-391)&-(0x1f+1)) == 0 && ((1<<uint((_la-391)))&((1<<(Cobol85ParserREMOVE-391))|(1<<(Cobol85ParserREQUIRED-391))|(1<<(Cobol85ParserREVERSE_VIDEO-391))|(1<<(Cobol85ParserSAVE-391))|(1<<(Cobol85ParserSECURE-391)))) != 0) || (((_la-431)&-(0x1f+1)) == 0 && ((1<<uint((_la-431)))&((1<<(Cobol85ParserSHARED-431))|(1<<(Cobol85ParserSHAREDBYALL-431))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-431))|(1<<(Cobol85ParserSHARING-431))|(1<<(Cobol85ParserSHORT_DATE-431)))) != 0) || (((_la-466)&-(0x1f+1)) == 0 && ((1<<uint((_la-466)))&((1<<(Cobol85ParserSYMBOL-466))|(1<<(Cobol85ParserTASK-466))|(1<<(Cobol85ParserTHREAD-466))|(1<<(Cobol85ParserTHREAD_LOCAL-466))|(1<<(Cobol85ParserTIMER-466))|(1<<(Cobol85ParserTODAYS_DATE-466))|(1<<(Cobol85ParserTODAYS_NAME-466))|(1<<(Cobol85ParserTRUNCATED-466))|(1<<(Cobol85ParserTYPEDEF-466)))) != 0) || (((_la-498)&-(0x1f+1)) == 0 && ((1<<uint((_la-498)))&((1<<(Cobol85ParserUNDERLINE-498))|(1<<(Cobol85ParserVIRTUAL-498))|(1<<(Cobol85ParserWAIT-498))|(1<<(Cobol85ParserYEAR-498))|(1<<(Cobol85ParserYYYYMMDD-498))|(1<<(Cobol85ParserYYYYDDD-498))|(1<<(Cobol85ParserZERO_FILL-498)))) != 0) || (((_la-552)&-(0x1f+1)) == 0 && ((1<<uint((_la-552)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-552))|(1<<(Cobol85ParserLEVEL_NUMBER_77-552))|(1<<(Cobol85ParserLEVEL_NUMBER_88-552))|(1<<(Cobol85ParserINTEGERLITERAL-552))|(1<<(Cobol85ParserIDENTIFIER-552)))) != 0) {
		{
			p.SetState(3764)
			p.AlterProceedTo()
		}

		p.SetState(3767)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IAlterProceedToContext is an interface to support dynamic dispatch.
type IAlterProceedToContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlterProceedToContext differentiates from other interfaces.
	IsAlterProceedToContext()
}

type AlterProceedToContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterProceedToContext() *AlterProceedToContext {
	var p = new(AlterProceedToContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_alterProceedTo
	return p
}

func (*AlterProceedToContext) IsAlterProceedToContext() {}

func NewAlterProceedToContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterProceedToContext {
	var p = new(AlterProceedToContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_alterProceedTo

	return p
}

func (s *AlterProceedToContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterProceedToContext) AllProcedureName() []IProcedureNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IProcedureNameContext)(nil)).Elem())
	var tst = make([]IProcedureNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IProcedureNameContext)
		}
	}

	return tst
}

func (s *AlterProceedToContext) ProcedureName(i int) IProcedureNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedureNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IProcedureNameContext)
}

func (s *AlterProceedToContext) AllTO() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserTO)
}

func (s *AlterProceedToContext) TO(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTO, i)
}

func (s *AlterProceedToContext) PROCEED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPROCEED, 0)
}

func (s *AlterProceedToContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterProceedToContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterProceedToContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAlterProceedTo(s)
	}
}

func (s *AlterProceedToContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAlterProceedTo(s)
	}
}

func (p *Cobol85Parser) AlterProceedTo() (localctx IAlterProceedToContext) {
	localctx = NewAlterProceedToContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 568, Cobol85ParserRULE_alterProceedTo)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3769)
		p.ProcedureName()
	}
	{
		p.SetState(3770)
		p.Match(Cobol85ParserTO)
	}
	p.SetState(3773)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserPROCEED {
		{
			p.SetState(3771)
			p.Match(Cobol85ParserPROCEED)
		}
		{
			p.SetState(3772)
			p.Match(Cobol85ParserTO)
		}

	}
	{
		p.SetState(3775)
		p.ProcedureName()
	}

	return localctx
}

// ICallStatementContext is an interface to support dynamic dispatch.
type ICallStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCallStatementContext differentiates from other interfaces.
	IsCallStatementContext()
}

type CallStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallStatementContext() *CallStatementContext {
	var p = new(CallStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_callStatement
	return p
}

func (*CallStatementContext) IsCallStatementContext() {}

func NewCallStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallStatementContext {
	var p = new(CallStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_callStatement

	return p
}

func (s *CallStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CallStatementContext) CALL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCALL, 0)
}

func (s *CallStatementContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CallStatementContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *CallStatementContext) CallUsingPhrase() ICallUsingPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICallUsingPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICallUsingPhraseContext)
}

func (s *CallStatementContext) CallGivingPhrase() ICallGivingPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICallGivingPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICallGivingPhraseContext)
}

func (s *CallStatementContext) OnOverflowPhrase() IOnOverflowPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOnOverflowPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOnOverflowPhraseContext)
}

func (s *CallStatementContext) OnExceptionClause() IOnExceptionClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOnExceptionClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOnExceptionClauseContext)
}

func (s *CallStatementContext) NotOnExceptionClause() INotOnExceptionClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INotOnExceptionClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INotOnExceptionClauseContext)
}

func (s *CallStatementContext) END_CALL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND_CALL, 0)
}

func (s *CallStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCallStatement(s)
	}
}

func (s *CallStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCallStatement(s)
	}
}

func (p *Cobol85Parser) CallStatement() (localctx ICallStatementContext) {
	localctx = NewCallStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 570, Cobol85ParserRULE_callStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3777)
		p.Match(Cobol85ParserCALL)
	}
	p.SetState(3780)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 491, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(3778)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(3779)
			p.Literal()
		}

	}
	p.SetState(3783)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserUSING {
		{
			p.SetState(3782)
			p.CallUsingPhrase()
		}

	}
	p.SetState(3786)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserGIVING || _la == Cobol85ParserRETURNING {
		{
			p.SetState(3785)
			p.CallGivingPhrase()
		}

	}
	p.SetState(3789)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 494, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3788)
			p.OnOverflowPhrase()
		}

	}
	p.SetState(3792)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 495, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3791)
			p.OnExceptionClause()
		}

	}
	p.SetState(3795)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 496, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3794)
			p.NotOnExceptionClause()
		}

	}
	p.SetState(3798)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 497, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3797)
			p.Match(Cobol85ParserEND_CALL)
		}

	}

	return localctx
}

// ICallUsingPhraseContext is an interface to support dynamic dispatch.
type ICallUsingPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCallUsingPhraseContext differentiates from other interfaces.
	IsCallUsingPhraseContext()
}

type CallUsingPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallUsingPhraseContext() *CallUsingPhraseContext {
	var p = new(CallUsingPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_callUsingPhrase
	return p
}

func (*CallUsingPhraseContext) IsCallUsingPhraseContext() {}

func NewCallUsingPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallUsingPhraseContext {
	var p = new(CallUsingPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_callUsingPhrase

	return p
}

func (s *CallUsingPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *CallUsingPhraseContext) USING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserUSING, 0)
}

func (s *CallUsingPhraseContext) AllCallUsingParameter() []ICallUsingParameterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICallUsingParameterContext)(nil)).Elem())
	var tst = make([]ICallUsingParameterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICallUsingParameterContext)
		}
	}

	return tst
}

func (s *CallUsingPhraseContext) CallUsingParameter(i int) ICallUsingParameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICallUsingParameterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICallUsingParameterContext)
}

func (s *CallUsingPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallUsingPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallUsingPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCallUsingPhrase(s)
	}
}

func (s *CallUsingPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCallUsingPhrase(s)
	}
}

func (p *Cobol85Parser) CallUsingPhrase() (localctx ICallUsingPhraseContext) {
	localctx = NewCallUsingPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 572, Cobol85ParserRULE_callUsingPhrase)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3800)
		p.Match(Cobol85ParserUSING)
	}
	p.SetState(3802)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(3801)
				p.CallUsingParameter()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(3804)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 498, p.GetParserRuleContext())
	}

	return localctx
}

// ICallUsingParameterContext is an interface to support dynamic dispatch.
type ICallUsingParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCallUsingParameterContext differentiates from other interfaces.
	IsCallUsingParameterContext()
}

type CallUsingParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallUsingParameterContext() *CallUsingParameterContext {
	var p = new(CallUsingParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_callUsingParameter
	return p
}

func (*CallUsingParameterContext) IsCallUsingParameterContext() {}

func NewCallUsingParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallUsingParameterContext {
	var p = new(CallUsingParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_callUsingParameter

	return p
}

func (s *CallUsingParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *CallUsingParameterContext) CallByReferencePhrase() ICallByReferencePhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICallByReferencePhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICallByReferencePhraseContext)
}

func (s *CallUsingParameterContext) CallByValuePhrase() ICallByValuePhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICallByValuePhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICallByValuePhraseContext)
}

func (s *CallUsingParameterContext) CallByContentPhrase() ICallByContentPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICallByContentPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICallByContentPhraseContext)
}

func (s *CallUsingParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallUsingParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallUsingParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCallUsingParameter(s)
	}
}

func (s *CallUsingParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCallUsingParameter(s)
	}
}

func (p *Cobol85Parser) CallUsingParameter() (localctx ICallUsingParameterContext) {
	localctx = NewCallUsingParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 574, Cobol85ParserRULE_callUsingParameter)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3809)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 499, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3806)
			p.CallByReferencePhrase()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3807)
			p.CallByValuePhrase()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3808)
			p.CallByContentPhrase()
		}

	}

	return localctx
}

// ICallByReferencePhraseContext is an interface to support dynamic dispatch.
type ICallByReferencePhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCallByReferencePhraseContext differentiates from other interfaces.
	IsCallByReferencePhraseContext()
}

type CallByReferencePhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallByReferencePhraseContext() *CallByReferencePhraseContext {
	var p = new(CallByReferencePhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_callByReferencePhrase
	return p
}

func (*CallByReferencePhraseContext) IsCallByReferencePhraseContext() {}

func NewCallByReferencePhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallByReferencePhraseContext {
	var p = new(CallByReferencePhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_callByReferencePhrase

	return p
}

func (s *CallByReferencePhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *CallByReferencePhraseContext) REFERENCE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREFERENCE, 0)
}

func (s *CallByReferencePhraseContext) AllCallByReference() []ICallByReferenceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICallByReferenceContext)(nil)).Elem())
	var tst = make([]ICallByReferenceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICallByReferenceContext)
		}
	}

	return tst
}

func (s *CallByReferencePhraseContext) CallByReference(i int) ICallByReferenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICallByReferenceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICallByReferenceContext)
}

func (s *CallByReferencePhraseContext) BY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBY, 0)
}

func (s *CallByReferencePhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallByReferencePhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallByReferencePhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCallByReferencePhrase(s)
	}
}

func (s *CallByReferencePhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCallByReferencePhrase(s)
	}
}

func (p *Cobol85Parser) CallByReferencePhrase() (localctx ICallByReferencePhraseContext) {
	localctx = NewCallByReferencePhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 576, Cobol85ParserRULE_callByReferencePhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3815)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserBY || _la == Cobol85ParserREFERENCE {
		p.SetState(3812)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserBY {
			{
				p.SetState(3811)
				p.Match(Cobol85ParserBY)
			}

		}
		{
			p.SetState(3814)
			p.Match(Cobol85ParserREFERENCE)
		}

	}
	p.SetState(3818)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(3817)
				p.CallByReference()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(3820)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 502, p.GetParserRuleContext())
	}

	return localctx
}

// ICallByReferenceContext is an interface to support dynamic dispatch.
type ICallByReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCallByReferenceContext differentiates from other interfaces.
	IsCallByReferenceContext()
}

type CallByReferenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallByReferenceContext() *CallByReferenceContext {
	var p = new(CallByReferenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_callByReference
	return p
}

func (*CallByReferenceContext) IsCallByReferenceContext() {}

func NewCallByReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallByReferenceContext {
	var p = new(CallByReferenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_callByReference

	return p
}

func (s *CallByReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *CallByReferenceContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CallByReferenceContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *CallByReferenceContext) FileName() IFileNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *CallByReferenceContext) ADDRESS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserADDRESS, 0)
}

func (s *CallByReferenceContext) OF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOF, 0)
}

func (s *CallByReferenceContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINTEGER, 0)
}

func (s *CallByReferenceContext) STRING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSTRING, 0)
}

func (s *CallByReferenceContext) OMITTED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOMITTED, 0)
}

func (s *CallByReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallByReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallByReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCallByReference(s)
	}
}

func (s *CallByReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCallByReference(s)
	}
}

func (p *Cobol85Parser) CallByReference() (localctx ICallByReferenceContext) {
	localctx = NewCallByReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 578, Cobol85ParserRULE_callByReference)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3834)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserABORT, Cobol85ParserADDRESS, Cobol85ParserALL, Cobol85ParserAS, Cobol85ParserASCII, Cobol85ParserASSOCIATED_DATA, Cobol85ParserASSOCIATED_DATA_LENGTH, Cobol85ParserATTRIBUTE, Cobol85ParserAUTO, Cobol85ParserAUTO_SKIP, Cobol85ParserBACKGROUND_COLOR, Cobol85ParserBACKGROUND_COLOUR, Cobol85ParserBEEP, Cobol85ParserBELL, Cobol85ParserBINARY, Cobol85ParserBIT, Cobol85ParserBLINK, Cobol85ParserBOUNDS, Cobol85ParserCAPABLE, Cobol85ParserCCSVERSION, Cobol85ParserCHANGED, Cobol85ParserCHANNEL, Cobol85ParserCLOSE_DISPOSITION, Cobol85ParserCOBOL, Cobol85ParserCOMMITMENT, Cobol85ParserCONTROL_POINT, Cobol85ParserCONVENTION, Cobol85ParserCRUNCH, Cobol85ParserCURSOR, Cobol85ParserDATE, Cobol85ParserDAY, Cobol85ParserDAY_OF_WEEK, Cobol85ParserDEBUG_CONTENTS, Cobol85ParserDEBUG_ITEM, Cobol85ParserDEBUG_LINE, Cobol85ParserDEBUG_NAME, Cobol85ParserDEBUG_SUB_1, Cobol85ParserDEBUG_SUB_2, Cobol85ParserDEBUG_SUB_3, Cobol85ParserDEFAULT, Cobol85ParserDEFAULT_DISPLAY, Cobol85ParserDEFINITION, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserDISK, Cobol85ParserDONTCARE, Cobol85ParserDOUBLE, Cobol85ParserEBCDIC, Cobol85ParserEMPTY_CHECK, Cobol85ParserENTER, Cobol85ParserENTRY_PROCEDURE, Cobol85ParserERASE, Cobol85ParserEOL, Cobol85ParserEOS, Cobol85ParserESCAPE, Cobol85ParserEVENT, Cobol85ParserEXCLUSIVE, Cobol85ParserEXPORT, Cobol85ParserEXTENDED, Cobol85ParserFALSE, Cobol85ParserFOREGROUND_COLOR, Cobol85ParserFOREGROUND_COLOUR, Cobol85ParserFULL, Cobol85ParserFUNCTION, Cobol85ParserFUNCTIONNAME, Cobol85ParserFUNCTION_POINTER, Cobol85ParserGRID, Cobol85ParserHIGHLIGHT, Cobol85ParserHIGH_VALUE, Cobol85ParserHIGH_VALUES, Cobol85ParserIMPLICIT, Cobol85ParserIMPORT, Cobol85ParserINTEGER, Cobol85ParserKEPT, Cobol85ParserKEYBOARD, Cobol85ParserLANGUAGE, Cobol85ParserLB, Cobol85ParserLD, Cobol85ParserLEFTLINE, Cobol85ParserLENGTH, Cobol85ParserLENGTH_CHECK, Cobol85ParserLIBACCESS, Cobol85ParserLIBPARAMETER, Cobol85ParserLIBRARY, Cobol85ParserLINAGE_COUNTER, Cobol85ParserLINE_COUNTER, Cobol85ParserLIST, Cobol85ParserLOCAL, Cobol85ParserLONG_DATE, Cobol85ParserLONG_TIME, Cobol85ParserLOWER, Cobol85ParserLOWLIGHT, Cobol85ParserLOW_VALUE, Cobol85ParserLOW_VALUES, Cobol85ParserMMDDYYYY, Cobol85ParserNAMED, Cobol85ParserNATIONAL, Cobol85ParserNATIONAL_EDITED, Cobol85ParserNETWORK, Cobol85ParserNO_ECHO, Cobol85ParserNULL, Cobol85ParserNULLS, Cobol85ParserNUMERIC_DATE, Cobol85ParserNUMERIC_TIME, Cobol85ParserODT, Cobol85ParserORDERLY, Cobol85ParserOVERLINE, Cobol85ParserOWN, Cobol85ParserPAGE_COUNTER, Cobol85ParserPASSWORD, Cobol85ParserPORT, Cobol85ParserPRINTER, Cobol85ParserPRIVATE, Cobol85ParserPROCESS, Cobol85ParserPROGRAM, Cobol85ParserPROMPT, Cobol85ParserQUOTE, Cobol85ParserQUOTES, Cobol85ParserREADER, Cobol85ParserREMOTE, Cobol85ParserREAL, Cobol85ParserRECEIVED, Cobol85ParserRECURSIVE, Cobol85ParserREF, Cobol85ParserREMOVE, Cobol85ParserREQUIRED, Cobol85ParserREVERSE_VIDEO, Cobol85ParserRETURN_CODE, Cobol85ParserSAVE, Cobol85ParserSECURE, Cobol85ParserSHARED, Cobol85ParserSHAREDBYALL, Cobol85ParserSHAREDBYRUNUNIT, Cobol85ParserSHARING, Cobol85ParserSHIFT_IN, Cobol85ParserSHIFT_OUT, Cobol85ParserSHORT_DATE, Cobol85ParserSORT_CONTROL, Cobol85ParserSORT_CORE_SIZE, Cobol85ParserSORT_FILE_SIZE, Cobol85ParserSORT_MESSAGE, Cobol85ParserSORT_MODE_SIZE, Cobol85ParserSORT_RETURN, Cobol85ParserSPACE, Cobol85ParserSPACES, Cobol85ParserSTRING, Cobol85ParserSYMBOL, Cobol85ParserTALLY, Cobol85ParserTASK, Cobol85ParserTHREAD, Cobol85ParserTHREAD_LOCAL, Cobol85ParserTIME, Cobol85ParserTIMER, Cobol85ParserTODAYS_DATE, Cobol85ParserTODAYS_NAME, Cobol85ParserTRUE, Cobol85ParserTRUNCATED, Cobol85ParserTYPEDEF, Cobol85ParserUNDERLINE, Cobol85ParserVIRTUAL, Cobol85ParserWAIT, Cobol85ParserWHEN_COMPILED, Cobol85ParserYEAR, Cobol85ParserYYYYMMDD, Cobol85ParserYYYYDDD, Cobol85ParserZERO, Cobol85ParserZERO_FILL, Cobol85ParserZEROS, Cobol85ParserZEROES, Cobol85ParserNONNUMERICLITERAL, Cobol85ParserLEVEL_NUMBER_66, Cobol85ParserLEVEL_NUMBER_77, Cobol85ParserLEVEL_NUMBER_88, Cobol85ParserINTEGERLITERAL, Cobol85ParserNUMERICLITERAL, Cobol85ParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(3831)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 504, p.GetParserRuleContext()) {
		case 1:
			p.SetState(3826)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 503, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(3822)
					p.Match(Cobol85ParserADDRESS)
				}
				{
					p.SetState(3823)
					p.Match(Cobol85ParserOF)
				}

			} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 503, p.GetParserRuleContext()) == 2 {
				{
					p.SetState(3824)
					p.Match(Cobol85ParserINTEGER)
				}

			} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 503, p.GetParserRuleContext()) == 3 {
				{
					p.SetState(3825)
					p.Match(Cobol85ParserSTRING)
				}

			}
			{
				p.SetState(3828)
				p.Identifier()
			}

		case 2:
			{
				p.SetState(3829)
				p.Literal()
			}

		case 3:
			{
				p.SetState(3830)
				p.FileName()
			}

		}

	case Cobol85ParserOMITTED:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3833)
			p.Match(Cobol85ParserOMITTED)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICallByValuePhraseContext is an interface to support dynamic dispatch.
type ICallByValuePhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCallByValuePhraseContext differentiates from other interfaces.
	IsCallByValuePhraseContext()
}

type CallByValuePhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallByValuePhraseContext() *CallByValuePhraseContext {
	var p = new(CallByValuePhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_callByValuePhrase
	return p
}

func (*CallByValuePhraseContext) IsCallByValuePhraseContext() {}

func NewCallByValuePhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallByValuePhraseContext {
	var p = new(CallByValuePhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_callByValuePhrase

	return p
}

func (s *CallByValuePhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *CallByValuePhraseContext) VALUE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserVALUE, 0)
}

func (s *CallByValuePhraseContext) BY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBY, 0)
}

func (s *CallByValuePhraseContext) AllCallByValue() []ICallByValueContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICallByValueContext)(nil)).Elem())
	var tst = make([]ICallByValueContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICallByValueContext)
		}
	}

	return tst
}

func (s *CallByValuePhraseContext) CallByValue(i int) ICallByValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICallByValueContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICallByValueContext)
}

func (s *CallByValuePhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallByValuePhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallByValuePhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCallByValuePhrase(s)
	}
}

func (s *CallByValuePhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCallByValuePhrase(s)
	}
}

func (p *Cobol85Parser) CallByValuePhrase() (localctx ICallByValuePhraseContext) {
	localctx = NewCallByValuePhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 580, Cobol85ParserRULE_callByValuePhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3837)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserBY {
		{
			p.SetState(3836)
			p.Match(Cobol85ParserBY)
		}

	}
	{
		p.SetState(3839)
		p.Match(Cobol85ParserVALUE)
	}
	p.SetState(3841)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(3840)
				p.CallByValue()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(3843)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 507, p.GetParserRuleContext())
	}

	return localctx
}

// ICallByValueContext is an interface to support dynamic dispatch.
type ICallByValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCallByValueContext differentiates from other interfaces.
	IsCallByValueContext()
}

type CallByValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallByValueContext() *CallByValueContext {
	var p = new(CallByValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_callByValue
	return p
}

func (*CallByValueContext) IsCallByValueContext() {}

func NewCallByValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallByValueContext {
	var p = new(CallByValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_callByValue

	return p
}

func (s *CallByValueContext) GetParser() antlr.Parser { return s.parser }

func (s *CallByValueContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CallByValueContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *CallByValueContext) ADDRESS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserADDRESS, 0)
}

func (s *CallByValueContext) OF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOF, 0)
}

func (s *CallByValueContext) LENGTH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLENGTH, 0)
}

func (s *CallByValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallByValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallByValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCallByValue(s)
	}
}

func (s *CallByValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCallByValue(s)
	}
}

func (p *Cobol85Parser) CallByValue() (localctx ICallByValueContext) {
	localctx = NewCallByValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 582, Cobol85ParserRULE_callByValue)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3851)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 509, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3845)
			p.Match(Cobol85ParserADDRESS)
		}
		{
			p.SetState(3846)
			p.Match(Cobol85ParserOF)
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 509, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(3847)
			p.Match(Cobol85ParserLENGTH)
		}
		p.SetState(3849)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserOF {
			{
				p.SetState(3848)
				p.Match(Cobol85ParserOF)
			}

		}

	}
	p.SetState(3855)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 510, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(3853)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(3854)
			p.Literal()
		}

	}

	return localctx
}

// ICallByContentPhraseContext is an interface to support dynamic dispatch.
type ICallByContentPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCallByContentPhraseContext differentiates from other interfaces.
	IsCallByContentPhraseContext()
}

type CallByContentPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallByContentPhraseContext() *CallByContentPhraseContext {
	var p = new(CallByContentPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_callByContentPhrase
	return p
}

func (*CallByContentPhraseContext) IsCallByContentPhraseContext() {}

func NewCallByContentPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallByContentPhraseContext {
	var p = new(CallByContentPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_callByContentPhrase

	return p
}

func (s *CallByContentPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *CallByContentPhraseContext) CONTENT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCONTENT, 0)
}

func (s *CallByContentPhraseContext) BY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBY, 0)
}

func (s *CallByContentPhraseContext) AllCallByContent() []ICallByContentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICallByContentContext)(nil)).Elem())
	var tst = make([]ICallByContentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICallByContentContext)
		}
	}

	return tst
}

func (s *CallByContentPhraseContext) CallByContent(i int) ICallByContentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICallByContentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICallByContentContext)
}

func (s *CallByContentPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallByContentPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallByContentPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCallByContentPhrase(s)
	}
}

func (s *CallByContentPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCallByContentPhrase(s)
	}
}

func (p *Cobol85Parser) CallByContentPhrase() (localctx ICallByContentPhraseContext) {
	localctx = NewCallByContentPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 584, Cobol85ParserRULE_callByContentPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3858)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserBY {
		{
			p.SetState(3857)
			p.Match(Cobol85ParserBY)
		}

	}
	{
		p.SetState(3860)
		p.Match(Cobol85ParserCONTENT)
	}
	p.SetState(3862)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(3861)
				p.CallByContent()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(3864)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 512, p.GetParserRuleContext())
	}

	return localctx
}

// ICallByContentContext is an interface to support dynamic dispatch.
type ICallByContentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCallByContentContext differentiates from other interfaces.
	IsCallByContentContext()
}

type CallByContentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallByContentContext() *CallByContentContext {
	var p = new(CallByContentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_callByContent
	return p
}

func (*CallByContentContext) IsCallByContentContext() {}

func NewCallByContentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallByContentContext {
	var p = new(CallByContentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_callByContent

	return p
}

func (s *CallByContentContext) GetParser() antlr.Parser { return s.parser }

func (s *CallByContentContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CallByContentContext) ADDRESS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserADDRESS, 0)
}

func (s *CallByContentContext) OF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOF, 0)
}

func (s *CallByContentContext) LENGTH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLENGTH, 0)
}

func (s *CallByContentContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *CallByContentContext) OMITTED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOMITTED, 0)
}

func (s *CallByContentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallByContentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallByContentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCallByContent(s)
	}
}

func (s *CallByContentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCallByContent(s)
	}
}

func (p *Cobol85Parser) CallByContent() (localctx ICallByContentContext) {
	localctx = NewCallByContentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 586, Cobol85ParserRULE_callByContent)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3877)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 515, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(3872)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 514, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3866)
				p.Match(Cobol85ParserADDRESS)
			}
			{
				p.SetState(3867)
				p.Match(Cobol85ParserOF)
			}

		} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 514, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(3868)
				p.Match(Cobol85ParserLENGTH)
			}
			p.SetState(3870)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == Cobol85ParserOF {
				{
					p.SetState(3869)
					p.Match(Cobol85ParserOF)
				}

			}

		}
		{
			p.SetState(3874)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3875)
			p.Literal()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3876)
			p.Match(Cobol85ParserOMITTED)
		}

	}

	return localctx
}

// ICallGivingPhraseContext is an interface to support dynamic dispatch.
type ICallGivingPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCallGivingPhraseContext differentiates from other interfaces.
	IsCallGivingPhraseContext()
}

type CallGivingPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallGivingPhraseContext() *CallGivingPhraseContext {
	var p = new(CallGivingPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_callGivingPhrase
	return p
}

func (*CallGivingPhraseContext) IsCallGivingPhraseContext() {}

func NewCallGivingPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallGivingPhraseContext {
	var p = new(CallGivingPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_callGivingPhrase

	return p
}

func (s *CallGivingPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *CallGivingPhraseContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CallGivingPhraseContext) GIVING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserGIVING, 0)
}

func (s *CallGivingPhraseContext) RETURNING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRETURNING, 0)
}

func (s *CallGivingPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallGivingPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallGivingPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCallGivingPhrase(s)
	}
}

func (s *CallGivingPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCallGivingPhrase(s)
	}
}

func (p *Cobol85Parser) CallGivingPhrase() (localctx ICallGivingPhraseContext) {
	localctx = NewCallGivingPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 588, Cobol85ParserRULE_callGivingPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3879)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserGIVING || _la == Cobol85ParserRETURNING) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(3880)
		p.Identifier()
	}

	return localctx
}

// ICancelStatementContext is an interface to support dynamic dispatch.
type ICancelStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCancelStatementContext differentiates from other interfaces.
	IsCancelStatementContext()
}

type CancelStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCancelStatementContext() *CancelStatementContext {
	var p = new(CancelStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_cancelStatement
	return p
}

func (*CancelStatementContext) IsCancelStatementContext() {}

func NewCancelStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CancelStatementContext {
	var p = new(CancelStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_cancelStatement

	return p
}

func (s *CancelStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CancelStatementContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCANCEL, 0)
}

func (s *CancelStatementContext) AllCancelCall() []ICancelCallContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICancelCallContext)(nil)).Elem())
	var tst = make([]ICancelCallContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICancelCallContext)
		}
	}

	return tst
}

func (s *CancelStatementContext) CancelCall(i int) ICancelCallContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICancelCallContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICancelCallContext)
}

func (s *CancelStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CancelStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCancelStatement(s)
	}
}

func (s *CancelStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCancelStatement(s)
	}
}

func (p *Cobol85Parser) CancelStatement() (localctx ICancelStatementContext) {
	localctx = NewCancelStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 590, Cobol85ParserRULE_cancelStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3882)
		p.Match(Cobol85ParserCANCEL)
	}
	p.SetState(3884)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserADDRESS)|(1<<Cobol85ParserALL)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH)|(1<<Cobol85ParserATTRIBUTE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBINARY-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-68))|(1<<(Cobol85ParserCOBOL-68))|(1<<(Cobol85ParserCOMMITMENT-68))|(1<<(Cobol85ParserCONTROL_POINT-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(Cobol85ParserCONVENTION-100))|(1<<(Cobol85ParserCRUNCH-100))|(1<<(Cobol85ParserCURSOR-100))|(1<<(Cobol85ParserDATE-100))|(1<<(Cobol85ParserDAY-100))|(1<<(Cobol85ParserDAY_OF_WEEK-100))|(1<<(Cobol85ParserDEBUG_CONTENTS-100))|(1<<(Cobol85ParserDEBUG_ITEM-100))|(1<<(Cobol85ParserDEBUG_LINE-100))|(1<<(Cobol85ParserDEBUG_NAME-100))|(1<<(Cobol85ParserDEBUG_SUB_1-100))|(1<<(Cobol85ParserDEBUG_SUB_2-100))|(1<<(Cobol85ParserDEBUG_SUB_3-100))|(1<<(Cobol85ParserDEFAULT-100))|(1<<(Cobol85ParserDEFAULT_DISPLAY-100))|(1<<(Cobol85ParserDEFINITION-100)))) != 0) || (((_la-138)&-(0x1f+1)) == 0 && ((1<<uint((_la-138)))&((1<<(Cobol85ParserDFHRESP-138))|(1<<(Cobol85ParserDFHVALUE-138))|(1<<(Cobol85ParserDISK-138))|(1<<(Cobol85ParserDONTCARE-138))|(1<<(Cobol85ParserDOUBLE-138))|(1<<(Cobol85ParserEBCDIC-138))|(1<<(Cobol85ParserEMPTY_CHECK-138)))) != 0) || (((_la-181)&-(0x1f+1)) == 0 && ((1<<uint((_la-181)))&((1<<(Cobol85ParserENTER-181))|(1<<(Cobol85ParserENTRY_PROCEDURE-181))|(1<<(Cobol85ParserERASE-181))|(1<<(Cobol85ParserEOL-181))|(1<<(Cobol85ParserEOS-181))|(1<<(Cobol85ParserESCAPE-181))|(1<<(Cobol85ParserEVENT-181))|(1<<(Cobol85ParserEXCLUSIVE-181))|(1<<(Cobol85ParserEXPORT-181))|(1<<(Cobol85ParserEXTENDED-181))|(1<<(Cobol85ParserFALSE-181)))) != 0) || (((_la-213)&-(0x1f+1)) == 0 && ((1<<uint((_la-213)))&((1<<(Cobol85ParserFOREGROUND_COLOR-213))|(1<<(Cobol85ParserFOREGROUND_COLOUR-213))|(1<<(Cobol85ParserFULL-213))|(1<<(Cobol85ParserFUNCTION-213))|(1<<(Cobol85ParserFUNCTIONNAME-213))|(1<<(Cobol85ParserFUNCTION_POINTER-213))|(1<<(Cobol85ParserGRID-213))|(1<<(Cobol85ParserHIGHLIGHT-213))|(1<<(Cobol85ParserHIGH_VALUE-213))|(1<<(Cobol85ParserHIGH_VALUES-213))|(1<<(Cobol85ParserIMPLICIT-213))|(1<<(Cobol85ParserIMPORT-213)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(Cobol85ParserINTEGER-250))|(1<<(Cobol85ParserKEPT-250))|(1<<(Cobol85ParserKEYBOARD-250))|(1<<(Cobol85ParserLANGUAGE-250))|(1<<(Cobol85ParserLB-250))|(1<<(Cobol85ParserLD-250))|(1<<(Cobol85ParserLEFTLINE-250))|(1<<(Cobol85ParserLENGTH-250))|(1<<(Cobol85ParserLENGTH_CHECK-250))|(1<<(Cobol85ParserLIBACCESS-250))|(1<<(Cobol85ParserLIBPARAMETER-250))|(1<<(Cobol85ParserLIBRARY-250))|(1<<(Cobol85ParserLINAGE_COUNTER-250))|(1<<(Cobol85ParserLINE_COUNTER-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(Cobol85ParserLIST-283))|(1<<(Cobol85ParserLOCAL-283))|(1<<(Cobol85ParserLONG_DATE-283))|(1<<(Cobol85ParserLONG_TIME-283))|(1<<(Cobol85ParserLOWER-283))|(1<<(Cobol85ParserLOWLIGHT-283))|(1<<(Cobol85ParserLOW_VALUE-283))|(1<<(Cobol85ParserLOW_VALUES-283))|(1<<(Cobol85ParserMMDDYYYY-283))|(1<<(Cobol85ParserNAMED-283))|(1<<(Cobol85ParserNATIONAL-283))|(1<<(Cobol85ParserNATIONAL_EDITED-283))|(1<<(Cobol85ParserNETWORK-283))|(1<<(Cobol85ParserNO_ECHO-283))|(1<<(Cobol85ParserNULL-283))|(1<<(Cobol85ParserNULLS-283)))) != 0) || (((_la-317)&-(0x1f+1)) == 0 && ((1<<uint((_la-317)))&((1<<(Cobol85ParserNUMERIC_DATE-317))|(1<<(Cobol85ParserNUMERIC_TIME-317))|(1<<(Cobol85ParserODT-317))|(1<<(Cobol85ParserORDERLY-317))|(1<<(Cobol85ParserOVERLINE-317))|(1<<(Cobol85ParserOWN-317))|(1<<(Cobol85ParserPAGE_COUNTER-317))|(1<<(Cobol85ParserPASSWORD-317)))) != 0) || (((_la-352)&-(0x1f+1)) == 0 && ((1<<uint((_la-352)))&((1<<(Cobol85ParserPORT-352))|(1<<(Cobol85ParserPRINTER-352))|(1<<(Cobol85ParserPRIVATE-352))|(1<<(Cobol85ParserPROCESS-352))|(1<<(Cobol85ParserPROGRAM-352))|(1<<(Cobol85ParserPROMPT-352))|(1<<(Cobol85ParserQUOTE-352))|(1<<(Cobol85ParserQUOTES-352))|(1<<(Cobol85ParserREADER-352))|(1<<(Cobol85ParserREMOTE-352))|(1<<(Cobol85ParserREAL-352))|(1<<(Cobol85ParserRECEIVED-352))|(1<<(Cobol85ParserRECURSIVE-352))|(1<<(Cobol85ParserREF-352)))) != 0) || (((_la-391)&-(0x1f+1)) == 0 && ((1<<uint((_la-391)))&((1<<(Cobol85ParserREMOVE-391))|(1<<(Cobol85ParserREQUIRED-391))|(1<<(Cobol85ParserREVERSE_VIDEO-391))|(1<<(Cobol85ParserRETURN_CODE-391))|(1<<(Cobol85ParserSAVE-391))|(1<<(Cobol85ParserSECURE-391)))) != 0) || (((_la-431)&-(0x1f+1)) == 0 && ((1<<uint((_la-431)))&((1<<(Cobol85ParserSHARED-431))|(1<<(Cobol85ParserSHAREDBYALL-431))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-431))|(1<<(Cobol85ParserSHARING-431))|(1<<(Cobol85ParserSHIFT_IN-431))|(1<<(Cobol85ParserSHIFT_OUT-431))|(1<<(Cobol85ParserSHORT_DATE-431))|(1<<(Cobol85ParserSORT_CONTROL-431))|(1<<(Cobol85ParserSORT_CORE_SIZE-431))|(1<<(Cobol85ParserSORT_FILE_SIZE-431))|(1<<(Cobol85ParserSORT_MESSAGE-431))|(1<<(Cobol85ParserSORT_MODE_SIZE-431))|(1<<(Cobol85ParserSORT_RETURN-431))|(1<<(Cobol85ParserSPACE-431))|(1<<(Cobol85ParserSPACES-431)))) != 0) || (((_la-466)&-(0x1f+1)) == 0 && ((1<<uint((_la-466)))&((1<<(Cobol85ParserSYMBOL-466))|(1<<(Cobol85ParserTALLY-466))|(1<<(Cobol85ParserTASK-466))|(1<<(Cobol85ParserTHREAD-466))|(1<<(Cobol85ParserTHREAD_LOCAL-466))|(1<<(Cobol85ParserTIME-466))|(1<<(Cobol85ParserTIMER-466))|(1<<(Cobol85ParserTODAYS_DATE-466))|(1<<(Cobol85ParserTODAYS_NAME-466))|(1<<(Cobol85ParserTRUE-466))|(1<<(Cobol85ParserTRUNCATED-466))|(1<<(Cobol85ParserTYPEDEF-466)))) != 0) || (((_la-498)&-(0x1f+1)) == 0 && ((1<<uint((_la-498)))&((1<<(Cobol85ParserUNDERLINE-498))|(1<<(Cobol85ParserVIRTUAL-498))|(1<<(Cobol85ParserWAIT-498))|(1<<(Cobol85ParserWHEN_COMPILED-498))|(1<<(Cobol85ParserYEAR-498))|(1<<(Cobol85ParserYYYYMMDD-498))|(1<<(Cobol85ParserYYYYDDD-498))|(1<<(Cobol85ParserZERO-498))|(1<<(Cobol85ParserZERO_FILL-498))|(1<<(Cobol85ParserZEROS-498))|(1<<(Cobol85ParserZEROES-498)))) != 0) || (((_la-551)&-(0x1f+1)) == 0 && ((1<<uint((_la-551)))&((1<<(Cobol85ParserNONNUMERICLITERAL-551))|(1<<(Cobol85ParserLEVEL_NUMBER_66-551))|(1<<(Cobol85ParserLEVEL_NUMBER_77-551))|(1<<(Cobol85ParserLEVEL_NUMBER_88-551))|(1<<(Cobol85ParserINTEGERLITERAL-551))|(1<<(Cobol85ParserNUMERICLITERAL-551))|(1<<(Cobol85ParserIDENTIFIER-551)))) != 0) {
		{
			p.SetState(3883)
			p.CancelCall()
		}

		p.SetState(3886)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ICancelCallContext is an interface to support dynamic dispatch.
type ICancelCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCancelCallContext differentiates from other interfaces.
	IsCancelCallContext()
}

type CancelCallContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCancelCallContext() *CancelCallContext {
	var p = new(CancelCallContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_cancelCall
	return p
}

func (*CancelCallContext) IsCancelCallContext() {}

func NewCancelCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CancelCallContext {
	var p = new(CancelCallContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_cancelCall

	return p
}

func (s *CancelCallContext) GetParser() antlr.Parser { return s.parser }

func (s *CancelCallContext) LibraryName() ILibraryNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibraryNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILibraryNameContext)
}

func (s *CancelCallContext) BYTITLE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBYTITLE, 0)
}

func (s *CancelCallContext) BYFUNCTION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBYFUNCTION, 0)
}

func (s *CancelCallContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CancelCallContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *CancelCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CancelCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCancelCall(s)
	}
}

func (s *CancelCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCancelCall(s)
	}
}

func (p *Cobol85Parser) CancelCall() (localctx ICancelCallContext) {
	localctx = NewCancelCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 592, Cobol85ParserRULE_cancelCall)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3893)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 517, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3888)
			p.LibraryName()
		}
		{
			p.SetState(3889)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85ParserBYFUNCTION || _la == Cobol85ParserBYTITLE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3891)
			p.Identifier()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3892)
			p.Literal()
		}

	}

	return localctx
}

// ICloseStatementContext is an interface to support dynamic dispatch.
type ICloseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCloseStatementContext differentiates from other interfaces.
	IsCloseStatementContext()
}

type CloseStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCloseStatementContext() *CloseStatementContext {
	var p = new(CloseStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_closeStatement
	return p
}

func (*CloseStatementContext) IsCloseStatementContext() {}

func NewCloseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CloseStatementContext {
	var p = new(CloseStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_closeStatement

	return p
}

func (s *CloseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CloseStatementContext) CLOSE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCLOSE, 0)
}

func (s *CloseStatementContext) AllCloseFile() []ICloseFileContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICloseFileContext)(nil)).Elem())
	var tst = make([]ICloseFileContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICloseFileContext)
		}
	}

	return tst
}

func (s *CloseStatementContext) CloseFile(i int) ICloseFileContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICloseFileContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICloseFileContext)
}

func (s *CloseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CloseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CloseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCloseStatement(s)
	}
}

func (s *CloseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCloseStatement(s)
	}
}

func (p *Cobol85Parser) CloseStatement() (localctx ICloseStatementContext) {
	localctx = NewCloseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 594, Cobol85ParserRULE_closeStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3895)
		p.Match(Cobol85ParserCLOSE)
	}
	p.SetState(3897)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH)|(1<<Cobol85ParserATTRIBUTE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBINARY-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-68))|(1<<(Cobol85ParserCOBOL-68))|(1<<(Cobol85ParserCOMMITMENT-68))|(1<<(Cobol85ParserCONTROL_POINT-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(Cobol85ParserCONVENTION-100))|(1<<(Cobol85ParserCRUNCH-100))|(1<<(Cobol85ParserCURSOR-100))|(1<<(Cobol85ParserDEFAULT-100))|(1<<(Cobol85ParserDEFAULT_DISPLAY-100))|(1<<(Cobol85ParserDEFINITION-100)))) != 0) || (((_la-138)&-(0x1f+1)) == 0 && ((1<<uint((_la-138)))&((1<<(Cobol85ParserDFHRESP-138))|(1<<(Cobol85ParserDFHVALUE-138))|(1<<(Cobol85ParserDISK-138))|(1<<(Cobol85ParserDONTCARE-138))|(1<<(Cobol85ParserDOUBLE-138))|(1<<(Cobol85ParserEBCDIC-138))|(1<<(Cobol85ParserEMPTY_CHECK-138)))) != 0) || (((_la-181)&-(0x1f+1)) == 0 && ((1<<uint((_la-181)))&((1<<(Cobol85ParserENTER-181))|(1<<(Cobol85ParserENTRY_PROCEDURE-181))|(1<<(Cobol85ParserERASE-181))|(1<<(Cobol85ParserEOL-181))|(1<<(Cobol85ParserEOS-181))|(1<<(Cobol85ParserESCAPE-181))|(1<<(Cobol85ParserEVENT-181))|(1<<(Cobol85ParserEXCLUSIVE-181))|(1<<(Cobol85ParserEXPORT-181))|(1<<(Cobol85ParserEXTENDED-181)))) != 0) || (((_la-213)&-(0x1f+1)) == 0 && ((1<<uint((_la-213)))&((1<<(Cobol85ParserFOREGROUND_COLOR-213))|(1<<(Cobol85ParserFOREGROUND_COLOUR-213))|(1<<(Cobol85ParserFULL-213))|(1<<(Cobol85ParserFUNCTIONNAME-213))|(1<<(Cobol85ParserFUNCTION_POINTER-213))|(1<<(Cobol85ParserGRID-213))|(1<<(Cobol85ParserHIGHLIGHT-213))|(1<<(Cobol85ParserIMPLICIT-213))|(1<<(Cobol85ParserIMPORT-213)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(Cobol85ParserINTEGER-250))|(1<<(Cobol85ParserKEPT-250))|(1<<(Cobol85ParserKEYBOARD-250))|(1<<(Cobol85ParserLANGUAGE-250))|(1<<(Cobol85ParserLB-250))|(1<<(Cobol85ParserLD-250))|(1<<(Cobol85ParserLEFTLINE-250))|(1<<(Cobol85ParserLENGTH_CHECK-250))|(1<<(Cobol85ParserLIBACCESS-250))|(1<<(Cobol85ParserLIBPARAMETER-250))|(1<<(Cobol85ParserLIBRARY-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(Cobol85ParserLIST-283))|(1<<(Cobol85ParserLOCAL-283))|(1<<(Cobol85ParserLONG_DATE-283))|(1<<(Cobol85ParserLONG_TIME-283))|(1<<(Cobol85ParserLOWER-283))|(1<<(Cobol85ParserLOWLIGHT-283))|(1<<(Cobol85ParserMMDDYYYY-283))|(1<<(Cobol85ParserNAMED-283))|(1<<(Cobol85ParserNATIONAL-283))|(1<<(Cobol85ParserNATIONAL_EDITED-283))|(1<<(Cobol85ParserNETWORK-283))|(1<<(Cobol85ParserNO_ECHO-283)))) != 0) || (((_la-317)&-(0x1f+1)) == 0 && ((1<<uint((_la-317)))&((1<<(Cobol85ParserNUMERIC_DATE-317))|(1<<(Cobol85ParserNUMERIC_TIME-317))|(1<<(Cobol85ParserODT-317))|(1<<(Cobol85ParserORDERLY-317))|(1<<(Cobol85ParserOVERLINE-317))|(1<<(Cobol85ParserOWN-317))|(1<<(Cobol85ParserPASSWORD-317)))) != 0) || (((_la-352)&-(0x1f+1)) == 0 && ((1<<uint((_la-352)))&((1<<(Cobol85ParserPORT-352))|(1<<(Cobol85ParserPRINTER-352))|(1<<(Cobol85ParserPRIVATE-352))|(1<<(Cobol85ParserPROCESS-352))|(1<<(Cobol85ParserPROGRAM-352))|(1<<(Cobol85ParserPROMPT-352))|(1<<(Cobol85ParserREADER-352))|(1<<(Cobol85ParserREMOTE-352))|(1<<(Cobol85ParserREAL-352))|(1<<(Cobol85ParserRECEIVED-352))|(1<<(Cobol85ParserRECURSIVE-352))|(1<<(Cobol85ParserREF-352)))) != 0) || (((_la-391)&-(0x1f+1)) == 0 && ((1<<uint((_la-391)))&((1<<(Cobol85ParserREMOVE-391))|(1<<(Cobol85ParserREQUIRED-391))|(1<<(Cobol85ParserREVERSE_VIDEO-391))|(1<<(Cobol85ParserSAVE-391))|(1<<(Cobol85ParserSECURE-391)))) != 0) || (((_la-431)&-(0x1f+1)) == 0 && ((1<<uint((_la-431)))&((1<<(Cobol85ParserSHARED-431))|(1<<(Cobol85ParserSHAREDBYALL-431))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-431))|(1<<(Cobol85ParserSHARING-431))|(1<<(Cobol85ParserSHORT_DATE-431)))) != 0) || (((_la-466)&-(0x1f+1)) == 0 && ((1<<uint((_la-466)))&((1<<(Cobol85ParserSYMBOL-466))|(1<<(Cobol85ParserTASK-466))|(1<<(Cobol85ParserTHREAD-466))|(1<<(Cobol85ParserTHREAD_LOCAL-466))|(1<<(Cobol85ParserTIMER-466))|(1<<(Cobol85ParserTODAYS_DATE-466))|(1<<(Cobol85ParserTODAYS_NAME-466))|(1<<(Cobol85ParserTRUNCATED-466))|(1<<(Cobol85ParserTYPEDEF-466)))) != 0) || (((_la-498)&-(0x1f+1)) == 0 && ((1<<uint((_la-498)))&((1<<(Cobol85ParserUNDERLINE-498))|(1<<(Cobol85ParserVIRTUAL-498))|(1<<(Cobol85ParserWAIT-498))|(1<<(Cobol85ParserYEAR-498))|(1<<(Cobol85ParserYYYYMMDD-498))|(1<<(Cobol85ParserYYYYDDD-498))|(1<<(Cobol85ParserZERO_FILL-498)))) != 0) || _la == Cobol85ParserIDENTIFIER {
		{
			p.SetState(3896)
			p.CloseFile()
		}

		p.SetState(3899)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ICloseFileContext is an interface to support dynamic dispatch.
type ICloseFileContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCloseFileContext differentiates from other interfaces.
	IsCloseFileContext()
}

type CloseFileContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCloseFileContext() *CloseFileContext {
	var p = new(CloseFileContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_closeFile
	return p
}

func (*CloseFileContext) IsCloseFileContext() {}

func NewCloseFileContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CloseFileContext {
	var p = new(CloseFileContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_closeFile

	return p
}

func (s *CloseFileContext) GetParser() antlr.Parser { return s.parser }

func (s *CloseFileContext) FileName() IFileNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *CloseFileContext) CloseReelUnitStatement() ICloseReelUnitStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICloseReelUnitStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICloseReelUnitStatementContext)
}

func (s *CloseFileContext) CloseRelativeStatement() ICloseRelativeStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICloseRelativeStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICloseRelativeStatementContext)
}

func (s *CloseFileContext) ClosePortFileIOStatement() IClosePortFileIOStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClosePortFileIOStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClosePortFileIOStatementContext)
}

func (s *CloseFileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CloseFileContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CloseFileContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCloseFile(s)
	}
}

func (s *CloseFileContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCloseFile(s)
	}
}

func (p *Cobol85Parser) CloseFile() (localctx ICloseFileContext) {
	localctx = NewCloseFileContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 596, Cobol85ParserRULE_closeFile)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3901)
		p.FileName()
	}
	p.SetState(3905)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 519, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3902)
			p.CloseReelUnitStatement()
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 519, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(3903)
			p.CloseRelativeStatement()
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 519, p.GetParserRuleContext()) == 3 {
		{
			p.SetState(3904)
			p.ClosePortFileIOStatement()
		}

	}

	return localctx
}

// ICloseReelUnitStatementContext is an interface to support dynamic dispatch.
type ICloseReelUnitStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCloseReelUnitStatementContext differentiates from other interfaces.
	IsCloseReelUnitStatementContext()
}

type CloseReelUnitStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCloseReelUnitStatementContext() *CloseReelUnitStatementContext {
	var p = new(CloseReelUnitStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_closeReelUnitStatement
	return p
}

func (*CloseReelUnitStatementContext) IsCloseReelUnitStatementContext() {}

func NewCloseReelUnitStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CloseReelUnitStatementContext {
	var p = new(CloseReelUnitStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_closeReelUnitStatement

	return p
}

func (s *CloseReelUnitStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CloseReelUnitStatementContext) REEL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREEL, 0)
}

func (s *CloseReelUnitStatementContext) UNIT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserUNIT, 0)
}

func (s *CloseReelUnitStatementContext) REMOVAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREMOVAL, 0)
}

func (s *CloseReelUnitStatementContext) NO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNO, 0)
}

func (s *CloseReelUnitStatementContext) REWIND() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREWIND, 0)
}

func (s *CloseReelUnitStatementContext) LOCK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLOCK, 0)
}

func (s *CloseReelUnitStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOR, 0)
}

func (s *CloseReelUnitStatementContext) WITH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWITH, 0)
}

func (s *CloseReelUnitStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CloseReelUnitStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CloseReelUnitStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCloseReelUnitStatement(s)
	}
}

func (s *CloseReelUnitStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCloseReelUnitStatement(s)
	}
}

func (p *Cobol85Parser) CloseReelUnitStatement() (localctx ICloseReelUnitStatementContext) {
	localctx = NewCloseReelUnitStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 598, Cobol85ParserRULE_closeReelUnitStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3907)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserREEL || _la == Cobol85ParserUNIT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(3912)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFOR || _la == Cobol85ParserREMOVAL {
		p.SetState(3909)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserFOR {
			{
				p.SetState(3908)
				p.Match(Cobol85ParserFOR)
			}

		}
		{
			p.SetState(3911)
			p.Match(Cobol85ParserREMOVAL)
		}

	}
	p.SetState(3922)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 524, p.GetParserRuleContext()) == 1 {
		p.SetState(3915)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserWITH {
			{
				p.SetState(3914)
				p.Match(Cobol85ParserWITH)
			}

		}
		p.SetState(3920)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case Cobol85ParserNO:
			{
				p.SetState(3917)
				p.Match(Cobol85ParserNO)
			}
			{
				p.SetState(3918)
				p.Match(Cobol85ParserREWIND)
			}

		case Cobol85ParserLOCK:
			{
				p.SetState(3919)
				p.Match(Cobol85ParserLOCK)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	}

	return localctx
}

// ICloseRelativeStatementContext is an interface to support dynamic dispatch.
type ICloseRelativeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCloseRelativeStatementContext differentiates from other interfaces.
	IsCloseRelativeStatementContext()
}

type CloseRelativeStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCloseRelativeStatementContext() *CloseRelativeStatementContext {
	var p = new(CloseRelativeStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_closeRelativeStatement
	return p
}

func (*CloseRelativeStatementContext) IsCloseRelativeStatementContext() {}

func NewCloseRelativeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CloseRelativeStatementContext {
	var p = new(CloseRelativeStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_closeRelativeStatement

	return p
}

func (s *CloseRelativeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CloseRelativeStatementContext) NO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNO, 0)
}

func (s *CloseRelativeStatementContext) REWIND() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREWIND, 0)
}

func (s *CloseRelativeStatementContext) LOCK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLOCK, 0)
}

func (s *CloseRelativeStatementContext) WITH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWITH, 0)
}

func (s *CloseRelativeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CloseRelativeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CloseRelativeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCloseRelativeStatement(s)
	}
}

func (s *CloseRelativeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCloseRelativeStatement(s)
	}
}

func (p *Cobol85Parser) CloseRelativeStatement() (localctx ICloseRelativeStatementContext) {
	localctx = NewCloseRelativeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 600, Cobol85ParserRULE_closeRelativeStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3925)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserWITH {
		{
			p.SetState(3924)
			p.Match(Cobol85ParserWITH)
		}

	}
	p.SetState(3930)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserNO:
		{
			p.SetState(3927)
			p.Match(Cobol85ParserNO)
		}
		{
			p.SetState(3928)
			p.Match(Cobol85ParserREWIND)
		}

	case Cobol85ParserLOCK:
		{
			p.SetState(3929)
			p.Match(Cobol85ParserLOCK)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IClosePortFileIOStatementContext is an interface to support dynamic dispatch.
type IClosePortFileIOStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClosePortFileIOStatementContext differentiates from other interfaces.
	IsClosePortFileIOStatementContext()
}

type ClosePortFileIOStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClosePortFileIOStatementContext() *ClosePortFileIOStatementContext {
	var p = new(ClosePortFileIOStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_closePortFileIOStatement
	return p
}

func (*ClosePortFileIOStatementContext) IsClosePortFileIOStatementContext() {}

func NewClosePortFileIOStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClosePortFileIOStatementContext {
	var p = new(ClosePortFileIOStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_closePortFileIOStatement

	return p
}

func (s *ClosePortFileIOStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ClosePortFileIOStatementContext) NO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNO, 0)
}

func (s *ClosePortFileIOStatementContext) WAIT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWAIT, 0)
}

func (s *ClosePortFileIOStatementContext) WITH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWITH, 0)
}

func (s *ClosePortFileIOStatementContext) USING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserUSING, 0)
}

func (s *ClosePortFileIOStatementContext) AllClosePortFileIOUsing() []IClosePortFileIOUsingContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IClosePortFileIOUsingContext)(nil)).Elem())
	var tst = make([]IClosePortFileIOUsingContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IClosePortFileIOUsingContext)
		}
	}

	return tst
}

func (s *ClosePortFileIOStatementContext) ClosePortFileIOUsing(i int) IClosePortFileIOUsingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClosePortFileIOUsingContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IClosePortFileIOUsingContext)
}

func (s *ClosePortFileIOStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClosePortFileIOStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClosePortFileIOStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterClosePortFileIOStatement(s)
	}
}

func (s *ClosePortFileIOStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitClosePortFileIOStatement(s)
	}
}

func (p *Cobol85Parser) ClosePortFileIOStatement() (localctx IClosePortFileIOStatementContext) {
	localctx = NewClosePortFileIOStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 602, Cobol85ParserRULE_closePortFileIOStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3939)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 528, p.GetParserRuleContext()) {
	case 1:
		p.SetState(3933)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserWITH {
			{
				p.SetState(3932)
				p.Match(Cobol85ParserWITH)
			}

		}
		{
			p.SetState(3935)
			p.Match(Cobol85ParserNO)
		}
		{
			p.SetState(3936)
			p.Match(Cobol85ParserWAIT)
		}

	case 2:
		{
			p.SetState(3937)
			p.Match(Cobol85ParserWITH)
		}
		{
			p.SetState(3938)
			p.Match(Cobol85ParserWAIT)
		}

	}
	p.SetState(3947)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserUSING {
		{
			p.SetState(3941)
			p.Match(Cobol85ParserUSING)
		}
		p.SetState(3943)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(3942)
					p.ClosePortFileIOUsing()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(3945)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 529, p.GetParserRuleContext())
		}

	}

	return localctx
}

// IClosePortFileIOUsingContext is an interface to support dynamic dispatch.
type IClosePortFileIOUsingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClosePortFileIOUsingContext differentiates from other interfaces.
	IsClosePortFileIOUsingContext()
}

type ClosePortFileIOUsingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClosePortFileIOUsingContext() *ClosePortFileIOUsingContext {
	var p = new(ClosePortFileIOUsingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_closePortFileIOUsing
	return p
}

func (*ClosePortFileIOUsingContext) IsClosePortFileIOUsingContext() {}

func NewClosePortFileIOUsingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClosePortFileIOUsingContext {
	var p = new(ClosePortFileIOUsingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_closePortFileIOUsing

	return p
}

func (s *ClosePortFileIOUsingContext) GetParser() antlr.Parser { return s.parser }

func (s *ClosePortFileIOUsingContext) ClosePortFileIOUsingCloseDisposition() IClosePortFileIOUsingCloseDispositionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClosePortFileIOUsingCloseDispositionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClosePortFileIOUsingCloseDispositionContext)
}

func (s *ClosePortFileIOUsingContext) ClosePortFileIOUsingAssociatedData() IClosePortFileIOUsingAssociatedDataContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClosePortFileIOUsingAssociatedDataContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClosePortFileIOUsingAssociatedDataContext)
}

func (s *ClosePortFileIOUsingContext) ClosePortFileIOUsingAssociatedDataLength() IClosePortFileIOUsingAssociatedDataLengthContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClosePortFileIOUsingAssociatedDataLengthContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClosePortFileIOUsingAssociatedDataLengthContext)
}

func (s *ClosePortFileIOUsingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClosePortFileIOUsingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClosePortFileIOUsingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterClosePortFileIOUsing(s)
	}
}

func (s *ClosePortFileIOUsingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitClosePortFileIOUsing(s)
	}
}

func (p *Cobol85Parser) ClosePortFileIOUsing() (localctx IClosePortFileIOUsingContext) {
	localctx = NewClosePortFileIOUsingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 604, Cobol85ParserRULE_closePortFileIOUsing)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3952)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserCLOSE_DISPOSITION:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3949)
			p.ClosePortFileIOUsingCloseDisposition()
		}

	case Cobol85ParserASSOCIATED_DATA:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3950)
			p.ClosePortFileIOUsingAssociatedData()
		}

	case Cobol85ParserASSOCIATED_DATA_LENGTH:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3951)
			p.ClosePortFileIOUsingAssociatedDataLength()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IClosePortFileIOUsingCloseDispositionContext is an interface to support dynamic dispatch.
type IClosePortFileIOUsingCloseDispositionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClosePortFileIOUsingCloseDispositionContext differentiates from other interfaces.
	IsClosePortFileIOUsingCloseDispositionContext()
}

type ClosePortFileIOUsingCloseDispositionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClosePortFileIOUsingCloseDispositionContext() *ClosePortFileIOUsingCloseDispositionContext {
	var p = new(ClosePortFileIOUsingCloseDispositionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_closePortFileIOUsingCloseDisposition
	return p
}

func (*ClosePortFileIOUsingCloseDispositionContext) IsClosePortFileIOUsingCloseDispositionContext() {}

func NewClosePortFileIOUsingCloseDispositionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClosePortFileIOUsingCloseDispositionContext {
	var p = new(ClosePortFileIOUsingCloseDispositionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_closePortFileIOUsingCloseDisposition

	return p
}

func (s *ClosePortFileIOUsingCloseDispositionContext) GetParser() antlr.Parser { return s.parser }

func (s *ClosePortFileIOUsingCloseDispositionContext) CLOSE_DISPOSITION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCLOSE_DISPOSITION, 0)
}

func (s *ClosePortFileIOUsingCloseDispositionContext) ABORT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserABORT, 0)
}

func (s *ClosePortFileIOUsingCloseDispositionContext) ORDERLY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserORDERLY, 0)
}

func (s *ClosePortFileIOUsingCloseDispositionContext) OF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOF, 0)
}

func (s *ClosePortFileIOUsingCloseDispositionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClosePortFileIOUsingCloseDispositionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClosePortFileIOUsingCloseDispositionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterClosePortFileIOUsingCloseDisposition(s)
	}
}

func (s *ClosePortFileIOUsingCloseDispositionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitClosePortFileIOUsingCloseDisposition(s)
	}
}

func (p *Cobol85Parser) ClosePortFileIOUsingCloseDisposition() (localctx IClosePortFileIOUsingCloseDispositionContext) {
	localctx = NewClosePortFileIOUsingCloseDispositionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 606, Cobol85ParserRULE_closePortFileIOUsingCloseDisposition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3954)
		p.Match(Cobol85ParserCLOSE_DISPOSITION)
	}
	p.SetState(3956)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserOF {
		{
			p.SetState(3955)
			p.Match(Cobol85ParserOF)
		}

	}
	{
		p.SetState(3958)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserABORT || _la == Cobol85ParserORDERLY) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IClosePortFileIOUsingAssociatedDataContext is an interface to support dynamic dispatch.
type IClosePortFileIOUsingAssociatedDataContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClosePortFileIOUsingAssociatedDataContext differentiates from other interfaces.
	IsClosePortFileIOUsingAssociatedDataContext()
}

type ClosePortFileIOUsingAssociatedDataContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClosePortFileIOUsingAssociatedDataContext() *ClosePortFileIOUsingAssociatedDataContext {
	var p = new(ClosePortFileIOUsingAssociatedDataContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_closePortFileIOUsingAssociatedData
	return p
}

func (*ClosePortFileIOUsingAssociatedDataContext) IsClosePortFileIOUsingAssociatedDataContext() {}

func NewClosePortFileIOUsingAssociatedDataContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClosePortFileIOUsingAssociatedDataContext {
	var p = new(ClosePortFileIOUsingAssociatedDataContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_closePortFileIOUsingAssociatedData

	return p
}

func (s *ClosePortFileIOUsingAssociatedDataContext) GetParser() antlr.Parser { return s.parser }

func (s *ClosePortFileIOUsingAssociatedDataContext) ASSOCIATED_DATA() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserASSOCIATED_DATA, 0)
}

func (s *ClosePortFileIOUsingAssociatedDataContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ClosePortFileIOUsingAssociatedDataContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ClosePortFileIOUsingAssociatedDataContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClosePortFileIOUsingAssociatedDataContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClosePortFileIOUsingAssociatedDataContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterClosePortFileIOUsingAssociatedData(s)
	}
}

func (s *ClosePortFileIOUsingAssociatedDataContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitClosePortFileIOUsingAssociatedData(s)
	}
}

func (p *Cobol85Parser) ClosePortFileIOUsingAssociatedData() (localctx IClosePortFileIOUsingAssociatedDataContext) {
	localctx = NewClosePortFileIOUsingAssociatedDataContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 608, Cobol85ParserRULE_closePortFileIOUsingAssociatedData)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3960)
		p.Match(Cobol85ParserASSOCIATED_DATA)
	}
	p.SetState(3963)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 533, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(3961)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(3962)
			p.IntegerLiteral()
		}

	}

	return localctx
}

// IClosePortFileIOUsingAssociatedDataLengthContext is an interface to support dynamic dispatch.
type IClosePortFileIOUsingAssociatedDataLengthContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClosePortFileIOUsingAssociatedDataLengthContext differentiates from other interfaces.
	IsClosePortFileIOUsingAssociatedDataLengthContext()
}

type ClosePortFileIOUsingAssociatedDataLengthContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClosePortFileIOUsingAssociatedDataLengthContext() *ClosePortFileIOUsingAssociatedDataLengthContext {
	var p = new(ClosePortFileIOUsingAssociatedDataLengthContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_closePortFileIOUsingAssociatedDataLength
	return p
}

func (*ClosePortFileIOUsingAssociatedDataLengthContext) IsClosePortFileIOUsingAssociatedDataLengthContext() {
}

func NewClosePortFileIOUsingAssociatedDataLengthContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClosePortFileIOUsingAssociatedDataLengthContext {
	var p = new(ClosePortFileIOUsingAssociatedDataLengthContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_closePortFileIOUsingAssociatedDataLength

	return p
}

func (s *ClosePortFileIOUsingAssociatedDataLengthContext) GetParser() antlr.Parser { return s.parser }

func (s *ClosePortFileIOUsingAssociatedDataLengthContext) ASSOCIATED_DATA_LENGTH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserASSOCIATED_DATA_LENGTH, 0)
}

func (s *ClosePortFileIOUsingAssociatedDataLengthContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ClosePortFileIOUsingAssociatedDataLengthContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ClosePortFileIOUsingAssociatedDataLengthContext) OF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOF, 0)
}

func (s *ClosePortFileIOUsingAssociatedDataLengthContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClosePortFileIOUsingAssociatedDataLengthContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClosePortFileIOUsingAssociatedDataLengthContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterClosePortFileIOUsingAssociatedDataLength(s)
	}
}

func (s *ClosePortFileIOUsingAssociatedDataLengthContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitClosePortFileIOUsingAssociatedDataLength(s)
	}
}

func (p *Cobol85Parser) ClosePortFileIOUsingAssociatedDataLength() (localctx IClosePortFileIOUsingAssociatedDataLengthContext) {
	localctx = NewClosePortFileIOUsingAssociatedDataLengthContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 610, Cobol85ParserRULE_closePortFileIOUsingAssociatedDataLength)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3965)
		p.Match(Cobol85ParserASSOCIATED_DATA_LENGTH)
	}
	p.SetState(3967)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserOF {
		{
			p.SetState(3966)
			p.Match(Cobol85ParserOF)
		}

	}
	p.SetState(3971)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 535, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(3969)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(3970)
			p.IntegerLiteral()
		}

	}

	return localctx
}

// IComputeStatementContext is an interface to support dynamic dispatch.
type IComputeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComputeStatementContext differentiates from other interfaces.
	IsComputeStatementContext()
}

type ComputeStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComputeStatementContext() *ComputeStatementContext {
	var p = new(ComputeStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_computeStatement
	return p
}

func (*ComputeStatementContext) IsComputeStatementContext() {}

func NewComputeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComputeStatementContext {
	var p = new(ComputeStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_computeStatement

	return p
}

func (s *ComputeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ComputeStatementContext) COMPUTE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMPUTE, 0)
}

func (s *ComputeStatementContext) ArithmeticExpression() IArithmeticExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArithmeticExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArithmeticExpressionContext)
}

func (s *ComputeStatementContext) EQUALCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEQUALCHAR, 0)
}

func (s *ComputeStatementContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEQUAL, 0)
}

func (s *ComputeStatementContext) AllComputeStore() []IComputeStoreContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IComputeStoreContext)(nil)).Elem())
	var tst = make([]IComputeStoreContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IComputeStoreContext)
		}
	}

	return tst
}

func (s *ComputeStatementContext) ComputeStore(i int) IComputeStoreContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComputeStoreContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IComputeStoreContext)
}

func (s *ComputeStatementContext) OnSizeErrorPhrase() IOnSizeErrorPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOnSizeErrorPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOnSizeErrorPhraseContext)
}

func (s *ComputeStatementContext) NotOnSizeErrorPhrase() INotOnSizeErrorPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INotOnSizeErrorPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INotOnSizeErrorPhraseContext)
}

func (s *ComputeStatementContext) END_COMPUTE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND_COMPUTE, 0)
}

func (s *ComputeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComputeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComputeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterComputeStatement(s)
	}
}

func (s *ComputeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitComputeStatement(s)
	}
}

func (p *Cobol85Parser) ComputeStatement() (localctx IComputeStatementContext) {
	localctx = NewComputeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 612, Cobol85ParserRULE_computeStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3973)
		p.Match(Cobol85ParserCOMPUTE)
	}
	p.SetState(3975)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserADDRESS)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH)|(1<<Cobol85ParserATTRIBUTE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBINARY-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-68))|(1<<(Cobol85ParserCOBOL-68))|(1<<(Cobol85ParserCOMMITMENT-68))|(1<<(Cobol85ParserCONTROL_POINT-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(Cobol85ParserCONVENTION-100))|(1<<(Cobol85ParserCRUNCH-100))|(1<<(Cobol85ParserCURSOR-100))|(1<<(Cobol85ParserDATE-100))|(1<<(Cobol85ParserDAY-100))|(1<<(Cobol85ParserDAY_OF_WEEK-100))|(1<<(Cobol85ParserDEBUG_CONTENTS-100))|(1<<(Cobol85ParserDEBUG_ITEM-100))|(1<<(Cobol85ParserDEBUG_LINE-100))|(1<<(Cobol85ParserDEBUG_NAME-100))|(1<<(Cobol85ParserDEBUG_SUB_1-100))|(1<<(Cobol85ParserDEBUG_SUB_2-100))|(1<<(Cobol85ParserDEBUG_SUB_3-100))|(1<<(Cobol85ParserDEFAULT-100))|(1<<(Cobol85ParserDEFAULT_DISPLAY-100))|(1<<(Cobol85ParserDEFINITION-100)))) != 0) || (((_la-138)&-(0x1f+1)) == 0 && ((1<<uint((_la-138)))&((1<<(Cobol85ParserDFHRESP-138))|(1<<(Cobol85ParserDFHVALUE-138))|(1<<(Cobol85ParserDISK-138))|(1<<(Cobol85ParserDONTCARE-138))|(1<<(Cobol85ParserDOUBLE-138))|(1<<(Cobol85ParserEBCDIC-138))|(1<<(Cobol85ParserEMPTY_CHECK-138)))) != 0) || (((_la-181)&-(0x1f+1)) == 0 && ((1<<uint((_la-181)))&((1<<(Cobol85ParserENTER-181))|(1<<(Cobol85ParserENTRY_PROCEDURE-181))|(1<<(Cobol85ParserERASE-181))|(1<<(Cobol85ParserEOL-181))|(1<<(Cobol85ParserEOS-181))|(1<<(Cobol85ParserESCAPE-181))|(1<<(Cobol85ParserEVENT-181))|(1<<(Cobol85ParserEXCLUSIVE-181))|(1<<(Cobol85ParserEXPORT-181))|(1<<(Cobol85ParserEXTENDED-181)))) != 0) || (((_la-213)&-(0x1f+1)) == 0 && ((1<<uint((_la-213)))&((1<<(Cobol85ParserFOREGROUND_COLOR-213))|(1<<(Cobol85ParserFOREGROUND_COLOUR-213))|(1<<(Cobol85ParserFULL-213))|(1<<(Cobol85ParserFUNCTION-213))|(1<<(Cobol85ParserFUNCTIONNAME-213))|(1<<(Cobol85ParserFUNCTION_POINTER-213))|(1<<(Cobol85ParserGRID-213))|(1<<(Cobol85ParserHIGHLIGHT-213))|(1<<(Cobol85ParserIMPLICIT-213))|(1<<(Cobol85ParserIMPORT-213)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(Cobol85ParserINTEGER-250))|(1<<(Cobol85ParserKEPT-250))|(1<<(Cobol85ParserKEYBOARD-250))|(1<<(Cobol85ParserLANGUAGE-250))|(1<<(Cobol85ParserLB-250))|(1<<(Cobol85ParserLD-250))|(1<<(Cobol85ParserLEFTLINE-250))|(1<<(Cobol85ParserLENGTH-250))|(1<<(Cobol85ParserLENGTH_CHECK-250))|(1<<(Cobol85ParserLIBACCESS-250))|(1<<(Cobol85ParserLIBPARAMETER-250))|(1<<(Cobol85ParserLIBRARY-250))|(1<<(Cobol85ParserLINAGE_COUNTER-250))|(1<<(Cobol85ParserLINE_COUNTER-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(Cobol85ParserLIST-283))|(1<<(Cobol85ParserLOCAL-283))|(1<<(Cobol85ParserLONG_DATE-283))|(1<<(Cobol85ParserLONG_TIME-283))|(1<<(Cobol85ParserLOWER-283))|(1<<(Cobol85ParserLOWLIGHT-283))|(1<<(Cobol85ParserMMDDYYYY-283))|(1<<(Cobol85ParserNAMED-283))|(1<<(Cobol85ParserNATIONAL-283))|(1<<(Cobol85ParserNATIONAL_EDITED-283))|(1<<(Cobol85ParserNETWORK-283))|(1<<(Cobol85ParserNO_ECHO-283)))) != 0) || (((_la-317)&-(0x1f+1)) == 0 && ((1<<uint((_la-317)))&((1<<(Cobol85ParserNUMERIC_DATE-317))|(1<<(Cobol85ParserNUMERIC_TIME-317))|(1<<(Cobol85ParserODT-317))|(1<<(Cobol85ParserORDERLY-317))|(1<<(Cobol85ParserOVERLINE-317))|(1<<(Cobol85ParserOWN-317))|(1<<(Cobol85ParserPAGE_COUNTER-317))|(1<<(Cobol85ParserPASSWORD-317)))) != 0) || (((_la-352)&-(0x1f+1)) == 0 && ((1<<uint((_la-352)))&((1<<(Cobol85ParserPORT-352))|(1<<(Cobol85ParserPRINTER-352))|(1<<(Cobol85ParserPRIVATE-352))|(1<<(Cobol85ParserPROCESS-352))|(1<<(Cobol85ParserPROGRAM-352))|(1<<(Cobol85ParserPROMPT-352))|(1<<(Cobol85ParserREADER-352))|(1<<(Cobol85ParserREMOTE-352))|(1<<(Cobol85ParserREAL-352))|(1<<(Cobol85ParserRECEIVED-352))|(1<<(Cobol85ParserRECURSIVE-352))|(1<<(Cobol85ParserREF-352)))) != 0) || (((_la-391)&-(0x1f+1)) == 0 && ((1<<uint((_la-391)))&((1<<(Cobol85ParserREMOVE-391))|(1<<(Cobol85ParserREQUIRED-391))|(1<<(Cobol85ParserREVERSE_VIDEO-391))|(1<<(Cobol85ParserRETURN_CODE-391))|(1<<(Cobol85ParserSAVE-391))|(1<<(Cobol85ParserSECURE-391)))) != 0) || (((_la-431)&-(0x1f+1)) == 0 && ((1<<uint((_la-431)))&((1<<(Cobol85ParserSHARED-431))|(1<<(Cobol85ParserSHAREDBYALL-431))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-431))|(1<<(Cobol85ParserSHARING-431))|(1<<(Cobol85ParserSHIFT_IN-431))|(1<<(Cobol85ParserSHIFT_OUT-431))|(1<<(Cobol85ParserSHORT_DATE-431))|(1<<(Cobol85ParserSORT_CONTROL-431))|(1<<(Cobol85ParserSORT_CORE_SIZE-431))|(1<<(Cobol85ParserSORT_FILE_SIZE-431))|(1<<(Cobol85ParserSORT_MESSAGE-431))|(1<<(Cobol85ParserSORT_MODE_SIZE-431))|(1<<(Cobol85ParserSORT_RETURN-431)))) != 0) || (((_la-466)&-(0x1f+1)) == 0 && ((1<<uint((_la-466)))&((1<<(Cobol85ParserSYMBOL-466))|(1<<(Cobol85ParserTALLY-466))|(1<<(Cobol85ParserTASK-466))|(1<<(Cobol85ParserTHREAD-466))|(1<<(Cobol85ParserTHREAD_LOCAL-466))|(1<<(Cobol85ParserTIME-466))|(1<<(Cobol85ParserTIMER-466))|(1<<(Cobol85ParserTODAYS_DATE-466))|(1<<(Cobol85ParserTODAYS_NAME-466))|(1<<(Cobol85ParserTRUNCATED-466))|(1<<(Cobol85ParserTYPEDEF-466)))) != 0) || (((_la-498)&-(0x1f+1)) == 0 && ((1<<uint((_la-498)))&((1<<(Cobol85ParserUNDERLINE-498))|(1<<(Cobol85ParserVIRTUAL-498))|(1<<(Cobol85ParserWAIT-498))|(1<<(Cobol85ParserWHEN_COMPILED-498))|(1<<(Cobol85ParserYEAR-498))|(1<<(Cobol85ParserYYYYMMDD-498))|(1<<(Cobol85ParserYYYYDDD-498))|(1<<(Cobol85ParserZERO_FILL-498)))) != 0) || (((_la-552)&-(0x1f+1)) == 0 && ((1<<uint((_la-552)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-552))|(1<<(Cobol85ParserLEVEL_NUMBER_77-552))|(1<<(Cobol85ParserLEVEL_NUMBER_88-552))|(1<<(Cobol85ParserINTEGERLITERAL-552))|(1<<(Cobol85ParserIDENTIFIER-552)))) != 0) {
		{
			p.SetState(3974)
			p.ComputeStore()
		}

		p.SetState(3977)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3979)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserEQUAL || _la == Cobol85ParserEQUALCHAR) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(3980)
		p.ArithmeticExpression()
	}
	p.SetState(3982)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 537, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3981)
			p.OnSizeErrorPhrase()
		}

	}
	p.SetState(3985)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 538, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3984)
			p.NotOnSizeErrorPhrase()
		}

	}
	p.SetState(3988)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 539, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3987)
			p.Match(Cobol85ParserEND_COMPUTE)
		}

	}

	return localctx
}

// IComputeStoreContext is an interface to support dynamic dispatch.
type IComputeStoreContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComputeStoreContext differentiates from other interfaces.
	IsComputeStoreContext()
}

type ComputeStoreContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComputeStoreContext() *ComputeStoreContext {
	var p = new(ComputeStoreContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_computeStore
	return p
}

func (*ComputeStoreContext) IsComputeStoreContext() {}

func NewComputeStoreContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComputeStoreContext {
	var p = new(ComputeStoreContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_computeStore

	return p
}

func (s *ComputeStoreContext) GetParser() antlr.Parser { return s.parser }

func (s *ComputeStoreContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ComputeStoreContext) ROUNDED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserROUNDED, 0)
}

func (s *ComputeStoreContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComputeStoreContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComputeStoreContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterComputeStore(s)
	}
}

func (s *ComputeStoreContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitComputeStore(s)
	}
}

func (p *Cobol85Parser) ComputeStore() (localctx IComputeStoreContext) {
	localctx = NewComputeStoreContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 614, Cobol85ParserRULE_computeStore)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3990)
		p.Identifier()
	}
	p.SetState(3992)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserROUNDED {
		{
			p.SetState(3991)
			p.Match(Cobol85ParserROUNDED)
		}

	}

	return localctx
}

// IContinueStatementContext is an interface to support dynamic dispatch.
type IContinueStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsContinueStatementContext differentiates from other interfaces.
	IsContinueStatementContext()
}

type ContinueStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContinueStatementContext() *ContinueStatementContext {
	var p = new(ContinueStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_continueStatement
	return p
}

func (*ContinueStatementContext) IsContinueStatementContext() {}

func NewContinueStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ContinueStatementContext {
	var p = new(ContinueStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_continueStatement

	return p
}

func (s *ContinueStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ContinueStatementContext) CONTINUE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCONTINUE, 0)
}

func (s *ContinueStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContinueStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ContinueStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterContinueStatement(s)
	}
}

func (s *ContinueStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitContinueStatement(s)
	}
}

func (p *Cobol85Parser) ContinueStatement() (localctx IContinueStatementContext) {
	localctx = NewContinueStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 616, Cobol85ParserRULE_continueStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3994)
		p.Match(Cobol85ParserCONTINUE)
	}

	return localctx
}

// IDeleteStatementContext is an interface to support dynamic dispatch.
type IDeleteStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeleteStatementContext differentiates from other interfaces.
	IsDeleteStatementContext()
}

type DeleteStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeleteStatementContext() *DeleteStatementContext {
	var p = new(DeleteStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_deleteStatement
	return p
}

func (*DeleteStatementContext) IsDeleteStatementContext() {}

func NewDeleteStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeleteStatementContext {
	var p = new(DeleteStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_deleteStatement

	return p
}

func (s *DeleteStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DeleteStatementContext) DELETE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDELETE, 0)
}

func (s *DeleteStatementContext) FileName() IFileNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *DeleteStatementContext) RECORD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRECORD, 0)
}

func (s *DeleteStatementContext) InvalidKeyPhrase() IInvalidKeyPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInvalidKeyPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInvalidKeyPhraseContext)
}

func (s *DeleteStatementContext) NotInvalidKeyPhrase() INotInvalidKeyPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INotInvalidKeyPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INotInvalidKeyPhraseContext)
}

func (s *DeleteStatementContext) END_DELETE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND_DELETE, 0)
}

func (s *DeleteStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeleteStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeleteStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDeleteStatement(s)
	}
}

func (s *DeleteStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDeleteStatement(s)
	}
}

func (p *Cobol85Parser) DeleteStatement() (localctx IDeleteStatementContext) {
	localctx = NewDeleteStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 618, Cobol85ParserRULE_deleteStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3996)
		p.Match(Cobol85ParserDELETE)
	}
	{
		p.SetState(3997)
		p.FileName()
	}
	p.SetState(3999)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserRECORD {
		{
			p.SetState(3998)
			p.Match(Cobol85ParserRECORD)
		}

	}
	p.SetState(4002)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 542, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4001)
			p.InvalidKeyPhrase()
		}

	}
	p.SetState(4005)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 543, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4004)
			p.NotInvalidKeyPhrase()
		}

	}
	p.SetState(4008)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 544, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4007)
			p.Match(Cobol85ParserEND_DELETE)
		}

	}

	return localctx
}

// IDisableStatementContext is an interface to support dynamic dispatch.
type IDisableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDisableStatementContext differentiates from other interfaces.
	IsDisableStatementContext()
}

type DisableStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDisableStatementContext() *DisableStatementContext {
	var p = new(DisableStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_disableStatement
	return p
}

func (*DisableStatementContext) IsDisableStatementContext() {}

func NewDisableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DisableStatementContext {
	var p = new(DisableStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_disableStatement

	return p
}

func (s *DisableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DisableStatementContext) DISABLE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDISABLE, 0)
}

func (s *DisableStatementContext) CdName() ICdNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICdNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICdNameContext)
}

func (s *DisableStatementContext) KEY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserKEY, 0)
}

func (s *DisableStatementContext) INPUT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINPUT, 0)
}

func (s *DisableStatementContext) I_O() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserI_O, 0)
}

func (s *DisableStatementContext) TERMINAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTERMINAL, 0)
}

func (s *DisableStatementContext) OUTPUT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOUTPUT, 0)
}

func (s *DisableStatementContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DisableStatementContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *DisableStatementContext) WITH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWITH, 0)
}

func (s *DisableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DisableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DisableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDisableStatement(s)
	}
}

func (s *DisableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDisableStatement(s)
	}
}

func (p *Cobol85Parser) DisableStatement() (localctx IDisableStatementContext) {
	localctx = NewDisableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 620, Cobol85ParserRULE_disableStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4010)
		p.Match(Cobol85ParserDISABLE)
	}
	p.SetState(4018)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserINPUT:
		{
			p.SetState(4011)
			p.Match(Cobol85ParserINPUT)
		}
		p.SetState(4013)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserTERMINAL {
			{
				p.SetState(4012)
				p.Match(Cobol85ParserTERMINAL)
			}

		}

	case Cobol85ParserI_O:
		{
			p.SetState(4015)
			p.Match(Cobol85ParserI_O)
		}
		{
			p.SetState(4016)
			p.Match(Cobol85ParserTERMINAL)
		}

	case Cobol85ParserOUTPUT:
		{
			p.SetState(4017)
			p.Match(Cobol85ParserOUTPUT)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(4020)
		p.CdName()
	}
	p.SetState(4022)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserWITH {
		{
			p.SetState(4021)
			p.Match(Cobol85ParserWITH)
		}

	}
	{
		p.SetState(4024)
		p.Match(Cobol85ParserKEY)
	}
	p.SetState(4027)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 548, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4025)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(4026)
			p.Literal()
		}

	}

	return localctx
}

// IDisplayStatementContext is an interface to support dynamic dispatch.
type IDisplayStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDisplayStatementContext differentiates from other interfaces.
	IsDisplayStatementContext()
}

type DisplayStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDisplayStatementContext() *DisplayStatementContext {
	var p = new(DisplayStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_displayStatement
	return p
}

func (*DisplayStatementContext) IsDisplayStatementContext() {}

func NewDisplayStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DisplayStatementContext {
	var p = new(DisplayStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_displayStatement

	return p
}

func (s *DisplayStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DisplayStatementContext) DISPLAY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDISPLAY, 0)
}

func (s *DisplayStatementContext) AllDisplayOperand() []IDisplayOperandContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDisplayOperandContext)(nil)).Elem())
	var tst = make([]IDisplayOperandContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDisplayOperandContext)
		}
	}

	return tst
}

func (s *DisplayStatementContext) DisplayOperand(i int) IDisplayOperandContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDisplayOperandContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDisplayOperandContext)
}

func (s *DisplayStatementContext) DisplayAt() IDisplayAtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDisplayAtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDisplayAtContext)
}

func (s *DisplayStatementContext) DisplayUpon() IDisplayUponContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDisplayUponContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDisplayUponContext)
}

func (s *DisplayStatementContext) DisplayWith() IDisplayWithContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDisplayWithContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDisplayWithContext)
}

func (s *DisplayStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DisplayStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DisplayStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDisplayStatement(s)
	}
}

func (s *DisplayStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDisplayStatement(s)
	}
}

func (p *Cobol85Parser) DisplayStatement() (localctx IDisplayStatementContext) {
	localctx = NewDisplayStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 622, Cobol85ParserRULE_displayStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4029)
		p.Match(Cobol85ParserDISPLAY)
	}
	p.SetState(4031)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserADDRESS)|(1<<Cobol85ParserALL)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH)|(1<<Cobol85ParserATTRIBUTE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBINARY-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-68))|(1<<(Cobol85ParserCOBOL-68))|(1<<(Cobol85ParserCOMMITMENT-68))|(1<<(Cobol85ParserCONTROL_POINT-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(Cobol85ParserCONVENTION-100))|(1<<(Cobol85ParserCRUNCH-100))|(1<<(Cobol85ParserCURSOR-100))|(1<<(Cobol85ParserDATE-100))|(1<<(Cobol85ParserDAY-100))|(1<<(Cobol85ParserDAY_OF_WEEK-100))|(1<<(Cobol85ParserDEBUG_CONTENTS-100))|(1<<(Cobol85ParserDEBUG_ITEM-100))|(1<<(Cobol85ParserDEBUG_LINE-100))|(1<<(Cobol85ParserDEBUG_NAME-100))|(1<<(Cobol85ParserDEBUG_SUB_1-100))|(1<<(Cobol85ParserDEBUG_SUB_2-100))|(1<<(Cobol85ParserDEBUG_SUB_3-100))|(1<<(Cobol85ParserDEFAULT-100))|(1<<(Cobol85ParserDEFAULT_DISPLAY-100))|(1<<(Cobol85ParserDEFINITION-100)))) != 0) || (((_la-138)&-(0x1f+1)) == 0 && ((1<<uint((_la-138)))&((1<<(Cobol85ParserDFHRESP-138))|(1<<(Cobol85ParserDFHVALUE-138))|(1<<(Cobol85ParserDISK-138))|(1<<(Cobol85ParserDONTCARE-138))|(1<<(Cobol85ParserDOUBLE-138))|(1<<(Cobol85ParserEBCDIC-138))|(1<<(Cobol85ParserEMPTY_CHECK-138)))) != 0) || (((_la-181)&-(0x1f+1)) == 0 && ((1<<uint((_la-181)))&((1<<(Cobol85ParserENTER-181))|(1<<(Cobol85ParserENTRY_PROCEDURE-181))|(1<<(Cobol85ParserERASE-181))|(1<<(Cobol85ParserEOL-181))|(1<<(Cobol85ParserEOS-181))|(1<<(Cobol85ParserESCAPE-181))|(1<<(Cobol85ParserEVENT-181))|(1<<(Cobol85ParserEXCLUSIVE-181))|(1<<(Cobol85ParserEXPORT-181))|(1<<(Cobol85ParserEXTENDED-181))|(1<<(Cobol85ParserFALSE-181)))) != 0) || (((_la-213)&-(0x1f+1)) == 0 && ((1<<uint((_la-213)))&((1<<(Cobol85ParserFOREGROUND_COLOR-213))|(1<<(Cobol85ParserFOREGROUND_COLOUR-213))|(1<<(Cobol85ParserFULL-213))|(1<<(Cobol85ParserFUNCTION-213))|(1<<(Cobol85ParserFUNCTIONNAME-213))|(1<<(Cobol85ParserFUNCTION_POINTER-213))|(1<<(Cobol85ParserGRID-213))|(1<<(Cobol85ParserHIGHLIGHT-213))|(1<<(Cobol85ParserHIGH_VALUE-213))|(1<<(Cobol85ParserHIGH_VALUES-213))|(1<<(Cobol85ParserIMPLICIT-213))|(1<<(Cobol85ParserIMPORT-213)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(Cobol85ParserINTEGER-250))|(1<<(Cobol85ParserKEPT-250))|(1<<(Cobol85ParserKEYBOARD-250))|(1<<(Cobol85ParserLANGUAGE-250))|(1<<(Cobol85ParserLB-250))|(1<<(Cobol85ParserLD-250))|(1<<(Cobol85ParserLEFTLINE-250))|(1<<(Cobol85ParserLENGTH-250))|(1<<(Cobol85ParserLENGTH_CHECK-250))|(1<<(Cobol85ParserLIBACCESS-250))|(1<<(Cobol85ParserLIBPARAMETER-250))|(1<<(Cobol85ParserLIBRARY-250))|(1<<(Cobol85ParserLINAGE_COUNTER-250))|(1<<(Cobol85ParserLINE_COUNTER-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(Cobol85ParserLIST-283))|(1<<(Cobol85ParserLOCAL-283))|(1<<(Cobol85ParserLONG_DATE-283))|(1<<(Cobol85ParserLONG_TIME-283))|(1<<(Cobol85ParserLOWER-283))|(1<<(Cobol85ParserLOWLIGHT-283))|(1<<(Cobol85ParserLOW_VALUE-283))|(1<<(Cobol85ParserLOW_VALUES-283))|(1<<(Cobol85ParserMMDDYYYY-283))|(1<<(Cobol85ParserNAMED-283))|(1<<(Cobol85ParserNATIONAL-283))|(1<<(Cobol85ParserNATIONAL_EDITED-283))|(1<<(Cobol85ParserNETWORK-283))|(1<<(Cobol85ParserNO_ECHO-283))|(1<<(Cobol85ParserNULL-283))|(1<<(Cobol85ParserNULLS-283)))) != 0) || (((_la-317)&-(0x1f+1)) == 0 && ((1<<uint((_la-317)))&((1<<(Cobol85ParserNUMERIC_DATE-317))|(1<<(Cobol85ParserNUMERIC_TIME-317))|(1<<(Cobol85ParserODT-317))|(1<<(Cobol85ParserORDERLY-317))|(1<<(Cobol85ParserOVERLINE-317))|(1<<(Cobol85ParserOWN-317))|(1<<(Cobol85ParserPAGE_COUNTER-317))|(1<<(Cobol85ParserPASSWORD-317)))) != 0) || (((_la-352)&-(0x1f+1)) == 0 && ((1<<uint((_la-352)))&((1<<(Cobol85ParserPORT-352))|(1<<(Cobol85ParserPRINTER-352))|(1<<(Cobol85ParserPRIVATE-352))|(1<<(Cobol85ParserPROCESS-352))|(1<<(Cobol85ParserPROGRAM-352))|(1<<(Cobol85ParserPROMPT-352))|(1<<(Cobol85ParserQUOTE-352))|(1<<(Cobol85ParserQUOTES-352))|(1<<(Cobol85ParserREADER-352))|(1<<(Cobol85ParserREMOTE-352))|(1<<(Cobol85ParserREAL-352))|(1<<(Cobol85ParserRECEIVED-352))|(1<<(Cobol85ParserRECURSIVE-352))|(1<<(Cobol85ParserREF-352)))) != 0) || (((_la-391)&-(0x1f+1)) == 0 && ((1<<uint((_la-391)))&((1<<(Cobol85ParserREMOVE-391))|(1<<(Cobol85ParserREQUIRED-391))|(1<<(Cobol85ParserREVERSE_VIDEO-391))|(1<<(Cobol85ParserRETURN_CODE-391))|(1<<(Cobol85ParserSAVE-391))|(1<<(Cobol85ParserSECURE-391)))) != 0) || (((_la-431)&-(0x1f+1)) == 0 && ((1<<uint((_la-431)))&((1<<(Cobol85ParserSHARED-431))|(1<<(Cobol85ParserSHAREDBYALL-431))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-431))|(1<<(Cobol85ParserSHARING-431))|(1<<(Cobol85ParserSHIFT_IN-431))|(1<<(Cobol85ParserSHIFT_OUT-431))|(1<<(Cobol85ParserSHORT_DATE-431))|(1<<(Cobol85ParserSORT_CONTROL-431))|(1<<(Cobol85ParserSORT_CORE_SIZE-431))|(1<<(Cobol85ParserSORT_FILE_SIZE-431))|(1<<(Cobol85ParserSORT_MESSAGE-431))|(1<<(Cobol85ParserSORT_MODE_SIZE-431))|(1<<(Cobol85ParserSORT_RETURN-431))|(1<<(Cobol85ParserSPACE-431))|(1<<(Cobol85ParserSPACES-431)))) != 0) || (((_la-466)&-(0x1f+1)) == 0 && ((1<<uint((_la-466)))&((1<<(Cobol85ParserSYMBOL-466))|(1<<(Cobol85ParserTALLY-466))|(1<<(Cobol85ParserTASK-466))|(1<<(Cobol85ParserTHREAD-466))|(1<<(Cobol85ParserTHREAD_LOCAL-466))|(1<<(Cobol85ParserTIME-466))|(1<<(Cobol85ParserTIMER-466))|(1<<(Cobol85ParserTODAYS_DATE-466))|(1<<(Cobol85ParserTODAYS_NAME-466))|(1<<(Cobol85ParserTRUE-466))|(1<<(Cobol85ParserTRUNCATED-466))|(1<<(Cobol85ParserTYPEDEF-466)))) != 0) || (((_la-498)&-(0x1f+1)) == 0 && ((1<<uint((_la-498)))&((1<<(Cobol85ParserUNDERLINE-498))|(1<<(Cobol85ParserVIRTUAL-498))|(1<<(Cobol85ParserWAIT-498))|(1<<(Cobol85ParserWHEN_COMPILED-498))|(1<<(Cobol85ParserYEAR-498))|(1<<(Cobol85ParserYYYYMMDD-498))|(1<<(Cobol85ParserYYYYDDD-498))|(1<<(Cobol85ParserZERO-498))|(1<<(Cobol85ParserZERO_FILL-498))|(1<<(Cobol85ParserZEROS-498))|(1<<(Cobol85ParserZEROES-498)))) != 0) || (((_la-551)&-(0x1f+1)) == 0 && ((1<<uint((_la-551)))&((1<<(Cobol85ParserNONNUMERICLITERAL-551))|(1<<(Cobol85ParserLEVEL_NUMBER_66-551))|(1<<(Cobol85ParserLEVEL_NUMBER_77-551))|(1<<(Cobol85ParserLEVEL_NUMBER_88-551))|(1<<(Cobol85ParserINTEGERLITERAL-551))|(1<<(Cobol85ParserNUMERICLITERAL-551))|(1<<(Cobol85ParserIDENTIFIER-551)))) != 0) {
		{
			p.SetState(4030)
			p.DisplayOperand()
		}

		p.SetState(4033)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(4036)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 550, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4035)
			p.DisplayAt()
		}

	}
	p.SetState(4039)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserUPON {
		{
			p.SetState(4038)
			p.DisplayUpon()
		}

	}
	p.SetState(4042)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 552, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4041)
			p.DisplayWith()
		}

	}

	return localctx
}

// IDisplayOperandContext is an interface to support dynamic dispatch.
type IDisplayOperandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDisplayOperandContext differentiates from other interfaces.
	IsDisplayOperandContext()
}

type DisplayOperandContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDisplayOperandContext() *DisplayOperandContext {
	var p = new(DisplayOperandContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_displayOperand
	return p
}

func (*DisplayOperandContext) IsDisplayOperandContext() {}

func NewDisplayOperandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DisplayOperandContext {
	var p = new(DisplayOperandContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_displayOperand

	return p
}

func (s *DisplayOperandContext) GetParser() antlr.Parser { return s.parser }

func (s *DisplayOperandContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DisplayOperandContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *DisplayOperandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DisplayOperandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DisplayOperandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDisplayOperand(s)
	}
}

func (s *DisplayOperandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDisplayOperand(s)
	}
}

func (p *Cobol85Parser) DisplayOperand() (localctx IDisplayOperandContext) {
	localctx = NewDisplayOperandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 624, Cobol85ParserRULE_displayOperand)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4046)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 553, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4044)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4045)
			p.Literal()
		}

	}

	return localctx
}

// IDisplayAtContext is an interface to support dynamic dispatch.
type IDisplayAtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDisplayAtContext differentiates from other interfaces.
	IsDisplayAtContext()
}

type DisplayAtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDisplayAtContext() *DisplayAtContext {
	var p = new(DisplayAtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_displayAt
	return p
}

func (*DisplayAtContext) IsDisplayAtContext() {}

func NewDisplayAtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DisplayAtContext {
	var p = new(DisplayAtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_displayAt

	return p
}

func (s *DisplayAtContext) GetParser() antlr.Parser { return s.parser }

func (s *DisplayAtContext) AT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAT, 0)
}

func (s *DisplayAtContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DisplayAtContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *DisplayAtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DisplayAtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DisplayAtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDisplayAt(s)
	}
}

func (s *DisplayAtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDisplayAt(s)
	}
}

func (p *Cobol85Parser) DisplayAt() (localctx IDisplayAtContext) {
	localctx = NewDisplayAtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 626, Cobol85ParserRULE_displayAt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4048)
		p.Match(Cobol85ParserAT)
	}
	p.SetState(4051)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 554, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4049)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(4050)
			p.Literal()
		}

	}

	return localctx
}

// IDisplayUponContext is an interface to support dynamic dispatch.
type IDisplayUponContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDisplayUponContext differentiates from other interfaces.
	IsDisplayUponContext()
}

type DisplayUponContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDisplayUponContext() *DisplayUponContext {
	var p = new(DisplayUponContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_displayUpon
	return p
}

func (*DisplayUponContext) IsDisplayUponContext() {}

func NewDisplayUponContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DisplayUponContext {
	var p = new(DisplayUponContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_displayUpon

	return p
}

func (s *DisplayUponContext) GetParser() antlr.Parser { return s.parser }

func (s *DisplayUponContext) UPON() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserUPON, 0)
}

func (s *DisplayUponContext) MnemonicName() IMnemonicNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMnemonicNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMnemonicNameContext)
}

func (s *DisplayUponContext) EnvironmentName() IEnvironmentNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnvironmentNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnvironmentNameContext)
}

func (s *DisplayUponContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DisplayUponContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DisplayUponContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDisplayUpon(s)
	}
}

func (s *DisplayUponContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDisplayUpon(s)
	}
}

func (p *Cobol85Parser) DisplayUpon() (localctx IDisplayUponContext) {
	localctx = NewDisplayUponContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 628, Cobol85ParserRULE_displayUpon)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4053)
		p.Match(Cobol85ParserUPON)
	}
	p.SetState(4056)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 555, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4054)
			p.MnemonicName()
		}

	case 2:
		{
			p.SetState(4055)
			p.EnvironmentName()
		}

	}

	return localctx
}

// IDisplayWithContext is an interface to support dynamic dispatch.
type IDisplayWithContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDisplayWithContext differentiates from other interfaces.
	IsDisplayWithContext()
}

type DisplayWithContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDisplayWithContext() *DisplayWithContext {
	var p = new(DisplayWithContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_displayWith
	return p
}

func (*DisplayWithContext) IsDisplayWithContext() {}

func NewDisplayWithContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DisplayWithContext {
	var p = new(DisplayWithContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_displayWith

	return p
}

func (s *DisplayWithContext) GetParser() antlr.Parser { return s.parser }

func (s *DisplayWithContext) NO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNO, 0)
}

func (s *DisplayWithContext) ADVANCING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserADVANCING, 0)
}

func (s *DisplayWithContext) WITH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWITH, 0)
}

func (s *DisplayWithContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DisplayWithContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DisplayWithContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDisplayWith(s)
	}
}

func (s *DisplayWithContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDisplayWith(s)
	}
}

func (p *Cobol85Parser) DisplayWith() (localctx IDisplayWithContext) {
	localctx = NewDisplayWithContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 630, Cobol85ParserRULE_displayWith)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4059)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserWITH {
		{
			p.SetState(4058)
			p.Match(Cobol85ParserWITH)
		}

	}
	{
		p.SetState(4061)
		p.Match(Cobol85ParserNO)
	}
	{
		p.SetState(4062)
		p.Match(Cobol85ParserADVANCING)
	}

	return localctx
}

// IDivideStatementContext is an interface to support dynamic dispatch.
type IDivideStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDivideStatementContext differentiates from other interfaces.
	IsDivideStatementContext()
}

type DivideStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDivideStatementContext() *DivideStatementContext {
	var p = new(DivideStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_divideStatement
	return p
}

func (*DivideStatementContext) IsDivideStatementContext() {}

func NewDivideStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DivideStatementContext {
	var p = new(DivideStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_divideStatement

	return p
}

func (s *DivideStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DivideStatementContext) DIVIDE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDIVIDE, 0)
}

func (s *DivideStatementContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DivideStatementContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *DivideStatementContext) DivideIntoStatement() IDivideIntoStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDivideIntoStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDivideIntoStatementContext)
}

func (s *DivideStatementContext) DivideIntoGivingStatement() IDivideIntoGivingStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDivideIntoGivingStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDivideIntoGivingStatementContext)
}

func (s *DivideStatementContext) DivideByGivingStatement() IDivideByGivingStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDivideByGivingStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDivideByGivingStatementContext)
}

func (s *DivideStatementContext) DivideRemainder() IDivideRemainderContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDivideRemainderContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDivideRemainderContext)
}

func (s *DivideStatementContext) OnSizeErrorPhrase() IOnSizeErrorPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOnSizeErrorPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOnSizeErrorPhraseContext)
}

func (s *DivideStatementContext) NotOnSizeErrorPhrase() INotOnSizeErrorPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INotOnSizeErrorPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INotOnSizeErrorPhraseContext)
}

func (s *DivideStatementContext) END_DIVIDE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND_DIVIDE, 0)
}

func (s *DivideStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DivideStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DivideStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDivideStatement(s)
	}
}

func (s *DivideStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDivideStatement(s)
	}
}

func (p *Cobol85Parser) DivideStatement() (localctx IDivideStatementContext) {
	localctx = NewDivideStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 632, Cobol85ParserRULE_divideStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4064)
		p.Match(Cobol85ParserDIVIDE)
	}
	p.SetState(4067)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 557, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4065)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(4066)
			p.Literal()
		}

	}
	p.SetState(4072)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 558, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4069)
			p.DivideIntoStatement()
		}

	case 2:
		{
			p.SetState(4070)
			p.DivideIntoGivingStatement()
		}

	case 3:
		{
			p.SetState(4071)
			p.DivideByGivingStatement()
		}

	}
	p.SetState(4075)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserREMAINDER {
		{
			p.SetState(4074)
			p.DivideRemainder()
		}

	}
	p.SetState(4078)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 560, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4077)
			p.OnSizeErrorPhrase()
		}

	}
	p.SetState(4081)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 561, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4080)
			p.NotOnSizeErrorPhrase()
		}

	}
	p.SetState(4084)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 562, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4083)
			p.Match(Cobol85ParserEND_DIVIDE)
		}

	}

	return localctx
}

// IDivideIntoStatementContext is an interface to support dynamic dispatch.
type IDivideIntoStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDivideIntoStatementContext differentiates from other interfaces.
	IsDivideIntoStatementContext()
}

type DivideIntoStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDivideIntoStatementContext() *DivideIntoStatementContext {
	var p = new(DivideIntoStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_divideIntoStatement
	return p
}

func (*DivideIntoStatementContext) IsDivideIntoStatementContext() {}

func NewDivideIntoStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DivideIntoStatementContext {
	var p = new(DivideIntoStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_divideIntoStatement

	return p
}

func (s *DivideIntoStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DivideIntoStatementContext) INTO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINTO, 0)
}

func (s *DivideIntoStatementContext) AllDivideInto() []IDivideIntoContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDivideIntoContext)(nil)).Elem())
	var tst = make([]IDivideIntoContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDivideIntoContext)
		}
	}

	return tst
}

func (s *DivideIntoStatementContext) DivideInto(i int) IDivideIntoContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDivideIntoContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDivideIntoContext)
}

func (s *DivideIntoStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DivideIntoStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DivideIntoStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDivideIntoStatement(s)
	}
}

func (s *DivideIntoStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDivideIntoStatement(s)
	}
}

func (p *Cobol85Parser) DivideIntoStatement() (localctx IDivideIntoStatementContext) {
	localctx = NewDivideIntoStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 634, Cobol85ParserRULE_divideIntoStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4086)
		p.Match(Cobol85ParserINTO)
	}
	p.SetState(4088)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserADDRESS)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH)|(1<<Cobol85ParserATTRIBUTE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBINARY-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-68))|(1<<(Cobol85ParserCOBOL-68))|(1<<(Cobol85ParserCOMMITMENT-68))|(1<<(Cobol85ParserCONTROL_POINT-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(Cobol85ParserCONVENTION-100))|(1<<(Cobol85ParserCRUNCH-100))|(1<<(Cobol85ParserCURSOR-100))|(1<<(Cobol85ParserDATE-100))|(1<<(Cobol85ParserDAY-100))|(1<<(Cobol85ParserDAY_OF_WEEK-100))|(1<<(Cobol85ParserDEBUG_CONTENTS-100))|(1<<(Cobol85ParserDEBUG_ITEM-100))|(1<<(Cobol85ParserDEBUG_LINE-100))|(1<<(Cobol85ParserDEBUG_NAME-100))|(1<<(Cobol85ParserDEBUG_SUB_1-100))|(1<<(Cobol85ParserDEBUG_SUB_2-100))|(1<<(Cobol85ParserDEBUG_SUB_3-100))|(1<<(Cobol85ParserDEFAULT-100))|(1<<(Cobol85ParserDEFAULT_DISPLAY-100))|(1<<(Cobol85ParserDEFINITION-100)))) != 0) || (((_la-138)&-(0x1f+1)) == 0 && ((1<<uint((_la-138)))&((1<<(Cobol85ParserDFHRESP-138))|(1<<(Cobol85ParserDFHVALUE-138))|(1<<(Cobol85ParserDISK-138))|(1<<(Cobol85ParserDONTCARE-138))|(1<<(Cobol85ParserDOUBLE-138))|(1<<(Cobol85ParserEBCDIC-138))|(1<<(Cobol85ParserEMPTY_CHECK-138)))) != 0) || (((_la-181)&-(0x1f+1)) == 0 && ((1<<uint((_la-181)))&((1<<(Cobol85ParserENTER-181))|(1<<(Cobol85ParserENTRY_PROCEDURE-181))|(1<<(Cobol85ParserERASE-181))|(1<<(Cobol85ParserEOL-181))|(1<<(Cobol85ParserEOS-181))|(1<<(Cobol85ParserESCAPE-181))|(1<<(Cobol85ParserEVENT-181))|(1<<(Cobol85ParserEXCLUSIVE-181))|(1<<(Cobol85ParserEXPORT-181))|(1<<(Cobol85ParserEXTENDED-181)))) != 0) || (((_la-213)&-(0x1f+1)) == 0 && ((1<<uint((_la-213)))&((1<<(Cobol85ParserFOREGROUND_COLOR-213))|(1<<(Cobol85ParserFOREGROUND_COLOUR-213))|(1<<(Cobol85ParserFULL-213))|(1<<(Cobol85ParserFUNCTION-213))|(1<<(Cobol85ParserFUNCTIONNAME-213))|(1<<(Cobol85ParserFUNCTION_POINTER-213))|(1<<(Cobol85ParserGRID-213))|(1<<(Cobol85ParserHIGHLIGHT-213))|(1<<(Cobol85ParserIMPLICIT-213))|(1<<(Cobol85ParserIMPORT-213)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(Cobol85ParserINTEGER-250))|(1<<(Cobol85ParserKEPT-250))|(1<<(Cobol85ParserKEYBOARD-250))|(1<<(Cobol85ParserLANGUAGE-250))|(1<<(Cobol85ParserLB-250))|(1<<(Cobol85ParserLD-250))|(1<<(Cobol85ParserLEFTLINE-250))|(1<<(Cobol85ParserLENGTH-250))|(1<<(Cobol85ParserLENGTH_CHECK-250))|(1<<(Cobol85ParserLIBACCESS-250))|(1<<(Cobol85ParserLIBPARAMETER-250))|(1<<(Cobol85ParserLIBRARY-250))|(1<<(Cobol85ParserLINAGE_COUNTER-250))|(1<<(Cobol85ParserLINE_COUNTER-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(Cobol85ParserLIST-283))|(1<<(Cobol85ParserLOCAL-283))|(1<<(Cobol85ParserLONG_DATE-283))|(1<<(Cobol85ParserLONG_TIME-283))|(1<<(Cobol85ParserLOWER-283))|(1<<(Cobol85ParserLOWLIGHT-283))|(1<<(Cobol85ParserMMDDYYYY-283))|(1<<(Cobol85ParserNAMED-283))|(1<<(Cobol85ParserNATIONAL-283))|(1<<(Cobol85ParserNATIONAL_EDITED-283))|(1<<(Cobol85ParserNETWORK-283))|(1<<(Cobol85ParserNO_ECHO-283)))) != 0) || (((_la-317)&-(0x1f+1)) == 0 && ((1<<uint((_la-317)))&((1<<(Cobol85ParserNUMERIC_DATE-317))|(1<<(Cobol85ParserNUMERIC_TIME-317))|(1<<(Cobol85ParserODT-317))|(1<<(Cobol85ParserORDERLY-317))|(1<<(Cobol85ParserOVERLINE-317))|(1<<(Cobol85ParserOWN-317))|(1<<(Cobol85ParserPAGE_COUNTER-317))|(1<<(Cobol85ParserPASSWORD-317)))) != 0) || (((_la-352)&-(0x1f+1)) == 0 && ((1<<uint((_la-352)))&((1<<(Cobol85ParserPORT-352))|(1<<(Cobol85ParserPRINTER-352))|(1<<(Cobol85ParserPRIVATE-352))|(1<<(Cobol85ParserPROCESS-352))|(1<<(Cobol85ParserPROGRAM-352))|(1<<(Cobol85ParserPROMPT-352))|(1<<(Cobol85ParserREADER-352))|(1<<(Cobol85ParserREMOTE-352))|(1<<(Cobol85ParserREAL-352))|(1<<(Cobol85ParserRECEIVED-352))|(1<<(Cobol85ParserRECURSIVE-352))|(1<<(Cobol85ParserREF-352)))) != 0) || (((_la-391)&-(0x1f+1)) == 0 && ((1<<uint((_la-391)))&((1<<(Cobol85ParserREMOVE-391))|(1<<(Cobol85ParserREQUIRED-391))|(1<<(Cobol85ParserREVERSE_VIDEO-391))|(1<<(Cobol85ParserRETURN_CODE-391))|(1<<(Cobol85ParserSAVE-391))|(1<<(Cobol85ParserSECURE-391)))) != 0) || (((_la-431)&-(0x1f+1)) == 0 && ((1<<uint((_la-431)))&((1<<(Cobol85ParserSHARED-431))|(1<<(Cobol85ParserSHAREDBYALL-431))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-431))|(1<<(Cobol85ParserSHARING-431))|(1<<(Cobol85ParserSHIFT_IN-431))|(1<<(Cobol85ParserSHIFT_OUT-431))|(1<<(Cobol85ParserSHORT_DATE-431))|(1<<(Cobol85ParserSORT_CONTROL-431))|(1<<(Cobol85ParserSORT_CORE_SIZE-431))|(1<<(Cobol85ParserSORT_FILE_SIZE-431))|(1<<(Cobol85ParserSORT_MESSAGE-431))|(1<<(Cobol85ParserSORT_MODE_SIZE-431))|(1<<(Cobol85ParserSORT_RETURN-431)))) != 0) || (((_la-466)&-(0x1f+1)) == 0 && ((1<<uint((_la-466)))&((1<<(Cobol85ParserSYMBOL-466))|(1<<(Cobol85ParserTALLY-466))|(1<<(Cobol85ParserTASK-466))|(1<<(Cobol85ParserTHREAD-466))|(1<<(Cobol85ParserTHREAD_LOCAL-466))|(1<<(Cobol85ParserTIME-466))|(1<<(Cobol85ParserTIMER-466))|(1<<(Cobol85ParserTODAYS_DATE-466))|(1<<(Cobol85ParserTODAYS_NAME-466))|(1<<(Cobol85ParserTRUNCATED-466))|(1<<(Cobol85ParserTYPEDEF-466)))) != 0) || (((_la-498)&-(0x1f+1)) == 0 && ((1<<uint((_la-498)))&((1<<(Cobol85ParserUNDERLINE-498))|(1<<(Cobol85ParserVIRTUAL-498))|(1<<(Cobol85ParserWAIT-498))|(1<<(Cobol85ParserWHEN_COMPILED-498))|(1<<(Cobol85ParserYEAR-498))|(1<<(Cobol85ParserYYYYMMDD-498))|(1<<(Cobol85ParserYYYYDDD-498))|(1<<(Cobol85ParserZERO_FILL-498)))) != 0) || (((_la-552)&-(0x1f+1)) == 0 && ((1<<uint((_la-552)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-552))|(1<<(Cobol85ParserLEVEL_NUMBER_77-552))|(1<<(Cobol85ParserLEVEL_NUMBER_88-552))|(1<<(Cobol85ParserINTEGERLITERAL-552))|(1<<(Cobol85ParserIDENTIFIER-552)))) != 0) {
		{
			p.SetState(4087)
			p.DivideInto()
		}

		p.SetState(4090)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IDivideIntoGivingStatementContext is an interface to support dynamic dispatch.
type IDivideIntoGivingStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDivideIntoGivingStatementContext differentiates from other interfaces.
	IsDivideIntoGivingStatementContext()
}

type DivideIntoGivingStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDivideIntoGivingStatementContext() *DivideIntoGivingStatementContext {
	var p = new(DivideIntoGivingStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_divideIntoGivingStatement
	return p
}

func (*DivideIntoGivingStatementContext) IsDivideIntoGivingStatementContext() {}

func NewDivideIntoGivingStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DivideIntoGivingStatementContext {
	var p = new(DivideIntoGivingStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_divideIntoGivingStatement

	return p
}

func (s *DivideIntoGivingStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DivideIntoGivingStatementContext) INTO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINTO, 0)
}

func (s *DivideIntoGivingStatementContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DivideIntoGivingStatementContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *DivideIntoGivingStatementContext) DivideGivingPhrase() IDivideGivingPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDivideGivingPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDivideGivingPhraseContext)
}

func (s *DivideIntoGivingStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DivideIntoGivingStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DivideIntoGivingStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDivideIntoGivingStatement(s)
	}
}

func (s *DivideIntoGivingStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDivideIntoGivingStatement(s)
	}
}

func (p *Cobol85Parser) DivideIntoGivingStatement() (localctx IDivideIntoGivingStatementContext) {
	localctx = NewDivideIntoGivingStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 636, Cobol85ParserRULE_divideIntoGivingStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4092)
		p.Match(Cobol85ParserINTO)
	}
	p.SetState(4095)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 564, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4093)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(4094)
			p.Literal()
		}

	}
	p.SetState(4098)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserGIVING {
		{
			p.SetState(4097)
			p.DivideGivingPhrase()
		}

	}

	return localctx
}

// IDivideByGivingStatementContext is an interface to support dynamic dispatch.
type IDivideByGivingStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDivideByGivingStatementContext differentiates from other interfaces.
	IsDivideByGivingStatementContext()
}

type DivideByGivingStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDivideByGivingStatementContext() *DivideByGivingStatementContext {
	var p = new(DivideByGivingStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_divideByGivingStatement
	return p
}

func (*DivideByGivingStatementContext) IsDivideByGivingStatementContext() {}

func NewDivideByGivingStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DivideByGivingStatementContext {
	var p = new(DivideByGivingStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_divideByGivingStatement

	return p
}

func (s *DivideByGivingStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DivideByGivingStatementContext) BY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBY, 0)
}

func (s *DivideByGivingStatementContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DivideByGivingStatementContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *DivideByGivingStatementContext) DivideGivingPhrase() IDivideGivingPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDivideGivingPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDivideGivingPhraseContext)
}

func (s *DivideByGivingStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DivideByGivingStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DivideByGivingStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDivideByGivingStatement(s)
	}
}

func (s *DivideByGivingStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDivideByGivingStatement(s)
	}
}

func (p *Cobol85Parser) DivideByGivingStatement() (localctx IDivideByGivingStatementContext) {
	localctx = NewDivideByGivingStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 638, Cobol85ParserRULE_divideByGivingStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4100)
		p.Match(Cobol85ParserBY)
	}
	p.SetState(4103)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 566, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4101)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(4102)
			p.Literal()
		}

	}
	p.SetState(4106)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserGIVING {
		{
			p.SetState(4105)
			p.DivideGivingPhrase()
		}

	}

	return localctx
}

// IDivideGivingPhraseContext is an interface to support dynamic dispatch.
type IDivideGivingPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDivideGivingPhraseContext differentiates from other interfaces.
	IsDivideGivingPhraseContext()
}

type DivideGivingPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDivideGivingPhraseContext() *DivideGivingPhraseContext {
	var p = new(DivideGivingPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_divideGivingPhrase
	return p
}

func (*DivideGivingPhraseContext) IsDivideGivingPhraseContext() {}

func NewDivideGivingPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DivideGivingPhraseContext {
	var p = new(DivideGivingPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_divideGivingPhrase

	return p
}

func (s *DivideGivingPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *DivideGivingPhraseContext) GIVING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserGIVING, 0)
}

func (s *DivideGivingPhraseContext) AllDivideGiving() []IDivideGivingContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDivideGivingContext)(nil)).Elem())
	var tst = make([]IDivideGivingContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDivideGivingContext)
		}
	}

	return tst
}

func (s *DivideGivingPhraseContext) DivideGiving(i int) IDivideGivingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDivideGivingContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDivideGivingContext)
}

func (s *DivideGivingPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DivideGivingPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DivideGivingPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDivideGivingPhrase(s)
	}
}

func (s *DivideGivingPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDivideGivingPhrase(s)
	}
}

func (p *Cobol85Parser) DivideGivingPhrase() (localctx IDivideGivingPhraseContext) {
	localctx = NewDivideGivingPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 640, Cobol85ParserRULE_divideGivingPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4108)
		p.Match(Cobol85ParserGIVING)
	}
	p.SetState(4110)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserADDRESS)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH)|(1<<Cobol85ParserATTRIBUTE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBINARY-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-68))|(1<<(Cobol85ParserCOBOL-68))|(1<<(Cobol85ParserCOMMITMENT-68))|(1<<(Cobol85ParserCONTROL_POINT-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(Cobol85ParserCONVENTION-100))|(1<<(Cobol85ParserCRUNCH-100))|(1<<(Cobol85ParserCURSOR-100))|(1<<(Cobol85ParserDATE-100))|(1<<(Cobol85ParserDAY-100))|(1<<(Cobol85ParserDAY_OF_WEEK-100))|(1<<(Cobol85ParserDEBUG_CONTENTS-100))|(1<<(Cobol85ParserDEBUG_ITEM-100))|(1<<(Cobol85ParserDEBUG_LINE-100))|(1<<(Cobol85ParserDEBUG_NAME-100))|(1<<(Cobol85ParserDEBUG_SUB_1-100))|(1<<(Cobol85ParserDEBUG_SUB_2-100))|(1<<(Cobol85ParserDEBUG_SUB_3-100))|(1<<(Cobol85ParserDEFAULT-100))|(1<<(Cobol85ParserDEFAULT_DISPLAY-100))|(1<<(Cobol85ParserDEFINITION-100)))) != 0) || (((_la-138)&-(0x1f+1)) == 0 && ((1<<uint((_la-138)))&((1<<(Cobol85ParserDFHRESP-138))|(1<<(Cobol85ParserDFHVALUE-138))|(1<<(Cobol85ParserDISK-138))|(1<<(Cobol85ParserDONTCARE-138))|(1<<(Cobol85ParserDOUBLE-138))|(1<<(Cobol85ParserEBCDIC-138))|(1<<(Cobol85ParserEMPTY_CHECK-138)))) != 0) || (((_la-181)&-(0x1f+1)) == 0 && ((1<<uint((_la-181)))&((1<<(Cobol85ParserENTER-181))|(1<<(Cobol85ParserENTRY_PROCEDURE-181))|(1<<(Cobol85ParserERASE-181))|(1<<(Cobol85ParserEOL-181))|(1<<(Cobol85ParserEOS-181))|(1<<(Cobol85ParserESCAPE-181))|(1<<(Cobol85ParserEVENT-181))|(1<<(Cobol85ParserEXCLUSIVE-181))|(1<<(Cobol85ParserEXPORT-181))|(1<<(Cobol85ParserEXTENDED-181)))) != 0) || (((_la-213)&-(0x1f+1)) == 0 && ((1<<uint((_la-213)))&((1<<(Cobol85ParserFOREGROUND_COLOR-213))|(1<<(Cobol85ParserFOREGROUND_COLOUR-213))|(1<<(Cobol85ParserFULL-213))|(1<<(Cobol85ParserFUNCTION-213))|(1<<(Cobol85ParserFUNCTIONNAME-213))|(1<<(Cobol85ParserFUNCTION_POINTER-213))|(1<<(Cobol85ParserGRID-213))|(1<<(Cobol85ParserHIGHLIGHT-213))|(1<<(Cobol85ParserIMPLICIT-213))|(1<<(Cobol85ParserIMPORT-213)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(Cobol85ParserINTEGER-250))|(1<<(Cobol85ParserKEPT-250))|(1<<(Cobol85ParserKEYBOARD-250))|(1<<(Cobol85ParserLANGUAGE-250))|(1<<(Cobol85ParserLB-250))|(1<<(Cobol85ParserLD-250))|(1<<(Cobol85ParserLEFTLINE-250))|(1<<(Cobol85ParserLENGTH-250))|(1<<(Cobol85ParserLENGTH_CHECK-250))|(1<<(Cobol85ParserLIBACCESS-250))|(1<<(Cobol85ParserLIBPARAMETER-250))|(1<<(Cobol85ParserLIBRARY-250))|(1<<(Cobol85ParserLINAGE_COUNTER-250))|(1<<(Cobol85ParserLINE_COUNTER-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(Cobol85ParserLIST-283))|(1<<(Cobol85ParserLOCAL-283))|(1<<(Cobol85ParserLONG_DATE-283))|(1<<(Cobol85ParserLONG_TIME-283))|(1<<(Cobol85ParserLOWER-283))|(1<<(Cobol85ParserLOWLIGHT-283))|(1<<(Cobol85ParserMMDDYYYY-283))|(1<<(Cobol85ParserNAMED-283))|(1<<(Cobol85ParserNATIONAL-283))|(1<<(Cobol85ParserNATIONAL_EDITED-283))|(1<<(Cobol85ParserNETWORK-283))|(1<<(Cobol85ParserNO_ECHO-283)))) != 0) || (((_la-317)&-(0x1f+1)) == 0 && ((1<<uint((_la-317)))&((1<<(Cobol85ParserNUMERIC_DATE-317))|(1<<(Cobol85ParserNUMERIC_TIME-317))|(1<<(Cobol85ParserODT-317))|(1<<(Cobol85ParserORDERLY-317))|(1<<(Cobol85ParserOVERLINE-317))|(1<<(Cobol85ParserOWN-317))|(1<<(Cobol85ParserPAGE_COUNTER-317))|(1<<(Cobol85ParserPASSWORD-317)))) != 0) || (((_la-352)&-(0x1f+1)) == 0 && ((1<<uint((_la-352)))&((1<<(Cobol85ParserPORT-352))|(1<<(Cobol85ParserPRINTER-352))|(1<<(Cobol85ParserPRIVATE-352))|(1<<(Cobol85ParserPROCESS-352))|(1<<(Cobol85ParserPROGRAM-352))|(1<<(Cobol85ParserPROMPT-352))|(1<<(Cobol85ParserREADER-352))|(1<<(Cobol85ParserREMOTE-352))|(1<<(Cobol85ParserREAL-352))|(1<<(Cobol85ParserRECEIVED-352))|(1<<(Cobol85ParserRECURSIVE-352))|(1<<(Cobol85ParserREF-352)))) != 0) || (((_la-391)&-(0x1f+1)) == 0 && ((1<<uint((_la-391)))&((1<<(Cobol85ParserREMOVE-391))|(1<<(Cobol85ParserREQUIRED-391))|(1<<(Cobol85ParserREVERSE_VIDEO-391))|(1<<(Cobol85ParserRETURN_CODE-391))|(1<<(Cobol85ParserSAVE-391))|(1<<(Cobol85ParserSECURE-391)))) != 0) || (((_la-431)&-(0x1f+1)) == 0 && ((1<<uint((_la-431)))&((1<<(Cobol85ParserSHARED-431))|(1<<(Cobol85ParserSHAREDBYALL-431))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-431))|(1<<(Cobol85ParserSHARING-431))|(1<<(Cobol85ParserSHIFT_IN-431))|(1<<(Cobol85ParserSHIFT_OUT-431))|(1<<(Cobol85ParserSHORT_DATE-431))|(1<<(Cobol85ParserSORT_CONTROL-431))|(1<<(Cobol85ParserSORT_CORE_SIZE-431))|(1<<(Cobol85ParserSORT_FILE_SIZE-431))|(1<<(Cobol85ParserSORT_MESSAGE-431))|(1<<(Cobol85ParserSORT_MODE_SIZE-431))|(1<<(Cobol85ParserSORT_RETURN-431)))) != 0) || (((_la-466)&-(0x1f+1)) == 0 && ((1<<uint((_la-466)))&((1<<(Cobol85ParserSYMBOL-466))|(1<<(Cobol85ParserTALLY-466))|(1<<(Cobol85ParserTASK-466))|(1<<(Cobol85ParserTHREAD-466))|(1<<(Cobol85ParserTHREAD_LOCAL-466))|(1<<(Cobol85ParserTIME-466))|(1<<(Cobol85ParserTIMER-466))|(1<<(Cobol85ParserTODAYS_DATE-466))|(1<<(Cobol85ParserTODAYS_NAME-466))|(1<<(Cobol85ParserTRUNCATED-466))|(1<<(Cobol85ParserTYPEDEF-466)))) != 0) || (((_la-498)&-(0x1f+1)) == 0 && ((1<<uint((_la-498)))&((1<<(Cobol85ParserUNDERLINE-498))|(1<<(Cobol85ParserVIRTUAL-498))|(1<<(Cobol85ParserWAIT-498))|(1<<(Cobol85ParserWHEN_COMPILED-498))|(1<<(Cobol85ParserYEAR-498))|(1<<(Cobol85ParserYYYYMMDD-498))|(1<<(Cobol85ParserYYYYDDD-498))|(1<<(Cobol85ParserZERO_FILL-498)))) != 0) || (((_la-552)&-(0x1f+1)) == 0 && ((1<<uint((_la-552)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-552))|(1<<(Cobol85ParserLEVEL_NUMBER_77-552))|(1<<(Cobol85ParserLEVEL_NUMBER_88-552))|(1<<(Cobol85ParserINTEGERLITERAL-552))|(1<<(Cobol85ParserIDENTIFIER-552)))) != 0) {
		{
			p.SetState(4109)
			p.DivideGiving()
		}

		p.SetState(4112)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IDivideIntoContext is an interface to support dynamic dispatch.
type IDivideIntoContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDivideIntoContext differentiates from other interfaces.
	IsDivideIntoContext()
}

type DivideIntoContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDivideIntoContext() *DivideIntoContext {
	var p = new(DivideIntoContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_divideInto
	return p
}

func (*DivideIntoContext) IsDivideIntoContext() {}

func NewDivideIntoContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DivideIntoContext {
	var p = new(DivideIntoContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_divideInto

	return p
}

func (s *DivideIntoContext) GetParser() antlr.Parser { return s.parser }

func (s *DivideIntoContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DivideIntoContext) ROUNDED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserROUNDED, 0)
}

func (s *DivideIntoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DivideIntoContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DivideIntoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDivideInto(s)
	}
}

func (s *DivideIntoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDivideInto(s)
	}
}

func (p *Cobol85Parser) DivideInto() (localctx IDivideIntoContext) {
	localctx = NewDivideIntoContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 642, Cobol85ParserRULE_divideInto)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4114)
		p.Identifier()
	}
	p.SetState(4116)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserROUNDED {
		{
			p.SetState(4115)
			p.Match(Cobol85ParserROUNDED)
		}

	}

	return localctx
}

// IDivideGivingContext is an interface to support dynamic dispatch.
type IDivideGivingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDivideGivingContext differentiates from other interfaces.
	IsDivideGivingContext()
}

type DivideGivingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDivideGivingContext() *DivideGivingContext {
	var p = new(DivideGivingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_divideGiving
	return p
}

func (*DivideGivingContext) IsDivideGivingContext() {}

func NewDivideGivingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DivideGivingContext {
	var p = new(DivideGivingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_divideGiving

	return p
}

func (s *DivideGivingContext) GetParser() antlr.Parser { return s.parser }

func (s *DivideGivingContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DivideGivingContext) ROUNDED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserROUNDED, 0)
}

func (s *DivideGivingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DivideGivingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DivideGivingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDivideGiving(s)
	}
}

func (s *DivideGivingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDivideGiving(s)
	}
}

func (p *Cobol85Parser) DivideGiving() (localctx IDivideGivingContext) {
	localctx = NewDivideGivingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 644, Cobol85ParserRULE_divideGiving)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4118)
		p.Identifier()
	}
	p.SetState(4120)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserROUNDED {
		{
			p.SetState(4119)
			p.Match(Cobol85ParserROUNDED)
		}

	}

	return localctx
}

// IDivideRemainderContext is an interface to support dynamic dispatch.
type IDivideRemainderContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDivideRemainderContext differentiates from other interfaces.
	IsDivideRemainderContext()
}

type DivideRemainderContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDivideRemainderContext() *DivideRemainderContext {
	var p = new(DivideRemainderContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_divideRemainder
	return p
}

func (*DivideRemainderContext) IsDivideRemainderContext() {}

func NewDivideRemainderContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DivideRemainderContext {
	var p = new(DivideRemainderContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_divideRemainder

	return p
}

func (s *DivideRemainderContext) GetParser() antlr.Parser { return s.parser }

func (s *DivideRemainderContext) REMAINDER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREMAINDER, 0)
}

func (s *DivideRemainderContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DivideRemainderContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DivideRemainderContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DivideRemainderContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDivideRemainder(s)
	}
}

func (s *DivideRemainderContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDivideRemainder(s)
	}
}

func (p *Cobol85Parser) DivideRemainder() (localctx IDivideRemainderContext) {
	localctx = NewDivideRemainderContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 646, Cobol85ParserRULE_divideRemainder)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4122)
		p.Match(Cobol85ParserREMAINDER)
	}
	{
		p.SetState(4123)
		p.Identifier()
	}

	return localctx
}

// IEnableStatementContext is an interface to support dynamic dispatch.
type IEnableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnableStatementContext differentiates from other interfaces.
	IsEnableStatementContext()
}

type EnableStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnableStatementContext() *EnableStatementContext {
	var p = new(EnableStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_enableStatement
	return p
}

func (*EnableStatementContext) IsEnableStatementContext() {}

func NewEnableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnableStatementContext {
	var p = new(EnableStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_enableStatement

	return p
}

func (s *EnableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *EnableStatementContext) ENABLE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserENABLE, 0)
}

func (s *EnableStatementContext) CdName() ICdNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICdNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICdNameContext)
}

func (s *EnableStatementContext) KEY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserKEY, 0)
}

func (s *EnableStatementContext) INPUT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINPUT, 0)
}

func (s *EnableStatementContext) I_O() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserI_O, 0)
}

func (s *EnableStatementContext) TERMINAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTERMINAL, 0)
}

func (s *EnableStatementContext) OUTPUT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOUTPUT, 0)
}

func (s *EnableStatementContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *EnableStatementContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *EnableStatementContext) WITH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWITH, 0)
}

func (s *EnableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterEnableStatement(s)
	}
}

func (s *EnableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitEnableStatement(s)
	}
}

func (p *Cobol85Parser) EnableStatement() (localctx IEnableStatementContext) {
	localctx = NewEnableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 648, Cobol85ParserRULE_enableStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4125)
		p.Match(Cobol85ParserENABLE)
	}
	p.SetState(4133)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserINPUT:
		{
			p.SetState(4126)
			p.Match(Cobol85ParserINPUT)
		}
		p.SetState(4128)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserTERMINAL {
			{
				p.SetState(4127)
				p.Match(Cobol85ParserTERMINAL)
			}

		}

	case Cobol85ParserI_O:
		{
			p.SetState(4130)
			p.Match(Cobol85ParserI_O)
		}
		{
			p.SetState(4131)
			p.Match(Cobol85ParserTERMINAL)
		}

	case Cobol85ParserOUTPUT:
		{
			p.SetState(4132)
			p.Match(Cobol85ParserOUTPUT)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(4135)
		p.CdName()
	}
	p.SetState(4137)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserWITH {
		{
			p.SetState(4136)
			p.Match(Cobol85ParserWITH)
		}

	}
	{
		p.SetState(4139)
		p.Match(Cobol85ParserKEY)
	}
	p.SetState(4142)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 574, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4140)
			p.Literal()
		}

	case 2:
		{
			p.SetState(4141)
			p.Identifier()
		}

	}

	return localctx
}

// IEntryStatementContext is an interface to support dynamic dispatch.
type IEntryStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEntryStatementContext differentiates from other interfaces.
	IsEntryStatementContext()
}

type EntryStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEntryStatementContext() *EntryStatementContext {
	var p = new(EntryStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_entryStatement
	return p
}

func (*EntryStatementContext) IsEntryStatementContext() {}

func NewEntryStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EntryStatementContext {
	var p = new(EntryStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_entryStatement

	return p
}

func (s *EntryStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *EntryStatementContext) ENTRY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserENTRY, 0)
}

func (s *EntryStatementContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *EntryStatementContext) USING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserUSING, 0)
}

func (s *EntryStatementContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *EntryStatementContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *EntryStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EntryStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EntryStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterEntryStatement(s)
	}
}

func (s *EntryStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitEntryStatement(s)
	}
}

func (p *Cobol85Parser) EntryStatement() (localctx IEntryStatementContext) {
	localctx = NewEntryStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 650, Cobol85ParserRULE_entryStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4144)
		p.Match(Cobol85ParserENTRY)
	}
	{
		p.SetState(4145)
		p.Literal()
	}
	p.SetState(4152)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserUSING {
		{
			p.SetState(4146)
			p.Match(Cobol85ParserUSING)
		}
		p.SetState(4148)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserADDRESS)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH)|(1<<Cobol85ParserATTRIBUTE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBINARY-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-68))|(1<<(Cobol85ParserCOBOL-68))|(1<<(Cobol85ParserCOMMITMENT-68))|(1<<(Cobol85ParserCONTROL_POINT-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(Cobol85ParserCONVENTION-100))|(1<<(Cobol85ParserCRUNCH-100))|(1<<(Cobol85ParserCURSOR-100))|(1<<(Cobol85ParserDATE-100))|(1<<(Cobol85ParserDAY-100))|(1<<(Cobol85ParserDAY_OF_WEEK-100))|(1<<(Cobol85ParserDEBUG_CONTENTS-100))|(1<<(Cobol85ParserDEBUG_ITEM-100))|(1<<(Cobol85ParserDEBUG_LINE-100))|(1<<(Cobol85ParserDEBUG_NAME-100))|(1<<(Cobol85ParserDEBUG_SUB_1-100))|(1<<(Cobol85ParserDEBUG_SUB_2-100))|(1<<(Cobol85ParserDEBUG_SUB_3-100))|(1<<(Cobol85ParserDEFAULT-100))|(1<<(Cobol85ParserDEFAULT_DISPLAY-100))|(1<<(Cobol85ParserDEFINITION-100)))) != 0) || (((_la-138)&-(0x1f+1)) == 0 && ((1<<uint((_la-138)))&((1<<(Cobol85ParserDFHRESP-138))|(1<<(Cobol85ParserDFHVALUE-138))|(1<<(Cobol85ParserDISK-138))|(1<<(Cobol85ParserDONTCARE-138))|(1<<(Cobol85ParserDOUBLE-138))|(1<<(Cobol85ParserEBCDIC-138))|(1<<(Cobol85ParserEMPTY_CHECK-138)))) != 0) || (((_la-181)&-(0x1f+1)) == 0 && ((1<<uint((_la-181)))&((1<<(Cobol85ParserENTER-181))|(1<<(Cobol85ParserENTRY_PROCEDURE-181))|(1<<(Cobol85ParserERASE-181))|(1<<(Cobol85ParserEOL-181))|(1<<(Cobol85ParserEOS-181))|(1<<(Cobol85ParserESCAPE-181))|(1<<(Cobol85ParserEVENT-181))|(1<<(Cobol85ParserEXCLUSIVE-181))|(1<<(Cobol85ParserEXPORT-181))|(1<<(Cobol85ParserEXTENDED-181)))) != 0) || (((_la-213)&-(0x1f+1)) == 0 && ((1<<uint((_la-213)))&((1<<(Cobol85ParserFOREGROUND_COLOR-213))|(1<<(Cobol85ParserFOREGROUND_COLOUR-213))|(1<<(Cobol85ParserFULL-213))|(1<<(Cobol85ParserFUNCTION-213))|(1<<(Cobol85ParserFUNCTIONNAME-213))|(1<<(Cobol85ParserFUNCTION_POINTER-213))|(1<<(Cobol85ParserGRID-213))|(1<<(Cobol85ParserHIGHLIGHT-213))|(1<<(Cobol85ParserIMPLICIT-213))|(1<<(Cobol85ParserIMPORT-213)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(Cobol85ParserINTEGER-250))|(1<<(Cobol85ParserKEPT-250))|(1<<(Cobol85ParserKEYBOARD-250))|(1<<(Cobol85ParserLANGUAGE-250))|(1<<(Cobol85ParserLB-250))|(1<<(Cobol85ParserLD-250))|(1<<(Cobol85ParserLEFTLINE-250))|(1<<(Cobol85ParserLENGTH-250))|(1<<(Cobol85ParserLENGTH_CHECK-250))|(1<<(Cobol85ParserLIBACCESS-250))|(1<<(Cobol85ParserLIBPARAMETER-250))|(1<<(Cobol85ParserLIBRARY-250))|(1<<(Cobol85ParserLINAGE_COUNTER-250))|(1<<(Cobol85ParserLINE_COUNTER-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(Cobol85ParserLIST-283))|(1<<(Cobol85ParserLOCAL-283))|(1<<(Cobol85ParserLONG_DATE-283))|(1<<(Cobol85ParserLONG_TIME-283))|(1<<(Cobol85ParserLOWER-283))|(1<<(Cobol85ParserLOWLIGHT-283))|(1<<(Cobol85ParserMMDDYYYY-283))|(1<<(Cobol85ParserNAMED-283))|(1<<(Cobol85ParserNATIONAL-283))|(1<<(Cobol85ParserNATIONAL_EDITED-283))|(1<<(Cobol85ParserNETWORK-283))|(1<<(Cobol85ParserNO_ECHO-283)))) != 0) || (((_la-317)&-(0x1f+1)) == 0 && ((1<<uint((_la-317)))&((1<<(Cobol85ParserNUMERIC_DATE-317))|(1<<(Cobol85ParserNUMERIC_TIME-317))|(1<<(Cobol85ParserODT-317))|(1<<(Cobol85ParserORDERLY-317))|(1<<(Cobol85ParserOVERLINE-317))|(1<<(Cobol85ParserOWN-317))|(1<<(Cobol85ParserPAGE_COUNTER-317))|(1<<(Cobol85ParserPASSWORD-317)))) != 0) || (((_la-352)&-(0x1f+1)) == 0 && ((1<<uint((_la-352)))&((1<<(Cobol85ParserPORT-352))|(1<<(Cobol85ParserPRINTER-352))|(1<<(Cobol85ParserPRIVATE-352))|(1<<(Cobol85ParserPROCESS-352))|(1<<(Cobol85ParserPROGRAM-352))|(1<<(Cobol85ParserPROMPT-352))|(1<<(Cobol85ParserREADER-352))|(1<<(Cobol85ParserREMOTE-352))|(1<<(Cobol85ParserREAL-352))|(1<<(Cobol85ParserRECEIVED-352))|(1<<(Cobol85ParserRECURSIVE-352))|(1<<(Cobol85ParserREF-352)))) != 0) || (((_la-391)&-(0x1f+1)) == 0 && ((1<<uint((_la-391)))&((1<<(Cobol85ParserREMOVE-391))|(1<<(Cobol85ParserREQUIRED-391))|(1<<(Cobol85ParserREVERSE_VIDEO-391))|(1<<(Cobol85ParserRETURN_CODE-391))|(1<<(Cobol85ParserSAVE-391))|(1<<(Cobol85ParserSECURE-391)))) != 0) || (((_la-431)&-(0x1f+1)) == 0 && ((1<<uint((_la-431)))&((1<<(Cobol85ParserSHARED-431))|(1<<(Cobol85ParserSHAREDBYALL-431))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-431))|(1<<(Cobol85ParserSHARING-431))|(1<<(Cobol85ParserSHIFT_IN-431))|(1<<(Cobol85ParserSHIFT_OUT-431))|(1<<(Cobol85ParserSHORT_DATE-431))|(1<<(Cobol85ParserSORT_CONTROL-431))|(1<<(Cobol85ParserSORT_CORE_SIZE-431))|(1<<(Cobol85ParserSORT_FILE_SIZE-431))|(1<<(Cobol85ParserSORT_MESSAGE-431))|(1<<(Cobol85ParserSORT_MODE_SIZE-431))|(1<<(Cobol85ParserSORT_RETURN-431)))) != 0) || (((_la-466)&-(0x1f+1)) == 0 && ((1<<uint((_la-466)))&((1<<(Cobol85ParserSYMBOL-466))|(1<<(Cobol85ParserTALLY-466))|(1<<(Cobol85ParserTASK-466))|(1<<(Cobol85ParserTHREAD-466))|(1<<(Cobol85ParserTHREAD_LOCAL-466))|(1<<(Cobol85ParserTIME-466))|(1<<(Cobol85ParserTIMER-466))|(1<<(Cobol85ParserTODAYS_DATE-466))|(1<<(Cobol85ParserTODAYS_NAME-466))|(1<<(Cobol85ParserTRUNCATED-466))|(1<<(Cobol85ParserTYPEDEF-466)))) != 0) || (((_la-498)&-(0x1f+1)) == 0 && ((1<<uint((_la-498)))&((1<<(Cobol85ParserUNDERLINE-498))|(1<<(Cobol85ParserVIRTUAL-498))|(1<<(Cobol85ParserWAIT-498))|(1<<(Cobol85ParserWHEN_COMPILED-498))|(1<<(Cobol85ParserYEAR-498))|(1<<(Cobol85ParserYYYYMMDD-498))|(1<<(Cobol85ParserYYYYDDD-498))|(1<<(Cobol85ParserZERO_FILL-498)))) != 0) || (((_la-552)&-(0x1f+1)) == 0 && ((1<<uint((_la-552)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-552))|(1<<(Cobol85ParserLEVEL_NUMBER_77-552))|(1<<(Cobol85ParserLEVEL_NUMBER_88-552))|(1<<(Cobol85ParserINTEGERLITERAL-552))|(1<<(Cobol85ParserIDENTIFIER-552)))) != 0) {
			{
				p.SetState(4147)
				p.Identifier()
			}

			p.SetState(4150)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// IEvaluateStatementContext is an interface to support dynamic dispatch.
type IEvaluateStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvaluateStatementContext differentiates from other interfaces.
	IsEvaluateStatementContext()
}

type EvaluateStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvaluateStatementContext() *EvaluateStatementContext {
	var p = new(EvaluateStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_evaluateStatement
	return p
}

func (*EvaluateStatementContext) IsEvaluateStatementContext() {}

func NewEvaluateStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EvaluateStatementContext {
	var p = new(EvaluateStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_evaluateStatement

	return p
}

func (s *EvaluateStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *EvaluateStatementContext) EVALUATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEVALUATE, 0)
}

func (s *EvaluateStatementContext) EvaluateSelect() IEvaluateSelectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvaluateSelectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEvaluateSelectContext)
}

func (s *EvaluateStatementContext) AllEvaluateAlsoSelect() []IEvaluateAlsoSelectContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEvaluateAlsoSelectContext)(nil)).Elem())
	var tst = make([]IEvaluateAlsoSelectContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEvaluateAlsoSelectContext)
		}
	}

	return tst
}

func (s *EvaluateStatementContext) EvaluateAlsoSelect(i int) IEvaluateAlsoSelectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvaluateAlsoSelectContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEvaluateAlsoSelectContext)
}

func (s *EvaluateStatementContext) AllEvaluateWhenPhrase() []IEvaluateWhenPhraseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEvaluateWhenPhraseContext)(nil)).Elem())
	var tst = make([]IEvaluateWhenPhraseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEvaluateWhenPhraseContext)
		}
	}

	return tst
}

func (s *EvaluateStatementContext) EvaluateWhenPhrase(i int) IEvaluateWhenPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvaluateWhenPhraseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEvaluateWhenPhraseContext)
}

func (s *EvaluateStatementContext) EvaluateWhenOther() IEvaluateWhenOtherContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvaluateWhenOtherContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEvaluateWhenOtherContext)
}

func (s *EvaluateStatementContext) END_EVALUATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND_EVALUATE, 0)
}

func (s *EvaluateStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EvaluateStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EvaluateStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterEvaluateStatement(s)
	}
}

func (s *EvaluateStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitEvaluateStatement(s)
	}
}

func (p *Cobol85Parser) EvaluateStatement() (localctx IEvaluateStatementContext) {
	localctx = NewEvaluateStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 652, Cobol85ParserRULE_evaluateStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4154)
		p.Match(Cobol85ParserEVALUATE)
	}
	{
		p.SetState(4155)
		p.EvaluateSelect()
	}
	p.SetState(4159)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserALSO {
		{
			p.SetState(4156)
			p.EvaluateAlsoSelect()
		}

		p.SetState(4161)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(4163)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(4162)
				p.EvaluateWhenPhrase()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(4165)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 578, p.GetParserRuleContext())
	}
	p.SetState(4168)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 579, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4167)
			p.EvaluateWhenOther()
		}

	}
	p.SetState(4171)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 580, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4170)
			p.Match(Cobol85ParserEND_EVALUATE)
		}

	}

	return localctx
}

// IEvaluateSelectContext is an interface to support dynamic dispatch.
type IEvaluateSelectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvaluateSelectContext differentiates from other interfaces.
	IsEvaluateSelectContext()
}

type EvaluateSelectContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvaluateSelectContext() *EvaluateSelectContext {
	var p = new(EvaluateSelectContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_evaluateSelect
	return p
}

func (*EvaluateSelectContext) IsEvaluateSelectContext() {}

func NewEvaluateSelectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EvaluateSelectContext {
	var p = new(EvaluateSelectContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_evaluateSelect

	return p
}

func (s *EvaluateSelectContext) GetParser() antlr.Parser { return s.parser }

func (s *EvaluateSelectContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *EvaluateSelectContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *EvaluateSelectContext) ArithmeticExpression() IArithmeticExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArithmeticExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArithmeticExpressionContext)
}

func (s *EvaluateSelectContext) Condition() IConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *EvaluateSelectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EvaluateSelectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EvaluateSelectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterEvaluateSelect(s)
	}
}

func (s *EvaluateSelectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitEvaluateSelect(s)
	}
}

func (p *Cobol85Parser) EvaluateSelect() (localctx IEvaluateSelectContext) {
	localctx = NewEvaluateSelectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 654, Cobol85ParserRULE_evaluateSelect)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4177)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 581, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4173)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4174)
			p.Literal()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4175)
			p.ArithmeticExpression()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4176)
			p.Condition()
		}

	}

	return localctx
}

// IEvaluateAlsoSelectContext is an interface to support dynamic dispatch.
type IEvaluateAlsoSelectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvaluateAlsoSelectContext differentiates from other interfaces.
	IsEvaluateAlsoSelectContext()
}

type EvaluateAlsoSelectContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvaluateAlsoSelectContext() *EvaluateAlsoSelectContext {
	var p = new(EvaluateAlsoSelectContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_evaluateAlsoSelect
	return p
}

func (*EvaluateAlsoSelectContext) IsEvaluateAlsoSelectContext() {}

func NewEvaluateAlsoSelectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EvaluateAlsoSelectContext {
	var p = new(EvaluateAlsoSelectContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_evaluateAlsoSelect

	return p
}

func (s *EvaluateAlsoSelectContext) GetParser() antlr.Parser { return s.parser }

func (s *EvaluateAlsoSelectContext) ALSO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALSO, 0)
}

func (s *EvaluateAlsoSelectContext) EvaluateSelect() IEvaluateSelectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvaluateSelectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEvaluateSelectContext)
}

func (s *EvaluateAlsoSelectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EvaluateAlsoSelectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EvaluateAlsoSelectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterEvaluateAlsoSelect(s)
	}
}

func (s *EvaluateAlsoSelectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitEvaluateAlsoSelect(s)
	}
}

func (p *Cobol85Parser) EvaluateAlsoSelect() (localctx IEvaluateAlsoSelectContext) {
	localctx = NewEvaluateAlsoSelectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 656, Cobol85ParserRULE_evaluateAlsoSelect)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4179)
		p.Match(Cobol85ParserALSO)
	}
	{
		p.SetState(4180)
		p.EvaluateSelect()
	}

	return localctx
}

// IEvaluateWhenPhraseContext is an interface to support dynamic dispatch.
type IEvaluateWhenPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvaluateWhenPhraseContext differentiates from other interfaces.
	IsEvaluateWhenPhraseContext()
}

type EvaluateWhenPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvaluateWhenPhraseContext() *EvaluateWhenPhraseContext {
	var p = new(EvaluateWhenPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_evaluateWhenPhrase
	return p
}

func (*EvaluateWhenPhraseContext) IsEvaluateWhenPhraseContext() {}

func NewEvaluateWhenPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EvaluateWhenPhraseContext {
	var p = new(EvaluateWhenPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_evaluateWhenPhrase

	return p
}

func (s *EvaluateWhenPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *EvaluateWhenPhraseContext) AllEvaluateWhen() []IEvaluateWhenContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEvaluateWhenContext)(nil)).Elem())
	var tst = make([]IEvaluateWhenContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEvaluateWhenContext)
		}
	}

	return tst
}

func (s *EvaluateWhenPhraseContext) EvaluateWhen(i int) IEvaluateWhenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvaluateWhenContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEvaluateWhenContext)
}

func (s *EvaluateWhenPhraseContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *EvaluateWhenPhraseContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *EvaluateWhenPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EvaluateWhenPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EvaluateWhenPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterEvaluateWhenPhrase(s)
	}
}

func (s *EvaluateWhenPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitEvaluateWhenPhrase(s)
	}
}

func (p *Cobol85Parser) EvaluateWhenPhrase() (localctx IEvaluateWhenPhraseContext) {
	localctx = NewEvaluateWhenPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 658, Cobol85ParserRULE_evaluateWhenPhrase)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4183)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(4182)
				p.EvaluateWhen()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(4185)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 582, p.GetParserRuleContext())
	}
	p.SetState(4190)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 583, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4187)
				p.Statement()
			}

		}
		p.SetState(4192)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 583, p.GetParserRuleContext())
	}

	return localctx
}

// IEvaluateWhenContext is an interface to support dynamic dispatch.
type IEvaluateWhenContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvaluateWhenContext differentiates from other interfaces.
	IsEvaluateWhenContext()
}

type EvaluateWhenContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvaluateWhenContext() *EvaluateWhenContext {
	var p = new(EvaluateWhenContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_evaluateWhen
	return p
}

func (*EvaluateWhenContext) IsEvaluateWhenContext() {}

func NewEvaluateWhenContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EvaluateWhenContext {
	var p = new(EvaluateWhenContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_evaluateWhen

	return p
}

func (s *EvaluateWhenContext) GetParser() antlr.Parser { return s.parser }

func (s *EvaluateWhenContext) WHEN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWHEN, 0)
}

func (s *EvaluateWhenContext) EvaluateCondition() IEvaluateConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvaluateConditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEvaluateConditionContext)
}

func (s *EvaluateWhenContext) AllEvaluateAlsoCondition() []IEvaluateAlsoConditionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEvaluateAlsoConditionContext)(nil)).Elem())
	var tst = make([]IEvaluateAlsoConditionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEvaluateAlsoConditionContext)
		}
	}

	return tst
}

func (s *EvaluateWhenContext) EvaluateAlsoCondition(i int) IEvaluateAlsoConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvaluateAlsoConditionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEvaluateAlsoConditionContext)
}

func (s *EvaluateWhenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EvaluateWhenContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EvaluateWhenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterEvaluateWhen(s)
	}
}

func (s *EvaluateWhenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitEvaluateWhen(s)
	}
}

func (p *Cobol85Parser) EvaluateWhen() (localctx IEvaluateWhenContext) {
	localctx = NewEvaluateWhenContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 660, Cobol85ParserRULE_evaluateWhen)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4193)
		p.Match(Cobol85ParserWHEN)
	}
	{
		p.SetState(4194)
		p.EvaluateCondition()
	}
	p.SetState(4198)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserALSO {
		{
			p.SetState(4195)
			p.EvaluateAlsoCondition()
		}

		p.SetState(4200)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IEvaluateConditionContext is an interface to support dynamic dispatch.
type IEvaluateConditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvaluateConditionContext differentiates from other interfaces.
	IsEvaluateConditionContext()
}

type EvaluateConditionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvaluateConditionContext() *EvaluateConditionContext {
	var p = new(EvaluateConditionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_evaluateCondition
	return p
}

func (*EvaluateConditionContext) IsEvaluateConditionContext() {}

func NewEvaluateConditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EvaluateConditionContext {
	var p = new(EvaluateConditionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_evaluateCondition

	return p
}

func (s *EvaluateConditionContext) GetParser() antlr.Parser { return s.parser }

func (s *EvaluateConditionContext) ANY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserANY, 0)
}

func (s *EvaluateConditionContext) EvaluateValue() IEvaluateValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvaluateValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEvaluateValueContext)
}

func (s *EvaluateConditionContext) NOT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNOT, 0)
}

func (s *EvaluateConditionContext) EvaluateThrough() IEvaluateThroughContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvaluateThroughContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEvaluateThroughContext)
}

func (s *EvaluateConditionContext) Condition() IConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *EvaluateConditionContext) BooleanLiteral() IBooleanLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBooleanLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBooleanLiteralContext)
}

func (s *EvaluateConditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EvaluateConditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EvaluateConditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterEvaluateCondition(s)
	}
}

func (s *EvaluateConditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitEvaluateCondition(s)
	}
}

func (p *Cobol85Parser) EvaluateCondition() (localctx IEvaluateConditionContext) {
	localctx = NewEvaluateConditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 662, Cobol85ParserRULE_evaluateCondition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4211)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 587, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4201)
			p.Match(Cobol85ParserANY)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(4203)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserNOT {
			{
				p.SetState(4202)
				p.Match(Cobol85ParserNOT)
			}

		}
		{
			p.SetState(4205)
			p.EvaluateValue()
		}
		p.SetState(4207)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserTHROUGH || _la == Cobol85ParserTHRU {
			{
				p.SetState(4206)
				p.EvaluateThrough()
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4209)
			p.Condition()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4210)
			p.BooleanLiteral()
		}

	}

	return localctx
}

// IEvaluateThroughContext is an interface to support dynamic dispatch.
type IEvaluateThroughContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvaluateThroughContext differentiates from other interfaces.
	IsEvaluateThroughContext()
}

type EvaluateThroughContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvaluateThroughContext() *EvaluateThroughContext {
	var p = new(EvaluateThroughContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_evaluateThrough
	return p
}

func (*EvaluateThroughContext) IsEvaluateThroughContext() {}

func NewEvaluateThroughContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EvaluateThroughContext {
	var p = new(EvaluateThroughContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_evaluateThrough

	return p
}

func (s *EvaluateThroughContext) GetParser() antlr.Parser { return s.parser }

func (s *EvaluateThroughContext) EvaluateValue() IEvaluateValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvaluateValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEvaluateValueContext)
}

func (s *EvaluateThroughContext) THROUGH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHROUGH, 0)
}

func (s *EvaluateThroughContext) THRU() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHRU, 0)
}

func (s *EvaluateThroughContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EvaluateThroughContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EvaluateThroughContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterEvaluateThrough(s)
	}
}

func (s *EvaluateThroughContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitEvaluateThrough(s)
	}
}

func (p *Cobol85Parser) EvaluateThrough() (localctx IEvaluateThroughContext) {
	localctx = NewEvaluateThroughContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 664, Cobol85ParserRULE_evaluateThrough)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4213)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserTHROUGH || _la == Cobol85ParserTHRU) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(4214)
		p.EvaluateValue()
	}

	return localctx
}

// IEvaluateAlsoConditionContext is an interface to support dynamic dispatch.
type IEvaluateAlsoConditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvaluateAlsoConditionContext differentiates from other interfaces.
	IsEvaluateAlsoConditionContext()
}

type EvaluateAlsoConditionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvaluateAlsoConditionContext() *EvaluateAlsoConditionContext {
	var p = new(EvaluateAlsoConditionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_evaluateAlsoCondition
	return p
}

func (*EvaluateAlsoConditionContext) IsEvaluateAlsoConditionContext() {}

func NewEvaluateAlsoConditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EvaluateAlsoConditionContext {
	var p = new(EvaluateAlsoConditionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_evaluateAlsoCondition

	return p
}

func (s *EvaluateAlsoConditionContext) GetParser() antlr.Parser { return s.parser }

func (s *EvaluateAlsoConditionContext) ALSO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALSO, 0)
}

func (s *EvaluateAlsoConditionContext) EvaluateCondition() IEvaluateConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvaluateConditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEvaluateConditionContext)
}

func (s *EvaluateAlsoConditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EvaluateAlsoConditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EvaluateAlsoConditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterEvaluateAlsoCondition(s)
	}
}

func (s *EvaluateAlsoConditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitEvaluateAlsoCondition(s)
	}
}

func (p *Cobol85Parser) EvaluateAlsoCondition() (localctx IEvaluateAlsoConditionContext) {
	localctx = NewEvaluateAlsoConditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 666, Cobol85ParserRULE_evaluateAlsoCondition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4216)
		p.Match(Cobol85ParserALSO)
	}
	{
		p.SetState(4217)
		p.EvaluateCondition()
	}

	return localctx
}

// IEvaluateWhenOtherContext is an interface to support dynamic dispatch.
type IEvaluateWhenOtherContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvaluateWhenOtherContext differentiates from other interfaces.
	IsEvaluateWhenOtherContext()
}

type EvaluateWhenOtherContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvaluateWhenOtherContext() *EvaluateWhenOtherContext {
	var p = new(EvaluateWhenOtherContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_evaluateWhenOther
	return p
}

func (*EvaluateWhenOtherContext) IsEvaluateWhenOtherContext() {}

func NewEvaluateWhenOtherContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EvaluateWhenOtherContext {
	var p = new(EvaluateWhenOtherContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_evaluateWhenOther

	return p
}

func (s *EvaluateWhenOtherContext) GetParser() antlr.Parser { return s.parser }

func (s *EvaluateWhenOtherContext) WHEN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWHEN, 0)
}

func (s *EvaluateWhenOtherContext) OTHER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOTHER, 0)
}

func (s *EvaluateWhenOtherContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *EvaluateWhenOtherContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *EvaluateWhenOtherContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EvaluateWhenOtherContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EvaluateWhenOtherContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterEvaluateWhenOther(s)
	}
}

func (s *EvaluateWhenOtherContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitEvaluateWhenOther(s)
	}
}

func (p *Cobol85Parser) EvaluateWhenOther() (localctx IEvaluateWhenOtherContext) {
	localctx = NewEvaluateWhenOtherContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 668, Cobol85ParserRULE_evaluateWhenOther)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4219)
		p.Match(Cobol85ParserWHEN)
	}
	{
		p.SetState(4220)
		p.Match(Cobol85ParserOTHER)
	}
	p.SetState(4224)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 588, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4221)
				p.Statement()
			}

		}
		p.SetState(4226)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 588, p.GetParserRuleContext())
	}

	return localctx
}

// IEvaluateValueContext is an interface to support dynamic dispatch.
type IEvaluateValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvaluateValueContext differentiates from other interfaces.
	IsEvaluateValueContext()
}

type EvaluateValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvaluateValueContext() *EvaluateValueContext {
	var p = new(EvaluateValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_evaluateValue
	return p
}

func (*EvaluateValueContext) IsEvaluateValueContext() {}

func NewEvaluateValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EvaluateValueContext {
	var p = new(EvaluateValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_evaluateValue

	return p
}

func (s *EvaluateValueContext) GetParser() antlr.Parser { return s.parser }

func (s *EvaluateValueContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *EvaluateValueContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *EvaluateValueContext) ArithmeticExpression() IArithmeticExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArithmeticExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArithmeticExpressionContext)
}

func (s *EvaluateValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EvaluateValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EvaluateValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterEvaluateValue(s)
	}
}

func (s *EvaluateValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitEvaluateValue(s)
	}
}

func (p *Cobol85Parser) EvaluateValue() (localctx IEvaluateValueContext) {
	localctx = NewEvaluateValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 670, Cobol85ParserRULE_evaluateValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4230)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 589, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4227)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4228)
			p.Literal()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4229)
			p.ArithmeticExpression()
		}

	}

	return localctx
}

// IExecCicsStatementContext is an interface to support dynamic dispatch.
type IExecCicsStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExecCicsStatementContext differentiates from other interfaces.
	IsExecCicsStatementContext()
}

type ExecCicsStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExecCicsStatementContext() *ExecCicsStatementContext {
	var p = new(ExecCicsStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_execCicsStatement
	return p
}

func (*ExecCicsStatementContext) IsExecCicsStatementContext() {}

func NewExecCicsStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExecCicsStatementContext {
	var p = new(ExecCicsStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_execCicsStatement

	return p
}

func (s *ExecCicsStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExecCicsStatementContext) AllEXECCICSLINE() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserEXECCICSLINE)
}

func (s *ExecCicsStatementContext) EXECCICSLINE(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEXECCICSLINE, i)
}

func (s *ExecCicsStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExecCicsStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExecCicsStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterExecCicsStatement(s)
	}
}

func (s *ExecCicsStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitExecCicsStatement(s)
	}
}

func (p *Cobol85Parser) ExecCicsStatement() (localctx IExecCicsStatementContext) {
	localctx = NewExecCicsStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 672, Cobol85ParserRULE_execCicsStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4233)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(4232)
				p.Match(Cobol85ParserEXECCICSLINE)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(4235)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 590, p.GetParserRuleContext())
	}

	return localctx
}

// IExecSqlStatementContext is an interface to support dynamic dispatch.
type IExecSqlStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExecSqlStatementContext differentiates from other interfaces.
	IsExecSqlStatementContext()
}

type ExecSqlStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExecSqlStatementContext() *ExecSqlStatementContext {
	var p = new(ExecSqlStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_execSqlStatement
	return p
}

func (*ExecSqlStatementContext) IsExecSqlStatementContext() {}

func NewExecSqlStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExecSqlStatementContext {
	var p = new(ExecSqlStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_execSqlStatement

	return p
}

func (s *ExecSqlStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExecSqlStatementContext) AllEXECSQLLINE() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserEXECSQLLINE)
}

func (s *ExecSqlStatementContext) EXECSQLLINE(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEXECSQLLINE, i)
}

func (s *ExecSqlStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExecSqlStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExecSqlStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterExecSqlStatement(s)
	}
}

func (s *ExecSqlStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitExecSqlStatement(s)
	}
}

func (p *Cobol85Parser) ExecSqlStatement() (localctx IExecSqlStatementContext) {
	localctx = NewExecSqlStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 674, Cobol85ParserRULE_execSqlStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4238)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(4237)
				p.Match(Cobol85ParserEXECSQLLINE)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(4240)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 591, p.GetParserRuleContext())
	}

	return localctx
}

// IExecSqlImsStatementContext is an interface to support dynamic dispatch.
type IExecSqlImsStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExecSqlImsStatementContext differentiates from other interfaces.
	IsExecSqlImsStatementContext()
}

type ExecSqlImsStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExecSqlImsStatementContext() *ExecSqlImsStatementContext {
	var p = new(ExecSqlImsStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_execSqlImsStatement
	return p
}

func (*ExecSqlImsStatementContext) IsExecSqlImsStatementContext() {}

func NewExecSqlImsStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExecSqlImsStatementContext {
	var p = new(ExecSqlImsStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_execSqlImsStatement

	return p
}

func (s *ExecSqlImsStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExecSqlImsStatementContext) AllEXECSQLIMSLINE() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserEXECSQLIMSLINE)
}

func (s *ExecSqlImsStatementContext) EXECSQLIMSLINE(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEXECSQLIMSLINE, i)
}

func (s *ExecSqlImsStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExecSqlImsStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExecSqlImsStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterExecSqlImsStatement(s)
	}
}

func (s *ExecSqlImsStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitExecSqlImsStatement(s)
	}
}

func (p *Cobol85Parser) ExecSqlImsStatement() (localctx IExecSqlImsStatementContext) {
	localctx = NewExecSqlImsStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 676, Cobol85ParserRULE_execSqlImsStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4243)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(4242)
				p.Match(Cobol85ParserEXECSQLIMSLINE)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(4245)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 592, p.GetParserRuleContext())
	}

	return localctx
}

// IExhibitStatementContext is an interface to support dynamic dispatch.
type IExhibitStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExhibitStatementContext differentiates from other interfaces.
	IsExhibitStatementContext()
}

type ExhibitStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExhibitStatementContext() *ExhibitStatementContext {
	var p = new(ExhibitStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_exhibitStatement
	return p
}

func (*ExhibitStatementContext) IsExhibitStatementContext() {}

func NewExhibitStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExhibitStatementContext {
	var p = new(ExhibitStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_exhibitStatement

	return p
}

func (s *ExhibitStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExhibitStatementContext) EXHIBIT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEXHIBIT, 0)
}

func (s *ExhibitStatementContext) NAMED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNAMED, 0)
}

func (s *ExhibitStatementContext) CHANGED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCHANGED, 0)
}

func (s *ExhibitStatementContext) AllExhibitOperand() []IExhibitOperandContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExhibitOperandContext)(nil)).Elem())
	var tst = make([]IExhibitOperandContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExhibitOperandContext)
		}
	}

	return tst
}

func (s *ExhibitStatementContext) ExhibitOperand(i int) IExhibitOperandContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExhibitOperandContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExhibitOperandContext)
}

func (s *ExhibitStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExhibitStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExhibitStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterExhibitStatement(s)
	}
}

func (s *ExhibitStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitExhibitStatement(s)
	}
}

func (p *Cobol85Parser) ExhibitStatement() (localctx IExhibitStatementContext) {
	localctx = NewExhibitStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 678, Cobol85ParserRULE_exhibitStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4247)
		p.Match(Cobol85ParserEXHIBIT)
	}
	p.SetState(4249)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 593, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4248)
			p.Match(Cobol85ParserNAMED)
		}

	}
	p.SetState(4252)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 594, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4251)
			p.Match(Cobol85ParserCHANGED)
		}

	}
	p.SetState(4255)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserADDRESS)|(1<<Cobol85ParserALL)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH)|(1<<Cobol85ParserATTRIBUTE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBINARY-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-68))|(1<<(Cobol85ParserCOBOL-68))|(1<<(Cobol85ParserCOMMITMENT-68))|(1<<(Cobol85ParserCONTROL_POINT-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(Cobol85ParserCONVENTION-100))|(1<<(Cobol85ParserCRUNCH-100))|(1<<(Cobol85ParserCURSOR-100))|(1<<(Cobol85ParserDATE-100))|(1<<(Cobol85ParserDAY-100))|(1<<(Cobol85ParserDAY_OF_WEEK-100))|(1<<(Cobol85ParserDEBUG_CONTENTS-100))|(1<<(Cobol85ParserDEBUG_ITEM-100))|(1<<(Cobol85ParserDEBUG_LINE-100))|(1<<(Cobol85ParserDEBUG_NAME-100))|(1<<(Cobol85ParserDEBUG_SUB_1-100))|(1<<(Cobol85ParserDEBUG_SUB_2-100))|(1<<(Cobol85ParserDEBUG_SUB_3-100))|(1<<(Cobol85ParserDEFAULT-100))|(1<<(Cobol85ParserDEFAULT_DISPLAY-100))|(1<<(Cobol85ParserDEFINITION-100)))) != 0) || (((_la-138)&-(0x1f+1)) == 0 && ((1<<uint((_la-138)))&((1<<(Cobol85ParserDFHRESP-138))|(1<<(Cobol85ParserDFHVALUE-138))|(1<<(Cobol85ParserDISK-138))|(1<<(Cobol85ParserDONTCARE-138))|(1<<(Cobol85ParserDOUBLE-138))|(1<<(Cobol85ParserEBCDIC-138))|(1<<(Cobol85ParserEMPTY_CHECK-138)))) != 0) || (((_la-181)&-(0x1f+1)) == 0 && ((1<<uint((_la-181)))&((1<<(Cobol85ParserENTER-181))|(1<<(Cobol85ParserENTRY_PROCEDURE-181))|(1<<(Cobol85ParserERASE-181))|(1<<(Cobol85ParserEOL-181))|(1<<(Cobol85ParserEOS-181))|(1<<(Cobol85ParserESCAPE-181))|(1<<(Cobol85ParserEVENT-181))|(1<<(Cobol85ParserEXCLUSIVE-181))|(1<<(Cobol85ParserEXPORT-181))|(1<<(Cobol85ParserEXTENDED-181))|(1<<(Cobol85ParserFALSE-181)))) != 0) || (((_la-213)&-(0x1f+1)) == 0 && ((1<<uint((_la-213)))&((1<<(Cobol85ParserFOREGROUND_COLOR-213))|(1<<(Cobol85ParserFOREGROUND_COLOUR-213))|(1<<(Cobol85ParserFULL-213))|(1<<(Cobol85ParserFUNCTION-213))|(1<<(Cobol85ParserFUNCTIONNAME-213))|(1<<(Cobol85ParserFUNCTION_POINTER-213))|(1<<(Cobol85ParserGRID-213))|(1<<(Cobol85ParserHIGHLIGHT-213))|(1<<(Cobol85ParserHIGH_VALUE-213))|(1<<(Cobol85ParserHIGH_VALUES-213))|(1<<(Cobol85ParserIMPLICIT-213))|(1<<(Cobol85ParserIMPORT-213)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(Cobol85ParserINTEGER-250))|(1<<(Cobol85ParserKEPT-250))|(1<<(Cobol85ParserKEYBOARD-250))|(1<<(Cobol85ParserLANGUAGE-250))|(1<<(Cobol85ParserLB-250))|(1<<(Cobol85ParserLD-250))|(1<<(Cobol85ParserLEFTLINE-250))|(1<<(Cobol85ParserLENGTH-250))|(1<<(Cobol85ParserLENGTH_CHECK-250))|(1<<(Cobol85ParserLIBACCESS-250))|(1<<(Cobol85ParserLIBPARAMETER-250))|(1<<(Cobol85ParserLIBRARY-250))|(1<<(Cobol85ParserLINAGE_COUNTER-250))|(1<<(Cobol85ParserLINE_COUNTER-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(Cobol85ParserLIST-283))|(1<<(Cobol85ParserLOCAL-283))|(1<<(Cobol85ParserLONG_DATE-283))|(1<<(Cobol85ParserLONG_TIME-283))|(1<<(Cobol85ParserLOWER-283))|(1<<(Cobol85ParserLOWLIGHT-283))|(1<<(Cobol85ParserLOW_VALUE-283))|(1<<(Cobol85ParserLOW_VALUES-283))|(1<<(Cobol85ParserMMDDYYYY-283))|(1<<(Cobol85ParserNAMED-283))|(1<<(Cobol85ParserNATIONAL-283))|(1<<(Cobol85ParserNATIONAL_EDITED-283))|(1<<(Cobol85ParserNETWORK-283))|(1<<(Cobol85ParserNO_ECHO-283))|(1<<(Cobol85ParserNULL-283))|(1<<(Cobol85ParserNULLS-283)))) != 0) || (((_la-317)&-(0x1f+1)) == 0 && ((1<<uint((_la-317)))&((1<<(Cobol85ParserNUMERIC_DATE-317))|(1<<(Cobol85ParserNUMERIC_TIME-317))|(1<<(Cobol85ParserODT-317))|(1<<(Cobol85ParserORDERLY-317))|(1<<(Cobol85ParserOVERLINE-317))|(1<<(Cobol85ParserOWN-317))|(1<<(Cobol85ParserPAGE_COUNTER-317))|(1<<(Cobol85ParserPASSWORD-317)))) != 0) || (((_la-352)&-(0x1f+1)) == 0 && ((1<<uint((_la-352)))&((1<<(Cobol85ParserPORT-352))|(1<<(Cobol85ParserPRINTER-352))|(1<<(Cobol85ParserPRIVATE-352))|(1<<(Cobol85ParserPROCESS-352))|(1<<(Cobol85ParserPROGRAM-352))|(1<<(Cobol85ParserPROMPT-352))|(1<<(Cobol85ParserQUOTE-352))|(1<<(Cobol85ParserQUOTES-352))|(1<<(Cobol85ParserREADER-352))|(1<<(Cobol85ParserREMOTE-352))|(1<<(Cobol85ParserREAL-352))|(1<<(Cobol85ParserRECEIVED-352))|(1<<(Cobol85ParserRECURSIVE-352))|(1<<(Cobol85ParserREF-352)))) != 0) || (((_la-391)&-(0x1f+1)) == 0 && ((1<<uint((_la-391)))&((1<<(Cobol85ParserREMOVE-391))|(1<<(Cobol85ParserREQUIRED-391))|(1<<(Cobol85ParserREVERSE_VIDEO-391))|(1<<(Cobol85ParserRETURN_CODE-391))|(1<<(Cobol85ParserSAVE-391))|(1<<(Cobol85ParserSECURE-391)))) != 0) || (((_la-431)&-(0x1f+1)) == 0 && ((1<<uint((_la-431)))&((1<<(Cobol85ParserSHARED-431))|(1<<(Cobol85ParserSHAREDBYALL-431))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-431))|(1<<(Cobol85ParserSHARING-431))|(1<<(Cobol85ParserSHIFT_IN-431))|(1<<(Cobol85ParserSHIFT_OUT-431))|(1<<(Cobol85ParserSHORT_DATE-431))|(1<<(Cobol85ParserSORT_CONTROL-431))|(1<<(Cobol85ParserSORT_CORE_SIZE-431))|(1<<(Cobol85ParserSORT_FILE_SIZE-431))|(1<<(Cobol85ParserSORT_MESSAGE-431))|(1<<(Cobol85ParserSORT_MODE_SIZE-431))|(1<<(Cobol85ParserSORT_RETURN-431))|(1<<(Cobol85ParserSPACE-431))|(1<<(Cobol85ParserSPACES-431)))) != 0) || (((_la-466)&-(0x1f+1)) == 0 && ((1<<uint((_la-466)))&((1<<(Cobol85ParserSYMBOL-466))|(1<<(Cobol85ParserTALLY-466))|(1<<(Cobol85ParserTASK-466))|(1<<(Cobol85ParserTHREAD-466))|(1<<(Cobol85ParserTHREAD_LOCAL-466))|(1<<(Cobol85ParserTIME-466))|(1<<(Cobol85ParserTIMER-466))|(1<<(Cobol85ParserTODAYS_DATE-466))|(1<<(Cobol85ParserTODAYS_NAME-466))|(1<<(Cobol85ParserTRUE-466))|(1<<(Cobol85ParserTRUNCATED-466))|(1<<(Cobol85ParserTYPEDEF-466)))) != 0) || (((_la-498)&-(0x1f+1)) == 0 && ((1<<uint((_la-498)))&((1<<(Cobol85ParserUNDERLINE-498))|(1<<(Cobol85ParserVIRTUAL-498))|(1<<(Cobol85ParserWAIT-498))|(1<<(Cobol85ParserWHEN_COMPILED-498))|(1<<(Cobol85ParserYEAR-498))|(1<<(Cobol85ParserYYYYMMDD-498))|(1<<(Cobol85ParserYYYYDDD-498))|(1<<(Cobol85ParserZERO-498))|(1<<(Cobol85ParserZERO_FILL-498))|(1<<(Cobol85ParserZEROS-498))|(1<<(Cobol85ParserZEROES-498)))) != 0) || (((_la-551)&-(0x1f+1)) == 0 && ((1<<uint((_la-551)))&((1<<(Cobol85ParserNONNUMERICLITERAL-551))|(1<<(Cobol85ParserLEVEL_NUMBER_66-551))|(1<<(Cobol85ParserLEVEL_NUMBER_77-551))|(1<<(Cobol85ParserLEVEL_NUMBER_88-551))|(1<<(Cobol85ParserINTEGERLITERAL-551))|(1<<(Cobol85ParserNUMERICLITERAL-551))|(1<<(Cobol85ParserIDENTIFIER-551)))) != 0) {
		{
			p.SetState(4254)
			p.ExhibitOperand()
		}

		p.SetState(4257)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IExhibitOperandContext is an interface to support dynamic dispatch.
type IExhibitOperandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExhibitOperandContext differentiates from other interfaces.
	IsExhibitOperandContext()
}

type ExhibitOperandContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExhibitOperandContext() *ExhibitOperandContext {
	var p = new(ExhibitOperandContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_exhibitOperand
	return p
}

func (*ExhibitOperandContext) IsExhibitOperandContext() {}

func NewExhibitOperandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExhibitOperandContext {
	var p = new(ExhibitOperandContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_exhibitOperand

	return p
}

func (s *ExhibitOperandContext) GetParser() antlr.Parser { return s.parser }

func (s *ExhibitOperandContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ExhibitOperandContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *ExhibitOperandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExhibitOperandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExhibitOperandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterExhibitOperand(s)
	}
}

func (s *ExhibitOperandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitExhibitOperand(s)
	}
}

func (p *Cobol85Parser) ExhibitOperand() (localctx IExhibitOperandContext) {
	localctx = NewExhibitOperandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 680, Cobol85ParserRULE_exhibitOperand)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4261)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 596, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4259)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4260)
			p.Literal()
		}

	}

	return localctx
}

// IExitStatementContext is an interface to support dynamic dispatch.
type IExitStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExitStatementContext differentiates from other interfaces.
	IsExitStatementContext()
}

type ExitStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExitStatementContext() *ExitStatementContext {
	var p = new(ExitStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_exitStatement
	return p
}

func (*ExitStatementContext) IsExitStatementContext() {}

func NewExitStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExitStatementContext {
	var p = new(ExitStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_exitStatement

	return p
}

func (s *ExitStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExitStatementContext) EXIT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEXIT, 0)
}

func (s *ExitStatementContext) PROGRAM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPROGRAM, 0)
}

func (s *ExitStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExitStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExitStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterExitStatement(s)
	}
}

func (s *ExitStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitExitStatement(s)
	}
}

func (p *Cobol85Parser) ExitStatement() (localctx IExitStatementContext) {
	localctx = NewExitStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 682, Cobol85ParserRULE_exitStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4263)
		p.Match(Cobol85ParserEXIT)
	}
	p.SetState(4265)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserPROGRAM {
		{
			p.SetState(4264)
			p.Match(Cobol85ParserPROGRAM)
		}

	}

	return localctx
}

// IGenerateStatementContext is an interface to support dynamic dispatch.
type IGenerateStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenerateStatementContext differentiates from other interfaces.
	IsGenerateStatementContext()
}

type GenerateStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenerateStatementContext() *GenerateStatementContext {
	var p = new(GenerateStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_generateStatement
	return p
}

func (*GenerateStatementContext) IsGenerateStatementContext() {}

func NewGenerateStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GenerateStatementContext {
	var p = new(GenerateStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_generateStatement

	return p
}

func (s *GenerateStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *GenerateStatementContext) GENERATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserGENERATE, 0)
}

func (s *GenerateStatementContext) ReportName() IReportNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReportNameContext)
}

func (s *GenerateStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GenerateStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GenerateStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterGenerateStatement(s)
	}
}

func (s *GenerateStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitGenerateStatement(s)
	}
}

func (p *Cobol85Parser) GenerateStatement() (localctx IGenerateStatementContext) {
	localctx = NewGenerateStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 684, Cobol85ParserRULE_generateStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4267)
		p.Match(Cobol85ParserGENERATE)
	}
	{
		p.SetState(4268)
		p.ReportName()
	}

	return localctx
}

// IGobackStatementContext is an interface to support dynamic dispatch.
type IGobackStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGobackStatementContext differentiates from other interfaces.
	IsGobackStatementContext()
}

type GobackStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGobackStatementContext() *GobackStatementContext {
	var p = new(GobackStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_gobackStatement
	return p
}

func (*GobackStatementContext) IsGobackStatementContext() {}

func NewGobackStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GobackStatementContext {
	var p = new(GobackStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_gobackStatement

	return p
}

func (s *GobackStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *GobackStatementContext) GOBACK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserGOBACK, 0)
}

func (s *GobackStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GobackStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GobackStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterGobackStatement(s)
	}
}

func (s *GobackStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitGobackStatement(s)
	}
}

func (p *Cobol85Parser) GobackStatement() (localctx IGobackStatementContext) {
	localctx = NewGobackStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 686, Cobol85ParserRULE_gobackStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4270)
		p.Match(Cobol85ParserGOBACK)
	}

	return localctx
}

// IGoToStatementContext is an interface to support dynamic dispatch.
type IGoToStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGoToStatementContext differentiates from other interfaces.
	IsGoToStatementContext()
}

type GoToStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGoToStatementContext() *GoToStatementContext {
	var p = new(GoToStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_goToStatement
	return p
}

func (*GoToStatementContext) IsGoToStatementContext() {}

func NewGoToStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GoToStatementContext {
	var p = new(GoToStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_goToStatement

	return p
}

func (s *GoToStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *GoToStatementContext) GO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserGO, 0)
}

func (s *GoToStatementContext) GoToStatementSimple() IGoToStatementSimpleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGoToStatementSimpleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGoToStatementSimpleContext)
}

func (s *GoToStatementContext) GoToDependingOnStatement() IGoToDependingOnStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGoToDependingOnStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGoToDependingOnStatementContext)
}

func (s *GoToStatementContext) TO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTO, 0)
}

func (s *GoToStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GoToStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GoToStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterGoToStatement(s)
	}
}

func (s *GoToStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitGoToStatement(s)
	}
}

func (p *Cobol85Parser) GoToStatement() (localctx IGoToStatementContext) {
	localctx = NewGoToStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 688, Cobol85ParserRULE_goToStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4272)
		p.Match(Cobol85ParserGO)
	}
	p.SetState(4274)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserTO {
		{
			p.SetState(4273)
			p.Match(Cobol85ParserTO)
		}

	}
	p.SetState(4278)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 599, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4276)
			p.GoToStatementSimple()
		}

	case 2:
		{
			p.SetState(4277)
			p.GoToDependingOnStatement()
		}

	}

	return localctx
}

// IGoToStatementSimpleContext is an interface to support dynamic dispatch.
type IGoToStatementSimpleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGoToStatementSimpleContext differentiates from other interfaces.
	IsGoToStatementSimpleContext()
}

type GoToStatementSimpleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGoToStatementSimpleContext() *GoToStatementSimpleContext {
	var p = new(GoToStatementSimpleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_goToStatementSimple
	return p
}

func (*GoToStatementSimpleContext) IsGoToStatementSimpleContext() {}

func NewGoToStatementSimpleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GoToStatementSimpleContext {
	var p = new(GoToStatementSimpleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_goToStatementSimple

	return p
}

func (s *GoToStatementSimpleContext) GetParser() antlr.Parser { return s.parser }

func (s *GoToStatementSimpleContext) ProcedureName() IProcedureNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedureNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedureNameContext)
}

func (s *GoToStatementSimpleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GoToStatementSimpleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GoToStatementSimpleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterGoToStatementSimple(s)
	}
}

func (s *GoToStatementSimpleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitGoToStatementSimple(s)
	}
}

func (p *Cobol85Parser) GoToStatementSimple() (localctx IGoToStatementSimpleContext) {
	localctx = NewGoToStatementSimpleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 690, Cobol85ParserRULE_goToStatementSimple)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4280)
		p.ProcedureName()
	}

	return localctx
}

// IGoToDependingOnStatementContext is an interface to support dynamic dispatch.
type IGoToDependingOnStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGoToDependingOnStatementContext differentiates from other interfaces.
	IsGoToDependingOnStatementContext()
}

type GoToDependingOnStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGoToDependingOnStatementContext() *GoToDependingOnStatementContext {
	var p = new(GoToDependingOnStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_goToDependingOnStatement
	return p
}

func (*GoToDependingOnStatementContext) IsGoToDependingOnStatementContext() {}

func NewGoToDependingOnStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GoToDependingOnStatementContext {
	var p = new(GoToDependingOnStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_goToDependingOnStatement

	return p
}

func (s *GoToDependingOnStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *GoToDependingOnStatementContext) MORE_LABELS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMORE_LABELS, 0)
}

func (s *GoToDependingOnStatementContext) AllProcedureName() []IProcedureNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IProcedureNameContext)(nil)).Elem())
	var tst = make([]IProcedureNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IProcedureNameContext)
		}
	}

	return tst
}

func (s *GoToDependingOnStatementContext) ProcedureName(i int) IProcedureNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedureNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IProcedureNameContext)
}

func (s *GoToDependingOnStatementContext) DEPENDING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDEPENDING, 0)
}

func (s *GoToDependingOnStatementContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *GoToDependingOnStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserON, 0)
}

func (s *GoToDependingOnStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GoToDependingOnStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GoToDependingOnStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterGoToDependingOnStatement(s)
	}
}

func (s *GoToDependingOnStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitGoToDependingOnStatement(s)
	}
}

func (p *Cobol85Parser) GoToDependingOnStatement() (localctx IGoToDependingOnStatementContext) {
	localctx = NewGoToDependingOnStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 692, Cobol85ParserRULE_goToDependingOnStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4295)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserMORE_LABELS:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4282)
			p.Match(Cobol85ParserMORE_LABELS)
		}

	case Cobol85ParserABORT, Cobol85ParserAS, Cobol85ParserASCII, Cobol85ParserASSOCIATED_DATA, Cobol85ParserASSOCIATED_DATA_LENGTH, Cobol85ParserATTRIBUTE, Cobol85ParserAUTO, Cobol85ParserAUTO_SKIP, Cobol85ParserBACKGROUND_COLOR, Cobol85ParserBACKGROUND_COLOUR, Cobol85ParserBEEP, Cobol85ParserBELL, Cobol85ParserBINARY, Cobol85ParserBIT, Cobol85ParserBLINK, Cobol85ParserBOUNDS, Cobol85ParserCAPABLE, Cobol85ParserCCSVERSION, Cobol85ParserCHANGED, Cobol85ParserCHANNEL, Cobol85ParserCLOSE_DISPOSITION, Cobol85ParserCOBOL, Cobol85ParserCOMMITMENT, Cobol85ParserCONTROL_POINT, Cobol85ParserCONVENTION, Cobol85ParserCRUNCH, Cobol85ParserCURSOR, Cobol85ParserDEFAULT, Cobol85ParserDEFAULT_DISPLAY, Cobol85ParserDEFINITION, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserDISK, Cobol85ParserDONTCARE, Cobol85ParserDOUBLE, Cobol85ParserEBCDIC, Cobol85ParserEMPTY_CHECK, Cobol85ParserENTER, Cobol85ParserENTRY_PROCEDURE, Cobol85ParserERASE, Cobol85ParserEOL, Cobol85ParserEOS, Cobol85ParserESCAPE, Cobol85ParserEVENT, Cobol85ParserEXCLUSIVE, Cobol85ParserEXPORT, Cobol85ParserEXTENDED, Cobol85ParserFOREGROUND_COLOR, Cobol85ParserFOREGROUND_COLOUR, Cobol85ParserFULL, Cobol85ParserFUNCTIONNAME, Cobol85ParserFUNCTION_POINTER, Cobol85ParserGRID, Cobol85ParserHIGHLIGHT, Cobol85ParserIMPLICIT, Cobol85ParserIMPORT, Cobol85ParserINTEGER, Cobol85ParserKEPT, Cobol85ParserKEYBOARD, Cobol85ParserLANGUAGE, Cobol85ParserLB, Cobol85ParserLD, Cobol85ParserLEFTLINE, Cobol85ParserLENGTH_CHECK, Cobol85ParserLIBACCESS, Cobol85ParserLIBPARAMETER, Cobol85ParserLIBRARY, Cobol85ParserLIST, Cobol85ParserLOCAL, Cobol85ParserLONG_DATE, Cobol85ParserLONG_TIME, Cobol85ParserLOWER, Cobol85ParserLOWLIGHT, Cobol85ParserMMDDYYYY, Cobol85ParserNAMED, Cobol85ParserNATIONAL, Cobol85ParserNATIONAL_EDITED, Cobol85ParserNETWORK, Cobol85ParserNO_ECHO, Cobol85ParserNUMERIC_DATE, Cobol85ParserNUMERIC_TIME, Cobol85ParserODT, Cobol85ParserORDERLY, Cobol85ParserOVERLINE, Cobol85ParserOWN, Cobol85ParserPASSWORD, Cobol85ParserPORT, Cobol85ParserPRINTER, Cobol85ParserPRIVATE, Cobol85ParserPROCESS, Cobol85ParserPROGRAM, Cobol85ParserPROMPT, Cobol85ParserREADER, Cobol85ParserREMOTE, Cobol85ParserREAL, Cobol85ParserRECEIVED, Cobol85ParserRECURSIVE, Cobol85ParserREF, Cobol85ParserREMOVE, Cobol85ParserREQUIRED, Cobol85ParserREVERSE_VIDEO, Cobol85ParserSAVE, Cobol85ParserSECURE, Cobol85ParserSHARED, Cobol85ParserSHAREDBYALL, Cobol85ParserSHAREDBYRUNUNIT, Cobol85ParserSHARING, Cobol85ParserSHORT_DATE, Cobol85ParserSYMBOL, Cobol85ParserTASK, Cobol85ParserTHREAD, Cobol85ParserTHREAD_LOCAL, Cobol85ParserTIMER, Cobol85ParserTODAYS_DATE, Cobol85ParserTODAYS_NAME, Cobol85ParserTRUNCATED, Cobol85ParserTYPEDEF, Cobol85ParserUNDERLINE, Cobol85ParserVIRTUAL, Cobol85ParserWAIT, Cobol85ParserYEAR, Cobol85ParserYYYYMMDD, Cobol85ParserYYYYDDD, Cobol85ParserZERO_FILL, Cobol85ParserLEVEL_NUMBER_66, Cobol85ParserLEVEL_NUMBER_77, Cobol85ParserLEVEL_NUMBER_88, Cobol85ParserINTEGERLITERAL, Cobol85ParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(4284)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH)|(1<<Cobol85ParserATTRIBUTE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBINARY-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-68))|(1<<(Cobol85ParserCOBOL-68))|(1<<(Cobol85ParserCOMMITMENT-68))|(1<<(Cobol85ParserCONTROL_POINT-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(Cobol85ParserCONVENTION-100))|(1<<(Cobol85ParserCRUNCH-100))|(1<<(Cobol85ParserCURSOR-100))|(1<<(Cobol85ParserDEFAULT-100))|(1<<(Cobol85ParserDEFAULT_DISPLAY-100))|(1<<(Cobol85ParserDEFINITION-100)))) != 0) || (((_la-138)&-(0x1f+1)) == 0 && ((1<<uint((_la-138)))&((1<<(Cobol85ParserDFHRESP-138))|(1<<(Cobol85ParserDFHVALUE-138))|(1<<(Cobol85ParserDISK-138))|(1<<(Cobol85ParserDONTCARE-138))|(1<<(Cobol85ParserDOUBLE-138))|(1<<(Cobol85ParserEBCDIC-138))|(1<<(Cobol85ParserEMPTY_CHECK-138)))) != 0) || (((_la-181)&-(0x1f+1)) == 0 && ((1<<uint((_la-181)))&((1<<(Cobol85ParserENTER-181))|(1<<(Cobol85ParserENTRY_PROCEDURE-181))|(1<<(Cobol85ParserERASE-181))|(1<<(Cobol85ParserEOL-181))|(1<<(Cobol85ParserEOS-181))|(1<<(Cobol85ParserESCAPE-181))|(1<<(Cobol85ParserEVENT-181))|(1<<(Cobol85ParserEXCLUSIVE-181))|(1<<(Cobol85ParserEXPORT-181))|(1<<(Cobol85ParserEXTENDED-181)))) != 0) || (((_la-213)&-(0x1f+1)) == 0 && ((1<<uint((_la-213)))&((1<<(Cobol85ParserFOREGROUND_COLOR-213))|(1<<(Cobol85ParserFOREGROUND_COLOUR-213))|(1<<(Cobol85ParserFULL-213))|(1<<(Cobol85ParserFUNCTIONNAME-213))|(1<<(Cobol85ParserFUNCTION_POINTER-213))|(1<<(Cobol85ParserGRID-213))|(1<<(Cobol85ParserHIGHLIGHT-213))|(1<<(Cobol85ParserIMPLICIT-213))|(1<<(Cobol85ParserIMPORT-213)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(Cobol85ParserINTEGER-250))|(1<<(Cobol85ParserKEPT-250))|(1<<(Cobol85ParserKEYBOARD-250))|(1<<(Cobol85ParserLANGUAGE-250))|(1<<(Cobol85ParserLB-250))|(1<<(Cobol85ParserLD-250))|(1<<(Cobol85ParserLEFTLINE-250))|(1<<(Cobol85ParserLENGTH_CHECK-250))|(1<<(Cobol85ParserLIBACCESS-250))|(1<<(Cobol85ParserLIBPARAMETER-250))|(1<<(Cobol85ParserLIBRARY-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(Cobol85ParserLIST-283))|(1<<(Cobol85ParserLOCAL-283))|(1<<(Cobol85ParserLONG_DATE-283))|(1<<(Cobol85ParserLONG_TIME-283))|(1<<(Cobol85ParserLOWER-283))|(1<<(Cobol85ParserLOWLIGHT-283))|(1<<(Cobol85ParserMMDDYYYY-283))|(1<<(Cobol85ParserNAMED-283))|(1<<(Cobol85ParserNATIONAL-283))|(1<<(Cobol85ParserNATIONAL_EDITED-283))|(1<<(Cobol85ParserNETWORK-283))|(1<<(Cobol85ParserNO_ECHO-283)))) != 0) || (((_la-317)&-(0x1f+1)) == 0 && ((1<<uint((_la-317)))&((1<<(Cobol85ParserNUMERIC_DATE-317))|(1<<(Cobol85ParserNUMERIC_TIME-317))|(1<<(Cobol85ParserODT-317))|(1<<(Cobol85ParserORDERLY-317))|(1<<(Cobol85ParserOVERLINE-317))|(1<<(Cobol85ParserOWN-317))|(1<<(Cobol85ParserPASSWORD-317)))) != 0) || (((_la-352)&-(0x1f+1)) == 0 && ((1<<uint((_la-352)))&((1<<(Cobol85ParserPORT-352))|(1<<(Cobol85ParserPRINTER-352))|(1<<(Cobol85ParserPRIVATE-352))|(1<<(Cobol85ParserPROCESS-352))|(1<<(Cobol85ParserPROGRAM-352))|(1<<(Cobol85ParserPROMPT-352))|(1<<(Cobol85ParserREADER-352))|(1<<(Cobol85ParserREMOTE-352))|(1<<(Cobol85ParserREAL-352))|(1<<(Cobol85ParserRECEIVED-352))|(1<<(Cobol85ParserRECURSIVE-352))|(1<<(Cobol85ParserREF-352)))) != 0) || (((_la-391)&-(0x1f+1)) == 0 && ((1<<uint((_la-391)))&((1<<(Cobol85ParserREMOVE-391))|(1<<(Cobol85ParserREQUIRED-391))|(1<<(Cobol85ParserREVERSE_VIDEO-391))|(1<<(Cobol85ParserSAVE-391))|(1<<(Cobol85ParserSECURE-391)))) != 0) || (((_la-431)&-(0x1f+1)) == 0 && ((1<<uint((_la-431)))&((1<<(Cobol85ParserSHARED-431))|(1<<(Cobol85ParserSHAREDBYALL-431))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-431))|(1<<(Cobol85ParserSHARING-431))|(1<<(Cobol85ParserSHORT_DATE-431)))) != 0) || (((_la-466)&-(0x1f+1)) == 0 && ((1<<uint((_la-466)))&((1<<(Cobol85ParserSYMBOL-466))|(1<<(Cobol85ParserTASK-466))|(1<<(Cobol85ParserTHREAD-466))|(1<<(Cobol85ParserTHREAD_LOCAL-466))|(1<<(Cobol85ParserTIMER-466))|(1<<(Cobol85ParserTODAYS_DATE-466))|(1<<(Cobol85ParserTODAYS_NAME-466))|(1<<(Cobol85ParserTRUNCATED-466))|(1<<(Cobol85ParserTYPEDEF-466)))) != 0) || (((_la-498)&-(0x1f+1)) == 0 && ((1<<uint((_la-498)))&((1<<(Cobol85ParserUNDERLINE-498))|(1<<(Cobol85ParserVIRTUAL-498))|(1<<(Cobol85ParserWAIT-498))|(1<<(Cobol85ParserYEAR-498))|(1<<(Cobol85ParserYYYYMMDD-498))|(1<<(Cobol85ParserYYYYDDD-498))|(1<<(Cobol85ParserZERO_FILL-498)))) != 0) || (((_la-552)&-(0x1f+1)) == 0 && ((1<<uint((_la-552)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-552))|(1<<(Cobol85ParserLEVEL_NUMBER_77-552))|(1<<(Cobol85ParserLEVEL_NUMBER_88-552))|(1<<(Cobol85ParserINTEGERLITERAL-552))|(1<<(Cobol85ParserIDENTIFIER-552)))) != 0) {
			{
				p.SetState(4283)
				p.ProcedureName()
			}

			p.SetState(4286)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(4293)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserDEPENDING {
			{
				p.SetState(4288)
				p.Match(Cobol85ParserDEPENDING)
			}
			p.SetState(4290)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == Cobol85ParserON {
				{
					p.SetState(4289)
					p.Match(Cobol85ParserON)
				}

			}
			{
				p.SetState(4292)
				p.Identifier()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IIfStatementContext is an interface to support dynamic dispatch.
type IIfStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIfStatementContext differentiates from other interfaces.
	IsIfStatementContext()
}

type IfStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfStatementContext() *IfStatementContext {
	var p = new(IfStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_ifStatement
	return p
}

func (*IfStatementContext) IsIfStatementContext() {}

func NewIfStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfStatementContext {
	var p = new(IfStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_ifStatement

	return p
}

func (s *IfStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *IfStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIF, 0)
}

func (s *IfStatementContext) Condition() IConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *IfStatementContext) IfThen() IIfThenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIfThenContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIfThenContext)
}

func (s *IfStatementContext) IfElse() IIfElseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIfElseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIfElseContext)
}

func (s *IfStatementContext) END_IF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND_IF, 0)
}

func (s *IfStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterIfStatement(s)
	}
}

func (s *IfStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitIfStatement(s)
	}
}

func (p *Cobol85Parser) IfStatement() (localctx IIfStatementContext) {
	localctx = NewIfStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 694, Cobol85ParserRULE_ifStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4297)
		p.Match(Cobol85ParserIF)
	}
	{
		p.SetState(4298)
		p.Condition()
	}
	{
		p.SetState(4299)
		p.IfThen()
	}
	p.SetState(4301)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 604, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4300)
			p.IfElse()
		}

	}
	p.SetState(4304)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 605, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4303)
			p.Match(Cobol85ParserEND_IF)
		}

	}

	return localctx
}

// IIfThenContext is an interface to support dynamic dispatch.
type IIfThenContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIfThenContext differentiates from other interfaces.
	IsIfThenContext()
}

type IfThenContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfThenContext() *IfThenContext {
	var p = new(IfThenContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_ifThen
	return p
}

func (*IfThenContext) IsIfThenContext() {}

func NewIfThenContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfThenContext {
	var p = new(IfThenContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_ifThen

	return p
}

func (s *IfThenContext) GetParser() antlr.Parser { return s.parser }

func (s *IfThenContext) NEXT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNEXT, 0)
}

func (s *IfThenContext) SENTENCE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSENTENCE, 0)
}

func (s *IfThenContext) THEN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHEN, 0)
}

func (s *IfThenContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *IfThenContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *IfThenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfThenContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfThenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterIfThen(s)
	}
}

func (s *IfThenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitIfThen(s)
	}
}

func (p *Cobol85Parser) IfThen() (localctx IIfThenContext) {
	localctx = NewIfThenContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 696, Cobol85ParserRULE_ifThen)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4307)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserTHEN {
		{
			p.SetState(4306)
			p.Match(Cobol85ParserTHEN)
		}

	}
	p.SetState(4317)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserNEXT:
		{
			p.SetState(4309)
			p.Match(Cobol85ParserNEXT)
		}
		{
			p.SetState(4310)
			p.Match(Cobol85ParserSENTENCE)
		}

	case Cobol85ParserACCEPT, Cobol85ParserADD, Cobol85ParserALTER, Cobol85ParserAT, Cobol85ParserCALL, Cobol85ParserCANCEL, Cobol85ParserCLOSE, Cobol85ParserCOMPUTE, Cobol85ParserCONTINUE, Cobol85ParserDELETE, Cobol85ParserDISABLE, Cobol85ParserDISPLAY, Cobol85ParserDIVIDE, Cobol85ParserELSE, Cobol85ParserENABLE, Cobol85ParserEND, Cobol85ParserEND_ACCEPT, Cobol85ParserEND_ADD, Cobol85ParserEND_CALL, Cobol85ParserEND_COMPUTE, Cobol85ParserEND_DELETE, Cobol85ParserEND_DIVIDE, Cobol85ParserEND_EVALUATE, Cobol85ParserEND_IF, Cobol85ParserEND_MULTIPLY, Cobol85ParserEND_PERFORM, Cobol85ParserEND_READ, Cobol85ParserEND_RECEIVE, Cobol85ParserEND_RETURN, Cobol85ParserEND_REWRITE, Cobol85ParserEND_SEARCH, Cobol85ParserEND_START, Cobol85ParserEND_STRING, Cobol85ParserEND_SUBTRACT, Cobol85ParserEND_UNSTRING, Cobol85ParserEND_WRITE, Cobol85ParserENTRY, Cobol85ParserEVALUATE, Cobol85ParserEXCEPTION, Cobol85ParserEXHIBIT, Cobol85ParserEXIT, Cobol85ParserGENERATE, Cobol85ParserGOBACK, Cobol85ParserGO, Cobol85ParserIF, Cobol85ParserINITIALIZE, Cobol85ParserINITIATE, Cobol85ParserINSPECT, Cobol85ParserINVALID, Cobol85ParserMERGE, Cobol85ParserMOVE, Cobol85ParserMULTIPLY, Cobol85ParserNOT, Cobol85ParserON, Cobol85ParserOPEN, Cobol85ParserPERFORM, Cobol85ParserPURGE, Cobol85ParserREAD, Cobol85ParserRECEIVE, Cobol85ParserRELEASE, Cobol85ParserRETURN, Cobol85ParserREWRITE, Cobol85ParserSEARCH, Cobol85ParserSEND, Cobol85ParserSET, Cobol85ParserSORT, Cobol85ParserSTART, Cobol85ParserSTOP, Cobol85ParserSTRING, Cobol85ParserSUBTRACT, Cobol85ParserTERMINATE, Cobol85ParserUNSTRING, Cobol85ParserWHEN, Cobol85ParserWITH, Cobol85ParserWRITE, Cobol85ParserDOT_FS, Cobol85ParserEXECCICSLINE, Cobol85ParserEXECSQLIMSLINE, Cobol85ParserEXECSQLLINE:
		p.SetState(4314)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 607, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(4311)
					p.Statement()
				}

			}
			p.SetState(4316)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 607, p.GetParserRuleContext())
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IIfElseContext is an interface to support dynamic dispatch.
type IIfElseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIfElseContext differentiates from other interfaces.
	IsIfElseContext()
}

type IfElseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfElseContext() *IfElseContext {
	var p = new(IfElseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_ifElse
	return p
}

func (*IfElseContext) IsIfElseContext() {}

func NewIfElseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfElseContext {
	var p = new(IfElseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_ifElse

	return p
}

func (s *IfElseContext) GetParser() antlr.Parser { return s.parser }

func (s *IfElseContext) ELSE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserELSE, 0)
}

func (s *IfElseContext) NEXT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNEXT, 0)
}

func (s *IfElseContext) SENTENCE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSENTENCE, 0)
}

func (s *IfElseContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *IfElseContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *IfElseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfElseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfElseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterIfElse(s)
	}
}

func (s *IfElseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitIfElse(s)
	}
}

func (p *Cobol85Parser) IfElse() (localctx IIfElseContext) {
	localctx = NewIfElseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 698, Cobol85ParserRULE_ifElse)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4319)
		p.Match(Cobol85ParserELSE)
	}
	p.SetState(4328)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserNEXT:
		{
			p.SetState(4320)
			p.Match(Cobol85ParserNEXT)
		}
		{
			p.SetState(4321)
			p.Match(Cobol85ParserSENTENCE)
		}

	case Cobol85ParserACCEPT, Cobol85ParserADD, Cobol85ParserALTER, Cobol85ParserAT, Cobol85ParserCALL, Cobol85ParserCANCEL, Cobol85ParserCLOSE, Cobol85ParserCOMPUTE, Cobol85ParserCONTINUE, Cobol85ParserDELETE, Cobol85ParserDISABLE, Cobol85ParserDISPLAY, Cobol85ParserDIVIDE, Cobol85ParserELSE, Cobol85ParserENABLE, Cobol85ParserEND, Cobol85ParserEND_ACCEPT, Cobol85ParserEND_ADD, Cobol85ParserEND_CALL, Cobol85ParserEND_COMPUTE, Cobol85ParserEND_DELETE, Cobol85ParserEND_DIVIDE, Cobol85ParserEND_EVALUATE, Cobol85ParserEND_IF, Cobol85ParserEND_MULTIPLY, Cobol85ParserEND_PERFORM, Cobol85ParserEND_READ, Cobol85ParserEND_RECEIVE, Cobol85ParserEND_RETURN, Cobol85ParserEND_REWRITE, Cobol85ParserEND_SEARCH, Cobol85ParserEND_START, Cobol85ParserEND_STRING, Cobol85ParserEND_SUBTRACT, Cobol85ParserEND_UNSTRING, Cobol85ParserEND_WRITE, Cobol85ParserENTRY, Cobol85ParserEVALUATE, Cobol85ParserEXCEPTION, Cobol85ParserEXHIBIT, Cobol85ParserEXIT, Cobol85ParserGENERATE, Cobol85ParserGOBACK, Cobol85ParserGO, Cobol85ParserIF, Cobol85ParserINITIALIZE, Cobol85ParserINITIATE, Cobol85ParserINSPECT, Cobol85ParserINVALID, Cobol85ParserMERGE, Cobol85ParserMOVE, Cobol85ParserMULTIPLY, Cobol85ParserNOT, Cobol85ParserON, Cobol85ParserOPEN, Cobol85ParserPERFORM, Cobol85ParserPURGE, Cobol85ParserREAD, Cobol85ParserRECEIVE, Cobol85ParserRELEASE, Cobol85ParserRETURN, Cobol85ParserREWRITE, Cobol85ParserSEARCH, Cobol85ParserSEND, Cobol85ParserSET, Cobol85ParserSORT, Cobol85ParserSTART, Cobol85ParserSTOP, Cobol85ParserSTRING, Cobol85ParserSUBTRACT, Cobol85ParserTERMINATE, Cobol85ParserUNSTRING, Cobol85ParserWHEN, Cobol85ParserWITH, Cobol85ParserWRITE, Cobol85ParserDOT_FS, Cobol85ParserEXECCICSLINE, Cobol85ParserEXECSQLIMSLINE, Cobol85ParserEXECSQLLINE:
		p.SetState(4325)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 609, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(4322)
					p.Statement()
				}

			}
			p.SetState(4327)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 609, p.GetParserRuleContext())
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IInitializeStatementContext is an interface to support dynamic dispatch.
type IInitializeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInitializeStatementContext differentiates from other interfaces.
	IsInitializeStatementContext()
}

type InitializeStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInitializeStatementContext() *InitializeStatementContext {
	var p = new(InitializeStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_initializeStatement
	return p
}

func (*InitializeStatementContext) IsInitializeStatementContext() {}

func NewInitializeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InitializeStatementContext {
	var p = new(InitializeStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_initializeStatement

	return p
}

func (s *InitializeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *InitializeStatementContext) INITIALIZE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINITIALIZE, 0)
}

func (s *InitializeStatementContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *InitializeStatementContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *InitializeStatementContext) InitializeReplacingPhrase() IInitializeReplacingPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInitializeReplacingPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInitializeReplacingPhraseContext)
}

func (s *InitializeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InitializeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InitializeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInitializeStatement(s)
	}
}

func (s *InitializeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInitializeStatement(s)
	}
}

func (p *Cobol85Parser) InitializeStatement() (localctx IInitializeStatementContext) {
	localctx = NewInitializeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 700, Cobol85ParserRULE_initializeStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4330)
		p.Match(Cobol85ParserINITIALIZE)
	}
	p.SetState(4332)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserADDRESS)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH)|(1<<Cobol85ParserATTRIBUTE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBINARY-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-68))|(1<<(Cobol85ParserCOBOL-68))|(1<<(Cobol85ParserCOMMITMENT-68))|(1<<(Cobol85ParserCONTROL_POINT-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(Cobol85ParserCONVENTION-100))|(1<<(Cobol85ParserCRUNCH-100))|(1<<(Cobol85ParserCURSOR-100))|(1<<(Cobol85ParserDATE-100))|(1<<(Cobol85ParserDAY-100))|(1<<(Cobol85ParserDAY_OF_WEEK-100))|(1<<(Cobol85ParserDEBUG_CONTENTS-100))|(1<<(Cobol85ParserDEBUG_ITEM-100))|(1<<(Cobol85ParserDEBUG_LINE-100))|(1<<(Cobol85ParserDEBUG_NAME-100))|(1<<(Cobol85ParserDEBUG_SUB_1-100))|(1<<(Cobol85ParserDEBUG_SUB_2-100))|(1<<(Cobol85ParserDEBUG_SUB_3-100))|(1<<(Cobol85ParserDEFAULT-100))|(1<<(Cobol85ParserDEFAULT_DISPLAY-100))|(1<<(Cobol85ParserDEFINITION-100)))) != 0) || (((_la-138)&-(0x1f+1)) == 0 && ((1<<uint((_la-138)))&((1<<(Cobol85ParserDFHRESP-138))|(1<<(Cobol85ParserDFHVALUE-138))|(1<<(Cobol85ParserDISK-138))|(1<<(Cobol85ParserDONTCARE-138))|(1<<(Cobol85ParserDOUBLE-138))|(1<<(Cobol85ParserEBCDIC-138))|(1<<(Cobol85ParserEMPTY_CHECK-138)))) != 0) || (((_la-181)&-(0x1f+1)) == 0 && ((1<<uint((_la-181)))&((1<<(Cobol85ParserENTER-181))|(1<<(Cobol85ParserENTRY_PROCEDURE-181))|(1<<(Cobol85ParserERASE-181))|(1<<(Cobol85ParserEOL-181))|(1<<(Cobol85ParserEOS-181))|(1<<(Cobol85ParserESCAPE-181))|(1<<(Cobol85ParserEVENT-181))|(1<<(Cobol85ParserEXCLUSIVE-181))|(1<<(Cobol85ParserEXPORT-181))|(1<<(Cobol85ParserEXTENDED-181)))) != 0) || (((_la-213)&-(0x1f+1)) == 0 && ((1<<uint((_la-213)))&((1<<(Cobol85ParserFOREGROUND_COLOR-213))|(1<<(Cobol85ParserFOREGROUND_COLOUR-213))|(1<<(Cobol85ParserFULL-213))|(1<<(Cobol85ParserFUNCTION-213))|(1<<(Cobol85ParserFUNCTIONNAME-213))|(1<<(Cobol85ParserFUNCTION_POINTER-213))|(1<<(Cobol85ParserGRID-213))|(1<<(Cobol85ParserHIGHLIGHT-213))|(1<<(Cobol85ParserIMPLICIT-213))|(1<<(Cobol85ParserIMPORT-213)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(Cobol85ParserINTEGER-250))|(1<<(Cobol85ParserKEPT-250))|(1<<(Cobol85ParserKEYBOARD-250))|(1<<(Cobol85ParserLANGUAGE-250))|(1<<(Cobol85ParserLB-250))|(1<<(Cobol85ParserLD-250))|(1<<(Cobol85ParserLEFTLINE-250))|(1<<(Cobol85ParserLENGTH-250))|(1<<(Cobol85ParserLENGTH_CHECK-250))|(1<<(Cobol85ParserLIBACCESS-250))|(1<<(Cobol85ParserLIBPARAMETER-250))|(1<<(Cobol85ParserLIBRARY-250))|(1<<(Cobol85ParserLINAGE_COUNTER-250))|(1<<(Cobol85ParserLINE_COUNTER-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(Cobol85ParserLIST-283))|(1<<(Cobol85ParserLOCAL-283))|(1<<(Cobol85ParserLONG_DATE-283))|(1<<(Cobol85ParserLONG_TIME-283))|(1<<(Cobol85ParserLOWER-283))|(1<<(Cobol85ParserLOWLIGHT-283))|(1<<(Cobol85ParserMMDDYYYY-283))|(1<<(Cobol85ParserNAMED-283))|(1<<(Cobol85ParserNATIONAL-283))|(1<<(Cobol85ParserNATIONAL_EDITED-283))|(1<<(Cobol85ParserNETWORK-283))|(1<<(Cobol85ParserNO_ECHO-283)))) != 0) || (((_la-317)&-(0x1f+1)) == 0 && ((1<<uint((_la-317)))&((1<<(Cobol85ParserNUMERIC_DATE-317))|(1<<(Cobol85ParserNUMERIC_TIME-317))|(1<<(Cobol85ParserODT-317))|(1<<(Cobol85ParserORDERLY-317))|(1<<(Cobol85ParserOVERLINE-317))|(1<<(Cobol85ParserOWN-317))|(1<<(Cobol85ParserPAGE_COUNTER-317))|(1<<(Cobol85ParserPASSWORD-317)))) != 0) || (((_la-352)&-(0x1f+1)) == 0 && ((1<<uint((_la-352)))&((1<<(Cobol85ParserPORT-352))|(1<<(Cobol85ParserPRINTER-352))|(1<<(Cobol85ParserPRIVATE-352))|(1<<(Cobol85ParserPROCESS-352))|(1<<(Cobol85ParserPROGRAM-352))|(1<<(Cobol85ParserPROMPT-352))|(1<<(Cobol85ParserREADER-352))|(1<<(Cobol85ParserREMOTE-352))|(1<<(Cobol85ParserREAL-352))|(1<<(Cobol85ParserRECEIVED-352))|(1<<(Cobol85ParserRECURSIVE-352))|(1<<(Cobol85ParserREF-352)))) != 0) || (((_la-391)&-(0x1f+1)) == 0 && ((1<<uint((_la-391)))&((1<<(Cobol85ParserREMOVE-391))|(1<<(Cobol85ParserREQUIRED-391))|(1<<(Cobol85ParserREVERSE_VIDEO-391))|(1<<(Cobol85ParserRETURN_CODE-391))|(1<<(Cobol85ParserSAVE-391))|(1<<(Cobol85ParserSECURE-391)))) != 0) || (((_la-431)&-(0x1f+1)) == 0 && ((1<<uint((_la-431)))&((1<<(Cobol85ParserSHARED-431))|(1<<(Cobol85ParserSHAREDBYALL-431))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-431))|(1<<(Cobol85ParserSHARING-431))|(1<<(Cobol85ParserSHIFT_IN-431))|(1<<(Cobol85ParserSHIFT_OUT-431))|(1<<(Cobol85ParserSHORT_DATE-431))|(1<<(Cobol85ParserSORT_CONTROL-431))|(1<<(Cobol85ParserSORT_CORE_SIZE-431))|(1<<(Cobol85ParserSORT_FILE_SIZE-431))|(1<<(Cobol85ParserSORT_MESSAGE-431))|(1<<(Cobol85ParserSORT_MODE_SIZE-431))|(1<<(Cobol85ParserSORT_RETURN-431)))) != 0) || (((_la-466)&-(0x1f+1)) == 0 && ((1<<uint((_la-466)))&((1<<(Cobol85ParserSYMBOL-466))|(1<<(Cobol85ParserTALLY-466))|(1<<(Cobol85ParserTASK-466))|(1<<(Cobol85ParserTHREAD-466))|(1<<(Cobol85ParserTHREAD_LOCAL-466))|(1<<(Cobol85ParserTIME-466))|(1<<(Cobol85ParserTIMER-466))|(1<<(Cobol85ParserTODAYS_DATE-466))|(1<<(Cobol85ParserTODAYS_NAME-466))|(1<<(Cobol85ParserTRUNCATED-466))|(1<<(Cobol85ParserTYPEDEF-466)))) != 0) || (((_la-498)&-(0x1f+1)) == 0 && ((1<<uint((_la-498)))&((1<<(Cobol85ParserUNDERLINE-498))|(1<<(Cobol85ParserVIRTUAL-498))|(1<<(Cobol85ParserWAIT-498))|(1<<(Cobol85ParserWHEN_COMPILED-498))|(1<<(Cobol85ParserYEAR-498))|(1<<(Cobol85ParserYYYYMMDD-498))|(1<<(Cobol85ParserYYYYDDD-498))|(1<<(Cobol85ParserZERO_FILL-498)))) != 0) || (((_la-552)&-(0x1f+1)) == 0 && ((1<<uint((_la-552)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-552))|(1<<(Cobol85ParserLEVEL_NUMBER_77-552))|(1<<(Cobol85ParserLEVEL_NUMBER_88-552))|(1<<(Cobol85ParserINTEGERLITERAL-552))|(1<<(Cobol85ParserIDENTIFIER-552)))) != 0) {
		{
			p.SetState(4331)
			p.Identifier()
		}

		p.SetState(4334)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(4337)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserREPLACING {
		{
			p.SetState(4336)
			p.InitializeReplacingPhrase()
		}

	}

	return localctx
}

// IInitializeReplacingPhraseContext is an interface to support dynamic dispatch.
type IInitializeReplacingPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInitializeReplacingPhraseContext differentiates from other interfaces.
	IsInitializeReplacingPhraseContext()
}

type InitializeReplacingPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInitializeReplacingPhraseContext() *InitializeReplacingPhraseContext {
	var p = new(InitializeReplacingPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_initializeReplacingPhrase
	return p
}

func (*InitializeReplacingPhraseContext) IsInitializeReplacingPhraseContext() {}

func NewInitializeReplacingPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InitializeReplacingPhraseContext {
	var p = new(InitializeReplacingPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_initializeReplacingPhrase

	return p
}

func (s *InitializeReplacingPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *InitializeReplacingPhraseContext) REPLACING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREPLACING, 0)
}

func (s *InitializeReplacingPhraseContext) AllInitializeReplacingBy() []IInitializeReplacingByContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInitializeReplacingByContext)(nil)).Elem())
	var tst = make([]IInitializeReplacingByContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInitializeReplacingByContext)
		}
	}

	return tst
}

func (s *InitializeReplacingPhraseContext) InitializeReplacingBy(i int) IInitializeReplacingByContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInitializeReplacingByContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInitializeReplacingByContext)
}

func (s *InitializeReplacingPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InitializeReplacingPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InitializeReplacingPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInitializeReplacingPhrase(s)
	}
}

func (s *InitializeReplacingPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInitializeReplacingPhrase(s)
	}
}

func (p *Cobol85Parser) InitializeReplacingPhrase() (localctx IInitializeReplacingPhraseContext) {
	localctx = NewInitializeReplacingPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 702, Cobol85ParserRULE_initializeReplacingPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4339)
		p.Match(Cobol85ParserREPLACING)
	}
	p.SetState(4341)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserALPHABETIC)|(1<<Cobol85ParserALPHANUMERIC)|(1<<Cobol85ParserALPHANUMERIC_EDITED))) != 0) || _la == Cobol85ParserDBCS || _la == Cobol85ParserEGCS || (((_la-304)&-(0x1f+1)) == 0 && ((1<<uint((_la-304)))&((1<<(Cobol85ParserNATIONAL-304))|(1<<(Cobol85ParserNATIONAL_EDITED-304))|(1<<(Cobol85ParserNUMERIC-304))|(1<<(Cobol85ParserNUMERIC_EDITED-304)))) != 0) {
		{
			p.SetState(4340)
			p.InitializeReplacingBy()
		}

		p.SetState(4343)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IInitializeReplacingByContext is an interface to support dynamic dispatch.
type IInitializeReplacingByContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInitializeReplacingByContext differentiates from other interfaces.
	IsInitializeReplacingByContext()
}

type InitializeReplacingByContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInitializeReplacingByContext() *InitializeReplacingByContext {
	var p = new(InitializeReplacingByContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_initializeReplacingBy
	return p
}

func (*InitializeReplacingByContext) IsInitializeReplacingByContext() {}

func NewInitializeReplacingByContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InitializeReplacingByContext {
	var p = new(InitializeReplacingByContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_initializeReplacingBy

	return p
}

func (s *InitializeReplacingByContext) GetParser() antlr.Parser { return s.parser }

func (s *InitializeReplacingByContext) BY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBY, 0)
}

func (s *InitializeReplacingByContext) ALPHABETIC() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALPHABETIC, 0)
}

func (s *InitializeReplacingByContext) ALPHANUMERIC() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALPHANUMERIC, 0)
}

func (s *InitializeReplacingByContext) ALPHANUMERIC_EDITED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALPHANUMERIC_EDITED, 0)
}

func (s *InitializeReplacingByContext) NATIONAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNATIONAL, 0)
}

func (s *InitializeReplacingByContext) NATIONAL_EDITED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNATIONAL_EDITED, 0)
}

func (s *InitializeReplacingByContext) NUMERIC() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNUMERIC, 0)
}

func (s *InitializeReplacingByContext) NUMERIC_EDITED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNUMERIC_EDITED, 0)
}

func (s *InitializeReplacingByContext) DBCS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDBCS, 0)
}

func (s *InitializeReplacingByContext) EGCS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEGCS, 0)
}

func (s *InitializeReplacingByContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *InitializeReplacingByContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *InitializeReplacingByContext) DATA() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDATA, 0)
}

func (s *InitializeReplacingByContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InitializeReplacingByContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InitializeReplacingByContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInitializeReplacingBy(s)
	}
}

func (s *InitializeReplacingByContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInitializeReplacingBy(s)
	}
}

func (p *Cobol85Parser) InitializeReplacingBy() (localctx IInitializeReplacingByContext) {
	localctx = NewInitializeReplacingByContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 704, Cobol85ParserRULE_initializeReplacingBy)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4345)
		_la = p.GetTokenStream().LA(1)

		if !((((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserALPHABETIC)|(1<<Cobol85ParserALPHANUMERIC)|(1<<Cobol85ParserALPHANUMERIC_EDITED))) != 0) || _la == Cobol85ParserDBCS || _la == Cobol85ParserEGCS || (((_la-304)&-(0x1f+1)) == 0 && ((1<<uint((_la-304)))&((1<<(Cobol85ParserNATIONAL-304))|(1<<(Cobol85ParserNATIONAL_EDITED-304))|(1<<(Cobol85ParserNUMERIC-304))|(1<<(Cobol85ParserNUMERIC_EDITED-304)))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(4347)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserDATA {
		{
			p.SetState(4346)
			p.Match(Cobol85ParserDATA)
		}

	}
	{
		p.SetState(4349)
		p.Match(Cobol85ParserBY)
	}
	p.SetState(4352)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 615, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4350)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(4351)
			p.Literal()
		}

	}

	return localctx
}

// IInitiateStatementContext is an interface to support dynamic dispatch.
type IInitiateStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInitiateStatementContext differentiates from other interfaces.
	IsInitiateStatementContext()
}

type InitiateStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInitiateStatementContext() *InitiateStatementContext {
	var p = new(InitiateStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_initiateStatement
	return p
}

func (*InitiateStatementContext) IsInitiateStatementContext() {}

func NewInitiateStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InitiateStatementContext {
	var p = new(InitiateStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_initiateStatement

	return p
}

func (s *InitiateStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *InitiateStatementContext) INITIATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINITIATE, 0)
}

func (s *InitiateStatementContext) AllReportName() []IReportNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IReportNameContext)(nil)).Elem())
	var tst = make([]IReportNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IReportNameContext)
		}
	}

	return tst
}

func (s *InitiateStatementContext) ReportName(i int) IReportNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IReportNameContext)
}

func (s *InitiateStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InitiateStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InitiateStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInitiateStatement(s)
	}
}

func (s *InitiateStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInitiateStatement(s)
	}
}

func (p *Cobol85Parser) InitiateStatement() (localctx IInitiateStatementContext) {
	localctx = NewInitiateStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 706, Cobol85ParserRULE_initiateStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4354)
		p.Match(Cobol85ParserINITIATE)
	}
	p.SetState(4356)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH)|(1<<Cobol85ParserATTRIBUTE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBINARY-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-68))|(1<<(Cobol85ParserCOBOL-68))|(1<<(Cobol85ParserCOMMITMENT-68))|(1<<(Cobol85ParserCONTROL_POINT-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(Cobol85ParserCONVENTION-100))|(1<<(Cobol85ParserCRUNCH-100))|(1<<(Cobol85ParserCURSOR-100))|(1<<(Cobol85ParserDEFAULT-100))|(1<<(Cobol85ParserDEFAULT_DISPLAY-100))|(1<<(Cobol85ParserDEFINITION-100)))) != 0) || (((_la-138)&-(0x1f+1)) == 0 && ((1<<uint((_la-138)))&((1<<(Cobol85ParserDFHRESP-138))|(1<<(Cobol85ParserDFHVALUE-138))|(1<<(Cobol85ParserDISK-138))|(1<<(Cobol85ParserDONTCARE-138))|(1<<(Cobol85ParserDOUBLE-138))|(1<<(Cobol85ParserEBCDIC-138))|(1<<(Cobol85ParserEMPTY_CHECK-138)))) != 0) || (((_la-181)&-(0x1f+1)) == 0 && ((1<<uint((_la-181)))&((1<<(Cobol85ParserENTER-181))|(1<<(Cobol85ParserENTRY_PROCEDURE-181))|(1<<(Cobol85ParserERASE-181))|(1<<(Cobol85ParserEOL-181))|(1<<(Cobol85ParserEOS-181))|(1<<(Cobol85ParserESCAPE-181))|(1<<(Cobol85ParserEVENT-181))|(1<<(Cobol85ParserEXCLUSIVE-181))|(1<<(Cobol85ParserEXPORT-181))|(1<<(Cobol85ParserEXTENDED-181)))) != 0) || (((_la-213)&-(0x1f+1)) == 0 && ((1<<uint((_la-213)))&((1<<(Cobol85ParserFOREGROUND_COLOR-213))|(1<<(Cobol85ParserFOREGROUND_COLOUR-213))|(1<<(Cobol85ParserFULL-213))|(1<<(Cobol85ParserFUNCTIONNAME-213))|(1<<(Cobol85ParserFUNCTION_POINTER-213))|(1<<(Cobol85ParserGRID-213))|(1<<(Cobol85ParserHIGHLIGHT-213))|(1<<(Cobol85ParserIMPLICIT-213))|(1<<(Cobol85ParserIMPORT-213)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(Cobol85ParserINTEGER-250))|(1<<(Cobol85ParserKEPT-250))|(1<<(Cobol85ParserKEYBOARD-250))|(1<<(Cobol85ParserLANGUAGE-250))|(1<<(Cobol85ParserLB-250))|(1<<(Cobol85ParserLD-250))|(1<<(Cobol85ParserLEFTLINE-250))|(1<<(Cobol85ParserLENGTH_CHECK-250))|(1<<(Cobol85ParserLIBACCESS-250))|(1<<(Cobol85ParserLIBPARAMETER-250))|(1<<(Cobol85ParserLIBRARY-250))|(1<<(Cobol85ParserLINAGE_COUNTER-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(Cobol85ParserLIST-283))|(1<<(Cobol85ParserLOCAL-283))|(1<<(Cobol85ParserLONG_DATE-283))|(1<<(Cobol85ParserLONG_TIME-283))|(1<<(Cobol85ParserLOWER-283))|(1<<(Cobol85ParserLOWLIGHT-283))|(1<<(Cobol85ParserMMDDYYYY-283))|(1<<(Cobol85ParserNAMED-283))|(1<<(Cobol85ParserNATIONAL-283))|(1<<(Cobol85ParserNATIONAL_EDITED-283))|(1<<(Cobol85ParserNETWORK-283))|(1<<(Cobol85ParserNO_ECHO-283)))) != 0) || (((_la-317)&-(0x1f+1)) == 0 && ((1<<uint((_la-317)))&((1<<(Cobol85ParserNUMERIC_DATE-317))|(1<<(Cobol85ParserNUMERIC_TIME-317))|(1<<(Cobol85ParserODT-317))|(1<<(Cobol85ParserORDERLY-317))|(1<<(Cobol85ParserOVERLINE-317))|(1<<(Cobol85ParserOWN-317))|(1<<(Cobol85ParserPASSWORD-317)))) != 0) || (((_la-352)&-(0x1f+1)) == 0 && ((1<<uint((_la-352)))&((1<<(Cobol85ParserPORT-352))|(1<<(Cobol85ParserPRINTER-352))|(1<<(Cobol85ParserPRIVATE-352))|(1<<(Cobol85ParserPROCESS-352))|(1<<(Cobol85ParserPROGRAM-352))|(1<<(Cobol85ParserPROMPT-352))|(1<<(Cobol85ParserREADER-352))|(1<<(Cobol85ParserREMOTE-352))|(1<<(Cobol85ParserREAL-352))|(1<<(Cobol85ParserRECEIVED-352))|(1<<(Cobol85ParserRECURSIVE-352))|(1<<(Cobol85ParserREF-352)))) != 0) || (((_la-391)&-(0x1f+1)) == 0 && ((1<<uint((_la-391)))&((1<<(Cobol85ParserREMOVE-391))|(1<<(Cobol85ParserREQUIRED-391))|(1<<(Cobol85ParserREVERSE_VIDEO-391))|(1<<(Cobol85ParserSAVE-391))|(1<<(Cobol85ParserSECURE-391)))) != 0) || (((_la-431)&-(0x1f+1)) == 0 && ((1<<uint((_la-431)))&((1<<(Cobol85ParserSHARED-431))|(1<<(Cobol85ParserSHAREDBYALL-431))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-431))|(1<<(Cobol85ParserSHARING-431))|(1<<(Cobol85ParserSHORT_DATE-431)))) != 0) || (((_la-466)&-(0x1f+1)) == 0 && ((1<<uint((_la-466)))&((1<<(Cobol85ParserSYMBOL-466))|(1<<(Cobol85ParserTASK-466))|(1<<(Cobol85ParserTHREAD-466))|(1<<(Cobol85ParserTHREAD_LOCAL-466))|(1<<(Cobol85ParserTIMER-466))|(1<<(Cobol85ParserTODAYS_DATE-466))|(1<<(Cobol85ParserTODAYS_NAME-466))|(1<<(Cobol85ParserTRUNCATED-466))|(1<<(Cobol85ParserTYPEDEF-466)))) != 0) || (((_la-498)&-(0x1f+1)) == 0 && ((1<<uint((_la-498)))&((1<<(Cobol85ParserUNDERLINE-498))|(1<<(Cobol85ParserVIRTUAL-498))|(1<<(Cobol85ParserWAIT-498))|(1<<(Cobol85ParserYEAR-498))|(1<<(Cobol85ParserYYYYMMDD-498))|(1<<(Cobol85ParserYYYYDDD-498))|(1<<(Cobol85ParserZERO_FILL-498)))) != 0) || (((_la-552)&-(0x1f+1)) == 0 && ((1<<uint((_la-552)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-552))|(1<<(Cobol85ParserLEVEL_NUMBER_77-552))|(1<<(Cobol85ParserLEVEL_NUMBER_88-552))|(1<<(Cobol85ParserINTEGERLITERAL-552))|(1<<(Cobol85ParserIDENTIFIER-552)))) != 0) {
		{
			p.SetState(4355)
			p.ReportName()
		}

		p.SetState(4358)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IInspectStatementContext is an interface to support dynamic dispatch.
type IInspectStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInspectStatementContext differentiates from other interfaces.
	IsInspectStatementContext()
}

type InspectStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInspectStatementContext() *InspectStatementContext {
	var p = new(InspectStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_inspectStatement
	return p
}

func (*InspectStatementContext) IsInspectStatementContext() {}

func NewInspectStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InspectStatementContext {
	var p = new(InspectStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_inspectStatement

	return p
}

func (s *InspectStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *InspectStatementContext) INSPECT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINSPECT, 0)
}

func (s *InspectStatementContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *InspectStatementContext) InspectTallyingPhrase() IInspectTallyingPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInspectTallyingPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInspectTallyingPhraseContext)
}

func (s *InspectStatementContext) InspectReplacingPhrase() IInspectReplacingPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInspectReplacingPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInspectReplacingPhraseContext)
}

func (s *InspectStatementContext) InspectTallyingReplacingPhrase() IInspectTallyingReplacingPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInspectTallyingReplacingPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInspectTallyingReplacingPhraseContext)
}

func (s *InspectStatementContext) InspectConvertingPhrase() IInspectConvertingPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInspectConvertingPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInspectConvertingPhraseContext)
}

func (s *InspectStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InspectStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InspectStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInspectStatement(s)
	}
}

func (s *InspectStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInspectStatement(s)
	}
}

func (p *Cobol85Parser) InspectStatement() (localctx IInspectStatementContext) {
	localctx = NewInspectStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 708, Cobol85ParserRULE_inspectStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4360)
		p.Match(Cobol85ParserINSPECT)
	}
	{
		p.SetState(4361)
		p.Identifier()
	}
	p.SetState(4366)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 617, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4362)
			p.InspectTallyingPhrase()
		}

	case 2:
		{
			p.SetState(4363)
			p.InspectReplacingPhrase()
		}

	case 3:
		{
			p.SetState(4364)
			p.InspectTallyingReplacingPhrase()
		}

	case 4:
		{
			p.SetState(4365)
			p.InspectConvertingPhrase()
		}

	}

	return localctx
}

// IInspectTallyingPhraseContext is an interface to support dynamic dispatch.
type IInspectTallyingPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInspectTallyingPhraseContext differentiates from other interfaces.
	IsInspectTallyingPhraseContext()
}

type InspectTallyingPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInspectTallyingPhraseContext() *InspectTallyingPhraseContext {
	var p = new(InspectTallyingPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_inspectTallyingPhrase
	return p
}

func (*InspectTallyingPhraseContext) IsInspectTallyingPhraseContext() {}

func NewInspectTallyingPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InspectTallyingPhraseContext {
	var p = new(InspectTallyingPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_inspectTallyingPhrase

	return p
}

func (s *InspectTallyingPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *InspectTallyingPhraseContext) TALLYING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTALLYING, 0)
}

func (s *InspectTallyingPhraseContext) AllInspectFor() []IInspectForContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInspectForContext)(nil)).Elem())
	var tst = make([]IInspectForContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInspectForContext)
		}
	}

	return tst
}

func (s *InspectTallyingPhraseContext) InspectFor(i int) IInspectForContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInspectForContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInspectForContext)
}

func (s *InspectTallyingPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InspectTallyingPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InspectTallyingPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInspectTallyingPhrase(s)
	}
}

func (s *InspectTallyingPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInspectTallyingPhrase(s)
	}
}

func (p *Cobol85Parser) InspectTallyingPhrase() (localctx IInspectTallyingPhraseContext) {
	localctx = NewInspectTallyingPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 710, Cobol85ParserRULE_inspectTallyingPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4368)
		p.Match(Cobol85ParserTALLYING)
	}
	p.SetState(4370)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserADDRESS)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH)|(1<<Cobol85ParserATTRIBUTE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBINARY-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-68))|(1<<(Cobol85ParserCOBOL-68))|(1<<(Cobol85ParserCOMMITMENT-68))|(1<<(Cobol85ParserCONTROL_POINT-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(Cobol85ParserCONVENTION-100))|(1<<(Cobol85ParserCRUNCH-100))|(1<<(Cobol85ParserCURSOR-100))|(1<<(Cobol85ParserDATE-100))|(1<<(Cobol85ParserDAY-100))|(1<<(Cobol85ParserDAY_OF_WEEK-100))|(1<<(Cobol85ParserDEBUG_CONTENTS-100))|(1<<(Cobol85ParserDEBUG_ITEM-100))|(1<<(Cobol85ParserDEBUG_LINE-100))|(1<<(Cobol85ParserDEBUG_NAME-100))|(1<<(Cobol85ParserDEBUG_SUB_1-100))|(1<<(Cobol85ParserDEBUG_SUB_2-100))|(1<<(Cobol85ParserDEBUG_SUB_3-100))|(1<<(Cobol85ParserDEFAULT-100))|(1<<(Cobol85ParserDEFAULT_DISPLAY-100))|(1<<(Cobol85ParserDEFINITION-100)))) != 0) || (((_la-138)&-(0x1f+1)) == 0 && ((1<<uint((_la-138)))&((1<<(Cobol85ParserDFHRESP-138))|(1<<(Cobol85ParserDFHVALUE-138))|(1<<(Cobol85ParserDISK-138))|(1<<(Cobol85ParserDONTCARE-138))|(1<<(Cobol85ParserDOUBLE-138))|(1<<(Cobol85ParserEBCDIC-138))|(1<<(Cobol85ParserEMPTY_CHECK-138)))) != 0) || (((_la-181)&-(0x1f+1)) == 0 && ((1<<uint((_la-181)))&((1<<(Cobol85ParserENTER-181))|(1<<(Cobol85ParserENTRY_PROCEDURE-181))|(1<<(Cobol85ParserERASE-181))|(1<<(Cobol85ParserEOL-181))|(1<<(Cobol85ParserEOS-181))|(1<<(Cobol85ParserESCAPE-181))|(1<<(Cobol85ParserEVENT-181))|(1<<(Cobol85ParserEXCLUSIVE-181))|(1<<(Cobol85ParserEXPORT-181))|(1<<(Cobol85ParserEXTENDED-181)))) != 0) || (((_la-213)&-(0x1f+1)) == 0 && ((1<<uint((_la-213)))&((1<<(Cobol85ParserFOREGROUND_COLOR-213))|(1<<(Cobol85ParserFOREGROUND_COLOUR-213))|(1<<(Cobol85ParserFULL-213))|(1<<(Cobol85ParserFUNCTION-213))|(1<<(Cobol85ParserFUNCTIONNAME-213))|(1<<(Cobol85ParserFUNCTION_POINTER-213))|(1<<(Cobol85ParserGRID-213))|(1<<(Cobol85ParserHIGHLIGHT-213))|(1<<(Cobol85ParserIMPLICIT-213))|(1<<(Cobol85ParserIMPORT-213)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(Cobol85ParserINTEGER-250))|(1<<(Cobol85ParserKEPT-250))|(1<<(Cobol85ParserKEYBOARD-250))|(1<<(Cobol85ParserLANGUAGE-250))|(1<<(Cobol85ParserLB-250))|(1<<(Cobol85ParserLD-250))|(1<<(Cobol85ParserLEFTLINE-250))|(1<<(Cobol85ParserLENGTH-250))|(1<<(Cobol85ParserLENGTH_CHECK-250))|(1<<(Cobol85ParserLIBACCESS-250))|(1<<(Cobol85ParserLIBPARAMETER-250))|(1<<(Cobol85ParserLIBRARY-250))|(1<<(Cobol85ParserLINAGE_COUNTER-250))|(1<<(Cobol85ParserLINE_COUNTER-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(Cobol85ParserLIST-283))|(1<<(Cobol85ParserLOCAL-283))|(1<<(Cobol85ParserLONG_DATE-283))|(1<<(Cobol85ParserLONG_TIME-283))|(1<<(Cobol85ParserLOWER-283))|(1<<(Cobol85ParserLOWLIGHT-283))|(1<<(Cobol85ParserMMDDYYYY-283))|(1<<(Cobol85ParserNAMED-283))|(1<<(Cobol85ParserNATIONAL-283))|(1<<(Cobol85ParserNATIONAL_EDITED-283))|(1<<(Cobol85ParserNETWORK-283))|(1<<(Cobol85ParserNO_ECHO-283)))) != 0) || (((_la-317)&-(0x1f+1)) == 0 && ((1<<uint((_la-317)))&((1<<(Cobol85ParserNUMERIC_DATE-317))|(1<<(Cobol85ParserNUMERIC_TIME-317))|(1<<(Cobol85ParserODT-317))|(1<<(Cobol85ParserORDERLY-317))|(1<<(Cobol85ParserOVERLINE-317))|(1<<(Cobol85ParserOWN-317))|(1<<(Cobol85ParserPAGE_COUNTER-317))|(1<<(Cobol85ParserPASSWORD-317)))) != 0) || (((_la-352)&-(0x1f+1)) == 0 && ((1<<uint((_la-352)))&((1<<(Cobol85ParserPORT-352))|(1<<(Cobol85ParserPRINTER-352))|(1<<(Cobol85ParserPRIVATE-352))|(1<<(Cobol85ParserPROCESS-352))|(1<<(Cobol85ParserPROGRAM-352))|(1<<(Cobol85ParserPROMPT-352))|(1<<(Cobol85ParserREADER-352))|(1<<(Cobol85ParserREMOTE-352))|(1<<(Cobol85ParserREAL-352))|(1<<(Cobol85ParserRECEIVED-352))|(1<<(Cobol85ParserRECURSIVE-352))|(1<<(Cobol85ParserREF-352)))) != 0) || (((_la-391)&-(0x1f+1)) == 0 && ((1<<uint((_la-391)))&((1<<(Cobol85ParserREMOVE-391))|(1<<(Cobol85ParserREQUIRED-391))|(1<<(Cobol85ParserREVERSE_VIDEO-391))|(1<<(Cobol85ParserRETURN_CODE-391))|(1<<(Cobol85ParserSAVE-391))|(1<<(Cobol85ParserSECURE-391)))) != 0) || (((_la-431)&-(0x1f+1)) == 0 && ((1<<uint((_la-431)))&((1<<(Cobol85ParserSHARED-431))|(1<<(Cobol85ParserSHAREDBYALL-431))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-431))|(1<<(Cobol85ParserSHARING-431))|(1<<(Cobol85ParserSHIFT_IN-431))|(1<<(Cobol85ParserSHIFT_OUT-431))|(1<<(Cobol85ParserSHORT_DATE-431))|(1<<(Cobol85ParserSORT_CONTROL-431))|(1<<(Cobol85ParserSORT_CORE_SIZE-431))|(1<<(Cobol85ParserSORT_FILE_SIZE-431))|(1<<(Cobol85ParserSORT_MESSAGE-431))|(1<<(Cobol85ParserSORT_MODE_SIZE-431))|(1<<(Cobol85ParserSORT_RETURN-431)))) != 0) || (((_la-466)&-(0x1f+1)) == 0 && ((1<<uint((_la-466)))&((1<<(Cobol85ParserSYMBOL-466))|(1<<(Cobol85ParserTALLY-466))|(1<<(Cobol85ParserTASK-466))|(1<<(Cobol85ParserTHREAD-466))|(1<<(Cobol85ParserTHREAD_LOCAL-466))|(1<<(Cobol85ParserTIME-466))|(1<<(Cobol85ParserTIMER-466))|(1<<(Cobol85ParserTODAYS_DATE-466))|(1<<(Cobol85ParserTODAYS_NAME-466))|(1<<(Cobol85ParserTRUNCATED-466))|(1<<(Cobol85ParserTYPEDEF-466)))) != 0) || (((_la-498)&-(0x1f+1)) == 0 && ((1<<uint((_la-498)))&((1<<(Cobol85ParserUNDERLINE-498))|(1<<(Cobol85ParserVIRTUAL-498))|(1<<(Cobol85ParserWAIT-498))|(1<<(Cobol85ParserWHEN_COMPILED-498))|(1<<(Cobol85ParserYEAR-498))|(1<<(Cobol85ParserYYYYMMDD-498))|(1<<(Cobol85ParserYYYYDDD-498))|(1<<(Cobol85ParserZERO_FILL-498)))) != 0) || (((_la-552)&-(0x1f+1)) == 0 && ((1<<uint((_la-552)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-552))|(1<<(Cobol85ParserLEVEL_NUMBER_77-552))|(1<<(Cobol85ParserLEVEL_NUMBER_88-552))|(1<<(Cobol85ParserINTEGERLITERAL-552))|(1<<(Cobol85ParserIDENTIFIER-552)))) != 0) {
		{
			p.SetState(4369)
			p.InspectFor()
		}

		p.SetState(4372)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IInspectReplacingPhraseContext is an interface to support dynamic dispatch.
type IInspectReplacingPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInspectReplacingPhraseContext differentiates from other interfaces.
	IsInspectReplacingPhraseContext()
}

type InspectReplacingPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInspectReplacingPhraseContext() *InspectReplacingPhraseContext {
	var p = new(InspectReplacingPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_inspectReplacingPhrase
	return p
}

func (*InspectReplacingPhraseContext) IsInspectReplacingPhraseContext() {}

func NewInspectReplacingPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InspectReplacingPhraseContext {
	var p = new(InspectReplacingPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_inspectReplacingPhrase

	return p
}

func (s *InspectReplacingPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *InspectReplacingPhraseContext) REPLACING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREPLACING, 0)
}

func (s *InspectReplacingPhraseContext) AllInspectReplacingCharacters() []IInspectReplacingCharactersContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInspectReplacingCharactersContext)(nil)).Elem())
	var tst = make([]IInspectReplacingCharactersContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInspectReplacingCharactersContext)
		}
	}

	return tst
}

func (s *InspectReplacingPhraseContext) InspectReplacingCharacters(i int) IInspectReplacingCharactersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInspectReplacingCharactersContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInspectReplacingCharactersContext)
}

func (s *InspectReplacingPhraseContext) AllInspectReplacingAllLeadings() []IInspectReplacingAllLeadingsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInspectReplacingAllLeadingsContext)(nil)).Elem())
	var tst = make([]IInspectReplacingAllLeadingsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInspectReplacingAllLeadingsContext)
		}
	}

	return tst
}

func (s *InspectReplacingPhraseContext) InspectReplacingAllLeadings(i int) IInspectReplacingAllLeadingsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInspectReplacingAllLeadingsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInspectReplacingAllLeadingsContext)
}

func (s *InspectReplacingPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InspectReplacingPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InspectReplacingPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInspectReplacingPhrase(s)
	}
}

func (s *InspectReplacingPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInspectReplacingPhrase(s)
	}
}

func (p *Cobol85Parser) InspectReplacingPhrase() (localctx IInspectReplacingPhraseContext) {
	localctx = NewInspectReplacingPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 712, Cobol85ParserRULE_inspectReplacingPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4374)
		p.Match(Cobol85ParserREPLACING)
	}
	p.SetState(4377)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == Cobol85ParserALL || _la == Cobol85ParserCHARACTERS || _la == Cobol85ParserFIRST || _la == Cobol85ParserLEADING {
		p.SetState(4377)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case Cobol85ParserCHARACTERS:
			{
				p.SetState(4375)
				p.InspectReplacingCharacters()
			}

		case Cobol85ParserALL, Cobol85ParserFIRST, Cobol85ParserLEADING:
			{
				p.SetState(4376)
				p.InspectReplacingAllLeadings()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(4379)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IInspectTallyingReplacingPhraseContext is an interface to support dynamic dispatch.
type IInspectTallyingReplacingPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInspectTallyingReplacingPhraseContext differentiates from other interfaces.
	IsInspectTallyingReplacingPhraseContext()
}

type InspectTallyingReplacingPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInspectTallyingReplacingPhraseContext() *InspectTallyingReplacingPhraseContext {
	var p = new(InspectTallyingReplacingPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_inspectTallyingReplacingPhrase
	return p
}

func (*InspectTallyingReplacingPhraseContext) IsInspectTallyingReplacingPhraseContext() {}

func NewInspectTallyingReplacingPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InspectTallyingReplacingPhraseContext {
	var p = new(InspectTallyingReplacingPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_inspectTallyingReplacingPhrase

	return p
}

func (s *InspectTallyingReplacingPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *InspectTallyingReplacingPhraseContext) TALLYING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTALLYING, 0)
}

func (s *InspectTallyingReplacingPhraseContext) AllInspectFor() []IInspectForContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInspectForContext)(nil)).Elem())
	var tst = make([]IInspectForContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInspectForContext)
		}
	}

	return tst
}

func (s *InspectTallyingReplacingPhraseContext) InspectFor(i int) IInspectForContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInspectForContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInspectForContext)
}

func (s *InspectTallyingReplacingPhraseContext) AllInspectReplacingPhrase() []IInspectReplacingPhraseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInspectReplacingPhraseContext)(nil)).Elem())
	var tst = make([]IInspectReplacingPhraseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInspectReplacingPhraseContext)
		}
	}

	return tst
}

func (s *InspectTallyingReplacingPhraseContext) InspectReplacingPhrase(i int) IInspectReplacingPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInspectReplacingPhraseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInspectReplacingPhraseContext)
}

func (s *InspectTallyingReplacingPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InspectTallyingReplacingPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InspectTallyingReplacingPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInspectTallyingReplacingPhrase(s)
	}
}

func (s *InspectTallyingReplacingPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInspectTallyingReplacingPhrase(s)
	}
}

func (p *Cobol85Parser) InspectTallyingReplacingPhrase() (localctx IInspectTallyingReplacingPhraseContext) {
	localctx = NewInspectTallyingReplacingPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 714, Cobol85ParserRULE_inspectTallyingReplacingPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4381)
		p.Match(Cobol85ParserTALLYING)
	}
	p.SetState(4383)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserADDRESS)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH)|(1<<Cobol85ParserATTRIBUTE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBINARY-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-68))|(1<<(Cobol85ParserCOBOL-68))|(1<<(Cobol85ParserCOMMITMENT-68))|(1<<(Cobol85ParserCONTROL_POINT-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(Cobol85ParserCONVENTION-100))|(1<<(Cobol85ParserCRUNCH-100))|(1<<(Cobol85ParserCURSOR-100))|(1<<(Cobol85ParserDATE-100))|(1<<(Cobol85ParserDAY-100))|(1<<(Cobol85ParserDAY_OF_WEEK-100))|(1<<(Cobol85ParserDEBUG_CONTENTS-100))|(1<<(Cobol85ParserDEBUG_ITEM-100))|(1<<(Cobol85ParserDEBUG_LINE-100))|(1<<(Cobol85ParserDEBUG_NAME-100))|(1<<(Cobol85ParserDEBUG_SUB_1-100))|(1<<(Cobol85ParserDEBUG_SUB_2-100))|(1<<(Cobol85ParserDEBUG_SUB_3-100))|(1<<(Cobol85ParserDEFAULT-100))|(1<<(Cobol85ParserDEFAULT_DISPLAY-100))|(1<<(Cobol85ParserDEFINITION-100)))) != 0) || (((_la-138)&-(0x1f+1)) == 0 && ((1<<uint((_la-138)))&((1<<(Cobol85ParserDFHRESP-138))|(1<<(Cobol85ParserDFHVALUE-138))|(1<<(Cobol85ParserDISK-138))|(1<<(Cobol85ParserDONTCARE-138))|(1<<(Cobol85ParserDOUBLE-138))|(1<<(Cobol85ParserEBCDIC-138))|(1<<(Cobol85ParserEMPTY_CHECK-138)))) != 0) || (((_la-181)&-(0x1f+1)) == 0 && ((1<<uint((_la-181)))&((1<<(Cobol85ParserENTER-181))|(1<<(Cobol85ParserENTRY_PROCEDURE-181))|(1<<(Cobol85ParserERASE-181))|(1<<(Cobol85ParserEOL-181))|(1<<(Cobol85ParserEOS-181))|(1<<(Cobol85ParserESCAPE-181))|(1<<(Cobol85ParserEVENT-181))|(1<<(Cobol85ParserEXCLUSIVE-181))|(1<<(Cobol85ParserEXPORT-181))|(1<<(Cobol85ParserEXTENDED-181)))) != 0) || (((_la-213)&-(0x1f+1)) == 0 && ((1<<uint((_la-213)))&((1<<(Cobol85ParserFOREGROUND_COLOR-213))|(1<<(Cobol85ParserFOREGROUND_COLOUR-213))|(1<<(Cobol85ParserFULL-213))|(1<<(Cobol85ParserFUNCTION-213))|(1<<(Cobol85ParserFUNCTIONNAME-213))|(1<<(Cobol85ParserFUNCTION_POINTER-213))|(1<<(Cobol85ParserGRID-213))|(1<<(Cobol85ParserHIGHLIGHT-213))|(1<<(Cobol85ParserIMPLICIT-213))|(1<<(Cobol85ParserIMPORT-213)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(Cobol85ParserINTEGER-250))|(1<<(Cobol85ParserKEPT-250))|(1<<(Cobol85ParserKEYBOARD-250))|(1<<(Cobol85ParserLANGUAGE-250))|(1<<(Cobol85ParserLB-250))|(1<<(Cobol85ParserLD-250))|(1<<(Cobol85ParserLEFTLINE-250))|(1<<(Cobol85ParserLENGTH-250))|(1<<(Cobol85ParserLENGTH_CHECK-250))|(1<<(Cobol85ParserLIBACCESS-250))|(1<<(Cobol85ParserLIBPARAMETER-250))|(1<<(Cobol85ParserLIBRARY-250))|(1<<(Cobol85ParserLINAGE_COUNTER-250))|(1<<(Cobol85ParserLINE_COUNTER-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(Cobol85ParserLIST-283))|(1<<(Cobol85ParserLOCAL-283))|(1<<(Cobol85ParserLONG_DATE-283))|(1<<(Cobol85ParserLONG_TIME-283))|(1<<(Cobol85ParserLOWER-283))|(1<<(Cobol85ParserLOWLIGHT-283))|(1<<(Cobol85ParserMMDDYYYY-283))|(1<<(Cobol85ParserNAMED-283))|(1<<(Cobol85ParserNATIONAL-283))|(1<<(Cobol85ParserNATIONAL_EDITED-283))|(1<<(Cobol85ParserNETWORK-283))|(1<<(Cobol85ParserNO_ECHO-283)))) != 0) || (((_la-317)&-(0x1f+1)) == 0 && ((1<<uint((_la-317)))&((1<<(Cobol85ParserNUMERIC_DATE-317))|(1<<(Cobol85ParserNUMERIC_TIME-317))|(1<<(Cobol85ParserODT-317))|(1<<(Cobol85ParserORDERLY-317))|(1<<(Cobol85ParserOVERLINE-317))|(1<<(Cobol85ParserOWN-317))|(1<<(Cobol85ParserPAGE_COUNTER-317))|(1<<(Cobol85ParserPASSWORD-317)))) != 0) || (((_la-352)&-(0x1f+1)) == 0 && ((1<<uint((_la-352)))&((1<<(Cobol85ParserPORT-352))|(1<<(Cobol85ParserPRINTER-352))|(1<<(Cobol85ParserPRIVATE-352))|(1<<(Cobol85ParserPROCESS-352))|(1<<(Cobol85ParserPROGRAM-352))|(1<<(Cobol85ParserPROMPT-352))|(1<<(Cobol85ParserREADER-352))|(1<<(Cobol85ParserREMOTE-352))|(1<<(Cobol85ParserREAL-352))|(1<<(Cobol85ParserRECEIVED-352))|(1<<(Cobol85ParserRECURSIVE-352))|(1<<(Cobol85ParserREF-352)))) != 0) || (((_la-391)&-(0x1f+1)) == 0 && ((1<<uint((_la-391)))&((1<<(Cobol85ParserREMOVE-391))|(1<<(Cobol85ParserREQUIRED-391))|(1<<(Cobol85ParserREVERSE_VIDEO-391))|(1<<(Cobol85ParserRETURN_CODE-391))|(1<<(Cobol85ParserSAVE-391))|(1<<(Cobol85ParserSECURE-391)))) != 0) || (((_la-431)&-(0x1f+1)) == 0 && ((1<<uint((_la-431)))&((1<<(Cobol85ParserSHARED-431))|(1<<(Cobol85ParserSHAREDBYALL-431))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-431))|(1<<(Cobol85ParserSHARING-431))|(1<<(Cobol85ParserSHIFT_IN-431))|(1<<(Cobol85ParserSHIFT_OUT-431))|(1<<(Cobol85ParserSHORT_DATE-431))|(1<<(Cobol85ParserSORT_CONTROL-431))|(1<<(Cobol85ParserSORT_CORE_SIZE-431))|(1<<(Cobol85ParserSORT_FILE_SIZE-431))|(1<<(Cobol85ParserSORT_MESSAGE-431))|(1<<(Cobol85ParserSORT_MODE_SIZE-431))|(1<<(Cobol85ParserSORT_RETURN-431)))) != 0) || (((_la-466)&-(0x1f+1)) == 0 && ((1<<uint((_la-466)))&((1<<(Cobol85ParserSYMBOL-466))|(1<<(Cobol85ParserTALLY-466))|(1<<(Cobol85ParserTASK-466))|(1<<(Cobol85ParserTHREAD-466))|(1<<(Cobol85ParserTHREAD_LOCAL-466))|(1<<(Cobol85ParserTIME-466))|(1<<(Cobol85ParserTIMER-466))|(1<<(Cobol85ParserTODAYS_DATE-466))|(1<<(Cobol85ParserTODAYS_NAME-466))|(1<<(Cobol85ParserTRUNCATED-466))|(1<<(Cobol85ParserTYPEDEF-466)))) != 0) || (((_la-498)&-(0x1f+1)) == 0 && ((1<<uint((_la-498)))&((1<<(Cobol85ParserUNDERLINE-498))|(1<<(Cobol85ParserVIRTUAL-498))|(1<<(Cobol85ParserWAIT-498))|(1<<(Cobol85ParserWHEN_COMPILED-498))|(1<<(Cobol85ParserYEAR-498))|(1<<(Cobol85ParserYYYYMMDD-498))|(1<<(Cobol85ParserYYYYDDD-498))|(1<<(Cobol85ParserZERO_FILL-498)))) != 0) || (((_la-552)&-(0x1f+1)) == 0 && ((1<<uint((_la-552)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-552))|(1<<(Cobol85ParserLEVEL_NUMBER_77-552))|(1<<(Cobol85ParserLEVEL_NUMBER_88-552))|(1<<(Cobol85ParserINTEGERLITERAL-552))|(1<<(Cobol85ParserIDENTIFIER-552)))) != 0) {
		{
			p.SetState(4382)
			p.InspectFor()
		}

		p.SetState(4385)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(4388)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == Cobol85ParserREPLACING {
		{
			p.SetState(4387)
			p.InspectReplacingPhrase()
		}

		p.SetState(4390)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IInspectConvertingPhraseContext is an interface to support dynamic dispatch.
type IInspectConvertingPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInspectConvertingPhraseContext differentiates from other interfaces.
	IsInspectConvertingPhraseContext()
}

type InspectConvertingPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInspectConvertingPhraseContext() *InspectConvertingPhraseContext {
	var p = new(InspectConvertingPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_inspectConvertingPhrase
	return p
}

func (*InspectConvertingPhraseContext) IsInspectConvertingPhraseContext() {}

func NewInspectConvertingPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InspectConvertingPhraseContext {
	var p = new(InspectConvertingPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_inspectConvertingPhrase

	return p
}

func (s *InspectConvertingPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *InspectConvertingPhraseContext) CONVERTING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCONVERTING, 0)
}

func (s *InspectConvertingPhraseContext) InspectTo() IInspectToContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInspectToContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInspectToContext)
}

func (s *InspectConvertingPhraseContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *InspectConvertingPhraseContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *InspectConvertingPhraseContext) AllInspectBeforeAfter() []IInspectBeforeAfterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInspectBeforeAfterContext)(nil)).Elem())
	var tst = make([]IInspectBeforeAfterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInspectBeforeAfterContext)
		}
	}

	return tst
}

func (s *InspectConvertingPhraseContext) InspectBeforeAfter(i int) IInspectBeforeAfterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInspectBeforeAfterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInspectBeforeAfterContext)
}

func (s *InspectConvertingPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InspectConvertingPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InspectConvertingPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInspectConvertingPhrase(s)
	}
}

func (s *InspectConvertingPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInspectConvertingPhrase(s)
	}
}

func (p *Cobol85Parser) InspectConvertingPhrase() (localctx IInspectConvertingPhraseContext) {
	localctx = NewInspectConvertingPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 716, Cobol85ParserRULE_inspectConvertingPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4392)
		p.Match(Cobol85ParserCONVERTING)
	}
	p.SetState(4395)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 623, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4393)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(4394)
			p.Literal()
		}

	}
	{
		p.SetState(4397)
		p.InspectTo()
	}
	p.SetState(4401)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserAFTER || _la == Cobol85ParserBEFORE {
		{
			p.SetState(4398)
			p.InspectBeforeAfter()
		}

		p.SetState(4403)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IInspectForContext is an interface to support dynamic dispatch.
type IInspectForContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInspectForContext differentiates from other interfaces.
	IsInspectForContext()
}

type InspectForContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInspectForContext() *InspectForContext {
	var p = new(InspectForContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_inspectFor
	return p
}

func (*InspectForContext) IsInspectForContext() {}

func NewInspectForContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InspectForContext {
	var p = new(InspectForContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_inspectFor

	return p
}

func (s *InspectForContext) GetParser() antlr.Parser { return s.parser }

func (s *InspectForContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *InspectForContext) FOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOR, 0)
}

func (s *InspectForContext) AllInspectCharacters() []IInspectCharactersContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInspectCharactersContext)(nil)).Elem())
	var tst = make([]IInspectCharactersContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInspectCharactersContext)
		}
	}

	return tst
}

func (s *InspectForContext) InspectCharacters(i int) IInspectCharactersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInspectCharactersContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInspectCharactersContext)
}

func (s *InspectForContext) AllInspectAllLeadings() []IInspectAllLeadingsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInspectAllLeadingsContext)(nil)).Elem())
	var tst = make([]IInspectAllLeadingsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInspectAllLeadingsContext)
		}
	}

	return tst
}

func (s *InspectForContext) InspectAllLeadings(i int) IInspectAllLeadingsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInspectAllLeadingsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInspectAllLeadingsContext)
}

func (s *InspectForContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InspectForContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InspectForContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInspectFor(s)
	}
}

func (s *InspectForContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInspectFor(s)
	}
}

func (p *Cobol85Parser) InspectFor() (localctx IInspectForContext) {
	localctx = NewInspectForContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 718, Cobol85ParserRULE_inspectFor)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4404)
		p.Identifier()
	}
	{
		p.SetState(4405)
		p.Match(Cobol85ParserFOR)
	}
	p.SetState(4408)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == Cobol85ParserALL || _la == Cobol85ParserCHARACTERS || _la == Cobol85ParserLEADING {
		p.SetState(4408)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case Cobol85ParserCHARACTERS:
			{
				p.SetState(4406)
				p.InspectCharacters()
			}

		case Cobol85ParserALL, Cobol85ParserLEADING:
			{
				p.SetState(4407)
				p.InspectAllLeadings()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(4410)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IInspectCharactersContext is an interface to support dynamic dispatch.
type IInspectCharactersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInspectCharactersContext differentiates from other interfaces.
	IsInspectCharactersContext()
}

type InspectCharactersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInspectCharactersContext() *InspectCharactersContext {
	var p = new(InspectCharactersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_inspectCharacters
	return p
}

func (*InspectCharactersContext) IsInspectCharactersContext() {}

func NewInspectCharactersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InspectCharactersContext {
	var p = new(InspectCharactersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_inspectCharacters

	return p
}

func (s *InspectCharactersContext) GetParser() antlr.Parser { return s.parser }

func (s *InspectCharactersContext) CHARACTERS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCHARACTERS, 0)
}

func (s *InspectCharactersContext) AllInspectBeforeAfter() []IInspectBeforeAfterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInspectBeforeAfterContext)(nil)).Elem())
	var tst = make([]IInspectBeforeAfterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInspectBeforeAfterContext)
		}
	}

	return tst
}

func (s *InspectCharactersContext) InspectBeforeAfter(i int) IInspectBeforeAfterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInspectBeforeAfterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInspectBeforeAfterContext)
}

func (s *InspectCharactersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InspectCharactersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InspectCharactersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInspectCharacters(s)
	}
}

func (s *InspectCharactersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInspectCharacters(s)
	}
}

func (p *Cobol85Parser) InspectCharacters() (localctx IInspectCharactersContext) {
	localctx = NewInspectCharactersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 720, Cobol85ParserRULE_inspectCharacters)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4412)
		p.Match(Cobol85ParserCHARACTERS)
	}
	p.SetState(4416)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserAFTER || _la == Cobol85ParserBEFORE {
		{
			p.SetState(4413)
			p.InspectBeforeAfter()
		}

		p.SetState(4418)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IInspectReplacingCharactersContext is an interface to support dynamic dispatch.
type IInspectReplacingCharactersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInspectReplacingCharactersContext differentiates from other interfaces.
	IsInspectReplacingCharactersContext()
}

type InspectReplacingCharactersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInspectReplacingCharactersContext() *InspectReplacingCharactersContext {
	var p = new(InspectReplacingCharactersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_inspectReplacingCharacters
	return p
}

func (*InspectReplacingCharactersContext) IsInspectReplacingCharactersContext() {}

func NewInspectReplacingCharactersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InspectReplacingCharactersContext {
	var p = new(InspectReplacingCharactersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_inspectReplacingCharacters

	return p
}

func (s *InspectReplacingCharactersContext) GetParser() antlr.Parser { return s.parser }

func (s *InspectReplacingCharactersContext) CHARACTERS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCHARACTERS, 0)
}

func (s *InspectReplacingCharactersContext) InspectBy() IInspectByContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInspectByContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInspectByContext)
}

func (s *InspectReplacingCharactersContext) AllInspectBeforeAfter() []IInspectBeforeAfterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInspectBeforeAfterContext)(nil)).Elem())
	var tst = make([]IInspectBeforeAfterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInspectBeforeAfterContext)
		}
	}

	return tst
}

func (s *InspectReplacingCharactersContext) InspectBeforeAfter(i int) IInspectBeforeAfterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInspectBeforeAfterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInspectBeforeAfterContext)
}

func (s *InspectReplacingCharactersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InspectReplacingCharactersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InspectReplacingCharactersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInspectReplacingCharacters(s)
	}
}

func (s *InspectReplacingCharactersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInspectReplacingCharacters(s)
	}
}

func (p *Cobol85Parser) InspectReplacingCharacters() (localctx IInspectReplacingCharactersContext) {
	localctx = NewInspectReplacingCharactersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 722, Cobol85ParserRULE_inspectReplacingCharacters)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4419)
		p.Match(Cobol85ParserCHARACTERS)
	}
	{
		p.SetState(4420)
		p.InspectBy()
	}
	p.SetState(4424)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserAFTER || _la == Cobol85ParserBEFORE {
		{
			p.SetState(4421)
			p.InspectBeforeAfter()
		}

		p.SetState(4426)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IInspectAllLeadingsContext is an interface to support dynamic dispatch.
type IInspectAllLeadingsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInspectAllLeadingsContext differentiates from other interfaces.
	IsInspectAllLeadingsContext()
}

type InspectAllLeadingsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInspectAllLeadingsContext() *InspectAllLeadingsContext {
	var p = new(InspectAllLeadingsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_inspectAllLeadings
	return p
}

func (*InspectAllLeadingsContext) IsInspectAllLeadingsContext() {}

func NewInspectAllLeadingsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InspectAllLeadingsContext {
	var p = new(InspectAllLeadingsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_inspectAllLeadings

	return p
}

func (s *InspectAllLeadingsContext) GetParser() antlr.Parser { return s.parser }

func (s *InspectAllLeadingsContext) ALL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALL, 0)
}

func (s *InspectAllLeadingsContext) LEADING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLEADING, 0)
}

func (s *InspectAllLeadingsContext) AllInspectAllLeading() []IInspectAllLeadingContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInspectAllLeadingContext)(nil)).Elem())
	var tst = make([]IInspectAllLeadingContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInspectAllLeadingContext)
		}
	}

	return tst
}

func (s *InspectAllLeadingsContext) InspectAllLeading(i int) IInspectAllLeadingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInspectAllLeadingContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInspectAllLeadingContext)
}

func (s *InspectAllLeadingsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InspectAllLeadingsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InspectAllLeadingsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInspectAllLeadings(s)
	}
}

func (s *InspectAllLeadingsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInspectAllLeadings(s)
	}
}

func (p *Cobol85Parser) InspectAllLeadings() (localctx IInspectAllLeadingsContext) {
	localctx = NewInspectAllLeadingsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 724, Cobol85ParserRULE_inspectAllLeadings)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4427)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserALL || _la == Cobol85ParserLEADING) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(4429)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(4428)
				p.InspectAllLeading()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(4431)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 629, p.GetParserRuleContext())
	}

	return localctx
}

// IInspectReplacingAllLeadingsContext is an interface to support dynamic dispatch.
type IInspectReplacingAllLeadingsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInspectReplacingAllLeadingsContext differentiates from other interfaces.
	IsInspectReplacingAllLeadingsContext()
}

type InspectReplacingAllLeadingsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInspectReplacingAllLeadingsContext() *InspectReplacingAllLeadingsContext {
	var p = new(InspectReplacingAllLeadingsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_inspectReplacingAllLeadings
	return p
}

func (*InspectReplacingAllLeadingsContext) IsInspectReplacingAllLeadingsContext() {}

func NewInspectReplacingAllLeadingsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InspectReplacingAllLeadingsContext {
	var p = new(InspectReplacingAllLeadingsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_inspectReplacingAllLeadings

	return p
}

func (s *InspectReplacingAllLeadingsContext) GetParser() antlr.Parser { return s.parser }

func (s *InspectReplacingAllLeadingsContext) ALL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALL, 0)
}

func (s *InspectReplacingAllLeadingsContext) LEADING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLEADING, 0)
}

func (s *InspectReplacingAllLeadingsContext) FIRST() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFIRST, 0)
}

func (s *InspectReplacingAllLeadingsContext) AllInspectReplacingAllLeading() []IInspectReplacingAllLeadingContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInspectReplacingAllLeadingContext)(nil)).Elem())
	var tst = make([]IInspectReplacingAllLeadingContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInspectReplacingAllLeadingContext)
		}
	}

	return tst
}

func (s *InspectReplacingAllLeadingsContext) InspectReplacingAllLeading(i int) IInspectReplacingAllLeadingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInspectReplacingAllLeadingContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInspectReplacingAllLeadingContext)
}

func (s *InspectReplacingAllLeadingsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InspectReplacingAllLeadingsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InspectReplacingAllLeadingsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInspectReplacingAllLeadings(s)
	}
}

func (s *InspectReplacingAllLeadingsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInspectReplacingAllLeadings(s)
	}
}

func (p *Cobol85Parser) InspectReplacingAllLeadings() (localctx IInspectReplacingAllLeadingsContext) {
	localctx = NewInspectReplacingAllLeadingsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 726, Cobol85ParserRULE_inspectReplacingAllLeadings)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4433)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserALL || _la == Cobol85ParserFIRST || _la == Cobol85ParserLEADING) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(4435)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(4434)
				p.InspectReplacingAllLeading()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(4437)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 630, p.GetParserRuleContext())
	}

	return localctx
}

// IInspectAllLeadingContext is an interface to support dynamic dispatch.
type IInspectAllLeadingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInspectAllLeadingContext differentiates from other interfaces.
	IsInspectAllLeadingContext()
}

type InspectAllLeadingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInspectAllLeadingContext() *InspectAllLeadingContext {
	var p = new(InspectAllLeadingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_inspectAllLeading
	return p
}

func (*InspectAllLeadingContext) IsInspectAllLeadingContext() {}

func NewInspectAllLeadingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InspectAllLeadingContext {
	var p = new(InspectAllLeadingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_inspectAllLeading

	return p
}

func (s *InspectAllLeadingContext) GetParser() antlr.Parser { return s.parser }

func (s *InspectAllLeadingContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *InspectAllLeadingContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *InspectAllLeadingContext) AllInspectBeforeAfter() []IInspectBeforeAfterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInspectBeforeAfterContext)(nil)).Elem())
	var tst = make([]IInspectBeforeAfterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInspectBeforeAfterContext)
		}
	}

	return tst
}

func (s *InspectAllLeadingContext) InspectBeforeAfter(i int) IInspectBeforeAfterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInspectBeforeAfterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInspectBeforeAfterContext)
}

func (s *InspectAllLeadingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InspectAllLeadingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InspectAllLeadingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInspectAllLeading(s)
	}
}

func (s *InspectAllLeadingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInspectAllLeading(s)
	}
}

func (p *Cobol85Parser) InspectAllLeading() (localctx IInspectAllLeadingContext) {
	localctx = NewInspectAllLeadingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 728, Cobol85ParserRULE_inspectAllLeading)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4441)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 631, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4439)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(4440)
			p.Literal()
		}

	}
	p.SetState(4446)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserAFTER || _la == Cobol85ParserBEFORE {
		{
			p.SetState(4443)
			p.InspectBeforeAfter()
		}

		p.SetState(4448)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IInspectReplacingAllLeadingContext is an interface to support dynamic dispatch.
type IInspectReplacingAllLeadingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInspectReplacingAllLeadingContext differentiates from other interfaces.
	IsInspectReplacingAllLeadingContext()
}

type InspectReplacingAllLeadingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInspectReplacingAllLeadingContext() *InspectReplacingAllLeadingContext {
	var p = new(InspectReplacingAllLeadingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_inspectReplacingAllLeading
	return p
}

func (*InspectReplacingAllLeadingContext) IsInspectReplacingAllLeadingContext() {}

func NewInspectReplacingAllLeadingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InspectReplacingAllLeadingContext {
	var p = new(InspectReplacingAllLeadingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_inspectReplacingAllLeading

	return p
}

func (s *InspectReplacingAllLeadingContext) GetParser() antlr.Parser { return s.parser }

func (s *InspectReplacingAllLeadingContext) InspectBy() IInspectByContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInspectByContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInspectByContext)
}

func (s *InspectReplacingAllLeadingContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *InspectReplacingAllLeadingContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *InspectReplacingAllLeadingContext) AllInspectBeforeAfter() []IInspectBeforeAfterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInspectBeforeAfterContext)(nil)).Elem())
	var tst = make([]IInspectBeforeAfterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInspectBeforeAfterContext)
		}
	}

	return tst
}

func (s *InspectReplacingAllLeadingContext) InspectBeforeAfter(i int) IInspectBeforeAfterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInspectBeforeAfterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInspectBeforeAfterContext)
}

func (s *InspectReplacingAllLeadingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InspectReplacingAllLeadingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InspectReplacingAllLeadingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInspectReplacingAllLeading(s)
	}
}

func (s *InspectReplacingAllLeadingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInspectReplacingAllLeading(s)
	}
}

func (p *Cobol85Parser) InspectReplacingAllLeading() (localctx IInspectReplacingAllLeadingContext) {
	localctx = NewInspectReplacingAllLeadingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 730, Cobol85ParserRULE_inspectReplacingAllLeading)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4451)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 633, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4449)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(4450)
			p.Literal()
		}

	}
	{
		p.SetState(4453)
		p.InspectBy()
	}
	p.SetState(4457)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserAFTER || _la == Cobol85ParserBEFORE {
		{
			p.SetState(4454)
			p.InspectBeforeAfter()
		}

		p.SetState(4459)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IInspectByContext is an interface to support dynamic dispatch.
type IInspectByContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInspectByContext differentiates from other interfaces.
	IsInspectByContext()
}

type InspectByContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInspectByContext() *InspectByContext {
	var p = new(InspectByContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_inspectBy
	return p
}

func (*InspectByContext) IsInspectByContext() {}

func NewInspectByContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InspectByContext {
	var p = new(InspectByContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_inspectBy

	return p
}

func (s *InspectByContext) GetParser() antlr.Parser { return s.parser }

func (s *InspectByContext) BY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBY, 0)
}

func (s *InspectByContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *InspectByContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *InspectByContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InspectByContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InspectByContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInspectBy(s)
	}
}

func (s *InspectByContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInspectBy(s)
	}
}

func (p *Cobol85Parser) InspectBy() (localctx IInspectByContext) {
	localctx = NewInspectByContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 732, Cobol85ParserRULE_inspectBy)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4460)
		p.Match(Cobol85ParserBY)
	}
	p.SetState(4463)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 635, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4461)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(4462)
			p.Literal()
		}

	}

	return localctx
}

// IInspectToContext is an interface to support dynamic dispatch.
type IInspectToContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInspectToContext differentiates from other interfaces.
	IsInspectToContext()
}

type InspectToContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInspectToContext() *InspectToContext {
	var p = new(InspectToContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_inspectTo
	return p
}

func (*InspectToContext) IsInspectToContext() {}

func NewInspectToContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InspectToContext {
	var p = new(InspectToContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_inspectTo

	return p
}

func (s *InspectToContext) GetParser() antlr.Parser { return s.parser }

func (s *InspectToContext) TO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTO, 0)
}

func (s *InspectToContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *InspectToContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *InspectToContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InspectToContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InspectToContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInspectTo(s)
	}
}

func (s *InspectToContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInspectTo(s)
	}
}

func (p *Cobol85Parser) InspectTo() (localctx IInspectToContext) {
	localctx = NewInspectToContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 734, Cobol85ParserRULE_inspectTo)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4465)
		p.Match(Cobol85ParserTO)
	}
	p.SetState(4468)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 636, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4466)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(4467)
			p.Literal()
		}

	}

	return localctx
}

// IInspectBeforeAfterContext is an interface to support dynamic dispatch.
type IInspectBeforeAfterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInspectBeforeAfterContext differentiates from other interfaces.
	IsInspectBeforeAfterContext()
}

type InspectBeforeAfterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInspectBeforeAfterContext() *InspectBeforeAfterContext {
	var p = new(InspectBeforeAfterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_inspectBeforeAfter
	return p
}

func (*InspectBeforeAfterContext) IsInspectBeforeAfterContext() {}

func NewInspectBeforeAfterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InspectBeforeAfterContext {
	var p = new(InspectBeforeAfterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_inspectBeforeAfter

	return p
}

func (s *InspectBeforeAfterContext) GetParser() antlr.Parser { return s.parser }

func (s *InspectBeforeAfterContext) BEFORE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBEFORE, 0)
}

func (s *InspectBeforeAfterContext) AFTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAFTER, 0)
}

func (s *InspectBeforeAfterContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *InspectBeforeAfterContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *InspectBeforeAfterContext) INITIAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINITIAL, 0)
}

func (s *InspectBeforeAfterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InspectBeforeAfterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InspectBeforeAfterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInspectBeforeAfter(s)
	}
}

func (s *InspectBeforeAfterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInspectBeforeAfter(s)
	}
}

func (p *Cobol85Parser) InspectBeforeAfter() (localctx IInspectBeforeAfterContext) {
	localctx = NewInspectBeforeAfterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 736, Cobol85ParserRULE_inspectBeforeAfter)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4470)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserAFTER || _la == Cobol85ParserBEFORE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(4472)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserINITIAL {
		{
			p.SetState(4471)
			p.Match(Cobol85ParserINITIAL)
		}

	}
	p.SetState(4476)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 638, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4474)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(4475)
			p.Literal()
		}

	}

	return localctx
}

// IMergeStatementContext is an interface to support dynamic dispatch.
type IMergeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMergeStatementContext differentiates from other interfaces.
	IsMergeStatementContext()
}

type MergeStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMergeStatementContext() *MergeStatementContext {
	var p = new(MergeStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_mergeStatement
	return p
}

func (*MergeStatementContext) IsMergeStatementContext() {}

func NewMergeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MergeStatementContext {
	var p = new(MergeStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_mergeStatement

	return p
}

func (s *MergeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *MergeStatementContext) MERGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMERGE, 0)
}

func (s *MergeStatementContext) FileName() IFileNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *MergeStatementContext) AllMergeOnKeyClause() []IMergeOnKeyClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMergeOnKeyClauseContext)(nil)).Elem())
	var tst = make([]IMergeOnKeyClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMergeOnKeyClauseContext)
		}
	}

	return tst
}

func (s *MergeStatementContext) MergeOnKeyClause(i int) IMergeOnKeyClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMergeOnKeyClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMergeOnKeyClauseContext)
}

func (s *MergeStatementContext) MergeCollatingSequencePhrase() IMergeCollatingSequencePhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMergeCollatingSequencePhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMergeCollatingSequencePhraseContext)
}

func (s *MergeStatementContext) AllMergeUsing() []IMergeUsingContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMergeUsingContext)(nil)).Elem())
	var tst = make([]IMergeUsingContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMergeUsingContext)
		}
	}

	return tst
}

func (s *MergeStatementContext) MergeUsing(i int) IMergeUsingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMergeUsingContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMergeUsingContext)
}

func (s *MergeStatementContext) MergeOutputProcedurePhrase() IMergeOutputProcedurePhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMergeOutputProcedurePhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMergeOutputProcedurePhraseContext)
}

func (s *MergeStatementContext) AllMergeGivingPhrase() []IMergeGivingPhraseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMergeGivingPhraseContext)(nil)).Elem())
	var tst = make([]IMergeGivingPhraseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMergeGivingPhraseContext)
		}
	}

	return tst
}

func (s *MergeStatementContext) MergeGivingPhrase(i int) IMergeGivingPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMergeGivingPhraseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMergeGivingPhraseContext)
}

func (s *MergeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MergeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MergeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMergeStatement(s)
	}
}

func (s *MergeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMergeStatement(s)
	}
}

func (p *Cobol85Parser) MergeStatement() (localctx IMergeStatementContext) {
	localctx = NewMergeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 738, Cobol85ParserRULE_mergeStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4478)
		p.Match(Cobol85ParserMERGE)
	}
	{
		p.SetState(4479)
		p.FileName()
	}
	p.SetState(4481)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(4480)
				p.MergeOnKeyClause()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(4483)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 639, p.GetParserRuleContext())
	}
	p.SetState(4486)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCOLLATING || _la == Cobol85ParserSEQUENCE {
		{
			p.SetState(4485)
			p.MergeCollatingSequencePhrase()
		}

	}
	p.SetState(4491)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserUSING {
		{
			p.SetState(4488)
			p.MergeUsing()
		}

		p.SetState(4493)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(4495)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserOUTPUT {
		{
			p.SetState(4494)
			p.MergeOutputProcedurePhrase()
		}

	}
	p.SetState(4500)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserGIVING {
		{
			p.SetState(4497)
			p.MergeGivingPhrase()
		}

		p.SetState(4502)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IMergeOnKeyClauseContext is an interface to support dynamic dispatch.
type IMergeOnKeyClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMergeOnKeyClauseContext differentiates from other interfaces.
	IsMergeOnKeyClauseContext()
}

type MergeOnKeyClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMergeOnKeyClauseContext() *MergeOnKeyClauseContext {
	var p = new(MergeOnKeyClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_mergeOnKeyClause
	return p
}

func (*MergeOnKeyClauseContext) IsMergeOnKeyClauseContext() {}

func NewMergeOnKeyClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MergeOnKeyClauseContext {
	var p = new(MergeOnKeyClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_mergeOnKeyClause

	return p
}

func (s *MergeOnKeyClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *MergeOnKeyClauseContext) ASCENDING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserASCENDING, 0)
}

func (s *MergeOnKeyClauseContext) DESCENDING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDESCENDING, 0)
}

func (s *MergeOnKeyClauseContext) ON() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserON, 0)
}

func (s *MergeOnKeyClauseContext) KEY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserKEY, 0)
}

func (s *MergeOnKeyClauseContext) AllQualifiedDataName() []IQualifiedDataNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IQualifiedDataNameContext)(nil)).Elem())
	var tst = make([]IQualifiedDataNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IQualifiedDataNameContext)
		}
	}

	return tst
}

func (s *MergeOnKeyClauseContext) QualifiedDataName(i int) IQualifiedDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedDataNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *MergeOnKeyClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MergeOnKeyClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MergeOnKeyClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMergeOnKeyClause(s)
	}
}

func (s *MergeOnKeyClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMergeOnKeyClause(s)
	}
}

func (p *Cobol85Parser) MergeOnKeyClause() (localctx IMergeOnKeyClauseContext) {
	localctx = NewMergeOnKeyClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 740, Cobol85ParserRULE_mergeOnKeyClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4504)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserON {
		{
			p.SetState(4503)
			p.Match(Cobol85ParserON)
		}

	}
	{
		p.SetState(4506)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserASCENDING || _la == Cobol85ParserDESCENDING) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(4508)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserKEY {
		{
			p.SetState(4507)
			p.Match(Cobol85ParserKEY)
		}

	}
	p.SetState(4511)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH)|(1<<Cobol85ParserATTRIBUTE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBINARY-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-68))|(1<<(Cobol85ParserCOBOL-68))|(1<<(Cobol85ParserCOMMITMENT-68))|(1<<(Cobol85ParserCONTROL_POINT-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(Cobol85ParserCONVENTION-100))|(1<<(Cobol85ParserCRUNCH-100))|(1<<(Cobol85ParserCURSOR-100))|(1<<(Cobol85ParserDEFAULT-100))|(1<<(Cobol85ParserDEFAULT_DISPLAY-100))|(1<<(Cobol85ParserDEFINITION-100)))) != 0) || (((_la-138)&-(0x1f+1)) == 0 && ((1<<uint((_la-138)))&((1<<(Cobol85ParserDFHRESP-138))|(1<<(Cobol85ParserDFHVALUE-138))|(1<<(Cobol85ParserDISK-138))|(1<<(Cobol85ParserDONTCARE-138))|(1<<(Cobol85ParserDOUBLE-138))|(1<<(Cobol85ParserEBCDIC-138))|(1<<(Cobol85ParserEMPTY_CHECK-138)))) != 0) || (((_la-181)&-(0x1f+1)) == 0 && ((1<<uint((_la-181)))&((1<<(Cobol85ParserENTER-181))|(1<<(Cobol85ParserENTRY_PROCEDURE-181))|(1<<(Cobol85ParserERASE-181))|(1<<(Cobol85ParserEOL-181))|(1<<(Cobol85ParserEOS-181))|(1<<(Cobol85ParserESCAPE-181))|(1<<(Cobol85ParserEVENT-181))|(1<<(Cobol85ParserEXCLUSIVE-181))|(1<<(Cobol85ParserEXPORT-181))|(1<<(Cobol85ParserEXTENDED-181)))) != 0) || (((_la-213)&-(0x1f+1)) == 0 && ((1<<uint((_la-213)))&((1<<(Cobol85ParserFOREGROUND_COLOR-213))|(1<<(Cobol85ParserFOREGROUND_COLOUR-213))|(1<<(Cobol85ParserFULL-213))|(1<<(Cobol85ParserFUNCTIONNAME-213))|(1<<(Cobol85ParserFUNCTION_POINTER-213))|(1<<(Cobol85ParserGRID-213))|(1<<(Cobol85ParserHIGHLIGHT-213))|(1<<(Cobol85ParserIMPLICIT-213))|(1<<(Cobol85ParserIMPORT-213)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(Cobol85ParserINTEGER-250))|(1<<(Cobol85ParserKEPT-250))|(1<<(Cobol85ParserKEYBOARD-250))|(1<<(Cobol85ParserLANGUAGE-250))|(1<<(Cobol85ParserLB-250))|(1<<(Cobol85ParserLD-250))|(1<<(Cobol85ParserLEFTLINE-250))|(1<<(Cobol85ParserLENGTH_CHECK-250))|(1<<(Cobol85ParserLIBACCESS-250))|(1<<(Cobol85ParserLIBPARAMETER-250))|(1<<(Cobol85ParserLIBRARY-250))|(1<<(Cobol85ParserLINAGE_COUNTER-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(Cobol85ParserLIST-283))|(1<<(Cobol85ParserLOCAL-283))|(1<<(Cobol85ParserLONG_DATE-283))|(1<<(Cobol85ParserLONG_TIME-283))|(1<<(Cobol85ParserLOWER-283))|(1<<(Cobol85ParserLOWLIGHT-283))|(1<<(Cobol85ParserMMDDYYYY-283))|(1<<(Cobol85ParserNAMED-283))|(1<<(Cobol85ParserNATIONAL-283))|(1<<(Cobol85ParserNATIONAL_EDITED-283))|(1<<(Cobol85ParserNETWORK-283))|(1<<(Cobol85ParserNO_ECHO-283)))) != 0) || (((_la-317)&-(0x1f+1)) == 0 && ((1<<uint((_la-317)))&((1<<(Cobol85ParserNUMERIC_DATE-317))|(1<<(Cobol85ParserNUMERIC_TIME-317))|(1<<(Cobol85ParserODT-317))|(1<<(Cobol85ParserORDERLY-317))|(1<<(Cobol85ParserOVERLINE-317))|(1<<(Cobol85ParserOWN-317))|(1<<(Cobol85ParserPASSWORD-317)))) != 0) || (((_la-352)&-(0x1f+1)) == 0 && ((1<<uint((_la-352)))&((1<<(Cobol85ParserPORT-352))|(1<<(Cobol85ParserPRINTER-352))|(1<<(Cobol85ParserPRIVATE-352))|(1<<(Cobol85ParserPROCESS-352))|(1<<(Cobol85ParserPROGRAM-352))|(1<<(Cobol85ParserPROMPT-352))|(1<<(Cobol85ParserREADER-352))|(1<<(Cobol85ParserREMOTE-352))|(1<<(Cobol85ParserREAL-352))|(1<<(Cobol85ParserRECEIVED-352))|(1<<(Cobol85ParserRECURSIVE-352))|(1<<(Cobol85ParserREF-352)))) != 0) || (((_la-391)&-(0x1f+1)) == 0 && ((1<<uint((_la-391)))&((1<<(Cobol85ParserREMOVE-391))|(1<<(Cobol85ParserREQUIRED-391))|(1<<(Cobol85ParserREVERSE_VIDEO-391))|(1<<(Cobol85ParserSAVE-391))|(1<<(Cobol85ParserSECURE-391)))) != 0) || (((_la-431)&-(0x1f+1)) == 0 && ((1<<uint((_la-431)))&((1<<(Cobol85ParserSHARED-431))|(1<<(Cobol85ParserSHAREDBYALL-431))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-431))|(1<<(Cobol85ParserSHARING-431))|(1<<(Cobol85ParserSHORT_DATE-431)))) != 0) || (((_la-466)&-(0x1f+1)) == 0 && ((1<<uint((_la-466)))&((1<<(Cobol85ParserSYMBOL-466))|(1<<(Cobol85ParserTASK-466))|(1<<(Cobol85ParserTHREAD-466))|(1<<(Cobol85ParserTHREAD_LOCAL-466))|(1<<(Cobol85ParserTIMER-466))|(1<<(Cobol85ParserTODAYS_DATE-466))|(1<<(Cobol85ParserTODAYS_NAME-466))|(1<<(Cobol85ParserTRUNCATED-466))|(1<<(Cobol85ParserTYPEDEF-466)))) != 0) || (((_la-498)&-(0x1f+1)) == 0 && ((1<<uint((_la-498)))&((1<<(Cobol85ParserUNDERLINE-498))|(1<<(Cobol85ParserVIRTUAL-498))|(1<<(Cobol85ParserWAIT-498))|(1<<(Cobol85ParserYEAR-498))|(1<<(Cobol85ParserYYYYMMDD-498))|(1<<(Cobol85ParserYYYYDDD-498))|(1<<(Cobol85ParserZERO_FILL-498)))) != 0) || (((_la-552)&-(0x1f+1)) == 0 && ((1<<uint((_la-552)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-552))|(1<<(Cobol85ParserLEVEL_NUMBER_77-552))|(1<<(Cobol85ParserLEVEL_NUMBER_88-552))|(1<<(Cobol85ParserINTEGERLITERAL-552))|(1<<(Cobol85ParserIDENTIFIER-552)))) != 0) {
		{
			p.SetState(4510)
			p.QualifiedDataName()
		}

		p.SetState(4513)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IMergeCollatingSequencePhraseContext is an interface to support dynamic dispatch.
type IMergeCollatingSequencePhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMergeCollatingSequencePhraseContext differentiates from other interfaces.
	IsMergeCollatingSequencePhraseContext()
}

type MergeCollatingSequencePhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMergeCollatingSequencePhraseContext() *MergeCollatingSequencePhraseContext {
	var p = new(MergeCollatingSequencePhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_mergeCollatingSequencePhrase
	return p
}

func (*MergeCollatingSequencePhraseContext) IsMergeCollatingSequencePhraseContext() {}

func NewMergeCollatingSequencePhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MergeCollatingSequencePhraseContext {
	var p = new(MergeCollatingSequencePhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_mergeCollatingSequencePhrase

	return p
}

func (s *MergeCollatingSequencePhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *MergeCollatingSequencePhraseContext) SEQUENCE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSEQUENCE, 0)
}

func (s *MergeCollatingSequencePhraseContext) COLLATING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOLLATING, 0)
}

func (s *MergeCollatingSequencePhraseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *MergeCollatingSequencePhraseContext) AllAlphabetName() []IAlphabetNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAlphabetNameContext)(nil)).Elem())
	var tst = make([]IAlphabetNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAlphabetNameContext)
		}
	}

	return tst
}

func (s *MergeCollatingSequencePhraseContext) AlphabetName(i int) IAlphabetNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlphabetNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAlphabetNameContext)
}

func (s *MergeCollatingSequencePhraseContext) MergeCollatingAlphanumeric() IMergeCollatingAlphanumericContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMergeCollatingAlphanumericContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMergeCollatingAlphanumericContext)
}

func (s *MergeCollatingSequencePhraseContext) MergeCollatingNational() IMergeCollatingNationalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMergeCollatingNationalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMergeCollatingNationalContext)
}

func (s *MergeCollatingSequencePhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MergeCollatingSequencePhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MergeCollatingSequencePhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMergeCollatingSequencePhrase(s)
	}
}

func (s *MergeCollatingSequencePhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMergeCollatingSequencePhrase(s)
	}
}

func (p *Cobol85Parser) MergeCollatingSequencePhrase() (localctx IMergeCollatingSequencePhraseContext) {
	localctx = NewMergeCollatingSequencePhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 742, Cobol85ParserRULE_mergeCollatingSequencePhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4516)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCOLLATING {
		{
			p.SetState(4515)
			p.Match(Cobol85ParserCOLLATING)
		}

	}
	{
		p.SetState(4518)
		p.Match(Cobol85ParserSEQUENCE)
	}
	p.SetState(4520)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(4519)
			p.Match(Cobol85ParserIS)
		}

	}
	p.SetState(4523)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(4522)
				p.AlphabetName()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(4525)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 649, p.GetParserRuleContext())
	}
	p.SetState(4528)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 650, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4527)
			p.MergeCollatingAlphanumeric()
		}

	}
	p.SetState(4531)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFOR || _la == Cobol85ParserNATIONAL {
		{
			p.SetState(4530)
			p.MergeCollatingNational()
		}

	}

	return localctx
}

// IMergeCollatingAlphanumericContext is an interface to support dynamic dispatch.
type IMergeCollatingAlphanumericContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMergeCollatingAlphanumericContext differentiates from other interfaces.
	IsMergeCollatingAlphanumericContext()
}

type MergeCollatingAlphanumericContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMergeCollatingAlphanumericContext() *MergeCollatingAlphanumericContext {
	var p = new(MergeCollatingAlphanumericContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_mergeCollatingAlphanumeric
	return p
}

func (*MergeCollatingAlphanumericContext) IsMergeCollatingAlphanumericContext() {}

func NewMergeCollatingAlphanumericContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MergeCollatingAlphanumericContext {
	var p = new(MergeCollatingAlphanumericContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_mergeCollatingAlphanumeric

	return p
}

func (s *MergeCollatingAlphanumericContext) GetParser() antlr.Parser { return s.parser }

func (s *MergeCollatingAlphanumericContext) ALPHANUMERIC() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALPHANUMERIC, 0)
}

func (s *MergeCollatingAlphanumericContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *MergeCollatingAlphanumericContext) AlphabetName() IAlphabetNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlphabetNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlphabetNameContext)
}

func (s *MergeCollatingAlphanumericContext) FOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOR, 0)
}

func (s *MergeCollatingAlphanumericContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MergeCollatingAlphanumericContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MergeCollatingAlphanumericContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMergeCollatingAlphanumeric(s)
	}
}

func (s *MergeCollatingAlphanumericContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMergeCollatingAlphanumeric(s)
	}
}

func (p *Cobol85Parser) MergeCollatingAlphanumeric() (localctx IMergeCollatingAlphanumericContext) {
	localctx = NewMergeCollatingAlphanumericContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 744, Cobol85ParserRULE_mergeCollatingAlphanumeric)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4534)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFOR {
		{
			p.SetState(4533)
			p.Match(Cobol85ParserFOR)
		}

	}
	{
		p.SetState(4536)
		p.Match(Cobol85ParserALPHANUMERIC)
	}
	{
		p.SetState(4537)
		p.Match(Cobol85ParserIS)
	}
	{
		p.SetState(4538)
		p.AlphabetName()
	}

	return localctx
}

// IMergeCollatingNationalContext is an interface to support dynamic dispatch.
type IMergeCollatingNationalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMergeCollatingNationalContext differentiates from other interfaces.
	IsMergeCollatingNationalContext()
}

type MergeCollatingNationalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMergeCollatingNationalContext() *MergeCollatingNationalContext {
	var p = new(MergeCollatingNationalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_mergeCollatingNational
	return p
}

func (*MergeCollatingNationalContext) IsMergeCollatingNationalContext() {}

func NewMergeCollatingNationalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MergeCollatingNationalContext {
	var p = new(MergeCollatingNationalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_mergeCollatingNational

	return p
}

func (s *MergeCollatingNationalContext) GetParser() antlr.Parser { return s.parser }

func (s *MergeCollatingNationalContext) NATIONAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNATIONAL, 0)
}

func (s *MergeCollatingNationalContext) AlphabetName() IAlphabetNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlphabetNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlphabetNameContext)
}

func (s *MergeCollatingNationalContext) FOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOR, 0)
}

func (s *MergeCollatingNationalContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *MergeCollatingNationalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MergeCollatingNationalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MergeCollatingNationalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMergeCollatingNational(s)
	}
}

func (s *MergeCollatingNationalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMergeCollatingNational(s)
	}
}

func (p *Cobol85Parser) MergeCollatingNational() (localctx IMergeCollatingNationalContext) {
	localctx = NewMergeCollatingNationalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 746, Cobol85ParserRULE_mergeCollatingNational)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4541)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFOR {
		{
			p.SetState(4540)
			p.Match(Cobol85ParserFOR)
		}

	}
	{
		p.SetState(4543)
		p.Match(Cobol85ParserNATIONAL)
	}
	p.SetState(4545)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(4544)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(4547)
		p.AlphabetName()
	}

	return localctx
}

// IMergeUsingContext is an interface to support dynamic dispatch.
type IMergeUsingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMergeUsingContext differentiates from other interfaces.
	IsMergeUsingContext()
}

type MergeUsingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMergeUsingContext() *MergeUsingContext {
	var p = new(MergeUsingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_mergeUsing
	return p
}

func (*MergeUsingContext) IsMergeUsingContext() {}

func NewMergeUsingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MergeUsingContext {
	var p = new(MergeUsingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_mergeUsing

	return p
}

func (s *MergeUsingContext) GetParser() antlr.Parser { return s.parser }

func (s *MergeUsingContext) USING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserUSING, 0)
}

func (s *MergeUsingContext) AllFileName() []IFileNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFileNameContext)(nil)).Elem())
	var tst = make([]IFileNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFileNameContext)
		}
	}

	return tst
}

func (s *MergeUsingContext) FileName(i int) IFileNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *MergeUsingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MergeUsingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MergeUsingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMergeUsing(s)
	}
}

func (s *MergeUsingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMergeUsing(s)
	}
}

func (p *Cobol85Parser) MergeUsing() (localctx IMergeUsingContext) {
	localctx = NewMergeUsingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 748, Cobol85ParserRULE_mergeUsing)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4549)
		p.Match(Cobol85ParserUSING)
	}
	p.SetState(4551)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH)|(1<<Cobol85ParserATTRIBUTE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBINARY-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-68))|(1<<(Cobol85ParserCOBOL-68))|(1<<(Cobol85ParserCOMMITMENT-68))|(1<<(Cobol85ParserCONTROL_POINT-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(Cobol85ParserCONVENTION-100))|(1<<(Cobol85ParserCRUNCH-100))|(1<<(Cobol85ParserCURSOR-100))|(1<<(Cobol85ParserDEFAULT-100))|(1<<(Cobol85ParserDEFAULT_DISPLAY-100))|(1<<(Cobol85ParserDEFINITION-100)))) != 0) || (((_la-138)&-(0x1f+1)) == 0 && ((1<<uint((_la-138)))&((1<<(Cobol85ParserDFHRESP-138))|(1<<(Cobol85ParserDFHVALUE-138))|(1<<(Cobol85ParserDISK-138))|(1<<(Cobol85ParserDONTCARE-138))|(1<<(Cobol85ParserDOUBLE-138))|(1<<(Cobol85ParserEBCDIC-138))|(1<<(Cobol85ParserEMPTY_CHECK-138)))) != 0) || (((_la-181)&-(0x1f+1)) == 0 && ((1<<uint((_la-181)))&((1<<(Cobol85ParserENTER-181))|(1<<(Cobol85ParserENTRY_PROCEDURE-181))|(1<<(Cobol85ParserERASE-181))|(1<<(Cobol85ParserEOL-181))|(1<<(Cobol85ParserEOS-181))|(1<<(Cobol85ParserESCAPE-181))|(1<<(Cobol85ParserEVENT-181))|(1<<(Cobol85ParserEXCLUSIVE-181))|(1<<(Cobol85ParserEXPORT-181))|(1<<(Cobol85ParserEXTENDED-181)))) != 0) || (((_la-213)&-(0x1f+1)) == 0 && ((1<<uint((_la-213)))&((1<<(Cobol85ParserFOREGROUND_COLOR-213))|(1<<(Cobol85ParserFOREGROUND_COLOUR-213))|(1<<(Cobol85ParserFULL-213))|(1<<(Cobol85ParserFUNCTIONNAME-213))|(1<<(Cobol85ParserFUNCTION_POINTER-213))|(1<<(Cobol85ParserGRID-213))|(1<<(Cobol85ParserHIGHLIGHT-213))|(1<<(Cobol85ParserIMPLICIT-213))|(1<<(Cobol85ParserIMPORT-213)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(Cobol85ParserINTEGER-250))|(1<<(Cobol85ParserKEPT-250))|(1<<(Cobol85ParserKEYBOARD-250))|(1<<(Cobol85ParserLANGUAGE-250))|(1<<(Cobol85ParserLB-250))|(1<<(Cobol85ParserLD-250))|(1<<(Cobol85ParserLEFTLINE-250))|(1<<(Cobol85ParserLENGTH_CHECK-250))|(1<<(Cobol85ParserLIBACCESS-250))|(1<<(Cobol85ParserLIBPARAMETER-250))|(1<<(Cobol85ParserLIBRARY-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(Cobol85ParserLIST-283))|(1<<(Cobol85ParserLOCAL-283))|(1<<(Cobol85ParserLONG_DATE-283))|(1<<(Cobol85ParserLONG_TIME-283))|(1<<(Cobol85ParserLOWER-283))|(1<<(Cobol85ParserLOWLIGHT-283))|(1<<(Cobol85ParserMMDDYYYY-283))|(1<<(Cobol85ParserNAMED-283))|(1<<(Cobol85ParserNATIONAL-283))|(1<<(Cobol85ParserNATIONAL_EDITED-283))|(1<<(Cobol85ParserNETWORK-283))|(1<<(Cobol85ParserNO_ECHO-283)))) != 0) || (((_la-317)&-(0x1f+1)) == 0 && ((1<<uint((_la-317)))&((1<<(Cobol85ParserNUMERIC_DATE-317))|(1<<(Cobol85ParserNUMERIC_TIME-317))|(1<<(Cobol85ParserODT-317))|(1<<(Cobol85ParserORDERLY-317))|(1<<(Cobol85ParserOVERLINE-317))|(1<<(Cobol85ParserOWN-317))|(1<<(Cobol85ParserPASSWORD-317)))) != 0) || (((_la-352)&-(0x1f+1)) == 0 && ((1<<uint((_la-352)))&((1<<(Cobol85ParserPORT-352))|(1<<(Cobol85ParserPRINTER-352))|(1<<(Cobol85ParserPRIVATE-352))|(1<<(Cobol85ParserPROCESS-352))|(1<<(Cobol85ParserPROGRAM-352))|(1<<(Cobol85ParserPROMPT-352))|(1<<(Cobol85ParserREADER-352))|(1<<(Cobol85ParserREMOTE-352))|(1<<(Cobol85ParserREAL-352))|(1<<(Cobol85ParserRECEIVED-352))|(1<<(Cobol85ParserRECURSIVE-352))|(1<<(Cobol85ParserREF-352)))) != 0) || (((_la-391)&-(0x1f+1)) == 0 && ((1<<uint((_la-391)))&((1<<(Cobol85ParserREMOVE-391))|(1<<(Cobol85ParserREQUIRED-391))|(1<<(Cobol85ParserREVERSE_VIDEO-391))|(1<<(Cobol85ParserSAVE-391))|(1<<(Cobol85ParserSECURE-391)))) != 0) || (((_la-431)&-(0x1f+1)) == 0 && ((1<<uint((_la-431)))&((1<<(Cobol85ParserSHARED-431))|(1<<(Cobol85ParserSHAREDBYALL-431))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-431))|(1<<(Cobol85ParserSHARING-431))|(1<<(Cobol85ParserSHORT_DATE-431)))) != 0) || (((_la-466)&-(0x1f+1)) == 0 && ((1<<uint((_la-466)))&((1<<(Cobol85ParserSYMBOL-466))|(1<<(Cobol85ParserTASK-466))|(1<<(Cobol85ParserTHREAD-466))|(1<<(Cobol85ParserTHREAD_LOCAL-466))|(1<<(Cobol85ParserTIMER-466))|(1<<(Cobol85ParserTODAYS_DATE-466))|(1<<(Cobol85ParserTODAYS_NAME-466))|(1<<(Cobol85ParserTRUNCATED-466))|(1<<(Cobol85ParserTYPEDEF-466)))) != 0) || (((_la-498)&-(0x1f+1)) == 0 && ((1<<uint((_la-498)))&((1<<(Cobol85ParserUNDERLINE-498))|(1<<(Cobol85ParserVIRTUAL-498))|(1<<(Cobol85ParserWAIT-498))|(1<<(Cobol85ParserYEAR-498))|(1<<(Cobol85ParserYYYYMMDD-498))|(1<<(Cobol85ParserYYYYDDD-498))|(1<<(Cobol85ParserZERO_FILL-498)))) != 0) || _la == Cobol85ParserIDENTIFIER {
		{
			p.SetState(4550)
			p.FileName()
		}

		p.SetState(4553)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IMergeOutputProcedurePhraseContext is an interface to support dynamic dispatch.
type IMergeOutputProcedurePhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMergeOutputProcedurePhraseContext differentiates from other interfaces.
	IsMergeOutputProcedurePhraseContext()
}

type MergeOutputProcedurePhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMergeOutputProcedurePhraseContext() *MergeOutputProcedurePhraseContext {
	var p = new(MergeOutputProcedurePhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_mergeOutputProcedurePhrase
	return p
}

func (*MergeOutputProcedurePhraseContext) IsMergeOutputProcedurePhraseContext() {}

func NewMergeOutputProcedurePhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MergeOutputProcedurePhraseContext {
	var p = new(MergeOutputProcedurePhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_mergeOutputProcedurePhrase

	return p
}

func (s *MergeOutputProcedurePhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *MergeOutputProcedurePhraseContext) OUTPUT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOUTPUT, 0)
}

func (s *MergeOutputProcedurePhraseContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPROCEDURE, 0)
}

func (s *MergeOutputProcedurePhraseContext) ProcedureName() IProcedureNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedureNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedureNameContext)
}

func (s *MergeOutputProcedurePhraseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *MergeOutputProcedurePhraseContext) MergeOutputThrough() IMergeOutputThroughContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMergeOutputThroughContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMergeOutputThroughContext)
}

func (s *MergeOutputProcedurePhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MergeOutputProcedurePhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MergeOutputProcedurePhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMergeOutputProcedurePhrase(s)
	}
}

func (s *MergeOutputProcedurePhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMergeOutputProcedurePhrase(s)
	}
}

func (p *Cobol85Parser) MergeOutputProcedurePhrase() (localctx IMergeOutputProcedurePhraseContext) {
	localctx = NewMergeOutputProcedurePhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 750, Cobol85ParserRULE_mergeOutputProcedurePhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4555)
		p.Match(Cobol85ParserOUTPUT)
	}
	{
		p.SetState(4556)
		p.Match(Cobol85ParserPROCEDURE)
	}
	p.SetState(4558)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(4557)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(4560)
		p.ProcedureName()
	}
	p.SetState(4562)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserTHROUGH || _la == Cobol85ParserTHRU {
		{
			p.SetState(4561)
			p.MergeOutputThrough()
		}

	}

	return localctx
}

// IMergeOutputThroughContext is an interface to support dynamic dispatch.
type IMergeOutputThroughContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMergeOutputThroughContext differentiates from other interfaces.
	IsMergeOutputThroughContext()
}

type MergeOutputThroughContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMergeOutputThroughContext() *MergeOutputThroughContext {
	var p = new(MergeOutputThroughContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_mergeOutputThrough
	return p
}

func (*MergeOutputThroughContext) IsMergeOutputThroughContext() {}

func NewMergeOutputThroughContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MergeOutputThroughContext {
	var p = new(MergeOutputThroughContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_mergeOutputThrough

	return p
}

func (s *MergeOutputThroughContext) GetParser() antlr.Parser { return s.parser }

func (s *MergeOutputThroughContext) ProcedureName() IProcedureNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedureNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedureNameContext)
}

func (s *MergeOutputThroughContext) THROUGH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHROUGH, 0)
}

func (s *MergeOutputThroughContext) THRU() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHRU, 0)
}

func (s *MergeOutputThroughContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MergeOutputThroughContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MergeOutputThroughContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMergeOutputThrough(s)
	}
}

func (s *MergeOutputThroughContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMergeOutputThrough(s)
	}
}

func (p *Cobol85Parser) MergeOutputThrough() (localctx IMergeOutputThroughContext) {
	localctx = NewMergeOutputThroughContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 752, Cobol85ParserRULE_mergeOutputThrough)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4564)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserTHROUGH || _la == Cobol85ParserTHRU) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(4565)
		p.ProcedureName()
	}

	return localctx
}

// IMergeGivingPhraseContext is an interface to support dynamic dispatch.
type IMergeGivingPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMergeGivingPhraseContext differentiates from other interfaces.
	IsMergeGivingPhraseContext()
}

type MergeGivingPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMergeGivingPhraseContext() *MergeGivingPhraseContext {
	var p = new(MergeGivingPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_mergeGivingPhrase
	return p
}

func (*MergeGivingPhraseContext) IsMergeGivingPhraseContext() {}

func NewMergeGivingPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MergeGivingPhraseContext {
	var p = new(MergeGivingPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_mergeGivingPhrase

	return p
}

func (s *MergeGivingPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *MergeGivingPhraseContext) GIVING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserGIVING, 0)
}

func (s *MergeGivingPhraseContext) AllMergeGiving() []IMergeGivingContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMergeGivingContext)(nil)).Elem())
	var tst = make([]IMergeGivingContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMergeGivingContext)
		}
	}

	return tst
}

func (s *MergeGivingPhraseContext) MergeGiving(i int) IMergeGivingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMergeGivingContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMergeGivingContext)
}

func (s *MergeGivingPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MergeGivingPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MergeGivingPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMergeGivingPhrase(s)
	}
}

func (s *MergeGivingPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMergeGivingPhrase(s)
	}
}

func (p *Cobol85Parser) MergeGivingPhrase() (localctx IMergeGivingPhraseContext) {
	localctx = NewMergeGivingPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 754, Cobol85ParserRULE_mergeGivingPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4567)
		p.Match(Cobol85ParserGIVING)
	}
	p.SetState(4569)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH)|(1<<Cobol85ParserATTRIBUTE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBINARY-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-68))|(1<<(Cobol85ParserCOBOL-68))|(1<<(Cobol85ParserCOMMITMENT-68))|(1<<(Cobol85ParserCONTROL_POINT-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(Cobol85ParserCONVENTION-100))|(1<<(Cobol85ParserCRUNCH-100))|(1<<(Cobol85ParserCURSOR-100))|(1<<(Cobol85ParserDEFAULT-100))|(1<<(Cobol85ParserDEFAULT_DISPLAY-100))|(1<<(Cobol85ParserDEFINITION-100)))) != 0) || (((_la-138)&-(0x1f+1)) == 0 && ((1<<uint((_la-138)))&((1<<(Cobol85ParserDFHRESP-138))|(1<<(Cobol85ParserDFHVALUE-138))|(1<<(Cobol85ParserDISK-138))|(1<<(Cobol85ParserDONTCARE-138))|(1<<(Cobol85ParserDOUBLE-138))|(1<<(Cobol85ParserEBCDIC-138))|(1<<(Cobol85ParserEMPTY_CHECK-138)))) != 0) || (((_la-181)&-(0x1f+1)) == 0 && ((1<<uint((_la-181)))&((1<<(Cobol85ParserENTER-181))|(1<<(Cobol85ParserENTRY_PROCEDURE-181))|(1<<(Cobol85ParserERASE-181))|(1<<(Cobol85ParserEOL-181))|(1<<(Cobol85ParserEOS-181))|(1<<(Cobol85ParserESCAPE-181))|(1<<(Cobol85ParserEVENT-181))|(1<<(Cobol85ParserEXCLUSIVE-181))|(1<<(Cobol85ParserEXPORT-181))|(1<<(Cobol85ParserEXTENDED-181)))) != 0) || (((_la-213)&-(0x1f+1)) == 0 && ((1<<uint((_la-213)))&((1<<(Cobol85ParserFOREGROUND_COLOR-213))|(1<<(Cobol85ParserFOREGROUND_COLOUR-213))|(1<<(Cobol85ParserFULL-213))|(1<<(Cobol85ParserFUNCTIONNAME-213))|(1<<(Cobol85ParserFUNCTION_POINTER-213))|(1<<(Cobol85ParserGRID-213))|(1<<(Cobol85ParserHIGHLIGHT-213))|(1<<(Cobol85ParserIMPLICIT-213))|(1<<(Cobol85ParserIMPORT-213)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(Cobol85ParserINTEGER-250))|(1<<(Cobol85ParserKEPT-250))|(1<<(Cobol85ParserKEYBOARD-250))|(1<<(Cobol85ParserLANGUAGE-250))|(1<<(Cobol85ParserLB-250))|(1<<(Cobol85ParserLD-250))|(1<<(Cobol85ParserLEFTLINE-250))|(1<<(Cobol85ParserLENGTH_CHECK-250))|(1<<(Cobol85ParserLIBACCESS-250))|(1<<(Cobol85ParserLIBPARAMETER-250))|(1<<(Cobol85ParserLIBRARY-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(Cobol85ParserLIST-283))|(1<<(Cobol85ParserLOCAL-283))|(1<<(Cobol85ParserLONG_DATE-283))|(1<<(Cobol85ParserLONG_TIME-283))|(1<<(Cobol85ParserLOWER-283))|(1<<(Cobol85ParserLOWLIGHT-283))|(1<<(Cobol85ParserMMDDYYYY-283))|(1<<(Cobol85ParserNAMED-283))|(1<<(Cobol85ParserNATIONAL-283))|(1<<(Cobol85ParserNATIONAL_EDITED-283))|(1<<(Cobol85ParserNETWORK-283))|(1<<(Cobol85ParserNO_ECHO-283)))) != 0) || (((_la-317)&-(0x1f+1)) == 0 && ((1<<uint((_la-317)))&((1<<(Cobol85ParserNUMERIC_DATE-317))|(1<<(Cobol85ParserNUMERIC_TIME-317))|(1<<(Cobol85ParserODT-317))|(1<<(Cobol85ParserORDERLY-317))|(1<<(Cobol85ParserOVERLINE-317))|(1<<(Cobol85ParserOWN-317))|(1<<(Cobol85ParserPASSWORD-317)))) != 0) || (((_la-352)&-(0x1f+1)) == 0 && ((1<<uint((_la-352)))&((1<<(Cobol85ParserPORT-352))|(1<<(Cobol85ParserPRINTER-352))|(1<<(Cobol85ParserPRIVATE-352))|(1<<(Cobol85ParserPROCESS-352))|(1<<(Cobol85ParserPROGRAM-352))|(1<<(Cobol85ParserPROMPT-352))|(1<<(Cobol85ParserREADER-352))|(1<<(Cobol85ParserREMOTE-352))|(1<<(Cobol85ParserREAL-352))|(1<<(Cobol85ParserRECEIVED-352))|(1<<(Cobol85ParserRECURSIVE-352))|(1<<(Cobol85ParserREF-352)))) != 0) || (((_la-391)&-(0x1f+1)) == 0 && ((1<<uint((_la-391)))&((1<<(Cobol85ParserREMOVE-391))|(1<<(Cobol85ParserREQUIRED-391))|(1<<(Cobol85ParserREVERSE_VIDEO-391))|(1<<(Cobol85ParserSAVE-391))|(1<<(Cobol85ParserSECURE-391)))) != 0) || (((_la-431)&-(0x1f+1)) == 0 && ((1<<uint((_la-431)))&((1<<(Cobol85ParserSHARED-431))|(1<<(Cobol85ParserSHAREDBYALL-431))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-431))|(1<<(Cobol85ParserSHARING-431))|(1<<(Cobol85ParserSHORT_DATE-431)))) != 0) || (((_la-466)&-(0x1f+1)) == 0 && ((1<<uint((_la-466)))&((1<<(Cobol85ParserSYMBOL-466))|(1<<(Cobol85ParserTASK-466))|(1<<(Cobol85ParserTHREAD-466))|(1<<(Cobol85ParserTHREAD_LOCAL-466))|(1<<(Cobol85ParserTIMER-466))|(1<<(Cobol85ParserTODAYS_DATE-466))|(1<<(Cobol85ParserTODAYS_NAME-466))|(1<<(Cobol85ParserTRUNCATED-466))|(1<<(Cobol85ParserTYPEDEF-466)))) != 0) || (((_la-498)&-(0x1f+1)) == 0 && ((1<<uint((_la-498)))&((1<<(Cobol85ParserUNDERLINE-498))|(1<<(Cobol85ParserVIRTUAL-498))|(1<<(Cobol85ParserWAIT-498))|(1<<(Cobol85ParserYEAR-498))|(1<<(Cobol85ParserYYYYMMDD-498))|(1<<(Cobol85ParserYYYYDDD-498))|(1<<(Cobol85ParserZERO_FILL-498)))) != 0) || _la == Cobol85ParserIDENTIFIER {
		{
			p.SetState(4568)
			p.MergeGiving()
		}

		p.SetState(4571)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IMergeGivingContext is an interface to support dynamic dispatch.
type IMergeGivingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMergeGivingContext differentiates from other interfaces.
	IsMergeGivingContext()
}

type MergeGivingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMergeGivingContext() *MergeGivingContext {
	var p = new(MergeGivingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_mergeGiving
	return p
}

func (*MergeGivingContext) IsMergeGivingContext() {}

func NewMergeGivingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MergeGivingContext {
	var p = new(MergeGivingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_mergeGiving

	return p
}

func (s *MergeGivingContext) GetParser() antlr.Parser { return s.parser }

func (s *MergeGivingContext) FileName() IFileNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *MergeGivingContext) LOCK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLOCK, 0)
}

func (s *MergeGivingContext) SAVE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSAVE, 0)
}

func (s *MergeGivingContext) NO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNO, 0)
}

func (s *MergeGivingContext) REWIND() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREWIND, 0)
}

func (s *MergeGivingContext) CRUNCH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCRUNCH, 0)
}

func (s *MergeGivingContext) RELEASE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRELEASE, 0)
}

func (s *MergeGivingContext) WITH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWITH, 0)
}

func (s *MergeGivingContext) REMOVE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREMOVE, 0)
}

func (s *MergeGivingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MergeGivingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MergeGivingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMergeGiving(s)
	}
}

func (s *MergeGivingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMergeGiving(s)
	}
}

func (p *Cobol85Parser) MergeGiving() (localctx IMergeGivingContext) {
	localctx = NewMergeGivingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 756, Cobol85ParserRULE_mergeGiving)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4573)
		p.FileName()
	}
	p.SetState(4583)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 659, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4574)
			p.Match(Cobol85ParserLOCK)
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 659, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(4575)
			p.Match(Cobol85ParserSAVE)
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 659, p.GetParserRuleContext()) == 3 {
		{
			p.SetState(4576)
			p.Match(Cobol85ParserNO)
		}
		{
			p.SetState(4577)
			p.Match(Cobol85ParserREWIND)
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 659, p.GetParserRuleContext()) == 4 {
		{
			p.SetState(4578)
			p.Match(Cobol85ParserCRUNCH)
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 659, p.GetParserRuleContext()) == 5 {
		{
			p.SetState(4579)
			p.Match(Cobol85ParserRELEASE)
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 659, p.GetParserRuleContext()) == 6 {
		{
			p.SetState(4580)
			p.Match(Cobol85ParserWITH)
		}
		{
			p.SetState(4581)
			p.Match(Cobol85ParserREMOVE)
		}
		{
			p.SetState(4582)
			p.Match(Cobol85ParserCRUNCH)
		}

	}

	return localctx
}

// IMoveStatementContext is an interface to support dynamic dispatch.
type IMoveStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMoveStatementContext differentiates from other interfaces.
	IsMoveStatementContext()
}

type MoveStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMoveStatementContext() *MoveStatementContext {
	var p = new(MoveStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_moveStatement
	return p
}

func (*MoveStatementContext) IsMoveStatementContext() {}

func NewMoveStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MoveStatementContext {
	var p = new(MoveStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_moveStatement

	return p
}

func (s *MoveStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *MoveStatementContext) MOVE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMOVE, 0)
}

func (s *MoveStatementContext) MoveToStatement() IMoveToStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMoveToStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMoveToStatementContext)
}

func (s *MoveStatementContext) MoveCorrespondingToStatement() IMoveCorrespondingToStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMoveCorrespondingToStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMoveCorrespondingToStatementContext)
}

func (s *MoveStatementContext) ALL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALL, 0)
}

func (s *MoveStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MoveStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MoveStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMoveStatement(s)
	}
}

func (s *MoveStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMoveStatement(s)
	}
}

func (p *Cobol85Parser) MoveStatement() (localctx IMoveStatementContext) {
	localctx = NewMoveStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 758, Cobol85ParserRULE_moveStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4585)
		p.Match(Cobol85ParserMOVE)
	}
	p.SetState(4587)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 660, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4586)
			p.Match(Cobol85ParserALL)
		}

	}
	p.SetState(4591)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserABORT, Cobol85ParserADDRESS, Cobol85ParserALL, Cobol85ParserAS, Cobol85ParserASCII, Cobol85ParserASSOCIATED_DATA, Cobol85ParserASSOCIATED_DATA_LENGTH, Cobol85ParserATTRIBUTE, Cobol85ParserAUTO, Cobol85ParserAUTO_SKIP, Cobol85ParserBACKGROUND_COLOR, Cobol85ParserBACKGROUND_COLOUR, Cobol85ParserBEEP, Cobol85ParserBELL, Cobol85ParserBINARY, Cobol85ParserBIT, Cobol85ParserBLINK, Cobol85ParserBOUNDS, Cobol85ParserCAPABLE, Cobol85ParserCCSVERSION, Cobol85ParserCHANGED, Cobol85ParserCHANNEL, Cobol85ParserCLOSE_DISPOSITION, Cobol85ParserCOBOL, Cobol85ParserCOMMITMENT, Cobol85ParserCONTROL_POINT, Cobol85ParserCONVENTION, Cobol85ParserCRUNCH, Cobol85ParserCURSOR, Cobol85ParserDATE, Cobol85ParserDAY, Cobol85ParserDAY_OF_WEEK, Cobol85ParserDEBUG_CONTENTS, Cobol85ParserDEBUG_ITEM, Cobol85ParserDEBUG_LINE, Cobol85ParserDEBUG_NAME, Cobol85ParserDEBUG_SUB_1, Cobol85ParserDEBUG_SUB_2, Cobol85ParserDEBUG_SUB_3, Cobol85ParserDEFAULT, Cobol85ParserDEFAULT_DISPLAY, Cobol85ParserDEFINITION, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserDISK, Cobol85ParserDONTCARE, Cobol85ParserDOUBLE, Cobol85ParserEBCDIC, Cobol85ParserEMPTY_CHECK, Cobol85ParserENTER, Cobol85ParserENTRY_PROCEDURE, Cobol85ParserERASE, Cobol85ParserEOL, Cobol85ParserEOS, Cobol85ParserESCAPE, Cobol85ParserEVENT, Cobol85ParserEXCLUSIVE, Cobol85ParserEXPORT, Cobol85ParserEXTENDED, Cobol85ParserFALSE, Cobol85ParserFOREGROUND_COLOR, Cobol85ParserFOREGROUND_COLOUR, Cobol85ParserFULL, Cobol85ParserFUNCTION, Cobol85ParserFUNCTIONNAME, Cobol85ParserFUNCTION_POINTER, Cobol85ParserGRID, Cobol85ParserHIGHLIGHT, Cobol85ParserHIGH_VALUE, Cobol85ParserHIGH_VALUES, Cobol85ParserIMPLICIT, Cobol85ParserIMPORT, Cobol85ParserINTEGER, Cobol85ParserKEPT, Cobol85ParserKEYBOARD, Cobol85ParserLANGUAGE, Cobol85ParserLB, Cobol85ParserLD, Cobol85ParserLEFTLINE, Cobol85ParserLENGTH, Cobol85ParserLENGTH_CHECK, Cobol85ParserLIBACCESS, Cobol85ParserLIBPARAMETER, Cobol85ParserLIBRARY, Cobol85ParserLINAGE_COUNTER, Cobol85ParserLINE_COUNTER, Cobol85ParserLIST, Cobol85ParserLOCAL, Cobol85ParserLONG_DATE, Cobol85ParserLONG_TIME, Cobol85ParserLOWER, Cobol85ParserLOWLIGHT, Cobol85ParserLOW_VALUE, Cobol85ParserLOW_VALUES, Cobol85ParserMMDDYYYY, Cobol85ParserNAMED, Cobol85ParserNATIONAL, Cobol85ParserNATIONAL_EDITED, Cobol85ParserNETWORK, Cobol85ParserNO_ECHO, Cobol85ParserNULL, Cobol85ParserNULLS, Cobol85ParserNUMERIC_DATE, Cobol85ParserNUMERIC_TIME, Cobol85ParserODT, Cobol85ParserORDERLY, Cobol85ParserOVERLINE, Cobol85ParserOWN, Cobol85ParserPAGE_COUNTER, Cobol85ParserPASSWORD, Cobol85ParserPORT, Cobol85ParserPRINTER, Cobol85ParserPRIVATE, Cobol85ParserPROCESS, Cobol85ParserPROGRAM, Cobol85ParserPROMPT, Cobol85ParserQUOTE, Cobol85ParserQUOTES, Cobol85ParserREADER, Cobol85ParserREMOTE, Cobol85ParserREAL, Cobol85ParserRECEIVED, Cobol85ParserRECURSIVE, Cobol85ParserREF, Cobol85ParserREMOVE, Cobol85ParserREQUIRED, Cobol85ParserREVERSE_VIDEO, Cobol85ParserRETURN_CODE, Cobol85ParserSAVE, Cobol85ParserSECURE, Cobol85ParserSHARED, Cobol85ParserSHAREDBYALL, Cobol85ParserSHAREDBYRUNUNIT, Cobol85ParserSHARING, Cobol85ParserSHIFT_IN, Cobol85ParserSHIFT_OUT, Cobol85ParserSHORT_DATE, Cobol85ParserSORT_CONTROL, Cobol85ParserSORT_CORE_SIZE, Cobol85ParserSORT_FILE_SIZE, Cobol85ParserSORT_MESSAGE, Cobol85ParserSORT_MODE_SIZE, Cobol85ParserSORT_RETURN, Cobol85ParserSPACE, Cobol85ParserSPACES, Cobol85ParserSYMBOL, Cobol85ParserTALLY, Cobol85ParserTASK, Cobol85ParserTHREAD, Cobol85ParserTHREAD_LOCAL, Cobol85ParserTIME, Cobol85ParserTIMER, Cobol85ParserTODAYS_DATE, Cobol85ParserTODAYS_NAME, Cobol85ParserTRUE, Cobol85ParserTRUNCATED, Cobol85ParserTYPEDEF, Cobol85ParserUNDERLINE, Cobol85ParserVIRTUAL, Cobol85ParserWAIT, Cobol85ParserWHEN_COMPILED, Cobol85ParserYEAR, Cobol85ParserYYYYMMDD, Cobol85ParserYYYYDDD, Cobol85ParserZERO, Cobol85ParserZERO_FILL, Cobol85ParserZEROS, Cobol85ParserZEROES, Cobol85ParserNONNUMERICLITERAL, Cobol85ParserLEVEL_NUMBER_66, Cobol85ParserLEVEL_NUMBER_77, Cobol85ParserLEVEL_NUMBER_88, Cobol85ParserINTEGERLITERAL, Cobol85ParserNUMERICLITERAL, Cobol85ParserIDENTIFIER:
		{
			p.SetState(4589)
			p.MoveToStatement()
		}

	case Cobol85ParserCORR, Cobol85ParserCORRESPONDING:
		{
			p.SetState(4590)
			p.MoveCorrespondingToStatement()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IMoveToStatementContext is an interface to support dynamic dispatch.
type IMoveToStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMoveToStatementContext differentiates from other interfaces.
	IsMoveToStatementContext()
}

type MoveToStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMoveToStatementContext() *MoveToStatementContext {
	var p = new(MoveToStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_moveToStatement
	return p
}

func (*MoveToStatementContext) IsMoveToStatementContext() {}

func NewMoveToStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MoveToStatementContext {
	var p = new(MoveToStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_moveToStatement

	return p
}

func (s *MoveToStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *MoveToStatementContext) MoveToSendingArea() IMoveToSendingAreaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMoveToSendingAreaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMoveToSendingAreaContext)
}

func (s *MoveToStatementContext) TO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTO, 0)
}

func (s *MoveToStatementContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *MoveToStatementContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MoveToStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MoveToStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MoveToStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMoveToStatement(s)
	}
}

func (s *MoveToStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMoveToStatement(s)
	}
}

func (p *Cobol85Parser) MoveToStatement() (localctx IMoveToStatementContext) {
	localctx = NewMoveToStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 760, Cobol85ParserRULE_moveToStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4593)
		p.MoveToSendingArea()
	}
	{
		p.SetState(4594)
		p.Match(Cobol85ParserTO)
	}
	p.SetState(4596)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserADDRESS)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH)|(1<<Cobol85ParserATTRIBUTE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBINARY-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-68))|(1<<(Cobol85ParserCOBOL-68))|(1<<(Cobol85ParserCOMMITMENT-68))|(1<<(Cobol85ParserCONTROL_POINT-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(Cobol85ParserCONVENTION-100))|(1<<(Cobol85ParserCRUNCH-100))|(1<<(Cobol85ParserCURSOR-100))|(1<<(Cobol85ParserDATE-100))|(1<<(Cobol85ParserDAY-100))|(1<<(Cobol85ParserDAY_OF_WEEK-100))|(1<<(Cobol85ParserDEBUG_CONTENTS-100))|(1<<(Cobol85ParserDEBUG_ITEM-100))|(1<<(Cobol85ParserDEBUG_LINE-100))|(1<<(Cobol85ParserDEBUG_NAME-100))|(1<<(Cobol85ParserDEBUG_SUB_1-100))|(1<<(Cobol85ParserDEBUG_SUB_2-100))|(1<<(Cobol85ParserDEBUG_SUB_3-100))|(1<<(Cobol85ParserDEFAULT-100))|(1<<(Cobol85ParserDEFAULT_DISPLAY-100))|(1<<(Cobol85ParserDEFINITION-100)))) != 0) || (((_la-138)&-(0x1f+1)) == 0 && ((1<<uint((_la-138)))&((1<<(Cobol85ParserDFHRESP-138))|(1<<(Cobol85ParserDFHVALUE-138))|(1<<(Cobol85ParserDISK-138))|(1<<(Cobol85ParserDONTCARE-138))|(1<<(Cobol85ParserDOUBLE-138))|(1<<(Cobol85ParserEBCDIC-138))|(1<<(Cobol85ParserEMPTY_CHECK-138)))) != 0) || (((_la-181)&-(0x1f+1)) == 0 && ((1<<uint((_la-181)))&((1<<(Cobol85ParserENTER-181))|(1<<(Cobol85ParserENTRY_PROCEDURE-181))|(1<<(Cobol85ParserERASE-181))|(1<<(Cobol85ParserEOL-181))|(1<<(Cobol85ParserEOS-181))|(1<<(Cobol85ParserESCAPE-181))|(1<<(Cobol85ParserEVENT-181))|(1<<(Cobol85ParserEXCLUSIVE-181))|(1<<(Cobol85ParserEXPORT-181))|(1<<(Cobol85ParserEXTENDED-181)))) != 0) || (((_la-213)&-(0x1f+1)) == 0 && ((1<<uint((_la-213)))&((1<<(Cobol85ParserFOREGROUND_COLOR-213))|(1<<(Cobol85ParserFOREGROUND_COLOUR-213))|(1<<(Cobol85ParserFULL-213))|(1<<(Cobol85ParserFUNCTION-213))|(1<<(Cobol85ParserFUNCTIONNAME-213))|(1<<(Cobol85ParserFUNCTION_POINTER-213))|(1<<(Cobol85ParserGRID-213))|(1<<(Cobol85ParserHIGHLIGHT-213))|(1<<(Cobol85ParserIMPLICIT-213))|(1<<(Cobol85ParserIMPORT-213)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(Cobol85ParserINTEGER-250))|(1<<(Cobol85ParserKEPT-250))|(1<<(Cobol85ParserKEYBOARD-250))|(1<<(Cobol85ParserLANGUAGE-250))|(1<<(Cobol85ParserLB-250))|(1<<(Cobol85ParserLD-250))|(1<<(Cobol85ParserLEFTLINE-250))|(1<<(Cobol85ParserLENGTH-250))|(1<<(Cobol85ParserLENGTH_CHECK-250))|(1<<(Cobol85ParserLIBACCESS-250))|(1<<(Cobol85ParserLIBPARAMETER-250))|(1<<(Cobol85ParserLIBRARY-250))|(1<<(Cobol85ParserLINAGE_COUNTER-250))|(1<<(Cobol85ParserLINE_COUNTER-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(Cobol85ParserLIST-283))|(1<<(Cobol85ParserLOCAL-283))|(1<<(Cobol85ParserLONG_DATE-283))|(1<<(Cobol85ParserLONG_TIME-283))|(1<<(Cobol85ParserLOWER-283))|(1<<(Cobol85ParserLOWLIGHT-283))|(1<<(Cobol85ParserMMDDYYYY-283))|(1<<(Cobol85ParserNAMED-283))|(1<<(Cobol85ParserNATIONAL-283))|(1<<(Cobol85ParserNATIONAL_EDITED-283))|(1<<(Cobol85ParserNETWORK-283))|(1<<(Cobol85ParserNO_ECHO-283)))) != 0) || (((_la-317)&-(0x1f+1)) == 0 && ((1<<uint((_la-317)))&((1<<(Cobol85ParserNUMERIC_DATE-317))|(1<<(Cobol85ParserNUMERIC_TIME-317))|(1<<(Cobol85ParserODT-317))|(1<<(Cobol85ParserORDERLY-317))|(1<<(Cobol85ParserOVERLINE-317))|(1<<(Cobol85ParserOWN-317))|(1<<(Cobol85ParserPAGE_COUNTER-317))|(1<<(Cobol85ParserPASSWORD-317)))) != 0) || (((_la-352)&-(0x1f+1)) == 0 && ((1<<uint((_la-352)))&((1<<(Cobol85ParserPORT-352))|(1<<(Cobol85ParserPRINTER-352))|(1<<(Cobol85ParserPRIVATE-352))|(1<<(Cobol85ParserPROCESS-352))|(1<<(Cobol85ParserPROGRAM-352))|(1<<(Cobol85ParserPROMPT-352))|(1<<(Cobol85ParserREADER-352))|(1<<(Cobol85ParserREMOTE-352))|(1<<(Cobol85ParserREAL-352))|(1<<(Cobol85ParserRECEIVED-352))|(1<<(Cobol85ParserRECURSIVE-352))|(1<<(Cobol85ParserREF-352)))) != 0) || (((_la-391)&-(0x1f+1)) == 0 && ((1<<uint((_la-391)))&((1<<(Cobol85ParserREMOVE-391))|(1<<(Cobol85ParserREQUIRED-391))|(1<<(Cobol85ParserREVERSE_VIDEO-391))|(1<<(Cobol85ParserRETURN_CODE-391))|(1<<(Cobol85ParserSAVE-391))|(1<<(Cobol85ParserSECURE-391)))) != 0) || (((_la-431)&-(0x1f+1)) == 0 && ((1<<uint((_la-431)))&((1<<(Cobol85ParserSHARED-431))|(1<<(Cobol85ParserSHAREDBYALL-431))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-431))|(1<<(Cobol85ParserSHARING-431))|(1<<(Cobol85ParserSHIFT_IN-431))|(1<<(Cobol85ParserSHIFT_OUT-431))|(1<<(Cobol85ParserSHORT_DATE-431))|(1<<(Cobol85ParserSORT_CONTROL-431))|(1<<(Cobol85ParserSORT_CORE_SIZE-431))|(1<<(Cobol85ParserSORT_FILE_SIZE-431))|(1<<(Cobol85ParserSORT_MESSAGE-431))|(1<<(Cobol85ParserSORT_MODE_SIZE-431))|(1<<(Cobol85ParserSORT_RETURN-431)))) != 0) || (((_la-466)&-(0x1f+1)) == 0 && ((1<<uint((_la-466)))&((1<<(Cobol85ParserSYMBOL-466))|(1<<(Cobol85ParserTALLY-466))|(1<<(Cobol85ParserTASK-466))|(1<<(Cobol85ParserTHREAD-466))|(1<<(Cobol85ParserTHREAD_LOCAL-466))|(1<<(Cobol85ParserTIME-466))|(1<<(Cobol85ParserTIMER-466))|(1<<(Cobol85ParserTODAYS_DATE-466))|(1<<(Cobol85ParserTODAYS_NAME-466))|(1<<(Cobol85ParserTRUNCATED-466))|(1<<(Cobol85ParserTYPEDEF-466)))) != 0) || (((_la-498)&-(0x1f+1)) == 0 && ((1<<uint((_la-498)))&((1<<(Cobol85ParserUNDERLINE-498))|(1<<(Cobol85ParserVIRTUAL-498))|(1<<(Cobol85ParserWAIT-498))|(1<<(Cobol85ParserWHEN_COMPILED-498))|(1<<(Cobol85ParserYEAR-498))|(1<<(Cobol85ParserYYYYMMDD-498))|(1<<(Cobol85ParserYYYYDDD-498))|(1<<(Cobol85ParserZERO_FILL-498)))) != 0) || (((_la-552)&-(0x1f+1)) == 0 && ((1<<uint((_la-552)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-552))|(1<<(Cobol85ParserLEVEL_NUMBER_77-552))|(1<<(Cobol85ParserLEVEL_NUMBER_88-552))|(1<<(Cobol85ParserINTEGERLITERAL-552))|(1<<(Cobol85ParserIDENTIFIER-552)))) != 0) {
		{
			p.SetState(4595)
			p.Identifier()
		}

		p.SetState(4598)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IMoveToSendingAreaContext is an interface to support dynamic dispatch.
type IMoveToSendingAreaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMoveToSendingAreaContext differentiates from other interfaces.
	IsMoveToSendingAreaContext()
}

type MoveToSendingAreaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMoveToSendingAreaContext() *MoveToSendingAreaContext {
	var p = new(MoveToSendingAreaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_moveToSendingArea
	return p
}

func (*MoveToSendingAreaContext) IsMoveToSendingAreaContext() {}

func NewMoveToSendingAreaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MoveToSendingAreaContext {
	var p = new(MoveToSendingAreaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_moveToSendingArea

	return p
}

func (s *MoveToSendingAreaContext) GetParser() antlr.Parser { return s.parser }

func (s *MoveToSendingAreaContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MoveToSendingAreaContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *MoveToSendingAreaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MoveToSendingAreaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MoveToSendingAreaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMoveToSendingArea(s)
	}
}

func (s *MoveToSendingAreaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMoveToSendingArea(s)
	}
}

func (p *Cobol85Parser) MoveToSendingArea() (localctx IMoveToSendingAreaContext) {
	localctx = NewMoveToSendingAreaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 762, Cobol85ParserRULE_moveToSendingArea)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4602)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 663, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4600)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4601)
			p.Literal()
		}

	}

	return localctx
}

// IMoveCorrespondingToStatementContext is an interface to support dynamic dispatch.
type IMoveCorrespondingToStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMoveCorrespondingToStatementContext differentiates from other interfaces.
	IsMoveCorrespondingToStatementContext()
}

type MoveCorrespondingToStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMoveCorrespondingToStatementContext() *MoveCorrespondingToStatementContext {
	var p = new(MoveCorrespondingToStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_moveCorrespondingToStatement
	return p
}

func (*MoveCorrespondingToStatementContext) IsMoveCorrespondingToStatementContext() {}

func NewMoveCorrespondingToStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MoveCorrespondingToStatementContext {
	var p = new(MoveCorrespondingToStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_moveCorrespondingToStatement

	return p
}

func (s *MoveCorrespondingToStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *MoveCorrespondingToStatementContext) MoveCorrespondingToSendingArea() IMoveCorrespondingToSendingAreaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMoveCorrespondingToSendingAreaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMoveCorrespondingToSendingAreaContext)
}

func (s *MoveCorrespondingToStatementContext) TO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTO, 0)
}

func (s *MoveCorrespondingToStatementContext) CORRESPONDING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCORRESPONDING, 0)
}

func (s *MoveCorrespondingToStatementContext) CORR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCORR, 0)
}

func (s *MoveCorrespondingToStatementContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *MoveCorrespondingToStatementContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MoveCorrespondingToStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MoveCorrespondingToStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MoveCorrespondingToStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMoveCorrespondingToStatement(s)
	}
}

func (s *MoveCorrespondingToStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMoveCorrespondingToStatement(s)
	}
}

func (p *Cobol85Parser) MoveCorrespondingToStatement() (localctx IMoveCorrespondingToStatementContext) {
	localctx = NewMoveCorrespondingToStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 764, Cobol85ParserRULE_moveCorrespondingToStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4604)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserCORR || _la == Cobol85ParserCORRESPONDING) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(4605)
		p.MoveCorrespondingToSendingArea()
	}
	{
		p.SetState(4606)
		p.Match(Cobol85ParserTO)
	}
	p.SetState(4608)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserADDRESS)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH)|(1<<Cobol85ParserATTRIBUTE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBINARY-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-68))|(1<<(Cobol85ParserCOBOL-68))|(1<<(Cobol85ParserCOMMITMENT-68))|(1<<(Cobol85ParserCONTROL_POINT-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(Cobol85ParserCONVENTION-100))|(1<<(Cobol85ParserCRUNCH-100))|(1<<(Cobol85ParserCURSOR-100))|(1<<(Cobol85ParserDATE-100))|(1<<(Cobol85ParserDAY-100))|(1<<(Cobol85ParserDAY_OF_WEEK-100))|(1<<(Cobol85ParserDEBUG_CONTENTS-100))|(1<<(Cobol85ParserDEBUG_ITEM-100))|(1<<(Cobol85ParserDEBUG_LINE-100))|(1<<(Cobol85ParserDEBUG_NAME-100))|(1<<(Cobol85ParserDEBUG_SUB_1-100))|(1<<(Cobol85ParserDEBUG_SUB_2-100))|(1<<(Cobol85ParserDEBUG_SUB_3-100))|(1<<(Cobol85ParserDEFAULT-100))|(1<<(Cobol85ParserDEFAULT_DISPLAY-100))|(1<<(Cobol85ParserDEFINITION-100)))) != 0) || (((_la-138)&-(0x1f+1)) == 0 && ((1<<uint((_la-138)))&((1<<(Cobol85ParserDFHRESP-138))|(1<<(Cobol85ParserDFHVALUE-138))|(1<<(Cobol85ParserDISK-138))|(1<<(Cobol85ParserDONTCARE-138))|(1<<(Cobol85ParserDOUBLE-138))|(1<<(Cobol85ParserEBCDIC-138))|(1<<(Cobol85ParserEMPTY_CHECK-138)))) != 0) || (((_la-181)&-(0x1f+1)) == 0 && ((1<<uint((_la-181)))&((1<<(Cobol85ParserENTER-181))|(1<<(Cobol85ParserENTRY_PROCEDURE-181))|(1<<(Cobol85ParserERASE-181))|(1<<(Cobol85ParserEOL-181))|(1<<(Cobol85ParserEOS-181))|(1<<(Cobol85ParserESCAPE-181))|(1<<(Cobol85ParserEVENT-181))|(1<<(Cobol85ParserEXCLUSIVE-181))|(1<<(Cobol85ParserEXPORT-181))|(1<<(Cobol85ParserEXTENDED-181)))) != 0) || (((_la-213)&-(0x1f+1)) == 0 && ((1<<uint((_la-213)))&((1<<(Cobol85ParserFOREGROUND_COLOR-213))|(1<<(Cobol85ParserFOREGROUND_COLOUR-213))|(1<<(Cobol85ParserFULL-213))|(1<<(Cobol85ParserFUNCTION-213))|(1<<(Cobol85ParserFUNCTIONNAME-213))|(1<<(Cobol85ParserFUNCTION_POINTER-213))|(1<<(Cobol85ParserGRID-213))|(1<<(Cobol85ParserHIGHLIGHT-213))|(1<<(Cobol85ParserIMPLICIT-213))|(1<<(Cobol85ParserIMPORT-213)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(Cobol85ParserINTEGER-250))|(1<<(Cobol85ParserKEPT-250))|(1<<(Cobol85ParserKEYBOARD-250))|(1<<(Cobol85ParserLANGUAGE-250))|(1<<(Cobol85ParserLB-250))|(1<<(Cobol85ParserLD-250))|(1<<(Cobol85ParserLEFTLINE-250))|(1<<(Cobol85ParserLENGTH-250))|(1<<(Cobol85ParserLENGTH_CHECK-250))|(1<<(Cobol85ParserLIBACCESS-250))|(1<<(Cobol85ParserLIBPARAMETER-250))|(1<<(Cobol85ParserLIBRARY-250))|(1<<(Cobol85ParserLINAGE_COUNTER-250))|(1<<(Cobol85ParserLINE_COUNTER-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(Cobol85ParserLIST-283))|(1<<(Cobol85ParserLOCAL-283))|(1<<(Cobol85ParserLONG_DATE-283))|(1<<(Cobol85ParserLONG_TIME-283))|(1<<(Cobol85ParserLOWER-283))|(1<<(Cobol85ParserLOWLIGHT-283))|(1<<(Cobol85ParserMMDDYYYY-283))|(1<<(Cobol85ParserNAMED-283))|(1<<(Cobol85ParserNATIONAL-283))|(1<<(Cobol85ParserNATIONAL_EDITED-283))|(1<<(Cobol85ParserNETWORK-283))|(1<<(Cobol85ParserNO_ECHO-283)))) != 0) || (((_la-317)&-(0x1f+1)) == 0 && ((1<<uint((_la-317)))&((1<<(Cobol85ParserNUMERIC_DATE-317))|(1<<(Cobol85ParserNUMERIC_TIME-317))|(1<<(Cobol85ParserODT-317))|(1<<(Cobol85ParserORDERLY-317))|(1<<(Cobol85ParserOVERLINE-317))|(1<<(Cobol85ParserOWN-317))|(1<<(Cobol85ParserPAGE_COUNTER-317))|(1<<(Cobol85ParserPASSWORD-317)))) != 0) || (((_la-352)&-(0x1f+1)) == 0 && ((1<<uint((_la-352)))&((1<<(Cobol85ParserPORT-352))|(1<<(Cobol85ParserPRINTER-352))|(1<<(Cobol85ParserPRIVATE-352))|(1<<(Cobol85ParserPROCESS-352))|(1<<(Cobol85ParserPROGRAM-352))|(1<<(Cobol85ParserPROMPT-352))|(1<<(Cobol85ParserREADER-352))|(1<<(Cobol85ParserREMOTE-352))|(1<<(Cobol85ParserREAL-352))|(1<<(Cobol85ParserRECEIVED-352))|(1<<(Cobol85ParserRECURSIVE-352))|(1<<(Cobol85ParserREF-352)))) != 0) || (((_la-391)&-(0x1f+1)) == 0 && ((1<<uint((_la-391)))&((1<<(Cobol85ParserREMOVE-391))|(1<<(Cobol85ParserREQUIRED-391))|(1<<(Cobol85ParserREVERSE_VIDEO-391))|(1<<(Cobol85ParserRETURN_CODE-391))|(1<<(Cobol85ParserSAVE-391))|(1<<(Cobol85ParserSECURE-391)))) != 0) || (((_la-431)&-(0x1f+1)) == 0 && ((1<<uint((_la-431)))&((1<<(Cobol85ParserSHARED-431))|(1<<(Cobol85ParserSHAREDBYALL-431))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-431))|(1<<(Cobol85ParserSHARING-431))|(1<<(Cobol85ParserSHIFT_IN-431))|(1<<(Cobol85ParserSHIFT_OUT-431))|(1<<(Cobol85ParserSHORT_DATE-431))|(1<<(Cobol85ParserSORT_CONTROL-431))|(1<<(Cobol85ParserSORT_CORE_SIZE-431))|(1<<(Cobol85ParserSORT_FILE_SIZE-431))|(1<<(Cobol85ParserSORT_MESSAGE-431))|(1<<(Cobol85ParserSORT_MODE_SIZE-431))|(1<<(Cobol85ParserSORT_RETURN-431)))) != 0) || (((_la-466)&-(0x1f+1)) == 0 && ((1<<uint((_la-466)))&((1<<(Cobol85ParserSYMBOL-466))|(1<<(Cobol85ParserTALLY-466))|(1<<(Cobol85ParserTASK-466))|(1<<(Cobol85ParserTHREAD-466))|(1<<(Cobol85ParserTHREAD_LOCAL-466))|(1<<(Cobol85ParserTIME-466))|(1<<(Cobol85ParserTIMER-466))|(1<<(Cobol85ParserTODAYS_DATE-466))|(1<<(Cobol85ParserTODAYS_NAME-466))|(1<<(Cobol85ParserTRUNCATED-466))|(1<<(Cobol85ParserTYPEDEF-466)))) != 0) || (((_la-498)&-(0x1f+1)) == 0 && ((1<<uint((_la-498)))&((1<<(Cobol85ParserUNDERLINE-498))|(1<<(Cobol85ParserVIRTUAL-498))|(1<<(Cobol85ParserWAIT-498))|(1<<(Cobol85ParserWHEN_COMPILED-498))|(1<<(Cobol85ParserYEAR-498))|(1<<(Cobol85ParserYYYYMMDD-498))|(1<<(Cobol85ParserYYYYDDD-498))|(1<<(Cobol85ParserZERO_FILL-498)))) != 0) || (((_la-552)&-(0x1f+1)) == 0 && ((1<<uint((_la-552)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-552))|(1<<(Cobol85ParserLEVEL_NUMBER_77-552))|(1<<(Cobol85ParserLEVEL_NUMBER_88-552))|(1<<(Cobol85ParserINTEGERLITERAL-552))|(1<<(Cobol85ParserIDENTIFIER-552)))) != 0) {
		{
			p.SetState(4607)
			p.Identifier()
		}

		p.SetState(4610)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IMoveCorrespondingToSendingAreaContext is an interface to support dynamic dispatch.
type IMoveCorrespondingToSendingAreaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMoveCorrespondingToSendingAreaContext differentiates from other interfaces.
	IsMoveCorrespondingToSendingAreaContext()
}

type MoveCorrespondingToSendingAreaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMoveCorrespondingToSendingAreaContext() *MoveCorrespondingToSendingAreaContext {
	var p = new(MoveCorrespondingToSendingAreaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_moveCorrespondingToSendingArea
	return p
}

func (*MoveCorrespondingToSendingAreaContext) IsMoveCorrespondingToSendingAreaContext() {}

func NewMoveCorrespondingToSendingAreaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MoveCorrespondingToSendingAreaContext {
	var p = new(MoveCorrespondingToSendingAreaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_moveCorrespondingToSendingArea

	return p
}

func (s *MoveCorrespondingToSendingAreaContext) GetParser() antlr.Parser { return s.parser }

func (s *MoveCorrespondingToSendingAreaContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MoveCorrespondingToSendingAreaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MoveCorrespondingToSendingAreaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MoveCorrespondingToSendingAreaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMoveCorrespondingToSendingArea(s)
	}
}

func (s *MoveCorrespondingToSendingAreaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMoveCorrespondingToSendingArea(s)
	}
}

func (p *Cobol85Parser) MoveCorrespondingToSendingArea() (localctx IMoveCorrespondingToSendingAreaContext) {
	localctx = NewMoveCorrespondingToSendingAreaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 766, Cobol85ParserRULE_moveCorrespondingToSendingArea)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4612)
		p.Identifier()
	}

	return localctx
}

// IMultiplyStatementContext is an interface to support dynamic dispatch.
type IMultiplyStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMultiplyStatementContext differentiates from other interfaces.
	IsMultiplyStatementContext()
}

type MultiplyStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiplyStatementContext() *MultiplyStatementContext {
	var p = new(MultiplyStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_multiplyStatement
	return p
}

func (*MultiplyStatementContext) IsMultiplyStatementContext() {}

func NewMultiplyStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiplyStatementContext {
	var p = new(MultiplyStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_multiplyStatement

	return p
}

func (s *MultiplyStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiplyStatementContext) MULTIPLY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMULTIPLY, 0)
}

func (s *MultiplyStatementContext) BY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBY, 0)
}

func (s *MultiplyStatementContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MultiplyStatementContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *MultiplyStatementContext) MultiplyRegular() IMultiplyRegularContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMultiplyRegularContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMultiplyRegularContext)
}

func (s *MultiplyStatementContext) MultiplyGiving() IMultiplyGivingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMultiplyGivingContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMultiplyGivingContext)
}

func (s *MultiplyStatementContext) OnSizeErrorPhrase() IOnSizeErrorPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOnSizeErrorPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOnSizeErrorPhraseContext)
}

func (s *MultiplyStatementContext) NotOnSizeErrorPhrase() INotOnSizeErrorPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INotOnSizeErrorPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INotOnSizeErrorPhraseContext)
}

func (s *MultiplyStatementContext) END_MULTIPLY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND_MULTIPLY, 0)
}

func (s *MultiplyStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiplyStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiplyStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMultiplyStatement(s)
	}
}

func (s *MultiplyStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMultiplyStatement(s)
	}
}

func (p *Cobol85Parser) MultiplyStatement() (localctx IMultiplyStatementContext) {
	localctx = NewMultiplyStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 768, Cobol85ParserRULE_multiplyStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4614)
		p.Match(Cobol85ParserMULTIPLY)
	}
	p.SetState(4617)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 665, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4615)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(4616)
			p.Literal()
		}

	}
	{
		p.SetState(4619)
		p.Match(Cobol85ParserBY)
	}
	p.SetState(4622)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 666, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4620)
			p.MultiplyRegular()
		}

	case 2:
		{
			p.SetState(4621)
			p.MultiplyGiving()
		}

	}
	p.SetState(4625)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 667, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4624)
			p.OnSizeErrorPhrase()
		}

	}
	p.SetState(4628)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 668, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4627)
			p.NotOnSizeErrorPhrase()
		}

	}
	p.SetState(4631)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 669, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4630)
			p.Match(Cobol85ParserEND_MULTIPLY)
		}

	}

	return localctx
}

// IMultiplyRegularContext is an interface to support dynamic dispatch.
type IMultiplyRegularContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMultiplyRegularContext differentiates from other interfaces.
	IsMultiplyRegularContext()
}

type MultiplyRegularContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiplyRegularContext() *MultiplyRegularContext {
	var p = new(MultiplyRegularContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_multiplyRegular
	return p
}

func (*MultiplyRegularContext) IsMultiplyRegularContext() {}

func NewMultiplyRegularContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiplyRegularContext {
	var p = new(MultiplyRegularContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_multiplyRegular

	return p
}

func (s *MultiplyRegularContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiplyRegularContext) AllMultiplyRegularOperand() []IMultiplyRegularOperandContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMultiplyRegularOperandContext)(nil)).Elem())
	var tst = make([]IMultiplyRegularOperandContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMultiplyRegularOperandContext)
		}
	}

	return tst
}

func (s *MultiplyRegularContext) MultiplyRegularOperand(i int) IMultiplyRegularOperandContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMultiplyRegularOperandContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMultiplyRegularOperandContext)
}

func (s *MultiplyRegularContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiplyRegularContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiplyRegularContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMultiplyRegular(s)
	}
}

func (s *MultiplyRegularContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMultiplyRegular(s)
	}
}

func (p *Cobol85Parser) MultiplyRegular() (localctx IMultiplyRegularContext) {
	localctx = NewMultiplyRegularContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 770, Cobol85ParserRULE_multiplyRegular)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4634)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserADDRESS)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH)|(1<<Cobol85ParserATTRIBUTE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBINARY-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-68))|(1<<(Cobol85ParserCOBOL-68))|(1<<(Cobol85ParserCOMMITMENT-68))|(1<<(Cobol85ParserCONTROL_POINT-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(Cobol85ParserCONVENTION-100))|(1<<(Cobol85ParserCRUNCH-100))|(1<<(Cobol85ParserCURSOR-100))|(1<<(Cobol85ParserDATE-100))|(1<<(Cobol85ParserDAY-100))|(1<<(Cobol85ParserDAY_OF_WEEK-100))|(1<<(Cobol85ParserDEBUG_CONTENTS-100))|(1<<(Cobol85ParserDEBUG_ITEM-100))|(1<<(Cobol85ParserDEBUG_LINE-100))|(1<<(Cobol85ParserDEBUG_NAME-100))|(1<<(Cobol85ParserDEBUG_SUB_1-100))|(1<<(Cobol85ParserDEBUG_SUB_2-100))|(1<<(Cobol85ParserDEBUG_SUB_3-100))|(1<<(Cobol85ParserDEFAULT-100))|(1<<(Cobol85ParserDEFAULT_DISPLAY-100))|(1<<(Cobol85ParserDEFINITION-100)))) != 0) || (((_la-138)&-(0x1f+1)) == 0 && ((1<<uint((_la-138)))&((1<<(Cobol85ParserDFHRESP-138))|(1<<(Cobol85ParserDFHVALUE-138))|(1<<(Cobol85ParserDISK-138))|(1<<(Cobol85ParserDONTCARE-138))|(1<<(Cobol85ParserDOUBLE-138))|(1<<(Cobol85ParserEBCDIC-138))|(1<<(Cobol85ParserEMPTY_CHECK-138)))) != 0) || (((_la-181)&-(0x1f+1)) == 0 && ((1<<uint((_la-181)))&((1<<(Cobol85ParserENTER-181))|(1<<(Cobol85ParserENTRY_PROCEDURE-181))|(1<<(Cobol85ParserERASE-181))|(1<<(Cobol85ParserEOL-181))|(1<<(Cobol85ParserEOS-181))|(1<<(Cobol85ParserESCAPE-181))|(1<<(Cobol85ParserEVENT-181))|(1<<(Cobol85ParserEXCLUSIVE-181))|(1<<(Cobol85ParserEXPORT-181))|(1<<(Cobol85ParserEXTENDED-181)))) != 0) || (((_la-213)&-(0x1f+1)) == 0 && ((1<<uint((_la-213)))&((1<<(Cobol85ParserFOREGROUND_COLOR-213))|(1<<(Cobol85ParserFOREGROUND_COLOUR-213))|(1<<(Cobol85ParserFULL-213))|(1<<(Cobol85ParserFUNCTION-213))|(1<<(Cobol85ParserFUNCTIONNAME-213))|(1<<(Cobol85ParserFUNCTION_POINTER-213))|(1<<(Cobol85ParserGRID-213))|(1<<(Cobol85ParserHIGHLIGHT-213))|(1<<(Cobol85ParserIMPLICIT-213))|(1<<(Cobol85ParserIMPORT-213)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(Cobol85ParserINTEGER-250))|(1<<(Cobol85ParserKEPT-250))|(1<<(Cobol85ParserKEYBOARD-250))|(1<<(Cobol85ParserLANGUAGE-250))|(1<<(Cobol85ParserLB-250))|(1<<(Cobol85ParserLD-250))|(1<<(Cobol85ParserLEFTLINE-250))|(1<<(Cobol85ParserLENGTH-250))|(1<<(Cobol85ParserLENGTH_CHECK-250))|(1<<(Cobol85ParserLIBACCESS-250))|(1<<(Cobol85ParserLIBPARAMETER-250))|(1<<(Cobol85ParserLIBRARY-250))|(1<<(Cobol85ParserLINAGE_COUNTER-250))|(1<<(Cobol85ParserLINE_COUNTER-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(Cobol85ParserLIST-283))|(1<<(Cobol85ParserLOCAL-283))|(1<<(Cobol85ParserLONG_DATE-283))|(1<<(Cobol85ParserLONG_TIME-283))|(1<<(Cobol85ParserLOWER-283))|(1<<(Cobol85ParserLOWLIGHT-283))|(1<<(Cobol85ParserMMDDYYYY-283))|(1<<(Cobol85ParserNAMED-283))|(1<<(Cobol85ParserNATIONAL-283))|(1<<(Cobol85ParserNATIONAL_EDITED-283))|(1<<(Cobol85ParserNETWORK-283))|(1<<(Cobol85ParserNO_ECHO-283)))) != 0) || (((_la-317)&-(0x1f+1)) == 0 && ((1<<uint((_la-317)))&((1<<(Cobol85ParserNUMERIC_DATE-317))|(1<<(Cobol85ParserNUMERIC_TIME-317))|(1<<(Cobol85ParserODT-317))|(1<<(Cobol85ParserORDERLY-317))|(1<<(Cobol85ParserOVERLINE-317))|(1<<(Cobol85ParserOWN-317))|(1<<(Cobol85ParserPAGE_COUNTER-317))|(1<<(Cobol85ParserPASSWORD-317)))) != 0) || (((_la-352)&-(0x1f+1)) == 0 && ((1<<uint((_la-352)))&((1<<(Cobol85ParserPORT-352))|(1<<(Cobol85ParserPRINTER-352))|(1<<(Cobol85ParserPRIVATE-352))|(1<<(Cobol85ParserPROCESS-352))|(1<<(Cobol85ParserPROGRAM-352))|(1<<(Cobol85ParserPROMPT-352))|(1<<(Cobol85ParserREADER-352))|(1<<(Cobol85ParserREMOTE-352))|(1<<(Cobol85ParserREAL-352))|(1<<(Cobol85ParserRECEIVED-352))|(1<<(Cobol85ParserRECURSIVE-352))|(1<<(Cobol85ParserREF-352)))) != 0) || (((_la-391)&-(0x1f+1)) == 0 && ((1<<uint((_la-391)))&((1<<(Cobol85ParserREMOVE-391))|(1<<(Cobol85ParserREQUIRED-391))|(1<<(Cobol85ParserREVERSE_VIDEO-391))|(1<<(Cobol85ParserRETURN_CODE-391))|(1<<(Cobol85ParserSAVE-391))|(1<<(Cobol85ParserSECURE-391)))) != 0) || (((_la-431)&-(0x1f+1)) == 0 && ((1<<uint((_la-431)))&((1<<(Cobol85ParserSHARED-431))|(1<<(Cobol85ParserSHAREDBYALL-431))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-431))|(1<<(Cobol85ParserSHARING-431))|(1<<(Cobol85ParserSHIFT_IN-431))|(1<<(Cobol85ParserSHIFT_OUT-431))|(1<<(Cobol85ParserSHORT_DATE-431))|(1<<(Cobol85ParserSORT_CONTROL-431))|(1<<(Cobol85ParserSORT_CORE_SIZE-431))|(1<<(Cobol85ParserSORT_FILE_SIZE-431))|(1<<(Cobol85ParserSORT_MESSAGE-431))|(1<<(Cobol85ParserSORT_MODE_SIZE-431))|(1<<(Cobol85ParserSORT_RETURN-431)))) != 0) || (((_la-466)&-(0x1f+1)) == 0 && ((1<<uint((_la-466)))&((1<<(Cobol85ParserSYMBOL-466))|(1<<(Cobol85ParserTALLY-466))|(1<<(Cobol85ParserTASK-466))|(1<<(Cobol85ParserTHREAD-466))|(1<<(Cobol85ParserTHREAD_LOCAL-466))|(1<<(Cobol85ParserTIME-466))|(1<<(Cobol85ParserTIMER-466))|(1<<(Cobol85ParserTODAYS_DATE-466))|(1<<(Cobol85ParserTODAYS_NAME-466))|(1<<(Cobol85ParserTRUNCATED-466))|(1<<(Cobol85ParserTYPEDEF-466)))) != 0) || (((_la-498)&-(0x1f+1)) == 0 && ((1<<uint((_la-498)))&((1<<(Cobol85ParserUNDERLINE-498))|(1<<(Cobol85ParserVIRTUAL-498))|(1<<(Cobol85ParserWAIT-498))|(1<<(Cobol85ParserWHEN_COMPILED-498))|(1<<(Cobol85ParserYEAR-498))|(1<<(Cobol85ParserYYYYMMDD-498))|(1<<(Cobol85ParserYYYYDDD-498))|(1<<(Cobol85ParserZERO_FILL-498)))) != 0) || (((_la-552)&-(0x1f+1)) == 0 && ((1<<uint((_la-552)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-552))|(1<<(Cobol85ParserLEVEL_NUMBER_77-552))|(1<<(Cobol85ParserLEVEL_NUMBER_88-552))|(1<<(Cobol85ParserINTEGERLITERAL-552))|(1<<(Cobol85ParserIDENTIFIER-552)))) != 0) {
		{
			p.SetState(4633)
			p.MultiplyRegularOperand()
		}

		p.SetState(4636)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IMultiplyRegularOperandContext is an interface to support dynamic dispatch.
type IMultiplyRegularOperandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMultiplyRegularOperandContext differentiates from other interfaces.
	IsMultiplyRegularOperandContext()
}

type MultiplyRegularOperandContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiplyRegularOperandContext() *MultiplyRegularOperandContext {
	var p = new(MultiplyRegularOperandContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_multiplyRegularOperand
	return p
}

func (*MultiplyRegularOperandContext) IsMultiplyRegularOperandContext() {}

func NewMultiplyRegularOperandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiplyRegularOperandContext {
	var p = new(MultiplyRegularOperandContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_multiplyRegularOperand

	return p
}

func (s *MultiplyRegularOperandContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiplyRegularOperandContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MultiplyRegularOperandContext) ROUNDED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserROUNDED, 0)
}

func (s *MultiplyRegularOperandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiplyRegularOperandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiplyRegularOperandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMultiplyRegularOperand(s)
	}
}

func (s *MultiplyRegularOperandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMultiplyRegularOperand(s)
	}
}

func (p *Cobol85Parser) MultiplyRegularOperand() (localctx IMultiplyRegularOperandContext) {
	localctx = NewMultiplyRegularOperandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 772, Cobol85ParserRULE_multiplyRegularOperand)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4638)
		p.Identifier()
	}
	p.SetState(4640)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserROUNDED {
		{
			p.SetState(4639)
			p.Match(Cobol85ParserROUNDED)
		}

	}

	return localctx
}

// IMultiplyGivingContext is an interface to support dynamic dispatch.
type IMultiplyGivingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMultiplyGivingContext differentiates from other interfaces.
	IsMultiplyGivingContext()
}

type MultiplyGivingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiplyGivingContext() *MultiplyGivingContext {
	var p = new(MultiplyGivingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_multiplyGiving
	return p
}

func (*MultiplyGivingContext) IsMultiplyGivingContext() {}

func NewMultiplyGivingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiplyGivingContext {
	var p = new(MultiplyGivingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_multiplyGiving

	return p
}

func (s *MultiplyGivingContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiplyGivingContext) MultiplyGivingOperand() IMultiplyGivingOperandContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMultiplyGivingOperandContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMultiplyGivingOperandContext)
}

func (s *MultiplyGivingContext) GIVING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserGIVING, 0)
}

func (s *MultiplyGivingContext) AllMultiplyGivingResult() []IMultiplyGivingResultContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMultiplyGivingResultContext)(nil)).Elem())
	var tst = make([]IMultiplyGivingResultContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMultiplyGivingResultContext)
		}
	}

	return tst
}

func (s *MultiplyGivingContext) MultiplyGivingResult(i int) IMultiplyGivingResultContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMultiplyGivingResultContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMultiplyGivingResultContext)
}

func (s *MultiplyGivingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiplyGivingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiplyGivingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMultiplyGiving(s)
	}
}

func (s *MultiplyGivingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMultiplyGiving(s)
	}
}

func (p *Cobol85Parser) MultiplyGiving() (localctx IMultiplyGivingContext) {
	localctx = NewMultiplyGivingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 774, Cobol85ParserRULE_multiplyGiving)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4642)
		p.MultiplyGivingOperand()
	}
	{
		p.SetState(4643)
		p.Match(Cobol85ParserGIVING)
	}
	p.SetState(4645)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserADDRESS)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH)|(1<<Cobol85ParserATTRIBUTE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBINARY-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-68))|(1<<(Cobol85ParserCOBOL-68))|(1<<(Cobol85ParserCOMMITMENT-68))|(1<<(Cobol85ParserCONTROL_POINT-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(Cobol85ParserCONVENTION-100))|(1<<(Cobol85ParserCRUNCH-100))|(1<<(Cobol85ParserCURSOR-100))|(1<<(Cobol85ParserDATE-100))|(1<<(Cobol85ParserDAY-100))|(1<<(Cobol85ParserDAY_OF_WEEK-100))|(1<<(Cobol85ParserDEBUG_CONTENTS-100))|(1<<(Cobol85ParserDEBUG_ITEM-100))|(1<<(Cobol85ParserDEBUG_LINE-100))|(1<<(Cobol85ParserDEBUG_NAME-100))|(1<<(Cobol85ParserDEBUG_SUB_1-100))|(1<<(Cobol85ParserDEBUG_SUB_2-100))|(1<<(Cobol85ParserDEBUG_SUB_3-100))|(1<<(Cobol85ParserDEFAULT-100))|(1<<(Cobol85ParserDEFAULT_DISPLAY-100))|(1<<(Cobol85ParserDEFINITION-100)))) != 0) || (((_la-138)&-(0x1f+1)) == 0 && ((1<<uint((_la-138)))&((1<<(Cobol85ParserDFHRESP-138))|(1<<(Cobol85ParserDFHVALUE-138))|(1<<(Cobol85ParserDISK-138))|(1<<(Cobol85ParserDONTCARE-138))|(1<<(Cobol85ParserDOUBLE-138))|(1<<(Cobol85ParserEBCDIC-138))|(1<<(Cobol85ParserEMPTY_CHECK-138)))) != 0) || (((_la-181)&-(0x1f+1)) == 0 && ((1<<uint((_la-181)))&((1<<(Cobol85ParserENTER-181))|(1<<(Cobol85ParserENTRY_PROCEDURE-181))|(1<<(Cobol85ParserERASE-181))|(1<<(Cobol85ParserEOL-181))|(1<<(Cobol85ParserEOS-181))|(1<<(Cobol85ParserESCAPE-181))|(1<<(Cobol85ParserEVENT-181))|(1<<(Cobol85ParserEXCLUSIVE-181))|(1<<(Cobol85ParserEXPORT-181))|(1<<(Cobol85ParserEXTENDED-181)))) != 0) || (((_la-213)&-(0x1f+1)) == 0 && ((1<<uint((_la-213)))&((1<<(Cobol85ParserFOREGROUND_COLOR-213))|(1<<(Cobol85ParserFOREGROUND_COLOUR-213))|(1<<(Cobol85ParserFULL-213))|(1<<(Cobol85ParserFUNCTION-213))|(1<<(Cobol85ParserFUNCTIONNAME-213))|(1<<(Cobol85ParserFUNCTION_POINTER-213))|(1<<(Cobol85ParserGRID-213))|(1<<(Cobol85ParserHIGHLIGHT-213))|(1<<(Cobol85ParserIMPLICIT-213))|(1<<(Cobol85ParserIMPORT-213)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(Cobol85ParserINTEGER-250))|(1<<(Cobol85ParserKEPT-250))|(1<<(Cobol85ParserKEYBOARD-250))|(1<<(Cobol85ParserLANGUAGE-250))|(1<<(Cobol85ParserLB-250))|(1<<(Cobol85ParserLD-250))|(1<<(Cobol85ParserLEFTLINE-250))|(1<<(Cobol85ParserLENGTH-250))|(1<<(Cobol85ParserLENGTH_CHECK-250))|(1<<(Cobol85ParserLIBACCESS-250))|(1<<(Cobol85ParserLIBPARAMETER-250))|(1<<(Cobol85ParserLIBRARY-250))|(1<<(Cobol85ParserLINAGE_COUNTER-250))|(1<<(Cobol85ParserLINE_COUNTER-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(Cobol85ParserLIST-283))|(1<<(Cobol85ParserLOCAL-283))|(1<<(Cobol85ParserLONG_DATE-283))|(1<<(Cobol85ParserLONG_TIME-283))|(1<<(Cobol85ParserLOWER-283))|(1<<(Cobol85ParserLOWLIGHT-283))|(1<<(Cobol85ParserMMDDYYYY-283))|(1<<(Cobol85ParserNAMED-283))|(1<<(Cobol85ParserNATIONAL-283))|(1<<(Cobol85ParserNATIONAL_EDITED-283))|(1<<(Cobol85ParserNETWORK-283))|(1<<(Cobol85ParserNO_ECHO-283)))) != 0) || (((_la-317)&-(0x1f+1)) == 0 && ((1<<uint((_la-317)))&((1<<(Cobol85ParserNUMERIC_DATE-317))|(1<<(Cobol85ParserNUMERIC_TIME-317))|(1<<(Cobol85ParserODT-317))|(1<<(Cobol85ParserORDERLY-317))|(1<<(Cobol85ParserOVERLINE-317))|(1<<(Cobol85ParserOWN-317))|(1<<(Cobol85ParserPAGE_COUNTER-317))|(1<<(Cobol85ParserPASSWORD-317)))) != 0) || (((_la-352)&-(0x1f+1)) == 0 && ((1<<uint((_la-352)))&((1<<(Cobol85ParserPORT-352))|(1<<(Cobol85ParserPRINTER-352))|(1<<(Cobol85ParserPRIVATE-352))|(1<<(Cobol85ParserPROCESS-352))|(1<<(Cobol85ParserPROGRAM-352))|(1<<(Cobol85ParserPROMPT-352))|(1<<(Cobol85ParserREADER-352))|(1<<(Cobol85ParserREMOTE-352))|(1<<(Cobol85ParserREAL-352))|(1<<(Cobol85ParserRECEIVED-352))|(1<<(Cobol85ParserRECURSIVE-352))|(1<<(Cobol85ParserREF-352)))) != 0) || (((_la-391)&-(0x1f+1)) == 0 && ((1<<uint((_la-391)))&((1<<(Cobol85ParserREMOVE-391))|(1<<(Cobol85ParserREQUIRED-391))|(1<<(Cobol85ParserREVERSE_VIDEO-391))|(1<<(Cobol85ParserRETURN_CODE-391))|(1<<(Cobol85ParserSAVE-391))|(1<<(Cobol85ParserSECURE-391)))) != 0) || (((_la-431)&-(0x1f+1)) == 0 && ((1<<uint((_la-431)))&((1<<(Cobol85ParserSHARED-431))|(1<<(Cobol85ParserSHAREDBYALL-431))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-431))|(1<<(Cobol85ParserSHARING-431))|(1<<(Cobol85ParserSHIFT_IN-431))|(1<<(Cobol85ParserSHIFT_OUT-431))|(1<<(Cobol85ParserSHORT_DATE-431))|(1<<(Cobol85ParserSORT_CONTROL-431))|(1<<(Cobol85ParserSORT_CORE_SIZE-431))|(1<<(Cobol85ParserSORT_FILE_SIZE-431))|(1<<(Cobol85ParserSORT_MESSAGE-431))|(1<<(Cobol85ParserSORT_MODE_SIZE-431))|(1<<(Cobol85ParserSORT_RETURN-431)))) != 0) || (((_la-466)&-(0x1f+1)) == 0 && ((1<<uint((_la-466)))&((1<<(Cobol85ParserSYMBOL-466))|(1<<(Cobol85ParserTALLY-466))|(1<<(Cobol85ParserTASK-466))|(1<<(Cobol85ParserTHREAD-466))|(1<<(Cobol85ParserTHREAD_LOCAL-466))|(1<<(Cobol85ParserTIME-466))|(1<<(Cobol85ParserTIMER-466))|(1<<(Cobol85ParserTODAYS_DATE-466))|(1<<(Cobol85ParserTODAYS_NAME-466))|(1<<(Cobol85ParserTRUNCATED-466))|(1<<(Cobol85ParserTYPEDEF-466)))) != 0) || (((_la-498)&-(0x1f+1)) == 0 && ((1<<uint((_la-498)))&((1<<(Cobol85ParserUNDERLINE-498))|(1<<(Cobol85ParserVIRTUAL-498))|(1<<(Cobol85ParserWAIT-498))|(1<<(Cobol85ParserWHEN_COMPILED-498))|(1<<(Cobol85ParserYEAR-498))|(1<<(Cobol85ParserYYYYMMDD-498))|(1<<(Cobol85ParserYYYYDDD-498))|(1<<(Cobol85ParserZERO_FILL-498)))) != 0) || (((_la-552)&-(0x1f+1)) == 0 && ((1<<uint((_la-552)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-552))|(1<<(Cobol85ParserLEVEL_NUMBER_77-552))|(1<<(Cobol85ParserLEVEL_NUMBER_88-552))|(1<<(Cobol85ParserINTEGERLITERAL-552))|(1<<(Cobol85ParserIDENTIFIER-552)))) != 0) {
		{
			p.SetState(4644)
			p.MultiplyGivingResult()
		}

		p.SetState(4647)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IMultiplyGivingOperandContext is an interface to support dynamic dispatch.
type IMultiplyGivingOperandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMultiplyGivingOperandContext differentiates from other interfaces.
	IsMultiplyGivingOperandContext()
}

type MultiplyGivingOperandContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiplyGivingOperandContext() *MultiplyGivingOperandContext {
	var p = new(MultiplyGivingOperandContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_multiplyGivingOperand
	return p
}

func (*MultiplyGivingOperandContext) IsMultiplyGivingOperandContext() {}

func NewMultiplyGivingOperandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiplyGivingOperandContext {
	var p = new(MultiplyGivingOperandContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_multiplyGivingOperand

	return p
}

func (s *MultiplyGivingOperandContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiplyGivingOperandContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MultiplyGivingOperandContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *MultiplyGivingOperandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiplyGivingOperandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiplyGivingOperandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMultiplyGivingOperand(s)
	}
}

func (s *MultiplyGivingOperandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMultiplyGivingOperand(s)
	}
}

func (p *Cobol85Parser) MultiplyGivingOperand() (localctx IMultiplyGivingOperandContext) {
	localctx = NewMultiplyGivingOperandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 776, Cobol85ParserRULE_multiplyGivingOperand)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4651)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 673, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4649)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4650)
			p.Literal()
		}

	}

	return localctx
}

// IMultiplyGivingResultContext is an interface to support dynamic dispatch.
type IMultiplyGivingResultContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMultiplyGivingResultContext differentiates from other interfaces.
	IsMultiplyGivingResultContext()
}

type MultiplyGivingResultContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiplyGivingResultContext() *MultiplyGivingResultContext {
	var p = new(MultiplyGivingResultContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_multiplyGivingResult
	return p
}

func (*MultiplyGivingResultContext) IsMultiplyGivingResultContext() {}

func NewMultiplyGivingResultContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiplyGivingResultContext {
	var p = new(MultiplyGivingResultContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_multiplyGivingResult

	return p
}

func (s *MultiplyGivingResultContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiplyGivingResultContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MultiplyGivingResultContext) ROUNDED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserROUNDED, 0)
}

func (s *MultiplyGivingResultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiplyGivingResultContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiplyGivingResultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMultiplyGivingResult(s)
	}
}

func (s *MultiplyGivingResultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMultiplyGivingResult(s)
	}
}

func (p *Cobol85Parser) MultiplyGivingResult() (localctx IMultiplyGivingResultContext) {
	localctx = NewMultiplyGivingResultContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 778, Cobol85ParserRULE_multiplyGivingResult)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4653)
		p.Identifier()
	}
	p.SetState(4655)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserROUNDED {
		{
			p.SetState(4654)
			p.Match(Cobol85ParserROUNDED)
		}

	}

	return localctx
}

// IOpenStatementContext is an interface to support dynamic dispatch.
type IOpenStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOpenStatementContext differentiates from other interfaces.
	IsOpenStatementContext()
}

type OpenStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpenStatementContext() *OpenStatementContext {
	var p = new(OpenStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_openStatement
	return p
}

func (*OpenStatementContext) IsOpenStatementContext() {}

func NewOpenStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OpenStatementContext {
	var p = new(OpenStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_openStatement

	return p
}

func (s *OpenStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *OpenStatementContext) OPEN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOPEN, 0)
}

func (s *OpenStatementContext) AllOpenInputStatement() []IOpenInputStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOpenInputStatementContext)(nil)).Elem())
	var tst = make([]IOpenInputStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOpenInputStatementContext)
		}
	}

	return tst
}

func (s *OpenStatementContext) OpenInputStatement(i int) IOpenInputStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOpenInputStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOpenInputStatementContext)
}

func (s *OpenStatementContext) AllOpenOutputStatement() []IOpenOutputStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOpenOutputStatementContext)(nil)).Elem())
	var tst = make([]IOpenOutputStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOpenOutputStatementContext)
		}
	}

	return tst
}

func (s *OpenStatementContext) OpenOutputStatement(i int) IOpenOutputStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOpenOutputStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOpenOutputStatementContext)
}

func (s *OpenStatementContext) AllOpenIOStatement() []IOpenIOStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOpenIOStatementContext)(nil)).Elem())
	var tst = make([]IOpenIOStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOpenIOStatementContext)
		}
	}

	return tst
}

func (s *OpenStatementContext) OpenIOStatement(i int) IOpenIOStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOpenIOStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOpenIOStatementContext)
}

func (s *OpenStatementContext) AllOpenExtendStatement() []IOpenExtendStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOpenExtendStatementContext)(nil)).Elem())
	var tst = make([]IOpenExtendStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOpenExtendStatementContext)
		}
	}

	return tst
}

func (s *OpenStatementContext) OpenExtendStatement(i int) IOpenExtendStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOpenExtendStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOpenExtendStatementContext)
}

func (s *OpenStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OpenStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OpenStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterOpenStatement(s)
	}
}

func (s *OpenStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitOpenStatement(s)
	}
}

func (p *Cobol85Parser) OpenStatement() (localctx IOpenStatementContext) {
	localctx = NewOpenStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 780, Cobol85ParserRULE_openStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4657)
		p.Match(Cobol85ParserOPEN)
	}
	p.SetState(4662)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == Cobol85ParserEXTEND || _la == Cobol85ParserI_O || _la == Cobol85ParserINPUT || _la == Cobol85ParserOUTPUT {
		p.SetState(4662)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case Cobol85ParserINPUT:
			{
				p.SetState(4658)
				p.OpenInputStatement()
			}

		case Cobol85ParserOUTPUT:
			{
				p.SetState(4659)
				p.OpenOutputStatement()
			}

		case Cobol85ParserI_O:
			{
				p.SetState(4660)
				p.OpenIOStatement()
			}

		case Cobol85ParserEXTEND:
			{
				p.SetState(4661)
				p.OpenExtendStatement()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(4664)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IOpenInputStatementContext is an interface to support dynamic dispatch.
type IOpenInputStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOpenInputStatementContext differentiates from other interfaces.
	IsOpenInputStatementContext()
}

type OpenInputStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpenInputStatementContext() *OpenInputStatementContext {
	var p = new(OpenInputStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_openInputStatement
	return p
}

func (*OpenInputStatementContext) IsOpenInputStatementContext() {}

func NewOpenInputStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OpenInputStatementContext {
	var p = new(OpenInputStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_openInputStatement

	return p
}

func (s *OpenInputStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *OpenInputStatementContext) INPUT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINPUT, 0)
}

func (s *OpenInputStatementContext) AllOpenInput() []IOpenInputContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOpenInputContext)(nil)).Elem())
	var tst = make([]IOpenInputContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOpenInputContext)
		}
	}

	return tst
}

func (s *OpenInputStatementContext) OpenInput(i int) IOpenInputContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOpenInputContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOpenInputContext)
}

func (s *OpenInputStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OpenInputStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OpenInputStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterOpenInputStatement(s)
	}
}

func (s *OpenInputStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitOpenInputStatement(s)
	}
}

func (p *Cobol85Parser) OpenInputStatement() (localctx IOpenInputStatementContext) {
	localctx = NewOpenInputStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 782, Cobol85ParserRULE_openInputStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4666)
		p.Match(Cobol85ParserINPUT)
	}
	p.SetState(4668)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH)|(1<<Cobol85ParserATTRIBUTE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBINARY-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-68))|(1<<(Cobol85ParserCOBOL-68))|(1<<(Cobol85ParserCOMMITMENT-68))|(1<<(Cobol85ParserCONTROL_POINT-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(Cobol85ParserCONVENTION-100))|(1<<(Cobol85ParserCRUNCH-100))|(1<<(Cobol85ParserCURSOR-100))|(1<<(Cobol85ParserDEFAULT-100))|(1<<(Cobol85ParserDEFAULT_DISPLAY-100))|(1<<(Cobol85ParserDEFINITION-100)))) != 0) || (((_la-138)&-(0x1f+1)) == 0 && ((1<<uint((_la-138)))&((1<<(Cobol85ParserDFHRESP-138))|(1<<(Cobol85ParserDFHVALUE-138))|(1<<(Cobol85ParserDISK-138))|(1<<(Cobol85ParserDONTCARE-138))|(1<<(Cobol85ParserDOUBLE-138))|(1<<(Cobol85ParserEBCDIC-138))|(1<<(Cobol85ParserEMPTY_CHECK-138)))) != 0) || (((_la-181)&-(0x1f+1)) == 0 && ((1<<uint((_la-181)))&((1<<(Cobol85ParserENTER-181))|(1<<(Cobol85ParserENTRY_PROCEDURE-181))|(1<<(Cobol85ParserERASE-181))|(1<<(Cobol85ParserEOL-181))|(1<<(Cobol85ParserEOS-181))|(1<<(Cobol85ParserESCAPE-181))|(1<<(Cobol85ParserEVENT-181))|(1<<(Cobol85ParserEXCLUSIVE-181))|(1<<(Cobol85ParserEXPORT-181))|(1<<(Cobol85ParserEXTENDED-181)))) != 0) || (((_la-213)&-(0x1f+1)) == 0 && ((1<<uint((_la-213)))&((1<<(Cobol85ParserFOREGROUND_COLOR-213))|(1<<(Cobol85ParserFOREGROUND_COLOUR-213))|(1<<(Cobol85ParserFULL-213))|(1<<(Cobol85ParserFUNCTIONNAME-213))|(1<<(Cobol85ParserFUNCTION_POINTER-213))|(1<<(Cobol85ParserGRID-213))|(1<<(Cobol85ParserHIGHLIGHT-213))|(1<<(Cobol85ParserIMPLICIT-213))|(1<<(Cobol85ParserIMPORT-213)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(Cobol85ParserINTEGER-250))|(1<<(Cobol85ParserKEPT-250))|(1<<(Cobol85ParserKEYBOARD-250))|(1<<(Cobol85ParserLANGUAGE-250))|(1<<(Cobol85ParserLB-250))|(1<<(Cobol85ParserLD-250))|(1<<(Cobol85ParserLEFTLINE-250))|(1<<(Cobol85ParserLENGTH_CHECK-250))|(1<<(Cobol85ParserLIBACCESS-250))|(1<<(Cobol85ParserLIBPARAMETER-250))|(1<<(Cobol85ParserLIBRARY-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(Cobol85ParserLIST-283))|(1<<(Cobol85ParserLOCAL-283))|(1<<(Cobol85ParserLONG_DATE-283))|(1<<(Cobol85ParserLONG_TIME-283))|(1<<(Cobol85ParserLOWER-283))|(1<<(Cobol85ParserLOWLIGHT-283))|(1<<(Cobol85ParserMMDDYYYY-283))|(1<<(Cobol85ParserNAMED-283))|(1<<(Cobol85ParserNATIONAL-283))|(1<<(Cobol85ParserNATIONAL_EDITED-283))|(1<<(Cobol85ParserNETWORK-283))|(1<<(Cobol85ParserNO_ECHO-283)))) != 0) || (((_la-317)&-(0x1f+1)) == 0 && ((1<<uint((_la-317)))&((1<<(Cobol85ParserNUMERIC_DATE-317))|(1<<(Cobol85ParserNUMERIC_TIME-317))|(1<<(Cobol85ParserODT-317))|(1<<(Cobol85ParserORDERLY-317))|(1<<(Cobol85ParserOVERLINE-317))|(1<<(Cobol85ParserOWN-317))|(1<<(Cobol85ParserPASSWORD-317)))) != 0) || (((_la-352)&-(0x1f+1)) == 0 && ((1<<uint((_la-352)))&((1<<(Cobol85ParserPORT-352))|(1<<(Cobol85ParserPRINTER-352))|(1<<(Cobol85ParserPRIVATE-352))|(1<<(Cobol85ParserPROCESS-352))|(1<<(Cobol85ParserPROGRAM-352))|(1<<(Cobol85ParserPROMPT-352))|(1<<(Cobol85ParserREADER-352))|(1<<(Cobol85ParserREMOTE-352))|(1<<(Cobol85ParserREAL-352))|(1<<(Cobol85ParserRECEIVED-352))|(1<<(Cobol85ParserRECURSIVE-352))|(1<<(Cobol85ParserREF-352)))) != 0) || (((_la-391)&-(0x1f+1)) == 0 && ((1<<uint((_la-391)))&((1<<(Cobol85ParserREMOVE-391))|(1<<(Cobol85ParserREQUIRED-391))|(1<<(Cobol85ParserREVERSE_VIDEO-391))|(1<<(Cobol85ParserSAVE-391))|(1<<(Cobol85ParserSECURE-391)))) != 0) || (((_la-431)&-(0x1f+1)) == 0 && ((1<<uint((_la-431)))&((1<<(Cobol85ParserSHARED-431))|(1<<(Cobol85ParserSHAREDBYALL-431))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-431))|(1<<(Cobol85ParserSHARING-431))|(1<<(Cobol85ParserSHORT_DATE-431)))) != 0) || (((_la-466)&-(0x1f+1)) == 0 && ((1<<uint((_la-466)))&((1<<(Cobol85ParserSYMBOL-466))|(1<<(Cobol85ParserTASK-466))|(1<<(Cobol85ParserTHREAD-466))|(1<<(Cobol85ParserTHREAD_LOCAL-466))|(1<<(Cobol85ParserTIMER-466))|(1<<(Cobol85ParserTODAYS_DATE-466))|(1<<(Cobol85ParserTODAYS_NAME-466))|(1<<(Cobol85ParserTRUNCATED-466))|(1<<(Cobol85ParserTYPEDEF-466)))) != 0) || (((_la-498)&-(0x1f+1)) == 0 && ((1<<uint((_la-498)))&((1<<(Cobol85ParserUNDERLINE-498))|(1<<(Cobol85ParserVIRTUAL-498))|(1<<(Cobol85ParserWAIT-498))|(1<<(Cobol85ParserYEAR-498))|(1<<(Cobol85ParserYYYYMMDD-498))|(1<<(Cobol85ParserYYYYDDD-498))|(1<<(Cobol85ParserZERO_FILL-498)))) != 0) || _la == Cobol85ParserIDENTIFIER {
		{
			p.SetState(4667)
			p.OpenInput()
		}

		p.SetState(4670)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IOpenInputContext is an interface to support dynamic dispatch.
type IOpenInputContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOpenInputContext differentiates from other interfaces.
	IsOpenInputContext()
}

type OpenInputContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpenInputContext() *OpenInputContext {
	var p = new(OpenInputContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_openInput
	return p
}

func (*OpenInputContext) IsOpenInputContext() {}

func NewOpenInputContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OpenInputContext {
	var p = new(OpenInputContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_openInput

	return p
}

func (s *OpenInputContext) GetParser() antlr.Parser { return s.parser }

func (s *OpenInputContext) FileName() IFileNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *OpenInputContext) REVERSED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREVERSED, 0)
}

func (s *OpenInputContext) NO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNO, 0)
}

func (s *OpenInputContext) REWIND() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREWIND, 0)
}

func (s *OpenInputContext) WITH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWITH, 0)
}

func (s *OpenInputContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OpenInputContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OpenInputContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterOpenInput(s)
	}
}

func (s *OpenInputContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitOpenInput(s)
	}
}

func (p *Cobol85Parser) OpenInput() (localctx IOpenInputContext) {
	localctx = NewOpenInputContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 784, Cobol85ParserRULE_openInput)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4672)
		p.FileName()
	}
	p.SetState(4679)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 679, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4673)
			p.Match(Cobol85ParserREVERSED)
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 679, p.GetParserRuleContext()) == 2 {
		p.SetState(4675)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserWITH {
			{
				p.SetState(4674)
				p.Match(Cobol85ParserWITH)
			}

		}
		{
			p.SetState(4677)
			p.Match(Cobol85ParserNO)
		}
		{
			p.SetState(4678)
			p.Match(Cobol85ParserREWIND)
		}

	}

	return localctx
}

// IOpenOutputStatementContext is an interface to support dynamic dispatch.
type IOpenOutputStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOpenOutputStatementContext differentiates from other interfaces.
	IsOpenOutputStatementContext()
}

type OpenOutputStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpenOutputStatementContext() *OpenOutputStatementContext {
	var p = new(OpenOutputStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_openOutputStatement
	return p
}

func (*OpenOutputStatementContext) IsOpenOutputStatementContext() {}

func NewOpenOutputStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OpenOutputStatementContext {
	var p = new(OpenOutputStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_openOutputStatement

	return p
}

func (s *OpenOutputStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *OpenOutputStatementContext) OUTPUT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOUTPUT, 0)
}

func (s *OpenOutputStatementContext) AllOpenOutput() []IOpenOutputContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOpenOutputContext)(nil)).Elem())
	var tst = make([]IOpenOutputContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOpenOutputContext)
		}
	}

	return tst
}

func (s *OpenOutputStatementContext) OpenOutput(i int) IOpenOutputContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOpenOutputContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOpenOutputContext)
}

func (s *OpenOutputStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OpenOutputStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OpenOutputStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterOpenOutputStatement(s)
	}
}

func (s *OpenOutputStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitOpenOutputStatement(s)
	}
}

func (p *Cobol85Parser) OpenOutputStatement() (localctx IOpenOutputStatementContext) {
	localctx = NewOpenOutputStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 786, Cobol85ParserRULE_openOutputStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4681)
		p.Match(Cobol85ParserOUTPUT)
	}
	p.SetState(4683)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH)|(1<<Cobol85ParserATTRIBUTE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBINARY-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-68))|(1<<(Cobol85ParserCOBOL-68))|(1<<(Cobol85ParserCOMMITMENT-68))|(1<<(Cobol85ParserCONTROL_POINT-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(Cobol85ParserCONVENTION-100))|(1<<(Cobol85ParserCRUNCH-100))|(1<<(Cobol85ParserCURSOR-100))|(1<<(Cobol85ParserDEFAULT-100))|(1<<(Cobol85ParserDEFAULT_DISPLAY-100))|(1<<(Cobol85ParserDEFINITION-100)))) != 0) || (((_la-138)&-(0x1f+1)) == 0 && ((1<<uint((_la-138)))&((1<<(Cobol85ParserDFHRESP-138))|(1<<(Cobol85ParserDFHVALUE-138))|(1<<(Cobol85ParserDISK-138))|(1<<(Cobol85ParserDONTCARE-138))|(1<<(Cobol85ParserDOUBLE-138))|(1<<(Cobol85ParserEBCDIC-138))|(1<<(Cobol85ParserEMPTY_CHECK-138)))) != 0) || (((_la-181)&-(0x1f+1)) == 0 && ((1<<uint((_la-181)))&((1<<(Cobol85ParserENTER-181))|(1<<(Cobol85ParserENTRY_PROCEDURE-181))|(1<<(Cobol85ParserERASE-181))|(1<<(Cobol85ParserEOL-181))|(1<<(Cobol85ParserEOS-181))|(1<<(Cobol85ParserESCAPE-181))|(1<<(Cobol85ParserEVENT-181))|(1<<(Cobol85ParserEXCLUSIVE-181))|(1<<(Cobol85ParserEXPORT-181))|(1<<(Cobol85ParserEXTENDED-181)))) != 0) || (((_la-213)&-(0x1f+1)) == 0 && ((1<<uint((_la-213)))&((1<<(Cobol85ParserFOREGROUND_COLOR-213))|(1<<(Cobol85ParserFOREGROUND_COLOUR-213))|(1<<(Cobol85ParserFULL-213))|(1<<(Cobol85ParserFUNCTIONNAME-213))|(1<<(Cobol85ParserFUNCTION_POINTER-213))|(1<<(Cobol85ParserGRID-213))|(1<<(Cobol85ParserHIGHLIGHT-213))|(1<<(Cobol85ParserIMPLICIT-213))|(1<<(Cobol85ParserIMPORT-213)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(Cobol85ParserINTEGER-250))|(1<<(Cobol85ParserKEPT-250))|(1<<(Cobol85ParserKEYBOARD-250))|(1<<(Cobol85ParserLANGUAGE-250))|(1<<(Cobol85ParserLB-250))|(1<<(Cobol85ParserLD-250))|(1<<(Cobol85ParserLEFTLINE-250))|(1<<(Cobol85ParserLENGTH_CHECK-250))|(1<<(Cobol85ParserLIBACCESS-250))|(1<<(Cobol85ParserLIBPARAMETER-250))|(1<<(Cobol85ParserLIBRARY-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(Cobol85ParserLIST-283))|(1<<(Cobol85ParserLOCAL-283))|(1<<(Cobol85ParserLONG_DATE-283))|(1<<(Cobol85ParserLONG_TIME-283))|(1<<(Cobol85ParserLOWER-283))|(1<<(Cobol85ParserLOWLIGHT-283))|(1<<(Cobol85ParserMMDDYYYY-283))|(1<<(Cobol85ParserNAMED-283))|(1<<(Cobol85ParserNATIONAL-283))|(1<<(Cobol85ParserNATIONAL_EDITED-283))|(1<<(Cobol85ParserNETWORK-283))|(1<<(Cobol85ParserNO_ECHO-283)))) != 0) || (((_la-317)&-(0x1f+1)) == 0 && ((1<<uint((_la-317)))&((1<<(Cobol85ParserNUMERIC_DATE-317))|(1<<(Cobol85ParserNUMERIC_TIME-317))|(1<<(Cobol85ParserODT-317))|(1<<(Cobol85ParserORDERLY-317))|(1<<(Cobol85ParserOVERLINE-317))|(1<<(Cobol85ParserOWN-317))|(1<<(Cobol85ParserPASSWORD-317)))) != 0) || (((_la-352)&-(0x1f+1)) == 0 && ((1<<uint((_la-352)))&((1<<(Cobol85ParserPORT-352))|(1<<(Cobol85ParserPRINTER-352))|(1<<(Cobol85ParserPRIVATE-352))|(1<<(Cobol85ParserPROCESS-352))|(1<<(Cobol85ParserPROGRAM-352))|(1<<(Cobol85ParserPROMPT-352))|(1<<(Cobol85ParserREADER-352))|(1<<(Cobol85ParserREMOTE-352))|(1<<(Cobol85ParserREAL-352))|(1<<(Cobol85ParserRECEIVED-352))|(1<<(Cobol85ParserRECURSIVE-352))|(1<<(Cobol85ParserREF-352)))) != 0) || (((_la-391)&-(0x1f+1)) == 0 && ((1<<uint((_la-391)))&((1<<(Cobol85ParserREMOVE-391))|(1<<(Cobol85ParserREQUIRED-391))|(1<<(Cobol85ParserREVERSE_VIDEO-391))|(1<<(Cobol85ParserSAVE-391))|(1<<(Cobol85ParserSECURE-391)))) != 0) || (((_la-431)&-(0x1f+1)) == 0 && ((1<<uint((_la-431)))&((1<<(Cobol85ParserSHARED-431))|(1<<(Cobol85ParserSHAREDBYALL-431))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-431))|(1<<(Cobol85ParserSHARING-431))|(1<<(Cobol85ParserSHORT_DATE-431)))) != 0) || (((_la-466)&-(0x1f+1)) == 0 && ((1<<uint((_la-466)))&((1<<(Cobol85ParserSYMBOL-466))|(1<<(Cobol85ParserTASK-466))|(1<<(Cobol85ParserTHREAD-466))|(1<<(Cobol85ParserTHREAD_LOCAL-466))|(1<<(Cobol85ParserTIMER-466))|(1<<(Cobol85ParserTODAYS_DATE-466))|(1<<(Cobol85ParserTODAYS_NAME-466))|(1<<(Cobol85ParserTRUNCATED-466))|(1<<(Cobol85ParserTYPEDEF-466)))) != 0) || (((_la-498)&-(0x1f+1)) == 0 && ((1<<uint((_la-498)))&((1<<(Cobol85ParserUNDERLINE-498))|(1<<(Cobol85ParserVIRTUAL-498))|(1<<(Cobol85ParserWAIT-498))|(1<<(Cobol85ParserYEAR-498))|(1<<(Cobol85ParserYYYYMMDD-498))|(1<<(Cobol85ParserYYYYDDD-498))|(1<<(Cobol85ParserZERO_FILL-498)))) != 0) || _la == Cobol85ParserIDENTIFIER {
		{
			p.SetState(4682)
			p.OpenOutput()
		}

		p.SetState(4685)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IOpenOutputContext is an interface to support dynamic dispatch.
type IOpenOutputContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOpenOutputContext differentiates from other interfaces.
	IsOpenOutputContext()
}

type OpenOutputContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpenOutputContext() *OpenOutputContext {
	var p = new(OpenOutputContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_openOutput
	return p
}

func (*OpenOutputContext) IsOpenOutputContext() {}

func NewOpenOutputContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OpenOutputContext {
	var p = new(OpenOutputContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_openOutput

	return p
}

func (s *OpenOutputContext) GetParser() antlr.Parser { return s.parser }

func (s *OpenOutputContext) FileName() IFileNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *OpenOutputContext) NO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNO, 0)
}

func (s *OpenOutputContext) REWIND() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREWIND, 0)
}

func (s *OpenOutputContext) WITH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWITH, 0)
}

func (s *OpenOutputContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OpenOutputContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OpenOutputContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterOpenOutput(s)
	}
}

func (s *OpenOutputContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitOpenOutput(s)
	}
}

func (p *Cobol85Parser) OpenOutput() (localctx IOpenOutputContext) {
	localctx = NewOpenOutputContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 788, Cobol85ParserRULE_openOutput)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4687)
		p.FileName()
	}
	p.SetState(4693)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 682, p.GetParserRuleContext()) == 1 {
		p.SetState(4689)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserWITH {
			{
				p.SetState(4688)
				p.Match(Cobol85ParserWITH)
			}

		}
		{
			p.SetState(4691)
			p.Match(Cobol85ParserNO)
		}
		{
			p.SetState(4692)
			p.Match(Cobol85ParserREWIND)
		}

	}

	return localctx
}

// IOpenIOStatementContext is an interface to support dynamic dispatch.
type IOpenIOStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOpenIOStatementContext differentiates from other interfaces.
	IsOpenIOStatementContext()
}

type OpenIOStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpenIOStatementContext() *OpenIOStatementContext {
	var p = new(OpenIOStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_openIOStatement
	return p
}

func (*OpenIOStatementContext) IsOpenIOStatementContext() {}

func NewOpenIOStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OpenIOStatementContext {
	var p = new(OpenIOStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_openIOStatement

	return p
}

func (s *OpenIOStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *OpenIOStatementContext) I_O() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserI_O, 0)
}

func (s *OpenIOStatementContext) AllFileName() []IFileNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFileNameContext)(nil)).Elem())
	var tst = make([]IFileNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFileNameContext)
		}
	}

	return tst
}

func (s *OpenIOStatementContext) FileName(i int) IFileNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *OpenIOStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OpenIOStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OpenIOStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterOpenIOStatement(s)
	}
}

func (s *OpenIOStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitOpenIOStatement(s)
	}
}

func (p *Cobol85Parser) OpenIOStatement() (localctx IOpenIOStatementContext) {
	localctx = NewOpenIOStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 790, Cobol85ParserRULE_openIOStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4695)
		p.Match(Cobol85ParserI_O)
	}
	p.SetState(4697)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH)|(1<<Cobol85ParserATTRIBUTE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBINARY-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-68))|(1<<(Cobol85ParserCOBOL-68))|(1<<(Cobol85ParserCOMMITMENT-68))|(1<<(Cobol85ParserCONTROL_POINT-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(Cobol85ParserCONVENTION-100))|(1<<(Cobol85ParserCRUNCH-100))|(1<<(Cobol85ParserCURSOR-100))|(1<<(Cobol85ParserDEFAULT-100))|(1<<(Cobol85ParserDEFAULT_DISPLAY-100))|(1<<(Cobol85ParserDEFINITION-100)))) != 0) || (((_la-138)&-(0x1f+1)) == 0 && ((1<<uint((_la-138)))&((1<<(Cobol85ParserDFHRESP-138))|(1<<(Cobol85ParserDFHVALUE-138))|(1<<(Cobol85ParserDISK-138))|(1<<(Cobol85ParserDONTCARE-138))|(1<<(Cobol85ParserDOUBLE-138))|(1<<(Cobol85ParserEBCDIC-138))|(1<<(Cobol85ParserEMPTY_CHECK-138)))) != 0) || (((_la-181)&-(0x1f+1)) == 0 && ((1<<uint((_la-181)))&((1<<(Cobol85ParserENTER-181))|(1<<(Cobol85ParserENTRY_PROCEDURE-181))|(1<<(Cobol85ParserERASE-181))|(1<<(Cobol85ParserEOL-181))|(1<<(Cobol85ParserEOS-181))|(1<<(Cobol85ParserESCAPE-181))|(1<<(Cobol85ParserEVENT-181))|(1<<(Cobol85ParserEXCLUSIVE-181))|(1<<(Cobol85ParserEXPORT-181))|(1<<(Cobol85ParserEXTENDED-181)))) != 0) || (((_la-213)&-(0x1f+1)) == 0 && ((1<<uint((_la-213)))&((1<<(Cobol85ParserFOREGROUND_COLOR-213))|(1<<(Cobol85ParserFOREGROUND_COLOUR-213))|(1<<(Cobol85ParserFULL-213))|(1<<(Cobol85ParserFUNCTIONNAME-213))|(1<<(Cobol85ParserFUNCTION_POINTER-213))|(1<<(Cobol85ParserGRID-213))|(1<<(Cobol85ParserHIGHLIGHT-213))|(1<<(Cobol85ParserIMPLICIT-213))|(1<<(Cobol85ParserIMPORT-213)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(Cobol85ParserINTEGER-250))|(1<<(Cobol85ParserKEPT-250))|(1<<(Cobol85ParserKEYBOARD-250))|(1<<(Cobol85ParserLANGUAGE-250))|(1<<(Cobol85ParserLB-250))|(1<<(Cobol85ParserLD-250))|(1<<(Cobol85ParserLEFTLINE-250))|(1<<(Cobol85ParserLENGTH_CHECK-250))|(1<<(Cobol85ParserLIBACCESS-250))|(1<<(Cobol85ParserLIBPARAMETER-250))|(1<<(Cobol85ParserLIBRARY-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(Cobol85ParserLIST-283))|(1<<(Cobol85ParserLOCAL-283))|(1<<(Cobol85ParserLONG_DATE-283))|(1<<(Cobol85ParserLONG_TIME-283))|(1<<(Cobol85ParserLOWER-283))|(1<<(Cobol85ParserLOWLIGHT-283))|(1<<(Cobol85ParserMMDDYYYY-283))|(1<<(Cobol85ParserNAMED-283))|(1<<(Cobol85ParserNATIONAL-283))|(1<<(Cobol85ParserNATIONAL_EDITED-283))|(1<<(Cobol85ParserNETWORK-283))|(1<<(Cobol85ParserNO_ECHO-283)))) != 0) || (((_la-317)&-(0x1f+1)) == 0 && ((1<<uint((_la-317)))&((1<<(Cobol85ParserNUMERIC_DATE-317))|(1<<(Cobol85ParserNUMERIC_TIME-317))|(1<<(Cobol85ParserODT-317))|(1<<(Cobol85ParserORDERLY-317))|(1<<(Cobol85ParserOVERLINE-317))|(1<<(Cobol85ParserOWN-317))|(1<<(Cobol85ParserPASSWORD-317)))) != 0) || (((_la-352)&-(0x1f+1)) == 0 && ((1<<uint((_la-352)))&((1<<(Cobol85ParserPORT-352))|(1<<(Cobol85ParserPRINTER-352))|(1<<(Cobol85ParserPRIVATE-352))|(1<<(Cobol85ParserPROCESS-352))|(1<<(Cobol85ParserPROGRAM-352))|(1<<(Cobol85ParserPROMPT-352))|(1<<(Cobol85ParserREADER-352))|(1<<(Cobol85ParserREMOTE-352))|(1<<(Cobol85ParserREAL-352))|(1<<(Cobol85ParserRECEIVED-352))|(1<<(Cobol85ParserRECURSIVE-352))|(1<<(Cobol85ParserREF-352)))) != 0) || (((_la-391)&-(0x1f+1)) == 0 && ((1<<uint((_la-391)))&((1<<(Cobol85ParserREMOVE-391))|(1<<(Cobol85ParserREQUIRED-391))|(1<<(Cobol85ParserREVERSE_VIDEO-391))|(1<<(Cobol85ParserSAVE-391))|(1<<(Cobol85ParserSECURE-391)))) != 0) || (((_la-431)&-(0x1f+1)) == 0 && ((1<<uint((_la-431)))&((1<<(Cobol85ParserSHARED-431))|(1<<(Cobol85ParserSHAREDBYALL-431))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-431))|(1<<(Cobol85ParserSHARING-431))|(1<<(Cobol85ParserSHORT_DATE-431)))) != 0) || (((_la-466)&-(0x1f+1)) == 0 && ((1<<uint((_la-466)))&((1<<(Cobol85ParserSYMBOL-466))|(1<<(Cobol85ParserTASK-466))|(1<<(Cobol85ParserTHREAD-466))|(1<<(Cobol85ParserTHREAD_LOCAL-466))|(1<<(Cobol85ParserTIMER-466))|(1<<(Cobol85ParserTODAYS_DATE-466))|(1<<(Cobol85ParserTODAYS_NAME-466))|(1<<(Cobol85ParserTRUNCATED-466))|(1<<(Cobol85ParserTYPEDEF-466)))) != 0) || (((_la-498)&-(0x1f+1)) == 0 && ((1<<uint((_la-498)))&((1<<(Cobol85ParserUNDERLINE-498))|(1<<(Cobol85ParserVIRTUAL-498))|(1<<(Cobol85ParserWAIT-498))|(1<<(Cobol85ParserYEAR-498))|(1<<(Cobol85ParserYYYYMMDD-498))|(1<<(Cobol85ParserYYYYDDD-498))|(1<<(Cobol85ParserZERO_FILL-498)))) != 0) || _la == Cobol85ParserIDENTIFIER {
		{
			p.SetState(4696)
			p.FileName()
		}

		p.SetState(4699)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IOpenExtendStatementContext is an interface to support dynamic dispatch.
type IOpenExtendStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOpenExtendStatementContext differentiates from other interfaces.
	IsOpenExtendStatementContext()
}

type OpenExtendStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpenExtendStatementContext() *OpenExtendStatementContext {
	var p = new(OpenExtendStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_openExtendStatement
	return p
}

func (*OpenExtendStatementContext) IsOpenExtendStatementContext() {}

func NewOpenExtendStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OpenExtendStatementContext {
	var p = new(OpenExtendStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_openExtendStatement

	return p
}

func (s *OpenExtendStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *OpenExtendStatementContext) EXTEND() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEXTEND, 0)
}

func (s *OpenExtendStatementContext) AllFileName() []IFileNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFileNameContext)(nil)).Elem())
	var tst = make([]IFileNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFileNameContext)
		}
	}

	return tst
}

func (s *OpenExtendStatementContext) FileName(i int) IFileNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *OpenExtendStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OpenExtendStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OpenExtendStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterOpenExtendStatement(s)
	}
}

func (s *OpenExtendStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitOpenExtendStatement(s)
	}
}

func (p *Cobol85Parser) OpenExtendStatement() (localctx IOpenExtendStatementContext) {
	localctx = NewOpenExtendStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 792, Cobol85ParserRULE_openExtendStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4701)
		p.Match(Cobol85ParserEXTEND)
	}
	p.SetState(4703)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH)|(1<<Cobol85ParserATTRIBUTE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBINARY-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-68))|(1<<(Cobol85ParserCOBOL-68))|(1<<(Cobol85ParserCOMMITMENT-68))|(1<<(Cobol85ParserCONTROL_POINT-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(Cobol85ParserCONVENTION-100))|(1<<(Cobol85ParserCRUNCH-100))|(1<<(Cobol85ParserCURSOR-100))|(1<<(Cobol85ParserDEFAULT-100))|(1<<(Cobol85ParserDEFAULT_DISPLAY-100))|(1<<(Cobol85ParserDEFINITION-100)))) != 0) || (((_la-138)&-(0x1f+1)) == 0 && ((1<<uint((_la-138)))&((1<<(Cobol85ParserDFHRESP-138))|(1<<(Cobol85ParserDFHVALUE-138))|(1<<(Cobol85ParserDISK-138))|(1<<(Cobol85ParserDONTCARE-138))|(1<<(Cobol85ParserDOUBLE-138))|(1<<(Cobol85ParserEBCDIC-138))|(1<<(Cobol85ParserEMPTY_CHECK-138)))) != 0) || (((_la-181)&-(0x1f+1)) == 0 && ((1<<uint((_la-181)))&((1<<(Cobol85ParserENTER-181))|(1<<(Cobol85ParserENTRY_PROCEDURE-181))|(1<<(Cobol85ParserERASE-181))|(1<<(Cobol85ParserEOL-181))|(1<<(Cobol85ParserEOS-181))|(1<<(Cobol85ParserESCAPE-181))|(1<<(Cobol85ParserEVENT-181))|(1<<(Cobol85ParserEXCLUSIVE-181))|(1<<(Cobol85ParserEXPORT-181))|(1<<(Cobol85ParserEXTENDED-181)))) != 0) || (((_la-213)&-(0x1f+1)) == 0 && ((1<<uint((_la-213)))&((1<<(Cobol85ParserFOREGROUND_COLOR-213))|(1<<(Cobol85ParserFOREGROUND_COLOUR-213))|(1<<(Cobol85ParserFULL-213))|(1<<(Cobol85ParserFUNCTIONNAME-213))|(1<<(Cobol85ParserFUNCTION_POINTER-213))|(1<<(Cobol85ParserGRID-213))|(1<<(Cobol85ParserHIGHLIGHT-213))|(1<<(Cobol85ParserIMPLICIT-213))|(1<<(Cobol85ParserIMPORT-213)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(Cobol85ParserINTEGER-250))|(1<<(Cobol85ParserKEPT-250))|(1<<(Cobol85ParserKEYBOARD-250))|(1<<(Cobol85ParserLANGUAGE-250))|(1<<(Cobol85ParserLB-250))|(1<<(Cobol85ParserLD-250))|(1<<(Cobol85ParserLEFTLINE-250))|(1<<(Cobol85ParserLENGTH_CHECK-250))|(1<<(Cobol85ParserLIBACCESS-250))|(1<<(Cobol85ParserLIBPARAMETER-250))|(1<<(Cobol85ParserLIBRARY-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(Cobol85ParserLIST-283))|(1<<(Cobol85ParserLOCAL-283))|(1<<(Cobol85ParserLONG_DATE-283))|(1<<(Cobol85ParserLONG_TIME-283))|(1<<(Cobol85ParserLOWER-283))|(1<<(Cobol85ParserLOWLIGHT-283))|(1<<(Cobol85ParserMMDDYYYY-283))|(1<<(Cobol85ParserNAMED-283))|(1<<(Cobol85ParserNATIONAL-283))|(1<<(Cobol85ParserNATIONAL_EDITED-283))|(1<<(Cobol85ParserNETWORK-283))|(1<<(Cobol85ParserNO_ECHO-283)))) != 0) || (((_la-317)&-(0x1f+1)) == 0 && ((1<<uint((_la-317)))&((1<<(Cobol85ParserNUMERIC_DATE-317))|(1<<(Cobol85ParserNUMERIC_TIME-317))|(1<<(Cobol85ParserODT-317))|(1<<(Cobol85ParserORDERLY-317))|(1<<(Cobol85ParserOVERLINE-317))|(1<<(Cobol85ParserOWN-317))|(1<<(Cobol85ParserPASSWORD-317)))) != 0) || (((_la-352)&-(0x1f+1)) == 0 && ((1<<uint((_la-352)))&((1<<(Cobol85ParserPORT-352))|(1<<(Cobol85ParserPRINTER-352))|(1<<(Cobol85ParserPRIVATE-352))|(1<<(Cobol85ParserPROCESS-352))|(1<<(Cobol85ParserPROGRAM-352))|(1<<(Cobol85ParserPROMPT-352))|(1<<(Cobol85ParserREADER-352))|(1<<(Cobol85ParserREMOTE-352))|(1<<(Cobol85ParserREAL-352))|(1<<(Cobol85ParserRECEIVED-352))|(1<<(Cobol85ParserRECURSIVE-352))|(1<<(Cobol85ParserREF-352)))) != 0) || (((_la-391)&-(0x1f+1)) == 0 && ((1<<uint((_la-391)))&((1<<(Cobol85ParserREMOVE-391))|(1<<(Cobol85ParserREQUIRED-391))|(1<<(Cobol85ParserREVERSE_VIDEO-391))|(1<<(Cobol85ParserSAVE-391))|(1<<(Cobol85ParserSECURE-391)))) != 0) || (((_la-431)&-(0x1f+1)) == 0 && ((1<<uint((_la-431)))&((1<<(Cobol85ParserSHARED-431))|(1<<(Cobol85ParserSHAREDBYALL-431))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-431))|(1<<(Cobol85ParserSHARING-431))|(1<<(Cobol85ParserSHORT_DATE-431)))) != 0) || (((_la-466)&-(0x1f+1)) == 0 && ((1<<uint((_la-466)))&((1<<(Cobol85ParserSYMBOL-466))|(1<<(Cobol85ParserTASK-466))|(1<<(Cobol85ParserTHREAD-466))|(1<<(Cobol85ParserTHREAD_LOCAL-466))|(1<<(Cobol85ParserTIMER-466))|(1<<(Cobol85ParserTODAYS_DATE-466))|(1<<(Cobol85ParserTODAYS_NAME-466))|(1<<(Cobol85ParserTRUNCATED-466))|(1<<(Cobol85ParserTYPEDEF-466)))) != 0) || (((_la-498)&-(0x1f+1)) == 0 && ((1<<uint((_la-498)))&((1<<(Cobol85ParserUNDERLINE-498))|(1<<(Cobol85ParserVIRTUAL-498))|(1<<(Cobol85ParserWAIT-498))|(1<<(Cobol85ParserYEAR-498))|(1<<(Cobol85ParserYYYYMMDD-498))|(1<<(Cobol85ParserYYYYDDD-498))|(1<<(Cobol85ParserZERO_FILL-498)))) != 0) || _la == Cobol85ParserIDENTIFIER {
		{
			p.SetState(4702)
			p.FileName()
		}

		p.SetState(4705)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IPerformStatementContext is an interface to support dynamic dispatch.
type IPerformStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPerformStatementContext differentiates from other interfaces.
	IsPerformStatementContext()
}

type PerformStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPerformStatementContext() *PerformStatementContext {
	var p = new(PerformStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_performStatement
	return p
}

func (*PerformStatementContext) IsPerformStatementContext() {}

func NewPerformStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PerformStatementContext {
	var p = new(PerformStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_performStatement

	return p
}

func (s *PerformStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *PerformStatementContext) PERFORM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPERFORM, 0)
}

func (s *PerformStatementContext) PerformInlineStatement() IPerformInlineStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPerformInlineStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPerformInlineStatementContext)
}

func (s *PerformStatementContext) PerformProcedureStatement() IPerformProcedureStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPerformProcedureStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPerformProcedureStatementContext)
}

func (s *PerformStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PerformStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PerformStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterPerformStatement(s)
	}
}

func (s *PerformStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitPerformStatement(s)
	}
}

func (p *Cobol85Parser) PerformStatement() (localctx IPerformStatementContext) {
	localctx = NewPerformStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 794, Cobol85ParserRULE_performStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4707)
		p.Match(Cobol85ParserPERFORM)
	}
	p.SetState(4710)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 685, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4708)
			p.PerformInlineStatement()
		}

	case 2:
		{
			p.SetState(4709)
			p.PerformProcedureStatement()
		}

	}

	return localctx
}

// IPerformInlineStatementContext is an interface to support dynamic dispatch.
type IPerformInlineStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPerformInlineStatementContext differentiates from other interfaces.
	IsPerformInlineStatementContext()
}

type PerformInlineStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPerformInlineStatementContext() *PerformInlineStatementContext {
	var p = new(PerformInlineStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_performInlineStatement
	return p
}

func (*PerformInlineStatementContext) IsPerformInlineStatementContext() {}

func NewPerformInlineStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PerformInlineStatementContext {
	var p = new(PerformInlineStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_performInlineStatement

	return p
}

func (s *PerformInlineStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *PerformInlineStatementContext) END_PERFORM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND_PERFORM, 0)
}

func (s *PerformInlineStatementContext) PerformType() IPerformTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPerformTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPerformTypeContext)
}

func (s *PerformInlineStatementContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *PerformInlineStatementContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *PerformInlineStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PerformInlineStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PerformInlineStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterPerformInlineStatement(s)
	}
}

func (s *PerformInlineStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitPerformInlineStatement(s)
	}
}

func (p *Cobol85Parser) PerformInlineStatement() (localctx IPerformInlineStatementContext) {
	localctx = NewPerformInlineStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 796, Cobol85ParserRULE_performInlineStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4713)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserADDRESS)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH)|(1<<Cobol85ParserATTRIBUTE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBINARY-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-68))|(1<<(Cobol85ParserCOBOL-68))|(1<<(Cobol85ParserCOMMITMENT-68))|(1<<(Cobol85ParserCONTROL_POINT-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(Cobol85ParserCONVENTION-100))|(1<<(Cobol85ParserCRUNCH-100))|(1<<(Cobol85ParserCURSOR-100))|(1<<(Cobol85ParserDATE-100))|(1<<(Cobol85ParserDAY-100))|(1<<(Cobol85ParserDAY_OF_WEEK-100))|(1<<(Cobol85ParserDEBUG_CONTENTS-100))|(1<<(Cobol85ParserDEBUG_ITEM-100))|(1<<(Cobol85ParserDEBUG_LINE-100))|(1<<(Cobol85ParserDEBUG_NAME-100))|(1<<(Cobol85ParserDEBUG_SUB_1-100))|(1<<(Cobol85ParserDEBUG_SUB_2-100))|(1<<(Cobol85ParserDEBUG_SUB_3-100))|(1<<(Cobol85ParserDEFAULT-100))|(1<<(Cobol85ParserDEFAULT_DISPLAY-100))|(1<<(Cobol85ParserDEFINITION-100)))) != 0) || (((_la-138)&-(0x1f+1)) == 0 && ((1<<uint((_la-138)))&((1<<(Cobol85ParserDFHRESP-138))|(1<<(Cobol85ParserDFHVALUE-138))|(1<<(Cobol85ParserDISK-138))|(1<<(Cobol85ParserDONTCARE-138))|(1<<(Cobol85ParserDOUBLE-138))|(1<<(Cobol85ParserEBCDIC-138))|(1<<(Cobol85ParserEMPTY_CHECK-138)))) != 0) || (((_la-181)&-(0x1f+1)) == 0 && ((1<<uint((_la-181)))&((1<<(Cobol85ParserENTER-181))|(1<<(Cobol85ParserENTRY_PROCEDURE-181))|(1<<(Cobol85ParserERASE-181))|(1<<(Cobol85ParserEOL-181))|(1<<(Cobol85ParserEOS-181))|(1<<(Cobol85ParserESCAPE-181))|(1<<(Cobol85ParserEVENT-181))|(1<<(Cobol85ParserEXCLUSIVE-181))|(1<<(Cobol85ParserEXPORT-181))|(1<<(Cobol85ParserEXTENDED-181)))) != 0) || (((_la-213)&-(0x1f+1)) == 0 && ((1<<uint((_la-213)))&((1<<(Cobol85ParserFOREGROUND_COLOR-213))|(1<<(Cobol85ParserFOREGROUND_COLOUR-213))|(1<<(Cobol85ParserFULL-213))|(1<<(Cobol85ParserFUNCTION-213))|(1<<(Cobol85ParserFUNCTIONNAME-213))|(1<<(Cobol85ParserFUNCTION_POINTER-213))|(1<<(Cobol85ParserGRID-213))|(1<<(Cobol85ParserHIGHLIGHT-213))|(1<<(Cobol85ParserIMPLICIT-213))|(1<<(Cobol85ParserIMPORT-213)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(Cobol85ParserINTEGER-250))|(1<<(Cobol85ParserKEPT-250))|(1<<(Cobol85ParserKEYBOARD-250))|(1<<(Cobol85ParserLANGUAGE-250))|(1<<(Cobol85ParserLB-250))|(1<<(Cobol85ParserLD-250))|(1<<(Cobol85ParserLEFTLINE-250))|(1<<(Cobol85ParserLENGTH-250))|(1<<(Cobol85ParserLENGTH_CHECK-250))|(1<<(Cobol85ParserLIBACCESS-250))|(1<<(Cobol85ParserLIBPARAMETER-250))|(1<<(Cobol85ParserLIBRARY-250))|(1<<(Cobol85ParserLINAGE_COUNTER-250))|(1<<(Cobol85ParserLINE_COUNTER-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(Cobol85ParserLIST-283))|(1<<(Cobol85ParserLOCAL-283))|(1<<(Cobol85ParserLONG_DATE-283))|(1<<(Cobol85ParserLONG_TIME-283))|(1<<(Cobol85ParserLOWER-283))|(1<<(Cobol85ParserLOWLIGHT-283))|(1<<(Cobol85ParserMMDDYYYY-283))|(1<<(Cobol85ParserNAMED-283))|(1<<(Cobol85ParserNATIONAL-283))|(1<<(Cobol85ParserNATIONAL_EDITED-283))|(1<<(Cobol85ParserNETWORK-283))|(1<<(Cobol85ParserNO_ECHO-283)))) != 0) || (((_la-317)&-(0x1f+1)) == 0 && ((1<<uint((_la-317)))&((1<<(Cobol85ParserNUMERIC_DATE-317))|(1<<(Cobol85ParserNUMERIC_TIME-317))|(1<<(Cobol85ParserODT-317))|(1<<(Cobol85ParserORDERLY-317))|(1<<(Cobol85ParserOVERLINE-317))|(1<<(Cobol85ParserOWN-317))|(1<<(Cobol85ParserPAGE_COUNTER-317))|(1<<(Cobol85ParserPASSWORD-317)))) != 0) || (((_la-352)&-(0x1f+1)) == 0 && ((1<<uint((_la-352)))&((1<<(Cobol85ParserPORT-352))|(1<<(Cobol85ParserPRINTER-352))|(1<<(Cobol85ParserPRIVATE-352))|(1<<(Cobol85ParserPROCESS-352))|(1<<(Cobol85ParserPROGRAM-352))|(1<<(Cobol85ParserPROMPT-352))|(1<<(Cobol85ParserREADER-352))|(1<<(Cobol85ParserREMOTE-352))|(1<<(Cobol85ParserREAL-352))|(1<<(Cobol85ParserRECEIVED-352))|(1<<(Cobol85ParserRECURSIVE-352))|(1<<(Cobol85ParserREF-352)))) != 0) || (((_la-391)&-(0x1f+1)) == 0 && ((1<<uint((_la-391)))&((1<<(Cobol85ParserREMOVE-391))|(1<<(Cobol85ParserREQUIRED-391))|(1<<(Cobol85ParserREVERSE_VIDEO-391))|(1<<(Cobol85ParserRETURN_CODE-391))|(1<<(Cobol85ParserSAVE-391))|(1<<(Cobol85ParserSECURE-391)))) != 0) || (((_la-431)&-(0x1f+1)) == 0 && ((1<<uint((_la-431)))&((1<<(Cobol85ParserSHARED-431))|(1<<(Cobol85ParserSHAREDBYALL-431))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-431))|(1<<(Cobol85ParserSHARING-431))|(1<<(Cobol85ParserSHIFT_IN-431))|(1<<(Cobol85ParserSHIFT_OUT-431))|(1<<(Cobol85ParserSHORT_DATE-431))|(1<<(Cobol85ParserSORT_CONTROL-431))|(1<<(Cobol85ParserSORT_CORE_SIZE-431))|(1<<(Cobol85ParserSORT_FILE_SIZE-431))|(1<<(Cobol85ParserSORT_MESSAGE-431))|(1<<(Cobol85ParserSORT_MODE_SIZE-431))|(1<<(Cobol85ParserSORT_RETURN-431)))) != 0) || (((_la-466)&-(0x1f+1)) == 0 && ((1<<uint((_la-466)))&((1<<(Cobol85ParserSYMBOL-466))|(1<<(Cobol85ParserTALLY-466))|(1<<(Cobol85ParserTASK-466))|(1<<(Cobol85ParserTEST-466))|(1<<(Cobol85ParserTHREAD-466))|(1<<(Cobol85ParserTHREAD_LOCAL-466))|(1<<(Cobol85ParserTIME-466))|(1<<(Cobol85ParserTIMER-466))|(1<<(Cobol85ParserTODAYS_DATE-466))|(1<<(Cobol85ParserTODAYS_NAME-466))|(1<<(Cobol85ParserTRUNCATED-466))|(1<<(Cobol85ParserTYPEDEF-466)))) != 0) || (((_la-498)&-(0x1f+1)) == 0 && ((1<<uint((_la-498)))&((1<<(Cobol85ParserUNDERLINE-498))|(1<<(Cobol85ParserUNTIL-498))|(1<<(Cobol85ParserVARYING-498))|(1<<(Cobol85ParserVIRTUAL-498))|(1<<(Cobol85ParserWAIT-498))|(1<<(Cobol85ParserWHEN_COMPILED-498))|(1<<(Cobol85ParserWITH-498))|(1<<(Cobol85ParserYEAR-498))|(1<<(Cobol85ParserYYYYMMDD-498))|(1<<(Cobol85ParserYYYYDDD-498))|(1<<(Cobol85ParserZERO_FILL-498)))) != 0) || (((_la-552)&-(0x1f+1)) == 0 && ((1<<uint((_la-552)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-552))|(1<<(Cobol85ParserLEVEL_NUMBER_77-552))|(1<<(Cobol85ParserLEVEL_NUMBER_88-552))|(1<<(Cobol85ParserINTEGERLITERAL-552))|(1<<(Cobol85ParserIDENTIFIER-552)))) != 0) {
		{
			p.SetState(4712)
			p.PerformType()
		}

	}
	p.SetState(4718)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserACCEPT)|(1<<Cobol85ParserADD)|(1<<Cobol85ParserALTER))) != 0) || (((_la-52)&-(0x1f+1)) == 0 && ((1<<uint((_la-52)))&((1<<(Cobol85ParserCALL-52))|(1<<(Cobol85ParserCANCEL-52))|(1<<(Cobol85ParserCLOSE-52)))) != 0) || _la == Cobol85ParserCOMPUTE || _la == Cobol85ParserCONTINUE || (((_la-131)&-(0x1f+1)) == 0 && ((1<<uint((_la-131)))&((1<<(Cobol85ParserDELETE-131))|(1<<(Cobol85ParserDISABLE-131))|(1<<(Cobol85ParserDISPLAY-131))|(1<<(Cobol85ParserDIVIDE-131))|(1<<(Cobol85ParserENABLE-131)))) != 0) || (((_la-182)&-(0x1f+1)) == 0 && ((1<<uint((_la-182)))&((1<<(Cobol85ParserENTRY-182))|(1<<(Cobol85ParserEVALUATE-182))|(1<<(Cobol85ParserEXHIBIT-182))|(1<<(Cobol85ParserEXIT-182)))) != 0) || (((_la-220)&-(0x1f+1)) == 0 && ((1<<uint((_la-220)))&((1<<(Cobol85ParserGENERATE-220))|(1<<(Cobol85ParserGOBACK-220))|(1<<(Cobol85ParserGO-220))|(1<<(Cobol85ParserIF-220))|(1<<(Cobol85ParserINITIALIZE-220))|(1<<(Cobol85ParserINITIATE-220))|(1<<(Cobol85ParserINSPECT-220)))) != 0) || (((_la-294)&-(0x1f+1)) == 0 && ((1<<uint((_la-294)))&((1<<(Cobol85ParserMERGE-294))|(1<<(Cobol85ParserMOVE-294))|(1<<(Cobol85ParserMULTIPLY-294)))) != 0) || _la == Cobol85ParserOPEN || _la == Cobol85ParserPERFORM || (((_la-365)&-(0x1f+1)) == 0 && ((1<<uint((_la-365)))&((1<<(Cobol85ParserPURGE-365))|(1<<(Cobol85ParserREAD-365))|(1<<(Cobol85ParserRECEIVE-365))|(1<<(Cobol85ParserRELEASE-365)))) != 0) || (((_la-403)&-(0x1f+1)) == 0 && ((1<<uint((_la-403)))&((1<<(Cobol85ParserRETURN-403))|(1<<(Cobol85ParserREWRITE-403))|(1<<(Cobol85ParserSEARCH-403))|(1<<(Cobol85ParserSEND-403))|(1<<(Cobol85ParserSET-403)))) != 0) || (((_la-440)&-(0x1f+1)) == 0 && ((1<<uint((_la-440)))&((1<<(Cobol85ParserSORT-440))|(1<<(Cobol85ParserSTART-440))|(1<<(Cobol85ParserSTOP-440))|(1<<(Cobol85ParserSTRING-440))|(1<<(Cobol85ParserSUBTRACT-440)))) != 0) || _la == Cobol85ParserTERMINATE || _la == Cobol85ParserUNSTRING || _la == Cobol85ParserWRITE || (((_la-559)&-(0x1f+1)) == 0 && ((1<<uint((_la-559)))&((1<<(Cobol85ParserEXECCICSLINE-559))|(1<<(Cobol85ParserEXECSQLIMSLINE-559))|(1<<(Cobol85ParserEXECSQLLINE-559)))) != 0) {
		{
			p.SetState(4715)
			p.Statement()
		}

		p.SetState(4720)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(4721)
		p.Match(Cobol85ParserEND_PERFORM)
	}

	return localctx
}

// IPerformProcedureStatementContext is an interface to support dynamic dispatch.
type IPerformProcedureStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPerformProcedureStatementContext differentiates from other interfaces.
	IsPerformProcedureStatementContext()
}

type PerformProcedureStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPerformProcedureStatementContext() *PerformProcedureStatementContext {
	var p = new(PerformProcedureStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_performProcedureStatement
	return p
}

func (*PerformProcedureStatementContext) IsPerformProcedureStatementContext() {}

func NewPerformProcedureStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PerformProcedureStatementContext {
	var p = new(PerformProcedureStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_performProcedureStatement

	return p
}

func (s *PerformProcedureStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *PerformProcedureStatementContext) AllProcedureName() []IProcedureNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IProcedureNameContext)(nil)).Elem())
	var tst = make([]IProcedureNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IProcedureNameContext)
		}
	}

	return tst
}

func (s *PerformProcedureStatementContext) ProcedureName(i int) IProcedureNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedureNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IProcedureNameContext)
}

func (s *PerformProcedureStatementContext) PerformType() IPerformTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPerformTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPerformTypeContext)
}

func (s *PerformProcedureStatementContext) THROUGH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHROUGH, 0)
}

func (s *PerformProcedureStatementContext) THRU() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHRU, 0)
}

func (s *PerformProcedureStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PerformProcedureStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PerformProcedureStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterPerformProcedureStatement(s)
	}
}

func (s *PerformProcedureStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitPerformProcedureStatement(s)
	}
}

func (p *Cobol85Parser) PerformProcedureStatement() (localctx IPerformProcedureStatementContext) {
	localctx = NewPerformProcedureStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 798, Cobol85ParserRULE_performProcedureStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4723)
		p.ProcedureName()
	}
	p.SetState(4726)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserTHROUGH || _la == Cobol85ParserTHRU {
		{
			p.SetState(4724)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85ParserTHROUGH || _la == Cobol85ParserTHRU) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(4725)
			p.ProcedureName()
		}

	}
	p.SetState(4729)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 689, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4728)
			p.PerformType()
		}

	}

	return localctx
}

// IPerformTypeContext is an interface to support dynamic dispatch.
type IPerformTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPerformTypeContext differentiates from other interfaces.
	IsPerformTypeContext()
}

type PerformTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPerformTypeContext() *PerformTypeContext {
	var p = new(PerformTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_performType
	return p
}

func (*PerformTypeContext) IsPerformTypeContext() {}

func NewPerformTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PerformTypeContext {
	var p = new(PerformTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_performType

	return p
}

func (s *PerformTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *PerformTypeContext) PerformTimes() IPerformTimesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPerformTimesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPerformTimesContext)
}

func (s *PerformTypeContext) PerformUntil() IPerformUntilContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPerformUntilContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPerformUntilContext)
}

func (s *PerformTypeContext) PerformVarying() IPerformVaryingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPerformVaryingContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPerformVaryingContext)
}

func (s *PerformTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PerformTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PerformTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterPerformType(s)
	}
}

func (s *PerformTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitPerformType(s)
	}
}

func (p *Cobol85Parser) PerformType() (localctx IPerformTypeContext) {
	localctx = NewPerformTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 800, Cobol85ParserRULE_performType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4734)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 690, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4731)
			p.PerformTimes()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4732)
			p.PerformUntil()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4733)
			p.PerformVarying()
		}

	}

	return localctx
}

// IPerformTimesContext is an interface to support dynamic dispatch.
type IPerformTimesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPerformTimesContext differentiates from other interfaces.
	IsPerformTimesContext()
}

type PerformTimesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPerformTimesContext() *PerformTimesContext {
	var p = new(PerformTimesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_performTimes
	return p
}

func (*PerformTimesContext) IsPerformTimesContext() {}

func NewPerformTimesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PerformTimesContext {
	var p = new(PerformTimesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_performTimes

	return p
}

func (s *PerformTimesContext) GetParser() antlr.Parser { return s.parser }

func (s *PerformTimesContext) TIMES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTIMES, 0)
}

func (s *PerformTimesContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PerformTimesContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *PerformTimesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PerformTimesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PerformTimesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterPerformTimes(s)
	}
}

func (s *PerformTimesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitPerformTimes(s)
	}
}

func (p *Cobol85Parser) PerformTimes() (localctx IPerformTimesContext) {
	localctx = NewPerformTimesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 802, Cobol85ParserRULE_performTimes)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4738)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 691, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4736)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(4737)
			p.IntegerLiteral()
		}

	}
	{
		p.SetState(4740)
		p.Match(Cobol85ParserTIMES)
	}

	return localctx
}

// IPerformUntilContext is an interface to support dynamic dispatch.
type IPerformUntilContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPerformUntilContext differentiates from other interfaces.
	IsPerformUntilContext()
}

type PerformUntilContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPerformUntilContext() *PerformUntilContext {
	var p = new(PerformUntilContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_performUntil
	return p
}

func (*PerformUntilContext) IsPerformUntilContext() {}

func NewPerformUntilContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PerformUntilContext {
	var p = new(PerformUntilContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_performUntil

	return p
}

func (s *PerformUntilContext) GetParser() antlr.Parser { return s.parser }

func (s *PerformUntilContext) UNTIL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserUNTIL, 0)
}

func (s *PerformUntilContext) Condition() IConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *PerformUntilContext) PerformTestClause() IPerformTestClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPerformTestClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPerformTestClauseContext)
}

func (s *PerformUntilContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PerformUntilContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PerformUntilContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterPerformUntil(s)
	}
}

func (s *PerformUntilContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitPerformUntil(s)
	}
}

func (p *Cobol85Parser) PerformUntil() (localctx IPerformUntilContext) {
	localctx = NewPerformUntilContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 804, Cobol85ParserRULE_performUntil)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4743)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserTEST || _la == Cobol85ParserWITH {
		{
			p.SetState(4742)
			p.PerformTestClause()
		}

	}
	{
		p.SetState(4745)
		p.Match(Cobol85ParserUNTIL)
	}
	{
		p.SetState(4746)
		p.Condition()
	}

	return localctx
}

// IPerformVaryingContext is an interface to support dynamic dispatch.
type IPerformVaryingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPerformVaryingContext differentiates from other interfaces.
	IsPerformVaryingContext()
}

type PerformVaryingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPerformVaryingContext() *PerformVaryingContext {
	var p = new(PerformVaryingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_performVarying
	return p
}

func (*PerformVaryingContext) IsPerformVaryingContext() {}

func NewPerformVaryingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PerformVaryingContext {
	var p = new(PerformVaryingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_performVarying

	return p
}

func (s *PerformVaryingContext) GetParser() antlr.Parser { return s.parser }

func (s *PerformVaryingContext) PerformTestClause() IPerformTestClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPerformTestClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPerformTestClauseContext)
}

func (s *PerformVaryingContext) PerformVaryingClause() IPerformVaryingClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPerformVaryingClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPerformVaryingClauseContext)
}

func (s *PerformVaryingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PerformVaryingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PerformVaryingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterPerformVarying(s)
	}
}

func (s *PerformVaryingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitPerformVarying(s)
	}
}

func (p *Cobol85Parser) PerformVarying() (localctx IPerformVaryingContext) {
	localctx = NewPerformVaryingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 806, Cobol85ParserRULE_performVarying)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4755)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserTEST, Cobol85ParserWITH:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4748)
			p.PerformTestClause()
		}
		{
			p.SetState(4749)
			p.PerformVaryingClause()
		}

	case Cobol85ParserVARYING:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4751)
			p.PerformVaryingClause()
		}
		p.SetState(4753)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 693, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4752)
				p.PerformTestClause()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPerformVaryingClauseContext is an interface to support dynamic dispatch.
type IPerformVaryingClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPerformVaryingClauseContext differentiates from other interfaces.
	IsPerformVaryingClauseContext()
}

type PerformVaryingClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPerformVaryingClauseContext() *PerformVaryingClauseContext {
	var p = new(PerformVaryingClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_performVaryingClause
	return p
}

func (*PerformVaryingClauseContext) IsPerformVaryingClauseContext() {}

func NewPerformVaryingClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PerformVaryingClauseContext {
	var p = new(PerformVaryingClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_performVaryingClause

	return p
}

func (s *PerformVaryingClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *PerformVaryingClauseContext) VARYING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserVARYING, 0)
}

func (s *PerformVaryingClauseContext) PerformVaryingPhrase() IPerformVaryingPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPerformVaryingPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPerformVaryingPhraseContext)
}

func (s *PerformVaryingClauseContext) AllPerformAfter() []IPerformAfterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPerformAfterContext)(nil)).Elem())
	var tst = make([]IPerformAfterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPerformAfterContext)
		}
	}

	return tst
}

func (s *PerformVaryingClauseContext) PerformAfter(i int) IPerformAfterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPerformAfterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPerformAfterContext)
}

func (s *PerformVaryingClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PerformVaryingClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PerformVaryingClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterPerformVaryingClause(s)
	}
}

func (s *PerformVaryingClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitPerformVaryingClause(s)
	}
}

func (p *Cobol85Parser) PerformVaryingClause() (localctx IPerformVaryingClauseContext) {
	localctx = NewPerformVaryingClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 808, Cobol85ParserRULE_performVaryingClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4757)
		p.Match(Cobol85ParserVARYING)
	}
	{
		p.SetState(4758)
		p.PerformVaryingPhrase()
	}
	p.SetState(4762)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserAFTER {
		{
			p.SetState(4759)
			p.PerformAfter()
		}

		p.SetState(4764)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IPerformVaryingPhraseContext is an interface to support dynamic dispatch.
type IPerformVaryingPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPerformVaryingPhraseContext differentiates from other interfaces.
	IsPerformVaryingPhraseContext()
}

type PerformVaryingPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPerformVaryingPhraseContext() *PerformVaryingPhraseContext {
	var p = new(PerformVaryingPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_performVaryingPhrase
	return p
}

func (*PerformVaryingPhraseContext) IsPerformVaryingPhraseContext() {}

func NewPerformVaryingPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PerformVaryingPhraseContext {
	var p = new(PerformVaryingPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_performVaryingPhrase

	return p
}

func (s *PerformVaryingPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *PerformVaryingPhraseContext) PerformFrom() IPerformFromContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPerformFromContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPerformFromContext)
}

func (s *PerformVaryingPhraseContext) PerformBy() IPerformByContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPerformByContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPerformByContext)
}

func (s *PerformVaryingPhraseContext) PerformUntil() IPerformUntilContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPerformUntilContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPerformUntilContext)
}

func (s *PerformVaryingPhraseContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PerformVaryingPhraseContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *PerformVaryingPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PerformVaryingPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PerformVaryingPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterPerformVaryingPhrase(s)
	}
}

func (s *PerformVaryingPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitPerformVaryingPhrase(s)
	}
}

func (p *Cobol85Parser) PerformVaryingPhrase() (localctx IPerformVaryingPhraseContext) {
	localctx = NewPerformVaryingPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 810, Cobol85ParserRULE_performVaryingPhrase)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4767)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 696, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4765)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(4766)
			p.Literal()
		}

	}
	{
		p.SetState(4769)
		p.PerformFrom()
	}
	{
		p.SetState(4770)
		p.PerformBy()
	}
	{
		p.SetState(4771)
		p.PerformUntil()
	}

	return localctx
}

// IPerformAfterContext is an interface to support dynamic dispatch.
type IPerformAfterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPerformAfterContext differentiates from other interfaces.
	IsPerformAfterContext()
}

type PerformAfterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPerformAfterContext() *PerformAfterContext {
	var p = new(PerformAfterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_performAfter
	return p
}

func (*PerformAfterContext) IsPerformAfterContext() {}

func NewPerformAfterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PerformAfterContext {
	var p = new(PerformAfterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_performAfter

	return p
}

func (s *PerformAfterContext) GetParser() antlr.Parser { return s.parser }

func (s *PerformAfterContext) AFTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAFTER, 0)
}

func (s *PerformAfterContext) PerformVaryingPhrase() IPerformVaryingPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPerformVaryingPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPerformVaryingPhraseContext)
}

func (s *PerformAfterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PerformAfterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PerformAfterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterPerformAfter(s)
	}
}

func (s *PerformAfterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitPerformAfter(s)
	}
}

func (p *Cobol85Parser) PerformAfter() (localctx IPerformAfterContext) {
	localctx = NewPerformAfterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 812, Cobol85ParserRULE_performAfter)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4773)
		p.Match(Cobol85ParserAFTER)
	}
	{
		p.SetState(4774)
		p.PerformVaryingPhrase()
	}

	return localctx
}

// IPerformFromContext is an interface to support dynamic dispatch.
type IPerformFromContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPerformFromContext differentiates from other interfaces.
	IsPerformFromContext()
}

type PerformFromContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPerformFromContext() *PerformFromContext {
	var p = new(PerformFromContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_performFrom
	return p
}

func (*PerformFromContext) IsPerformFromContext() {}

func NewPerformFromContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PerformFromContext {
	var p = new(PerformFromContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_performFrom

	return p
}

func (s *PerformFromContext) GetParser() antlr.Parser { return s.parser }

func (s *PerformFromContext) FROM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFROM, 0)
}

func (s *PerformFromContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PerformFromContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *PerformFromContext) ArithmeticExpression() IArithmeticExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArithmeticExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArithmeticExpressionContext)
}

func (s *PerformFromContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PerformFromContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PerformFromContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterPerformFrom(s)
	}
}

func (s *PerformFromContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitPerformFrom(s)
	}
}

func (p *Cobol85Parser) PerformFrom() (localctx IPerformFromContext) {
	localctx = NewPerformFromContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 814, Cobol85ParserRULE_performFrom)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4776)
		p.Match(Cobol85ParserFROM)
	}
	p.SetState(4780)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 697, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4777)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(4778)
			p.Literal()
		}

	case 3:
		{
			p.SetState(4779)
			p.ArithmeticExpression()
		}

	}

	return localctx
}

// IPerformByContext is an interface to support dynamic dispatch.
type IPerformByContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPerformByContext differentiates from other interfaces.
	IsPerformByContext()
}

type PerformByContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPerformByContext() *PerformByContext {
	var p = new(PerformByContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_performBy
	return p
}

func (*PerformByContext) IsPerformByContext() {}

func NewPerformByContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PerformByContext {
	var p = new(PerformByContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_performBy

	return p
}

func (s *PerformByContext) GetParser() antlr.Parser { return s.parser }

func (s *PerformByContext) BY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBY, 0)
}

func (s *PerformByContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PerformByContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *PerformByContext) ArithmeticExpression() IArithmeticExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArithmeticExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArithmeticExpressionContext)
}

func (s *PerformByContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PerformByContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PerformByContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterPerformBy(s)
	}
}

func (s *PerformByContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitPerformBy(s)
	}
}

func (p *Cobol85Parser) PerformBy() (localctx IPerformByContext) {
	localctx = NewPerformByContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 816, Cobol85ParserRULE_performBy)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4782)
		p.Match(Cobol85ParserBY)
	}
	p.SetState(4786)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 698, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4783)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(4784)
			p.Literal()
		}

	case 3:
		{
			p.SetState(4785)
			p.ArithmeticExpression()
		}

	}

	return localctx
}

// IPerformTestClauseContext is an interface to support dynamic dispatch.
type IPerformTestClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPerformTestClauseContext differentiates from other interfaces.
	IsPerformTestClauseContext()
}

type PerformTestClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPerformTestClauseContext() *PerformTestClauseContext {
	var p = new(PerformTestClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_performTestClause
	return p
}

func (*PerformTestClauseContext) IsPerformTestClauseContext() {}

func NewPerformTestClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PerformTestClauseContext {
	var p = new(PerformTestClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_performTestClause

	return p
}

func (s *PerformTestClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *PerformTestClauseContext) TEST() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTEST, 0)
}

func (s *PerformTestClauseContext) BEFORE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBEFORE, 0)
}

func (s *PerformTestClauseContext) AFTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAFTER, 0)
}

func (s *PerformTestClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWITH, 0)
}

func (s *PerformTestClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PerformTestClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PerformTestClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterPerformTestClause(s)
	}
}

func (s *PerformTestClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitPerformTestClause(s)
	}
}

func (p *Cobol85Parser) PerformTestClause() (localctx IPerformTestClauseContext) {
	localctx = NewPerformTestClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 818, Cobol85ParserRULE_performTestClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4789)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserWITH {
		{
			p.SetState(4788)
			p.Match(Cobol85ParserWITH)
		}

	}
	{
		p.SetState(4791)
		p.Match(Cobol85ParserTEST)
	}
	{
		p.SetState(4792)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserAFTER || _la == Cobol85ParserBEFORE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IPurgeStatementContext is an interface to support dynamic dispatch.
type IPurgeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPurgeStatementContext differentiates from other interfaces.
	IsPurgeStatementContext()
}

type PurgeStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPurgeStatementContext() *PurgeStatementContext {
	var p = new(PurgeStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_purgeStatement
	return p
}

func (*PurgeStatementContext) IsPurgeStatementContext() {}

func NewPurgeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PurgeStatementContext {
	var p = new(PurgeStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_purgeStatement

	return p
}

func (s *PurgeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *PurgeStatementContext) PURGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPURGE, 0)
}

func (s *PurgeStatementContext) AllCdName() []ICdNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICdNameContext)(nil)).Elem())
	var tst = make([]ICdNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICdNameContext)
		}
	}

	return tst
}

func (s *PurgeStatementContext) CdName(i int) ICdNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICdNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICdNameContext)
}

func (s *PurgeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PurgeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PurgeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterPurgeStatement(s)
	}
}

func (s *PurgeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitPurgeStatement(s)
	}
}

func (p *Cobol85Parser) PurgeStatement() (localctx IPurgeStatementContext) {
	localctx = NewPurgeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 820, Cobol85ParserRULE_purgeStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4794)
		p.Match(Cobol85ParserPURGE)
	}
	p.SetState(4796)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH)|(1<<Cobol85ParserATTRIBUTE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBINARY-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-68))|(1<<(Cobol85ParserCOBOL-68))|(1<<(Cobol85ParserCOMMITMENT-68))|(1<<(Cobol85ParserCONTROL_POINT-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(Cobol85ParserCONVENTION-100))|(1<<(Cobol85ParserCRUNCH-100))|(1<<(Cobol85ParserCURSOR-100))|(1<<(Cobol85ParserDEFAULT-100))|(1<<(Cobol85ParserDEFAULT_DISPLAY-100))|(1<<(Cobol85ParserDEFINITION-100)))) != 0) || (((_la-138)&-(0x1f+1)) == 0 && ((1<<uint((_la-138)))&((1<<(Cobol85ParserDFHRESP-138))|(1<<(Cobol85ParserDFHVALUE-138))|(1<<(Cobol85ParserDISK-138))|(1<<(Cobol85ParserDONTCARE-138))|(1<<(Cobol85ParserDOUBLE-138))|(1<<(Cobol85ParserEBCDIC-138))|(1<<(Cobol85ParserEMPTY_CHECK-138)))) != 0) || (((_la-181)&-(0x1f+1)) == 0 && ((1<<uint((_la-181)))&((1<<(Cobol85ParserENTER-181))|(1<<(Cobol85ParserENTRY_PROCEDURE-181))|(1<<(Cobol85ParserERASE-181))|(1<<(Cobol85ParserEOL-181))|(1<<(Cobol85ParserEOS-181))|(1<<(Cobol85ParserESCAPE-181))|(1<<(Cobol85ParserEVENT-181))|(1<<(Cobol85ParserEXCLUSIVE-181))|(1<<(Cobol85ParserEXPORT-181))|(1<<(Cobol85ParserEXTENDED-181)))) != 0) || (((_la-213)&-(0x1f+1)) == 0 && ((1<<uint((_la-213)))&((1<<(Cobol85ParserFOREGROUND_COLOR-213))|(1<<(Cobol85ParserFOREGROUND_COLOUR-213))|(1<<(Cobol85ParserFULL-213))|(1<<(Cobol85ParserFUNCTIONNAME-213))|(1<<(Cobol85ParserFUNCTION_POINTER-213))|(1<<(Cobol85ParserGRID-213))|(1<<(Cobol85ParserHIGHLIGHT-213))|(1<<(Cobol85ParserIMPLICIT-213))|(1<<(Cobol85ParserIMPORT-213)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(Cobol85ParserINTEGER-250))|(1<<(Cobol85ParserKEPT-250))|(1<<(Cobol85ParserKEYBOARD-250))|(1<<(Cobol85ParserLANGUAGE-250))|(1<<(Cobol85ParserLB-250))|(1<<(Cobol85ParserLD-250))|(1<<(Cobol85ParserLEFTLINE-250))|(1<<(Cobol85ParserLENGTH_CHECK-250))|(1<<(Cobol85ParserLIBACCESS-250))|(1<<(Cobol85ParserLIBPARAMETER-250))|(1<<(Cobol85ParserLIBRARY-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(Cobol85ParserLIST-283))|(1<<(Cobol85ParserLOCAL-283))|(1<<(Cobol85ParserLONG_DATE-283))|(1<<(Cobol85ParserLONG_TIME-283))|(1<<(Cobol85ParserLOWER-283))|(1<<(Cobol85ParserLOWLIGHT-283))|(1<<(Cobol85ParserMMDDYYYY-283))|(1<<(Cobol85ParserNAMED-283))|(1<<(Cobol85ParserNATIONAL-283))|(1<<(Cobol85ParserNATIONAL_EDITED-283))|(1<<(Cobol85ParserNETWORK-283))|(1<<(Cobol85ParserNO_ECHO-283)))) != 0) || (((_la-317)&-(0x1f+1)) == 0 && ((1<<uint((_la-317)))&((1<<(Cobol85ParserNUMERIC_DATE-317))|(1<<(Cobol85ParserNUMERIC_TIME-317))|(1<<(Cobol85ParserODT-317))|(1<<(Cobol85ParserORDERLY-317))|(1<<(Cobol85ParserOVERLINE-317))|(1<<(Cobol85ParserOWN-317))|(1<<(Cobol85ParserPASSWORD-317)))) != 0) || (((_la-352)&-(0x1f+1)) == 0 && ((1<<uint((_la-352)))&((1<<(Cobol85ParserPORT-352))|(1<<(Cobol85ParserPRINTER-352))|(1<<(Cobol85ParserPRIVATE-352))|(1<<(Cobol85ParserPROCESS-352))|(1<<(Cobol85ParserPROGRAM-352))|(1<<(Cobol85ParserPROMPT-352))|(1<<(Cobol85ParserREADER-352))|(1<<(Cobol85ParserREMOTE-352))|(1<<(Cobol85ParserREAL-352))|(1<<(Cobol85ParserRECEIVED-352))|(1<<(Cobol85ParserRECURSIVE-352))|(1<<(Cobol85ParserREF-352)))) != 0) || (((_la-391)&-(0x1f+1)) == 0 && ((1<<uint((_la-391)))&((1<<(Cobol85ParserREMOVE-391))|(1<<(Cobol85ParserREQUIRED-391))|(1<<(Cobol85ParserREVERSE_VIDEO-391))|(1<<(Cobol85ParserSAVE-391))|(1<<(Cobol85ParserSECURE-391)))) != 0) || (((_la-431)&-(0x1f+1)) == 0 && ((1<<uint((_la-431)))&((1<<(Cobol85ParserSHARED-431))|(1<<(Cobol85ParserSHAREDBYALL-431))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-431))|(1<<(Cobol85ParserSHARING-431))|(1<<(Cobol85ParserSHORT_DATE-431)))) != 0) || (((_la-466)&-(0x1f+1)) == 0 && ((1<<uint((_la-466)))&((1<<(Cobol85ParserSYMBOL-466))|(1<<(Cobol85ParserTASK-466))|(1<<(Cobol85ParserTHREAD-466))|(1<<(Cobol85ParserTHREAD_LOCAL-466))|(1<<(Cobol85ParserTIMER-466))|(1<<(Cobol85ParserTODAYS_DATE-466))|(1<<(Cobol85ParserTODAYS_NAME-466))|(1<<(Cobol85ParserTRUNCATED-466))|(1<<(Cobol85ParserTYPEDEF-466)))) != 0) || (((_la-498)&-(0x1f+1)) == 0 && ((1<<uint((_la-498)))&((1<<(Cobol85ParserUNDERLINE-498))|(1<<(Cobol85ParserVIRTUAL-498))|(1<<(Cobol85ParserWAIT-498))|(1<<(Cobol85ParserYEAR-498))|(1<<(Cobol85ParserYYYYMMDD-498))|(1<<(Cobol85ParserYYYYDDD-498))|(1<<(Cobol85ParserZERO_FILL-498)))) != 0) || _la == Cobol85ParserIDENTIFIER {
		{
			p.SetState(4795)
			p.CdName()
		}

		p.SetState(4798)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IReadStatementContext is an interface to support dynamic dispatch.
type IReadStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReadStatementContext differentiates from other interfaces.
	IsReadStatementContext()
}

type ReadStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReadStatementContext() *ReadStatementContext {
	var p = new(ReadStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_readStatement
	return p
}

func (*ReadStatementContext) IsReadStatementContext() {}

func NewReadStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReadStatementContext {
	var p = new(ReadStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_readStatement

	return p
}

func (s *ReadStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReadStatementContext) READ() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREAD, 0)
}

func (s *ReadStatementContext) FileName() IFileNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *ReadStatementContext) NEXT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNEXT, 0)
}

func (s *ReadStatementContext) RECORD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRECORD, 0)
}

func (s *ReadStatementContext) ReadInto() IReadIntoContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReadIntoContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReadIntoContext)
}

func (s *ReadStatementContext) ReadWith() IReadWithContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReadWithContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReadWithContext)
}

func (s *ReadStatementContext) ReadKey() IReadKeyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReadKeyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReadKeyContext)
}

func (s *ReadStatementContext) InvalidKeyPhrase() IInvalidKeyPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInvalidKeyPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInvalidKeyPhraseContext)
}

func (s *ReadStatementContext) NotInvalidKeyPhrase() INotInvalidKeyPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INotInvalidKeyPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INotInvalidKeyPhraseContext)
}

func (s *ReadStatementContext) AtEndPhrase() IAtEndPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtEndPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtEndPhraseContext)
}

func (s *ReadStatementContext) NotAtEndPhrase() INotAtEndPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INotAtEndPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INotAtEndPhraseContext)
}

func (s *ReadStatementContext) END_READ() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND_READ, 0)
}

func (s *ReadStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReadStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReadStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReadStatement(s)
	}
}

func (s *ReadStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReadStatement(s)
	}
}

func (p *Cobol85Parser) ReadStatement() (localctx IReadStatementContext) {
	localctx = NewReadStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 822, Cobol85ParserRULE_readStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4800)
		p.Match(Cobol85ParserREAD)
	}
	{
		p.SetState(4801)
		p.FileName()
	}
	p.SetState(4803)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserNEXT {
		{
			p.SetState(4802)
			p.Match(Cobol85ParserNEXT)
		}

	}
	p.SetState(4806)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserRECORD {
		{
			p.SetState(4805)
			p.Match(Cobol85ParserRECORD)
		}

	}
	p.SetState(4809)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserINTO {
		{
			p.SetState(4808)
			p.ReadInto()
		}

	}
	p.SetState(4812)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 704, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4811)
			p.ReadWith()
		}

	}
	p.SetState(4815)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserKEY {
		{
			p.SetState(4814)
			p.ReadKey()
		}

	}
	p.SetState(4818)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 706, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4817)
			p.InvalidKeyPhrase()
		}

	}
	p.SetState(4821)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 707, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4820)
			p.NotInvalidKeyPhrase()
		}

	}
	p.SetState(4824)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 708, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4823)
			p.AtEndPhrase()
		}

	}
	p.SetState(4827)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 709, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4826)
			p.NotAtEndPhrase()
		}

	}
	p.SetState(4830)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 710, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4829)
			p.Match(Cobol85ParserEND_READ)
		}

	}

	return localctx
}

// IReadIntoContext is an interface to support dynamic dispatch.
type IReadIntoContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReadIntoContext differentiates from other interfaces.
	IsReadIntoContext()
}

type ReadIntoContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReadIntoContext() *ReadIntoContext {
	var p = new(ReadIntoContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_readInto
	return p
}

func (*ReadIntoContext) IsReadIntoContext() {}

func NewReadIntoContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReadIntoContext {
	var p = new(ReadIntoContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_readInto

	return p
}

func (s *ReadIntoContext) GetParser() antlr.Parser { return s.parser }

func (s *ReadIntoContext) INTO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINTO, 0)
}

func (s *ReadIntoContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ReadIntoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReadIntoContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReadIntoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReadInto(s)
	}
}

func (s *ReadIntoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReadInto(s)
	}
}

func (p *Cobol85Parser) ReadInto() (localctx IReadIntoContext) {
	localctx = NewReadIntoContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 824, Cobol85ParserRULE_readInto)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4832)
		p.Match(Cobol85ParserINTO)
	}
	{
		p.SetState(4833)
		p.Identifier()
	}

	return localctx
}

// IReadWithContext is an interface to support dynamic dispatch.
type IReadWithContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReadWithContext differentiates from other interfaces.
	IsReadWithContext()
}

type ReadWithContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReadWithContext() *ReadWithContext {
	var p = new(ReadWithContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_readWith
	return p
}

func (*ReadWithContext) IsReadWithContext() {}

func NewReadWithContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReadWithContext {
	var p = new(ReadWithContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_readWith

	return p
}

func (s *ReadWithContext) GetParser() antlr.Parser { return s.parser }

func (s *ReadWithContext) LOCK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLOCK, 0)
}

func (s *ReadWithContext) WAIT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWAIT, 0)
}

func (s *ReadWithContext) WITH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWITH, 0)
}

func (s *ReadWithContext) KEPT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserKEPT, 0)
}

func (s *ReadWithContext) NO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNO, 0)
}

func (s *ReadWithContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReadWithContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReadWithContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReadWith(s)
	}
}

func (s *ReadWithContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReadWith(s)
	}
}

func (p *Cobol85Parser) ReadWith() (localctx IReadWithContext) {
	localctx = NewReadWithContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 826, Cobol85ParserRULE_readWith)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4836)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserWITH {
		{
			p.SetState(4835)
			p.Match(Cobol85ParserWITH)
		}

	}
	p.SetState(4841)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserKEPT, Cobol85ParserNO:
		{
			p.SetState(4838)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85ParserKEPT || _la == Cobol85ParserNO) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(4839)
			p.Match(Cobol85ParserLOCK)
		}

	case Cobol85ParserWAIT:
		{
			p.SetState(4840)
			p.Match(Cobol85ParserWAIT)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IReadKeyContext is an interface to support dynamic dispatch.
type IReadKeyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReadKeyContext differentiates from other interfaces.
	IsReadKeyContext()
}

type ReadKeyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReadKeyContext() *ReadKeyContext {
	var p = new(ReadKeyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_readKey
	return p
}

func (*ReadKeyContext) IsReadKeyContext() {}

func NewReadKeyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReadKeyContext {
	var p = new(ReadKeyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_readKey

	return p
}

func (s *ReadKeyContext) GetParser() antlr.Parser { return s.parser }

func (s *ReadKeyContext) KEY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserKEY, 0)
}

func (s *ReadKeyContext) QualifiedDataName() IQualifiedDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *ReadKeyContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ReadKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReadKeyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReadKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReadKey(s)
	}
}

func (s *ReadKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReadKey(s)
	}
}

func (p *Cobol85Parser) ReadKey() (localctx IReadKeyContext) {
	localctx = NewReadKeyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 828, Cobol85ParserRULE_readKey)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4843)
		p.Match(Cobol85ParserKEY)
	}
	p.SetState(4845)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(4844)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(4847)
		p.QualifiedDataName()
	}

	return localctx
}

// IReceiveStatementContext is an interface to support dynamic dispatch.
type IReceiveStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReceiveStatementContext differentiates from other interfaces.
	IsReceiveStatementContext()
}

type ReceiveStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReceiveStatementContext() *ReceiveStatementContext {
	var p = new(ReceiveStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_receiveStatement
	return p
}

func (*ReceiveStatementContext) IsReceiveStatementContext() {}

func NewReceiveStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReceiveStatementContext {
	var p = new(ReceiveStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_receiveStatement

	return p
}

func (s *ReceiveStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReceiveStatementContext) RECEIVE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRECEIVE, 0)
}

func (s *ReceiveStatementContext) ReceiveFromStatement() IReceiveFromStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReceiveFromStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReceiveFromStatementContext)
}

func (s *ReceiveStatementContext) ReceiveIntoStatement() IReceiveIntoStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReceiveIntoStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReceiveIntoStatementContext)
}

func (s *ReceiveStatementContext) OnExceptionClause() IOnExceptionClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOnExceptionClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOnExceptionClauseContext)
}

func (s *ReceiveStatementContext) NotOnExceptionClause() INotOnExceptionClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INotOnExceptionClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INotOnExceptionClauseContext)
}

func (s *ReceiveStatementContext) END_RECEIVE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND_RECEIVE, 0)
}

func (s *ReceiveStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReceiveStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReceiveStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReceiveStatement(s)
	}
}

func (s *ReceiveStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReceiveStatement(s)
	}
}

func (p *Cobol85Parser) ReceiveStatement() (localctx IReceiveStatementContext) {
	localctx = NewReceiveStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 830, Cobol85ParserRULE_receiveStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4849)
		p.Match(Cobol85ParserRECEIVE)
	}
	p.SetState(4852)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 714, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4850)
			p.ReceiveFromStatement()
		}

	case 2:
		{
			p.SetState(4851)
			p.ReceiveIntoStatement()
		}

	}
	p.SetState(4855)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 715, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4854)
			p.OnExceptionClause()
		}

	}
	p.SetState(4858)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 716, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4857)
			p.NotOnExceptionClause()
		}

	}
	p.SetState(4861)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 717, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4860)
			p.Match(Cobol85ParserEND_RECEIVE)
		}

	}

	return localctx
}

// IReceiveFromStatementContext is an interface to support dynamic dispatch.
type IReceiveFromStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReceiveFromStatementContext differentiates from other interfaces.
	IsReceiveFromStatementContext()
}

type ReceiveFromStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReceiveFromStatementContext() *ReceiveFromStatementContext {
	var p = new(ReceiveFromStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_receiveFromStatement
	return p
}

func (*ReceiveFromStatementContext) IsReceiveFromStatementContext() {}

func NewReceiveFromStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReceiveFromStatementContext {
	var p = new(ReceiveFromStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_receiveFromStatement

	return p
}

func (s *ReceiveFromStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReceiveFromStatementContext) DataName() IDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *ReceiveFromStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFROM, 0)
}

func (s *ReceiveFromStatementContext) ReceiveFrom() IReceiveFromContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReceiveFromContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReceiveFromContext)
}

func (s *ReceiveFromStatementContext) AllReceiveBefore() []IReceiveBeforeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IReceiveBeforeContext)(nil)).Elem())
	var tst = make([]IReceiveBeforeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IReceiveBeforeContext)
		}
	}

	return tst
}

func (s *ReceiveFromStatementContext) ReceiveBefore(i int) IReceiveBeforeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReceiveBeforeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IReceiveBeforeContext)
}

func (s *ReceiveFromStatementContext) AllReceiveWith() []IReceiveWithContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IReceiveWithContext)(nil)).Elem())
	var tst = make([]IReceiveWithContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IReceiveWithContext)
		}
	}

	return tst
}

func (s *ReceiveFromStatementContext) ReceiveWith(i int) IReceiveWithContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReceiveWithContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IReceiveWithContext)
}

func (s *ReceiveFromStatementContext) AllReceiveThread() []IReceiveThreadContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IReceiveThreadContext)(nil)).Elem())
	var tst = make([]IReceiveThreadContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IReceiveThreadContext)
		}
	}

	return tst
}

func (s *ReceiveFromStatementContext) ReceiveThread(i int) IReceiveThreadContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReceiveThreadContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IReceiveThreadContext)
}

func (s *ReceiveFromStatementContext) AllReceiveSize() []IReceiveSizeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IReceiveSizeContext)(nil)).Elem())
	var tst = make([]IReceiveSizeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IReceiveSizeContext)
		}
	}

	return tst
}

func (s *ReceiveFromStatementContext) ReceiveSize(i int) IReceiveSizeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReceiveSizeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IReceiveSizeContext)
}

func (s *ReceiveFromStatementContext) AllReceiveStatus() []IReceiveStatusContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IReceiveStatusContext)(nil)).Elem())
	var tst = make([]IReceiveStatusContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IReceiveStatusContext)
		}
	}

	return tst
}

func (s *ReceiveFromStatementContext) ReceiveStatus(i int) IReceiveStatusContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReceiveStatusContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IReceiveStatusContext)
}

func (s *ReceiveFromStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReceiveFromStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReceiveFromStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReceiveFromStatement(s)
	}
}

func (s *ReceiveFromStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReceiveFromStatement(s)
	}
}

func (p *Cobol85Parser) ReceiveFromStatement() (localctx IReceiveFromStatementContext) {
	localctx = NewReceiveFromStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 832, Cobol85ParserRULE_receiveFromStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4863)
		p.DataName()
	}
	{
		p.SetState(4864)
		p.Match(Cobol85ParserFROM)
	}
	{
		p.SetState(4865)
		p.ReceiveFrom()
	}
	p.SetState(4873)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 719, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(4871)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case Cobol85ParserBEFORE:
				{
					p.SetState(4866)
					p.ReceiveBefore()
				}

			case Cobol85ParserNO, Cobol85ParserWITH:
				{
					p.SetState(4867)
					p.ReceiveWith()
				}

			case Cobol85ParserTHREAD:
				{
					p.SetState(4868)
					p.ReceiveThread()
				}

			case Cobol85ParserSIZE:
				{
					p.SetState(4869)
					p.ReceiveSize()
				}

			case Cobol85ParserSTATUS:
				{
					p.SetState(4870)
					p.ReceiveStatus()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		}
		p.SetState(4875)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 719, p.GetParserRuleContext())
	}

	return localctx
}

// IReceiveFromContext is an interface to support dynamic dispatch.
type IReceiveFromContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReceiveFromContext differentiates from other interfaces.
	IsReceiveFromContext()
}

type ReceiveFromContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReceiveFromContext() *ReceiveFromContext {
	var p = new(ReceiveFromContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_receiveFrom
	return p
}

func (*ReceiveFromContext) IsReceiveFromContext() {}

func NewReceiveFromContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReceiveFromContext {
	var p = new(ReceiveFromContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_receiveFrom

	return p
}

func (s *ReceiveFromContext) GetParser() antlr.Parser { return s.parser }

func (s *ReceiveFromContext) THREAD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHREAD, 0)
}

func (s *ReceiveFromContext) DataName() IDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *ReceiveFromContext) LAST() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLAST, 0)
}

func (s *ReceiveFromContext) ANY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserANY, 0)
}

func (s *ReceiveFromContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReceiveFromContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReceiveFromContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReceiveFrom(s)
	}
}

func (s *ReceiveFromContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReceiveFrom(s)
	}
}

func (p *Cobol85Parser) ReceiveFrom() (localctx IReceiveFromContext) {
	localctx = NewReceiveFromContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 834, Cobol85ParserRULE_receiveFrom)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4882)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserTHREAD:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4876)
			p.Match(Cobol85ParserTHREAD)
		}
		{
			p.SetState(4877)
			p.DataName()
		}

	case Cobol85ParserLAST:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4878)
			p.Match(Cobol85ParserLAST)
		}
		{
			p.SetState(4879)
			p.Match(Cobol85ParserTHREAD)
		}

	case Cobol85ParserANY:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4880)
			p.Match(Cobol85ParserANY)
		}
		{
			p.SetState(4881)
			p.Match(Cobol85ParserTHREAD)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IReceiveIntoStatementContext is an interface to support dynamic dispatch.
type IReceiveIntoStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReceiveIntoStatementContext differentiates from other interfaces.
	IsReceiveIntoStatementContext()
}

type ReceiveIntoStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReceiveIntoStatementContext() *ReceiveIntoStatementContext {
	var p = new(ReceiveIntoStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_receiveIntoStatement
	return p
}

func (*ReceiveIntoStatementContext) IsReceiveIntoStatementContext() {}

func NewReceiveIntoStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReceiveIntoStatementContext {
	var p = new(ReceiveIntoStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_receiveIntoStatement

	return p
}

func (s *ReceiveIntoStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReceiveIntoStatementContext) CdName() ICdNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICdNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICdNameContext)
}

func (s *ReceiveIntoStatementContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ReceiveIntoStatementContext) MESSAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMESSAGE, 0)
}

func (s *ReceiveIntoStatementContext) SEGMENT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSEGMENT, 0)
}

func (s *ReceiveIntoStatementContext) INTO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINTO, 0)
}

func (s *ReceiveIntoStatementContext) ReceiveNoData() IReceiveNoDataContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReceiveNoDataContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReceiveNoDataContext)
}

func (s *ReceiveIntoStatementContext) ReceiveWithData() IReceiveWithDataContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReceiveWithDataContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReceiveWithDataContext)
}

func (s *ReceiveIntoStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReceiveIntoStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReceiveIntoStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReceiveIntoStatement(s)
	}
}

func (s *ReceiveIntoStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReceiveIntoStatement(s)
	}
}

func (p *Cobol85Parser) ReceiveIntoStatement() (localctx IReceiveIntoStatementContext) {
	localctx = NewReceiveIntoStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 836, Cobol85ParserRULE_receiveIntoStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4884)
		p.CdName()
	}
	{
		p.SetState(4885)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserMESSAGE || _la == Cobol85ParserSEGMENT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(4887)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserINTO {
		{
			p.SetState(4886)
			p.Match(Cobol85ParserINTO)
		}

	}
	{
		p.SetState(4889)
		p.Identifier()
	}
	p.SetState(4891)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserNO {
		{
			p.SetState(4890)
			p.ReceiveNoData()
		}

	}
	p.SetState(4894)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 723, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4893)
			p.ReceiveWithData()
		}

	}

	return localctx
}

// IReceiveNoDataContext is an interface to support dynamic dispatch.
type IReceiveNoDataContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReceiveNoDataContext differentiates from other interfaces.
	IsReceiveNoDataContext()
}

type ReceiveNoDataContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReceiveNoDataContext() *ReceiveNoDataContext {
	var p = new(ReceiveNoDataContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_receiveNoData
	return p
}

func (*ReceiveNoDataContext) IsReceiveNoDataContext() {}

func NewReceiveNoDataContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReceiveNoDataContext {
	var p = new(ReceiveNoDataContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_receiveNoData

	return p
}

func (s *ReceiveNoDataContext) GetParser() antlr.Parser { return s.parser }

func (s *ReceiveNoDataContext) NO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNO, 0)
}

func (s *ReceiveNoDataContext) DATA() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDATA, 0)
}

func (s *ReceiveNoDataContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *ReceiveNoDataContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ReceiveNoDataContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReceiveNoDataContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReceiveNoDataContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReceiveNoData(s)
	}
}

func (s *ReceiveNoDataContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReceiveNoData(s)
	}
}

func (p *Cobol85Parser) ReceiveNoData() (localctx IReceiveNoDataContext) {
	localctx = NewReceiveNoDataContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 838, Cobol85ParserRULE_receiveNoData)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4896)
		p.Match(Cobol85ParserNO)
	}
	{
		p.SetState(4897)
		p.Match(Cobol85ParserDATA)
	}
	p.SetState(4901)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 724, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4898)
				p.Statement()
			}

		}
		p.SetState(4903)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 724, p.GetParserRuleContext())
	}

	return localctx
}

// IReceiveWithDataContext is an interface to support dynamic dispatch.
type IReceiveWithDataContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReceiveWithDataContext differentiates from other interfaces.
	IsReceiveWithDataContext()
}

type ReceiveWithDataContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReceiveWithDataContext() *ReceiveWithDataContext {
	var p = new(ReceiveWithDataContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_receiveWithData
	return p
}

func (*ReceiveWithDataContext) IsReceiveWithDataContext() {}

func NewReceiveWithDataContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReceiveWithDataContext {
	var p = new(ReceiveWithDataContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_receiveWithData

	return p
}

func (s *ReceiveWithDataContext) GetParser() antlr.Parser { return s.parser }

func (s *ReceiveWithDataContext) WITH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWITH, 0)
}

func (s *ReceiveWithDataContext) DATA() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDATA, 0)
}

func (s *ReceiveWithDataContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *ReceiveWithDataContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ReceiveWithDataContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReceiveWithDataContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReceiveWithDataContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReceiveWithData(s)
	}
}

func (s *ReceiveWithDataContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReceiveWithData(s)
	}
}

func (p *Cobol85Parser) ReceiveWithData() (localctx IReceiveWithDataContext) {
	localctx = NewReceiveWithDataContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 840, Cobol85ParserRULE_receiveWithData)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4904)
		p.Match(Cobol85ParserWITH)
	}
	{
		p.SetState(4905)
		p.Match(Cobol85ParserDATA)
	}
	p.SetState(4909)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 725, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4906)
				p.Statement()
			}

		}
		p.SetState(4911)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 725, p.GetParserRuleContext())
	}

	return localctx
}

// IReceiveBeforeContext is an interface to support dynamic dispatch.
type IReceiveBeforeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReceiveBeforeContext differentiates from other interfaces.
	IsReceiveBeforeContext()
}

type ReceiveBeforeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReceiveBeforeContext() *ReceiveBeforeContext {
	var p = new(ReceiveBeforeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_receiveBefore
	return p
}

func (*ReceiveBeforeContext) IsReceiveBeforeContext() {}

func NewReceiveBeforeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReceiveBeforeContext {
	var p = new(ReceiveBeforeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_receiveBefore

	return p
}

func (s *ReceiveBeforeContext) GetParser() antlr.Parser { return s.parser }

func (s *ReceiveBeforeContext) BEFORE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBEFORE, 0)
}

func (s *ReceiveBeforeContext) NumericLiteral() INumericLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumericLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumericLiteralContext)
}

func (s *ReceiveBeforeContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ReceiveBeforeContext) TIME() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTIME, 0)
}

func (s *ReceiveBeforeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReceiveBeforeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReceiveBeforeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReceiveBefore(s)
	}
}

func (s *ReceiveBeforeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReceiveBefore(s)
	}
}

func (p *Cobol85Parser) ReceiveBefore() (localctx IReceiveBeforeContext) {
	localctx = NewReceiveBeforeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 842, Cobol85ParserRULE_receiveBefore)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4912)
		p.Match(Cobol85ParserBEFORE)
	}
	p.SetState(4914)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 726, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4913)
			p.Match(Cobol85ParserTIME)
		}

	}
	p.SetState(4918)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 727, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4916)
			p.NumericLiteral()
		}

	case 2:
		{
			p.SetState(4917)
			p.Identifier()
		}

	}

	return localctx
}

// IReceiveWithContext is an interface to support dynamic dispatch.
type IReceiveWithContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReceiveWithContext differentiates from other interfaces.
	IsReceiveWithContext()
}

type ReceiveWithContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReceiveWithContext() *ReceiveWithContext {
	var p = new(ReceiveWithContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_receiveWith
	return p
}

func (*ReceiveWithContext) IsReceiveWithContext() {}

func NewReceiveWithContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReceiveWithContext {
	var p = new(ReceiveWithContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_receiveWith

	return p
}

func (s *ReceiveWithContext) GetParser() antlr.Parser { return s.parser }

func (s *ReceiveWithContext) NO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNO, 0)
}

func (s *ReceiveWithContext) WAIT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWAIT, 0)
}

func (s *ReceiveWithContext) WITH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWITH, 0)
}

func (s *ReceiveWithContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReceiveWithContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReceiveWithContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReceiveWith(s)
	}
}

func (s *ReceiveWithContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReceiveWith(s)
	}
}

func (p *Cobol85Parser) ReceiveWith() (localctx IReceiveWithContext) {
	localctx = NewReceiveWithContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 844, Cobol85ParserRULE_receiveWith)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4921)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserWITH {
		{
			p.SetState(4920)
			p.Match(Cobol85ParserWITH)
		}

	}
	{
		p.SetState(4923)
		p.Match(Cobol85ParserNO)
	}
	{
		p.SetState(4924)
		p.Match(Cobol85ParserWAIT)
	}

	return localctx
}

// IReceiveThreadContext is an interface to support dynamic dispatch.
type IReceiveThreadContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReceiveThreadContext differentiates from other interfaces.
	IsReceiveThreadContext()
}

type ReceiveThreadContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReceiveThreadContext() *ReceiveThreadContext {
	var p = new(ReceiveThreadContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_receiveThread
	return p
}

func (*ReceiveThreadContext) IsReceiveThreadContext() {}

func NewReceiveThreadContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReceiveThreadContext {
	var p = new(ReceiveThreadContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_receiveThread

	return p
}

func (s *ReceiveThreadContext) GetParser() antlr.Parser { return s.parser }

func (s *ReceiveThreadContext) THREAD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHREAD, 0)
}

func (s *ReceiveThreadContext) DataName() IDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *ReceiveThreadContext) IN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIN, 0)
}

func (s *ReceiveThreadContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReceiveThreadContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReceiveThreadContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReceiveThread(s)
	}
}

func (s *ReceiveThreadContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReceiveThread(s)
	}
}

func (p *Cobol85Parser) ReceiveThread() (localctx IReceiveThreadContext) {
	localctx = NewReceiveThreadContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 846, Cobol85ParserRULE_receiveThread)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4926)
		p.Match(Cobol85ParserTHREAD)
	}
	p.SetState(4928)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIN {
		{
			p.SetState(4927)
			p.Match(Cobol85ParserIN)
		}

	}
	{
		p.SetState(4930)
		p.DataName()
	}

	return localctx
}

// IReceiveSizeContext is an interface to support dynamic dispatch.
type IReceiveSizeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReceiveSizeContext differentiates from other interfaces.
	IsReceiveSizeContext()
}

type ReceiveSizeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReceiveSizeContext() *ReceiveSizeContext {
	var p = new(ReceiveSizeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_receiveSize
	return p
}

func (*ReceiveSizeContext) IsReceiveSizeContext() {}

func NewReceiveSizeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReceiveSizeContext {
	var p = new(ReceiveSizeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_receiveSize

	return p
}

func (s *ReceiveSizeContext) GetParser() antlr.Parser { return s.parser }

func (s *ReceiveSizeContext) SIZE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSIZE, 0)
}

func (s *ReceiveSizeContext) NumericLiteral() INumericLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumericLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumericLiteralContext)
}

func (s *ReceiveSizeContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ReceiveSizeContext) IN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIN, 0)
}

func (s *ReceiveSizeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReceiveSizeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReceiveSizeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReceiveSize(s)
	}
}

func (s *ReceiveSizeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReceiveSize(s)
	}
}

func (p *Cobol85Parser) ReceiveSize() (localctx IReceiveSizeContext) {
	localctx = NewReceiveSizeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 848, Cobol85ParserRULE_receiveSize)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4932)
		p.Match(Cobol85ParserSIZE)
	}
	p.SetState(4934)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIN {
		{
			p.SetState(4933)
			p.Match(Cobol85ParserIN)
		}

	}
	p.SetState(4938)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 731, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4936)
			p.NumericLiteral()
		}

	case 2:
		{
			p.SetState(4937)
			p.Identifier()
		}

	}

	return localctx
}

// IReceiveStatusContext is an interface to support dynamic dispatch.
type IReceiveStatusContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReceiveStatusContext differentiates from other interfaces.
	IsReceiveStatusContext()
}

type ReceiveStatusContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReceiveStatusContext() *ReceiveStatusContext {
	var p = new(ReceiveStatusContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_receiveStatus
	return p
}

func (*ReceiveStatusContext) IsReceiveStatusContext() {}

func NewReceiveStatusContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReceiveStatusContext {
	var p = new(ReceiveStatusContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_receiveStatus

	return p
}

func (s *ReceiveStatusContext) GetParser() antlr.Parser { return s.parser }

func (s *ReceiveStatusContext) STATUS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSTATUS, 0)
}

func (s *ReceiveStatusContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ReceiveStatusContext) IN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIN, 0)
}

func (s *ReceiveStatusContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReceiveStatusContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReceiveStatusContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReceiveStatus(s)
	}
}

func (s *ReceiveStatusContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReceiveStatus(s)
	}
}

func (p *Cobol85Parser) ReceiveStatus() (localctx IReceiveStatusContext) {
	localctx = NewReceiveStatusContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 850, Cobol85ParserRULE_receiveStatus)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4940)
		p.Match(Cobol85ParserSTATUS)
	}
	p.SetState(4942)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIN {
		{
			p.SetState(4941)
			p.Match(Cobol85ParserIN)
		}

	}

	{
		p.SetState(4944)
		p.Identifier()
	}

	return localctx
}

// IReleaseStatementContext is an interface to support dynamic dispatch.
type IReleaseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReleaseStatementContext differentiates from other interfaces.
	IsReleaseStatementContext()
}

type ReleaseStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReleaseStatementContext() *ReleaseStatementContext {
	var p = new(ReleaseStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_releaseStatement
	return p
}

func (*ReleaseStatementContext) IsReleaseStatementContext() {}

func NewReleaseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReleaseStatementContext {
	var p = new(ReleaseStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_releaseStatement

	return p
}

func (s *ReleaseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReleaseStatementContext) RELEASE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRELEASE, 0)
}

func (s *ReleaseStatementContext) RecordName() IRecordNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRecordNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRecordNameContext)
}

func (s *ReleaseStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFROM, 0)
}

func (s *ReleaseStatementContext) QualifiedDataName() IQualifiedDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *ReleaseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReleaseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReleaseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReleaseStatement(s)
	}
}

func (s *ReleaseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReleaseStatement(s)
	}
}

func (p *Cobol85Parser) ReleaseStatement() (localctx IReleaseStatementContext) {
	localctx = NewReleaseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 852, Cobol85ParserRULE_releaseStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4946)
		p.Match(Cobol85ParserRELEASE)
	}
	{
		p.SetState(4947)
		p.RecordName()
	}
	p.SetState(4950)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFROM {
		{
			p.SetState(4948)
			p.Match(Cobol85ParserFROM)
		}
		{
			p.SetState(4949)
			p.QualifiedDataName()
		}

	}

	return localctx
}

// IReturnStatementContext is an interface to support dynamic dispatch.
type IReturnStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReturnStatementContext differentiates from other interfaces.
	IsReturnStatementContext()
}

type ReturnStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnStatementContext() *ReturnStatementContext {
	var p = new(ReturnStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_returnStatement
	return p
}

func (*ReturnStatementContext) IsReturnStatementContext() {}

func NewReturnStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnStatementContext {
	var p = new(ReturnStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_returnStatement

	return p
}

func (s *ReturnStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnStatementContext) RETURN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRETURN, 0)
}

func (s *ReturnStatementContext) FileName() IFileNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *ReturnStatementContext) AtEndPhrase() IAtEndPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtEndPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtEndPhraseContext)
}

func (s *ReturnStatementContext) RECORD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRECORD, 0)
}

func (s *ReturnStatementContext) ReturnInto() IReturnIntoContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReturnIntoContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReturnIntoContext)
}

func (s *ReturnStatementContext) NotAtEndPhrase() INotAtEndPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INotAtEndPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INotAtEndPhraseContext)
}

func (s *ReturnStatementContext) END_RETURN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND_RETURN, 0)
}

func (s *ReturnStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReturnStatement(s)
	}
}

func (s *ReturnStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReturnStatement(s)
	}
}

func (p *Cobol85Parser) ReturnStatement() (localctx IReturnStatementContext) {
	localctx = NewReturnStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 854, Cobol85ParserRULE_returnStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4952)
		p.Match(Cobol85ParserRETURN)
	}
	{
		p.SetState(4953)
		p.FileName()
	}
	p.SetState(4955)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserRECORD {
		{
			p.SetState(4954)
			p.Match(Cobol85ParserRECORD)
		}

	}
	p.SetState(4958)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserINTO {
		{
			p.SetState(4957)
			p.ReturnInto()
		}

	}
	{
		p.SetState(4960)
		p.AtEndPhrase()
	}
	p.SetState(4962)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 736, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4961)
			p.NotAtEndPhrase()
		}

	}
	p.SetState(4965)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 737, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4964)
			p.Match(Cobol85ParserEND_RETURN)
		}

	}

	return localctx
}

// IReturnIntoContext is an interface to support dynamic dispatch.
type IReturnIntoContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReturnIntoContext differentiates from other interfaces.
	IsReturnIntoContext()
}

type ReturnIntoContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnIntoContext() *ReturnIntoContext {
	var p = new(ReturnIntoContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_returnInto
	return p
}

func (*ReturnIntoContext) IsReturnIntoContext() {}

func NewReturnIntoContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnIntoContext {
	var p = new(ReturnIntoContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_returnInto

	return p
}

func (s *ReturnIntoContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnIntoContext) INTO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINTO, 0)
}

func (s *ReturnIntoContext) QualifiedDataName() IQualifiedDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *ReturnIntoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnIntoContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnIntoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReturnInto(s)
	}
}

func (s *ReturnIntoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReturnInto(s)
	}
}

func (p *Cobol85Parser) ReturnInto() (localctx IReturnIntoContext) {
	localctx = NewReturnIntoContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 856, Cobol85ParserRULE_returnInto)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4967)
		p.Match(Cobol85ParserINTO)
	}
	{
		p.SetState(4968)
		p.QualifiedDataName()
	}

	return localctx
}

// IRewriteStatementContext is an interface to support dynamic dispatch.
type IRewriteStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRewriteStatementContext differentiates from other interfaces.
	IsRewriteStatementContext()
}

type RewriteStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRewriteStatementContext() *RewriteStatementContext {
	var p = new(RewriteStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_rewriteStatement
	return p
}

func (*RewriteStatementContext) IsRewriteStatementContext() {}

func NewRewriteStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RewriteStatementContext {
	var p = new(RewriteStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_rewriteStatement

	return p
}

func (s *RewriteStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RewriteStatementContext) REWRITE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREWRITE, 0)
}

func (s *RewriteStatementContext) RecordName() IRecordNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRecordNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRecordNameContext)
}

func (s *RewriteStatementContext) RewriteFrom() IRewriteFromContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRewriteFromContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRewriteFromContext)
}

func (s *RewriteStatementContext) InvalidKeyPhrase() IInvalidKeyPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInvalidKeyPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInvalidKeyPhraseContext)
}

func (s *RewriteStatementContext) NotInvalidKeyPhrase() INotInvalidKeyPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INotInvalidKeyPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INotInvalidKeyPhraseContext)
}

func (s *RewriteStatementContext) END_REWRITE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND_REWRITE, 0)
}

func (s *RewriteStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RewriteStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RewriteStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterRewriteStatement(s)
	}
}

func (s *RewriteStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitRewriteStatement(s)
	}
}

func (p *Cobol85Parser) RewriteStatement() (localctx IRewriteStatementContext) {
	localctx = NewRewriteStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 858, Cobol85ParserRULE_rewriteStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4970)
		p.Match(Cobol85ParserREWRITE)
	}
	{
		p.SetState(4971)
		p.RecordName()
	}
	p.SetState(4973)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFROM {
		{
			p.SetState(4972)
			p.RewriteFrom()
		}

	}
	p.SetState(4976)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 739, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4975)
			p.InvalidKeyPhrase()
		}

	}
	p.SetState(4979)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 740, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4978)
			p.NotInvalidKeyPhrase()
		}

	}
	p.SetState(4982)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 741, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4981)
			p.Match(Cobol85ParserEND_REWRITE)
		}

	}

	return localctx
}

// IRewriteFromContext is an interface to support dynamic dispatch.
type IRewriteFromContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRewriteFromContext differentiates from other interfaces.
	IsRewriteFromContext()
}

type RewriteFromContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRewriteFromContext() *RewriteFromContext {
	var p = new(RewriteFromContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_rewriteFrom
	return p
}

func (*RewriteFromContext) IsRewriteFromContext() {}

func NewRewriteFromContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RewriteFromContext {
	var p = new(RewriteFromContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_rewriteFrom

	return p
}

func (s *RewriteFromContext) GetParser() antlr.Parser { return s.parser }

func (s *RewriteFromContext) FROM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFROM, 0)
}

func (s *RewriteFromContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RewriteFromContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RewriteFromContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RewriteFromContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterRewriteFrom(s)
	}
}

func (s *RewriteFromContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitRewriteFrom(s)
	}
}

func (p *Cobol85Parser) RewriteFrom() (localctx IRewriteFromContext) {
	localctx = NewRewriteFromContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 860, Cobol85ParserRULE_rewriteFrom)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4984)
		p.Match(Cobol85ParserFROM)
	}
	{
		p.SetState(4985)
		p.Identifier()
	}

	return localctx
}

// ISearchStatementContext is an interface to support dynamic dispatch.
type ISearchStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSearchStatementContext differentiates from other interfaces.
	IsSearchStatementContext()
}

type SearchStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySearchStatementContext() *SearchStatementContext {
	var p = new(SearchStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_searchStatement
	return p
}

func (*SearchStatementContext) IsSearchStatementContext() {}

func NewSearchStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SearchStatementContext {
	var p = new(SearchStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_searchStatement

	return p
}

func (s *SearchStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SearchStatementContext) SEARCH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSEARCH, 0)
}

func (s *SearchStatementContext) QualifiedDataName() IQualifiedDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *SearchStatementContext) ALL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALL, 0)
}

func (s *SearchStatementContext) SearchVarying() ISearchVaryingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISearchVaryingContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISearchVaryingContext)
}

func (s *SearchStatementContext) AtEndPhrase() IAtEndPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtEndPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtEndPhraseContext)
}

func (s *SearchStatementContext) AllSearchWhen() []ISearchWhenContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISearchWhenContext)(nil)).Elem())
	var tst = make([]ISearchWhenContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISearchWhenContext)
		}
	}

	return tst
}

func (s *SearchStatementContext) SearchWhen(i int) ISearchWhenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISearchWhenContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISearchWhenContext)
}

func (s *SearchStatementContext) END_SEARCH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND_SEARCH, 0)
}

func (s *SearchStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SearchStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SearchStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSearchStatement(s)
	}
}

func (s *SearchStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSearchStatement(s)
	}
}

func (p *Cobol85Parser) SearchStatement() (localctx ISearchStatementContext) {
	localctx = NewSearchStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 862, Cobol85ParserRULE_searchStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4987)
		p.Match(Cobol85ParserSEARCH)
	}
	p.SetState(4989)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserALL {
		{
			p.SetState(4988)
			p.Match(Cobol85ParserALL)
		}

	}
	{
		p.SetState(4991)
		p.QualifiedDataName()
	}
	p.SetState(4993)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserVARYING {
		{
			p.SetState(4992)
			p.SearchVarying()
		}

	}
	p.SetState(4996)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserAT || _la == Cobol85ParserEND {
		{
			p.SetState(4995)
			p.AtEndPhrase()
		}

	}
	p.SetState(4999)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(4998)
				p.SearchWhen()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(5001)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 745, p.GetParserRuleContext())
	}
	p.SetState(5004)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 746, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5003)
			p.Match(Cobol85ParserEND_SEARCH)
		}

	}

	return localctx
}

// ISearchVaryingContext is an interface to support dynamic dispatch.
type ISearchVaryingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSearchVaryingContext differentiates from other interfaces.
	IsSearchVaryingContext()
}

type SearchVaryingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySearchVaryingContext() *SearchVaryingContext {
	var p = new(SearchVaryingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_searchVarying
	return p
}

func (*SearchVaryingContext) IsSearchVaryingContext() {}

func NewSearchVaryingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SearchVaryingContext {
	var p = new(SearchVaryingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_searchVarying

	return p
}

func (s *SearchVaryingContext) GetParser() antlr.Parser { return s.parser }

func (s *SearchVaryingContext) VARYING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserVARYING, 0)
}

func (s *SearchVaryingContext) QualifiedDataName() IQualifiedDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *SearchVaryingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SearchVaryingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SearchVaryingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSearchVarying(s)
	}
}

func (s *SearchVaryingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSearchVarying(s)
	}
}

func (p *Cobol85Parser) SearchVarying() (localctx ISearchVaryingContext) {
	localctx = NewSearchVaryingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 864, Cobol85ParserRULE_searchVarying)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5006)
		p.Match(Cobol85ParserVARYING)
	}
	{
		p.SetState(5007)
		p.QualifiedDataName()
	}

	return localctx
}

// ISearchWhenContext is an interface to support dynamic dispatch.
type ISearchWhenContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSearchWhenContext differentiates from other interfaces.
	IsSearchWhenContext()
}

type SearchWhenContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySearchWhenContext() *SearchWhenContext {
	var p = new(SearchWhenContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_searchWhen
	return p
}

func (*SearchWhenContext) IsSearchWhenContext() {}

func NewSearchWhenContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SearchWhenContext {
	var p = new(SearchWhenContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_searchWhen

	return p
}

func (s *SearchWhenContext) GetParser() antlr.Parser { return s.parser }

func (s *SearchWhenContext) WHEN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWHEN, 0)
}

func (s *SearchWhenContext) Condition() IConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *SearchWhenContext) NEXT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNEXT, 0)
}

func (s *SearchWhenContext) SENTENCE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSENTENCE, 0)
}

func (s *SearchWhenContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *SearchWhenContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *SearchWhenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SearchWhenContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SearchWhenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSearchWhen(s)
	}
}

func (s *SearchWhenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSearchWhen(s)
	}
}

func (p *Cobol85Parser) SearchWhen() (localctx ISearchWhenContext) {
	localctx = NewSearchWhenContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 866, Cobol85ParserRULE_searchWhen)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5009)
		p.Match(Cobol85ParserWHEN)
	}
	{
		p.SetState(5010)
		p.Condition()
	}
	p.SetState(5019)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserNEXT:
		{
			p.SetState(5011)
			p.Match(Cobol85ParserNEXT)
		}
		{
			p.SetState(5012)
			p.Match(Cobol85ParserSENTENCE)
		}

	case Cobol85ParserACCEPT, Cobol85ParserADD, Cobol85ParserALTER, Cobol85ParserAT, Cobol85ParserCALL, Cobol85ParserCANCEL, Cobol85ParserCLOSE, Cobol85ParserCOMPUTE, Cobol85ParserCONTINUE, Cobol85ParserDELETE, Cobol85ParserDISABLE, Cobol85ParserDISPLAY, Cobol85ParserDIVIDE, Cobol85ParserELSE, Cobol85ParserENABLE, Cobol85ParserEND, Cobol85ParserEND_ACCEPT, Cobol85ParserEND_ADD, Cobol85ParserEND_CALL, Cobol85ParserEND_COMPUTE, Cobol85ParserEND_DELETE, Cobol85ParserEND_DIVIDE, Cobol85ParserEND_EVALUATE, Cobol85ParserEND_IF, Cobol85ParserEND_MULTIPLY, Cobol85ParserEND_PERFORM, Cobol85ParserEND_READ, Cobol85ParserEND_RECEIVE, Cobol85ParserEND_RETURN, Cobol85ParserEND_REWRITE, Cobol85ParserEND_SEARCH, Cobol85ParserEND_START, Cobol85ParserEND_STRING, Cobol85ParserEND_SUBTRACT, Cobol85ParserEND_UNSTRING, Cobol85ParserEND_WRITE, Cobol85ParserENTRY, Cobol85ParserEVALUATE, Cobol85ParserEXCEPTION, Cobol85ParserEXHIBIT, Cobol85ParserEXIT, Cobol85ParserGENERATE, Cobol85ParserGOBACK, Cobol85ParserGO, Cobol85ParserIF, Cobol85ParserINITIALIZE, Cobol85ParserINITIATE, Cobol85ParserINSPECT, Cobol85ParserINVALID, Cobol85ParserMERGE, Cobol85ParserMOVE, Cobol85ParserMULTIPLY, Cobol85ParserNOT, Cobol85ParserON, Cobol85ParserOPEN, Cobol85ParserPERFORM, Cobol85ParserPURGE, Cobol85ParserREAD, Cobol85ParserRECEIVE, Cobol85ParserRELEASE, Cobol85ParserRETURN, Cobol85ParserREWRITE, Cobol85ParserSEARCH, Cobol85ParserSEND, Cobol85ParserSET, Cobol85ParserSORT, Cobol85ParserSTART, Cobol85ParserSTOP, Cobol85ParserSTRING, Cobol85ParserSUBTRACT, Cobol85ParserTERMINATE, Cobol85ParserUNSTRING, Cobol85ParserWHEN, Cobol85ParserWITH, Cobol85ParserWRITE, Cobol85ParserDOT_FS, Cobol85ParserEXECCICSLINE, Cobol85ParserEXECSQLIMSLINE, Cobol85ParserEXECSQLLINE:
		p.SetState(5016)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 747, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(5013)
					p.Statement()
				}

			}
			p.SetState(5018)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 747, p.GetParserRuleContext())
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISendStatementContext is an interface to support dynamic dispatch.
type ISendStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSendStatementContext differentiates from other interfaces.
	IsSendStatementContext()
}

type SendStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySendStatementContext() *SendStatementContext {
	var p = new(SendStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sendStatement
	return p
}

func (*SendStatementContext) IsSendStatementContext() {}

func NewSendStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SendStatementContext {
	var p = new(SendStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sendStatement

	return p
}

func (s *SendStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SendStatementContext) SEND() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSEND, 0)
}

func (s *SendStatementContext) SendStatementSync() ISendStatementSyncContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISendStatementSyncContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISendStatementSyncContext)
}

func (s *SendStatementContext) SendStatementAsync() ISendStatementAsyncContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISendStatementAsyncContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISendStatementAsyncContext)
}

func (s *SendStatementContext) OnExceptionClause() IOnExceptionClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOnExceptionClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOnExceptionClauseContext)
}

func (s *SendStatementContext) NotOnExceptionClause() INotOnExceptionClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INotOnExceptionClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INotOnExceptionClauseContext)
}

func (s *SendStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SendStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SendStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSendStatement(s)
	}
}

func (s *SendStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSendStatement(s)
	}
}

func (p *Cobol85Parser) SendStatement() (localctx ISendStatementContext) {
	localctx = NewSendStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 868, Cobol85ParserRULE_sendStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5021)
		p.Match(Cobol85ParserSEND)
	}
	p.SetState(5024)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserABORT, Cobol85ParserADDRESS, Cobol85ParserALL, Cobol85ParserAS, Cobol85ParserASCII, Cobol85ParserASSOCIATED_DATA, Cobol85ParserASSOCIATED_DATA_LENGTH, Cobol85ParserATTRIBUTE, Cobol85ParserAUTO, Cobol85ParserAUTO_SKIP, Cobol85ParserBACKGROUND_COLOR, Cobol85ParserBACKGROUND_COLOUR, Cobol85ParserBEEP, Cobol85ParserBELL, Cobol85ParserBINARY, Cobol85ParserBIT, Cobol85ParserBLINK, Cobol85ParserBOUNDS, Cobol85ParserCAPABLE, Cobol85ParserCCSVERSION, Cobol85ParserCHANGED, Cobol85ParserCHANNEL, Cobol85ParserCLOSE_DISPOSITION, Cobol85ParserCOBOL, Cobol85ParserCOMMITMENT, Cobol85ParserCONTROL_POINT, Cobol85ParserCONVENTION, Cobol85ParserCRUNCH, Cobol85ParserCURSOR, Cobol85ParserDATE, Cobol85ParserDAY, Cobol85ParserDAY_OF_WEEK, Cobol85ParserDEBUG_CONTENTS, Cobol85ParserDEBUG_ITEM, Cobol85ParserDEBUG_LINE, Cobol85ParserDEBUG_NAME, Cobol85ParserDEBUG_SUB_1, Cobol85ParserDEBUG_SUB_2, Cobol85ParserDEBUG_SUB_3, Cobol85ParserDEFAULT, Cobol85ParserDEFAULT_DISPLAY, Cobol85ParserDEFINITION, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserDISK, Cobol85ParserDONTCARE, Cobol85ParserDOUBLE, Cobol85ParserEBCDIC, Cobol85ParserEMPTY_CHECK, Cobol85ParserENTER, Cobol85ParserENTRY_PROCEDURE, Cobol85ParserERASE, Cobol85ParserEOL, Cobol85ParserEOS, Cobol85ParserESCAPE, Cobol85ParserEVENT, Cobol85ParserEXCLUSIVE, Cobol85ParserEXPORT, Cobol85ParserEXTENDED, Cobol85ParserFALSE, Cobol85ParserFOREGROUND_COLOR, Cobol85ParserFOREGROUND_COLOUR, Cobol85ParserFULL, Cobol85ParserFUNCTION, Cobol85ParserFUNCTIONNAME, Cobol85ParserFUNCTION_POINTER, Cobol85ParserGRID, Cobol85ParserHIGHLIGHT, Cobol85ParserHIGH_VALUE, Cobol85ParserHIGH_VALUES, Cobol85ParserIMPLICIT, Cobol85ParserIMPORT, Cobol85ParserINTEGER, Cobol85ParserKEPT, Cobol85ParserKEYBOARD, Cobol85ParserLANGUAGE, Cobol85ParserLB, Cobol85ParserLD, Cobol85ParserLEFTLINE, Cobol85ParserLENGTH, Cobol85ParserLENGTH_CHECK, Cobol85ParserLIBACCESS, Cobol85ParserLIBPARAMETER, Cobol85ParserLIBRARY, Cobol85ParserLINAGE_COUNTER, Cobol85ParserLINE_COUNTER, Cobol85ParserLIST, Cobol85ParserLOCAL, Cobol85ParserLONG_DATE, Cobol85ParserLONG_TIME, Cobol85ParserLOWER, Cobol85ParserLOWLIGHT, Cobol85ParserLOW_VALUE, Cobol85ParserLOW_VALUES, Cobol85ParserMMDDYYYY, Cobol85ParserNAMED, Cobol85ParserNATIONAL, Cobol85ParserNATIONAL_EDITED, Cobol85ParserNETWORK, Cobol85ParserNO_ECHO, Cobol85ParserNULL, Cobol85ParserNULLS, Cobol85ParserNUMERIC_DATE, Cobol85ParserNUMERIC_TIME, Cobol85ParserODT, Cobol85ParserORDERLY, Cobol85ParserOVERLINE, Cobol85ParserOWN, Cobol85ParserPAGE_COUNTER, Cobol85ParserPASSWORD, Cobol85ParserPORT, Cobol85ParserPRINTER, Cobol85ParserPRIVATE, Cobol85ParserPROCESS, Cobol85ParserPROGRAM, Cobol85ParserPROMPT, Cobol85ParserQUOTE, Cobol85ParserQUOTES, Cobol85ParserREADER, Cobol85ParserREMOTE, Cobol85ParserREAL, Cobol85ParserRECEIVED, Cobol85ParserRECURSIVE, Cobol85ParserREF, Cobol85ParserREMOVE, Cobol85ParserREQUIRED, Cobol85ParserREVERSE_VIDEO, Cobol85ParserRETURN_CODE, Cobol85ParserSAVE, Cobol85ParserSECURE, Cobol85ParserSHARED, Cobol85ParserSHAREDBYALL, Cobol85ParserSHAREDBYRUNUNIT, Cobol85ParserSHARING, Cobol85ParserSHIFT_IN, Cobol85ParserSHIFT_OUT, Cobol85ParserSHORT_DATE, Cobol85ParserSORT_CONTROL, Cobol85ParserSORT_CORE_SIZE, Cobol85ParserSORT_FILE_SIZE, Cobol85ParserSORT_MESSAGE, Cobol85ParserSORT_MODE_SIZE, Cobol85ParserSORT_RETURN, Cobol85ParserSPACE, Cobol85ParserSPACES, Cobol85ParserSYMBOL, Cobol85ParserTALLY, Cobol85ParserTASK, Cobol85ParserTHREAD, Cobol85ParserTHREAD_LOCAL, Cobol85ParserTIME, Cobol85ParserTIMER, Cobol85ParserTODAYS_DATE, Cobol85ParserTODAYS_NAME, Cobol85ParserTRUE, Cobol85ParserTRUNCATED, Cobol85ParserTYPEDEF, Cobol85ParserUNDERLINE, Cobol85ParserVIRTUAL, Cobol85ParserWAIT, Cobol85ParserWHEN_COMPILED, Cobol85ParserYEAR, Cobol85ParserYYYYMMDD, Cobol85ParserYYYYDDD, Cobol85ParserZERO, Cobol85ParserZERO_FILL, Cobol85ParserZEROS, Cobol85ParserZEROES, Cobol85ParserNONNUMERICLITERAL, Cobol85ParserLEVEL_NUMBER_66, Cobol85ParserLEVEL_NUMBER_77, Cobol85ParserLEVEL_NUMBER_88, Cobol85ParserINTEGERLITERAL, Cobol85ParserNUMERICLITERAL, Cobol85ParserIDENTIFIER:
		{
			p.SetState(5022)
			p.SendStatementSync()
		}

	case Cobol85ParserTO:
		{
			p.SetState(5023)
			p.SendStatementAsync()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(5027)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 750, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5026)
			p.OnExceptionClause()
		}

	}
	p.SetState(5030)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 751, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5029)
			p.NotOnExceptionClause()
		}

	}

	return localctx
}

// ISendStatementSyncContext is an interface to support dynamic dispatch.
type ISendStatementSyncContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSendStatementSyncContext differentiates from other interfaces.
	IsSendStatementSyncContext()
}

type SendStatementSyncContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySendStatementSyncContext() *SendStatementSyncContext {
	var p = new(SendStatementSyncContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sendStatementSync
	return p
}

func (*SendStatementSyncContext) IsSendStatementSyncContext() {}

func NewSendStatementSyncContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SendStatementSyncContext {
	var p = new(SendStatementSyncContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sendStatementSync

	return p
}

func (s *SendStatementSyncContext) GetParser() antlr.Parser { return s.parser }

func (s *SendStatementSyncContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SendStatementSyncContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *SendStatementSyncContext) SendFromPhrase() ISendFromPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISendFromPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISendFromPhraseContext)
}

func (s *SendStatementSyncContext) SendWithPhrase() ISendWithPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISendWithPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISendWithPhraseContext)
}

func (s *SendStatementSyncContext) SendReplacingPhrase() ISendReplacingPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISendReplacingPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISendReplacingPhraseContext)
}

func (s *SendStatementSyncContext) SendAdvancingPhrase() ISendAdvancingPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISendAdvancingPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISendAdvancingPhraseContext)
}

func (s *SendStatementSyncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SendStatementSyncContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SendStatementSyncContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSendStatementSync(s)
	}
}

func (s *SendStatementSyncContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSendStatementSync(s)
	}
}

func (p *Cobol85Parser) SendStatementSync() (localctx ISendStatementSyncContext) {
	localctx = NewSendStatementSyncContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 870, Cobol85ParserRULE_sendStatementSync)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5034)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 752, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(5032)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(5033)
			p.Literal()
		}

	}
	p.SetState(5037)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFROM {
		{
			p.SetState(5036)
			p.SendFromPhrase()
		}

	}
	p.SetState(5040)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 754, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5039)
			p.SendWithPhrase()
		}

	}
	p.SetState(5043)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserREPLACING {
		{
			p.SetState(5042)
			p.SendReplacingPhrase()
		}

	}
	p.SetState(5046)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserAFTER || _la == Cobol85ParserBEFORE {
		{
			p.SetState(5045)
			p.SendAdvancingPhrase()
		}

	}

	return localctx
}

// ISendStatementAsyncContext is an interface to support dynamic dispatch.
type ISendStatementAsyncContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSendStatementAsyncContext differentiates from other interfaces.
	IsSendStatementAsyncContext()
}

type SendStatementAsyncContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySendStatementAsyncContext() *SendStatementAsyncContext {
	var p = new(SendStatementAsyncContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sendStatementAsync
	return p
}

func (*SendStatementAsyncContext) IsSendStatementAsyncContext() {}

func NewSendStatementAsyncContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SendStatementAsyncContext {
	var p = new(SendStatementAsyncContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sendStatementAsync

	return p
}

func (s *SendStatementAsyncContext) GetParser() antlr.Parser { return s.parser }

func (s *SendStatementAsyncContext) TO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTO, 0)
}

func (s *SendStatementAsyncContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SendStatementAsyncContext) TOP() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTOP, 0)
}

func (s *SendStatementAsyncContext) BOTTOM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBOTTOM, 0)
}

func (s *SendStatementAsyncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SendStatementAsyncContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SendStatementAsyncContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSendStatementAsync(s)
	}
}

func (s *SendStatementAsyncContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSendStatementAsync(s)
	}
}

func (p *Cobol85Parser) SendStatementAsync() (localctx ISendStatementAsyncContext) {
	localctx = NewSendStatementAsyncContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 872, Cobol85ParserRULE_sendStatementAsync)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5048)
		p.Match(Cobol85ParserTO)
	}
	{
		p.SetState(5049)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserBOTTOM || _la == Cobol85ParserTOP) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(5050)
		p.Identifier()
	}

	return localctx
}

// ISendFromPhraseContext is an interface to support dynamic dispatch.
type ISendFromPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSendFromPhraseContext differentiates from other interfaces.
	IsSendFromPhraseContext()
}

type SendFromPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySendFromPhraseContext() *SendFromPhraseContext {
	var p = new(SendFromPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sendFromPhrase
	return p
}

func (*SendFromPhraseContext) IsSendFromPhraseContext() {}

func NewSendFromPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SendFromPhraseContext {
	var p = new(SendFromPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sendFromPhrase

	return p
}

func (s *SendFromPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *SendFromPhraseContext) FROM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFROM, 0)
}

func (s *SendFromPhraseContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SendFromPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SendFromPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SendFromPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSendFromPhrase(s)
	}
}

func (s *SendFromPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSendFromPhrase(s)
	}
}

func (p *Cobol85Parser) SendFromPhrase() (localctx ISendFromPhraseContext) {
	localctx = NewSendFromPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 874, Cobol85ParserRULE_sendFromPhrase)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5052)
		p.Match(Cobol85ParserFROM)
	}
	{
		p.SetState(5053)
		p.Identifier()
	}

	return localctx
}

// ISendWithPhraseContext is an interface to support dynamic dispatch.
type ISendWithPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSendWithPhraseContext differentiates from other interfaces.
	IsSendWithPhraseContext()
}

type SendWithPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySendWithPhraseContext() *SendWithPhraseContext {
	var p = new(SendWithPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sendWithPhrase
	return p
}

func (*SendWithPhraseContext) IsSendWithPhraseContext() {}

func NewSendWithPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SendWithPhraseContext {
	var p = new(SendWithPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sendWithPhrase

	return p
}

func (s *SendWithPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *SendWithPhraseContext) WITH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWITH, 0)
}

func (s *SendWithPhraseContext) EGI() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEGI, 0)
}

func (s *SendWithPhraseContext) EMI() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEMI, 0)
}

func (s *SendWithPhraseContext) ESI() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserESI, 0)
}

func (s *SendWithPhraseContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SendWithPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SendWithPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SendWithPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSendWithPhrase(s)
	}
}

func (s *SendWithPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSendWithPhrase(s)
	}
}

func (p *Cobol85Parser) SendWithPhrase() (localctx ISendWithPhraseContext) {
	localctx = NewSendWithPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 876, Cobol85ParserRULE_sendWithPhrase)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5055)
		p.Match(Cobol85ParserWITH)
	}
	p.SetState(5060)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserEGI:
		{
			p.SetState(5056)
			p.Match(Cobol85ParserEGI)
		}

	case Cobol85ParserEMI:
		{
			p.SetState(5057)
			p.Match(Cobol85ParserEMI)
		}

	case Cobol85ParserESI:
		{
			p.SetState(5058)
			p.Match(Cobol85ParserESI)
		}

	case Cobol85ParserABORT, Cobol85ParserADDRESS, Cobol85ParserAS, Cobol85ParserASCII, Cobol85ParserASSOCIATED_DATA, Cobol85ParserASSOCIATED_DATA_LENGTH, Cobol85ParserATTRIBUTE, Cobol85ParserAUTO, Cobol85ParserAUTO_SKIP, Cobol85ParserBACKGROUND_COLOR, Cobol85ParserBACKGROUND_COLOUR, Cobol85ParserBEEP, Cobol85ParserBELL, Cobol85ParserBINARY, Cobol85ParserBIT, Cobol85ParserBLINK, Cobol85ParserBOUNDS, Cobol85ParserCAPABLE, Cobol85ParserCCSVERSION, Cobol85ParserCHANGED, Cobol85ParserCHANNEL, Cobol85ParserCLOSE_DISPOSITION, Cobol85ParserCOBOL, Cobol85ParserCOMMITMENT, Cobol85ParserCONTROL_POINT, Cobol85ParserCONVENTION, Cobol85ParserCRUNCH, Cobol85ParserCURSOR, Cobol85ParserDATE, Cobol85ParserDAY, Cobol85ParserDAY_OF_WEEK, Cobol85ParserDEBUG_CONTENTS, Cobol85ParserDEBUG_ITEM, Cobol85ParserDEBUG_LINE, Cobol85ParserDEBUG_NAME, Cobol85ParserDEBUG_SUB_1, Cobol85ParserDEBUG_SUB_2, Cobol85ParserDEBUG_SUB_3, Cobol85ParserDEFAULT, Cobol85ParserDEFAULT_DISPLAY, Cobol85ParserDEFINITION, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserDISK, Cobol85ParserDONTCARE, Cobol85ParserDOUBLE, Cobol85ParserEBCDIC, Cobol85ParserEMPTY_CHECK, Cobol85ParserENTER, Cobol85ParserENTRY_PROCEDURE, Cobol85ParserERASE, Cobol85ParserEOL, Cobol85ParserEOS, Cobol85ParserESCAPE, Cobol85ParserEVENT, Cobol85ParserEXCLUSIVE, Cobol85ParserEXPORT, Cobol85ParserEXTENDED, Cobol85ParserFOREGROUND_COLOR, Cobol85ParserFOREGROUND_COLOUR, Cobol85ParserFULL, Cobol85ParserFUNCTION, Cobol85ParserFUNCTIONNAME, Cobol85ParserFUNCTION_POINTER, Cobol85ParserGRID, Cobol85ParserHIGHLIGHT, Cobol85ParserIMPLICIT, Cobol85ParserIMPORT, Cobol85ParserINTEGER, Cobol85ParserKEPT, Cobol85ParserKEYBOARD, Cobol85ParserLANGUAGE, Cobol85ParserLB, Cobol85ParserLD, Cobol85ParserLEFTLINE, Cobol85ParserLENGTH, Cobol85ParserLENGTH_CHECK, Cobol85ParserLIBACCESS, Cobol85ParserLIBPARAMETER, Cobol85ParserLIBRARY, Cobol85ParserLINAGE_COUNTER, Cobol85ParserLINE_COUNTER, Cobol85ParserLIST, Cobol85ParserLOCAL, Cobol85ParserLONG_DATE, Cobol85ParserLONG_TIME, Cobol85ParserLOWER, Cobol85ParserLOWLIGHT, Cobol85ParserMMDDYYYY, Cobol85ParserNAMED, Cobol85ParserNATIONAL, Cobol85ParserNATIONAL_EDITED, Cobol85ParserNETWORK, Cobol85ParserNO_ECHO, Cobol85ParserNUMERIC_DATE, Cobol85ParserNUMERIC_TIME, Cobol85ParserODT, Cobol85ParserORDERLY, Cobol85ParserOVERLINE, Cobol85ParserOWN, Cobol85ParserPAGE_COUNTER, Cobol85ParserPASSWORD, Cobol85ParserPORT, Cobol85ParserPRINTER, Cobol85ParserPRIVATE, Cobol85ParserPROCESS, Cobol85ParserPROGRAM, Cobol85ParserPROMPT, Cobol85ParserREADER, Cobol85ParserREMOTE, Cobol85ParserREAL, Cobol85ParserRECEIVED, Cobol85ParserRECURSIVE, Cobol85ParserREF, Cobol85ParserREMOVE, Cobol85ParserREQUIRED, Cobol85ParserREVERSE_VIDEO, Cobol85ParserRETURN_CODE, Cobol85ParserSAVE, Cobol85ParserSECURE, Cobol85ParserSHARED, Cobol85ParserSHAREDBYALL, Cobol85ParserSHAREDBYRUNUNIT, Cobol85ParserSHARING, Cobol85ParserSHIFT_IN, Cobol85ParserSHIFT_OUT, Cobol85ParserSHORT_DATE, Cobol85ParserSORT_CONTROL, Cobol85ParserSORT_CORE_SIZE, Cobol85ParserSORT_FILE_SIZE, Cobol85ParserSORT_MESSAGE, Cobol85ParserSORT_MODE_SIZE, Cobol85ParserSORT_RETURN, Cobol85ParserSYMBOL, Cobol85ParserTALLY, Cobol85ParserTASK, Cobol85ParserTHREAD, Cobol85ParserTHREAD_LOCAL, Cobol85ParserTIME, Cobol85ParserTIMER, Cobol85ParserTODAYS_DATE, Cobol85ParserTODAYS_NAME, Cobol85ParserTRUNCATED, Cobol85ParserTYPEDEF, Cobol85ParserUNDERLINE, Cobol85ParserVIRTUAL, Cobol85ParserWAIT, Cobol85ParserWHEN_COMPILED, Cobol85ParserYEAR, Cobol85ParserYYYYMMDD, Cobol85ParserYYYYDDD, Cobol85ParserZERO_FILL, Cobol85ParserLEVEL_NUMBER_66, Cobol85ParserLEVEL_NUMBER_77, Cobol85ParserLEVEL_NUMBER_88, Cobol85ParserINTEGERLITERAL, Cobol85ParserIDENTIFIER:
		{
			p.SetState(5059)
			p.Identifier()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISendReplacingPhraseContext is an interface to support dynamic dispatch.
type ISendReplacingPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSendReplacingPhraseContext differentiates from other interfaces.
	IsSendReplacingPhraseContext()
}

type SendReplacingPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySendReplacingPhraseContext() *SendReplacingPhraseContext {
	var p = new(SendReplacingPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sendReplacingPhrase
	return p
}

func (*SendReplacingPhraseContext) IsSendReplacingPhraseContext() {}

func NewSendReplacingPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SendReplacingPhraseContext {
	var p = new(SendReplacingPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sendReplacingPhrase

	return p
}

func (s *SendReplacingPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *SendReplacingPhraseContext) REPLACING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREPLACING, 0)
}

func (s *SendReplacingPhraseContext) LINE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLINE, 0)
}

func (s *SendReplacingPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SendReplacingPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SendReplacingPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSendReplacingPhrase(s)
	}
}

func (s *SendReplacingPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSendReplacingPhrase(s)
	}
}

func (p *Cobol85Parser) SendReplacingPhrase() (localctx ISendReplacingPhraseContext) {
	localctx = NewSendReplacingPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 878, Cobol85ParserRULE_sendReplacingPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5062)
		p.Match(Cobol85ParserREPLACING)
	}
	p.SetState(5064)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserLINE {
		{
			p.SetState(5063)
			p.Match(Cobol85ParserLINE)
		}

	}

	return localctx
}

// ISendAdvancingPhraseContext is an interface to support dynamic dispatch.
type ISendAdvancingPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSendAdvancingPhraseContext differentiates from other interfaces.
	IsSendAdvancingPhraseContext()
}

type SendAdvancingPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySendAdvancingPhraseContext() *SendAdvancingPhraseContext {
	var p = new(SendAdvancingPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sendAdvancingPhrase
	return p
}

func (*SendAdvancingPhraseContext) IsSendAdvancingPhraseContext() {}

func NewSendAdvancingPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SendAdvancingPhraseContext {
	var p = new(SendAdvancingPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sendAdvancingPhrase

	return p
}

func (s *SendAdvancingPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *SendAdvancingPhraseContext) BEFORE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBEFORE, 0)
}

func (s *SendAdvancingPhraseContext) AFTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAFTER, 0)
}

func (s *SendAdvancingPhraseContext) SendAdvancingPage() ISendAdvancingPageContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISendAdvancingPageContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISendAdvancingPageContext)
}

func (s *SendAdvancingPhraseContext) SendAdvancingLines() ISendAdvancingLinesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISendAdvancingLinesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISendAdvancingLinesContext)
}

func (s *SendAdvancingPhraseContext) SendAdvancingMnemonic() ISendAdvancingMnemonicContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISendAdvancingMnemonicContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISendAdvancingMnemonicContext)
}

func (s *SendAdvancingPhraseContext) ADVANCING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserADVANCING, 0)
}

func (s *SendAdvancingPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SendAdvancingPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SendAdvancingPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSendAdvancingPhrase(s)
	}
}

func (s *SendAdvancingPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSendAdvancingPhrase(s)
	}
}

func (p *Cobol85Parser) SendAdvancingPhrase() (localctx ISendAdvancingPhraseContext) {
	localctx = NewSendAdvancingPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 880, Cobol85ParserRULE_sendAdvancingPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5066)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserAFTER || _la == Cobol85ParserBEFORE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(5068)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserADVANCING {
		{
			p.SetState(5067)
			p.Match(Cobol85ParserADVANCING)
		}

	}
	p.SetState(5073)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 760, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(5070)
			p.SendAdvancingPage()
		}

	case 2:
		{
			p.SetState(5071)
			p.SendAdvancingLines()
		}

	case 3:
		{
			p.SetState(5072)
			p.SendAdvancingMnemonic()
		}

	}

	return localctx
}

// ISendAdvancingPageContext is an interface to support dynamic dispatch.
type ISendAdvancingPageContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSendAdvancingPageContext differentiates from other interfaces.
	IsSendAdvancingPageContext()
}

type SendAdvancingPageContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySendAdvancingPageContext() *SendAdvancingPageContext {
	var p = new(SendAdvancingPageContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sendAdvancingPage
	return p
}

func (*SendAdvancingPageContext) IsSendAdvancingPageContext() {}

func NewSendAdvancingPageContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SendAdvancingPageContext {
	var p = new(SendAdvancingPageContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sendAdvancingPage

	return p
}

func (s *SendAdvancingPageContext) GetParser() antlr.Parser { return s.parser }

func (s *SendAdvancingPageContext) PAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPAGE, 0)
}

func (s *SendAdvancingPageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SendAdvancingPageContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SendAdvancingPageContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSendAdvancingPage(s)
	}
}

func (s *SendAdvancingPageContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSendAdvancingPage(s)
	}
}

func (p *Cobol85Parser) SendAdvancingPage() (localctx ISendAdvancingPageContext) {
	localctx = NewSendAdvancingPageContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 882, Cobol85ParserRULE_sendAdvancingPage)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5075)
		p.Match(Cobol85ParserPAGE)
	}

	return localctx
}

// ISendAdvancingLinesContext is an interface to support dynamic dispatch.
type ISendAdvancingLinesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSendAdvancingLinesContext differentiates from other interfaces.
	IsSendAdvancingLinesContext()
}

type SendAdvancingLinesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySendAdvancingLinesContext() *SendAdvancingLinesContext {
	var p = new(SendAdvancingLinesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sendAdvancingLines
	return p
}

func (*SendAdvancingLinesContext) IsSendAdvancingLinesContext() {}

func NewSendAdvancingLinesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SendAdvancingLinesContext {
	var p = new(SendAdvancingLinesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sendAdvancingLines

	return p
}

func (s *SendAdvancingLinesContext) GetParser() antlr.Parser { return s.parser }

func (s *SendAdvancingLinesContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SendAdvancingLinesContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *SendAdvancingLinesContext) LINE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLINE, 0)
}

func (s *SendAdvancingLinesContext) LINES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLINES, 0)
}

func (s *SendAdvancingLinesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SendAdvancingLinesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SendAdvancingLinesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSendAdvancingLines(s)
	}
}

func (s *SendAdvancingLinesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSendAdvancingLines(s)
	}
}

func (p *Cobol85Parser) SendAdvancingLines() (localctx ISendAdvancingLinesContext) {
	localctx = NewSendAdvancingLinesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 884, Cobol85ParserRULE_sendAdvancingLines)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5079)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 761, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(5077)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(5078)
			p.Literal()
		}

	}
	p.SetState(5082)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserLINE || _la == Cobol85ParserLINES {
		{
			p.SetState(5081)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85ParserLINE || _la == Cobol85ParserLINES) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

	return localctx
}

// ISendAdvancingMnemonicContext is an interface to support dynamic dispatch.
type ISendAdvancingMnemonicContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSendAdvancingMnemonicContext differentiates from other interfaces.
	IsSendAdvancingMnemonicContext()
}

type SendAdvancingMnemonicContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySendAdvancingMnemonicContext() *SendAdvancingMnemonicContext {
	var p = new(SendAdvancingMnemonicContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sendAdvancingMnemonic
	return p
}

func (*SendAdvancingMnemonicContext) IsSendAdvancingMnemonicContext() {}

func NewSendAdvancingMnemonicContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SendAdvancingMnemonicContext {
	var p = new(SendAdvancingMnemonicContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sendAdvancingMnemonic

	return p
}

func (s *SendAdvancingMnemonicContext) GetParser() antlr.Parser { return s.parser }

func (s *SendAdvancingMnemonicContext) MnemonicName() IMnemonicNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMnemonicNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMnemonicNameContext)
}

func (s *SendAdvancingMnemonicContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SendAdvancingMnemonicContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SendAdvancingMnemonicContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSendAdvancingMnemonic(s)
	}
}

func (s *SendAdvancingMnemonicContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSendAdvancingMnemonic(s)
	}
}

func (p *Cobol85Parser) SendAdvancingMnemonic() (localctx ISendAdvancingMnemonicContext) {
	localctx = NewSendAdvancingMnemonicContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 886, Cobol85ParserRULE_sendAdvancingMnemonic)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5084)
		p.MnemonicName()
	}

	return localctx
}

// ISetStatementContext is an interface to support dynamic dispatch.
type ISetStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSetStatementContext differentiates from other interfaces.
	IsSetStatementContext()
}

type SetStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetStatementContext() *SetStatementContext {
	var p = new(SetStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_setStatement
	return p
}

func (*SetStatementContext) IsSetStatementContext() {}

func NewSetStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetStatementContext {
	var p = new(SetStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_setStatement

	return p
}

func (s *SetStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SetStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSET, 0)
}

func (s *SetStatementContext) SetUpDownByStatement() ISetUpDownByStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetUpDownByStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISetUpDownByStatementContext)
}

func (s *SetStatementContext) AllSetToStatement() []ISetToStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISetToStatementContext)(nil)).Elem())
	var tst = make([]ISetToStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISetToStatementContext)
		}
	}

	return tst
}

func (s *SetStatementContext) SetToStatement(i int) ISetToStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetToStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISetToStatementContext)
}

func (s *SetStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSetStatement(s)
	}
}

func (s *SetStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSetStatement(s)
	}
}

func (p *Cobol85Parser) SetStatement() (localctx ISetStatementContext) {
	localctx = NewSetStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 888, Cobol85ParserRULE_setStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5086)
		p.Match(Cobol85ParserSET)
	}
	p.SetState(5093)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 764, p.GetParserRuleContext()) {
	case 1:
		p.SetState(5088)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserADDRESS)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH)|(1<<Cobol85ParserATTRIBUTE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBINARY-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-68))|(1<<(Cobol85ParserCOBOL-68))|(1<<(Cobol85ParserCOMMITMENT-68))|(1<<(Cobol85ParserCONTROL_POINT-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(Cobol85ParserCONVENTION-100))|(1<<(Cobol85ParserCRUNCH-100))|(1<<(Cobol85ParserCURSOR-100))|(1<<(Cobol85ParserDATE-100))|(1<<(Cobol85ParserDAY-100))|(1<<(Cobol85ParserDAY_OF_WEEK-100))|(1<<(Cobol85ParserDEBUG_CONTENTS-100))|(1<<(Cobol85ParserDEBUG_ITEM-100))|(1<<(Cobol85ParserDEBUG_LINE-100))|(1<<(Cobol85ParserDEBUG_NAME-100))|(1<<(Cobol85ParserDEBUG_SUB_1-100))|(1<<(Cobol85ParserDEBUG_SUB_2-100))|(1<<(Cobol85ParserDEBUG_SUB_3-100))|(1<<(Cobol85ParserDEFAULT-100))|(1<<(Cobol85ParserDEFAULT_DISPLAY-100))|(1<<(Cobol85ParserDEFINITION-100)))) != 0) || (((_la-138)&-(0x1f+1)) == 0 && ((1<<uint((_la-138)))&((1<<(Cobol85ParserDFHRESP-138))|(1<<(Cobol85ParserDFHVALUE-138))|(1<<(Cobol85ParserDISK-138))|(1<<(Cobol85ParserDONTCARE-138))|(1<<(Cobol85ParserDOUBLE-138))|(1<<(Cobol85ParserEBCDIC-138))|(1<<(Cobol85ParserEMPTY_CHECK-138)))) != 0) || (((_la-181)&-(0x1f+1)) == 0 && ((1<<uint((_la-181)))&((1<<(Cobol85ParserENTER-181))|(1<<(Cobol85ParserENTRY_PROCEDURE-181))|(1<<(Cobol85ParserERASE-181))|(1<<(Cobol85ParserEOL-181))|(1<<(Cobol85ParserEOS-181))|(1<<(Cobol85ParserESCAPE-181))|(1<<(Cobol85ParserEVENT-181))|(1<<(Cobol85ParserEXCLUSIVE-181))|(1<<(Cobol85ParserEXPORT-181))|(1<<(Cobol85ParserEXTENDED-181)))) != 0) || (((_la-213)&-(0x1f+1)) == 0 && ((1<<uint((_la-213)))&((1<<(Cobol85ParserFOREGROUND_COLOR-213))|(1<<(Cobol85ParserFOREGROUND_COLOUR-213))|(1<<(Cobol85ParserFULL-213))|(1<<(Cobol85ParserFUNCTION-213))|(1<<(Cobol85ParserFUNCTIONNAME-213))|(1<<(Cobol85ParserFUNCTION_POINTER-213))|(1<<(Cobol85ParserGRID-213))|(1<<(Cobol85ParserHIGHLIGHT-213))|(1<<(Cobol85ParserIMPLICIT-213))|(1<<(Cobol85ParserIMPORT-213)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(Cobol85ParserINTEGER-250))|(1<<(Cobol85ParserKEPT-250))|(1<<(Cobol85ParserKEYBOARD-250))|(1<<(Cobol85ParserLANGUAGE-250))|(1<<(Cobol85ParserLB-250))|(1<<(Cobol85ParserLD-250))|(1<<(Cobol85ParserLEFTLINE-250))|(1<<(Cobol85ParserLENGTH-250))|(1<<(Cobol85ParserLENGTH_CHECK-250))|(1<<(Cobol85ParserLIBACCESS-250))|(1<<(Cobol85ParserLIBPARAMETER-250))|(1<<(Cobol85ParserLIBRARY-250))|(1<<(Cobol85ParserLINAGE_COUNTER-250))|(1<<(Cobol85ParserLINE_COUNTER-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(Cobol85ParserLIST-283))|(1<<(Cobol85ParserLOCAL-283))|(1<<(Cobol85ParserLONG_DATE-283))|(1<<(Cobol85ParserLONG_TIME-283))|(1<<(Cobol85ParserLOWER-283))|(1<<(Cobol85ParserLOWLIGHT-283))|(1<<(Cobol85ParserMMDDYYYY-283))|(1<<(Cobol85ParserNAMED-283))|(1<<(Cobol85ParserNATIONAL-283))|(1<<(Cobol85ParserNATIONAL_EDITED-283))|(1<<(Cobol85ParserNETWORK-283))|(1<<(Cobol85ParserNO_ECHO-283)))) != 0) || (((_la-317)&-(0x1f+1)) == 0 && ((1<<uint((_la-317)))&((1<<(Cobol85ParserNUMERIC_DATE-317))|(1<<(Cobol85ParserNUMERIC_TIME-317))|(1<<(Cobol85ParserODT-317))|(1<<(Cobol85ParserORDERLY-317))|(1<<(Cobol85ParserOVERLINE-317))|(1<<(Cobol85ParserOWN-317))|(1<<(Cobol85ParserPAGE_COUNTER-317))|(1<<(Cobol85ParserPASSWORD-317)))) != 0) || (((_la-352)&-(0x1f+1)) == 0 && ((1<<uint((_la-352)))&((1<<(Cobol85ParserPORT-352))|(1<<(Cobol85ParserPRINTER-352))|(1<<(Cobol85ParserPRIVATE-352))|(1<<(Cobol85ParserPROCESS-352))|(1<<(Cobol85ParserPROGRAM-352))|(1<<(Cobol85ParserPROMPT-352))|(1<<(Cobol85ParserREADER-352))|(1<<(Cobol85ParserREMOTE-352))|(1<<(Cobol85ParserREAL-352))|(1<<(Cobol85ParserRECEIVED-352))|(1<<(Cobol85ParserRECURSIVE-352))|(1<<(Cobol85ParserREF-352)))) != 0) || (((_la-391)&-(0x1f+1)) == 0 && ((1<<uint((_la-391)))&((1<<(Cobol85ParserREMOVE-391))|(1<<(Cobol85ParserREQUIRED-391))|(1<<(Cobol85ParserREVERSE_VIDEO-391))|(1<<(Cobol85ParserRETURN_CODE-391))|(1<<(Cobol85ParserSAVE-391))|(1<<(Cobol85ParserSECURE-391)))) != 0) || (((_la-431)&-(0x1f+1)) == 0 && ((1<<uint((_la-431)))&((1<<(Cobol85ParserSHARED-431))|(1<<(Cobol85ParserSHAREDBYALL-431))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-431))|(1<<(Cobol85ParserSHARING-431))|(1<<(Cobol85ParserSHIFT_IN-431))|(1<<(Cobol85ParserSHIFT_OUT-431))|(1<<(Cobol85ParserSHORT_DATE-431))|(1<<(Cobol85ParserSORT_CONTROL-431))|(1<<(Cobol85ParserSORT_CORE_SIZE-431))|(1<<(Cobol85ParserSORT_FILE_SIZE-431))|(1<<(Cobol85ParserSORT_MESSAGE-431))|(1<<(Cobol85ParserSORT_MODE_SIZE-431))|(1<<(Cobol85ParserSORT_RETURN-431)))) != 0) || (((_la-466)&-(0x1f+1)) == 0 && ((1<<uint((_la-466)))&((1<<(Cobol85ParserSYMBOL-466))|(1<<(Cobol85ParserTALLY-466))|(1<<(Cobol85ParserTASK-466))|(1<<(Cobol85ParserTHREAD-466))|(1<<(Cobol85ParserTHREAD_LOCAL-466))|(1<<(Cobol85ParserTIME-466))|(1<<(Cobol85ParserTIMER-466))|(1<<(Cobol85ParserTODAYS_DATE-466))|(1<<(Cobol85ParserTODAYS_NAME-466))|(1<<(Cobol85ParserTRUNCATED-466))|(1<<(Cobol85ParserTYPEDEF-466)))) != 0) || (((_la-498)&-(0x1f+1)) == 0 && ((1<<uint((_la-498)))&((1<<(Cobol85ParserUNDERLINE-498))|(1<<(Cobol85ParserVIRTUAL-498))|(1<<(Cobol85ParserWAIT-498))|(1<<(Cobol85ParserWHEN_COMPILED-498))|(1<<(Cobol85ParserYEAR-498))|(1<<(Cobol85ParserYYYYMMDD-498))|(1<<(Cobol85ParserYYYYDDD-498))|(1<<(Cobol85ParserZERO_FILL-498)))) != 0) || (((_la-552)&-(0x1f+1)) == 0 && ((1<<uint((_la-552)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-552))|(1<<(Cobol85ParserLEVEL_NUMBER_77-552))|(1<<(Cobol85ParserLEVEL_NUMBER_88-552))|(1<<(Cobol85ParserINTEGERLITERAL-552))|(1<<(Cobol85ParserIDENTIFIER-552)))) != 0) {
			{
				p.SetState(5087)
				p.SetToStatement()
			}

			p.SetState(5090)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		{
			p.SetState(5092)
			p.SetUpDownByStatement()
		}

	}

	return localctx
}

// ISetToStatementContext is an interface to support dynamic dispatch.
type ISetToStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSetToStatementContext differentiates from other interfaces.
	IsSetToStatementContext()
}

type SetToStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetToStatementContext() *SetToStatementContext {
	var p = new(SetToStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_setToStatement
	return p
}

func (*SetToStatementContext) IsSetToStatementContext() {}

func NewSetToStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetToStatementContext {
	var p = new(SetToStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_setToStatement

	return p
}

func (s *SetToStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SetToStatementContext) TO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTO, 0)
}

func (s *SetToStatementContext) AllSetTo() []ISetToContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISetToContext)(nil)).Elem())
	var tst = make([]ISetToContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISetToContext)
		}
	}

	return tst
}

func (s *SetToStatementContext) SetTo(i int) ISetToContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetToContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISetToContext)
}

func (s *SetToStatementContext) AllSetToValue() []ISetToValueContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISetToValueContext)(nil)).Elem())
	var tst = make([]ISetToValueContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISetToValueContext)
		}
	}

	return tst
}

func (s *SetToStatementContext) SetToValue(i int) ISetToValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetToValueContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISetToValueContext)
}

func (s *SetToStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetToStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetToStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSetToStatement(s)
	}
}

func (s *SetToStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSetToStatement(s)
	}
}

func (p *Cobol85Parser) SetToStatement() (localctx ISetToStatementContext) {
	localctx = NewSetToStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 890, Cobol85ParserRULE_setToStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5096)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserADDRESS)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH)|(1<<Cobol85ParserATTRIBUTE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBINARY-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-68))|(1<<(Cobol85ParserCOBOL-68))|(1<<(Cobol85ParserCOMMITMENT-68))|(1<<(Cobol85ParserCONTROL_POINT-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(Cobol85ParserCONVENTION-100))|(1<<(Cobol85ParserCRUNCH-100))|(1<<(Cobol85ParserCURSOR-100))|(1<<(Cobol85ParserDATE-100))|(1<<(Cobol85ParserDAY-100))|(1<<(Cobol85ParserDAY_OF_WEEK-100))|(1<<(Cobol85ParserDEBUG_CONTENTS-100))|(1<<(Cobol85ParserDEBUG_ITEM-100))|(1<<(Cobol85ParserDEBUG_LINE-100))|(1<<(Cobol85ParserDEBUG_NAME-100))|(1<<(Cobol85ParserDEBUG_SUB_1-100))|(1<<(Cobol85ParserDEBUG_SUB_2-100))|(1<<(Cobol85ParserDEBUG_SUB_3-100))|(1<<(Cobol85ParserDEFAULT-100))|(1<<(Cobol85ParserDEFAULT_DISPLAY-100))|(1<<(Cobol85ParserDEFINITION-100)))) != 0) || (((_la-138)&-(0x1f+1)) == 0 && ((1<<uint((_la-138)))&((1<<(Cobol85ParserDFHRESP-138))|(1<<(Cobol85ParserDFHVALUE-138))|(1<<(Cobol85ParserDISK-138))|(1<<(Cobol85ParserDONTCARE-138))|(1<<(Cobol85ParserDOUBLE-138))|(1<<(Cobol85ParserEBCDIC-138))|(1<<(Cobol85ParserEMPTY_CHECK-138)))) != 0) || (((_la-181)&-(0x1f+1)) == 0 && ((1<<uint((_la-181)))&((1<<(Cobol85ParserENTER-181))|(1<<(Cobol85ParserENTRY_PROCEDURE-181))|(1<<(Cobol85ParserERASE-181))|(1<<(Cobol85ParserEOL-181))|(1<<(Cobol85ParserEOS-181))|(1<<(Cobol85ParserESCAPE-181))|(1<<(Cobol85ParserEVENT-181))|(1<<(Cobol85ParserEXCLUSIVE-181))|(1<<(Cobol85ParserEXPORT-181))|(1<<(Cobol85ParserEXTENDED-181)))) != 0) || (((_la-213)&-(0x1f+1)) == 0 && ((1<<uint((_la-213)))&((1<<(Cobol85ParserFOREGROUND_COLOR-213))|(1<<(Cobol85ParserFOREGROUND_COLOUR-213))|(1<<(Cobol85ParserFULL-213))|(1<<(Cobol85ParserFUNCTION-213))|(1<<(Cobol85ParserFUNCTIONNAME-213))|(1<<(Cobol85ParserFUNCTION_POINTER-213))|(1<<(Cobol85ParserGRID-213))|(1<<(Cobol85ParserHIGHLIGHT-213))|(1<<(Cobol85ParserIMPLICIT-213))|(1<<(Cobol85ParserIMPORT-213)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(Cobol85ParserINTEGER-250))|(1<<(Cobol85ParserKEPT-250))|(1<<(Cobol85ParserKEYBOARD-250))|(1<<(Cobol85ParserLANGUAGE-250))|(1<<(Cobol85ParserLB-250))|(1<<(Cobol85ParserLD-250))|(1<<(Cobol85ParserLEFTLINE-250))|(1<<(Cobol85ParserLENGTH-250))|(1<<(Cobol85ParserLENGTH_CHECK-250))|(1<<(Cobol85ParserLIBACCESS-250))|(1<<(Cobol85ParserLIBPARAMETER-250))|(1<<(Cobol85ParserLIBRARY-250))|(1<<(Cobol85ParserLINAGE_COUNTER-250))|(1<<(Cobol85ParserLINE_COUNTER-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(Cobol85ParserLIST-283))|(1<<(Cobol85ParserLOCAL-283))|(1<<(Cobol85ParserLONG_DATE-283))|(1<<(Cobol85ParserLONG_TIME-283))|(1<<(Cobol85ParserLOWER-283))|(1<<(Cobol85ParserLOWLIGHT-283))|(1<<(Cobol85ParserMMDDYYYY-283))|(1<<(Cobol85ParserNAMED-283))|(1<<(Cobol85ParserNATIONAL-283))|(1<<(Cobol85ParserNATIONAL_EDITED-283))|(1<<(Cobol85ParserNETWORK-283))|(1<<(Cobol85ParserNO_ECHO-283)))) != 0) || (((_la-317)&-(0x1f+1)) == 0 && ((1<<uint((_la-317)))&((1<<(Cobol85ParserNUMERIC_DATE-317))|(1<<(Cobol85ParserNUMERIC_TIME-317))|(1<<(Cobol85ParserODT-317))|(1<<(Cobol85ParserORDERLY-317))|(1<<(Cobol85ParserOVERLINE-317))|(1<<(Cobol85ParserOWN-317))|(1<<(Cobol85ParserPAGE_COUNTER-317))|(1<<(Cobol85ParserPASSWORD-317)))) != 0) || (((_la-352)&-(0x1f+1)) == 0 && ((1<<uint((_la-352)))&((1<<(Cobol85ParserPORT-352))|(1<<(Cobol85ParserPRINTER-352))|(1<<(Cobol85ParserPRIVATE-352))|(1<<(Cobol85ParserPROCESS-352))|(1<<(Cobol85ParserPROGRAM-352))|(1<<(Cobol85ParserPROMPT-352))|(1<<(Cobol85ParserREADER-352))|(1<<(Cobol85ParserREMOTE-352))|(1<<(Cobol85ParserREAL-352))|(1<<(Cobol85ParserRECEIVED-352))|(1<<(Cobol85ParserRECURSIVE-352))|(1<<(Cobol85ParserREF-352)))) != 0) || (((_la-391)&-(0x1f+1)) == 0 && ((1<<uint((_la-391)))&((1<<(Cobol85ParserREMOVE-391))|(1<<(Cobol85ParserREQUIRED-391))|(1<<(Cobol85ParserREVERSE_VIDEO-391))|(1<<(Cobol85ParserRETURN_CODE-391))|(1<<(Cobol85ParserSAVE-391))|(1<<(Cobol85ParserSECURE-391)))) != 0) || (((_la-431)&-(0x1f+1)) == 0 && ((1<<uint((_la-431)))&((1<<(Cobol85ParserSHARED-431))|(1<<(Cobol85ParserSHAREDBYALL-431))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-431))|(1<<(Cobol85ParserSHARING-431))|(1<<(Cobol85ParserSHIFT_IN-431))|(1<<(Cobol85ParserSHIFT_OUT-431))|(1<<(Cobol85ParserSHORT_DATE-431))|(1<<(Cobol85ParserSORT_CONTROL-431))|(1<<(Cobol85ParserSORT_CORE_SIZE-431))|(1<<(Cobol85ParserSORT_FILE_SIZE-431))|(1<<(Cobol85ParserSORT_MESSAGE-431))|(1<<(Cobol85ParserSORT_MODE_SIZE-431))|(1<<(Cobol85ParserSORT_RETURN-431)))) != 0) || (((_la-466)&-(0x1f+1)) == 0 && ((1<<uint((_la-466)))&((1<<(Cobol85ParserSYMBOL-466))|(1<<(Cobol85ParserTALLY-466))|(1<<(Cobol85ParserTASK-466))|(1<<(Cobol85ParserTHREAD-466))|(1<<(Cobol85ParserTHREAD_LOCAL-466))|(1<<(Cobol85ParserTIME-466))|(1<<(Cobol85ParserTIMER-466))|(1<<(Cobol85ParserTODAYS_DATE-466))|(1<<(Cobol85ParserTODAYS_NAME-466))|(1<<(Cobol85ParserTRUNCATED-466))|(1<<(Cobol85ParserTYPEDEF-466)))) != 0) || (((_la-498)&-(0x1f+1)) == 0 && ((1<<uint((_la-498)))&((1<<(Cobol85ParserUNDERLINE-498))|(1<<(Cobol85ParserVIRTUAL-498))|(1<<(Cobol85ParserWAIT-498))|(1<<(Cobol85ParserWHEN_COMPILED-498))|(1<<(Cobol85ParserYEAR-498))|(1<<(Cobol85ParserYYYYMMDD-498))|(1<<(Cobol85ParserYYYYDDD-498))|(1<<(Cobol85ParserZERO_FILL-498)))) != 0) || (((_la-552)&-(0x1f+1)) == 0 && ((1<<uint((_la-552)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-552))|(1<<(Cobol85ParserLEVEL_NUMBER_77-552))|(1<<(Cobol85ParserLEVEL_NUMBER_88-552))|(1<<(Cobol85ParserINTEGERLITERAL-552))|(1<<(Cobol85ParserIDENTIFIER-552)))) != 0) {
		{
			p.SetState(5095)
			p.SetTo()
		}

		p.SetState(5098)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(5100)
		p.Match(Cobol85ParserTO)
	}
	p.SetState(5102)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(5101)
				p.SetToValue()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(5104)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 766, p.GetParserRuleContext())
	}

	return localctx
}

// ISetUpDownByStatementContext is an interface to support dynamic dispatch.
type ISetUpDownByStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSetUpDownByStatementContext differentiates from other interfaces.
	IsSetUpDownByStatementContext()
}

type SetUpDownByStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetUpDownByStatementContext() *SetUpDownByStatementContext {
	var p = new(SetUpDownByStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_setUpDownByStatement
	return p
}

func (*SetUpDownByStatementContext) IsSetUpDownByStatementContext() {}

func NewSetUpDownByStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetUpDownByStatementContext {
	var p = new(SetUpDownByStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_setUpDownByStatement

	return p
}

func (s *SetUpDownByStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SetUpDownByStatementContext) SetByValue() ISetByValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetByValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISetByValueContext)
}

func (s *SetUpDownByStatementContext) UP() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserUP, 0)
}

func (s *SetUpDownByStatementContext) BY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBY, 0)
}

func (s *SetUpDownByStatementContext) DOWN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOWN, 0)
}

func (s *SetUpDownByStatementContext) AllSetTo() []ISetToContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISetToContext)(nil)).Elem())
	var tst = make([]ISetToContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISetToContext)
		}
	}

	return tst
}

func (s *SetUpDownByStatementContext) SetTo(i int) ISetToContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetToContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISetToContext)
}

func (s *SetUpDownByStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetUpDownByStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetUpDownByStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSetUpDownByStatement(s)
	}
}

func (s *SetUpDownByStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSetUpDownByStatement(s)
	}
}

func (p *Cobol85Parser) SetUpDownByStatement() (localctx ISetUpDownByStatementContext) {
	localctx = NewSetUpDownByStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 892, Cobol85ParserRULE_setUpDownByStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5107)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserADDRESS)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH)|(1<<Cobol85ParserATTRIBUTE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBINARY-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-68))|(1<<(Cobol85ParserCOBOL-68))|(1<<(Cobol85ParserCOMMITMENT-68))|(1<<(Cobol85ParserCONTROL_POINT-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(Cobol85ParserCONVENTION-100))|(1<<(Cobol85ParserCRUNCH-100))|(1<<(Cobol85ParserCURSOR-100))|(1<<(Cobol85ParserDATE-100))|(1<<(Cobol85ParserDAY-100))|(1<<(Cobol85ParserDAY_OF_WEEK-100))|(1<<(Cobol85ParserDEBUG_CONTENTS-100))|(1<<(Cobol85ParserDEBUG_ITEM-100))|(1<<(Cobol85ParserDEBUG_LINE-100))|(1<<(Cobol85ParserDEBUG_NAME-100))|(1<<(Cobol85ParserDEBUG_SUB_1-100))|(1<<(Cobol85ParserDEBUG_SUB_2-100))|(1<<(Cobol85ParserDEBUG_SUB_3-100))|(1<<(Cobol85ParserDEFAULT-100))|(1<<(Cobol85ParserDEFAULT_DISPLAY-100))|(1<<(Cobol85ParserDEFINITION-100)))) != 0) || (((_la-138)&-(0x1f+1)) == 0 && ((1<<uint((_la-138)))&((1<<(Cobol85ParserDFHRESP-138))|(1<<(Cobol85ParserDFHVALUE-138))|(1<<(Cobol85ParserDISK-138))|(1<<(Cobol85ParserDONTCARE-138))|(1<<(Cobol85ParserDOUBLE-138))|(1<<(Cobol85ParserEBCDIC-138))|(1<<(Cobol85ParserEMPTY_CHECK-138)))) != 0) || (((_la-181)&-(0x1f+1)) == 0 && ((1<<uint((_la-181)))&((1<<(Cobol85ParserENTER-181))|(1<<(Cobol85ParserENTRY_PROCEDURE-181))|(1<<(Cobol85ParserERASE-181))|(1<<(Cobol85ParserEOL-181))|(1<<(Cobol85ParserEOS-181))|(1<<(Cobol85ParserESCAPE-181))|(1<<(Cobol85ParserEVENT-181))|(1<<(Cobol85ParserEXCLUSIVE-181))|(1<<(Cobol85ParserEXPORT-181))|(1<<(Cobol85ParserEXTENDED-181)))) != 0) || (((_la-213)&-(0x1f+1)) == 0 && ((1<<uint((_la-213)))&((1<<(Cobol85ParserFOREGROUND_COLOR-213))|(1<<(Cobol85ParserFOREGROUND_COLOUR-213))|(1<<(Cobol85ParserFULL-213))|(1<<(Cobol85ParserFUNCTION-213))|(1<<(Cobol85ParserFUNCTIONNAME-213))|(1<<(Cobol85ParserFUNCTION_POINTER-213))|(1<<(Cobol85ParserGRID-213))|(1<<(Cobol85ParserHIGHLIGHT-213))|(1<<(Cobol85ParserIMPLICIT-213))|(1<<(Cobol85ParserIMPORT-213)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(Cobol85ParserINTEGER-250))|(1<<(Cobol85ParserKEPT-250))|(1<<(Cobol85ParserKEYBOARD-250))|(1<<(Cobol85ParserLANGUAGE-250))|(1<<(Cobol85ParserLB-250))|(1<<(Cobol85ParserLD-250))|(1<<(Cobol85ParserLEFTLINE-250))|(1<<(Cobol85ParserLENGTH-250))|(1<<(Cobol85ParserLENGTH_CHECK-250))|(1<<(Cobol85ParserLIBACCESS-250))|(1<<(Cobol85ParserLIBPARAMETER-250))|(1<<(Cobol85ParserLIBRARY-250))|(1<<(Cobol85ParserLINAGE_COUNTER-250))|(1<<(Cobol85ParserLINE_COUNTER-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(Cobol85ParserLIST-283))|(1<<(Cobol85ParserLOCAL-283))|(1<<(Cobol85ParserLONG_DATE-283))|(1<<(Cobol85ParserLONG_TIME-283))|(1<<(Cobol85ParserLOWER-283))|(1<<(Cobol85ParserLOWLIGHT-283))|(1<<(Cobol85ParserMMDDYYYY-283))|(1<<(Cobol85ParserNAMED-283))|(1<<(Cobol85ParserNATIONAL-283))|(1<<(Cobol85ParserNATIONAL_EDITED-283))|(1<<(Cobol85ParserNETWORK-283))|(1<<(Cobol85ParserNO_ECHO-283)))) != 0) || (((_la-317)&-(0x1f+1)) == 0 && ((1<<uint((_la-317)))&((1<<(Cobol85ParserNUMERIC_DATE-317))|(1<<(Cobol85ParserNUMERIC_TIME-317))|(1<<(Cobol85ParserODT-317))|(1<<(Cobol85ParserORDERLY-317))|(1<<(Cobol85ParserOVERLINE-317))|(1<<(Cobol85ParserOWN-317))|(1<<(Cobol85ParserPAGE_COUNTER-317))|(1<<(Cobol85ParserPASSWORD-317)))) != 0) || (((_la-352)&-(0x1f+1)) == 0 && ((1<<uint((_la-352)))&((1<<(Cobol85ParserPORT-352))|(1<<(Cobol85ParserPRINTER-352))|(1<<(Cobol85ParserPRIVATE-352))|(1<<(Cobol85ParserPROCESS-352))|(1<<(Cobol85ParserPROGRAM-352))|(1<<(Cobol85ParserPROMPT-352))|(1<<(Cobol85ParserREADER-352))|(1<<(Cobol85ParserREMOTE-352))|(1<<(Cobol85ParserREAL-352))|(1<<(Cobol85ParserRECEIVED-352))|(1<<(Cobol85ParserRECURSIVE-352))|(1<<(Cobol85ParserREF-352)))) != 0) || (((_la-391)&-(0x1f+1)) == 0 && ((1<<uint((_la-391)))&((1<<(Cobol85ParserREMOVE-391))|(1<<(Cobol85ParserREQUIRED-391))|(1<<(Cobol85ParserREVERSE_VIDEO-391))|(1<<(Cobol85ParserRETURN_CODE-391))|(1<<(Cobol85ParserSAVE-391))|(1<<(Cobol85ParserSECURE-391)))) != 0) || (((_la-431)&-(0x1f+1)) == 0 && ((1<<uint((_la-431)))&((1<<(Cobol85ParserSHARED-431))|(1<<(Cobol85ParserSHAREDBYALL-431))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-431))|(1<<(Cobol85ParserSHARING-431))|(1<<(Cobol85ParserSHIFT_IN-431))|(1<<(Cobol85ParserSHIFT_OUT-431))|(1<<(Cobol85ParserSHORT_DATE-431))|(1<<(Cobol85ParserSORT_CONTROL-431))|(1<<(Cobol85ParserSORT_CORE_SIZE-431))|(1<<(Cobol85ParserSORT_FILE_SIZE-431))|(1<<(Cobol85ParserSORT_MESSAGE-431))|(1<<(Cobol85ParserSORT_MODE_SIZE-431))|(1<<(Cobol85ParserSORT_RETURN-431)))) != 0) || (((_la-466)&-(0x1f+1)) == 0 && ((1<<uint((_la-466)))&((1<<(Cobol85ParserSYMBOL-466))|(1<<(Cobol85ParserTALLY-466))|(1<<(Cobol85ParserTASK-466))|(1<<(Cobol85ParserTHREAD-466))|(1<<(Cobol85ParserTHREAD_LOCAL-466))|(1<<(Cobol85ParserTIME-466))|(1<<(Cobol85ParserTIMER-466))|(1<<(Cobol85ParserTODAYS_DATE-466))|(1<<(Cobol85ParserTODAYS_NAME-466))|(1<<(Cobol85ParserTRUNCATED-466))|(1<<(Cobol85ParserTYPEDEF-466)))) != 0) || (((_la-498)&-(0x1f+1)) == 0 && ((1<<uint((_la-498)))&((1<<(Cobol85ParserUNDERLINE-498))|(1<<(Cobol85ParserVIRTUAL-498))|(1<<(Cobol85ParserWAIT-498))|(1<<(Cobol85ParserWHEN_COMPILED-498))|(1<<(Cobol85ParserYEAR-498))|(1<<(Cobol85ParserYYYYMMDD-498))|(1<<(Cobol85ParserYYYYDDD-498))|(1<<(Cobol85ParserZERO_FILL-498)))) != 0) || (((_la-552)&-(0x1f+1)) == 0 && ((1<<uint((_la-552)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-552))|(1<<(Cobol85ParserLEVEL_NUMBER_77-552))|(1<<(Cobol85ParserLEVEL_NUMBER_88-552))|(1<<(Cobol85ParserINTEGERLITERAL-552))|(1<<(Cobol85ParserIDENTIFIER-552)))) != 0) {
		{
			p.SetState(5106)
			p.SetTo()
		}

		p.SetState(5109)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(5115)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserUP:
		{
			p.SetState(5111)
			p.Match(Cobol85ParserUP)
		}
		{
			p.SetState(5112)
			p.Match(Cobol85ParserBY)
		}

	case Cobol85ParserDOWN:
		{
			p.SetState(5113)
			p.Match(Cobol85ParserDOWN)
		}
		{
			p.SetState(5114)
			p.Match(Cobol85ParserBY)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(5117)
		p.SetByValue()
	}

	return localctx
}

// ISetToContext is an interface to support dynamic dispatch.
type ISetToContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSetToContext differentiates from other interfaces.
	IsSetToContext()
}

type SetToContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetToContext() *SetToContext {
	var p = new(SetToContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_setTo
	return p
}

func (*SetToContext) IsSetToContext() {}

func NewSetToContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetToContext {
	var p = new(SetToContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_setTo

	return p
}

func (s *SetToContext) GetParser() antlr.Parser { return s.parser }

func (s *SetToContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SetToContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetToContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetToContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSetTo(s)
	}
}

func (s *SetToContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSetTo(s)
	}
}

func (p *Cobol85Parser) SetTo() (localctx ISetToContext) {
	localctx = NewSetToContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 894, Cobol85ParserRULE_setTo)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5119)
		p.Identifier()
	}

	return localctx
}

// ISetToValueContext is an interface to support dynamic dispatch.
type ISetToValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSetToValueContext differentiates from other interfaces.
	IsSetToValueContext()
}

type SetToValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetToValueContext() *SetToValueContext {
	var p = new(SetToValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_setToValue
	return p
}

func (*SetToValueContext) IsSetToValueContext() {}

func NewSetToValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetToValueContext {
	var p = new(SetToValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_setToValue

	return p
}

func (s *SetToValueContext) GetParser() antlr.Parser { return s.parser }

func (s *SetToValueContext) ON() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserON, 0)
}

func (s *SetToValueContext) OFF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOFF, 0)
}

func (s *SetToValueContext) ENTRY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserENTRY, 0)
}

func (s *SetToValueContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SetToValueContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *SetToValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetToValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetToValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSetToValue(s)
	}
}

func (s *SetToValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSetToValue(s)
	}
}

func (p *Cobol85Parser) SetToValue() (localctx ISetToValueContext) {
	localctx = NewSetToValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 896, Cobol85ParserRULE_setToValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5130)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 770, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5121)
			p.Match(Cobol85ParserON)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5122)
			p.Match(Cobol85ParserOFF)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5123)
			p.Match(Cobol85ParserENTRY)
		}
		p.SetState(5126)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 769, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(5124)
				p.Identifier()
			}

		case 2:
			{
				p.SetState(5125)
				p.Literal()
			}

		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5128)
			p.Identifier()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5129)
			p.Literal()
		}

	}

	return localctx
}

// ISetByValueContext is an interface to support dynamic dispatch.
type ISetByValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSetByValueContext differentiates from other interfaces.
	IsSetByValueContext()
}

type SetByValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetByValueContext() *SetByValueContext {
	var p = new(SetByValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_setByValue
	return p
}

func (*SetByValueContext) IsSetByValueContext() {}

func NewSetByValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetByValueContext {
	var p = new(SetByValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_setByValue

	return p
}

func (s *SetByValueContext) GetParser() antlr.Parser { return s.parser }

func (s *SetByValueContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SetByValueContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *SetByValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetByValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetByValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSetByValue(s)
	}
}

func (s *SetByValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSetByValue(s)
	}
}

func (p *Cobol85Parser) SetByValue() (localctx ISetByValueContext) {
	localctx = NewSetByValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 898, Cobol85ParserRULE_setByValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5134)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 771, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5132)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5133)
			p.Literal()
		}

	}

	return localctx
}

// ISortStatementContext is an interface to support dynamic dispatch.
type ISortStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSortStatementContext differentiates from other interfaces.
	IsSortStatementContext()
}

type SortStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySortStatementContext() *SortStatementContext {
	var p = new(SortStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sortStatement
	return p
}

func (*SortStatementContext) IsSortStatementContext() {}

func NewSortStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortStatementContext {
	var p = new(SortStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sortStatement

	return p
}

func (s *SortStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SortStatementContext) SORT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSORT, 0)
}

func (s *SortStatementContext) FileName() IFileNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *SortStatementContext) AllSortOnKeyClause() []ISortOnKeyClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISortOnKeyClauseContext)(nil)).Elem())
	var tst = make([]ISortOnKeyClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISortOnKeyClauseContext)
		}
	}

	return tst
}

func (s *SortStatementContext) SortOnKeyClause(i int) ISortOnKeyClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISortOnKeyClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISortOnKeyClauseContext)
}

func (s *SortStatementContext) SortDuplicatesPhrase() ISortDuplicatesPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISortDuplicatesPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISortDuplicatesPhraseContext)
}

func (s *SortStatementContext) SortCollatingSequencePhrase() ISortCollatingSequencePhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISortCollatingSequencePhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISortCollatingSequencePhraseContext)
}

func (s *SortStatementContext) SortInputProcedurePhrase() ISortInputProcedurePhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISortInputProcedurePhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISortInputProcedurePhraseContext)
}

func (s *SortStatementContext) AllSortUsing() []ISortUsingContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISortUsingContext)(nil)).Elem())
	var tst = make([]ISortUsingContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISortUsingContext)
		}
	}

	return tst
}

func (s *SortStatementContext) SortUsing(i int) ISortUsingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISortUsingContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISortUsingContext)
}

func (s *SortStatementContext) SortOutputProcedurePhrase() ISortOutputProcedurePhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISortOutputProcedurePhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISortOutputProcedurePhraseContext)
}

func (s *SortStatementContext) AllSortGivingPhrase() []ISortGivingPhraseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISortGivingPhraseContext)(nil)).Elem())
	var tst = make([]ISortGivingPhraseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISortGivingPhraseContext)
		}
	}

	return tst
}

func (s *SortStatementContext) SortGivingPhrase(i int) ISortGivingPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISortGivingPhraseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISortGivingPhraseContext)
}

func (s *SortStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSortStatement(s)
	}
}

func (s *SortStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSortStatement(s)
	}
}

func (p *Cobol85Parser) SortStatement() (localctx ISortStatementContext) {
	localctx = NewSortStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 900, Cobol85ParserRULE_sortStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5136)
		p.Match(Cobol85ParserSORT)
	}
	{
		p.SetState(5137)
		p.FileName()
	}
	p.SetState(5139)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(5138)
				p.SortOnKeyClause()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(5141)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 772, p.GetParserRuleContext())
	}
	p.SetState(5144)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 773, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5143)
			p.SortDuplicatesPhrase()
		}

	}
	p.SetState(5147)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCOLLATING || _la == Cobol85ParserSEQUENCE {
		{
			p.SetState(5146)
			p.SortCollatingSequencePhrase()
		}

	}
	p.SetState(5150)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserINPUT {
		{
			p.SetState(5149)
			p.SortInputProcedurePhrase()
		}

	}
	p.SetState(5155)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserUSING {
		{
			p.SetState(5152)
			p.SortUsing()
		}

		p.SetState(5157)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(5159)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserOUTPUT {
		{
			p.SetState(5158)
			p.SortOutputProcedurePhrase()
		}

	}
	p.SetState(5164)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserGIVING {
		{
			p.SetState(5161)
			p.SortGivingPhrase()
		}

		p.SetState(5166)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISortOnKeyClauseContext is an interface to support dynamic dispatch.
type ISortOnKeyClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSortOnKeyClauseContext differentiates from other interfaces.
	IsSortOnKeyClauseContext()
}

type SortOnKeyClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySortOnKeyClauseContext() *SortOnKeyClauseContext {
	var p = new(SortOnKeyClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sortOnKeyClause
	return p
}

func (*SortOnKeyClauseContext) IsSortOnKeyClauseContext() {}

func NewSortOnKeyClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortOnKeyClauseContext {
	var p = new(SortOnKeyClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sortOnKeyClause

	return p
}

func (s *SortOnKeyClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SortOnKeyClauseContext) ASCENDING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserASCENDING, 0)
}

func (s *SortOnKeyClauseContext) DESCENDING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDESCENDING, 0)
}

func (s *SortOnKeyClauseContext) ON() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserON, 0)
}

func (s *SortOnKeyClauseContext) KEY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserKEY, 0)
}

func (s *SortOnKeyClauseContext) AllQualifiedDataName() []IQualifiedDataNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IQualifiedDataNameContext)(nil)).Elem())
	var tst = make([]IQualifiedDataNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IQualifiedDataNameContext)
		}
	}

	return tst
}

func (s *SortOnKeyClauseContext) QualifiedDataName(i int) IQualifiedDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedDataNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *SortOnKeyClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortOnKeyClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortOnKeyClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSortOnKeyClause(s)
	}
}

func (s *SortOnKeyClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSortOnKeyClause(s)
	}
}

func (p *Cobol85Parser) SortOnKeyClause() (localctx ISortOnKeyClauseContext) {
	localctx = NewSortOnKeyClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 902, Cobol85ParserRULE_sortOnKeyClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5168)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserON {
		{
			p.SetState(5167)
			p.Match(Cobol85ParserON)
		}

	}
	{
		p.SetState(5170)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserASCENDING || _la == Cobol85ParserDESCENDING) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(5172)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserKEY {
		{
			p.SetState(5171)
			p.Match(Cobol85ParserKEY)
		}

	}
	p.SetState(5175)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH)|(1<<Cobol85ParserATTRIBUTE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBINARY-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-68))|(1<<(Cobol85ParserCOBOL-68))|(1<<(Cobol85ParserCOMMITMENT-68))|(1<<(Cobol85ParserCONTROL_POINT-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(Cobol85ParserCONVENTION-100))|(1<<(Cobol85ParserCRUNCH-100))|(1<<(Cobol85ParserCURSOR-100))|(1<<(Cobol85ParserDEFAULT-100))|(1<<(Cobol85ParserDEFAULT_DISPLAY-100))|(1<<(Cobol85ParserDEFINITION-100)))) != 0) || (((_la-138)&-(0x1f+1)) == 0 && ((1<<uint((_la-138)))&((1<<(Cobol85ParserDFHRESP-138))|(1<<(Cobol85ParserDFHVALUE-138))|(1<<(Cobol85ParserDISK-138))|(1<<(Cobol85ParserDONTCARE-138))|(1<<(Cobol85ParserDOUBLE-138))|(1<<(Cobol85ParserEBCDIC-138))|(1<<(Cobol85ParserEMPTY_CHECK-138)))) != 0) || (((_la-181)&-(0x1f+1)) == 0 && ((1<<uint((_la-181)))&((1<<(Cobol85ParserENTER-181))|(1<<(Cobol85ParserENTRY_PROCEDURE-181))|(1<<(Cobol85ParserERASE-181))|(1<<(Cobol85ParserEOL-181))|(1<<(Cobol85ParserEOS-181))|(1<<(Cobol85ParserESCAPE-181))|(1<<(Cobol85ParserEVENT-181))|(1<<(Cobol85ParserEXCLUSIVE-181))|(1<<(Cobol85ParserEXPORT-181))|(1<<(Cobol85ParserEXTENDED-181)))) != 0) || (((_la-213)&-(0x1f+1)) == 0 && ((1<<uint((_la-213)))&((1<<(Cobol85ParserFOREGROUND_COLOR-213))|(1<<(Cobol85ParserFOREGROUND_COLOUR-213))|(1<<(Cobol85ParserFULL-213))|(1<<(Cobol85ParserFUNCTIONNAME-213))|(1<<(Cobol85ParserFUNCTION_POINTER-213))|(1<<(Cobol85ParserGRID-213))|(1<<(Cobol85ParserHIGHLIGHT-213))|(1<<(Cobol85ParserIMPLICIT-213))|(1<<(Cobol85ParserIMPORT-213)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(Cobol85ParserINTEGER-250))|(1<<(Cobol85ParserKEPT-250))|(1<<(Cobol85ParserKEYBOARD-250))|(1<<(Cobol85ParserLANGUAGE-250))|(1<<(Cobol85ParserLB-250))|(1<<(Cobol85ParserLD-250))|(1<<(Cobol85ParserLEFTLINE-250))|(1<<(Cobol85ParserLENGTH_CHECK-250))|(1<<(Cobol85ParserLIBACCESS-250))|(1<<(Cobol85ParserLIBPARAMETER-250))|(1<<(Cobol85ParserLIBRARY-250))|(1<<(Cobol85ParserLINAGE_COUNTER-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(Cobol85ParserLIST-283))|(1<<(Cobol85ParserLOCAL-283))|(1<<(Cobol85ParserLONG_DATE-283))|(1<<(Cobol85ParserLONG_TIME-283))|(1<<(Cobol85ParserLOWER-283))|(1<<(Cobol85ParserLOWLIGHT-283))|(1<<(Cobol85ParserMMDDYYYY-283))|(1<<(Cobol85ParserNAMED-283))|(1<<(Cobol85ParserNATIONAL-283))|(1<<(Cobol85ParserNATIONAL_EDITED-283))|(1<<(Cobol85ParserNETWORK-283))|(1<<(Cobol85ParserNO_ECHO-283)))) != 0) || (((_la-317)&-(0x1f+1)) == 0 && ((1<<uint((_la-317)))&((1<<(Cobol85ParserNUMERIC_DATE-317))|(1<<(Cobol85ParserNUMERIC_TIME-317))|(1<<(Cobol85ParserODT-317))|(1<<(Cobol85ParserORDERLY-317))|(1<<(Cobol85ParserOVERLINE-317))|(1<<(Cobol85ParserOWN-317))|(1<<(Cobol85ParserPASSWORD-317)))) != 0) || (((_la-352)&-(0x1f+1)) == 0 && ((1<<uint((_la-352)))&((1<<(Cobol85ParserPORT-352))|(1<<(Cobol85ParserPRINTER-352))|(1<<(Cobol85ParserPRIVATE-352))|(1<<(Cobol85ParserPROCESS-352))|(1<<(Cobol85ParserPROGRAM-352))|(1<<(Cobol85ParserPROMPT-352))|(1<<(Cobol85ParserREADER-352))|(1<<(Cobol85ParserREMOTE-352))|(1<<(Cobol85ParserREAL-352))|(1<<(Cobol85ParserRECEIVED-352))|(1<<(Cobol85ParserRECURSIVE-352))|(1<<(Cobol85ParserREF-352)))) != 0) || (((_la-391)&-(0x1f+1)) == 0 && ((1<<uint((_la-391)))&((1<<(Cobol85ParserREMOVE-391))|(1<<(Cobol85ParserREQUIRED-391))|(1<<(Cobol85ParserREVERSE_VIDEO-391))|(1<<(Cobol85ParserSAVE-391))|(1<<(Cobol85ParserSECURE-391)))) != 0) || (((_la-431)&-(0x1f+1)) == 0 && ((1<<uint((_la-431)))&((1<<(Cobol85ParserSHARED-431))|(1<<(Cobol85ParserSHAREDBYALL-431))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-431))|(1<<(Cobol85ParserSHARING-431))|(1<<(Cobol85ParserSHORT_DATE-431)))) != 0) || (((_la-466)&-(0x1f+1)) == 0 && ((1<<uint((_la-466)))&((1<<(Cobol85ParserSYMBOL-466))|(1<<(Cobol85ParserTASK-466))|(1<<(Cobol85ParserTHREAD-466))|(1<<(Cobol85ParserTHREAD_LOCAL-466))|(1<<(Cobol85ParserTIMER-466))|(1<<(Cobol85ParserTODAYS_DATE-466))|(1<<(Cobol85ParserTODAYS_NAME-466))|(1<<(Cobol85ParserTRUNCATED-466))|(1<<(Cobol85ParserTYPEDEF-466)))) != 0) || (((_la-498)&-(0x1f+1)) == 0 && ((1<<uint((_la-498)))&((1<<(Cobol85ParserUNDERLINE-498))|(1<<(Cobol85ParserVIRTUAL-498))|(1<<(Cobol85ParserWAIT-498))|(1<<(Cobol85ParserYEAR-498))|(1<<(Cobol85ParserYYYYMMDD-498))|(1<<(Cobol85ParserYYYYDDD-498))|(1<<(Cobol85ParserZERO_FILL-498)))) != 0) || (((_la-552)&-(0x1f+1)) == 0 && ((1<<uint((_la-552)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-552))|(1<<(Cobol85ParserLEVEL_NUMBER_77-552))|(1<<(Cobol85ParserLEVEL_NUMBER_88-552))|(1<<(Cobol85ParserINTEGERLITERAL-552))|(1<<(Cobol85ParserIDENTIFIER-552)))) != 0) {
		{
			p.SetState(5174)
			p.QualifiedDataName()
		}

		p.SetState(5177)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISortDuplicatesPhraseContext is an interface to support dynamic dispatch.
type ISortDuplicatesPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSortDuplicatesPhraseContext differentiates from other interfaces.
	IsSortDuplicatesPhraseContext()
}

type SortDuplicatesPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySortDuplicatesPhraseContext() *SortDuplicatesPhraseContext {
	var p = new(SortDuplicatesPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sortDuplicatesPhrase
	return p
}

func (*SortDuplicatesPhraseContext) IsSortDuplicatesPhraseContext() {}

func NewSortDuplicatesPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortDuplicatesPhraseContext {
	var p = new(SortDuplicatesPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sortDuplicatesPhrase

	return p
}

func (s *SortDuplicatesPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *SortDuplicatesPhraseContext) DUPLICATES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDUPLICATES, 0)
}

func (s *SortDuplicatesPhraseContext) WITH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWITH, 0)
}

func (s *SortDuplicatesPhraseContext) IN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIN, 0)
}

func (s *SortDuplicatesPhraseContext) ORDER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserORDER, 0)
}

func (s *SortDuplicatesPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortDuplicatesPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortDuplicatesPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSortDuplicatesPhrase(s)
	}
}

func (s *SortDuplicatesPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSortDuplicatesPhrase(s)
	}
}

func (p *Cobol85Parser) SortDuplicatesPhrase() (localctx ISortDuplicatesPhraseContext) {
	localctx = NewSortDuplicatesPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 904, Cobol85ParserRULE_sortDuplicatesPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5180)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserWITH {
		{
			p.SetState(5179)
			p.Match(Cobol85ParserWITH)
		}

	}
	{
		p.SetState(5182)
		p.Match(Cobol85ParserDUPLICATES)
	}
	p.SetState(5184)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIN {
		{
			p.SetState(5183)
			p.Match(Cobol85ParserIN)
		}

	}
	p.SetState(5187)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserORDER {
		{
			p.SetState(5186)
			p.Match(Cobol85ParserORDER)
		}

	}

	return localctx
}

// ISortCollatingSequencePhraseContext is an interface to support dynamic dispatch.
type ISortCollatingSequencePhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSortCollatingSequencePhraseContext differentiates from other interfaces.
	IsSortCollatingSequencePhraseContext()
}

type SortCollatingSequencePhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySortCollatingSequencePhraseContext() *SortCollatingSequencePhraseContext {
	var p = new(SortCollatingSequencePhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sortCollatingSequencePhrase
	return p
}

func (*SortCollatingSequencePhraseContext) IsSortCollatingSequencePhraseContext() {}

func NewSortCollatingSequencePhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortCollatingSequencePhraseContext {
	var p = new(SortCollatingSequencePhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sortCollatingSequencePhrase

	return p
}

func (s *SortCollatingSequencePhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *SortCollatingSequencePhraseContext) SEQUENCE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSEQUENCE, 0)
}

func (s *SortCollatingSequencePhraseContext) COLLATING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOLLATING, 0)
}

func (s *SortCollatingSequencePhraseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *SortCollatingSequencePhraseContext) AllAlphabetName() []IAlphabetNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAlphabetNameContext)(nil)).Elem())
	var tst = make([]IAlphabetNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAlphabetNameContext)
		}
	}

	return tst
}

func (s *SortCollatingSequencePhraseContext) AlphabetName(i int) IAlphabetNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlphabetNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAlphabetNameContext)
}

func (s *SortCollatingSequencePhraseContext) SortCollatingAlphanumeric() ISortCollatingAlphanumericContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISortCollatingAlphanumericContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISortCollatingAlphanumericContext)
}

func (s *SortCollatingSequencePhraseContext) SortCollatingNational() ISortCollatingNationalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISortCollatingNationalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISortCollatingNationalContext)
}

func (s *SortCollatingSequencePhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortCollatingSequencePhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortCollatingSequencePhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSortCollatingSequencePhrase(s)
	}
}

func (s *SortCollatingSequencePhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSortCollatingSequencePhrase(s)
	}
}

func (p *Cobol85Parser) SortCollatingSequencePhrase() (localctx ISortCollatingSequencePhraseContext) {
	localctx = NewSortCollatingSequencePhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 906, Cobol85ParserRULE_sortCollatingSequencePhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5190)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCOLLATING {
		{
			p.SetState(5189)
			p.Match(Cobol85ParserCOLLATING)
		}

	}
	{
		p.SetState(5192)
		p.Match(Cobol85ParserSEQUENCE)
	}
	p.SetState(5194)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(5193)
			p.Match(Cobol85ParserIS)
		}

	}
	p.SetState(5197)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(5196)
				p.AlphabetName()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(5199)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 787, p.GetParserRuleContext())
	}
	p.SetState(5202)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 788, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5201)
			p.SortCollatingAlphanumeric()
		}

	}
	p.SetState(5205)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFOR || _la == Cobol85ParserNATIONAL {
		{
			p.SetState(5204)
			p.SortCollatingNational()
		}

	}

	return localctx
}

// ISortCollatingAlphanumericContext is an interface to support dynamic dispatch.
type ISortCollatingAlphanumericContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSortCollatingAlphanumericContext differentiates from other interfaces.
	IsSortCollatingAlphanumericContext()
}

type SortCollatingAlphanumericContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySortCollatingAlphanumericContext() *SortCollatingAlphanumericContext {
	var p = new(SortCollatingAlphanumericContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sortCollatingAlphanumeric
	return p
}

func (*SortCollatingAlphanumericContext) IsSortCollatingAlphanumericContext() {}

func NewSortCollatingAlphanumericContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortCollatingAlphanumericContext {
	var p = new(SortCollatingAlphanumericContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sortCollatingAlphanumeric

	return p
}

func (s *SortCollatingAlphanumericContext) GetParser() antlr.Parser { return s.parser }

func (s *SortCollatingAlphanumericContext) ALPHANUMERIC() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALPHANUMERIC, 0)
}

func (s *SortCollatingAlphanumericContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *SortCollatingAlphanumericContext) AlphabetName() IAlphabetNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlphabetNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlphabetNameContext)
}

func (s *SortCollatingAlphanumericContext) FOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOR, 0)
}

func (s *SortCollatingAlphanumericContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortCollatingAlphanumericContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortCollatingAlphanumericContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSortCollatingAlphanumeric(s)
	}
}

func (s *SortCollatingAlphanumericContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSortCollatingAlphanumeric(s)
	}
}

func (p *Cobol85Parser) SortCollatingAlphanumeric() (localctx ISortCollatingAlphanumericContext) {
	localctx = NewSortCollatingAlphanumericContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 908, Cobol85ParserRULE_sortCollatingAlphanumeric)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5208)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFOR {
		{
			p.SetState(5207)
			p.Match(Cobol85ParserFOR)
		}

	}
	{
		p.SetState(5210)
		p.Match(Cobol85ParserALPHANUMERIC)
	}
	{
		p.SetState(5211)
		p.Match(Cobol85ParserIS)
	}
	{
		p.SetState(5212)
		p.AlphabetName()
	}

	return localctx
}

// ISortCollatingNationalContext is an interface to support dynamic dispatch.
type ISortCollatingNationalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSortCollatingNationalContext differentiates from other interfaces.
	IsSortCollatingNationalContext()
}

type SortCollatingNationalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySortCollatingNationalContext() *SortCollatingNationalContext {
	var p = new(SortCollatingNationalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sortCollatingNational
	return p
}

func (*SortCollatingNationalContext) IsSortCollatingNationalContext() {}

func NewSortCollatingNationalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortCollatingNationalContext {
	var p = new(SortCollatingNationalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sortCollatingNational

	return p
}

func (s *SortCollatingNationalContext) GetParser() antlr.Parser { return s.parser }

func (s *SortCollatingNationalContext) NATIONAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNATIONAL, 0)
}

func (s *SortCollatingNationalContext) AlphabetName() IAlphabetNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlphabetNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlphabetNameContext)
}

func (s *SortCollatingNationalContext) FOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOR, 0)
}

func (s *SortCollatingNationalContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *SortCollatingNationalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortCollatingNationalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortCollatingNationalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSortCollatingNational(s)
	}
}

func (s *SortCollatingNationalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSortCollatingNational(s)
	}
}

func (p *Cobol85Parser) SortCollatingNational() (localctx ISortCollatingNationalContext) {
	localctx = NewSortCollatingNationalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 910, Cobol85ParserRULE_sortCollatingNational)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5215)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFOR {
		{
			p.SetState(5214)
			p.Match(Cobol85ParserFOR)
		}

	}
	{
		p.SetState(5217)
		p.Match(Cobol85ParserNATIONAL)
	}
	p.SetState(5219)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(5218)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(5221)
		p.AlphabetName()
	}

	return localctx
}

// ISortInputProcedurePhraseContext is an interface to support dynamic dispatch.
type ISortInputProcedurePhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSortInputProcedurePhraseContext differentiates from other interfaces.
	IsSortInputProcedurePhraseContext()
}

type SortInputProcedurePhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySortInputProcedurePhraseContext() *SortInputProcedurePhraseContext {
	var p = new(SortInputProcedurePhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sortInputProcedurePhrase
	return p
}

func (*SortInputProcedurePhraseContext) IsSortInputProcedurePhraseContext() {}

func NewSortInputProcedurePhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortInputProcedurePhraseContext {
	var p = new(SortInputProcedurePhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sortInputProcedurePhrase

	return p
}

func (s *SortInputProcedurePhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *SortInputProcedurePhraseContext) INPUT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINPUT, 0)
}

func (s *SortInputProcedurePhraseContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPROCEDURE, 0)
}

func (s *SortInputProcedurePhraseContext) ProcedureName() IProcedureNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedureNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedureNameContext)
}

func (s *SortInputProcedurePhraseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *SortInputProcedurePhraseContext) SortInputThrough() ISortInputThroughContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISortInputThroughContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISortInputThroughContext)
}

func (s *SortInputProcedurePhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortInputProcedurePhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortInputProcedurePhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSortInputProcedurePhrase(s)
	}
}

func (s *SortInputProcedurePhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSortInputProcedurePhrase(s)
	}
}

func (p *Cobol85Parser) SortInputProcedurePhrase() (localctx ISortInputProcedurePhraseContext) {
	localctx = NewSortInputProcedurePhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 912, Cobol85ParserRULE_sortInputProcedurePhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5223)
		p.Match(Cobol85ParserINPUT)
	}
	{
		p.SetState(5224)
		p.Match(Cobol85ParserPROCEDURE)
	}
	p.SetState(5226)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(5225)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(5228)
		p.ProcedureName()
	}
	p.SetState(5230)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserTHROUGH || _la == Cobol85ParserTHRU {
		{
			p.SetState(5229)
			p.SortInputThrough()
		}

	}

	return localctx
}

// ISortInputThroughContext is an interface to support dynamic dispatch.
type ISortInputThroughContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSortInputThroughContext differentiates from other interfaces.
	IsSortInputThroughContext()
}

type SortInputThroughContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySortInputThroughContext() *SortInputThroughContext {
	var p = new(SortInputThroughContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sortInputThrough
	return p
}

func (*SortInputThroughContext) IsSortInputThroughContext() {}

func NewSortInputThroughContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortInputThroughContext {
	var p = new(SortInputThroughContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sortInputThrough

	return p
}

func (s *SortInputThroughContext) GetParser() antlr.Parser { return s.parser }

func (s *SortInputThroughContext) ProcedureName() IProcedureNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedureNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedureNameContext)
}

func (s *SortInputThroughContext) THROUGH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHROUGH, 0)
}

func (s *SortInputThroughContext) THRU() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHRU, 0)
}

func (s *SortInputThroughContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortInputThroughContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortInputThroughContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSortInputThrough(s)
	}
}

func (s *SortInputThroughContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSortInputThrough(s)
	}
}

func (p *Cobol85Parser) SortInputThrough() (localctx ISortInputThroughContext) {
	localctx = NewSortInputThroughContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 914, Cobol85ParserRULE_sortInputThrough)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5232)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserTHROUGH || _la == Cobol85ParserTHRU) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(5233)
		p.ProcedureName()
	}

	return localctx
}

// ISortUsingContext is an interface to support dynamic dispatch.
type ISortUsingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSortUsingContext differentiates from other interfaces.
	IsSortUsingContext()
}

type SortUsingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySortUsingContext() *SortUsingContext {
	var p = new(SortUsingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sortUsing
	return p
}

func (*SortUsingContext) IsSortUsingContext() {}

func NewSortUsingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortUsingContext {
	var p = new(SortUsingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sortUsing

	return p
}

func (s *SortUsingContext) GetParser() antlr.Parser { return s.parser }

func (s *SortUsingContext) USING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserUSING, 0)
}

func (s *SortUsingContext) AllFileName() []IFileNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFileNameContext)(nil)).Elem())
	var tst = make([]IFileNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFileNameContext)
		}
	}

	return tst
}

func (s *SortUsingContext) FileName(i int) IFileNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *SortUsingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortUsingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortUsingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSortUsing(s)
	}
}

func (s *SortUsingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSortUsing(s)
	}
}

func (p *Cobol85Parser) SortUsing() (localctx ISortUsingContext) {
	localctx = NewSortUsingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 916, Cobol85ParserRULE_sortUsing)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5235)
		p.Match(Cobol85ParserUSING)
	}
	p.SetState(5237)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH)|(1<<Cobol85ParserATTRIBUTE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBINARY-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-68))|(1<<(Cobol85ParserCOBOL-68))|(1<<(Cobol85ParserCOMMITMENT-68))|(1<<(Cobol85ParserCONTROL_POINT-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(Cobol85ParserCONVENTION-100))|(1<<(Cobol85ParserCRUNCH-100))|(1<<(Cobol85ParserCURSOR-100))|(1<<(Cobol85ParserDEFAULT-100))|(1<<(Cobol85ParserDEFAULT_DISPLAY-100))|(1<<(Cobol85ParserDEFINITION-100)))) != 0) || (((_la-138)&-(0x1f+1)) == 0 && ((1<<uint((_la-138)))&((1<<(Cobol85ParserDFHRESP-138))|(1<<(Cobol85ParserDFHVALUE-138))|(1<<(Cobol85ParserDISK-138))|(1<<(Cobol85ParserDONTCARE-138))|(1<<(Cobol85ParserDOUBLE-138))|(1<<(Cobol85ParserEBCDIC-138))|(1<<(Cobol85ParserEMPTY_CHECK-138)))) != 0) || (((_la-181)&-(0x1f+1)) == 0 && ((1<<uint((_la-181)))&((1<<(Cobol85ParserENTER-181))|(1<<(Cobol85ParserENTRY_PROCEDURE-181))|(1<<(Cobol85ParserERASE-181))|(1<<(Cobol85ParserEOL-181))|(1<<(Cobol85ParserEOS-181))|(1<<(Cobol85ParserESCAPE-181))|(1<<(Cobol85ParserEVENT-181))|(1<<(Cobol85ParserEXCLUSIVE-181))|(1<<(Cobol85ParserEXPORT-181))|(1<<(Cobol85ParserEXTENDED-181)))) != 0) || (((_la-213)&-(0x1f+1)) == 0 && ((1<<uint((_la-213)))&((1<<(Cobol85ParserFOREGROUND_COLOR-213))|(1<<(Cobol85ParserFOREGROUND_COLOUR-213))|(1<<(Cobol85ParserFULL-213))|(1<<(Cobol85ParserFUNCTIONNAME-213))|(1<<(Cobol85ParserFUNCTION_POINTER-213))|(1<<(Cobol85ParserGRID-213))|(1<<(Cobol85ParserHIGHLIGHT-213))|(1<<(Cobol85ParserIMPLICIT-213))|(1<<(Cobol85ParserIMPORT-213)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(Cobol85ParserINTEGER-250))|(1<<(Cobol85ParserKEPT-250))|(1<<(Cobol85ParserKEYBOARD-250))|(1<<(Cobol85ParserLANGUAGE-250))|(1<<(Cobol85ParserLB-250))|(1<<(Cobol85ParserLD-250))|(1<<(Cobol85ParserLEFTLINE-250))|(1<<(Cobol85ParserLENGTH_CHECK-250))|(1<<(Cobol85ParserLIBACCESS-250))|(1<<(Cobol85ParserLIBPARAMETER-250))|(1<<(Cobol85ParserLIBRARY-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(Cobol85ParserLIST-283))|(1<<(Cobol85ParserLOCAL-283))|(1<<(Cobol85ParserLONG_DATE-283))|(1<<(Cobol85ParserLONG_TIME-283))|(1<<(Cobol85ParserLOWER-283))|(1<<(Cobol85ParserLOWLIGHT-283))|(1<<(Cobol85ParserMMDDYYYY-283))|(1<<(Cobol85ParserNAMED-283))|(1<<(Cobol85ParserNATIONAL-283))|(1<<(Cobol85ParserNATIONAL_EDITED-283))|(1<<(Cobol85ParserNETWORK-283))|(1<<(Cobol85ParserNO_ECHO-283)))) != 0) || (((_la-317)&-(0x1f+1)) == 0 && ((1<<uint((_la-317)))&((1<<(Cobol85ParserNUMERIC_DATE-317))|(1<<(Cobol85ParserNUMERIC_TIME-317))|(1<<(Cobol85ParserODT-317))|(1<<(Cobol85ParserORDERLY-317))|(1<<(Cobol85ParserOVERLINE-317))|(1<<(Cobol85ParserOWN-317))|(1<<(Cobol85ParserPASSWORD-317)))) != 0) || (((_la-352)&-(0x1f+1)) == 0 && ((1<<uint((_la-352)))&((1<<(Cobol85ParserPORT-352))|(1<<(Cobol85ParserPRINTER-352))|(1<<(Cobol85ParserPRIVATE-352))|(1<<(Cobol85ParserPROCESS-352))|(1<<(Cobol85ParserPROGRAM-352))|(1<<(Cobol85ParserPROMPT-352))|(1<<(Cobol85ParserREADER-352))|(1<<(Cobol85ParserREMOTE-352))|(1<<(Cobol85ParserREAL-352))|(1<<(Cobol85ParserRECEIVED-352))|(1<<(Cobol85ParserRECURSIVE-352))|(1<<(Cobol85ParserREF-352)))) != 0) || (((_la-391)&-(0x1f+1)) == 0 && ((1<<uint((_la-391)))&((1<<(Cobol85ParserREMOVE-391))|(1<<(Cobol85ParserREQUIRED-391))|(1<<(Cobol85ParserREVERSE_VIDEO-391))|(1<<(Cobol85ParserSAVE-391))|(1<<(Cobol85ParserSECURE-391)))) != 0) || (((_la-431)&-(0x1f+1)) == 0 && ((1<<uint((_la-431)))&((1<<(Cobol85ParserSHARED-431))|(1<<(Cobol85ParserSHAREDBYALL-431))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-431))|(1<<(Cobol85ParserSHARING-431))|(1<<(Cobol85ParserSHORT_DATE-431)))) != 0) || (((_la-466)&-(0x1f+1)) == 0 && ((1<<uint((_la-466)))&((1<<(Cobol85ParserSYMBOL-466))|(1<<(Cobol85ParserTASK-466))|(1<<(Cobol85ParserTHREAD-466))|(1<<(Cobol85ParserTHREAD_LOCAL-466))|(1<<(Cobol85ParserTIMER-466))|(1<<(Cobol85ParserTODAYS_DATE-466))|(1<<(Cobol85ParserTODAYS_NAME-466))|(1<<(Cobol85ParserTRUNCATED-466))|(1<<(Cobol85ParserTYPEDEF-466)))) != 0) || (((_la-498)&-(0x1f+1)) == 0 && ((1<<uint((_la-498)))&((1<<(Cobol85ParserUNDERLINE-498))|(1<<(Cobol85ParserVIRTUAL-498))|(1<<(Cobol85ParserWAIT-498))|(1<<(Cobol85ParserYEAR-498))|(1<<(Cobol85ParserYYYYMMDD-498))|(1<<(Cobol85ParserYYYYDDD-498))|(1<<(Cobol85ParserZERO_FILL-498)))) != 0) || _la == Cobol85ParserIDENTIFIER {
		{
			p.SetState(5236)
			p.FileName()
		}

		p.SetState(5239)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISortOutputProcedurePhraseContext is an interface to support dynamic dispatch.
type ISortOutputProcedurePhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSortOutputProcedurePhraseContext differentiates from other interfaces.
	IsSortOutputProcedurePhraseContext()
}

type SortOutputProcedurePhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySortOutputProcedurePhraseContext() *SortOutputProcedurePhraseContext {
	var p = new(SortOutputProcedurePhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sortOutputProcedurePhrase
	return p
}

func (*SortOutputProcedurePhraseContext) IsSortOutputProcedurePhraseContext() {}

func NewSortOutputProcedurePhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortOutputProcedurePhraseContext {
	var p = new(SortOutputProcedurePhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sortOutputProcedurePhrase

	return p
}

func (s *SortOutputProcedurePhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *SortOutputProcedurePhraseContext) OUTPUT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOUTPUT, 0)
}

func (s *SortOutputProcedurePhraseContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPROCEDURE, 0)
}

func (s *SortOutputProcedurePhraseContext) ProcedureName() IProcedureNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedureNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedureNameContext)
}

func (s *SortOutputProcedurePhraseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *SortOutputProcedurePhraseContext) SortOutputThrough() ISortOutputThroughContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISortOutputThroughContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISortOutputThroughContext)
}

func (s *SortOutputProcedurePhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortOutputProcedurePhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortOutputProcedurePhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSortOutputProcedurePhrase(s)
	}
}

func (s *SortOutputProcedurePhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSortOutputProcedurePhrase(s)
	}
}

func (p *Cobol85Parser) SortOutputProcedurePhrase() (localctx ISortOutputProcedurePhraseContext) {
	localctx = NewSortOutputProcedurePhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 918, Cobol85ParserRULE_sortOutputProcedurePhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5241)
		p.Match(Cobol85ParserOUTPUT)
	}
	{
		p.SetState(5242)
		p.Match(Cobol85ParserPROCEDURE)
	}
	p.SetState(5244)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(5243)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(5246)
		p.ProcedureName()
	}
	p.SetState(5248)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserTHROUGH || _la == Cobol85ParserTHRU {
		{
			p.SetState(5247)
			p.SortOutputThrough()
		}

	}

	return localctx
}

// ISortOutputThroughContext is an interface to support dynamic dispatch.
type ISortOutputThroughContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSortOutputThroughContext differentiates from other interfaces.
	IsSortOutputThroughContext()
}

type SortOutputThroughContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySortOutputThroughContext() *SortOutputThroughContext {
	var p = new(SortOutputThroughContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sortOutputThrough
	return p
}

func (*SortOutputThroughContext) IsSortOutputThroughContext() {}

func NewSortOutputThroughContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortOutputThroughContext {
	var p = new(SortOutputThroughContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sortOutputThrough

	return p
}

func (s *SortOutputThroughContext) GetParser() antlr.Parser { return s.parser }

func (s *SortOutputThroughContext) ProcedureName() IProcedureNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedureNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedureNameContext)
}

func (s *SortOutputThroughContext) THROUGH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHROUGH, 0)
}

func (s *SortOutputThroughContext) THRU() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHRU, 0)
}

func (s *SortOutputThroughContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortOutputThroughContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortOutputThroughContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSortOutputThrough(s)
	}
}

func (s *SortOutputThroughContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSortOutputThrough(s)
	}
}

func (p *Cobol85Parser) SortOutputThrough() (localctx ISortOutputThroughContext) {
	localctx = NewSortOutputThroughContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 920, Cobol85ParserRULE_sortOutputThrough)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5250)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserTHROUGH || _la == Cobol85ParserTHRU) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(5251)
		p.ProcedureName()
	}

	return localctx
}

// ISortGivingPhraseContext is an interface to support dynamic dispatch.
type ISortGivingPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSortGivingPhraseContext differentiates from other interfaces.
	IsSortGivingPhraseContext()
}

type SortGivingPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySortGivingPhraseContext() *SortGivingPhraseContext {
	var p = new(SortGivingPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sortGivingPhrase
	return p
}

func (*SortGivingPhraseContext) IsSortGivingPhraseContext() {}

func NewSortGivingPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortGivingPhraseContext {
	var p = new(SortGivingPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sortGivingPhrase

	return p
}

func (s *SortGivingPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *SortGivingPhraseContext) GIVING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserGIVING, 0)
}

func (s *SortGivingPhraseContext) AllSortGiving() []ISortGivingContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISortGivingContext)(nil)).Elem())
	var tst = make([]ISortGivingContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISortGivingContext)
		}
	}

	return tst
}

func (s *SortGivingPhraseContext) SortGiving(i int) ISortGivingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISortGivingContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISortGivingContext)
}

func (s *SortGivingPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortGivingPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortGivingPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSortGivingPhrase(s)
	}
}

func (s *SortGivingPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSortGivingPhrase(s)
	}
}

func (p *Cobol85Parser) SortGivingPhrase() (localctx ISortGivingPhraseContext) {
	localctx = NewSortGivingPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 922, Cobol85ParserRULE_sortGivingPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5253)
		p.Match(Cobol85ParserGIVING)
	}
	p.SetState(5255)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH)|(1<<Cobol85ParserATTRIBUTE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBINARY-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-68))|(1<<(Cobol85ParserCOBOL-68))|(1<<(Cobol85ParserCOMMITMENT-68))|(1<<(Cobol85ParserCONTROL_POINT-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(Cobol85ParserCONVENTION-100))|(1<<(Cobol85ParserCRUNCH-100))|(1<<(Cobol85ParserCURSOR-100))|(1<<(Cobol85ParserDEFAULT-100))|(1<<(Cobol85ParserDEFAULT_DISPLAY-100))|(1<<(Cobol85ParserDEFINITION-100)))) != 0) || (((_la-138)&-(0x1f+1)) == 0 && ((1<<uint((_la-138)))&((1<<(Cobol85ParserDFHRESP-138))|(1<<(Cobol85ParserDFHVALUE-138))|(1<<(Cobol85ParserDISK-138))|(1<<(Cobol85ParserDONTCARE-138))|(1<<(Cobol85ParserDOUBLE-138))|(1<<(Cobol85ParserEBCDIC-138))|(1<<(Cobol85ParserEMPTY_CHECK-138)))) != 0) || (((_la-181)&-(0x1f+1)) == 0 && ((1<<uint((_la-181)))&((1<<(Cobol85ParserENTER-181))|(1<<(Cobol85ParserENTRY_PROCEDURE-181))|(1<<(Cobol85ParserERASE-181))|(1<<(Cobol85ParserEOL-181))|(1<<(Cobol85ParserEOS-181))|(1<<(Cobol85ParserESCAPE-181))|(1<<(Cobol85ParserEVENT-181))|(1<<(Cobol85ParserEXCLUSIVE-181))|(1<<(Cobol85ParserEXPORT-181))|(1<<(Cobol85ParserEXTENDED-181)))) != 0) || (((_la-213)&-(0x1f+1)) == 0 && ((1<<uint((_la-213)))&((1<<(Cobol85ParserFOREGROUND_COLOR-213))|(1<<(Cobol85ParserFOREGROUND_COLOUR-213))|(1<<(Cobol85ParserFULL-213))|(1<<(Cobol85ParserFUNCTIONNAME-213))|(1<<(Cobol85ParserFUNCTION_POINTER-213))|(1<<(Cobol85ParserGRID-213))|(1<<(Cobol85ParserHIGHLIGHT-213))|(1<<(Cobol85ParserIMPLICIT-213))|(1<<(Cobol85ParserIMPORT-213)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(Cobol85ParserINTEGER-250))|(1<<(Cobol85ParserKEPT-250))|(1<<(Cobol85ParserKEYBOARD-250))|(1<<(Cobol85ParserLANGUAGE-250))|(1<<(Cobol85ParserLB-250))|(1<<(Cobol85ParserLD-250))|(1<<(Cobol85ParserLEFTLINE-250))|(1<<(Cobol85ParserLENGTH_CHECK-250))|(1<<(Cobol85ParserLIBACCESS-250))|(1<<(Cobol85ParserLIBPARAMETER-250))|(1<<(Cobol85ParserLIBRARY-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(Cobol85ParserLIST-283))|(1<<(Cobol85ParserLOCAL-283))|(1<<(Cobol85ParserLONG_DATE-283))|(1<<(Cobol85ParserLONG_TIME-283))|(1<<(Cobol85ParserLOWER-283))|(1<<(Cobol85ParserLOWLIGHT-283))|(1<<(Cobol85ParserMMDDYYYY-283))|(1<<(Cobol85ParserNAMED-283))|(1<<(Cobol85ParserNATIONAL-283))|(1<<(Cobol85ParserNATIONAL_EDITED-283))|(1<<(Cobol85ParserNETWORK-283))|(1<<(Cobol85ParserNO_ECHO-283)))) != 0) || (((_la-317)&-(0x1f+1)) == 0 && ((1<<uint((_la-317)))&((1<<(Cobol85ParserNUMERIC_DATE-317))|(1<<(Cobol85ParserNUMERIC_TIME-317))|(1<<(Cobol85ParserODT-317))|(1<<(Cobol85ParserORDERLY-317))|(1<<(Cobol85ParserOVERLINE-317))|(1<<(Cobol85ParserOWN-317))|(1<<(Cobol85ParserPASSWORD-317)))) != 0) || (((_la-352)&-(0x1f+1)) == 0 && ((1<<uint((_la-352)))&((1<<(Cobol85ParserPORT-352))|(1<<(Cobol85ParserPRINTER-352))|(1<<(Cobol85ParserPRIVATE-352))|(1<<(Cobol85ParserPROCESS-352))|(1<<(Cobol85ParserPROGRAM-352))|(1<<(Cobol85ParserPROMPT-352))|(1<<(Cobol85ParserREADER-352))|(1<<(Cobol85ParserREMOTE-352))|(1<<(Cobol85ParserREAL-352))|(1<<(Cobol85ParserRECEIVED-352))|(1<<(Cobol85ParserRECURSIVE-352))|(1<<(Cobol85ParserREF-352)))) != 0) || (((_la-391)&-(0x1f+1)) == 0 && ((1<<uint((_la-391)))&((1<<(Cobol85ParserREMOVE-391))|(1<<(Cobol85ParserREQUIRED-391))|(1<<(Cobol85ParserREVERSE_VIDEO-391))|(1<<(Cobol85ParserSAVE-391))|(1<<(Cobol85ParserSECURE-391)))) != 0) || (((_la-431)&-(0x1f+1)) == 0 && ((1<<uint((_la-431)))&((1<<(Cobol85ParserSHARED-431))|(1<<(Cobol85ParserSHAREDBYALL-431))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-431))|(1<<(Cobol85ParserSHARING-431))|(1<<(Cobol85ParserSHORT_DATE-431)))) != 0) || (((_la-466)&-(0x1f+1)) == 0 && ((1<<uint((_la-466)))&((1<<(Cobol85ParserSYMBOL-466))|(1<<(Cobol85ParserTASK-466))|(1<<(Cobol85ParserTHREAD-466))|(1<<(Cobol85ParserTHREAD_LOCAL-466))|(1<<(Cobol85ParserTIMER-466))|(1<<(Cobol85ParserTODAYS_DATE-466))|(1<<(Cobol85ParserTODAYS_NAME-466))|(1<<(Cobol85ParserTRUNCATED-466))|(1<<(Cobol85ParserTYPEDEF-466)))) != 0) || (((_la-498)&-(0x1f+1)) == 0 && ((1<<uint((_la-498)))&((1<<(Cobol85ParserUNDERLINE-498))|(1<<(Cobol85ParserVIRTUAL-498))|(1<<(Cobol85ParserWAIT-498))|(1<<(Cobol85ParserYEAR-498))|(1<<(Cobol85ParserYYYYMMDD-498))|(1<<(Cobol85ParserYYYYDDD-498))|(1<<(Cobol85ParserZERO_FILL-498)))) != 0) || _la == Cobol85ParserIDENTIFIER {
		{
			p.SetState(5254)
			p.SortGiving()
		}

		p.SetState(5257)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISortGivingContext is an interface to support dynamic dispatch.
type ISortGivingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSortGivingContext differentiates from other interfaces.
	IsSortGivingContext()
}

type SortGivingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySortGivingContext() *SortGivingContext {
	var p = new(SortGivingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sortGiving
	return p
}

func (*SortGivingContext) IsSortGivingContext() {}

func NewSortGivingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortGivingContext {
	var p = new(SortGivingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sortGiving

	return p
}

func (s *SortGivingContext) GetParser() antlr.Parser { return s.parser }

func (s *SortGivingContext) FileName() IFileNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *SortGivingContext) LOCK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLOCK, 0)
}

func (s *SortGivingContext) SAVE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSAVE, 0)
}

func (s *SortGivingContext) NO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNO, 0)
}

func (s *SortGivingContext) REWIND() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREWIND, 0)
}

func (s *SortGivingContext) CRUNCH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCRUNCH, 0)
}

func (s *SortGivingContext) RELEASE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRELEASE, 0)
}

func (s *SortGivingContext) WITH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWITH, 0)
}

func (s *SortGivingContext) REMOVE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREMOVE, 0)
}

func (s *SortGivingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortGivingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortGivingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSortGiving(s)
	}
}

func (s *SortGivingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSortGiving(s)
	}
}

func (p *Cobol85Parser) SortGiving() (localctx ISortGivingContext) {
	localctx = NewSortGivingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 924, Cobol85ParserRULE_sortGiving)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5259)
		p.FileName()
	}
	p.SetState(5269)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 799, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5260)
			p.Match(Cobol85ParserLOCK)
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 799, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(5261)
			p.Match(Cobol85ParserSAVE)
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 799, p.GetParserRuleContext()) == 3 {
		{
			p.SetState(5262)
			p.Match(Cobol85ParserNO)
		}
		{
			p.SetState(5263)
			p.Match(Cobol85ParserREWIND)
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 799, p.GetParserRuleContext()) == 4 {
		{
			p.SetState(5264)
			p.Match(Cobol85ParserCRUNCH)
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 799, p.GetParserRuleContext()) == 5 {
		{
			p.SetState(5265)
			p.Match(Cobol85ParserRELEASE)
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 799, p.GetParserRuleContext()) == 6 {
		{
			p.SetState(5266)
			p.Match(Cobol85ParserWITH)
		}
		{
			p.SetState(5267)
			p.Match(Cobol85ParserREMOVE)
		}
		{
			p.SetState(5268)
			p.Match(Cobol85ParserCRUNCH)
		}

	}

	return localctx
}

// IStartStatementContext is an interface to support dynamic dispatch.
type IStartStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStartStatementContext differentiates from other interfaces.
	IsStartStatementContext()
}

type StartStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStartStatementContext() *StartStatementContext {
	var p = new(StartStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_startStatement
	return p
}

func (*StartStatementContext) IsStartStatementContext() {}

func NewStartStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StartStatementContext {
	var p = new(StartStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_startStatement

	return p
}

func (s *StartStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StartStatementContext) START() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSTART, 0)
}

func (s *StartStatementContext) FileName() IFileNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *StartStatementContext) StartKey() IStartKeyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStartKeyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStartKeyContext)
}

func (s *StartStatementContext) InvalidKeyPhrase() IInvalidKeyPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInvalidKeyPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInvalidKeyPhraseContext)
}

func (s *StartStatementContext) NotInvalidKeyPhrase() INotInvalidKeyPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INotInvalidKeyPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INotInvalidKeyPhraseContext)
}

func (s *StartStatementContext) END_START() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND_START, 0)
}

func (s *StartStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StartStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StartStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterStartStatement(s)
	}
}

func (s *StartStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitStartStatement(s)
	}
}

func (p *Cobol85Parser) StartStatement() (localctx IStartStatementContext) {
	localctx = NewStartStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 926, Cobol85ParserRULE_startStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5271)
		p.Match(Cobol85ParserSTART)
	}
	{
		p.SetState(5272)
		p.FileName()
	}
	p.SetState(5274)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserKEY {
		{
			p.SetState(5273)
			p.StartKey()
		}

	}
	p.SetState(5277)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 801, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5276)
			p.InvalidKeyPhrase()
		}

	}
	p.SetState(5280)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 802, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5279)
			p.NotInvalidKeyPhrase()
		}

	}
	p.SetState(5283)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 803, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5282)
			p.Match(Cobol85ParserEND_START)
		}

	}

	return localctx
}

// IStartKeyContext is an interface to support dynamic dispatch.
type IStartKeyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStartKeyContext differentiates from other interfaces.
	IsStartKeyContext()
}

type StartKeyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStartKeyContext() *StartKeyContext {
	var p = new(StartKeyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_startKey
	return p
}

func (*StartKeyContext) IsStartKeyContext() {}

func NewStartKeyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StartKeyContext {
	var p = new(StartKeyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_startKey

	return p
}

func (s *StartKeyContext) GetParser() antlr.Parser { return s.parser }

func (s *StartKeyContext) KEY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserKEY, 0)
}

func (s *StartKeyContext) QualifiedDataName() IQualifiedDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *StartKeyContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEQUAL, 0)
}

func (s *StartKeyContext) EQUALCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEQUALCHAR, 0)
}

func (s *StartKeyContext) GREATER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserGREATER, 0)
}

func (s *StartKeyContext) MORETHANCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMORETHANCHAR, 0)
}

func (s *StartKeyContext) NOT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNOT, 0)
}

func (s *StartKeyContext) LESS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLESS, 0)
}

func (s *StartKeyContext) LESSTHANCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLESSTHANCHAR, 0)
}

func (s *StartKeyContext) OR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOR, 0)
}

func (s *StartKeyContext) MORETHANOREQUAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMORETHANOREQUAL, 0)
}

func (s *StartKeyContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *StartKeyContext) TO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTO, 0)
}

func (s *StartKeyContext) THAN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHAN, 0)
}

func (s *StartKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StartKeyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StartKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterStartKey(s)
	}
}

func (s *StartKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitStartKey(s)
	}
}

func (p *Cobol85Parser) StartKey() (localctx IStartKeyContext) {
	localctx = NewStartKeyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 928, Cobol85ParserRULE_startKey)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5285)
		p.Match(Cobol85ParserKEY)
	}
	p.SetState(5287)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(5286)
			p.Match(Cobol85ParserIS)
		}

	}
	p.SetState(5316)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 810, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(5289)
			p.Match(Cobol85ParserEQUAL)
		}
		p.SetState(5291)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserTO {
			{
				p.SetState(5290)
				p.Match(Cobol85ParserTO)
			}

		}

	case 2:
		{
			p.SetState(5293)
			p.Match(Cobol85ParserEQUALCHAR)
		}

	case 3:
		{
			p.SetState(5294)
			p.Match(Cobol85ParserGREATER)
		}
		p.SetState(5296)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserTHAN {
			{
				p.SetState(5295)
				p.Match(Cobol85ParserTHAN)
			}

		}

	case 4:
		{
			p.SetState(5298)
			p.Match(Cobol85ParserMORETHANCHAR)
		}

	case 5:
		{
			p.SetState(5299)
			p.Match(Cobol85ParserNOT)
		}
		{
			p.SetState(5300)
			p.Match(Cobol85ParserLESS)
		}
		p.SetState(5302)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserTHAN {
			{
				p.SetState(5301)
				p.Match(Cobol85ParserTHAN)
			}

		}

	case 6:
		{
			p.SetState(5304)
			p.Match(Cobol85ParserNOT)
		}
		{
			p.SetState(5305)
			p.Match(Cobol85ParserLESSTHANCHAR)
		}

	case 7:
		{
			p.SetState(5306)
			p.Match(Cobol85ParserGREATER)
		}
		p.SetState(5308)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserTHAN {
			{
				p.SetState(5307)
				p.Match(Cobol85ParserTHAN)
			}

		}
		{
			p.SetState(5310)
			p.Match(Cobol85ParserOR)
		}
		{
			p.SetState(5311)
			p.Match(Cobol85ParserEQUAL)
		}
		p.SetState(5313)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserTO {
			{
				p.SetState(5312)
				p.Match(Cobol85ParserTO)
			}

		}

	case 8:
		{
			p.SetState(5315)
			p.Match(Cobol85ParserMORETHANOREQUAL)
		}

	}
	{
		p.SetState(5318)
		p.QualifiedDataName()
	}

	return localctx
}

// IStopStatementContext is an interface to support dynamic dispatch.
type IStopStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStopStatementContext differentiates from other interfaces.
	IsStopStatementContext()
}

type StopStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStopStatementContext() *StopStatementContext {
	var p = new(StopStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_stopStatement
	return p
}

func (*StopStatementContext) IsStopStatementContext() {}

func NewStopStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StopStatementContext {
	var p = new(StopStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_stopStatement

	return p
}

func (s *StopStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StopStatementContext) STOP() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSTOP, 0)
}

func (s *StopStatementContext) RUN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRUN, 0)
}

func (s *StopStatementContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *StopStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StopStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StopStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterStopStatement(s)
	}
}

func (s *StopStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitStopStatement(s)
	}
}

func (p *Cobol85Parser) StopStatement() (localctx IStopStatementContext) {
	localctx = NewStopStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 930, Cobol85ParserRULE_stopStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5320)
		p.Match(Cobol85ParserSTOP)
	}
	p.SetState(5323)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserRUN:
		{
			p.SetState(5321)
			p.Match(Cobol85ParserRUN)
		}

	case Cobol85ParserALL, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserFALSE, Cobol85ParserHIGH_VALUE, Cobol85ParserHIGH_VALUES, Cobol85ParserLOW_VALUE, Cobol85ParserLOW_VALUES, Cobol85ParserNULL, Cobol85ParserNULLS, Cobol85ParserQUOTE, Cobol85ParserQUOTES, Cobol85ParserSPACE, Cobol85ParserSPACES, Cobol85ParserTRUE, Cobol85ParserZERO, Cobol85ParserZEROS, Cobol85ParserZEROES, Cobol85ParserNONNUMERICLITERAL, Cobol85ParserLEVEL_NUMBER_66, Cobol85ParserLEVEL_NUMBER_77, Cobol85ParserLEVEL_NUMBER_88, Cobol85ParserINTEGERLITERAL, Cobol85ParserNUMERICLITERAL:
		{
			p.SetState(5322)
			p.Literal()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IStringStatementContext is an interface to support dynamic dispatch.
type IStringStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStringStatementContext differentiates from other interfaces.
	IsStringStatementContext()
}

type StringStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringStatementContext() *StringStatementContext {
	var p = new(StringStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_stringStatement
	return p
}

func (*StringStatementContext) IsStringStatementContext() {}

func NewStringStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringStatementContext {
	var p = new(StringStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_stringStatement

	return p
}

func (s *StringStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StringStatementContext) STRING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSTRING, 0)
}

func (s *StringStatementContext) StringIntoPhrase() IStringIntoPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStringIntoPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStringIntoPhraseContext)
}

func (s *StringStatementContext) AllStringSendingPhrase() []IStringSendingPhraseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStringSendingPhraseContext)(nil)).Elem())
	var tst = make([]IStringSendingPhraseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStringSendingPhraseContext)
		}
	}

	return tst
}

func (s *StringStatementContext) StringSendingPhrase(i int) IStringSendingPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStringSendingPhraseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStringSendingPhraseContext)
}

func (s *StringStatementContext) StringWithPointerPhrase() IStringWithPointerPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStringWithPointerPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStringWithPointerPhraseContext)
}

func (s *StringStatementContext) OnOverflowPhrase() IOnOverflowPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOnOverflowPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOnOverflowPhraseContext)
}

func (s *StringStatementContext) NotOnOverflowPhrase() INotOnOverflowPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INotOnOverflowPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INotOnOverflowPhraseContext)
}

func (s *StringStatementContext) END_STRING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND_STRING, 0)
}

func (s *StringStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterStringStatement(s)
	}
}

func (s *StringStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitStringStatement(s)
	}
}

func (p *Cobol85Parser) StringStatement() (localctx IStringStatementContext) {
	localctx = NewStringStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 932, Cobol85ParserRULE_stringStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5325)
		p.Match(Cobol85ParserSTRING)
	}
	p.SetState(5327)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserADDRESS)|(1<<Cobol85ParserALL)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH)|(1<<Cobol85ParserATTRIBUTE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBINARY-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-68))|(1<<(Cobol85ParserCOBOL-68))|(1<<(Cobol85ParserCOMMITMENT-68))|(1<<(Cobol85ParserCONTROL_POINT-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(Cobol85ParserCONVENTION-100))|(1<<(Cobol85ParserCRUNCH-100))|(1<<(Cobol85ParserCURSOR-100))|(1<<(Cobol85ParserDATE-100))|(1<<(Cobol85ParserDAY-100))|(1<<(Cobol85ParserDAY_OF_WEEK-100))|(1<<(Cobol85ParserDEBUG_CONTENTS-100))|(1<<(Cobol85ParserDEBUG_ITEM-100))|(1<<(Cobol85ParserDEBUG_LINE-100))|(1<<(Cobol85ParserDEBUG_NAME-100))|(1<<(Cobol85ParserDEBUG_SUB_1-100))|(1<<(Cobol85ParserDEBUG_SUB_2-100))|(1<<(Cobol85ParserDEBUG_SUB_3-100))|(1<<(Cobol85ParserDEFAULT-100))|(1<<(Cobol85ParserDEFAULT_DISPLAY-100))|(1<<(Cobol85ParserDEFINITION-100)))) != 0) || (((_la-138)&-(0x1f+1)) == 0 && ((1<<uint((_la-138)))&((1<<(Cobol85ParserDFHRESP-138))|(1<<(Cobol85ParserDFHVALUE-138))|(1<<(Cobol85ParserDISK-138))|(1<<(Cobol85ParserDONTCARE-138))|(1<<(Cobol85ParserDOUBLE-138))|(1<<(Cobol85ParserEBCDIC-138))|(1<<(Cobol85ParserEMPTY_CHECK-138)))) != 0) || (((_la-181)&-(0x1f+1)) == 0 && ((1<<uint((_la-181)))&((1<<(Cobol85ParserENTER-181))|(1<<(Cobol85ParserENTRY_PROCEDURE-181))|(1<<(Cobol85ParserERASE-181))|(1<<(Cobol85ParserEOL-181))|(1<<(Cobol85ParserEOS-181))|(1<<(Cobol85ParserESCAPE-181))|(1<<(Cobol85ParserEVENT-181))|(1<<(Cobol85ParserEXCLUSIVE-181))|(1<<(Cobol85ParserEXPORT-181))|(1<<(Cobol85ParserEXTENDED-181))|(1<<(Cobol85ParserFALSE-181)))) != 0) || (((_la-213)&-(0x1f+1)) == 0 && ((1<<uint((_la-213)))&((1<<(Cobol85ParserFOREGROUND_COLOR-213))|(1<<(Cobol85ParserFOREGROUND_COLOUR-213))|(1<<(Cobol85ParserFULL-213))|(1<<(Cobol85ParserFUNCTION-213))|(1<<(Cobol85ParserFUNCTIONNAME-213))|(1<<(Cobol85ParserFUNCTION_POINTER-213))|(1<<(Cobol85ParserGRID-213))|(1<<(Cobol85ParserHIGHLIGHT-213))|(1<<(Cobol85ParserHIGH_VALUE-213))|(1<<(Cobol85ParserHIGH_VALUES-213))|(1<<(Cobol85ParserIMPLICIT-213))|(1<<(Cobol85ParserIMPORT-213)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(Cobol85ParserINTEGER-250))|(1<<(Cobol85ParserKEPT-250))|(1<<(Cobol85ParserKEYBOARD-250))|(1<<(Cobol85ParserLANGUAGE-250))|(1<<(Cobol85ParserLB-250))|(1<<(Cobol85ParserLD-250))|(1<<(Cobol85ParserLEFTLINE-250))|(1<<(Cobol85ParserLENGTH-250))|(1<<(Cobol85ParserLENGTH_CHECK-250))|(1<<(Cobol85ParserLIBACCESS-250))|(1<<(Cobol85ParserLIBPARAMETER-250))|(1<<(Cobol85ParserLIBRARY-250))|(1<<(Cobol85ParserLINAGE_COUNTER-250))|(1<<(Cobol85ParserLINE_COUNTER-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(Cobol85ParserLIST-283))|(1<<(Cobol85ParserLOCAL-283))|(1<<(Cobol85ParserLONG_DATE-283))|(1<<(Cobol85ParserLONG_TIME-283))|(1<<(Cobol85ParserLOWER-283))|(1<<(Cobol85ParserLOWLIGHT-283))|(1<<(Cobol85ParserLOW_VALUE-283))|(1<<(Cobol85ParserLOW_VALUES-283))|(1<<(Cobol85ParserMMDDYYYY-283))|(1<<(Cobol85ParserNAMED-283))|(1<<(Cobol85ParserNATIONAL-283))|(1<<(Cobol85ParserNATIONAL_EDITED-283))|(1<<(Cobol85ParserNETWORK-283))|(1<<(Cobol85ParserNO_ECHO-283))|(1<<(Cobol85ParserNULL-283))|(1<<(Cobol85ParserNULLS-283)))) != 0) || (((_la-317)&-(0x1f+1)) == 0 && ((1<<uint((_la-317)))&((1<<(Cobol85ParserNUMERIC_DATE-317))|(1<<(Cobol85ParserNUMERIC_TIME-317))|(1<<(Cobol85ParserODT-317))|(1<<(Cobol85ParserORDERLY-317))|(1<<(Cobol85ParserOVERLINE-317))|(1<<(Cobol85ParserOWN-317))|(1<<(Cobol85ParserPAGE_COUNTER-317))|(1<<(Cobol85ParserPASSWORD-317)))) != 0) || (((_la-352)&-(0x1f+1)) == 0 && ((1<<uint((_la-352)))&((1<<(Cobol85ParserPORT-352))|(1<<(Cobol85ParserPRINTER-352))|(1<<(Cobol85ParserPRIVATE-352))|(1<<(Cobol85ParserPROCESS-352))|(1<<(Cobol85ParserPROGRAM-352))|(1<<(Cobol85ParserPROMPT-352))|(1<<(Cobol85ParserQUOTE-352))|(1<<(Cobol85ParserQUOTES-352))|(1<<(Cobol85ParserREADER-352))|(1<<(Cobol85ParserREMOTE-352))|(1<<(Cobol85ParserREAL-352))|(1<<(Cobol85ParserRECEIVED-352))|(1<<(Cobol85ParserRECURSIVE-352))|(1<<(Cobol85ParserREF-352)))) != 0) || (((_la-391)&-(0x1f+1)) == 0 && ((1<<uint((_la-391)))&((1<<(Cobol85ParserREMOVE-391))|(1<<(Cobol85ParserREQUIRED-391))|(1<<(Cobol85ParserREVERSE_VIDEO-391))|(1<<(Cobol85ParserRETURN_CODE-391))|(1<<(Cobol85ParserSAVE-391))|(1<<(Cobol85ParserSECURE-391)))) != 0) || (((_la-431)&-(0x1f+1)) == 0 && ((1<<uint((_la-431)))&((1<<(Cobol85ParserSHARED-431))|(1<<(Cobol85ParserSHAREDBYALL-431))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-431))|(1<<(Cobol85ParserSHARING-431))|(1<<(Cobol85ParserSHIFT_IN-431))|(1<<(Cobol85ParserSHIFT_OUT-431))|(1<<(Cobol85ParserSHORT_DATE-431))|(1<<(Cobol85ParserSORT_CONTROL-431))|(1<<(Cobol85ParserSORT_CORE_SIZE-431))|(1<<(Cobol85ParserSORT_FILE_SIZE-431))|(1<<(Cobol85ParserSORT_MESSAGE-431))|(1<<(Cobol85ParserSORT_MODE_SIZE-431))|(1<<(Cobol85ParserSORT_RETURN-431))|(1<<(Cobol85ParserSPACE-431))|(1<<(Cobol85ParserSPACES-431)))) != 0) || (((_la-466)&-(0x1f+1)) == 0 && ((1<<uint((_la-466)))&((1<<(Cobol85ParserSYMBOL-466))|(1<<(Cobol85ParserTALLY-466))|(1<<(Cobol85ParserTASK-466))|(1<<(Cobol85ParserTHREAD-466))|(1<<(Cobol85ParserTHREAD_LOCAL-466))|(1<<(Cobol85ParserTIME-466))|(1<<(Cobol85ParserTIMER-466))|(1<<(Cobol85ParserTODAYS_DATE-466))|(1<<(Cobol85ParserTODAYS_NAME-466))|(1<<(Cobol85ParserTRUE-466))|(1<<(Cobol85ParserTRUNCATED-466))|(1<<(Cobol85ParserTYPEDEF-466)))) != 0) || (((_la-498)&-(0x1f+1)) == 0 && ((1<<uint((_la-498)))&((1<<(Cobol85ParserUNDERLINE-498))|(1<<(Cobol85ParserVIRTUAL-498))|(1<<(Cobol85ParserWAIT-498))|(1<<(Cobol85ParserWHEN_COMPILED-498))|(1<<(Cobol85ParserYEAR-498))|(1<<(Cobol85ParserYYYYMMDD-498))|(1<<(Cobol85ParserYYYYDDD-498))|(1<<(Cobol85ParserZERO-498))|(1<<(Cobol85ParserZERO_FILL-498))|(1<<(Cobol85ParserZEROS-498))|(1<<(Cobol85ParserZEROES-498)))) != 0) || (((_la-551)&-(0x1f+1)) == 0 && ((1<<uint((_la-551)))&((1<<(Cobol85ParserNONNUMERICLITERAL-551))|(1<<(Cobol85ParserLEVEL_NUMBER_66-551))|(1<<(Cobol85ParserLEVEL_NUMBER_77-551))|(1<<(Cobol85ParserLEVEL_NUMBER_88-551))|(1<<(Cobol85ParserINTEGERLITERAL-551))|(1<<(Cobol85ParserNUMERICLITERAL-551))|(1<<(Cobol85ParserIDENTIFIER-551)))) != 0) {
		{
			p.SetState(5326)
			p.StringSendingPhrase()
		}

		p.SetState(5329)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(5331)
		p.StringIntoPhrase()
	}
	p.SetState(5333)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 813, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5332)
			p.StringWithPointerPhrase()
		}

	}
	p.SetState(5336)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 814, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5335)
			p.OnOverflowPhrase()
		}

	}
	p.SetState(5339)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 815, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5338)
			p.NotOnOverflowPhrase()
		}

	}
	p.SetState(5342)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 816, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5341)
			p.Match(Cobol85ParserEND_STRING)
		}

	}

	return localctx
}

// IStringSendingPhraseContext is an interface to support dynamic dispatch.
type IStringSendingPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStringSendingPhraseContext differentiates from other interfaces.
	IsStringSendingPhraseContext()
}

type StringSendingPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringSendingPhraseContext() *StringSendingPhraseContext {
	var p = new(StringSendingPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_stringSendingPhrase
	return p
}

func (*StringSendingPhraseContext) IsStringSendingPhraseContext() {}

func NewStringSendingPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringSendingPhraseContext {
	var p = new(StringSendingPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_stringSendingPhrase

	return p
}

func (s *StringSendingPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *StringSendingPhraseContext) StringDelimitedByPhrase() IStringDelimitedByPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStringDelimitedByPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStringDelimitedByPhraseContext)
}

func (s *StringSendingPhraseContext) StringForPhrase() IStringForPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStringForPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStringForPhraseContext)
}

func (s *StringSendingPhraseContext) AllStringSending() []IStringSendingContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStringSendingContext)(nil)).Elem())
	var tst = make([]IStringSendingContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStringSendingContext)
		}
	}

	return tst
}

func (s *StringSendingPhraseContext) StringSending(i int) IStringSendingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStringSendingContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStringSendingContext)
}

func (s *StringSendingPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringSendingPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringSendingPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterStringSendingPhrase(s)
	}
}

func (s *StringSendingPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitStringSendingPhrase(s)
	}
}

func (p *Cobol85Parser) StringSendingPhrase() (localctx IStringSendingPhraseContext) {
	localctx = NewStringSendingPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 934, Cobol85ParserRULE_stringSendingPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5345)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserADDRESS)|(1<<Cobol85ParserALL)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH)|(1<<Cobol85ParserATTRIBUTE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBINARY-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-68))|(1<<(Cobol85ParserCOBOL-68))|(1<<(Cobol85ParserCOMMITMENT-68))|(1<<(Cobol85ParserCONTROL_POINT-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(Cobol85ParserCONVENTION-100))|(1<<(Cobol85ParserCRUNCH-100))|(1<<(Cobol85ParserCURSOR-100))|(1<<(Cobol85ParserDATE-100))|(1<<(Cobol85ParserDAY-100))|(1<<(Cobol85ParserDAY_OF_WEEK-100))|(1<<(Cobol85ParserDEBUG_CONTENTS-100))|(1<<(Cobol85ParserDEBUG_ITEM-100))|(1<<(Cobol85ParserDEBUG_LINE-100))|(1<<(Cobol85ParserDEBUG_NAME-100))|(1<<(Cobol85ParserDEBUG_SUB_1-100))|(1<<(Cobol85ParserDEBUG_SUB_2-100))|(1<<(Cobol85ParserDEBUG_SUB_3-100))|(1<<(Cobol85ParserDEFAULT-100))|(1<<(Cobol85ParserDEFAULT_DISPLAY-100))|(1<<(Cobol85ParserDEFINITION-100)))) != 0) || (((_la-138)&-(0x1f+1)) == 0 && ((1<<uint((_la-138)))&((1<<(Cobol85ParserDFHRESP-138))|(1<<(Cobol85ParserDFHVALUE-138))|(1<<(Cobol85ParserDISK-138))|(1<<(Cobol85ParserDONTCARE-138))|(1<<(Cobol85ParserDOUBLE-138))|(1<<(Cobol85ParserEBCDIC-138))|(1<<(Cobol85ParserEMPTY_CHECK-138)))) != 0) || (((_la-181)&-(0x1f+1)) == 0 && ((1<<uint((_la-181)))&((1<<(Cobol85ParserENTER-181))|(1<<(Cobol85ParserENTRY_PROCEDURE-181))|(1<<(Cobol85ParserERASE-181))|(1<<(Cobol85ParserEOL-181))|(1<<(Cobol85ParserEOS-181))|(1<<(Cobol85ParserESCAPE-181))|(1<<(Cobol85ParserEVENT-181))|(1<<(Cobol85ParserEXCLUSIVE-181))|(1<<(Cobol85ParserEXPORT-181))|(1<<(Cobol85ParserEXTENDED-181))|(1<<(Cobol85ParserFALSE-181)))) != 0) || (((_la-213)&-(0x1f+1)) == 0 && ((1<<uint((_la-213)))&((1<<(Cobol85ParserFOREGROUND_COLOR-213))|(1<<(Cobol85ParserFOREGROUND_COLOUR-213))|(1<<(Cobol85ParserFULL-213))|(1<<(Cobol85ParserFUNCTION-213))|(1<<(Cobol85ParserFUNCTIONNAME-213))|(1<<(Cobol85ParserFUNCTION_POINTER-213))|(1<<(Cobol85ParserGRID-213))|(1<<(Cobol85ParserHIGHLIGHT-213))|(1<<(Cobol85ParserHIGH_VALUE-213))|(1<<(Cobol85ParserHIGH_VALUES-213))|(1<<(Cobol85ParserIMPLICIT-213))|(1<<(Cobol85ParserIMPORT-213)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(Cobol85ParserINTEGER-250))|(1<<(Cobol85ParserKEPT-250))|(1<<(Cobol85ParserKEYBOARD-250))|(1<<(Cobol85ParserLANGUAGE-250))|(1<<(Cobol85ParserLB-250))|(1<<(Cobol85ParserLD-250))|(1<<(Cobol85ParserLEFTLINE-250))|(1<<(Cobol85ParserLENGTH-250))|(1<<(Cobol85ParserLENGTH_CHECK-250))|(1<<(Cobol85ParserLIBACCESS-250))|(1<<(Cobol85ParserLIBPARAMETER-250))|(1<<(Cobol85ParserLIBRARY-250))|(1<<(Cobol85ParserLINAGE_COUNTER-250))|(1<<(Cobol85ParserLINE_COUNTER-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(Cobol85ParserLIST-283))|(1<<(Cobol85ParserLOCAL-283))|(1<<(Cobol85ParserLONG_DATE-283))|(1<<(Cobol85ParserLONG_TIME-283))|(1<<(Cobol85ParserLOWER-283))|(1<<(Cobol85ParserLOWLIGHT-283))|(1<<(Cobol85ParserLOW_VALUE-283))|(1<<(Cobol85ParserLOW_VALUES-283))|(1<<(Cobol85ParserMMDDYYYY-283))|(1<<(Cobol85ParserNAMED-283))|(1<<(Cobol85ParserNATIONAL-283))|(1<<(Cobol85ParserNATIONAL_EDITED-283))|(1<<(Cobol85ParserNETWORK-283))|(1<<(Cobol85ParserNO_ECHO-283))|(1<<(Cobol85ParserNULL-283))|(1<<(Cobol85ParserNULLS-283)))) != 0) || (((_la-317)&-(0x1f+1)) == 0 && ((1<<uint((_la-317)))&((1<<(Cobol85ParserNUMERIC_DATE-317))|(1<<(Cobol85ParserNUMERIC_TIME-317))|(1<<(Cobol85ParserODT-317))|(1<<(Cobol85ParserORDERLY-317))|(1<<(Cobol85ParserOVERLINE-317))|(1<<(Cobol85ParserOWN-317))|(1<<(Cobol85ParserPAGE_COUNTER-317))|(1<<(Cobol85ParserPASSWORD-317)))) != 0) || (((_la-352)&-(0x1f+1)) == 0 && ((1<<uint((_la-352)))&((1<<(Cobol85ParserPORT-352))|(1<<(Cobol85ParserPRINTER-352))|(1<<(Cobol85ParserPRIVATE-352))|(1<<(Cobol85ParserPROCESS-352))|(1<<(Cobol85ParserPROGRAM-352))|(1<<(Cobol85ParserPROMPT-352))|(1<<(Cobol85ParserQUOTE-352))|(1<<(Cobol85ParserQUOTES-352))|(1<<(Cobol85ParserREADER-352))|(1<<(Cobol85ParserREMOTE-352))|(1<<(Cobol85ParserREAL-352))|(1<<(Cobol85ParserRECEIVED-352))|(1<<(Cobol85ParserRECURSIVE-352))|(1<<(Cobol85ParserREF-352)))) != 0) || (((_la-391)&-(0x1f+1)) == 0 && ((1<<uint((_la-391)))&((1<<(Cobol85ParserREMOVE-391))|(1<<(Cobol85ParserREQUIRED-391))|(1<<(Cobol85ParserREVERSE_VIDEO-391))|(1<<(Cobol85ParserRETURN_CODE-391))|(1<<(Cobol85ParserSAVE-391))|(1<<(Cobol85ParserSECURE-391)))) != 0) || (((_la-431)&-(0x1f+1)) == 0 && ((1<<uint((_la-431)))&((1<<(Cobol85ParserSHARED-431))|(1<<(Cobol85ParserSHAREDBYALL-431))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-431))|(1<<(Cobol85ParserSHARING-431))|(1<<(Cobol85ParserSHIFT_IN-431))|(1<<(Cobol85ParserSHIFT_OUT-431))|(1<<(Cobol85ParserSHORT_DATE-431))|(1<<(Cobol85ParserSORT_CONTROL-431))|(1<<(Cobol85ParserSORT_CORE_SIZE-431))|(1<<(Cobol85ParserSORT_FILE_SIZE-431))|(1<<(Cobol85ParserSORT_MESSAGE-431))|(1<<(Cobol85ParserSORT_MODE_SIZE-431))|(1<<(Cobol85ParserSORT_RETURN-431))|(1<<(Cobol85ParserSPACE-431))|(1<<(Cobol85ParserSPACES-431)))) != 0) || (((_la-466)&-(0x1f+1)) == 0 && ((1<<uint((_la-466)))&((1<<(Cobol85ParserSYMBOL-466))|(1<<(Cobol85ParserTALLY-466))|(1<<(Cobol85ParserTASK-466))|(1<<(Cobol85ParserTHREAD-466))|(1<<(Cobol85ParserTHREAD_LOCAL-466))|(1<<(Cobol85ParserTIME-466))|(1<<(Cobol85ParserTIMER-466))|(1<<(Cobol85ParserTODAYS_DATE-466))|(1<<(Cobol85ParserTODAYS_NAME-466))|(1<<(Cobol85ParserTRUE-466))|(1<<(Cobol85ParserTRUNCATED-466))|(1<<(Cobol85ParserTYPEDEF-466)))) != 0) || (((_la-498)&-(0x1f+1)) == 0 && ((1<<uint((_la-498)))&((1<<(Cobol85ParserUNDERLINE-498))|(1<<(Cobol85ParserVIRTUAL-498))|(1<<(Cobol85ParserWAIT-498))|(1<<(Cobol85ParserWHEN_COMPILED-498))|(1<<(Cobol85ParserYEAR-498))|(1<<(Cobol85ParserYYYYMMDD-498))|(1<<(Cobol85ParserYYYYDDD-498))|(1<<(Cobol85ParserZERO-498))|(1<<(Cobol85ParserZERO_FILL-498))|(1<<(Cobol85ParserZEROS-498))|(1<<(Cobol85ParserZEROES-498)))) != 0) || (((_la-551)&-(0x1f+1)) == 0 && ((1<<uint((_la-551)))&((1<<(Cobol85ParserNONNUMERICLITERAL-551))|(1<<(Cobol85ParserLEVEL_NUMBER_66-551))|(1<<(Cobol85ParserLEVEL_NUMBER_77-551))|(1<<(Cobol85ParserLEVEL_NUMBER_88-551))|(1<<(Cobol85ParserINTEGERLITERAL-551))|(1<<(Cobol85ParserNUMERICLITERAL-551))|(1<<(Cobol85ParserIDENTIFIER-551)))) != 0) {
		{
			p.SetState(5344)
			p.StringSending()
		}

		p.SetState(5347)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(5351)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserDELIMITED:
		{
			p.SetState(5349)
			p.StringDelimitedByPhrase()
		}

	case Cobol85ParserFOR:
		{
			p.SetState(5350)
			p.StringForPhrase()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IStringSendingContext is an interface to support dynamic dispatch.
type IStringSendingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStringSendingContext differentiates from other interfaces.
	IsStringSendingContext()
}

type StringSendingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringSendingContext() *StringSendingContext {
	var p = new(StringSendingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_stringSending
	return p
}

func (*StringSendingContext) IsStringSendingContext() {}

func NewStringSendingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringSendingContext {
	var p = new(StringSendingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_stringSending

	return p
}

func (s *StringSendingContext) GetParser() antlr.Parser { return s.parser }

func (s *StringSendingContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *StringSendingContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *StringSendingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringSendingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringSendingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterStringSending(s)
	}
}

func (s *StringSendingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitStringSending(s)
	}
}

func (p *Cobol85Parser) StringSending() (localctx IStringSendingContext) {
	localctx = NewStringSendingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 936, Cobol85ParserRULE_stringSending)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5355)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 819, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5353)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5354)
			p.Literal()
		}

	}

	return localctx
}

// IStringDelimitedByPhraseContext is an interface to support dynamic dispatch.
type IStringDelimitedByPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStringDelimitedByPhraseContext differentiates from other interfaces.
	IsStringDelimitedByPhraseContext()
}

type StringDelimitedByPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringDelimitedByPhraseContext() *StringDelimitedByPhraseContext {
	var p = new(StringDelimitedByPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_stringDelimitedByPhrase
	return p
}

func (*StringDelimitedByPhraseContext) IsStringDelimitedByPhraseContext() {}

func NewStringDelimitedByPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringDelimitedByPhraseContext {
	var p = new(StringDelimitedByPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_stringDelimitedByPhrase

	return p
}

func (s *StringDelimitedByPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *StringDelimitedByPhraseContext) DELIMITED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDELIMITED, 0)
}

func (s *StringDelimitedByPhraseContext) SIZE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSIZE, 0)
}

func (s *StringDelimitedByPhraseContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *StringDelimitedByPhraseContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *StringDelimitedByPhraseContext) BY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBY, 0)
}

func (s *StringDelimitedByPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringDelimitedByPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringDelimitedByPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterStringDelimitedByPhrase(s)
	}
}

func (s *StringDelimitedByPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitStringDelimitedByPhrase(s)
	}
}

func (p *Cobol85Parser) StringDelimitedByPhrase() (localctx IStringDelimitedByPhraseContext) {
	localctx = NewStringDelimitedByPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 938, Cobol85ParserRULE_stringDelimitedByPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5357)
		p.Match(Cobol85ParserDELIMITED)
	}
	p.SetState(5359)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserBY {
		{
			p.SetState(5358)
			p.Match(Cobol85ParserBY)
		}

	}
	p.SetState(5364)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 821, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(5361)
			p.Match(Cobol85ParserSIZE)
		}

	case 2:
		{
			p.SetState(5362)
			p.Identifier()
		}

	case 3:
		{
			p.SetState(5363)
			p.Literal()
		}

	}

	return localctx
}

// IStringForPhraseContext is an interface to support dynamic dispatch.
type IStringForPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStringForPhraseContext differentiates from other interfaces.
	IsStringForPhraseContext()
}

type StringForPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringForPhraseContext() *StringForPhraseContext {
	var p = new(StringForPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_stringForPhrase
	return p
}

func (*StringForPhraseContext) IsStringForPhraseContext() {}

func NewStringForPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringForPhraseContext {
	var p = new(StringForPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_stringForPhrase

	return p
}

func (s *StringForPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *StringForPhraseContext) FOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOR, 0)
}

func (s *StringForPhraseContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *StringForPhraseContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *StringForPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringForPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringForPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterStringForPhrase(s)
	}
}

func (s *StringForPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitStringForPhrase(s)
	}
}

func (p *Cobol85Parser) StringForPhrase() (localctx IStringForPhraseContext) {
	localctx = NewStringForPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 940, Cobol85ParserRULE_stringForPhrase)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5366)
		p.Match(Cobol85ParserFOR)
	}
	p.SetState(5369)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 822, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(5367)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(5368)
			p.Literal()
		}

	}

	return localctx
}

// IStringIntoPhraseContext is an interface to support dynamic dispatch.
type IStringIntoPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStringIntoPhraseContext differentiates from other interfaces.
	IsStringIntoPhraseContext()
}

type StringIntoPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringIntoPhraseContext() *StringIntoPhraseContext {
	var p = new(StringIntoPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_stringIntoPhrase
	return p
}

func (*StringIntoPhraseContext) IsStringIntoPhraseContext() {}

func NewStringIntoPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringIntoPhraseContext {
	var p = new(StringIntoPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_stringIntoPhrase

	return p
}

func (s *StringIntoPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *StringIntoPhraseContext) INTO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINTO, 0)
}

func (s *StringIntoPhraseContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *StringIntoPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringIntoPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringIntoPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterStringIntoPhrase(s)
	}
}

func (s *StringIntoPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitStringIntoPhrase(s)
	}
}

func (p *Cobol85Parser) StringIntoPhrase() (localctx IStringIntoPhraseContext) {
	localctx = NewStringIntoPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 942, Cobol85ParserRULE_stringIntoPhrase)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5371)
		p.Match(Cobol85ParserINTO)
	}
	{
		p.SetState(5372)
		p.Identifier()
	}

	return localctx
}

// IStringWithPointerPhraseContext is an interface to support dynamic dispatch.
type IStringWithPointerPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStringWithPointerPhraseContext differentiates from other interfaces.
	IsStringWithPointerPhraseContext()
}

type StringWithPointerPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringWithPointerPhraseContext() *StringWithPointerPhraseContext {
	var p = new(StringWithPointerPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_stringWithPointerPhrase
	return p
}

func (*StringWithPointerPhraseContext) IsStringWithPointerPhraseContext() {}

func NewStringWithPointerPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringWithPointerPhraseContext {
	var p = new(StringWithPointerPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_stringWithPointerPhrase

	return p
}

func (s *StringWithPointerPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *StringWithPointerPhraseContext) POINTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPOINTER, 0)
}

func (s *StringWithPointerPhraseContext) QualifiedDataName() IQualifiedDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *StringWithPointerPhraseContext) WITH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWITH, 0)
}

func (s *StringWithPointerPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringWithPointerPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringWithPointerPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterStringWithPointerPhrase(s)
	}
}

func (s *StringWithPointerPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitStringWithPointerPhrase(s)
	}
}

func (p *Cobol85Parser) StringWithPointerPhrase() (localctx IStringWithPointerPhraseContext) {
	localctx = NewStringWithPointerPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 944, Cobol85ParserRULE_stringWithPointerPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5375)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserWITH {
		{
			p.SetState(5374)
			p.Match(Cobol85ParserWITH)
		}

	}
	{
		p.SetState(5377)
		p.Match(Cobol85ParserPOINTER)
	}
	{
		p.SetState(5378)
		p.QualifiedDataName()
	}

	return localctx
}

// ISubtractStatementContext is an interface to support dynamic dispatch.
type ISubtractStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubtractStatementContext differentiates from other interfaces.
	IsSubtractStatementContext()
}

type SubtractStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubtractStatementContext() *SubtractStatementContext {
	var p = new(SubtractStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_subtractStatement
	return p
}

func (*SubtractStatementContext) IsSubtractStatementContext() {}

func NewSubtractStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubtractStatementContext {
	var p = new(SubtractStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_subtractStatement

	return p
}

func (s *SubtractStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SubtractStatementContext) SUBTRACT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSUBTRACT, 0)
}

func (s *SubtractStatementContext) SubtractFromStatement() ISubtractFromStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtractFromStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtractFromStatementContext)
}

func (s *SubtractStatementContext) SubtractFromGivingStatement() ISubtractFromGivingStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtractFromGivingStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtractFromGivingStatementContext)
}

func (s *SubtractStatementContext) SubtractCorrespondingStatement() ISubtractCorrespondingStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtractCorrespondingStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtractCorrespondingStatementContext)
}

func (s *SubtractStatementContext) OnSizeErrorPhrase() IOnSizeErrorPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOnSizeErrorPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOnSizeErrorPhraseContext)
}

func (s *SubtractStatementContext) NotOnSizeErrorPhrase() INotOnSizeErrorPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INotOnSizeErrorPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INotOnSizeErrorPhraseContext)
}

func (s *SubtractStatementContext) END_SUBTRACT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND_SUBTRACT, 0)
}

func (s *SubtractStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubtractStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubtractStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSubtractStatement(s)
	}
}

func (s *SubtractStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSubtractStatement(s)
	}
}

func (p *Cobol85Parser) SubtractStatement() (localctx ISubtractStatementContext) {
	localctx = NewSubtractStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 946, Cobol85ParserRULE_subtractStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5380)
		p.Match(Cobol85ParserSUBTRACT)
	}
	p.SetState(5384)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 824, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(5381)
			p.SubtractFromStatement()
		}

	case 2:
		{
			p.SetState(5382)
			p.SubtractFromGivingStatement()
		}

	case 3:
		{
			p.SetState(5383)
			p.SubtractCorrespondingStatement()
		}

	}
	p.SetState(5387)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 825, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5386)
			p.OnSizeErrorPhrase()
		}

	}
	p.SetState(5390)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 826, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5389)
			p.NotOnSizeErrorPhrase()
		}

	}
	p.SetState(5393)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 827, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5392)
			p.Match(Cobol85ParserEND_SUBTRACT)
		}

	}

	return localctx
}

// ISubtractFromStatementContext is an interface to support dynamic dispatch.
type ISubtractFromStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubtractFromStatementContext differentiates from other interfaces.
	IsSubtractFromStatementContext()
}

type SubtractFromStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubtractFromStatementContext() *SubtractFromStatementContext {
	var p = new(SubtractFromStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_subtractFromStatement
	return p
}

func (*SubtractFromStatementContext) IsSubtractFromStatementContext() {}

func NewSubtractFromStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubtractFromStatementContext {
	var p = new(SubtractFromStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_subtractFromStatement

	return p
}

func (s *SubtractFromStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SubtractFromStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFROM, 0)
}

func (s *SubtractFromStatementContext) AllSubtractSubtrahend() []ISubtractSubtrahendContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISubtractSubtrahendContext)(nil)).Elem())
	var tst = make([]ISubtractSubtrahendContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISubtractSubtrahendContext)
		}
	}

	return tst
}

func (s *SubtractFromStatementContext) SubtractSubtrahend(i int) ISubtractSubtrahendContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtractSubtrahendContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISubtractSubtrahendContext)
}

func (s *SubtractFromStatementContext) AllSubtractMinuend() []ISubtractMinuendContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISubtractMinuendContext)(nil)).Elem())
	var tst = make([]ISubtractMinuendContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISubtractMinuendContext)
		}
	}

	return tst
}

func (s *SubtractFromStatementContext) SubtractMinuend(i int) ISubtractMinuendContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtractMinuendContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISubtractMinuendContext)
}

func (s *SubtractFromStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubtractFromStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubtractFromStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSubtractFromStatement(s)
	}
}

func (s *SubtractFromStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSubtractFromStatement(s)
	}
}

func (p *Cobol85Parser) SubtractFromStatement() (localctx ISubtractFromStatementContext) {
	localctx = NewSubtractFromStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 948, Cobol85ParserRULE_subtractFromStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5396)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserADDRESS)|(1<<Cobol85ParserALL)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH)|(1<<Cobol85ParserATTRIBUTE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBINARY-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-68))|(1<<(Cobol85ParserCOBOL-68))|(1<<(Cobol85ParserCOMMITMENT-68))|(1<<(Cobol85ParserCONTROL_POINT-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(Cobol85ParserCONVENTION-100))|(1<<(Cobol85ParserCRUNCH-100))|(1<<(Cobol85ParserCURSOR-100))|(1<<(Cobol85ParserDATE-100))|(1<<(Cobol85ParserDAY-100))|(1<<(Cobol85ParserDAY_OF_WEEK-100))|(1<<(Cobol85ParserDEBUG_CONTENTS-100))|(1<<(Cobol85ParserDEBUG_ITEM-100))|(1<<(Cobol85ParserDEBUG_LINE-100))|(1<<(Cobol85ParserDEBUG_NAME-100))|(1<<(Cobol85ParserDEBUG_SUB_1-100))|(1<<(Cobol85ParserDEBUG_SUB_2-100))|(1<<(Cobol85ParserDEBUG_SUB_3-100))|(1<<(Cobol85ParserDEFAULT-100))|(1<<(Cobol85ParserDEFAULT_DISPLAY-100))|(1<<(Cobol85ParserDEFINITION-100)))) != 0) || (((_la-138)&-(0x1f+1)) == 0 && ((1<<uint((_la-138)))&((1<<(Cobol85ParserDFHRESP-138))|(1<<(Cobol85ParserDFHVALUE-138))|(1<<(Cobol85ParserDISK-138))|(1<<(Cobol85ParserDONTCARE-138))|(1<<(Cobol85ParserDOUBLE-138))|(1<<(Cobol85ParserEBCDIC-138))|(1<<(Cobol85ParserEMPTY_CHECK-138)))) != 0) || (((_la-181)&-(0x1f+1)) == 0 && ((1<<uint((_la-181)))&((1<<(Cobol85ParserENTER-181))|(1<<(Cobol85ParserENTRY_PROCEDURE-181))|(1<<(Cobol85ParserERASE-181))|(1<<(Cobol85ParserEOL-181))|(1<<(Cobol85ParserEOS-181))|(1<<(Cobol85ParserESCAPE-181))|(1<<(Cobol85ParserEVENT-181))|(1<<(Cobol85ParserEXCLUSIVE-181))|(1<<(Cobol85ParserEXPORT-181))|(1<<(Cobol85ParserEXTENDED-181))|(1<<(Cobol85ParserFALSE-181)))) != 0) || (((_la-213)&-(0x1f+1)) == 0 && ((1<<uint((_la-213)))&((1<<(Cobol85ParserFOREGROUND_COLOR-213))|(1<<(Cobol85ParserFOREGROUND_COLOUR-213))|(1<<(Cobol85ParserFULL-213))|(1<<(Cobol85ParserFUNCTION-213))|(1<<(Cobol85ParserFUNCTIONNAME-213))|(1<<(Cobol85ParserFUNCTION_POINTER-213))|(1<<(Cobol85ParserGRID-213))|(1<<(Cobol85ParserHIGHLIGHT-213))|(1<<(Cobol85ParserHIGH_VALUE-213))|(1<<(Cobol85ParserHIGH_VALUES-213))|(1<<(Cobol85ParserIMPLICIT-213))|(1<<(Cobol85ParserIMPORT-213)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(Cobol85ParserINTEGER-250))|(1<<(Cobol85ParserKEPT-250))|(1<<(Cobol85ParserKEYBOARD-250))|(1<<(Cobol85ParserLANGUAGE-250))|(1<<(Cobol85ParserLB-250))|(1<<(Cobol85ParserLD-250))|(1<<(Cobol85ParserLEFTLINE-250))|(1<<(Cobol85ParserLENGTH-250))|(1<<(Cobol85ParserLENGTH_CHECK-250))|(1<<(Cobol85ParserLIBACCESS-250))|(1<<(Cobol85ParserLIBPARAMETER-250))|(1<<(Cobol85ParserLIBRARY-250))|(1<<(Cobol85ParserLINAGE_COUNTER-250))|(1<<(Cobol85ParserLINE_COUNTER-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(Cobol85ParserLIST-283))|(1<<(Cobol85ParserLOCAL-283))|(1<<(Cobol85ParserLONG_DATE-283))|(1<<(Cobol85ParserLONG_TIME-283))|(1<<(Cobol85ParserLOWER-283))|(1<<(Cobol85ParserLOWLIGHT-283))|(1<<(Cobol85ParserLOW_VALUE-283))|(1<<(Cobol85ParserLOW_VALUES-283))|(1<<(Cobol85ParserMMDDYYYY-283))|(1<<(Cobol85ParserNAMED-283))|(1<<(Cobol85ParserNATIONAL-283))|(1<<(Cobol85ParserNATIONAL_EDITED-283))|(1<<(Cobol85ParserNETWORK-283))|(1<<(Cobol85ParserNO_ECHO-283))|(1<<(Cobol85ParserNULL-283))|(1<<(Cobol85ParserNULLS-283)))) != 0) || (((_la-317)&-(0x1f+1)) == 0 && ((1<<uint((_la-317)))&((1<<(Cobol85ParserNUMERIC_DATE-317))|(1<<(Cobol85ParserNUMERIC_TIME-317))|(1<<(Cobol85ParserODT-317))|(1<<(Cobol85ParserORDERLY-317))|(1<<(Cobol85ParserOVERLINE-317))|(1<<(Cobol85ParserOWN-317))|(1<<(Cobol85ParserPAGE_COUNTER-317))|(1<<(Cobol85ParserPASSWORD-317)))) != 0) || (((_la-352)&-(0x1f+1)) == 0 && ((1<<uint((_la-352)))&((1<<(Cobol85ParserPORT-352))|(1<<(Cobol85ParserPRINTER-352))|(1<<(Cobol85ParserPRIVATE-352))|(1<<(Cobol85ParserPROCESS-352))|(1<<(Cobol85ParserPROGRAM-352))|(1<<(Cobol85ParserPROMPT-352))|(1<<(Cobol85ParserQUOTE-352))|(1<<(Cobol85ParserQUOTES-352))|(1<<(Cobol85ParserREADER-352))|(1<<(Cobol85ParserREMOTE-352))|(1<<(Cobol85ParserREAL-352))|(1<<(Cobol85ParserRECEIVED-352))|(1<<(Cobol85ParserRECURSIVE-352))|(1<<(Cobol85ParserREF-352)))) != 0) || (((_la-391)&-(0x1f+1)) == 0 && ((1<<uint((_la-391)))&((1<<(Cobol85ParserREMOVE-391))|(1<<(Cobol85ParserREQUIRED-391))|(1<<(Cobol85ParserREVERSE_VIDEO-391))|(1<<(Cobol85ParserRETURN_CODE-391))|(1<<(Cobol85ParserSAVE-391))|(1<<(Cobol85ParserSECURE-391)))) != 0) || (((_la-431)&-(0x1f+1)) == 0 && ((1<<uint((_la-431)))&((1<<(Cobol85ParserSHARED-431))|(1<<(Cobol85ParserSHAREDBYALL-431))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-431))|(1<<(Cobol85ParserSHARING-431))|(1<<(Cobol85ParserSHIFT_IN-431))|(1<<(Cobol85ParserSHIFT_OUT-431))|(1<<(Cobol85ParserSHORT_DATE-431))|(1<<(Cobol85ParserSORT_CONTROL-431))|(1<<(Cobol85ParserSORT_CORE_SIZE-431))|(1<<(Cobol85ParserSORT_FILE_SIZE-431))|(1<<(Cobol85ParserSORT_MESSAGE-431))|(1<<(Cobol85ParserSORT_MODE_SIZE-431))|(1<<(Cobol85ParserSORT_RETURN-431))|(1<<(Cobol85ParserSPACE-431))|(1<<(Cobol85ParserSPACES-431)))) != 0) || (((_la-466)&-(0x1f+1)) == 0 && ((1<<uint((_la-466)))&((1<<(Cobol85ParserSYMBOL-466))|(1<<(Cobol85ParserTALLY-466))|(1<<(Cobol85ParserTASK-466))|(1<<(Cobol85ParserTHREAD-466))|(1<<(Cobol85ParserTHREAD_LOCAL-466))|(1<<(Cobol85ParserTIME-466))|(1<<(Cobol85ParserTIMER-466))|(1<<(Cobol85ParserTODAYS_DATE-466))|(1<<(Cobol85ParserTODAYS_NAME-466))|(1<<(Cobol85ParserTRUE-466))|(1<<(Cobol85ParserTRUNCATED-466))|(1<<(Cobol85ParserTYPEDEF-466)))) != 0) || (((_la-498)&-(0x1f+1)) == 0 && ((1<<uint((_la-498)))&((1<<(Cobol85ParserUNDERLINE-498))|(1<<(Cobol85ParserVIRTUAL-498))|(1<<(Cobol85ParserWAIT-498))|(1<<(Cobol85ParserWHEN_COMPILED-498))|(1<<(Cobol85ParserYEAR-498))|(1<<(Cobol85ParserYYYYMMDD-498))|(1<<(Cobol85ParserYYYYDDD-498))|(1<<(Cobol85ParserZERO-498))|(1<<(Cobol85ParserZERO_FILL-498))|(1<<(Cobol85ParserZEROS-498))|(1<<(Cobol85ParserZEROES-498)))) != 0) || (((_la-551)&-(0x1f+1)) == 0 && ((1<<uint((_la-551)))&((1<<(Cobol85ParserNONNUMERICLITERAL-551))|(1<<(Cobol85ParserLEVEL_NUMBER_66-551))|(1<<(Cobol85ParserLEVEL_NUMBER_77-551))|(1<<(Cobol85ParserLEVEL_NUMBER_88-551))|(1<<(Cobol85ParserINTEGERLITERAL-551))|(1<<(Cobol85ParserNUMERICLITERAL-551))|(1<<(Cobol85ParserIDENTIFIER-551)))) != 0) {
		{
			p.SetState(5395)
			p.SubtractSubtrahend()
		}

		p.SetState(5398)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(5400)
		p.Match(Cobol85ParserFROM)
	}
	p.SetState(5402)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserADDRESS)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH)|(1<<Cobol85ParserATTRIBUTE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBINARY-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-68))|(1<<(Cobol85ParserCOBOL-68))|(1<<(Cobol85ParserCOMMITMENT-68))|(1<<(Cobol85ParserCONTROL_POINT-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(Cobol85ParserCONVENTION-100))|(1<<(Cobol85ParserCRUNCH-100))|(1<<(Cobol85ParserCURSOR-100))|(1<<(Cobol85ParserDATE-100))|(1<<(Cobol85ParserDAY-100))|(1<<(Cobol85ParserDAY_OF_WEEK-100))|(1<<(Cobol85ParserDEBUG_CONTENTS-100))|(1<<(Cobol85ParserDEBUG_ITEM-100))|(1<<(Cobol85ParserDEBUG_LINE-100))|(1<<(Cobol85ParserDEBUG_NAME-100))|(1<<(Cobol85ParserDEBUG_SUB_1-100))|(1<<(Cobol85ParserDEBUG_SUB_2-100))|(1<<(Cobol85ParserDEBUG_SUB_3-100))|(1<<(Cobol85ParserDEFAULT-100))|(1<<(Cobol85ParserDEFAULT_DISPLAY-100))|(1<<(Cobol85ParserDEFINITION-100)))) != 0) || (((_la-138)&-(0x1f+1)) == 0 && ((1<<uint((_la-138)))&((1<<(Cobol85ParserDFHRESP-138))|(1<<(Cobol85ParserDFHVALUE-138))|(1<<(Cobol85ParserDISK-138))|(1<<(Cobol85ParserDONTCARE-138))|(1<<(Cobol85ParserDOUBLE-138))|(1<<(Cobol85ParserEBCDIC-138))|(1<<(Cobol85ParserEMPTY_CHECK-138)))) != 0) || (((_la-181)&-(0x1f+1)) == 0 && ((1<<uint((_la-181)))&((1<<(Cobol85ParserENTER-181))|(1<<(Cobol85ParserENTRY_PROCEDURE-181))|(1<<(Cobol85ParserERASE-181))|(1<<(Cobol85ParserEOL-181))|(1<<(Cobol85ParserEOS-181))|(1<<(Cobol85ParserESCAPE-181))|(1<<(Cobol85ParserEVENT-181))|(1<<(Cobol85ParserEXCLUSIVE-181))|(1<<(Cobol85ParserEXPORT-181))|(1<<(Cobol85ParserEXTENDED-181)))) != 0) || (((_la-213)&-(0x1f+1)) == 0 && ((1<<uint((_la-213)))&((1<<(Cobol85ParserFOREGROUND_COLOR-213))|(1<<(Cobol85ParserFOREGROUND_COLOUR-213))|(1<<(Cobol85ParserFULL-213))|(1<<(Cobol85ParserFUNCTION-213))|(1<<(Cobol85ParserFUNCTIONNAME-213))|(1<<(Cobol85ParserFUNCTION_POINTER-213))|(1<<(Cobol85ParserGRID-213))|(1<<(Cobol85ParserHIGHLIGHT-213))|(1<<(Cobol85ParserIMPLICIT-213))|(1<<(Cobol85ParserIMPORT-213)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(Cobol85ParserINTEGER-250))|(1<<(Cobol85ParserKEPT-250))|(1<<(Cobol85ParserKEYBOARD-250))|(1<<(Cobol85ParserLANGUAGE-250))|(1<<(Cobol85ParserLB-250))|(1<<(Cobol85ParserLD-250))|(1<<(Cobol85ParserLEFTLINE-250))|(1<<(Cobol85ParserLENGTH-250))|(1<<(Cobol85ParserLENGTH_CHECK-250))|(1<<(Cobol85ParserLIBACCESS-250))|(1<<(Cobol85ParserLIBPARAMETER-250))|(1<<(Cobol85ParserLIBRARY-250))|(1<<(Cobol85ParserLINAGE_COUNTER-250))|(1<<(Cobol85ParserLINE_COUNTER-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(Cobol85ParserLIST-283))|(1<<(Cobol85ParserLOCAL-283))|(1<<(Cobol85ParserLONG_DATE-283))|(1<<(Cobol85ParserLONG_TIME-283))|(1<<(Cobol85ParserLOWER-283))|(1<<(Cobol85ParserLOWLIGHT-283))|(1<<(Cobol85ParserMMDDYYYY-283))|(1<<(Cobol85ParserNAMED-283))|(1<<(Cobol85ParserNATIONAL-283))|(1<<(Cobol85ParserNATIONAL_EDITED-283))|(1<<(Cobol85ParserNETWORK-283))|(1<<(Cobol85ParserNO_ECHO-283)))) != 0) || (((_la-317)&-(0x1f+1)) == 0 && ((1<<uint((_la-317)))&((1<<(Cobol85ParserNUMERIC_DATE-317))|(1<<(Cobol85ParserNUMERIC_TIME-317))|(1<<(Cobol85ParserODT-317))|(1<<(Cobol85ParserORDERLY-317))|(1<<(Cobol85ParserOVERLINE-317))|(1<<(Cobol85ParserOWN-317))|(1<<(Cobol85ParserPAGE_COUNTER-317))|(1<<(Cobol85ParserPASSWORD-317)))) != 0) || (((_la-352)&-(0x1f+1)) == 0 && ((1<<uint((_la-352)))&((1<<(Cobol85ParserPORT-352))|(1<<(Cobol85ParserPRINTER-352))|(1<<(Cobol85ParserPRIVATE-352))|(1<<(Cobol85ParserPROCESS-352))|(1<<(Cobol85ParserPROGRAM-352))|(1<<(Cobol85ParserPROMPT-352))|(1<<(Cobol85ParserREADER-352))|(1<<(Cobol85ParserREMOTE-352))|(1<<(Cobol85ParserREAL-352))|(1<<(Cobol85ParserRECEIVED-352))|(1<<(Cobol85ParserRECURSIVE-352))|(1<<(Cobol85ParserREF-352)))) != 0) || (((_la-391)&-(0x1f+1)) == 0 && ((1<<uint((_la-391)))&((1<<(Cobol85ParserREMOVE-391))|(1<<(Cobol85ParserREQUIRED-391))|(1<<(Cobol85ParserREVERSE_VIDEO-391))|(1<<(Cobol85ParserRETURN_CODE-391))|(1<<(Cobol85ParserSAVE-391))|(1<<(Cobol85ParserSECURE-391)))) != 0) || (((_la-431)&-(0x1f+1)) == 0 && ((1<<uint((_la-431)))&((1<<(Cobol85ParserSHARED-431))|(1<<(Cobol85ParserSHAREDBYALL-431))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-431))|(1<<(Cobol85ParserSHARING-431))|(1<<(Cobol85ParserSHIFT_IN-431))|(1<<(Cobol85ParserSHIFT_OUT-431))|(1<<(Cobol85ParserSHORT_DATE-431))|(1<<(Cobol85ParserSORT_CONTROL-431))|(1<<(Cobol85ParserSORT_CORE_SIZE-431))|(1<<(Cobol85ParserSORT_FILE_SIZE-431))|(1<<(Cobol85ParserSORT_MESSAGE-431))|(1<<(Cobol85ParserSORT_MODE_SIZE-431))|(1<<(Cobol85ParserSORT_RETURN-431)))) != 0) || (((_la-466)&-(0x1f+1)) == 0 && ((1<<uint((_la-466)))&((1<<(Cobol85ParserSYMBOL-466))|(1<<(Cobol85ParserTALLY-466))|(1<<(Cobol85ParserTASK-466))|(1<<(Cobol85ParserTHREAD-466))|(1<<(Cobol85ParserTHREAD_LOCAL-466))|(1<<(Cobol85ParserTIME-466))|(1<<(Cobol85ParserTIMER-466))|(1<<(Cobol85ParserTODAYS_DATE-466))|(1<<(Cobol85ParserTODAYS_NAME-466))|(1<<(Cobol85ParserTRUNCATED-466))|(1<<(Cobol85ParserTYPEDEF-466)))) != 0) || (((_la-498)&-(0x1f+1)) == 0 && ((1<<uint((_la-498)))&((1<<(Cobol85ParserUNDERLINE-498))|(1<<(Cobol85ParserVIRTUAL-498))|(1<<(Cobol85ParserWAIT-498))|(1<<(Cobol85ParserWHEN_COMPILED-498))|(1<<(Cobol85ParserYEAR-498))|(1<<(Cobol85ParserYYYYMMDD-498))|(1<<(Cobol85ParserYYYYDDD-498))|(1<<(Cobol85ParserZERO_FILL-498)))) != 0) || (((_la-552)&-(0x1f+1)) == 0 && ((1<<uint((_la-552)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-552))|(1<<(Cobol85ParserLEVEL_NUMBER_77-552))|(1<<(Cobol85ParserLEVEL_NUMBER_88-552))|(1<<(Cobol85ParserINTEGERLITERAL-552))|(1<<(Cobol85ParserIDENTIFIER-552)))) != 0) {
		{
			p.SetState(5401)
			p.SubtractMinuend()
		}

		p.SetState(5404)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISubtractFromGivingStatementContext is an interface to support dynamic dispatch.
type ISubtractFromGivingStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubtractFromGivingStatementContext differentiates from other interfaces.
	IsSubtractFromGivingStatementContext()
}

type SubtractFromGivingStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubtractFromGivingStatementContext() *SubtractFromGivingStatementContext {
	var p = new(SubtractFromGivingStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_subtractFromGivingStatement
	return p
}

func (*SubtractFromGivingStatementContext) IsSubtractFromGivingStatementContext() {}

func NewSubtractFromGivingStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubtractFromGivingStatementContext {
	var p = new(SubtractFromGivingStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_subtractFromGivingStatement

	return p
}

func (s *SubtractFromGivingStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SubtractFromGivingStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFROM, 0)
}

func (s *SubtractFromGivingStatementContext) SubtractMinuendGiving() ISubtractMinuendGivingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtractMinuendGivingContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtractMinuendGivingContext)
}

func (s *SubtractFromGivingStatementContext) GIVING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserGIVING, 0)
}

func (s *SubtractFromGivingStatementContext) AllSubtractSubtrahend() []ISubtractSubtrahendContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISubtractSubtrahendContext)(nil)).Elem())
	var tst = make([]ISubtractSubtrahendContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISubtractSubtrahendContext)
		}
	}

	return tst
}

func (s *SubtractFromGivingStatementContext) SubtractSubtrahend(i int) ISubtractSubtrahendContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtractSubtrahendContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISubtractSubtrahendContext)
}

func (s *SubtractFromGivingStatementContext) AllSubtractGiving() []ISubtractGivingContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISubtractGivingContext)(nil)).Elem())
	var tst = make([]ISubtractGivingContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISubtractGivingContext)
		}
	}

	return tst
}

func (s *SubtractFromGivingStatementContext) SubtractGiving(i int) ISubtractGivingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtractGivingContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISubtractGivingContext)
}

func (s *SubtractFromGivingStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubtractFromGivingStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubtractFromGivingStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSubtractFromGivingStatement(s)
	}
}

func (s *SubtractFromGivingStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSubtractFromGivingStatement(s)
	}
}

func (p *Cobol85Parser) SubtractFromGivingStatement() (localctx ISubtractFromGivingStatementContext) {
	localctx = NewSubtractFromGivingStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 950, Cobol85ParserRULE_subtractFromGivingStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5407)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserADDRESS)|(1<<Cobol85ParserALL)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH)|(1<<Cobol85ParserATTRIBUTE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBINARY-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-68))|(1<<(Cobol85ParserCOBOL-68))|(1<<(Cobol85ParserCOMMITMENT-68))|(1<<(Cobol85ParserCONTROL_POINT-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(Cobol85ParserCONVENTION-100))|(1<<(Cobol85ParserCRUNCH-100))|(1<<(Cobol85ParserCURSOR-100))|(1<<(Cobol85ParserDATE-100))|(1<<(Cobol85ParserDAY-100))|(1<<(Cobol85ParserDAY_OF_WEEK-100))|(1<<(Cobol85ParserDEBUG_CONTENTS-100))|(1<<(Cobol85ParserDEBUG_ITEM-100))|(1<<(Cobol85ParserDEBUG_LINE-100))|(1<<(Cobol85ParserDEBUG_NAME-100))|(1<<(Cobol85ParserDEBUG_SUB_1-100))|(1<<(Cobol85ParserDEBUG_SUB_2-100))|(1<<(Cobol85ParserDEBUG_SUB_3-100))|(1<<(Cobol85ParserDEFAULT-100))|(1<<(Cobol85ParserDEFAULT_DISPLAY-100))|(1<<(Cobol85ParserDEFINITION-100)))) != 0) || (((_la-138)&-(0x1f+1)) == 0 && ((1<<uint((_la-138)))&((1<<(Cobol85ParserDFHRESP-138))|(1<<(Cobol85ParserDFHVALUE-138))|(1<<(Cobol85ParserDISK-138))|(1<<(Cobol85ParserDONTCARE-138))|(1<<(Cobol85ParserDOUBLE-138))|(1<<(Cobol85ParserEBCDIC-138))|(1<<(Cobol85ParserEMPTY_CHECK-138)))) != 0) || (((_la-181)&-(0x1f+1)) == 0 && ((1<<uint((_la-181)))&((1<<(Cobol85ParserENTER-181))|(1<<(Cobol85ParserENTRY_PROCEDURE-181))|(1<<(Cobol85ParserERASE-181))|(1<<(Cobol85ParserEOL-181))|(1<<(Cobol85ParserEOS-181))|(1<<(Cobol85ParserESCAPE-181))|(1<<(Cobol85ParserEVENT-181))|(1<<(Cobol85ParserEXCLUSIVE-181))|(1<<(Cobol85ParserEXPORT-181))|(1<<(Cobol85ParserEXTENDED-181))|(1<<(Cobol85ParserFALSE-181)))) != 0) || (((_la-213)&-(0x1f+1)) == 0 && ((1<<uint((_la-213)))&((1<<(Cobol85ParserFOREGROUND_COLOR-213))|(1<<(Cobol85ParserFOREGROUND_COLOUR-213))|(1<<(Cobol85ParserFULL-213))|(1<<(Cobol85ParserFUNCTION-213))|(1<<(Cobol85ParserFUNCTIONNAME-213))|(1<<(Cobol85ParserFUNCTION_POINTER-213))|(1<<(Cobol85ParserGRID-213))|(1<<(Cobol85ParserHIGHLIGHT-213))|(1<<(Cobol85ParserHIGH_VALUE-213))|(1<<(Cobol85ParserHIGH_VALUES-213))|(1<<(Cobol85ParserIMPLICIT-213))|(1<<(Cobol85ParserIMPORT-213)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(Cobol85ParserINTEGER-250))|(1<<(Cobol85ParserKEPT-250))|(1<<(Cobol85ParserKEYBOARD-250))|(1<<(Cobol85ParserLANGUAGE-250))|(1<<(Cobol85ParserLB-250))|(1<<(Cobol85ParserLD-250))|(1<<(Cobol85ParserLEFTLINE-250))|(1<<(Cobol85ParserLENGTH-250))|(1<<(Cobol85ParserLENGTH_CHECK-250))|(1<<(Cobol85ParserLIBACCESS-250))|(1<<(Cobol85ParserLIBPARAMETER-250))|(1<<(Cobol85ParserLIBRARY-250))|(1<<(Cobol85ParserLINAGE_COUNTER-250))|(1<<(Cobol85ParserLINE_COUNTER-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(Cobol85ParserLIST-283))|(1<<(Cobol85ParserLOCAL-283))|(1<<(Cobol85ParserLONG_DATE-283))|(1<<(Cobol85ParserLONG_TIME-283))|(1<<(Cobol85ParserLOWER-283))|(1<<(Cobol85ParserLOWLIGHT-283))|(1<<(Cobol85ParserLOW_VALUE-283))|(1<<(Cobol85ParserLOW_VALUES-283))|(1<<(Cobol85ParserMMDDYYYY-283))|(1<<(Cobol85ParserNAMED-283))|(1<<(Cobol85ParserNATIONAL-283))|(1<<(Cobol85ParserNATIONAL_EDITED-283))|(1<<(Cobol85ParserNETWORK-283))|(1<<(Cobol85ParserNO_ECHO-283))|(1<<(Cobol85ParserNULL-283))|(1<<(Cobol85ParserNULLS-283)))) != 0) || (((_la-317)&-(0x1f+1)) == 0 && ((1<<uint((_la-317)))&((1<<(Cobol85ParserNUMERIC_DATE-317))|(1<<(Cobol85ParserNUMERIC_TIME-317))|(1<<(Cobol85ParserODT-317))|(1<<(Cobol85ParserORDERLY-317))|(1<<(Cobol85ParserOVERLINE-317))|(1<<(Cobol85ParserOWN-317))|(1<<(Cobol85ParserPAGE_COUNTER-317))|(1<<(Cobol85ParserPASSWORD-317)))) != 0) || (((_la-352)&-(0x1f+1)) == 0 && ((1<<uint((_la-352)))&((1<<(Cobol85ParserPORT-352))|(1<<(Cobol85ParserPRINTER-352))|(1<<(Cobol85ParserPRIVATE-352))|(1<<(Cobol85ParserPROCESS-352))|(1<<(Cobol85ParserPROGRAM-352))|(1<<(Cobol85ParserPROMPT-352))|(1<<(Cobol85ParserQUOTE-352))|(1<<(Cobol85ParserQUOTES-352))|(1<<(Cobol85ParserREADER-352))|(1<<(Cobol85ParserREMOTE-352))|(1<<(Cobol85ParserREAL-352))|(1<<(Cobol85ParserRECEIVED-352))|(1<<(Cobol85ParserRECURSIVE-352))|(1<<(Cobol85ParserREF-352)))) != 0) || (((_la-391)&-(0x1f+1)) == 0 && ((1<<uint((_la-391)))&((1<<(Cobol85ParserREMOVE-391))|(1<<(Cobol85ParserREQUIRED-391))|(1<<(Cobol85ParserREVERSE_VIDEO-391))|(1<<(Cobol85ParserRETURN_CODE-391))|(1<<(Cobol85ParserSAVE-391))|(1<<(Cobol85ParserSECURE-391)))) != 0) || (((_la-431)&-(0x1f+1)) == 0 && ((1<<uint((_la-431)))&((1<<(Cobol85ParserSHARED-431))|(1<<(Cobol85ParserSHAREDBYALL-431))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-431))|(1<<(Cobol85ParserSHARING-431))|(1<<(Cobol85ParserSHIFT_IN-431))|(1<<(Cobol85ParserSHIFT_OUT-431))|(1<<(Cobol85ParserSHORT_DATE-431))|(1<<(Cobol85ParserSORT_CONTROL-431))|(1<<(Cobol85ParserSORT_CORE_SIZE-431))|(1<<(Cobol85ParserSORT_FILE_SIZE-431))|(1<<(Cobol85ParserSORT_MESSAGE-431))|(1<<(Cobol85ParserSORT_MODE_SIZE-431))|(1<<(Cobol85ParserSORT_RETURN-431))|(1<<(Cobol85ParserSPACE-431))|(1<<(Cobol85ParserSPACES-431)))) != 0) || (((_la-466)&-(0x1f+1)) == 0 && ((1<<uint((_la-466)))&((1<<(Cobol85ParserSYMBOL-466))|(1<<(Cobol85ParserTALLY-466))|(1<<(Cobol85ParserTASK-466))|(1<<(Cobol85ParserTHREAD-466))|(1<<(Cobol85ParserTHREAD_LOCAL-466))|(1<<(Cobol85ParserTIME-466))|(1<<(Cobol85ParserTIMER-466))|(1<<(Cobol85ParserTODAYS_DATE-466))|(1<<(Cobol85ParserTODAYS_NAME-466))|(1<<(Cobol85ParserTRUE-466))|(1<<(Cobol85ParserTRUNCATED-466))|(1<<(Cobol85ParserTYPEDEF-466)))) != 0) || (((_la-498)&-(0x1f+1)) == 0 && ((1<<uint((_la-498)))&((1<<(Cobol85ParserUNDERLINE-498))|(1<<(Cobol85ParserVIRTUAL-498))|(1<<(Cobol85ParserWAIT-498))|(1<<(Cobol85ParserWHEN_COMPILED-498))|(1<<(Cobol85ParserYEAR-498))|(1<<(Cobol85ParserYYYYMMDD-498))|(1<<(Cobol85ParserYYYYDDD-498))|(1<<(Cobol85ParserZERO-498))|(1<<(Cobol85ParserZERO_FILL-498))|(1<<(Cobol85ParserZEROS-498))|(1<<(Cobol85ParserZEROES-498)))) != 0) || (((_la-551)&-(0x1f+1)) == 0 && ((1<<uint((_la-551)))&((1<<(Cobol85ParserNONNUMERICLITERAL-551))|(1<<(Cobol85ParserLEVEL_NUMBER_66-551))|(1<<(Cobol85ParserLEVEL_NUMBER_77-551))|(1<<(Cobol85ParserLEVEL_NUMBER_88-551))|(1<<(Cobol85ParserINTEGERLITERAL-551))|(1<<(Cobol85ParserNUMERICLITERAL-551))|(1<<(Cobol85ParserIDENTIFIER-551)))) != 0) {
		{
			p.SetState(5406)
			p.SubtractSubtrahend()
		}

		p.SetState(5409)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(5411)
		p.Match(Cobol85ParserFROM)
	}
	{
		p.SetState(5412)
		p.SubtractMinuendGiving()
	}
	{
		p.SetState(5413)
		p.Match(Cobol85ParserGIVING)
	}
	p.SetState(5415)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserADDRESS)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH)|(1<<Cobol85ParserATTRIBUTE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBINARY-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-68))|(1<<(Cobol85ParserCOBOL-68))|(1<<(Cobol85ParserCOMMITMENT-68))|(1<<(Cobol85ParserCONTROL_POINT-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(Cobol85ParserCONVENTION-100))|(1<<(Cobol85ParserCRUNCH-100))|(1<<(Cobol85ParserCURSOR-100))|(1<<(Cobol85ParserDATE-100))|(1<<(Cobol85ParserDAY-100))|(1<<(Cobol85ParserDAY_OF_WEEK-100))|(1<<(Cobol85ParserDEBUG_CONTENTS-100))|(1<<(Cobol85ParserDEBUG_ITEM-100))|(1<<(Cobol85ParserDEBUG_LINE-100))|(1<<(Cobol85ParserDEBUG_NAME-100))|(1<<(Cobol85ParserDEBUG_SUB_1-100))|(1<<(Cobol85ParserDEBUG_SUB_2-100))|(1<<(Cobol85ParserDEBUG_SUB_3-100))|(1<<(Cobol85ParserDEFAULT-100))|(1<<(Cobol85ParserDEFAULT_DISPLAY-100))|(1<<(Cobol85ParserDEFINITION-100)))) != 0) || (((_la-138)&-(0x1f+1)) == 0 && ((1<<uint((_la-138)))&((1<<(Cobol85ParserDFHRESP-138))|(1<<(Cobol85ParserDFHVALUE-138))|(1<<(Cobol85ParserDISK-138))|(1<<(Cobol85ParserDONTCARE-138))|(1<<(Cobol85ParserDOUBLE-138))|(1<<(Cobol85ParserEBCDIC-138))|(1<<(Cobol85ParserEMPTY_CHECK-138)))) != 0) || (((_la-181)&-(0x1f+1)) == 0 && ((1<<uint((_la-181)))&((1<<(Cobol85ParserENTER-181))|(1<<(Cobol85ParserENTRY_PROCEDURE-181))|(1<<(Cobol85ParserERASE-181))|(1<<(Cobol85ParserEOL-181))|(1<<(Cobol85ParserEOS-181))|(1<<(Cobol85ParserESCAPE-181))|(1<<(Cobol85ParserEVENT-181))|(1<<(Cobol85ParserEXCLUSIVE-181))|(1<<(Cobol85ParserEXPORT-181))|(1<<(Cobol85ParserEXTENDED-181)))) != 0) || (((_la-213)&-(0x1f+1)) == 0 && ((1<<uint((_la-213)))&((1<<(Cobol85ParserFOREGROUND_COLOR-213))|(1<<(Cobol85ParserFOREGROUND_COLOUR-213))|(1<<(Cobol85ParserFULL-213))|(1<<(Cobol85ParserFUNCTION-213))|(1<<(Cobol85ParserFUNCTIONNAME-213))|(1<<(Cobol85ParserFUNCTION_POINTER-213))|(1<<(Cobol85ParserGRID-213))|(1<<(Cobol85ParserHIGHLIGHT-213))|(1<<(Cobol85ParserIMPLICIT-213))|(1<<(Cobol85ParserIMPORT-213)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(Cobol85ParserINTEGER-250))|(1<<(Cobol85ParserKEPT-250))|(1<<(Cobol85ParserKEYBOARD-250))|(1<<(Cobol85ParserLANGUAGE-250))|(1<<(Cobol85ParserLB-250))|(1<<(Cobol85ParserLD-250))|(1<<(Cobol85ParserLEFTLINE-250))|(1<<(Cobol85ParserLENGTH-250))|(1<<(Cobol85ParserLENGTH_CHECK-250))|(1<<(Cobol85ParserLIBACCESS-250))|(1<<(Cobol85ParserLIBPARAMETER-250))|(1<<(Cobol85ParserLIBRARY-250))|(1<<(Cobol85ParserLINAGE_COUNTER-250))|(1<<(Cobol85ParserLINE_COUNTER-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(Cobol85ParserLIST-283))|(1<<(Cobol85ParserLOCAL-283))|(1<<(Cobol85ParserLONG_DATE-283))|(1<<(Cobol85ParserLONG_TIME-283))|(1<<(Cobol85ParserLOWER-283))|(1<<(Cobol85ParserLOWLIGHT-283))|(1<<(Cobol85ParserMMDDYYYY-283))|(1<<(Cobol85ParserNAMED-283))|(1<<(Cobol85ParserNATIONAL-283))|(1<<(Cobol85ParserNATIONAL_EDITED-283))|(1<<(Cobol85ParserNETWORK-283))|(1<<(Cobol85ParserNO_ECHO-283)))) != 0) || (((_la-317)&-(0x1f+1)) == 0 && ((1<<uint((_la-317)))&((1<<(Cobol85ParserNUMERIC_DATE-317))|(1<<(Cobol85ParserNUMERIC_TIME-317))|(1<<(Cobol85ParserODT-317))|(1<<(Cobol85ParserORDERLY-317))|(1<<(Cobol85ParserOVERLINE-317))|(1<<(Cobol85ParserOWN-317))|(1<<(Cobol85ParserPAGE_COUNTER-317))|(1<<(Cobol85ParserPASSWORD-317)))) != 0) || (((_la-352)&-(0x1f+1)) == 0 && ((1<<uint((_la-352)))&((1<<(Cobol85ParserPORT-352))|(1<<(Cobol85ParserPRINTER-352))|(1<<(Cobol85ParserPRIVATE-352))|(1<<(Cobol85ParserPROCESS-352))|(1<<(Cobol85ParserPROGRAM-352))|(1<<(Cobol85ParserPROMPT-352))|(1<<(Cobol85ParserREADER-352))|(1<<(Cobol85ParserREMOTE-352))|(1<<(Cobol85ParserREAL-352))|(1<<(Cobol85ParserRECEIVED-352))|(1<<(Cobol85ParserRECURSIVE-352))|(1<<(Cobol85ParserREF-352)))) != 0) || (((_la-391)&-(0x1f+1)) == 0 && ((1<<uint((_la-391)))&((1<<(Cobol85ParserREMOVE-391))|(1<<(Cobol85ParserREQUIRED-391))|(1<<(Cobol85ParserREVERSE_VIDEO-391))|(1<<(Cobol85ParserRETURN_CODE-391))|(1<<(Cobol85ParserSAVE-391))|(1<<(Cobol85ParserSECURE-391)))) != 0) || (((_la-431)&-(0x1f+1)) == 0 && ((1<<uint((_la-431)))&((1<<(Cobol85ParserSHARED-431))|(1<<(Cobol85ParserSHAREDBYALL-431))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-431))|(1<<(Cobol85ParserSHARING-431))|(1<<(Cobol85ParserSHIFT_IN-431))|(1<<(Cobol85ParserSHIFT_OUT-431))|(1<<(Cobol85ParserSHORT_DATE-431))|(1<<(Cobol85ParserSORT_CONTROL-431))|(1<<(Cobol85ParserSORT_CORE_SIZE-431))|(1<<(Cobol85ParserSORT_FILE_SIZE-431))|(1<<(Cobol85ParserSORT_MESSAGE-431))|(1<<(Cobol85ParserSORT_MODE_SIZE-431))|(1<<(Cobol85ParserSORT_RETURN-431)))) != 0) || (((_la-466)&-(0x1f+1)) == 0 && ((1<<uint((_la-466)))&((1<<(Cobol85ParserSYMBOL-466))|(1<<(Cobol85ParserTALLY-466))|(1<<(Cobol85ParserTASK-466))|(1<<(Cobol85ParserTHREAD-466))|(1<<(Cobol85ParserTHREAD_LOCAL-466))|(1<<(Cobol85ParserTIME-466))|(1<<(Cobol85ParserTIMER-466))|(1<<(Cobol85ParserTODAYS_DATE-466))|(1<<(Cobol85ParserTODAYS_NAME-466))|(1<<(Cobol85ParserTRUNCATED-466))|(1<<(Cobol85ParserTYPEDEF-466)))) != 0) || (((_la-498)&-(0x1f+1)) == 0 && ((1<<uint((_la-498)))&((1<<(Cobol85ParserUNDERLINE-498))|(1<<(Cobol85ParserVIRTUAL-498))|(1<<(Cobol85ParserWAIT-498))|(1<<(Cobol85ParserWHEN_COMPILED-498))|(1<<(Cobol85ParserYEAR-498))|(1<<(Cobol85ParserYYYYMMDD-498))|(1<<(Cobol85ParserYYYYDDD-498))|(1<<(Cobol85ParserZERO_FILL-498)))) != 0) || (((_la-552)&-(0x1f+1)) == 0 && ((1<<uint((_la-552)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-552))|(1<<(Cobol85ParserLEVEL_NUMBER_77-552))|(1<<(Cobol85ParserLEVEL_NUMBER_88-552))|(1<<(Cobol85ParserINTEGERLITERAL-552))|(1<<(Cobol85ParserIDENTIFIER-552)))) != 0) {
		{
			p.SetState(5414)
			p.SubtractGiving()
		}

		p.SetState(5417)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISubtractCorrespondingStatementContext is an interface to support dynamic dispatch.
type ISubtractCorrespondingStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubtractCorrespondingStatementContext differentiates from other interfaces.
	IsSubtractCorrespondingStatementContext()
}

type SubtractCorrespondingStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubtractCorrespondingStatementContext() *SubtractCorrespondingStatementContext {
	var p = new(SubtractCorrespondingStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_subtractCorrespondingStatement
	return p
}

func (*SubtractCorrespondingStatementContext) IsSubtractCorrespondingStatementContext() {}

func NewSubtractCorrespondingStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubtractCorrespondingStatementContext {
	var p = new(SubtractCorrespondingStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_subtractCorrespondingStatement

	return p
}

func (s *SubtractCorrespondingStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SubtractCorrespondingStatementContext) QualifiedDataName() IQualifiedDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *SubtractCorrespondingStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFROM, 0)
}

func (s *SubtractCorrespondingStatementContext) SubtractMinuendCorresponding() ISubtractMinuendCorrespondingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtractMinuendCorrespondingContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtractMinuendCorrespondingContext)
}

func (s *SubtractCorrespondingStatementContext) CORRESPONDING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCORRESPONDING, 0)
}

func (s *SubtractCorrespondingStatementContext) CORR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCORR, 0)
}

func (s *SubtractCorrespondingStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubtractCorrespondingStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubtractCorrespondingStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSubtractCorrespondingStatement(s)
	}
}

func (s *SubtractCorrespondingStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSubtractCorrespondingStatement(s)
	}
}

func (p *Cobol85Parser) SubtractCorrespondingStatement() (localctx ISubtractCorrespondingStatementContext) {
	localctx = NewSubtractCorrespondingStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 952, Cobol85ParserRULE_subtractCorrespondingStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5419)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserCORR || _la == Cobol85ParserCORRESPONDING) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(5420)
		p.QualifiedDataName()
	}
	{
		p.SetState(5421)
		p.Match(Cobol85ParserFROM)
	}
	{
		p.SetState(5422)
		p.SubtractMinuendCorresponding()
	}

	return localctx
}

// ISubtractSubtrahendContext is an interface to support dynamic dispatch.
type ISubtractSubtrahendContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubtractSubtrahendContext differentiates from other interfaces.
	IsSubtractSubtrahendContext()
}

type SubtractSubtrahendContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubtractSubtrahendContext() *SubtractSubtrahendContext {
	var p = new(SubtractSubtrahendContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_subtractSubtrahend
	return p
}

func (*SubtractSubtrahendContext) IsSubtractSubtrahendContext() {}

func NewSubtractSubtrahendContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubtractSubtrahendContext {
	var p = new(SubtractSubtrahendContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_subtractSubtrahend

	return p
}

func (s *SubtractSubtrahendContext) GetParser() antlr.Parser { return s.parser }

func (s *SubtractSubtrahendContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SubtractSubtrahendContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *SubtractSubtrahendContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubtractSubtrahendContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubtractSubtrahendContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSubtractSubtrahend(s)
	}
}

func (s *SubtractSubtrahendContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSubtractSubtrahend(s)
	}
}

func (p *Cobol85Parser) SubtractSubtrahend() (localctx ISubtractSubtrahendContext) {
	localctx = NewSubtractSubtrahendContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 954, Cobol85ParserRULE_subtractSubtrahend)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5426)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 832, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5424)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5425)
			p.Literal()
		}

	}

	return localctx
}

// ISubtractMinuendContext is an interface to support dynamic dispatch.
type ISubtractMinuendContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubtractMinuendContext differentiates from other interfaces.
	IsSubtractMinuendContext()
}

type SubtractMinuendContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubtractMinuendContext() *SubtractMinuendContext {
	var p = new(SubtractMinuendContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_subtractMinuend
	return p
}

func (*SubtractMinuendContext) IsSubtractMinuendContext() {}

func NewSubtractMinuendContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubtractMinuendContext {
	var p = new(SubtractMinuendContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_subtractMinuend

	return p
}

func (s *SubtractMinuendContext) GetParser() antlr.Parser { return s.parser }

func (s *SubtractMinuendContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SubtractMinuendContext) ROUNDED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserROUNDED, 0)
}

func (s *SubtractMinuendContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubtractMinuendContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubtractMinuendContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSubtractMinuend(s)
	}
}

func (s *SubtractMinuendContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSubtractMinuend(s)
	}
}

func (p *Cobol85Parser) SubtractMinuend() (localctx ISubtractMinuendContext) {
	localctx = NewSubtractMinuendContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 956, Cobol85ParserRULE_subtractMinuend)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5428)
		p.Identifier()
	}
	p.SetState(5430)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserROUNDED {
		{
			p.SetState(5429)
			p.Match(Cobol85ParserROUNDED)
		}

	}

	return localctx
}

// ISubtractMinuendGivingContext is an interface to support dynamic dispatch.
type ISubtractMinuendGivingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubtractMinuendGivingContext differentiates from other interfaces.
	IsSubtractMinuendGivingContext()
}

type SubtractMinuendGivingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubtractMinuendGivingContext() *SubtractMinuendGivingContext {
	var p = new(SubtractMinuendGivingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_subtractMinuendGiving
	return p
}

func (*SubtractMinuendGivingContext) IsSubtractMinuendGivingContext() {}

func NewSubtractMinuendGivingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubtractMinuendGivingContext {
	var p = new(SubtractMinuendGivingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_subtractMinuendGiving

	return p
}

func (s *SubtractMinuendGivingContext) GetParser() antlr.Parser { return s.parser }

func (s *SubtractMinuendGivingContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SubtractMinuendGivingContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *SubtractMinuendGivingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubtractMinuendGivingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubtractMinuendGivingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSubtractMinuendGiving(s)
	}
}

func (s *SubtractMinuendGivingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSubtractMinuendGiving(s)
	}
}

func (p *Cobol85Parser) SubtractMinuendGiving() (localctx ISubtractMinuendGivingContext) {
	localctx = NewSubtractMinuendGivingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 958, Cobol85ParserRULE_subtractMinuendGiving)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5434)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 834, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5432)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5433)
			p.Literal()
		}

	}

	return localctx
}

// ISubtractGivingContext is an interface to support dynamic dispatch.
type ISubtractGivingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubtractGivingContext differentiates from other interfaces.
	IsSubtractGivingContext()
}

type SubtractGivingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubtractGivingContext() *SubtractGivingContext {
	var p = new(SubtractGivingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_subtractGiving
	return p
}

func (*SubtractGivingContext) IsSubtractGivingContext() {}

func NewSubtractGivingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubtractGivingContext {
	var p = new(SubtractGivingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_subtractGiving

	return p
}

func (s *SubtractGivingContext) GetParser() antlr.Parser { return s.parser }

func (s *SubtractGivingContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SubtractGivingContext) ROUNDED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserROUNDED, 0)
}

func (s *SubtractGivingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubtractGivingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubtractGivingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSubtractGiving(s)
	}
}

func (s *SubtractGivingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSubtractGiving(s)
	}
}

func (p *Cobol85Parser) SubtractGiving() (localctx ISubtractGivingContext) {
	localctx = NewSubtractGivingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 960, Cobol85ParserRULE_subtractGiving)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5436)
		p.Identifier()
	}
	p.SetState(5438)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserROUNDED {
		{
			p.SetState(5437)
			p.Match(Cobol85ParserROUNDED)
		}

	}

	return localctx
}

// ISubtractMinuendCorrespondingContext is an interface to support dynamic dispatch.
type ISubtractMinuendCorrespondingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubtractMinuendCorrespondingContext differentiates from other interfaces.
	IsSubtractMinuendCorrespondingContext()
}

type SubtractMinuendCorrespondingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubtractMinuendCorrespondingContext() *SubtractMinuendCorrespondingContext {
	var p = new(SubtractMinuendCorrespondingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_subtractMinuendCorresponding
	return p
}

func (*SubtractMinuendCorrespondingContext) IsSubtractMinuendCorrespondingContext() {}

func NewSubtractMinuendCorrespondingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubtractMinuendCorrespondingContext {
	var p = new(SubtractMinuendCorrespondingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_subtractMinuendCorresponding

	return p
}

func (s *SubtractMinuendCorrespondingContext) GetParser() antlr.Parser { return s.parser }

func (s *SubtractMinuendCorrespondingContext) QualifiedDataName() IQualifiedDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *SubtractMinuendCorrespondingContext) ROUNDED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserROUNDED, 0)
}

func (s *SubtractMinuendCorrespondingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubtractMinuendCorrespondingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubtractMinuendCorrespondingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSubtractMinuendCorresponding(s)
	}
}

func (s *SubtractMinuendCorrespondingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSubtractMinuendCorresponding(s)
	}
}

func (p *Cobol85Parser) SubtractMinuendCorresponding() (localctx ISubtractMinuendCorrespondingContext) {
	localctx = NewSubtractMinuendCorrespondingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 962, Cobol85ParserRULE_subtractMinuendCorresponding)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5440)
		p.QualifiedDataName()
	}
	p.SetState(5442)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserROUNDED {
		{
			p.SetState(5441)
			p.Match(Cobol85ParserROUNDED)
		}

	}

	return localctx
}

// ITerminateStatementContext is an interface to support dynamic dispatch.
type ITerminateStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTerminateStatementContext differentiates from other interfaces.
	IsTerminateStatementContext()
}

type TerminateStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTerminateStatementContext() *TerminateStatementContext {
	var p = new(TerminateStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_terminateStatement
	return p
}

func (*TerminateStatementContext) IsTerminateStatementContext() {}

func NewTerminateStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TerminateStatementContext {
	var p = new(TerminateStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_terminateStatement

	return p
}

func (s *TerminateStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TerminateStatementContext) TERMINATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTERMINATE, 0)
}

func (s *TerminateStatementContext) ReportName() IReportNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReportNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReportNameContext)
}

func (s *TerminateStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TerminateStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TerminateStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterTerminateStatement(s)
	}
}

func (s *TerminateStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitTerminateStatement(s)
	}
}

func (p *Cobol85Parser) TerminateStatement() (localctx ITerminateStatementContext) {
	localctx = NewTerminateStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 964, Cobol85ParserRULE_terminateStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5444)
		p.Match(Cobol85ParserTERMINATE)
	}
	{
		p.SetState(5445)
		p.ReportName()
	}

	return localctx
}

// IUnstringStatementContext is an interface to support dynamic dispatch.
type IUnstringStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnstringStatementContext differentiates from other interfaces.
	IsUnstringStatementContext()
}

type UnstringStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnstringStatementContext() *UnstringStatementContext {
	var p = new(UnstringStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_unstringStatement
	return p
}

func (*UnstringStatementContext) IsUnstringStatementContext() {}

func NewUnstringStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnstringStatementContext {
	var p = new(UnstringStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_unstringStatement

	return p
}

func (s *UnstringStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UnstringStatementContext) UNSTRING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserUNSTRING, 0)
}

func (s *UnstringStatementContext) UnstringSendingPhrase() IUnstringSendingPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnstringSendingPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnstringSendingPhraseContext)
}

func (s *UnstringStatementContext) UnstringIntoPhrase() IUnstringIntoPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnstringIntoPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnstringIntoPhraseContext)
}

func (s *UnstringStatementContext) UnstringWithPointerPhrase() IUnstringWithPointerPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnstringWithPointerPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnstringWithPointerPhraseContext)
}

func (s *UnstringStatementContext) UnstringTallyingPhrase() IUnstringTallyingPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnstringTallyingPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnstringTallyingPhraseContext)
}

func (s *UnstringStatementContext) OnOverflowPhrase() IOnOverflowPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOnOverflowPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOnOverflowPhraseContext)
}

func (s *UnstringStatementContext) NotOnOverflowPhrase() INotOnOverflowPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INotOnOverflowPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INotOnOverflowPhraseContext)
}

func (s *UnstringStatementContext) END_UNSTRING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND_UNSTRING, 0)
}

func (s *UnstringStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnstringStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnstringStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterUnstringStatement(s)
	}
}

func (s *UnstringStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitUnstringStatement(s)
	}
}

func (p *Cobol85Parser) UnstringStatement() (localctx IUnstringStatementContext) {
	localctx = NewUnstringStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 966, Cobol85ParserRULE_unstringStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5447)
		p.Match(Cobol85ParserUNSTRING)
	}
	{
		p.SetState(5448)
		p.UnstringSendingPhrase()
	}
	{
		p.SetState(5449)
		p.UnstringIntoPhrase()
	}
	p.SetState(5451)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 837, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5450)
			p.UnstringWithPointerPhrase()
		}

	}
	p.SetState(5454)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserTALLYING {
		{
			p.SetState(5453)
			p.UnstringTallyingPhrase()
		}

	}
	p.SetState(5457)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 839, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5456)
			p.OnOverflowPhrase()
		}

	}
	p.SetState(5460)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 840, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5459)
			p.NotOnOverflowPhrase()
		}

	}
	p.SetState(5463)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 841, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5462)
			p.Match(Cobol85ParserEND_UNSTRING)
		}

	}

	return localctx
}

// IUnstringSendingPhraseContext is an interface to support dynamic dispatch.
type IUnstringSendingPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnstringSendingPhraseContext differentiates from other interfaces.
	IsUnstringSendingPhraseContext()
}

type UnstringSendingPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnstringSendingPhraseContext() *UnstringSendingPhraseContext {
	var p = new(UnstringSendingPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_unstringSendingPhrase
	return p
}

func (*UnstringSendingPhraseContext) IsUnstringSendingPhraseContext() {}

func NewUnstringSendingPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnstringSendingPhraseContext {
	var p = new(UnstringSendingPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_unstringSendingPhrase

	return p
}

func (s *UnstringSendingPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *UnstringSendingPhraseContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *UnstringSendingPhraseContext) UnstringDelimitedByPhrase() IUnstringDelimitedByPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnstringDelimitedByPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnstringDelimitedByPhraseContext)
}

func (s *UnstringSendingPhraseContext) AllUnstringOrAllPhrase() []IUnstringOrAllPhraseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IUnstringOrAllPhraseContext)(nil)).Elem())
	var tst = make([]IUnstringOrAllPhraseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IUnstringOrAllPhraseContext)
		}
	}

	return tst
}

func (s *UnstringSendingPhraseContext) UnstringOrAllPhrase(i int) IUnstringOrAllPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnstringOrAllPhraseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IUnstringOrAllPhraseContext)
}

func (s *UnstringSendingPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnstringSendingPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnstringSendingPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterUnstringSendingPhrase(s)
	}
}

func (s *UnstringSendingPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitUnstringSendingPhrase(s)
	}
}

func (p *Cobol85Parser) UnstringSendingPhrase() (localctx IUnstringSendingPhraseContext) {
	localctx = NewUnstringSendingPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 968, Cobol85ParserRULE_unstringSendingPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5465)
		p.Identifier()
	}
	p.SetState(5473)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserDELIMITED {
		{
			p.SetState(5466)
			p.UnstringDelimitedByPhrase()
		}
		p.SetState(5470)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == Cobol85ParserOR {
			{
				p.SetState(5467)
				p.UnstringOrAllPhrase()
			}

			p.SetState(5472)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// IUnstringDelimitedByPhraseContext is an interface to support dynamic dispatch.
type IUnstringDelimitedByPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnstringDelimitedByPhraseContext differentiates from other interfaces.
	IsUnstringDelimitedByPhraseContext()
}

type UnstringDelimitedByPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnstringDelimitedByPhraseContext() *UnstringDelimitedByPhraseContext {
	var p = new(UnstringDelimitedByPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_unstringDelimitedByPhrase
	return p
}

func (*UnstringDelimitedByPhraseContext) IsUnstringDelimitedByPhraseContext() {}

func NewUnstringDelimitedByPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnstringDelimitedByPhraseContext {
	var p = new(UnstringDelimitedByPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_unstringDelimitedByPhrase

	return p
}

func (s *UnstringDelimitedByPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *UnstringDelimitedByPhraseContext) DELIMITED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDELIMITED, 0)
}

func (s *UnstringDelimitedByPhraseContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *UnstringDelimitedByPhraseContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *UnstringDelimitedByPhraseContext) BY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBY, 0)
}

func (s *UnstringDelimitedByPhraseContext) ALL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALL, 0)
}

func (s *UnstringDelimitedByPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnstringDelimitedByPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnstringDelimitedByPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterUnstringDelimitedByPhrase(s)
	}
}

func (s *UnstringDelimitedByPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitUnstringDelimitedByPhrase(s)
	}
}

func (p *Cobol85Parser) UnstringDelimitedByPhrase() (localctx IUnstringDelimitedByPhraseContext) {
	localctx = NewUnstringDelimitedByPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 970, Cobol85ParserRULE_unstringDelimitedByPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5475)
		p.Match(Cobol85ParserDELIMITED)
	}
	p.SetState(5477)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserBY {
		{
			p.SetState(5476)
			p.Match(Cobol85ParserBY)
		}

	}
	p.SetState(5480)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 845, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5479)
			p.Match(Cobol85ParserALL)
		}

	}
	p.SetState(5484)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 846, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(5482)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(5483)
			p.Literal()
		}

	}

	return localctx
}

// IUnstringOrAllPhraseContext is an interface to support dynamic dispatch.
type IUnstringOrAllPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnstringOrAllPhraseContext differentiates from other interfaces.
	IsUnstringOrAllPhraseContext()
}

type UnstringOrAllPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnstringOrAllPhraseContext() *UnstringOrAllPhraseContext {
	var p = new(UnstringOrAllPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_unstringOrAllPhrase
	return p
}

func (*UnstringOrAllPhraseContext) IsUnstringOrAllPhraseContext() {}

func NewUnstringOrAllPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnstringOrAllPhraseContext {
	var p = new(UnstringOrAllPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_unstringOrAllPhrase

	return p
}

func (s *UnstringOrAllPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *UnstringOrAllPhraseContext) OR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOR, 0)
}

func (s *UnstringOrAllPhraseContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *UnstringOrAllPhraseContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *UnstringOrAllPhraseContext) ALL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALL, 0)
}

func (s *UnstringOrAllPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnstringOrAllPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnstringOrAllPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterUnstringOrAllPhrase(s)
	}
}

func (s *UnstringOrAllPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitUnstringOrAllPhrase(s)
	}
}

func (p *Cobol85Parser) UnstringOrAllPhrase() (localctx IUnstringOrAllPhraseContext) {
	localctx = NewUnstringOrAllPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 972, Cobol85ParserRULE_unstringOrAllPhrase)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5486)
		p.Match(Cobol85ParserOR)
	}
	p.SetState(5488)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 847, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5487)
			p.Match(Cobol85ParserALL)
		}

	}
	p.SetState(5492)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 848, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(5490)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(5491)
			p.Literal()
		}

	}

	return localctx
}

// IUnstringIntoPhraseContext is an interface to support dynamic dispatch.
type IUnstringIntoPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnstringIntoPhraseContext differentiates from other interfaces.
	IsUnstringIntoPhraseContext()
}

type UnstringIntoPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnstringIntoPhraseContext() *UnstringIntoPhraseContext {
	var p = new(UnstringIntoPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_unstringIntoPhrase
	return p
}

func (*UnstringIntoPhraseContext) IsUnstringIntoPhraseContext() {}

func NewUnstringIntoPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnstringIntoPhraseContext {
	var p = new(UnstringIntoPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_unstringIntoPhrase

	return p
}

func (s *UnstringIntoPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *UnstringIntoPhraseContext) INTO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINTO, 0)
}

func (s *UnstringIntoPhraseContext) AllUnstringInto() []IUnstringIntoContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IUnstringIntoContext)(nil)).Elem())
	var tst = make([]IUnstringIntoContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IUnstringIntoContext)
		}
	}

	return tst
}

func (s *UnstringIntoPhraseContext) UnstringInto(i int) IUnstringIntoContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnstringIntoContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IUnstringIntoContext)
}

func (s *UnstringIntoPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnstringIntoPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnstringIntoPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterUnstringIntoPhrase(s)
	}
}

func (s *UnstringIntoPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitUnstringIntoPhrase(s)
	}
}

func (p *Cobol85Parser) UnstringIntoPhrase() (localctx IUnstringIntoPhraseContext) {
	localctx = NewUnstringIntoPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 974, Cobol85ParserRULE_unstringIntoPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5494)
		p.Match(Cobol85ParserINTO)
	}
	p.SetState(5496)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserADDRESS)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH)|(1<<Cobol85ParserATTRIBUTE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBINARY-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-68))|(1<<(Cobol85ParserCOBOL-68))|(1<<(Cobol85ParserCOMMITMENT-68))|(1<<(Cobol85ParserCONTROL_POINT-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(Cobol85ParserCONVENTION-100))|(1<<(Cobol85ParserCRUNCH-100))|(1<<(Cobol85ParserCURSOR-100))|(1<<(Cobol85ParserDATE-100))|(1<<(Cobol85ParserDAY-100))|(1<<(Cobol85ParserDAY_OF_WEEK-100))|(1<<(Cobol85ParserDEBUG_CONTENTS-100))|(1<<(Cobol85ParserDEBUG_ITEM-100))|(1<<(Cobol85ParserDEBUG_LINE-100))|(1<<(Cobol85ParserDEBUG_NAME-100))|(1<<(Cobol85ParserDEBUG_SUB_1-100))|(1<<(Cobol85ParserDEBUG_SUB_2-100))|(1<<(Cobol85ParserDEBUG_SUB_3-100))|(1<<(Cobol85ParserDEFAULT-100))|(1<<(Cobol85ParserDEFAULT_DISPLAY-100))|(1<<(Cobol85ParserDEFINITION-100)))) != 0) || (((_la-138)&-(0x1f+1)) == 0 && ((1<<uint((_la-138)))&((1<<(Cobol85ParserDFHRESP-138))|(1<<(Cobol85ParserDFHVALUE-138))|(1<<(Cobol85ParserDISK-138))|(1<<(Cobol85ParserDONTCARE-138))|(1<<(Cobol85ParserDOUBLE-138))|(1<<(Cobol85ParserEBCDIC-138))|(1<<(Cobol85ParserEMPTY_CHECK-138)))) != 0) || (((_la-181)&-(0x1f+1)) == 0 && ((1<<uint((_la-181)))&((1<<(Cobol85ParserENTER-181))|(1<<(Cobol85ParserENTRY_PROCEDURE-181))|(1<<(Cobol85ParserERASE-181))|(1<<(Cobol85ParserEOL-181))|(1<<(Cobol85ParserEOS-181))|(1<<(Cobol85ParserESCAPE-181))|(1<<(Cobol85ParserEVENT-181))|(1<<(Cobol85ParserEXCLUSIVE-181))|(1<<(Cobol85ParserEXPORT-181))|(1<<(Cobol85ParserEXTENDED-181)))) != 0) || (((_la-213)&-(0x1f+1)) == 0 && ((1<<uint((_la-213)))&((1<<(Cobol85ParserFOREGROUND_COLOR-213))|(1<<(Cobol85ParserFOREGROUND_COLOUR-213))|(1<<(Cobol85ParserFULL-213))|(1<<(Cobol85ParserFUNCTION-213))|(1<<(Cobol85ParserFUNCTIONNAME-213))|(1<<(Cobol85ParserFUNCTION_POINTER-213))|(1<<(Cobol85ParserGRID-213))|(1<<(Cobol85ParserHIGHLIGHT-213))|(1<<(Cobol85ParserIMPLICIT-213))|(1<<(Cobol85ParserIMPORT-213)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(Cobol85ParserINTEGER-250))|(1<<(Cobol85ParserKEPT-250))|(1<<(Cobol85ParserKEYBOARD-250))|(1<<(Cobol85ParserLANGUAGE-250))|(1<<(Cobol85ParserLB-250))|(1<<(Cobol85ParserLD-250))|(1<<(Cobol85ParserLEFTLINE-250))|(1<<(Cobol85ParserLENGTH-250))|(1<<(Cobol85ParserLENGTH_CHECK-250))|(1<<(Cobol85ParserLIBACCESS-250))|(1<<(Cobol85ParserLIBPARAMETER-250))|(1<<(Cobol85ParserLIBRARY-250))|(1<<(Cobol85ParserLINAGE_COUNTER-250))|(1<<(Cobol85ParserLINE_COUNTER-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(Cobol85ParserLIST-283))|(1<<(Cobol85ParserLOCAL-283))|(1<<(Cobol85ParserLONG_DATE-283))|(1<<(Cobol85ParserLONG_TIME-283))|(1<<(Cobol85ParserLOWER-283))|(1<<(Cobol85ParserLOWLIGHT-283))|(1<<(Cobol85ParserMMDDYYYY-283))|(1<<(Cobol85ParserNAMED-283))|(1<<(Cobol85ParserNATIONAL-283))|(1<<(Cobol85ParserNATIONAL_EDITED-283))|(1<<(Cobol85ParserNETWORK-283))|(1<<(Cobol85ParserNO_ECHO-283)))) != 0) || (((_la-317)&-(0x1f+1)) == 0 && ((1<<uint((_la-317)))&((1<<(Cobol85ParserNUMERIC_DATE-317))|(1<<(Cobol85ParserNUMERIC_TIME-317))|(1<<(Cobol85ParserODT-317))|(1<<(Cobol85ParserORDERLY-317))|(1<<(Cobol85ParserOVERLINE-317))|(1<<(Cobol85ParserOWN-317))|(1<<(Cobol85ParserPAGE_COUNTER-317))|(1<<(Cobol85ParserPASSWORD-317)))) != 0) || (((_la-352)&-(0x1f+1)) == 0 && ((1<<uint((_la-352)))&((1<<(Cobol85ParserPORT-352))|(1<<(Cobol85ParserPRINTER-352))|(1<<(Cobol85ParserPRIVATE-352))|(1<<(Cobol85ParserPROCESS-352))|(1<<(Cobol85ParserPROGRAM-352))|(1<<(Cobol85ParserPROMPT-352))|(1<<(Cobol85ParserREADER-352))|(1<<(Cobol85ParserREMOTE-352))|(1<<(Cobol85ParserREAL-352))|(1<<(Cobol85ParserRECEIVED-352))|(1<<(Cobol85ParserRECURSIVE-352))|(1<<(Cobol85ParserREF-352)))) != 0) || (((_la-391)&-(0x1f+1)) == 0 && ((1<<uint((_la-391)))&((1<<(Cobol85ParserREMOVE-391))|(1<<(Cobol85ParserREQUIRED-391))|(1<<(Cobol85ParserREVERSE_VIDEO-391))|(1<<(Cobol85ParserRETURN_CODE-391))|(1<<(Cobol85ParserSAVE-391))|(1<<(Cobol85ParserSECURE-391)))) != 0) || (((_la-431)&-(0x1f+1)) == 0 && ((1<<uint((_la-431)))&((1<<(Cobol85ParserSHARED-431))|(1<<(Cobol85ParserSHAREDBYALL-431))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-431))|(1<<(Cobol85ParserSHARING-431))|(1<<(Cobol85ParserSHIFT_IN-431))|(1<<(Cobol85ParserSHIFT_OUT-431))|(1<<(Cobol85ParserSHORT_DATE-431))|(1<<(Cobol85ParserSORT_CONTROL-431))|(1<<(Cobol85ParserSORT_CORE_SIZE-431))|(1<<(Cobol85ParserSORT_FILE_SIZE-431))|(1<<(Cobol85ParserSORT_MESSAGE-431))|(1<<(Cobol85ParserSORT_MODE_SIZE-431))|(1<<(Cobol85ParserSORT_RETURN-431)))) != 0) || (((_la-466)&-(0x1f+1)) == 0 && ((1<<uint((_la-466)))&((1<<(Cobol85ParserSYMBOL-466))|(1<<(Cobol85ParserTALLY-466))|(1<<(Cobol85ParserTASK-466))|(1<<(Cobol85ParserTHREAD-466))|(1<<(Cobol85ParserTHREAD_LOCAL-466))|(1<<(Cobol85ParserTIME-466))|(1<<(Cobol85ParserTIMER-466))|(1<<(Cobol85ParserTODAYS_DATE-466))|(1<<(Cobol85ParserTODAYS_NAME-466))|(1<<(Cobol85ParserTRUNCATED-466))|(1<<(Cobol85ParserTYPEDEF-466)))) != 0) || (((_la-498)&-(0x1f+1)) == 0 && ((1<<uint((_la-498)))&((1<<(Cobol85ParserUNDERLINE-498))|(1<<(Cobol85ParserVIRTUAL-498))|(1<<(Cobol85ParserWAIT-498))|(1<<(Cobol85ParserWHEN_COMPILED-498))|(1<<(Cobol85ParserYEAR-498))|(1<<(Cobol85ParserYYYYMMDD-498))|(1<<(Cobol85ParserYYYYDDD-498))|(1<<(Cobol85ParserZERO_FILL-498)))) != 0) || (((_la-552)&-(0x1f+1)) == 0 && ((1<<uint((_la-552)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-552))|(1<<(Cobol85ParserLEVEL_NUMBER_77-552))|(1<<(Cobol85ParserLEVEL_NUMBER_88-552))|(1<<(Cobol85ParserINTEGERLITERAL-552))|(1<<(Cobol85ParserIDENTIFIER-552)))) != 0) {
		{
			p.SetState(5495)
			p.UnstringInto()
		}

		p.SetState(5498)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IUnstringIntoContext is an interface to support dynamic dispatch.
type IUnstringIntoContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnstringIntoContext differentiates from other interfaces.
	IsUnstringIntoContext()
}

type UnstringIntoContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnstringIntoContext() *UnstringIntoContext {
	var p = new(UnstringIntoContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_unstringInto
	return p
}

func (*UnstringIntoContext) IsUnstringIntoContext() {}

func NewUnstringIntoContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnstringIntoContext {
	var p = new(UnstringIntoContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_unstringInto

	return p
}

func (s *UnstringIntoContext) GetParser() antlr.Parser { return s.parser }

func (s *UnstringIntoContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *UnstringIntoContext) UnstringDelimiterIn() IUnstringDelimiterInContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnstringDelimiterInContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnstringDelimiterInContext)
}

func (s *UnstringIntoContext) UnstringCountIn() IUnstringCountInContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnstringCountInContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnstringCountInContext)
}

func (s *UnstringIntoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnstringIntoContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnstringIntoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterUnstringInto(s)
	}
}

func (s *UnstringIntoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitUnstringInto(s)
	}
}

func (p *Cobol85Parser) UnstringInto() (localctx IUnstringIntoContext) {
	localctx = NewUnstringIntoContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 976, Cobol85ParserRULE_unstringInto)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5500)
		p.Identifier()
	}
	p.SetState(5502)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserDELIMITER {
		{
			p.SetState(5501)
			p.UnstringDelimiterIn()
		}

	}
	p.SetState(5505)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCOUNT {
		{
			p.SetState(5504)
			p.UnstringCountIn()
		}

	}

	return localctx
}

// IUnstringDelimiterInContext is an interface to support dynamic dispatch.
type IUnstringDelimiterInContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnstringDelimiterInContext differentiates from other interfaces.
	IsUnstringDelimiterInContext()
}

type UnstringDelimiterInContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnstringDelimiterInContext() *UnstringDelimiterInContext {
	var p = new(UnstringDelimiterInContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_unstringDelimiterIn
	return p
}

func (*UnstringDelimiterInContext) IsUnstringDelimiterInContext() {}

func NewUnstringDelimiterInContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnstringDelimiterInContext {
	var p = new(UnstringDelimiterInContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_unstringDelimiterIn

	return p
}

func (s *UnstringDelimiterInContext) GetParser() antlr.Parser { return s.parser }

func (s *UnstringDelimiterInContext) DELIMITER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDELIMITER, 0)
}

func (s *UnstringDelimiterInContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *UnstringDelimiterInContext) IN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIN, 0)
}

func (s *UnstringDelimiterInContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnstringDelimiterInContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnstringDelimiterInContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterUnstringDelimiterIn(s)
	}
}

func (s *UnstringDelimiterInContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitUnstringDelimiterIn(s)
	}
}

func (p *Cobol85Parser) UnstringDelimiterIn() (localctx IUnstringDelimiterInContext) {
	localctx = NewUnstringDelimiterInContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 978, Cobol85ParserRULE_unstringDelimiterIn)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5507)
		p.Match(Cobol85ParserDELIMITER)
	}
	p.SetState(5509)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIN {
		{
			p.SetState(5508)
			p.Match(Cobol85ParserIN)
		}

	}
	{
		p.SetState(5511)
		p.Identifier()
	}

	return localctx
}

// IUnstringCountInContext is an interface to support dynamic dispatch.
type IUnstringCountInContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnstringCountInContext differentiates from other interfaces.
	IsUnstringCountInContext()
}

type UnstringCountInContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnstringCountInContext() *UnstringCountInContext {
	var p = new(UnstringCountInContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_unstringCountIn
	return p
}

func (*UnstringCountInContext) IsUnstringCountInContext() {}

func NewUnstringCountInContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnstringCountInContext {
	var p = new(UnstringCountInContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_unstringCountIn

	return p
}

func (s *UnstringCountInContext) GetParser() antlr.Parser { return s.parser }

func (s *UnstringCountInContext) COUNT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOUNT, 0)
}

func (s *UnstringCountInContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *UnstringCountInContext) IN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIN, 0)
}

func (s *UnstringCountInContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnstringCountInContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnstringCountInContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterUnstringCountIn(s)
	}
}

func (s *UnstringCountInContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitUnstringCountIn(s)
	}
}

func (p *Cobol85Parser) UnstringCountIn() (localctx IUnstringCountInContext) {
	localctx = NewUnstringCountInContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 980, Cobol85ParserRULE_unstringCountIn)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5513)
		p.Match(Cobol85ParserCOUNT)
	}
	p.SetState(5515)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIN {
		{
			p.SetState(5514)
			p.Match(Cobol85ParserIN)
		}

	}
	{
		p.SetState(5517)
		p.Identifier()
	}

	return localctx
}

// IUnstringWithPointerPhraseContext is an interface to support dynamic dispatch.
type IUnstringWithPointerPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnstringWithPointerPhraseContext differentiates from other interfaces.
	IsUnstringWithPointerPhraseContext()
}

type UnstringWithPointerPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnstringWithPointerPhraseContext() *UnstringWithPointerPhraseContext {
	var p = new(UnstringWithPointerPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_unstringWithPointerPhrase
	return p
}

func (*UnstringWithPointerPhraseContext) IsUnstringWithPointerPhraseContext() {}

func NewUnstringWithPointerPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnstringWithPointerPhraseContext {
	var p = new(UnstringWithPointerPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_unstringWithPointerPhrase

	return p
}

func (s *UnstringWithPointerPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *UnstringWithPointerPhraseContext) POINTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPOINTER, 0)
}

func (s *UnstringWithPointerPhraseContext) QualifiedDataName() IQualifiedDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *UnstringWithPointerPhraseContext) WITH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWITH, 0)
}

func (s *UnstringWithPointerPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnstringWithPointerPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnstringWithPointerPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterUnstringWithPointerPhrase(s)
	}
}

func (s *UnstringWithPointerPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitUnstringWithPointerPhrase(s)
	}
}

func (p *Cobol85Parser) UnstringWithPointerPhrase() (localctx IUnstringWithPointerPhraseContext) {
	localctx = NewUnstringWithPointerPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 982, Cobol85ParserRULE_unstringWithPointerPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5520)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserWITH {
		{
			p.SetState(5519)
			p.Match(Cobol85ParserWITH)
		}

	}
	{
		p.SetState(5522)
		p.Match(Cobol85ParserPOINTER)
	}
	{
		p.SetState(5523)
		p.QualifiedDataName()
	}

	return localctx
}

// IUnstringTallyingPhraseContext is an interface to support dynamic dispatch.
type IUnstringTallyingPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnstringTallyingPhraseContext differentiates from other interfaces.
	IsUnstringTallyingPhraseContext()
}

type UnstringTallyingPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnstringTallyingPhraseContext() *UnstringTallyingPhraseContext {
	var p = new(UnstringTallyingPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_unstringTallyingPhrase
	return p
}

func (*UnstringTallyingPhraseContext) IsUnstringTallyingPhraseContext() {}

func NewUnstringTallyingPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnstringTallyingPhraseContext {
	var p = new(UnstringTallyingPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_unstringTallyingPhrase

	return p
}

func (s *UnstringTallyingPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *UnstringTallyingPhraseContext) TALLYING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTALLYING, 0)
}

func (s *UnstringTallyingPhraseContext) QualifiedDataName() IQualifiedDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *UnstringTallyingPhraseContext) IN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIN, 0)
}

func (s *UnstringTallyingPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnstringTallyingPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnstringTallyingPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterUnstringTallyingPhrase(s)
	}
}

func (s *UnstringTallyingPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitUnstringTallyingPhrase(s)
	}
}

func (p *Cobol85Parser) UnstringTallyingPhrase() (localctx IUnstringTallyingPhraseContext) {
	localctx = NewUnstringTallyingPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 984, Cobol85ParserRULE_unstringTallyingPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5525)
		p.Match(Cobol85ParserTALLYING)
	}
	p.SetState(5527)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIN {
		{
			p.SetState(5526)
			p.Match(Cobol85ParserIN)
		}

	}
	{
		p.SetState(5529)
		p.QualifiedDataName()
	}

	return localctx
}

// IUseStatementContext is an interface to support dynamic dispatch.
type IUseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUseStatementContext differentiates from other interfaces.
	IsUseStatementContext()
}

type UseStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUseStatementContext() *UseStatementContext {
	var p = new(UseStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_useStatement
	return p
}

func (*UseStatementContext) IsUseStatementContext() {}

func NewUseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UseStatementContext {
	var p = new(UseStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_useStatement

	return p
}

func (s *UseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UseStatementContext) USE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserUSE, 0)
}

func (s *UseStatementContext) UseAfterClause() IUseAfterClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUseAfterClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUseAfterClauseContext)
}

func (s *UseStatementContext) UseDebugClause() IUseDebugClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUseDebugClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUseDebugClauseContext)
}

func (s *UseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterUseStatement(s)
	}
}

func (s *UseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitUseStatement(s)
	}
}

func (p *Cobol85Parser) UseStatement() (localctx IUseStatementContext) {
	localctx = NewUseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 986, Cobol85ParserRULE_useStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5531)
		p.Match(Cobol85ParserUSE)
	}
	p.SetState(5534)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserAFTER, Cobol85ParserGLOBAL:
		{
			p.SetState(5532)
			p.UseAfterClause()
		}

	case Cobol85ParserDEBUGGING, Cobol85ParserFOR:
		{
			p.SetState(5533)
			p.UseDebugClause()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IUseAfterClauseContext is an interface to support dynamic dispatch.
type IUseAfterClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUseAfterClauseContext differentiates from other interfaces.
	IsUseAfterClauseContext()
}

type UseAfterClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUseAfterClauseContext() *UseAfterClauseContext {
	var p = new(UseAfterClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_useAfterClause
	return p
}

func (*UseAfterClauseContext) IsUseAfterClauseContext() {}

func NewUseAfterClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UseAfterClauseContext {
	var p = new(UseAfterClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_useAfterClause

	return p
}

func (s *UseAfterClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *UseAfterClauseContext) AFTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAFTER, 0)
}

func (s *UseAfterClauseContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPROCEDURE, 0)
}

func (s *UseAfterClauseContext) UseAfterOn() IUseAfterOnContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUseAfterOnContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUseAfterOnContext)
}

func (s *UseAfterClauseContext) EXCEPTION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEXCEPTION, 0)
}

func (s *UseAfterClauseContext) ERROR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserERROR, 0)
}

func (s *UseAfterClauseContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserGLOBAL, 0)
}

func (s *UseAfterClauseContext) STANDARD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSTANDARD, 0)
}

func (s *UseAfterClauseContext) ON() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserON, 0)
}

func (s *UseAfterClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UseAfterClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UseAfterClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterUseAfterClause(s)
	}
}

func (s *UseAfterClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitUseAfterClause(s)
	}
}

func (p *Cobol85Parser) UseAfterClause() (localctx IUseAfterClauseContext) {
	localctx = NewUseAfterClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 988, Cobol85ParserRULE_useAfterClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5537)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserGLOBAL {
		{
			p.SetState(5536)
			p.Match(Cobol85ParserGLOBAL)
		}

	}
	{
		p.SetState(5539)
		p.Match(Cobol85ParserAFTER)
	}
	p.SetState(5541)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserSTANDARD {
		{
			p.SetState(5540)
			p.Match(Cobol85ParserSTANDARD)
		}

	}
	{
		p.SetState(5543)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserERROR || _la == Cobol85ParserEXCEPTION) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(5544)
		p.Match(Cobol85ParserPROCEDURE)
	}
	p.SetState(5546)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserON {
		{
			p.SetState(5545)
			p.Match(Cobol85ParserON)
		}

	}
	{
		p.SetState(5548)
		p.UseAfterOn()
	}

	return localctx
}

// IUseAfterOnContext is an interface to support dynamic dispatch.
type IUseAfterOnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUseAfterOnContext differentiates from other interfaces.
	IsUseAfterOnContext()
}

type UseAfterOnContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUseAfterOnContext() *UseAfterOnContext {
	var p = new(UseAfterOnContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_useAfterOn
	return p
}

func (*UseAfterOnContext) IsUseAfterOnContext() {}

func NewUseAfterOnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UseAfterOnContext {
	var p = new(UseAfterOnContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_useAfterOn

	return p
}

func (s *UseAfterOnContext) GetParser() antlr.Parser { return s.parser }

func (s *UseAfterOnContext) INPUT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINPUT, 0)
}

func (s *UseAfterOnContext) OUTPUT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOUTPUT, 0)
}

func (s *UseAfterOnContext) I_O() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserI_O, 0)
}

func (s *UseAfterOnContext) EXTEND() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEXTEND, 0)
}

func (s *UseAfterOnContext) AllFileName() []IFileNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFileNameContext)(nil)).Elem())
	var tst = make([]IFileNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFileNameContext)
		}
	}

	return tst
}

func (s *UseAfterOnContext) FileName(i int) IFileNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *UseAfterOnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UseAfterOnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UseAfterOnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterUseAfterOn(s)
	}
}

func (s *UseAfterOnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitUseAfterOn(s)
	}
}

func (p *Cobol85Parser) UseAfterOn() (localctx IUseAfterOnContext) {
	localctx = NewUseAfterOnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 990, Cobol85ParserRULE_useAfterOn)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5559)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserINPUT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5550)
			p.Match(Cobol85ParserINPUT)
		}

	case Cobol85ParserOUTPUT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5551)
			p.Match(Cobol85ParserOUTPUT)
		}

	case Cobol85ParserI_O:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5552)
			p.Match(Cobol85ParserI_O)
		}

	case Cobol85ParserEXTEND:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5553)
			p.Match(Cobol85ParserEXTEND)
		}

	case Cobol85ParserABORT, Cobol85ParserAS, Cobol85ParserASCII, Cobol85ParserASSOCIATED_DATA, Cobol85ParserASSOCIATED_DATA_LENGTH, Cobol85ParserATTRIBUTE, Cobol85ParserAUTO, Cobol85ParserAUTO_SKIP, Cobol85ParserBACKGROUND_COLOR, Cobol85ParserBACKGROUND_COLOUR, Cobol85ParserBEEP, Cobol85ParserBELL, Cobol85ParserBINARY, Cobol85ParserBIT, Cobol85ParserBLINK, Cobol85ParserBOUNDS, Cobol85ParserCAPABLE, Cobol85ParserCCSVERSION, Cobol85ParserCHANGED, Cobol85ParserCHANNEL, Cobol85ParserCLOSE_DISPOSITION, Cobol85ParserCOBOL, Cobol85ParserCOMMITMENT, Cobol85ParserCONTROL_POINT, Cobol85ParserCONVENTION, Cobol85ParserCRUNCH, Cobol85ParserCURSOR, Cobol85ParserDEFAULT, Cobol85ParserDEFAULT_DISPLAY, Cobol85ParserDEFINITION, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserDISK, Cobol85ParserDONTCARE, Cobol85ParserDOUBLE, Cobol85ParserEBCDIC, Cobol85ParserEMPTY_CHECK, Cobol85ParserENTER, Cobol85ParserENTRY_PROCEDURE, Cobol85ParserERASE, Cobol85ParserEOL, Cobol85ParserEOS, Cobol85ParserESCAPE, Cobol85ParserEVENT, Cobol85ParserEXCLUSIVE, Cobol85ParserEXPORT, Cobol85ParserEXTENDED, Cobol85ParserFOREGROUND_COLOR, Cobol85ParserFOREGROUND_COLOUR, Cobol85ParserFULL, Cobol85ParserFUNCTIONNAME, Cobol85ParserFUNCTION_POINTER, Cobol85ParserGRID, Cobol85ParserHIGHLIGHT, Cobol85ParserIMPLICIT, Cobol85ParserIMPORT, Cobol85ParserINTEGER, Cobol85ParserKEPT, Cobol85ParserKEYBOARD, Cobol85ParserLANGUAGE, Cobol85ParserLB, Cobol85ParserLD, Cobol85ParserLEFTLINE, Cobol85ParserLENGTH_CHECK, Cobol85ParserLIBACCESS, Cobol85ParserLIBPARAMETER, Cobol85ParserLIBRARY, Cobol85ParserLIST, Cobol85ParserLOCAL, Cobol85ParserLONG_DATE, Cobol85ParserLONG_TIME, Cobol85ParserLOWER, Cobol85ParserLOWLIGHT, Cobol85ParserMMDDYYYY, Cobol85ParserNAMED, Cobol85ParserNATIONAL, Cobol85ParserNATIONAL_EDITED, Cobol85ParserNETWORK, Cobol85ParserNO_ECHO, Cobol85ParserNUMERIC_DATE, Cobol85ParserNUMERIC_TIME, Cobol85ParserODT, Cobol85ParserORDERLY, Cobol85ParserOVERLINE, Cobol85ParserOWN, Cobol85ParserPASSWORD, Cobol85ParserPORT, Cobol85ParserPRINTER, Cobol85ParserPRIVATE, Cobol85ParserPROCESS, Cobol85ParserPROGRAM, Cobol85ParserPROMPT, Cobol85ParserREADER, Cobol85ParserREMOTE, Cobol85ParserREAL, Cobol85ParserRECEIVED, Cobol85ParserRECURSIVE, Cobol85ParserREF, Cobol85ParserREMOVE, Cobol85ParserREQUIRED, Cobol85ParserREVERSE_VIDEO, Cobol85ParserSAVE, Cobol85ParserSECURE, Cobol85ParserSHARED, Cobol85ParserSHAREDBYALL, Cobol85ParserSHAREDBYRUNUNIT, Cobol85ParserSHARING, Cobol85ParserSHORT_DATE, Cobol85ParserSYMBOL, Cobol85ParserTASK, Cobol85ParserTHREAD, Cobol85ParserTHREAD_LOCAL, Cobol85ParserTIMER, Cobol85ParserTODAYS_DATE, Cobol85ParserTODAYS_NAME, Cobol85ParserTRUNCATED, Cobol85ParserTYPEDEF, Cobol85ParserUNDERLINE, Cobol85ParserVIRTUAL, Cobol85ParserWAIT, Cobol85ParserYEAR, Cobol85ParserYYYYMMDD, Cobol85ParserYYYYDDD, Cobol85ParserZERO_FILL, Cobol85ParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 5)
		p.SetState(5555)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH)|(1<<Cobol85ParserATTRIBUTE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBINARY-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-68))|(1<<(Cobol85ParserCOBOL-68))|(1<<(Cobol85ParserCOMMITMENT-68))|(1<<(Cobol85ParserCONTROL_POINT-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(Cobol85ParserCONVENTION-100))|(1<<(Cobol85ParserCRUNCH-100))|(1<<(Cobol85ParserCURSOR-100))|(1<<(Cobol85ParserDEFAULT-100))|(1<<(Cobol85ParserDEFAULT_DISPLAY-100))|(1<<(Cobol85ParserDEFINITION-100)))) != 0) || (((_la-138)&-(0x1f+1)) == 0 && ((1<<uint((_la-138)))&((1<<(Cobol85ParserDFHRESP-138))|(1<<(Cobol85ParserDFHVALUE-138))|(1<<(Cobol85ParserDISK-138))|(1<<(Cobol85ParserDONTCARE-138))|(1<<(Cobol85ParserDOUBLE-138))|(1<<(Cobol85ParserEBCDIC-138))|(1<<(Cobol85ParserEMPTY_CHECK-138)))) != 0) || (((_la-181)&-(0x1f+1)) == 0 && ((1<<uint((_la-181)))&((1<<(Cobol85ParserENTER-181))|(1<<(Cobol85ParserENTRY_PROCEDURE-181))|(1<<(Cobol85ParserERASE-181))|(1<<(Cobol85ParserEOL-181))|(1<<(Cobol85ParserEOS-181))|(1<<(Cobol85ParserESCAPE-181))|(1<<(Cobol85ParserEVENT-181))|(1<<(Cobol85ParserEXCLUSIVE-181))|(1<<(Cobol85ParserEXPORT-181))|(1<<(Cobol85ParserEXTENDED-181)))) != 0) || (((_la-213)&-(0x1f+1)) == 0 && ((1<<uint((_la-213)))&((1<<(Cobol85ParserFOREGROUND_COLOR-213))|(1<<(Cobol85ParserFOREGROUND_COLOUR-213))|(1<<(Cobol85ParserFULL-213))|(1<<(Cobol85ParserFUNCTIONNAME-213))|(1<<(Cobol85ParserFUNCTION_POINTER-213))|(1<<(Cobol85ParserGRID-213))|(1<<(Cobol85ParserHIGHLIGHT-213))|(1<<(Cobol85ParserIMPLICIT-213))|(1<<(Cobol85ParserIMPORT-213)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(Cobol85ParserINTEGER-250))|(1<<(Cobol85ParserKEPT-250))|(1<<(Cobol85ParserKEYBOARD-250))|(1<<(Cobol85ParserLANGUAGE-250))|(1<<(Cobol85ParserLB-250))|(1<<(Cobol85ParserLD-250))|(1<<(Cobol85ParserLEFTLINE-250))|(1<<(Cobol85ParserLENGTH_CHECK-250))|(1<<(Cobol85ParserLIBACCESS-250))|(1<<(Cobol85ParserLIBPARAMETER-250))|(1<<(Cobol85ParserLIBRARY-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(Cobol85ParserLIST-283))|(1<<(Cobol85ParserLOCAL-283))|(1<<(Cobol85ParserLONG_DATE-283))|(1<<(Cobol85ParserLONG_TIME-283))|(1<<(Cobol85ParserLOWER-283))|(1<<(Cobol85ParserLOWLIGHT-283))|(1<<(Cobol85ParserMMDDYYYY-283))|(1<<(Cobol85ParserNAMED-283))|(1<<(Cobol85ParserNATIONAL-283))|(1<<(Cobol85ParserNATIONAL_EDITED-283))|(1<<(Cobol85ParserNETWORK-283))|(1<<(Cobol85ParserNO_ECHO-283)))) != 0) || (((_la-317)&-(0x1f+1)) == 0 && ((1<<uint((_la-317)))&((1<<(Cobol85ParserNUMERIC_DATE-317))|(1<<(Cobol85ParserNUMERIC_TIME-317))|(1<<(Cobol85ParserODT-317))|(1<<(Cobol85ParserORDERLY-317))|(1<<(Cobol85ParserOVERLINE-317))|(1<<(Cobol85ParserOWN-317))|(1<<(Cobol85ParserPASSWORD-317)))) != 0) || (((_la-352)&-(0x1f+1)) == 0 && ((1<<uint((_la-352)))&((1<<(Cobol85ParserPORT-352))|(1<<(Cobol85ParserPRINTER-352))|(1<<(Cobol85ParserPRIVATE-352))|(1<<(Cobol85ParserPROCESS-352))|(1<<(Cobol85ParserPROGRAM-352))|(1<<(Cobol85ParserPROMPT-352))|(1<<(Cobol85ParserREADER-352))|(1<<(Cobol85ParserREMOTE-352))|(1<<(Cobol85ParserREAL-352))|(1<<(Cobol85ParserRECEIVED-352))|(1<<(Cobol85ParserRECURSIVE-352))|(1<<(Cobol85ParserREF-352)))) != 0) || (((_la-391)&-(0x1f+1)) == 0 && ((1<<uint((_la-391)))&((1<<(Cobol85ParserREMOVE-391))|(1<<(Cobol85ParserREQUIRED-391))|(1<<(Cobol85ParserREVERSE_VIDEO-391))|(1<<(Cobol85ParserSAVE-391))|(1<<(Cobol85ParserSECURE-391)))) != 0) || (((_la-431)&-(0x1f+1)) == 0 && ((1<<uint((_la-431)))&((1<<(Cobol85ParserSHARED-431))|(1<<(Cobol85ParserSHAREDBYALL-431))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-431))|(1<<(Cobol85ParserSHARING-431))|(1<<(Cobol85ParserSHORT_DATE-431)))) != 0) || (((_la-466)&-(0x1f+1)) == 0 && ((1<<uint((_la-466)))&((1<<(Cobol85ParserSYMBOL-466))|(1<<(Cobol85ParserTASK-466))|(1<<(Cobol85ParserTHREAD-466))|(1<<(Cobol85ParserTHREAD_LOCAL-466))|(1<<(Cobol85ParserTIMER-466))|(1<<(Cobol85ParserTODAYS_DATE-466))|(1<<(Cobol85ParserTODAYS_NAME-466))|(1<<(Cobol85ParserTRUNCATED-466))|(1<<(Cobol85ParserTYPEDEF-466)))) != 0) || (((_la-498)&-(0x1f+1)) == 0 && ((1<<uint((_la-498)))&((1<<(Cobol85ParserUNDERLINE-498))|(1<<(Cobol85ParserVIRTUAL-498))|(1<<(Cobol85ParserWAIT-498))|(1<<(Cobol85ParserYEAR-498))|(1<<(Cobol85ParserYYYYMMDD-498))|(1<<(Cobol85ParserYYYYDDD-498))|(1<<(Cobol85ParserZERO_FILL-498)))) != 0) || _la == Cobol85ParserIDENTIFIER {
			{
				p.SetState(5554)
				p.FileName()
			}

			p.SetState(5557)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IUseDebugClauseContext is an interface to support dynamic dispatch.
type IUseDebugClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUseDebugClauseContext differentiates from other interfaces.
	IsUseDebugClauseContext()
}

type UseDebugClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUseDebugClauseContext() *UseDebugClauseContext {
	var p = new(UseDebugClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_useDebugClause
	return p
}

func (*UseDebugClauseContext) IsUseDebugClauseContext() {}

func NewUseDebugClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UseDebugClauseContext {
	var p = new(UseDebugClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_useDebugClause

	return p
}

func (s *UseDebugClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *UseDebugClauseContext) DEBUGGING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDEBUGGING, 0)
}

func (s *UseDebugClauseContext) FOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOR, 0)
}

func (s *UseDebugClauseContext) ON() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserON, 0)
}

func (s *UseDebugClauseContext) AllUseDebugOn() []IUseDebugOnContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IUseDebugOnContext)(nil)).Elem())
	var tst = make([]IUseDebugOnContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IUseDebugOnContext)
		}
	}

	return tst
}

func (s *UseDebugClauseContext) UseDebugOn(i int) IUseDebugOnContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUseDebugOnContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IUseDebugOnContext)
}

func (s *UseDebugClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UseDebugClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UseDebugClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterUseDebugClause(s)
	}
}

func (s *UseDebugClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitUseDebugClause(s)
	}
}

func (p *Cobol85Parser) UseDebugClause() (localctx IUseDebugClauseContext) {
	localctx = NewUseDebugClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 992, Cobol85ParserRULE_useDebugClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5562)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFOR {
		{
			p.SetState(5561)
			p.Match(Cobol85ParserFOR)
		}

	}
	{
		p.SetState(5564)
		p.Match(Cobol85ParserDEBUGGING)
	}
	p.SetState(5566)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserON {
		{
			p.SetState(5565)
			p.Match(Cobol85ParserON)
		}

	}
	p.SetState(5569)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserALL)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH)|(1<<Cobol85ParserATTRIBUTE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBINARY-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-68))|(1<<(Cobol85ParserCOBOL-68))|(1<<(Cobol85ParserCOMMITMENT-68))|(1<<(Cobol85ParserCONTROL_POINT-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(Cobol85ParserCONVENTION-100))|(1<<(Cobol85ParserCRUNCH-100))|(1<<(Cobol85ParserCURSOR-100))|(1<<(Cobol85ParserDEFAULT-100))|(1<<(Cobol85ParserDEFAULT_DISPLAY-100))|(1<<(Cobol85ParserDEFINITION-100)))) != 0) || (((_la-138)&-(0x1f+1)) == 0 && ((1<<uint((_la-138)))&((1<<(Cobol85ParserDFHRESP-138))|(1<<(Cobol85ParserDFHVALUE-138))|(1<<(Cobol85ParserDISK-138))|(1<<(Cobol85ParserDONTCARE-138))|(1<<(Cobol85ParserDOUBLE-138))|(1<<(Cobol85ParserEBCDIC-138))|(1<<(Cobol85ParserEMPTY_CHECK-138)))) != 0) || (((_la-181)&-(0x1f+1)) == 0 && ((1<<uint((_la-181)))&((1<<(Cobol85ParserENTER-181))|(1<<(Cobol85ParserENTRY_PROCEDURE-181))|(1<<(Cobol85ParserERASE-181))|(1<<(Cobol85ParserEOL-181))|(1<<(Cobol85ParserEOS-181))|(1<<(Cobol85ParserESCAPE-181))|(1<<(Cobol85ParserEVENT-181))|(1<<(Cobol85ParserEXCLUSIVE-181))|(1<<(Cobol85ParserEXPORT-181))|(1<<(Cobol85ParserEXTENDED-181)))) != 0) || (((_la-213)&-(0x1f+1)) == 0 && ((1<<uint((_la-213)))&((1<<(Cobol85ParserFOREGROUND_COLOR-213))|(1<<(Cobol85ParserFOREGROUND_COLOUR-213))|(1<<(Cobol85ParserFULL-213))|(1<<(Cobol85ParserFUNCTIONNAME-213))|(1<<(Cobol85ParserFUNCTION_POINTER-213))|(1<<(Cobol85ParserGRID-213))|(1<<(Cobol85ParserHIGHLIGHT-213))|(1<<(Cobol85ParserIMPLICIT-213))|(1<<(Cobol85ParserIMPORT-213)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(Cobol85ParserINTEGER-250))|(1<<(Cobol85ParserKEPT-250))|(1<<(Cobol85ParserKEYBOARD-250))|(1<<(Cobol85ParserLANGUAGE-250))|(1<<(Cobol85ParserLB-250))|(1<<(Cobol85ParserLD-250))|(1<<(Cobol85ParserLEFTLINE-250))|(1<<(Cobol85ParserLENGTH_CHECK-250))|(1<<(Cobol85ParserLIBACCESS-250))|(1<<(Cobol85ParserLIBPARAMETER-250))|(1<<(Cobol85ParserLIBRARY-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(Cobol85ParserLIST-283))|(1<<(Cobol85ParserLOCAL-283))|(1<<(Cobol85ParserLONG_DATE-283))|(1<<(Cobol85ParserLONG_TIME-283))|(1<<(Cobol85ParserLOWER-283))|(1<<(Cobol85ParserLOWLIGHT-283))|(1<<(Cobol85ParserMMDDYYYY-283))|(1<<(Cobol85ParserNAMED-283))|(1<<(Cobol85ParserNATIONAL-283))|(1<<(Cobol85ParserNATIONAL_EDITED-283))|(1<<(Cobol85ParserNETWORK-283))|(1<<(Cobol85ParserNO_ECHO-283)))) != 0) || (((_la-317)&-(0x1f+1)) == 0 && ((1<<uint((_la-317)))&((1<<(Cobol85ParserNUMERIC_DATE-317))|(1<<(Cobol85ParserNUMERIC_TIME-317))|(1<<(Cobol85ParserODT-317))|(1<<(Cobol85ParserORDERLY-317))|(1<<(Cobol85ParserOVERLINE-317))|(1<<(Cobol85ParserOWN-317))|(1<<(Cobol85ParserPASSWORD-317)))) != 0) || (((_la-352)&-(0x1f+1)) == 0 && ((1<<uint((_la-352)))&((1<<(Cobol85ParserPORT-352))|(1<<(Cobol85ParserPRINTER-352))|(1<<(Cobol85ParserPRIVATE-352))|(1<<(Cobol85ParserPROCESS-352))|(1<<(Cobol85ParserPROGRAM-352))|(1<<(Cobol85ParserPROMPT-352))|(1<<(Cobol85ParserREADER-352))|(1<<(Cobol85ParserREMOTE-352))|(1<<(Cobol85ParserREAL-352))|(1<<(Cobol85ParserRECEIVED-352))|(1<<(Cobol85ParserRECURSIVE-352))|(1<<(Cobol85ParserREF-352)))) != 0) || (((_la-391)&-(0x1f+1)) == 0 && ((1<<uint((_la-391)))&((1<<(Cobol85ParserREMOVE-391))|(1<<(Cobol85ParserREQUIRED-391))|(1<<(Cobol85ParserREVERSE_VIDEO-391))|(1<<(Cobol85ParserSAVE-391))|(1<<(Cobol85ParserSECURE-391)))) != 0) || (((_la-431)&-(0x1f+1)) == 0 && ((1<<uint((_la-431)))&((1<<(Cobol85ParserSHARED-431))|(1<<(Cobol85ParserSHAREDBYALL-431))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-431))|(1<<(Cobol85ParserSHARING-431))|(1<<(Cobol85ParserSHORT_DATE-431)))) != 0) || (((_la-466)&-(0x1f+1)) == 0 && ((1<<uint((_la-466)))&((1<<(Cobol85ParserSYMBOL-466))|(1<<(Cobol85ParserTASK-466))|(1<<(Cobol85ParserTHREAD-466))|(1<<(Cobol85ParserTHREAD_LOCAL-466))|(1<<(Cobol85ParserTIMER-466))|(1<<(Cobol85ParserTODAYS_DATE-466))|(1<<(Cobol85ParserTODAYS_NAME-466))|(1<<(Cobol85ParserTRUNCATED-466))|(1<<(Cobol85ParserTYPEDEF-466)))) != 0) || (((_la-498)&-(0x1f+1)) == 0 && ((1<<uint((_la-498)))&((1<<(Cobol85ParserUNDERLINE-498))|(1<<(Cobol85ParserVIRTUAL-498))|(1<<(Cobol85ParserWAIT-498))|(1<<(Cobol85ParserYEAR-498))|(1<<(Cobol85ParserYYYYMMDD-498))|(1<<(Cobol85ParserYYYYDDD-498))|(1<<(Cobol85ParserZERO_FILL-498)))) != 0) || (((_la-552)&-(0x1f+1)) == 0 && ((1<<uint((_la-552)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-552))|(1<<(Cobol85ParserLEVEL_NUMBER_77-552))|(1<<(Cobol85ParserLEVEL_NUMBER_88-552))|(1<<(Cobol85ParserINTEGERLITERAL-552))|(1<<(Cobol85ParserIDENTIFIER-552)))) != 0) {
		{
			p.SetState(5568)
			p.UseDebugOn()
		}

		p.SetState(5571)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IUseDebugOnContext is an interface to support dynamic dispatch.
type IUseDebugOnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUseDebugOnContext differentiates from other interfaces.
	IsUseDebugOnContext()
}

type UseDebugOnContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUseDebugOnContext() *UseDebugOnContext {
	var p = new(UseDebugOnContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_useDebugOn
	return p
}

func (*UseDebugOnContext) IsUseDebugOnContext() {}

func NewUseDebugOnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UseDebugOnContext {
	var p = new(UseDebugOnContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_useDebugOn

	return p
}

func (s *UseDebugOnContext) GetParser() antlr.Parser { return s.parser }

func (s *UseDebugOnContext) ALL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALL, 0)
}

func (s *UseDebugOnContext) PROCEDURES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPROCEDURES, 0)
}

func (s *UseDebugOnContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *UseDebugOnContext) REFERENCES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREFERENCES, 0)
}

func (s *UseDebugOnContext) OF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOF, 0)
}

func (s *UseDebugOnContext) ProcedureName() IProcedureNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedureNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedureNameContext)
}

func (s *UseDebugOnContext) FileName() IFileNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *UseDebugOnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UseDebugOnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UseDebugOnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterUseDebugOn(s)
	}
}

func (s *UseDebugOnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitUseDebugOn(s)
	}
}

func (p *Cobol85Parser) UseDebugOn() (localctx IUseDebugOnContext) {
	localctx = NewUseDebugOnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 994, Cobol85ParserRULE_useDebugOn)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5585)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 867, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5573)
			p.Match(Cobol85ParserALL)
		}
		{
			p.SetState(5574)
			p.Match(Cobol85ParserPROCEDURES)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5575)
			p.Match(Cobol85ParserALL)
		}
		p.SetState(5577)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserREFERENCES {
			{
				p.SetState(5576)
				p.Match(Cobol85ParserREFERENCES)
			}

		}
		p.SetState(5580)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserOF {
			{
				p.SetState(5579)
				p.Match(Cobol85ParserOF)
			}

		}
		{
			p.SetState(5582)
			p.Identifier()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5583)
			p.ProcedureName()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5584)
			p.FileName()
		}

	}

	return localctx
}

// IWriteStatementContext is an interface to support dynamic dispatch.
type IWriteStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWriteStatementContext differentiates from other interfaces.
	IsWriteStatementContext()
}

type WriteStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWriteStatementContext() *WriteStatementContext {
	var p = new(WriteStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_writeStatement
	return p
}

func (*WriteStatementContext) IsWriteStatementContext() {}

func NewWriteStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WriteStatementContext {
	var p = new(WriteStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_writeStatement

	return p
}

func (s *WriteStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *WriteStatementContext) WRITE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWRITE, 0)
}

func (s *WriteStatementContext) RecordName() IRecordNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRecordNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRecordNameContext)
}

func (s *WriteStatementContext) WriteFromPhrase() IWriteFromPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWriteFromPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWriteFromPhraseContext)
}

func (s *WriteStatementContext) WriteAdvancingPhrase() IWriteAdvancingPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWriteAdvancingPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWriteAdvancingPhraseContext)
}

func (s *WriteStatementContext) WriteAtEndOfPagePhrase() IWriteAtEndOfPagePhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWriteAtEndOfPagePhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWriteAtEndOfPagePhraseContext)
}

func (s *WriteStatementContext) WriteNotAtEndOfPagePhrase() IWriteNotAtEndOfPagePhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWriteNotAtEndOfPagePhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWriteNotAtEndOfPagePhraseContext)
}

func (s *WriteStatementContext) InvalidKeyPhrase() IInvalidKeyPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInvalidKeyPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInvalidKeyPhraseContext)
}

func (s *WriteStatementContext) NotInvalidKeyPhrase() INotInvalidKeyPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INotInvalidKeyPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INotInvalidKeyPhraseContext)
}

func (s *WriteStatementContext) END_WRITE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND_WRITE, 0)
}

func (s *WriteStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WriteStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WriteStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterWriteStatement(s)
	}
}

func (s *WriteStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitWriteStatement(s)
	}
}

func (p *Cobol85Parser) WriteStatement() (localctx IWriteStatementContext) {
	localctx = NewWriteStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 996, Cobol85ParserRULE_writeStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5587)
		p.Match(Cobol85ParserWRITE)
	}
	{
		p.SetState(5588)
		p.RecordName()
	}
	p.SetState(5590)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFROM {
		{
			p.SetState(5589)
			p.WriteFromPhrase()
		}

	}
	p.SetState(5593)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserAFTER || _la == Cobol85ParserBEFORE {
		{
			p.SetState(5592)
			p.WriteAdvancingPhrase()
		}

	}
	p.SetState(5596)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 870, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5595)
			p.WriteAtEndOfPagePhrase()
		}

	}
	p.SetState(5599)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 871, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5598)
			p.WriteNotAtEndOfPagePhrase()
		}

	}
	p.SetState(5602)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 872, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5601)
			p.InvalidKeyPhrase()
		}

	}
	p.SetState(5605)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 873, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5604)
			p.NotInvalidKeyPhrase()
		}

	}
	p.SetState(5608)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 874, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5607)
			p.Match(Cobol85ParserEND_WRITE)
		}

	}

	return localctx
}

// IWriteFromPhraseContext is an interface to support dynamic dispatch.
type IWriteFromPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWriteFromPhraseContext differentiates from other interfaces.
	IsWriteFromPhraseContext()
}

type WriteFromPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWriteFromPhraseContext() *WriteFromPhraseContext {
	var p = new(WriteFromPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_writeFromPhrase
	return p
}

func (*WriteFromPhraseContext) IsWriteFromPhraseContext() {}

func NewWriteFromPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WriteFromPhraseContext {
	var p = new(WriteFromPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_writeFromPhrase

	return p
}

func (s *WriteFromPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *WriteFromPhraseContext) FROM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFROM, 0)
}

func (s *WriteFromPhraseContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *WriteFromPhraseContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *WriteFromPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WriteFromPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WriteFromPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterWriteFromPhrase(s)
	}
}

func (s *WriteFromPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitWriteFromPhrase(s)
	}
}

func (p *Cobol85Parser) WriteFromPhrase() (localctx IWriteFromPhraseContext) {
	localctx = NewWriteFromPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 998, Cobol85ParserRULE_writeFromPhrase)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5610)
		p.Match(Cobol85ParserFROM)
	}
	p.SetState(5613)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 875, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(5611)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(5612)
			p.Literal()
		}

	}

	return localctx
}

// IWriteAdvancingPhraseContext is an interface to support dynamic dispatch.
type IWriteAdvancingPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWriteAdvancingPhraseContext differentiates from other interfaces.
	IsWriteAdvancingPhraseContext()
}

type WriteAdvancingPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWriteAdvancingPhraseContext() *WriteAdvancingPhraseContext {
	var p = new(WriteAdvancingPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_writeAdvancingPhrase
	return p
}

func (*WriteAdvancingPhraseContext) IsWriteAdvancingPhraseContext() {}

func NewWriteAdvancingPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WriteAdvancingPhraseContext {
	var p = new(WriteAdvancingPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_writeAdvancingPhrase

	return p
}

func (s *WriteAdvancingPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *WriteAdvancingPhraseContext) BEFORE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBEFORE, 0)
}

func (s *WriteAdvancingPhraseContext) AFTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAFTER, 0)
}

func (s *WriteAdvancingPhraseContext) WriteAdvancingPage() IWriteAdvancingPageContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWriteAdvancingPageContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWriteAdvancingPageContext)
}

func (s *WriteAdvancingPhraseContext) WriteAdvancingLines() IWriteAdvancingLinesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWriteAdvancingLinesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWriteAdvancingLinesContext)
}

func (s *WriteAdvancingPhraseContext) WriteAdvancingMnemonic() IWriteAdvancingMnemonicContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWriteAdvancingMnemonicContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWriteAdvancingMnemonicContext)
}

func (s *WriteAdvancingPhraseContext) ADVANCING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserADVANCING, 0)
}

func (s *WriteAdvancingPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WriteAdvancingPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WriteAdvancingPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterWriteAdvancingPhrase(s)
	}
}

func (s *WriteAdvancingPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitWriteAdvancingPhrase(s)
	}
}

func (p *Cobol85Parser) WriteAdvancingPhrase() (localctx IWriteAdvancingPhraseContext) {
	localctx = NewWriteAdvancingPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1000, Cobol85ParserRULE_writeAdvancingPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5615)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserAFTER || _la == Cobol85ParserBEFORE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(5617)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserADVANCING {
		{
			p.SetState(5616)
			p.Match(Cobol85ParserADVANCING)
		}

	}
	p.SetState(5622)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 877, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(5619)
			p.WriteAdvancingPage()
		}

	case 2:
		{
			p.SetState(5620)
			p.WriteAdvancingLines()
		}

	case 3:
		{
			p.SetState(5621)
			p.WriteAdvancingMnemonic()
		}

	}

	return localctx
}

// IWriteAdvancingPageContext is an interface to support dynamic dispatch.
type IWriteAdvancingPageContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWriteAdvancingPageContext differentiates from other interfaces.
	IsWriteAdvancingPageContext()
}

type WriteAdvancingPageContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWriteAdvancingPageContext() *WriteAdvancingPageContext {
	var p = new(WriteAdvancingPageContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_writeAdvancingPage
	return p
}

func (*WriteAdvancingPageContext) IsWriteAdvancingPageContext() {}

func NewWriteAdvancingPageContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WriteAdvancingPageContext {
	var p = new(WriteAdvancingPageContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_writeAdvancingPage

	return p
}

func (s *WriteAdvancingPageContext) GetParser() antlr.Parser { return s.parser }

func (s *WriteAdvancingPageContext) PAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPAGE, 0)
}

func (s *WriteAdvancingPageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WriteAdvancingPageContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WriteAdvancingPageContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterWriteAdvancingPage(s)
	}
}

func (s *WriteAdvancingPageContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitWriteAdvancingPage(s)
	}
}

func (p *Cobol85Parser) WriteAdvancingPage() (localctx IWriteAdvancingPageContext) {
	localctx = NewWriteAdvancingPageContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1002, Cobol85ParserRULE_writeAdvancingPage)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5624)
		p.Match(Cobol85ParserPAGE)
	}

	return localctx
}

// IWriteAdvancingLinesContext is an interface to support dynamic dispatch.
type IWriteAdvancingLinesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWriteAdvancingLinesContext differentiates from other interfaces.
	IsWriteAdvancingLinesContext()
}

type WriteAdvancingLinesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWriteAdvancingLinesContext() *WriteAdvancingLinesContext {
	var p = new(WriteAdvancingLinesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_writeAdvancingLines
	return p
}

func (*WriteAdvancingLinesContext) IsWriteAdvancingLinesContext() {}

func NewWriteAdvancingLinesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WriteAdvancingLinesContext {
	var p = new(WriteAdvancingLinesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_writeAdvancingLines

	return p
}

func (s *WriteAdvancingLinesContext) GetParser() antlr.Parser { return s.parser }

func (s *WriteAdvancingLinesContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *WriteAdvancingLinesContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *WriteAdvancingLinesContext) LINE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLINE, 0)
}

func (s *WriteAdvancingLinesContext) LINES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLINES, 0)
}

func (s *WriteAdvancingLinesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WriteAdvancingLinesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WriteAdvancingLinesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterWriteAdvancingLines(s)
	}
}

func (s *WriteAdvancingLinesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitWriteAdvancingLines(s)
	}
}

func (p *Cobol85Parser) WriteAdvancingLines() (localctx IWriteAdvancingLinesContext) {
	localctx = NewWriteAdvancingLinesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1004, Cobol85ParserRULE_writeAdvancingLines)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5628)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 878, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(5626)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(5627)
			p.Literal()
		}

	}
	p.SetState(5631)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserLINE || _la == Cobol85ParserLINES {
		{
			p.SetState(5630)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85ParserLINE || _la == Cobol85ParserLINES) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

	return localctx
}

// IWriteAdvancingMnemonicContext is an interface to support dynamic dispatch.
type IWriteAdvancingMnemonicContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWriteAdvancingMnemonicContext differentiates from other interfaces.
	IsWriteAdvancingMnemonicContext()
}

type WriteAdvancingMnemonicContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWriteAdvancingMnemonicContext() *WriteAdvancingMnemonicContext {
	var p = new(WriteAdvancingMnemonicContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_writeAdvancingMnemonic
	return p
}

func (*WriteAdvancingMnemonicContext) IsWriteAdvancingMnemonicContext() {}

func NewWriteAdvancingMnemonicContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WriteAdvancingMnemonicContext {
	var p = new(WriteAdvancingMnemonicContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_writeAdvancingMnemonic

	return p
}

func (s *WriteAdvancingMnemonicContext) GetParser() antlr.Parser { return s.parser }

func (s *WriteAdvancingMnemonicContext) MnemonicName() IMnemonicNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMnemonicNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMnemonicNameContext)
}

func (s *WriteAdvancingMnemonicContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WriteAdvancingMnemonicContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WriteAdvancingMnemonicContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterWriteAdvancingMnemonic(s)
	}
}

func (s *WriteAdvancingMnemonicContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitWriteAdvancingMnemonic(s)
	}
}

func (p *Cobol85Parser) WriteAdvancingMnemonic() (localctx IWriteAdvancingMnemonicContext) {
	localctx = NewWriteAdvancingMnemonicContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1006, Cobol85ParserRULE_writeAdvancingMnemonic)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5633)
		p.MnemonicName()
	}

	return localctx
}

// IWriteAtEndOfPagePhraseContext is an interface to support dynamic dispatch.
type IWriteAtEndOfPagePhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWriteAtEndOfPagePhraseContext differentiates from other interfaces.
	IsWriteAtEndOfPagePhraseContext()
}

type WriteAtEndOfPagePhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWriteAtEndOfPagePhraseContext() *WriteAtEndOfPagePhraseContext {
	var p = new(WriteAtEndOfPagePhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_writeAtEndOfPagePhrase
	return p
}

func (*WriteAtEndOfPagePhraseContext) IsWriteAtEndOfPagePhraseContext() {}

func NewWriteAtEndOfPagePhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WriteAtEndOfPagePhraseContext {
	var p = new(WriteAtEndOfPagePhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_writeAtEndOfPagePhrase

	return p
}

func (s *WriteAtEndOfPagePhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *WriteAtEndOfPagePhraseContext) END_OF_PAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND_OF_PAGE, 0)
}

func (s *WriteAtEndOfPagePhraseContext) EOP() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEOP, 0)
}

func (s *WriteAtEndOfPagePhraseContext) AT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAT, 0)
}

func (s *WriteAtEndOfPagePhraseContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *WriteAtEndOfPagePhraseContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *WriteAtEndOfPagePhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WriteAtEndOfPagePhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WriteAtEndOfPagePhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterWriteAtEndOfPagePhrase(s)
	}
}

func (s *WriteAtEndOfPagePhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitWriteAtEndOfPagePhrase(s)
	}
}

func (p *Cobol85Parser) WriteAtEndOfPagePhrase() (localctx IWriteAtEndOfPagePhraseContext) {
	localctx = NewWriteAtEndOfPagePhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1008, Cobol85ParserRULE_writeAtEndOfPagePhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5636)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserAT {
		{
			p.SetState(5635)
			p.Match(Cobol85ParserAT)
		}

	}
	{
		p.SetState(5638)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserEND_OF_PAGE || _la == Cobol85ParserEOP) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(5642)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 881, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(5639)
				p.Statement()
			}

		}
		p.SetState(5644)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 881, p.GetParserRuleContext())
	}

	return localctx
}

// IWriteNotAtEndOfPagePhraseContext is an interface to support dynamic dispatch.
type IWriteNotAtEndOfPagePhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWriteNotAtEndOfPagePhraseContext differentiates from other interfaces.
	IsWriteNotAtEndOfPagePhraseContext()
}

type WriteNotAtEndOfPagePhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWriteNotAtEndOfPagePhraseContext() *WriteNotAtEndOfPagePhraseContext {
	var p = new(WriteNotAtEndOfPagePhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_writeNotAtEndOfPagePhrase
	return p
}

func (*WriteNotAtEndOfPagePhraseContext) IsWriteNotAtEndOfPagePhraseContext() {}

func NewWriteNotAtEndOfPagePhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WriteNotAtEndOfPagePhraseContext {
	var p = new(WriteNotAtEndOfPagePhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_writeNotAtEndOfPagePhrase

	return p
}

func (s *WriteNotAtEndOfPagePhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *WriteNotAtEndOfPagePhraseContext) NOT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNOT, 0)
}

func (s *WriteNotAtEndOfPagePhraseContext) END_OF_PAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND_OF_PAGE, 0)
}

func (s *WriteNotAtEndOfPagePhraseContext) EOP() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEOP, 0)
}

func (s *WriteNotAtEndOfPagePhraseContext) AT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAT, 0)
}

func (s *WriteNotAtEndOfPagePhraseContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *WriteNotAtEndOfPagePhraseContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *WriteNotAtEndOfPagePhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WriteNotAtEndOfPagePhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WriteNotAtEndOfPagePhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterWriteNotAtEndOfPagePhrase(s)
	}
}

func (s *WriteNotAtEndOfPagePhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitWriteNotAtEndOfPagePhrase(s)
	}
}

func (p *Cobol85Parser) WriteNotAtEndOfPagePhrase() (localctx IWriteNotAtEndOfPagePhraseContext) {
	localctx = NewWriteNotAtEndOfPagePhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1010, Cobol85ParserRULE_writeNotAtEndOfPagePhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5645)
		p.Match(Cobol85ParserNOT)
	}
	p.SetState(5647)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserAT {
		{
			p.SetState(5646)
			p.Match(Cobol85ParserAT)
		}

	}
	{
		p.SetState(5649)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserEND_OF_PAGE || _la == Cobol85ParserEOP) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(5653)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 883, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(5650)
				p.Statement()
			}

		}
		p.SetState(5655)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 883, p.GetParserRuleContext())
	}

	return localctx
}

// IAtEndPhraseContext is an interface to support dynamic dispatch.
type IAtEndPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtEndPhraseContext differentiates from other interfaces.
	IsAtEndPhraseContext()
}

type AtEndPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtEndPhraseContext() *AtEndPhraseContext {
	var p = new(AtEndPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_atEndPhrase
	return p
}

func (*AtEndPhraseContext) IsAtEndPhraseContext() {}

func NewAtEndPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtEndPhraseContext {
	var p = new(AtEndPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_atEndPhrase

	return p
}

func (s *AtEndPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *AtEndPhraseContext) END() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND, 0)
}

func (s *AtEndPhraseContext) AT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAT, 0)
}

func (s *AtEndPhraseContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *AtEndPhraseContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *AtEndPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtEndPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AtEndPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAtEndPhrase(s)
	}
}

func (s *AtEndPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAtEndPhrase(s)
	}
}

func (p *Cobol85Parser) AtEndPhrase() (localctx IAtEndPhraseContext) {
	localctx = NewAtEndPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1012, Cobol85ParserRULE_atEndPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5657)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserAT {
		{
			p.SetState(5656)
			p.Match(Cobol85ParserAT)
		}

	}
	{
		p.SetState(5659)
		p.Match(Cobol85ParserEND)
	}
	p.SetState(5663)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 885, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(5660)
				p.Statement()
			}

		}
		p.SetState(5665)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 885, p.GetParserRuleContext())
	}

	return localctx
}

// INotAtEndPhraseContext is an interface to support dynamic dispatch.
type INotAtEndPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNotAtEndPhraseContext differentiates from other interfaces.
	IsNotAtEndPhraseContext()
}

type NotAtEndPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNotAtEndPhraseContext() *NotAtEndPhraseContext {
	var p = new(NotAtEndPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_notAtEndPhrase
	return p
}

func (*NotAtEndPhraseContext) IsNotAtEndPhraseContext() {}

func NewNotAtEndPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NotAtEndPhraseContext {
	var p = new(NotAtEndPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_notAtEndPhrase

	return p
}

func (s *NotAtEndPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *NotAtEndPhraseContext) NOT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNOT, 0)
}

func (s *NotAtEndPhraseContext) END() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND, 0)
}

func (s *NotAtEndPhraseContext) AT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAT, 0)
}

func (s *NotAtEndPhraseContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *NotAtEndPhraseContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *NotAtEndPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NotAtEndPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NotAtEndPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterNotAtEndPhrase(s)
	}
}

func (s *NotAtEndPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitNotAtEndPhrase(s)
	}
}

func (p *Cobol85Parser) NotAtEndPhrase() (localctx INotAtEndPhraseContext) {
	localctx = NewNotAtEndPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1014, Cobol85ParserRULE_notAtEndPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5666)
		p.Match(Cobol85ParserNOT)
	}
	p.SetState(5668)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserAT {
		{
			p.SetState(5667)
			p.Match(Cobol85ParserAT)
		}

	}
	{
		p.SetState(5670)
		p.Match(Cobol85ParserEND)
	}
	p.SetState(5674)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 887, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(5671)
				p.Statement()
			}

		}
		p.SetState(5676)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 887, p.GetParserRuleContext())
	}

	return localctx
}

// IInvalidKeyPhraseContext is an interface to support dynamic dispatch.
type IInvalidKeyPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInvalidKeyPhraseContext differentiates from other interfaces.
	IsInvalidKeyPhraseContext()
}

type InvalidKeyPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInvalidKeyPhraseContext() *InvalidKeyPhraseContext {
	var p = new(InvalidKeyPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_invalidKeyPhrase
	return p
}

func (*InvalidKeyPhraseContext) IsInvalidKeyPhraseContext() {}

func NewInvalidKeyPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InvalidKeyPhraseContext {
	var p = new(InvalidKeyPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_invalidKeyPhrase

	return p
}

func (s *InvalidKeyPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *InvalidKeyPhraseContext) INVALID() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINVALID, 0)
}

func (s *InvalidKeyPhraseContext) KEY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserKEY, 0)
}

func (s *InvalidKeyPhraseContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *InvalidKeyPhraseContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *InvalidKeyPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InvalidKeyPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InvalidKeyPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInvalidKeyPhrase(s)
	}
}

func (s *InvalidKeyPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInvalidKeyPhrase(s)
	}
}

func (p *Cobol85Parser) InvalidKeyPhrase() (localctx IInvalidKeyPhraseContext) {
	localctx = NewInvalidKeyPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1016, Cobol85ParserRULE_invalidKeyPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5677)
		p.Match(Cobol85ParserINVALID)
	}
	p.SetState(5679)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserKEY {
		{
			p.SetState(5678)
			p.Match(Cobol85ParserKEY)
		}

	}
	p.SetState(5684)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 889, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(5681)
				p.Statement()
			}

		}
		p.SetState(5686)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 889, p.GetParserRuleContext())
	}

	return localctx
}

// INotInvalidKeyPhraseContext is an interface to support dynamic dispatch.
type INotInvalidKeyPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNotInvalidKeyPhraseContext differentiates from other interfaces.
	IsNotInvalidKeyPhraseContext()
}

type NotInvalidKeyPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNotInvalidKeyPhraseContext() *NotInvalidKeyPhraseContext {
	var p = new(NotInvalidKeyPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_notInvalidKeyPhrase
	return p
}

func (*NotInvalidKeyPhraseContext) IsNotInvalidKeyPhraseContext() {}

func NewNotInvalidKeyPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NotInvalidKeyPhraseContext {
	var p = new(NotInvalidKeyPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_notInvalidKeyPhrase

	return p
}

func (s *NotInvalidKeyPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *NotInvalidKeyPhraseContext) NOT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNOT, 0)
}

func (s *NotInvalidKeyPhraseContext) INVALID() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINVALID, 0)
}

func (s *NotInvalidKeyPhraseContext) KEY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserKEY, 0)
}

func (s *NotInvalidKeyPhraseContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *NotInvalidKeyPhraseContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *NotInvalidKeyPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NotInvalidKeyPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NotInvalidKeyPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterNotInvalidKeyPhrase(s)
	}
}

func (s *NotInvalidKeyPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitNotInvalidKeyPhrase(s)
	}
}

func (p *Cobol85Parser) NotInvalidKeyPhrase() (localctx INotInvalidKeyPhraseContext) {
	localctx = NewNotInvalidKeyPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1018, Cobol85ParserRULE_notInvalidKeyPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5687)
		p.Match(Cobol85ParserNOT)
	}
	{
		p.SetState(5688)
		p.Match(Cobol85ParserINVALID)
	}
	p.SetState(5690)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserKEY {
		{
			p.SetState(5689)
			p.Match(Cobol85ParserKEY)
		}

	}
	p.SetState(5695)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 891, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(5692)
				p.Statement()
			}

		}
		p.SetState(5697)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 891, p.GetParserRuleContext())
	}

	return localctx
}

// IOnOverflowPhraseContext is an interface to support dynamic dispatch.
type IOnOverflowPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOnOverflowPhraseContext differentiates from other interfaces.
	IsOnOverflowPhraseContext()
}

type OnOverflowPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOnOverflowPhraseContext() *OnOverflowPhraseContext {
	var p = new(OnOverflowPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_onOverflowPhrase
	return p
}

func (*OnOverflowPhraseContext) IsOnOverflowPhraseContext() {}

func NewOnOverflowPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OnOverflowPhraseContext {
	var p = new(OnOverflowPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_onOverflowPhrase

	return p
}

func (s *OnOverflowPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *OnOverflowPhraseContext) OVERFLOW() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOVERFLOW, 0)
}

func (s *OnOverflowPhraseContext) ON() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserON, 0)
}

func (s *OnOverflowPhraseContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *OnOverflowPhraseContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *OnOverflowPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OnOverflowPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OnOverflowPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterOnOverflowPhrase(s)
	}
}

func (s *OnOverflowPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitOnOverflowPhrase(s)
	}
}

func (p *Cobol85Parser) OnOverflowPhrase() (localctx IOnOverflowPhraseContext) {
	localctx = NewOnOverflowPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1020, Cobol85ParserRULE_onOverflowPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5699)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserON {
		{
			p.SetState(5698)
			p.Match(Cobol85ParserON)
		}

	}
	{
		p.SetState(5701)
		p.Match(Cobol85ParserOVERFLOW)
	}
	p.SetState(5705)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 893, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(5702)
				p.Statement()
			}

		}
		p.SetState(5707)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 893, p.GetParserRuleContext())
	}

	return localctx
}

// INotOnOverflowPhraseContext is an interface to support dynamic dispatch.
type INotOnOverflowPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNotOnOverflowPhraseContext differentiates from other interfaces.
	IsNotOnOverflowPhraseContext()
}

type NotOnOverflowPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNotOnOverflowPhraseContext() *NotOnOverflowPhraseContext {
	var p = new(NotOnOverflowPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_notOnOverflowPhrase
	return p
}

func (*NotOnOverflowPhraseContext) IsNotOnOverflowPhraseContext() {}

func NewNotOnOverflowPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NotOnOverflowPhraseContext {
	var p = new(NotOnOverflowPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_notOnOverflowPhrase

	return p
}

func (s *NotOnOverflowPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *NotOnOverflowPhraseContext) NOT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNOT, 0)
}

func (s *NotOnOverflowPhraseContext) OVERFLOW() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOVERFLOW, 0)
}

func (s *NotOnOverflowPhraseContext) ON() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserON, 0)
}

func (s *NotOnOverflowPhraseContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *NotOnOverflowPhraseContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *NotOnOverflowPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NotOnOverflowPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NotOnOverflowPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterNotOnOverflowPhrase(s)
	}
}

func (s *NotOnOverflowPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitNotOnOverflowPhrase(s)
	}
}

func (p *Cobol85Parser) NotOnOverflowPhrase() (localctx INotOnOverflowPhraseContext) {
	localctx = NewNotOnOverflowPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1022, Cobol85ParserRULE_notOnOverflowPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5708)
		p.Match(Cobol85ParserNOT)
	}
	p.SetState(5710)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserON {
		{
			p.SetState(5709)
			p.Match(Cobol85ParserON)
		}

	}
	{
		p.SetState(5712)
		p.Match(Cobol85ParserOVERFLOW)
	}
	p.SetState(5716)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 895, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(5713)
				p.Statement()
			}

		}
		p.SetState(5718)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 895, p.GetParserRuleContext())
	}

	return localctx
}

// IOnSizeErrorPhraseContext is an interface to support dynamic dispatch.
type IOnSizeErrorPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOnSizeErrorPhraseContext differentiates from other interfaces.
	IsOnSizeErrorPhraseContext()
}

type OnSizeErrorPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOnSizeErrorPhraseContext() *OnSizeErrorPhraseContext {
	var p = new(OnSizeErrorPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_onSizeErrorPhrase
	return p
}

func (*OnSizeErrorPhraseContext) IsOnSizeErrorPhraseContext() {}

func NewOnSizeErrorPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OnSizeErrorPhraseContext {
	var p = new(OnSizeErrorPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_onSizeErrorPhrase

	return p
}

func (s *OnSizeErrorPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *OnSizeErrorPhraseContext) SIZE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSIZE, 0)
}

func (s *OnSizeErrorPhraseContext) ERROR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserERROR, 0)
}

func (s *OnSizeErrorPhraseContext) ON() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserON, 0)
}

func (s *OnSizeErrorPhraseContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *OnSizeErrorPhraseContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *OnSizeErrorPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OnSizeErrorPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OnSizeErrorPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterOnSizeErrorPhrase(s)
	}
}

func (s *OnSizeErrorPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitOnSizeErrorPhrase(s)
	}
}

func (p *Cobol85Parser) OnSizeErrorPhrase() (localctx IOnSizeErrorPhraseContext) {
	localctx = NewOnSizeErrorPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1024, Cobol85ParserRULE_onSizeErrorPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5720)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserON {
		{
			p.SetState(5719)
			p.Match(Cobol85ParserON)
		}

	}
	{
		p.SetState(5722)
		p.Match(Cobol85ParserSIZE)
	}
	{
		p.SetState(5723)
		p.Match(Cobol85ParserERROR)
	}
	p.SetState(5727)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 897, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(5724)
				p.Statement()
			}

		}
		p.SetState(5729)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 897, p.GetParserRuleContext())
	}

	return localctx
}

// INotOnSizeErrorPhraseContext is an interface to support dynamic dispatch.
type INotOnSizeErrorPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNotOnSizeErrorPhraseContext differentiates from other interfaces.
	IsNotOnSizeErrorPhraseContext()
}

type NotOnSizeErrorPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNotOnSizeErrorPhraseContext() *NotOnSizeErrorPhraseContext {
	var p = new(NotOnSizeErrorPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_notOnSizeErrorPhrase
	return p
}

func (*NotOnSizeErrorPhraseContext) IsNotOnSizeErrorPhraseContext() {}

func NewNotOnSizeErrorPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NotOnSizeErrorPhraseContext {
	var p = new(NotOnSizeErrorPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_notOnSizeErrorPhrase

	return p
}

func (s *NotOnSizeErrorPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *NotOnSizeErrorPhraseContext) NOT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNOT, 0)
}

func (s *NotOnSizeErrorPhraseContext) SIZE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSIZE, 0)
}

func (s *NotOnSizeErrorPhraseContext) ERROR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserERROR, 0)
}

func (s *NotOnSizeErrorPhraseContext) ON() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserON, 0)
}

func (s *NotOnSizeErrorPhraseContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *NotOnSizeErrorPhraseContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *NotOnSizeErrorPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NotOnSizeErrorPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NotOnSizeErrorPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterNotOnSizeErrorPhrase(s)
	}
}

func (s *NotOnSizeErrorPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitNotOnSizeErrorPhrase(s)
	}
}

func (p *Cobol85Parser) NotOnSizeErrorPhrase() (localctx INotOnSizeErrorPhraseContext) {
	localctx = NewNotOnSizeErrorPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1026, Cobol85ParserRULE_notOnSizeErrorPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5730)
		p.Match(Cobol85ParserNOT)
	}
	p.SetState(5732)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserON {
		{
			p.SetState(5731)
			p.Match(Cobol85ParserON)
		}

	}
	{
		p.SetState(5734)
		p.Match(Cobol85ParserSIZE)
	}
	{
		p.SetState(5735)
		p.Match(Cobol85ParserERROR)
	}
	p.SetState(5739)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 899, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(5736)
				p.Statement()
			}

		}
		p.SetState(5741)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 899, p.GetParserRuleContext())
	}

	return localctx
}

// IOnExceptionClauseContext is an interface to support dynamic dispatch.
type IOnExceptionClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOnExceptionClauseContext differentiates from other interfaces.
	IsOnExceptionClauseContext()
}

type OnExceptionClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOnExceptionClauseContext() *OnExceptionClauseContext {
	var p = new(OnExceptionClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_onExceptionClause
	return p
}

func (*OnExceptionClauseContext) IsOnExceptionClauseContext() {}

func NewOnExceptionClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OnExceptionClauseContext {
	var p = new(OnExceptionClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_onExceptionClause

	return p
}

func (s *OnExceptionClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *OnExceptionClauseContext) EXCEPTION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEXCEPTION, 0)
}

func (s *OnExceptionClauseContext) ON() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserON, 0)
}

func (s *OnExceptionClauseContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *OnExceptionClauseContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *OnExceptionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OnExceptionClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OnExceptionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterOnExceptionClause(s)
	}
}

func (s *OnExceptionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitOnExceptionClause(s)
	}
}

func (p *Cobol85Parser) OnExceptionClause() (localctx IOnExceptionClauseContext) {
	localctx = NewOnExceptionClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1028, Cobol85ParserRULE_onExceptionClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5743)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserON {
		{
			p.SetState(5742)
			p.Match(Cobol85ParserON)
		}

	}
	{
		p.SetState(5745)
		p.Match(Cobol85ParserEXCEPTION)
	}
	p.SetState(5749)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 901, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(5746)
				p.Statement()
			}

		}
		p.SetState(5751)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 901, p.GetParserRuleContext())
	}

	return localctx
}

// INotOnExceptionClauseContext is an interface to support dynamic dispatch.
type INotOnExceptionClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNotOnExceptionClauseContext differentiates from other interfaces.
	IsNotOnExceptionClauseContext()
}

type NotOnExceptionClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNotOnExceptionClauseContext() *NotOnExceptionClauseContext {
	var p = new(NotOnExceptionClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_notOnExceptionClause
	return p
}

func (*NotOnExceptionClauseContext) IsNotOnExceptionClauseContext() {}

func NewNotOnExceptionClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NotOnExceptionClauseContext {
	var p = new(NotOnExceptionClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_notOnExceptionClause

	return p
}

func (s *NotOnExceptionClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *NotOnExceptionClauseContext) NOT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNOT, 0)
}

func (s *NotOnExceptionClauseContext) EXCEPTION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEXCEPTION, 0)
}

func (s *NotOnExceptionClauseContext) ON() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserON, 0)
}

func (s *NotOnExceptionClauseContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *NotOnExceptionClauseContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *NotOnExceptionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NotOnExceptionClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NotOnExceptionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterNotOnExceptionClause(s)
	}
}

func (s *NotOnExceptionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitNotOnExceptionClause(s)
	}
}

func (p *Cobol85Parser) NotOnExceptionClause() (localctx INotOnExceptionClauseContext) {
	localctx = NewNotOnExceptionClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1030, Cobol85ParserRULE_notOnExceptionClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5752)
		p.Match(Cobol85ParserNOT)
	}
	p.SetState(5754)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserON {
		{
			p.SetState(5753)
			p.Match(Cobol85ParserON)
		}

	}
	{
		p.SetState(5756)
		p.Match(Cobol85ParserEXCEPTION)
	}
	p.SetState(5760)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 903, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(5757)
				p.Statement()
			}

		}
		p.SetState(5762)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 903, p.GetParserRuleContext())
	}

	return localctx
}

// IArithmeticExpressionContext is an interface to support dynamic dispatch.
type IArithmeticExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArithmeticExpressionContext differentiates from other interfaces.
	IsArithmeticExpressionContext()
}

type ArithmeticExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArithmeticExpressionContext() *ArithmeticExpressionContext {
	var p = new(ArithmeticExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_arithmeticExpression
	return p
}

func (*ArithmeticExpressionContext) IsArithmeticExpressionContext() {}

func NewArithmeticExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArithmeticExpressionContext {
	var p = new(ArithmeticExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_arithmeticExpression

	return p
}

func (s *ArithmeticExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ArithmeticExpressionContext) MultDivs() IMultDivsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMultDivsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMultDivsContext)
}

func (s *ArithmeticExpressionContext) AllPlusMinus() []IPlusMinusContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPlusMinusContext)(nil)).Elem())
	var tst = make([]IPlusMinusContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPlusMinusContext)
		}
	}

	return tst
}

func (s *ArithmeticExpressionContext) PlusMinus(i int) IPlusMinusContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPlusMinusContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPlusMinusContext)
}

func (s *ArithmeticExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArithmeticExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArithmeticExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterArithmeticExpression(s)
	}
}

func (s *ArithmeticExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitArithmeticExpression(s)
	}
}

func (p *Cobol85Parser) ArithmeticExpression() (localctx IArithmeticExpressionContext) {
	localctx = NewArithmeticExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1032, Cobol85ParserRULE_arithmeticExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5763)
		p.MultDivs()
	}
	p.SetState(5767)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 904, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(5764)
				p.PlusMinus()
			}

		}
		p.SetState(5769)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 904, p.GetParserRuleContext())
	}

	return localctx
}

// IPlusMinusContext is an interface to support dynamic dispatch.
type IPlusMinusContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPlusMinusContext differentiates from other interfaces.
	IsPlusMinusContext()
}

type PlusMinusContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPlusMinusContext() *PlusMinusContext {
	var p = new(PlusMinusContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_plusMinus
	return p
}

func (*PlusMinusContext) IsPlusMinusContext() {}

func NewPlusMinusContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PlusMinusContext {
	var p = new(PlusMinusContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_plusMinus

	return p
}

func (s *PlusMinusContext) GetParser() antlr.Parser { return s.parser }

func (s *PlusMinusContext) MultDivs() IMultDivsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMultDivsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMultDivsContext)
}

func (s *PlusMinusContext) PLUSCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPLUSCHAR, 0)
}

func (s *PlusMinusContext) MINUSCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMINUSCHAR, 0)
}

func (s *PlusMinusContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PlusMinusContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PlusMinusContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterPlusMinus(s)
	}
}

func (s *PlusMinusContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitPlusMinus(s)
	}
}

func (p *Cobol85Parser) PlusMinus() (localctx IPlusMinusContext) {
	localctx = NewPlusMinusContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1034, Cobol85ParserRULE_plusMinus)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5770)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserMINUSCHAR || _la == Cobol85ParserPLUSCHAR) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(5771)
		p.MultDivs()
	}

	return localctx
}

// IMultDivsContext is an interface to support dynamic dispatch.
type IMultDivsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMultDivsContext differentiates from other interfaces.
	IsMultDivsContext()
}

type MultDivsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultDivsContext() *MultDivsContext {
	var p = new(MultDivsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_multDivs
	return p
}

func (*MultDivsContext) IsMultDivsContext() {}

func NewMultDivsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultDivsContext {
	var p = new(MultDivsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_multDivs

	return p
}

func (s *MultDivsContext) GetParser() antlr.Parser { return s.parser }

func (s *MultDivsContext) Powers() IPowersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPowersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPowersContext)
}

func (s *MultDivsContext) AllMultDiv() []IMultDivContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMultDivContext)(nil)).Elem())
	var tst = make([]IMultDivContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMultDivContext)
		}
	}

	return tst
}

func (s *MultDivsContext) MultDiv(i int) IMultDivContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMultDivContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMultDivContext)
}

func (s *MultDivsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultDivsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultDivsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMultDivs(s)
	}
}

func (s *MultDivsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMultDivs(s)
	}
}

func (p *Cobol85Parser) MultDivs() (localctx IMultDivsContext) {
	localctx = NewMultDivsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1036, Cobol85ParserRULE_multDivs)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5773)
		p.Powers()
	}
	p.SetState(5777)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserASTERISKCHAR || _la == Cobol85ParserSLASHCHAR {
		{
			p.SetState(5774)
			p.MultDiv()
		}

		p.SetState(5779)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IMultDivContext is an interface to support dynamic dispatch.
type IMultDivContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMultDivContext differentiates from other interfaces.
	IsMultDivContext()
}

type MultDivContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultDivContext() *MultDivContext {
	var p = new(MultDivContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_multDiv
	return p
}

func (*MultDivContext) IsMultDivContext() {}

func NewMultDivContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultDivContext {
	var p = new(MultDivContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_multDiv

	return p
}

func (s *MultDivContext) GetParser() antlr.Parser { return s.parser }

func (s *MultDivContext) Powers() IPowersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPowersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPowersContext)
}

func (s *MultDivContext) ASTERISKCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserASTERISKCHAR, 0)
}

func (s *MultDivContext) SLASHCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSLASHCHAR, 0)
}

func (s *MultDivContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultDivContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultDivContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMultDiv(s)
	}
}

func (s *MultDivContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMultDiv(s)
	}
}

func (p *Cobol85Parser) MultDiv() (localctx IMultDivContext) {
	localctx = NewMultDivContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1038, Cobol85ParserRULE_multDiv)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5780)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserASTERISKCHAR || _la == Cobol85ParserSLASHCHAR) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(5781)
		p.Powers()
	}

	return localctx
}

// IPowersContext is an interface to support dynamic dispatch.
type IPowersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPowersContext differentiates from other interfaces.
	IsPowersContext()
}

type PowersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPowersContext() *PowersContext {
	var p = new(PowersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_powers
	return p
}

func (*PowersContext) IsPowersContext() {}

func NewPowersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PowersContext {
	var p = new(PowersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_powers

	return p
}

func (s *PowersContext) GetParser() antlr.Parser { return s.parser }

func (s *PowersContext) Basis() IBasisContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBasisContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBasisContext)
}

func (s *PowersContext) AllPower() []IPowerContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPowerContext)(nil)).Elem())
	var tst = make([]IPowerContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPowerContext)
		}
	}

	return tst
}

func (s *PowersContext) Power(i int) IPowerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPowerContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPowerContext)
}

func (s *PowersContext) PLUSCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPLUSCHAR, 0)
}

func (s *PowersContext) MINUSCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMINUSCHAR, 0)
}

func (s *PowersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PowersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PowersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterPowers(s)
	}
}

func (s *PowersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitPowers(s)
	}
}

func (p *Cobol85Parser) Powers() (localctx IPowersContext) {
	localctx = NewPowersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1040, Cobol85ParserRULE_powers)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5784)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserMINUSCHAR || _la == Cobol85ParserPLUSCHAR {
		{
			p.SetState(5783)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85ParserMINUSCHAR || _la == Cobol85ParserPLUSCHAR) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(5786)
		p.Basis()
	}
	p.SetState(5790)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserDOUBLEASTERISKCHAR {
		{
			p.SetState(5787)
			p.Power()
		}

		p.SetState(5792)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IPowerContext is an interface to support dynamic dispatch.
type IPowerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPowerContext differentiates from other interfaces.
	IsPowerContext()
}

type PowerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPowerContext() *PowerContext {
	var p = new(PowerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_power
	return p
}

func (*PowerContext) IsPowerContext() {}

func NewPowerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PowerContext {
	var p = new(PowerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_power

	return p
}

func (s *PowerContext) GetParser() antlr.Parser { return s.parser }

func (s *PowerContext) DOUBLEASTERISKCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOUBLEASTERISKCHAR, 0)
}

func (s *PowerContext) Basis() IBasisContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBasisContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBasisContext)
}

func (s *PowerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PowerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PowerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterPower(s)
	}
}

func (s *PowerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitPower(s)
	}
}

func (p *Cobol85Parser) Power() (localctx IPowerContext) {
	localctx = NewPowerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1042, Cobol85ParserRULE_power)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5793)
		p.Match(Cobol85ParserDOUBLEASTERISKCHAR)
	}
	{
		p.SetState(5794)
		p.Basis()
	}

	return localctx
}

// IBasisContext is an interface to support dynamic dispatch.
type IBasisContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBasisContext differentiates from other interfaces.
	IsBasisContext()
}

type BasisContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBasisContext() *BasisContext {
	var p = new(BasisContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_basis
	return p
}

func (*BasisContext) IsBasisContext() {}

func NewBasisContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BasisContext {
	var p = new(BasisContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_basis

	return p
}

func (s *BasisContext) GetParser() antlr.Parser { return s.parser }

func (s *BasisContext) LPARENCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLPARENCHAR, 0)
}

func (s *BasisContext) ArithmeticExpression() IArithmeticExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArithmeticExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArithmeticExpressionContext)
}

func (s *BasisContext) RPARENCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRPARENCHAR, 0)
}

func (s *BasisContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *BasisContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *BasisContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BasisContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BasisContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterBasis(s)
	}
}

func (s *BasisContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitBasis(s)
	}
}

func (p *Cobol85Parser) Basis() (localctx IBasisContext) {
	localctx = NewBasisContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1044, Cobol85ParserRULE_basis)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5802)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 908, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5796)
			p.Match(Cobol85ParserLPARENCHAR)
		}
		{
			p.SetState(5797)
			p.ArithmeticExpression()
		}
		{
			p.SetState(5798)
			p.Match(Cobol85ParserRPARENCHAR)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5800)
			p.Identifier()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5801)
			p.Literal()
		}

	}

	return localctx
}

// IConditionContext is an interface to support dynamic dispatch.
type IConditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConditionContext differentiates from other interfaces.
	IsConditionContext()
}

type ConditionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditionContext() *ConditionContext {
	var p = new(ConditionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_condition
	return p
}

func (*ConditionContext) IsConditionContext() {}

func NewConditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConditionContext {
	var p = new(ConditionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_condition

	return p
}

func (s *ConditionContext) GetParser() antlr.Parser { return s.parser }

func (s *ConditionContext) CombinableCondition() ICombinableConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICombinableConditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICombinableConditionContext)
}

func (s *ConditionContext) AllAndOrCondition() []IAndOrConditionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAndOrConditionContext)(nil)).Elem())
	var tst = make([]IAndOrConditionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAndOrConditionContext)
		}
	}

	return tst
}

func (s *ConditionContext) AndOrCondition(i int) IAndOrConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAndOrConditionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAndOrConditionContext)
}

func (s *ConditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCondition(s)
	}
}

func (s *ConditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCondition(s)
	}
}

func (p *Cobol85Parser) Condition() (localctx IConditionContext) {
	localctx = NewConditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1046, Cobol85ParserRULE_condition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5804)
		p.CombinableCondition()
	}
	p.SetState(5808)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserAND || _la == Cobol85ParserOR {
		{
			p.SetState(5805)
			p.AndOrCondition()
		}

		p.SetState(5810)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IAndOrConditionContext is an interface to support dynamic dispatch.
type IAndOrConditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAndOrConditionContext differentiates from other interfaces.
	IsAndOrConditionContext()
}

type AndOrConditionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAndOrConditionContext() *AndOrConditionContext {
	var p = new(AndOrConditionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_andOrCondition
	return p
}

func (*AndOrConditionContext) IsAndOrConditionContext() {}

func NewAndOrConditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AndOrConditionContext {
	var p = new(AndOrConditionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_andOrCondition

	return p
}

func (s *AndOrConditionContext) GetParser() antlr.Parser { return s.parser }

func (s *AndOrConditionContext) AND() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAND, 0)
}

func (s *AndOrConditionContext) OR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOR, 0)
}

func (s *AndOrConditionContext) CombinableCondition() ICombinableConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICombinableConditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICombinableConditionContext)
}

func (s *AndOrConditionContext) AllAbbreviation() []IAbbreviationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAbbreviationContext)(nil)).Elem())
	var tst = make([]IAbbreviationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAbbreviationContext)
		}
	}

	return tst
}

func (s *AndOrConditionContext) Abbreviation(i int) IAbbreviationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAbbreviationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAbbreviationContext)
}

func (s *AndOrConditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AndOrConditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AndOrConditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAndOrCondition(s)
	}
}

func (s *AndOrConditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAndOrCondition(s)
	}
}

func (p *Cobol85Parser) AndOrCondition() (localctx IAndOrConditionContext) {
	localctx = NewAndOrConditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1048, Cobol85ParserRULE_andOrCondition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5811)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserAND || _la == Cobol85ParserOR) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(5818)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 911, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(5812)
			p.CombinableCondition()
		}

	case 2:
		p.SetState(5814)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(5813)
					p.Abbreviation()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(5816)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 910, p.GetParserRuleContext())
		}

	}

	return localctx
}

// ICombinableConditionContext is an interface to support dynamic dispatch.
type ICombinableConditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCombinableConditionContext differentiates from other interfaces.
	IsCombinableConditionContext()
}

type CombinableConditionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCombinableConditionContext() *CombinableConditionContext {
	var p = new(CombinableConditionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_combinableCondition
	return p
}

func (*CombinableConditionContext) IsCombinableConditionContext() {}

func NewCombinableConditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CombinableConditionContext {
	var p = new(CombinableConditionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_combinableCondition

	return p
}

func (s *CombinableConditionContext) GetParser() antlr.Parser { return s.parser }

func (s *CombinableConditionContext) SimpleCondition() ISimpleConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleConditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimpleConditionContext)
}

func (s *CombinableConditionContext) NOT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNOT, 0)
}

func (s *CombinableConditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CombinableConditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CombinableConditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCombinableCondition(s)
	}
}

func (s *CombinableConditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCombinableCondition(s)
	}
}

func (p *Cobol85Parser) CombinableCondition() (localctx ICombinableConditionContext) {
	localctx = NewCombinableConditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1050, Cobol85ParserRULE_combinableCondition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5821)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserNOT {
		{
			p.SetState(5820)
			p.Match(Cobol85ParserNOT)
		}

	}
	{
		p.SetState(5823)
		p.SimpleCondition()
	}

	return localctx
}

// ISimpleConditionContext is an interface to support dynamic dispatch.
type ISimpleConditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimpleConditionContext differentiates from other interfaces.
	IsSimpleConditionContext()
}

type SimpleConditionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleConditionContext() *SimpleConditionContext {
	var p = new(SimpleConditionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_simpleCondition
	return p
}

func (*SimpleConditionContext) IsSimpleConditionContext() {}

func NewSimpleConditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleConditionContext {
	var p = new(SimpleConditionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_simpleCondition

	return p
}

func (s *SimpleConditionContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleConditionContext) LPARENCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLPARENCHAR, 0)
}

func (s *SimpleConditionContext) Condition() IConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *SimpleConditionContext) RPARENCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRPARENCHAR, 0)
}

func (s *SimpleConditionContext) RelationCondition() IRelationConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelationConditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRelationConditionContext)
}

func (s *SimpleConditionContext) ClassCondition() IClassConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassConditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassConditionContext)
}

func (s *SimpleConditionContext) ConditionNameReference() IConditionNameReferenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionNameReferenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditionNameReferenceContext)
}

func (s *SimpleConditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleConditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleConditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSimpleCondition(s)
	}
}

func (s *SimpleConditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSimpleCondition(s)
	}
}

func (p *Cobol85Parser) SimpleCondition() (localctx ISimpleConditionContext) {
	localctx = NewSimpleConditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1052, Cobol85ParserRULE_simpleCondition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5832)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 913, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5825)
			p.Match(Cobol85ParserLPARENCHAR)
		}
		{
			p.SetState(5826)
			p.Condition()
		}
		{
			p.SetState(5827)
			p.Match(Cobol85ParserRPARENCHAR)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5829)
			p.RelationCondition()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5830)
			p.ClassCondition()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5831)
			p.ConditionNameReference()
		}

	}

	return localctx
}

// IClassConditionContext is an interface to support dynamic dispatch.
type IClassConditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassConditionContext differentiates from other interfaces.
	IsClassConditionContext()
}

type ClassConditionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassConditionContext() *ClassConditionContext {
	var p = new(ClassConditionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_classCondition
	return p
}

func (*ClassConditionContext) IsClassConditionContext() {}

func NewClassConditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassConditionContext {
	var p = new(ClassConditionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_classCondition

	return p
}

func (s *ClassConditionContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassConditionContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ClassConditionContext) NUMERIC() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNUMERIC, 0)
}

func (s *ClassConditionContext) ALPHABETIC() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALPHABETIC, 0)
}

func (s *ClassConditionContext) ALPHABETIC_LOWER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALPHABETIC_LOWER, 0)
}

func (s *ClassConditionContext) ALPHABETIC_UPPER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALPHABETIC_UPPER, 0)
}

func (s *ClassConditionContext) DBCS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDBCS, 0)
}

func (s *ClassConditionContext) KANJI() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserKANJI, 0)
}

func (s *ClassConditionContext) ClassName() IClassNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassNameContext)
}

func (s *ClassConditionContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ClassConditionContext) NOT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNOT, 0)
}

func (s *ClassConditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassConditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassConditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterClassCondition(s)
	}
}

func (s *ClassConditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitClassCondition(s)
	}
}

func (p *Cobol85Parser) ClassCondition() (localctx IClassConditionContext) {
	localctx = NewClassConditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1054, Cobol85ParserRULE_classCondition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5834)
		p.Identifier()
	}
	p.SetState(5836)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(5835)
			p.Match(Cobol85ParserIS)
		}

	}
	p.SetState(5839)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserNOT {
		{
			p.SetState(5838)
			p.Match(Cobol85ParserNOT)
		}

	}
	p.SetState(5848)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserNUMERIC:
		{
			p.SetState(5841)
			p.Match(Cobol85ParserNUMERIC)
		}

	case Cobol85ParserALPHABETIC:
		{
			p.SetState(5842)
			p.Match(Cobol85ParserALPHABETIC)
		}

	case Cobol85ParserALPHABETIC_LOWER:
		{
			p.SetState(5843)
			p.Match(Cobol85ParserALPHABETIC_LOWER)
		}

	case Cobol85ParserALPHABETIC_UPPER:
		{
			p.SetState(5844)
			p.Match(Cobol85ParserALPHABETIC_UPPER)
		}

	case Cobol85ParserDBCS:
		{
			p.SetState(5845)
			p.Match(Cobol85ParserDBCS)
		}

	case Cobol85ParserKANJI:
		{
			p.SetState(5846)
			p.Match(Cobol85ParserKANJI)
		}

	case Cobol85ParserABORT, Cobol85ParserAS, Cobol85ParserASCII, Cobol85ParserASSOCIATED_DATA, Cobol85ParserASSOCIATED_DATA_LENGTH, Cobol85ParserATTRIBUTE, Cobol85ParserAUTO, Cobol85ParserAUTO_SKIP, Cobol85ParserBACKGROUND_COLOR, Cobol85ParserBACKGROUND_COLOUR, Cobol85ParserBEEP, Cobol85ParserBELL, Cobol85ParserBINARY, Cobol85ParserBIT, Cobol85ParserBLINK, Cobol85ParserBOUNDS, Cobol85ParserCAPABLE, Cobol85ParserCCSVERSION, Cobol85ParserCHANGED, Cobol85ParserCHANNEL, Cobol85ParserCLOSE_DISPOSITION, Cobol85ParserCOBOL, Cobol85ParserCOMMITMENT, Cobol85ParserCONTROL_POINT, Cobol85ParserCONVENTION, Cobol85ParserCRUNCH, Cobol85ParserCURSOR, Cobol85ParserDEFAULT, Cobol85ParserDEFAULT_DISPLAY, Cobol85ParserDEFINITION, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserDISK, Cobol85ParserDONTCARE, Cobol85ParserDOUBLE, Cobol85ParserEBCDIC, Cobol85ParserEMPTY_CHECK, Cobol85ParserENTER, Cobol85ParserENTRY_PROCEDURE, Cobol85ParserERASE, Cobol85ParserEOL, Cobol85ParserEOS, Cobol85ParserESCAPE, Cobol85ParserEVENT, Cobol85ParserEXCLUSIVE, Cobol85ParserEXPORT, Cobol85ParserEXTENDED, Cobol85ParserFOREGROUND_COLOR, Cobol85ParserFOREGROUND_COLOUR, Cobol85ParserFULL, Cobol85ParserFUNCTIONNAME, Cobol85ParserFUNCTION_POINTER, Cobol85ParserGRID, Cobol85ParserHIGHLIGHT, Cobol85ParserIMPLICIT, Cobol85ParserIMPORT, Cobol85ParserINTEGER, Cobol85ParserKEPT, Cobol85ParserKEYBOARD, Cobol85ParserLANGUAGE, Cobol85ParserLB, Cobol85ParserLD, Cobol85ParserLEFTLINE, Cobol85ParserLENGTH_CHECK, Cobol85ParserLIBACCESS, Cobol85ParserLIBPARAMETER, Cobol85ParserLIBRARY, Cobol85ParserLIST, Cobol85ParserLOCAL, Cobol85ParserLONG_DATE, Cobol85ParserLONG_TIME, Cobol85ParserLOWER, Cobol85ParserLOWLIGHT, Cobol85ParserMMDDYYYY, Cobol85ParserNAMED, Cobol85ParserNATIONAL, Cobol85ParserNATIONAL_EDITED, Cobol85ParserNETWORK, Cobol85ParserNO_ECHO, Cobol85ParserNUMERIC_DATE, Cobol85ParserNUMERIC_TIME, Cobol85ParserODT, Cobol85ParserORDERLY, Cobol85ParserOVERLINE, Cobol85ParserOWN, Cobol85ParserPASSWORD, Cobol85ParserPORT, Cobol85ParserPRINTER, Cobol85ParserPRIVATE, Cobol85ParserPROCESS, Cobol85ParserPROGRAM, Cobol85ParserPROMPT, Cobol85ParserREADER, Cobol85ParserREMOTE, Cobol85ParserREAL, Cobol85ParserRECEIVED, Cobol85ParserRECURSIVE, Cobol85ParserREF, Cobol85ParserREMOVE, Cobol85ParserREQUIRED, Cobol85ParserREVERSE_VIDEO, Cobol85ParserSAVE, Cobol85ParserSECURE, Cobol85ParserSHARED, Cobol85ParserSHAREDBYALL, Cobol85ParserSHAREDBYRUNUNIT, Cobol85ParserSHARING, Cobol85ParserSHORT_DATE, Cobol85ParserSYMBOL, Cobol85ParserTASK, Cobol85ParserTHREAD, Cobol85ParserTHREAD_LOCAL, Cobol85ParserTIMER, Cobol85ParserTODAYS_DATE, Cobol85ParserTODAYS_NAME, Cobol85ParserTRUNCATED, Cobol85ParserTYPEDEF, Cobol85ParserUNDERLINE, Cobol85ParserVIRTUAL, Cobol85ParserWAIT, Cobol85ParserYEAR, Cobol85ParserYYYYMMDD, Cobol85ParserYYYYDDD, Cobol85ParserZERO_FILL, Cobol85ParserIDENTIFIER:
		{
			p.SetState(5847)
			p.ClassName()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IConditionNameReferenceContext is an interface to support dynamic dispatch.
type IConditionNameReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConditionNameReferenceContext differentiates from other interfaces.
	IsConditionNameReferenceContext()
}

type ConditionNameReferenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditionNameReferenceContext() *ConditionNameReferenceContext {
	var p = new(ConditionNameReferenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_conditionNameReference
	return p
}

func (*ConditionNameReferenceContext) IsConditionNameReferenceContext() {}

func NewConditionNameReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConditionNameReferenceContext {
	var p = new(ConditionNameReferenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_conditionNameReference

	return p
}

func (s *ConditionNameReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *ConditionNameReferenceContext) ConditionName() IConditionNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditionNameContext)
}

func (s *ConditionNameReferenceContext) AllInData() []IInDataContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInDataContext)(nil)).Elem())
	var tst = make([]IInDataContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInDataContext)
		}
	}

	return tst
}

func (s *ConditionNameReferenceContext) InData(i int) IInDataContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInDataContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInDataContext)
}

func (s *ConditionNameReferenceContext) InFile() IInFileContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInFileContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInFileContext)
}

func (s *ConditionNameReferenceContext) AllConditionNameSubscriptReference() []IConditionNameSubscriptReferenceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConditionNameSubscriptReferenceContext)(nil)).Elem())
	var tst = make([]IConditionNameSubscriptReferenceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConditionNameSubscriptReferenceContext)
		}
	}

	return tst
}

func (s *ConditionNameReferenceContext) ConditionNameSubscriptReference(i int) IConditionNameSubscriptReferenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionNameSubscriptReferenceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConditionNameSubscriptReferenceContext)
}

func (s *ConditionNameReferenceContext) AllInMnemonic() []IInMnemonicContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInMnemonicContext)(nil)).Elem())
	var tst = make([]IInMnemonicContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInMnemonicContext)
		}
	}

	return tst
}

func (s *ConditionNameReferenceContext) InMnemonic(i int) IInMnemonicContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInMnemonicContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInMnemonicContext)
}

func (s *ConditionNameReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConditionNameReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConditionNameReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterConditionNameReference(s)
	}
}

func (s *ConditionNameReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitConditionNameReference(s)
	}
}

func (p *Cobol85Parser) ConditionNameReference() (localctx IConditionNameReferenceContext) {
	localctx = NewConditionNameReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1056, Cobol85ParserRULE_conditionNameReference)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5850)
		p.ConditionName()
	}
	p.SetState(5872)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 921, p.GetParserRuleContext()) {
	case 1:
		p.SetState(5854)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 917, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(5851)
					p.InData()
				}

			}
			p.SetState(5856)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 917, p.GetParserRuleContext())
		}
		p.SetState(5858)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserIN || _la == Cobol85ParserOF {
			{
				p.SetState(5857)
				p.InFile()
			}

		}
		p.SetState(5863)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == Cobol85ParserLPARENCHAR {
			{
				p.SetState(5860)
				p.ConditionNameSubscriptReference()
			}

			p.SetState(5865)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		p.SetState(5869)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == Cobol85ParserIN || _la == Cobol85ParserOF {
			{
				p.SetState(5866)
				p.InMnemonic()
			}

			p.SetState(5871)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// IConditionNameSubscriptReferenceContext is an interface to support dynamic dispatch.
type IConditionNameSubscriptReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConditionNameSubscriptReferenceContext differentiates from other interfaces.
	IsConditionNameSubscriptReferenceContext()
}

type ConditionNameSubscriptReferenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditionNameSubscriptReferenceContext() *ConditionNameSubscriptReferenceContext {
	var p = new(ConditionNameSubscriptReferenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_conditionNameSubscriptReference
	return p
}

func (*ConditionNameSubscriptReferenceContext) IsConditionNameSubscriptReferenceContext() {}

func NewConditionNameSubscriptReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConditionNameSubscriptReferenceContext {
	var p = new(ConditionNameSubscriptReferenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_conditionNameSubscriptReference

	return p
}

func (s *ConditionNameSubscriptReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *ConditionNameSubscriptReferenceContext) LPARENCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLPARENCHAR, 0)
}

func (s *ConditionNameSubscriptReferenceContext) AllSubscript() []ISubscriptContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISubscriptContext)(nil)).Elem())
	var tst = make([]ISubscriptContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISubscriptContext)
		}
	}

	return tst
}

func (s *ConditionNameSubscriptReferenceContext) Subscript(i int) ISubscriptContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubscriptContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISubscriptContext)
}

func (s *ConditionNameSubscriptReferenceContext) RPARENCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRPARENCHAR, 0)
}

func (s *ConditionNameSubscriptReferenceContext) AllCOMMACHAR() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserCOMMACHAR)
}

func (s *ConditionNameSubscriptReferenceContext) COMMACHAR(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMMACHAR, i)
}

func (s *ConditionNameSubscriptReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConditionNameSubscriptReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConditionNameSubscriptReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterConditionNameSubscriptReference(s)
	}
}

func (s *ConditionNameSubscriptReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitConditionNameSubscriptReference(s)
	}
}

func (p *Cobol85Parser) ConditionNameSubscriptReference() (localctx IConditionNameSubscriptReferenceContext) {
	localctx = NewConditionNameSubscriptReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1058, Cobol85ParserRULE_conditionNameSubscriptReference)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5874)
		p.Match(Cobol85ParserLPARENCHAR)
	}
	{
		p.SetState(5875)
		p.Subscript()
	}
	p.SetState(5882)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserADDRESS)|(1<<Cobol85ParserALL)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH)|(1<<Cobol85ParserATTRIBUTE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBINARY-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-68))|(1<<(Cobol85ParserCOBOL-68))|(1<<(Cobol85ParserCOMMITMENT-68))|(1<<(Cobol85ParserCONTROL_POINT-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(Cobol85ParserCONVENTION-100))|(1<<(Cobol85ParserCRUNCH-100))|(1<<(Cobol85ParserCURSOR-100))|(1<<(Cobol85ParserDATE-100))|(1<<(Cobol85ParserDAY-100))|(1<<(Cobol85ParserDAY_OF_WEEK-100))|(1<<(Cobol85ParserDEBUG_CONTENTS-100))|(1<<(Cobol85ParserDEBUG_ITEM-100))|(1<<(Cobol85ParserDEBUG_LINE-100))|(1<<(Cobol85ParserDEBUG_NAME-100))|(1<<(Cobol85ParserDEBUG_SUB_1-100))|(1<<(Cobol85ParserDEBUG_SUB_2-100))|(1<<(Cobol85ParserDEBUG_SUB_3-100))|(1<<(Cobol85ParserDEFAULT-100))|(1<<(Cobol85ParserDEFAULT_DISPLAY-100))|(1<<(Cobol85ParserDEFINITION-100)))) != 0) || (((_la-138)&-(0x1f+1)) == 0 && ((1<<uint((_la-138)))&((1<<(Cobol85ParserDFHRESP-138))|(1<<(Cobol85ParserDFHVALUE-138))|(1<<(Cobol85ParserDISK-138))|(1<<(Cobol85ParserDONTCARE-138))|(1<<(Cobol85ParserDOUBLE-138))|(1<<(Cobol85ParserEBCDIC-138))|(1<<(Cobol85ParserEMPTY_CHECK-138)))) != 0) || (((_la-181)&-(0x1f+1)) == 0 && ((1<<uint((_la-181)))&((1<<(Cobol85ParserENTER-181))|(1<<(Cobol85ParserENTRY_PROCEDURE-181))|(1<<(Cobol85ParserERASE-181))|(1<<(Cobol85ParserEOL-181))|(1<<(Cobol85ParserEOS-181))|(1<<(Cobol85ParserESCAPE-181))|(1<<(Cobol85ParserEVENT-181))|(1<<(Cobol85ParserEXCLUSIVE-181))|(1<<(Cobol85ParserEXPORT-181))|(1<<(Cobol85ParserEXTENDED-181))|(1<<(Cobol85ParserFALSE-181)))) != 0) || (((_la-213)&-(0x1f+1)) == 0 && ((1<<uint((_la-213)))&((1<<(Cobol85ParserFOREGROUND_COLOR-213))|(1<<(Cobol85ParserFOREGROUND_COLOUR-213))|(1<<(Cobol85ParserFULL-213))|(1<<(Cobol85ParserFUNCTION-213))|(1<<(Cobol85ParserFUNCTIONNAME-213))|(1<<(Cobol85ParserFUNCTION_POINTER-213))|(1<<(Cobol85ParserGRID-213))|(1<<(Cobol85ParserHIGHLIGHT-213))|(1<<(Cobol85ParserHIGH_VALUE-213))|(1<<(Cobol85ParserHIGH_VALUES-213))|(1<<(Cobol85ParserIMPLICIT-213))|(1<<(Cobol85ParserIMPORT-213)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(Cobol85ParserINTEGER-250))|(1<<(Cobol85ParserKEPT-250))|(1<<(Cobol85ParserKEYBOARD-250))|(1<<(Cobol85ParserLANGUAGE-250))|(1<<(Cobol85ParserLB-250))|(1<<(Cobol85ParserLD-250))|(1<<(Cobol85ParserLEFTLINE-250))|(1<<(Cobol85ParserLENGTH-250))|(1<<(Cobol85ParserLENGTH_CHECK-250))|(1<<(Cobol85ParserLIBACCESS-250))|(1<<(Cobol85ParserLIBPARAMETER-250))|(1<<(Cobol85ParserLIBRARY-250))|(1<<(Cobol85ParserLINAGE_COUNTER-250))|(1<<(Cobol85ParserLINE_COUNTER-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(Cobol85ParserLIST-283))|(1<<(Cobol85ParserLOCAL-283))|(1<<(Cobol85ParserLONG_DATE-283))|(1<<(Cobol85ParserLONG_TIME-283))|(1<<(Cobol85ParserLOWER-283))|(1<<(Cobol85ParserLOWLIGHT-283))|(1<<(Cobol85ParserLOW_VALUE-283))|(1<<(Cobol85ParserLOW_VALUES-283))|(1<<(Cobol85ParserMMDDYYYY-283))|(1<<(Cobol85ParserNAMED-283))|(1<<(Cobol85ParserNATIONAL-283))|(1<<(Cobol85ParserNATIONAL_EDITED-283))|(1<<(Cobol85ParserNETWORK-283))|(1<<(Cobol85ParserNO_ECHO-283))|(1<<(Cobol85ParserNULL-283))|(1<<(Cobol85ParserNULLS-283)))) != 0) || (((_la-317)&-(0x1f+1)) == 0 && ((1<<uint((_la-317)))&((1<<(Cobol85ParserNUMERIC_DATE-317))|(1<<(Cobol85ParserNUMERIC_TIME-317))|(1<<(Cobol85ParserODT-317))|(1<<(Cobol85ParserORDERLY-317))|(1<<(Cobol85ParserOVERLINE-317))|(1<<(Cobol85ParserOWN-317))|(1<<(Cobol85ParserPAGE_COUNTER-317))|(1<<(Cobol85ParserPASSWORD-317)))) != 0) || (((_la-352)&-(0x1f+1)) == 0 && ((1<<uint((_la-352)))&((1<<(Cobol85ParserPORT-352))|(1<<(Cobol85ParserPRINTER-352))|(1<<(Cobol85ParserPRIVATE-352))|(1<<(Cobol85ParserPROCESS-352))|(1<<(Cobol85ParserPROGRAM-352))|(1<<(Cobol85ParserPROMPT-352))|(1<<(Cobol85ParserQUOTE-352))|(1<<(Cobol85ParserQUOTES-352))|(1<<(Cobol85ParserREADER-352))|(1<<(Cobol85ParserREMOTE-352))|(1<<(Cobol85ParserREAL-352))|(1<<(Cobol85ParserRECEIVED-352))|(1<<(Cobol85ParserRECURSIVE-352))|(1<<(Cobol85ParserREF-352)))) != 0) || (((_la-391)&-(0x1f+1)) == 0 && ((1<<uint((_la-391)))&((1<<(Cobol85ParserREMOVE-391))|(1<<(Cobol85ParserREQUIRED-391))|(1<<(Cobol85ParserREVERSE_VIDEO-391))|(1<<(Cobol85ParserRETURN_CODE-391))|(1<<(Cobol85ParserSAVE-391))|(1<<(Cobol85ParserSECURE-391)))) != 0) || (((_la-431)&-(0x1f+1)) == 0 && ((1<<uint((_la-431)))&((1<<(Cobol85ParserSHARED-431))|(1<<(Cobol85ParserSHAREDBYALL-431))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-431))|(1<<(Cobol85ParserSHARING-431))|(1<<(Cobol85ParserSHIFT_IN-431))|(1<<(Cobol85ParserSHIFT_OUT-431))|(1<<(Cobol85ParserSHORT_DATE-431))|(1<<(Cobol85ParserSORT_CONTROL-431))|(1<<(Cobol85ParserSORT_CORE_SIZE-431))|(1<<(Cobol85ParserSORT_FILE_SIZE-431))|(1<<(Cobol85ParserSORT_MESSAGE-431))|(1<<(Cobol85ParserSORT_MODE_SIZE-431))|(1<<(Cobol85ParserSORT_RETURN-431))|(1<<(Cobol85ParserSPACE-431))|(1<<(Cobol85ParserSPACES-431)))) != 0) || (((_la-466)&-(0x1f+1)) == 0 && ((1<<uint((_la-466)))&((1<<(Cobol85ParserSYMBOL-466))|(1<<(Cobol85ParserTALLY-466))|(1<<(Cobol85ParserTASK-466))|(1<<(Cobol85ParserTHREAD-466))|(1<<(Cobol85ParserTHREAD_LOCAL-466))|(1<<(Cobol85ParserTIME-466))|(1<<(Cobol85ParserTIMER-466))|(1<<(Cobol85ParserTODAYS_DATE-466))|(1<<(Cobol85ParserTODAYS_NAME-466))|(1<<(Cobol85ParserTRUE-466))|(1<<(Cobol85ParserTRUNCATED-466))|(1<<(Cobol85ParserTYPEDEF-466)))) != 0) || (((_la-498)&-(0x1f+1)) == 0 && ((1<<uint((_la-498)))&((1<<(Cobol85ParserUNDERLINE-498))|(1<<(Cobol85ParserVIRTUAL-498))|(1<<(Cobol85ParserWAIT-498))|(1<<(Cobol85ParserWHEN_COMPILED-498))|(1<<(Cobol85ParserYEAR-498))|(1<<(Cobol85ParserYYYYMMDD-498))|(1<<(Cobol85ParserYYYYDDD-498))|(1<<(Cobol85ParserZERO-498))|(1<<(Cobol85ParserZERO_FILL-498))|(1<<(Cobol85ParserZEROS-498))|(1<<(Cobol85ParserZEROES-498))|(1<<(Cobol85ParserCOMMACHAR-498)))) != 0) || (((_la-542)&-(0x1f+1)) == 0 && ((1<<uint((_la-542)))&((1<<(Cobol85ParserLPARENCHAR-542))|(1<<(Cobol85ParserMINUSCHAR-542))|(1<<(Cobol85ParserPLUSCHAR-542))|(1<<(Cobol85ParserNONNUMERICLITERAL-542))|(1<<(Cobol85ParserLEVEL_NUMBER_66-542))|(1<<(Cobol85ParserLEVEL_NUMBER_77-542))|(1<<(Cobol85ParserLEVEL_NUMBER_88-542))|(1<<(Cobol85ParserINTEGERLITERAL-542))|(1<<(Cobol85ParserNUMERICLITERAL-542))|(1<<(Cobol85ParserIDENTIFIER-542)))) != 0) {
		p.SetState(5877)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserCOMMACHAR {
			{
				p.SetState(5876)
				p.Match(Cobol85ParserCOMMACHAR)
			}

		}
		{
			p.SetState(5879)
			p.Subscript()
		}

		p.SetState(5884)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(5885)
		p.Match(Cobol85ParserRPARENCHAR)
	}

	return localctx
}

// IRelationConditionContext is an interface to support dynamic dispatch.
type IRelationConditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelationConditionContext differentiates from other interfaces.
	IsRelationConditionContext()
}

type RelationConditionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationConditionContext() *RelationConditionContext {
	var p = new(RelationConditionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_relationCondition
	return p
}

func (*RelationConditionContext) IsRelationConditionContext() {}

func NewRelationConditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationConditionContext {
	var p = new(RelationConditionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_relationCondition

	return p
}

func (s *RelationConditionContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationConditionContext) RelationSignCondition() IRelationSignConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelationSignConditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRelationSignConditionContext)
}

func (s *RelationConditionContext) RelationArithmeticComparison() IRelationArithmeticComparisonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelationArithmeticComparisonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRelationArithmeticComparisonContext)
}

func (s *RelationConditionContext) RelationCombinedComparison() IRelationCombinedComparisonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelationCombinedComparisonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRelationCombinedComparisonContext)
}

func (s *RelationConditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationConditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationConditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterRelationCondition(s)
	}
}

func (s *RelationConditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitRelationCondition(s)
	}
}

func (p *Cobol85Parser) RelationCondition() (localctx IRelationConditionContext) {
	localctx = NewRelationConditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1060, Cobol85ParserRULE_relationCondition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5890)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 924, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5887)
			p.RelationSignCondition()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5888)
			p.RelationArithmeticComparison()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5889)
			p.RelationCombinedComparison()
		}

	}

	return localctx
}

// IRelationSignConditionContext is an interface to support dynamic dispatch.
type IRelationSignConditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelationSignConditionContext differentiates from other interfaces.
	IsRelationSignConditionContext()
}

type RelationSignConditionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationSignConditionContext() *RelationSignConditionContext {
	var p = new(RelationSignConditionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_relationSignCondition
	return p
}

func (*RelationSignConditionContext) IsRelationSignConditionContext() {}

func NewRelationSignConditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationSignConditionContext {
	var p = new(RelationSignConditionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_relationSignCondition

	return p
}

func (s *RelationSignConditionContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationSignConditionContext) ArithmeticExpression() IArithmeticExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArithmeticExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArithmeticExpressionContext)
}

func (s *RelationSignConditionContext) POSITIVE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPOSITIVE, 0)
}

func (s *RelationSignConditionContext) NEGATIVE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNEGATIVE, 0)
}

func (s *RelationSignConditionContext) ZERO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserZERO, 0)
}

func (s *RelationSignConditionContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *RelationSignConditionContext) NOT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNOT, 0)
}

func (s *RelationSignConditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationSignConditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationSignConditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterRelationSignCondition(s)
	}
}

func (s *RelationSignConditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitRelationSignCondition(s)
	}
}

func (p *Cobol85Parser) RelationSignCondition() (localctx IRelationSignConditionContext) {
	localctx = NewRelationSignConditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1062, Cobol85ParserRULE_relationSignCondition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5892)
		p.ArithmeticExpression()
	}
	p.SetState(5894)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(5893)
			p.Match(Cobol85ParserIS)
		}

	}
	p.SetState(5897)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserNOT {
		{
			p.SetState(5896)
			p.Match(Cobol85ParserNOT)
		}

	}
	{
		p.SetState(5899)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserNEGATIVE || _la == Cobol85ParserPOSITIVE || _la == Cobol85ParserZERO) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IRelationArithmeticComparisonContext is an interface to support dynamic dispatch.
type IRelationArithmeticComparisonContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelationArithmeticComparisonContext differentiates from other interfaces.
	IsRelationArithmeticComparisonContext()
}

type RelationArithmeticComparisonContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationArithmeticComparisonContext() *RelationArithmeticComparisonContext {
	var p = new(RelationArithmeticComparisonContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_relationArithmeticComparison
	return p
}

func (*RelationArithmeticComparisonContext) IsRelationArithmeticComparisonContext() {}

func NewRelationArithmeticComparisonContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationArithmeticComparisonContext {
	var p = new(RelationArithmeticComparisonContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_relationArithmeticComparison

	return p
}

func (s *RelationArithmeticComparisonContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationArithmeticComparisonContext) AllArithmeticExpression() []IArithmeticExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IArithmeticExpressionContext)(nil)).Elem())
	var tst = make([]IArithmeticExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IArithmeticExpressionContext)
		}
	}

	return tst
}

func (s *RelationArithmeticComparisonContext) ArithmeticExpression(i int) IArithmeticExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArithmeticExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IArithmeticExpressionContext)
}

func (s *RelationArithmeticComparisonContext) RelationalOperator() IRelationalOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelationalOperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRelationalOperatorContext)
}

func (s *RelationArithmeticComparisonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationArithmeticComparisonContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationArithmeticComparisonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterRelationArithmeticComparison(s)
	}
}

func (s *RelationArithmeticComparisonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitRelationArithmeticComparison(s)
	}
}

func (p *Cobol85Parser) RelationArithmeticComparison() (localctx IRelationArithmeticComparisonContext) {
	localctx = NewRelationArithmeticComparisonContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1064, Cobol85ParserRULE_relationArithmeticComparison)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5901)
		p.ArithmeticExpression()
	}
	{
		p.SetState(5902)
		p.RelationalOperator()
	}
	{
		p.SetState(5903)
		p.ArithmeticExpression()
	}

	return localctx
}

// IRelationCombinedComparisonContext is an interface to support dynamic dispatch.
type IRelationCombinedComparisonContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelationCombinedComparisonContext differentiates from other interfaces.
	IsRelationCombinedComparisonContext()
}

type RelationCombinedComparisonContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationCombinedComparisonContext() *RelationCombinedComparisonContext {
	var p = new(RelationCombinedComparisonContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_relationCombinedComparison
	return p
}

func (*RelationCombinedComparisonContext) IsRelationCombinedComparisonContext() {}

func NewRelationCombinedComparisonContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationCombinedComparisonContext {
	var p = new(RelationCombinedComparisonContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_relationCombinedComparison

	return p
}

func (s *RelationCombinedComparisonContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationCombinedComparisonContext) ArithmeticExpression() IArithmeticExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArithmeticExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArithmeticExpressionContext)
}

func (s *RelationCombinedComparisonContext) RelationalOperator() IRelationalOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelationalOperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRelationalOperatorContext)
}

func (s *RelationCombinedComparisonContext) LPARENCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLPARENCHAR, 0)
}

func (s *RelationCombinedComparisonContext) RelationCombinedCondition() IRelationCombinedConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelationCombinedConditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRelationCombinedConditionContext)
}

func (s *RelationCombinedComparisonContext) RPARENCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRPARENCHAR, 0)
}

func (s *RelationCombinedComparisonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationCombinedComparisonContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationCombinedComparisonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterRelationCombinedComparison(s)
	}
}

func (s *RelationCombinedComparisonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitRelationCombinedComparison(s)
	}
}

func (p *Cobol85Parser) RelationCombinedComparison() (localctx IRelationCombinedComparisonContext) {
	localctx = NewRelationCombinedComparisonContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1066, Cobol85ParserRULE_relationCombinedComparison)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5905)
		p.ArithmeticExpression()
	}
	{
		p.SetState(5906)
		p.RelationalOperator()
	}
	{
		p.SetState(5907)
		p.Match(Cobol85ParserLPARENCHAR)
	}
	{
		p.SetState(5908)
		p.RelationCombinedCondition()
	}
	{
		p.SetState(5909)
		p.Match(Cobol85ParserRPARENCHAR)
	}

	return localctx
}

// IRelationCombinedConditionContext is an interface to support dynamic dispatch.
type IRelationCombinedConditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelationCombinedConditionContext differentiates from other interfaces.
	IsRelationCombinedConditionContext()
}

type RelationCombinedConditionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationCombinedConditionContext() *RelationCombinedConditionContext {
	var p = new(RelationCombinedConditionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_relationCombinedCondition
	return p
}

func (*RelationCombinedConditionContext) IsRelationCombinedConditionContext() {}

func NewRelationCombinedConditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationCombinedConditionContext {
	var p = new(RelationCombinedConditionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_relationCombinedCondition

	return p
}

func (s *RelationCombinedConditionContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationCombinedConditionContext) AllArithmeticExpression() []IArithmeticExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IArithmeticExpressionContext)(nil)).Elem())
	var tst = make([]IArithmeticExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IArithmeticExpressionContext)
		}
	}

	return tst
}

func (s *RelationCombinedConditionContext) ArithmeticExpression(i int) IArithmeticExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArithmeticExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IArithmeticExpressionContext)
}

func (s *RelationCombinedConditionContext) AllAND() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserAND)
}

func (s *RelationCombinedConditionContext) AND(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAND, i)
}

func (s *RelationCombinedConditionContext) AllOR() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserOR)
}

func (s *RelationCombinedConditionContext) OR(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOR, i)
}

func (s *RelationCombinedConditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationCombinedConditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationCombinedConditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterRelationCombinedCondition(s)
	}
}

func (s *RelationCombinedConditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitRelationCombinedCondition(s)
	}
}

func (p *Cobol85Parser) RelationCombinedCondition() (localctx IRelationCombinedConditionContext) {
	localctx = NewRelationCombinedConditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1068, Cobol85ParserRULE_relationCombinedCondition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5911)
		p.ArithmeticExpression()
	}
	p.SetState(5914)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == Cobol85ParserAND || _la == Cobol85ParserOR {
		{
			p.SetState(5912)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85ParserAND || _la == Cobol85ParserOR) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5913)
			p.ArithmeticExpression()
		}

		p.SetState(5916)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IRelationalOperatorContext is an interface to support dynamic dispatch.
type IRelationalOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelationalOperatorContext differentiates from other interfaces.
	IsRelationalOperatorContext()
}

type RelationalOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationalOperatorContext() *RelationalOperatorContext {
	var p = new(RelationalOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_relationalOperator
	return p
}

func (*RelationalOperatorContext) IsRelationalOperatorContext() {}

func NewRelationalOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationalOperatorContext {
	var p = new(RelationalOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_relationalOperator

	return p
}

func (s *RelationalOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationalOperatorContext) NOTEQUALCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNOTEQUALCHAR, 0)
}

func (s *RelationalOperatorContext) GREATER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserGREATER, 0)
}

func (s *RelationalOperatorContext) OR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOR, 0)
}

func (s *RelationalOperatorContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEQUAL, 0)
}

func (s *RelationalOperatorContext) MORETHANOREQUAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMORETHANOREQUAL, 0)
}

func (s *RelationalOperatorContext) LESS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLESS, 0)
}

func (s *RelationalOperatorContext) LESSTHANOREQUAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLESSTHANOREQUAL, 0)
}

func (s *RelationalOperatorContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *RelationalOperatorContext) ARE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserARE, 0)
}

func (s *RelationalOperatorContext) MORETHANCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMORETHANCHAR, 0)
}

func (s *RelationalOperatorContext) LESSTHANCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLESSTHANCHAR, 0)
}

func (s *RelationalOperatorContext) EQUALCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEQUALCHAR, 0)
}

func (s *RelationalOperatorContext) NOT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNOT, 0)
}

func (s *RelationalOperatorContext) THAN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHAN, 0)
}

func (s *RelationalOperatorContext) TO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTO, 0)
}

func (s *RelationalOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationalOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationalOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterRelationalOperator(s)
	}
}

func (s *RelationalOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitRelationalOperator(s)
	}
}

func (p *Cobol85Parser) RelationalOperator() (localctx IRelationalOperatorContext) {
	localctx = NewRelationalOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1070, Cobol85ParserRULE_relationalOperator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5919)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserARE || _la == Cobol85ParserIS {
		{
			p.SetState(5918)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85ParserARE || _la == Cobol85ParserIS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(5962)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 938, p.GetParserRuleContext()) {
	case 1:
		p.SetState(5922)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserNOT {
			{
				p.SetState(5921)
				p.Match(Cobol85ParserNOT)
			}

		}
		p.SetState(5939)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case Cobol85ParserGREATER:
			{
				p.SetState(5924)
				p.Match(Cobol85ParserGREATER)
			}
			p.SetState(5926)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == Cobol85ParserTHAN {
				{
					p.SetState(5925)
					p.Match(Cobol85ParserTHAN)
				}

			}

		case Cobol85ParserMORETHANCHAR:
			{
				p.SetState(5928)
				p.Match(Cobol85ParserMORETHANCHAR)
			}

		case Cobol85ParserLESS:
			{
				p.SetState(5929)
				p.Match(Cobol85ParserLESS)
			}
			p.SetState(5931)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == Cobol85ParserTHAN {
				{
					p.SetState(5930)
					p.Match(Cobol85ParserTHAN)
				}

			}

		case Cobol85ParserLESSTHANCHAR:
			{
				p.SetState(5933)
				p.Match(Cobol85ParserLESSTHANCHAR)
			}

		case Cobol85ParserEQUAL:
			{
				p.SetState(5934)
				p.Match(Cobol85ParserEQUAL)
			}
			p.SetState(5936)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == Cobol85ParserTO {
				{
					p.SetState(5935)
					p.Match(Cobol85ParserTO)
				}

			}

		case Cobol85ParserEQUALCHAR:
			{
				p.SetState(5938)
				p.Match(Cobol85ParserEQUALCHAR)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case 2:
		{
			p.SetState(5941)
			p.Match(Cobol85ParserNOTEQUALCHAR)
		}

	case 3:
		{
			p.SetState(5942)
			p.Match(Cobol85ParserGREATER)
		}
		p.SetState(5944)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserTHAN {
			{
				p.SetState(5943)
				p.Match(Cobol85ParserTHAN)
			}

		}
		{
			p.SetState(5946)
			p.Match(Cobol85ParserOR)
		}
		{
			p.SetState(5947)
			p.Match(Cobol85ParserEQUAL)
		}
		p.SetState(5949)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserTO {
			{
				p.SetState(5948)
				p.Match(Cobol85ParserTO)
			}

		}

	case 4:
		{
			p.SetState(5951)
			p.Match(Cobol85ParserMORETHANOREQUAL)
		}

	case 5:
		{
			p.SetState(5952)
			p.Match(Cobol85ParserLESS)
		}
		p.SetState(5954)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserTHAN {
			{
				p.SetState(5953)
				p.Match(Cobol85ParserTHAN)
			}

		}
		{
			p.SetState(5956)
			p.Match(Cobol85ParserOR)
		}
		{
			p.SetState(5957)
			p.Match(Cobol85ParserEQUAL)
		}
		p.SetState(5959)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserTO {
			{
				p.SetState(5958)
				p.Match(Cobol85ParserTO)
			}

		}

	case 6:
		{
			p.SetState(5961)
			p.Match(Cobol85ParserLESSTHANOREQUAL)
		}

	}

	return localctx
}

// IAbbreviationContext is an interface to support dynamic dispatch.
type IAbbreviationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAbbreviationContext differentiates from other interfaces.
	IsAbbreviationContext()
}

type AbbreviationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAbbreviationContext() *AbbreviationContext {
	var p = new(AbbreviationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_abbreviation
	return p
}

func (*AbbreviationContext) IsAbbreviationContext() {}

func NewAbbreviationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AbbreviationContext {
	var p = new(AbbreviationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_abbreviation

	return p
}

func (s *AbbreviationContext) GetParser() antlr.Parser { return s.parser }

func (s *AbbreviationContext) ArithmeticExpression() IArithmeticExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArithmeticExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArithmeticExpressionContext)
}

func (s *AbbreviationContext) LPARENCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLPARENCHAR, 0)
}

func (s *AbbreviationContext) Abbreviation() IAbbreviationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAbbreviationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAbbreviationContext)
}

func (s *AbbreviationContext) RPARENCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRPARENCHAR, 0)
}

func (s *AbbreviationContext) NOT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNOT, 0)
}

func (s *AbbreviationContext) RelationalOperator() IRelationalOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelationalOperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRelationalOperatorContext)
}

func (s *AbbreviationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AbbreviationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AbbreviationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAbbreviation(s)
	}
}

func (s *AbbreviationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAbbreviation(s)
	}
}

func (p *Cobol85Parser) Abbreviation() (localctx IAbbreviationContext) {
	localctx = NewAbbreviationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1072, Cobol85ParserRULE_abbreviation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5965)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 939, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5964)
			p.Match(Cobol85ParserNOT)
		}

	}
	p.SetState(5968)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserARE || _la == Cobol85ParserEQUAL || _la == Cobol85ParserGREATER || _la == Cobol85ParserIS || _la == Cobol85ParserLESS || _la == Cobol85ParserNOT || (((_la-536)&-(0x1f+1)) == 0 && ((1<<uint((_la-536)))&((1<<(Cobol85ParserEQUALCHAR-536))|(1<<(Cobol85ParserLESSTHANCHAR-536))|(1<<(Cobol85ParserLESSTHANOREQUAL-536))|(1<<(Cobol85ParserMORETHANCHAR-536))|(1<<(Cobol85ParserMORETHANOREQUAL-536))|(1<<(Cobol85ParserNOTEQUALCHAR-536)))) != 0) {
		{
			p.SetState(5967)
			p.RelationalOperator()
		}

	}
	p.SetState(5976)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 941, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(5970)
			p.ArithmeticExpression()
		}

	case 2:
		{
			p.SetState(5971)
			p.Match(Cobol85ParserLPARENCHAR)
		}
		{
			p.SetState(5972)
			p.ArithmeticExpression()
		}
		{
			p.SetState(5973)
			p.Abbreviation()
		}
		{
			p.SetState(5974)
			p.Match(Cobol85ParserRPARENCHAR)
		}

	}

	return localctx
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_identifier
	return p
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) QualifiedDataName() IQualifiedDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *IdentifierContext) TableCall() ITableCallContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableCallContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableCallContext)
}

func (s *IdentifierContext) FunctionCall() IFunctionCallContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionCallContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *IdentifierContext) SpecialRegister() ISpecialRegisterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecialRegisterContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpecialRegisterContext)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterIdentifier(s)
	}
}

func (s *IdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitIdentifier(s)
	}
}

func (p *Cobol85Parser) Identifier() (localctx IIdentifierContext) {
	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1074, Cobol85ParserRULE_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5982)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 942, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5978)
			p.QualifiedDataName()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5979)
			p.TableCall()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5980)
			p.FunctionCall()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5981)
			p.SpecialRegister()
		}

	}

	return localctx
}

// ITableCallContext is an interface to support dynamic dispatch.
type ITableCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTableCallContext differentiates from other interfaces.
	IsTableCallContext()
}

type TableCallContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableCallContext() *TableCallContext {
	var p = new(TableCallContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_tableCall
	return p
}

func (*TableCallContext) IsTableCallContext() {}

func NewTableCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableCallContext {
	var p = new(TableCallContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_tableCall

	return p
}

func (s *TableCallContext) GetParser() antlr.Parser { return s.parser }

func (s *TableCallContext) QualifiedDataName() IQualifiedDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *TableCallContext) AllLPARENCHAR() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserLPARENCHAR)
}

func (s *TableCallContext) LPARENCHAR(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLPARENCHAR, i)
}

func (s *TableCallContext) AllSubscript() []ISubscriptContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISubscriptContext)(nil)).Elem())
	var tst = make([]ISubscriptContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISubscriptContext)
		}
	}

	return tst
}

func (s *TableCallContext) Subscript(i int) ISubscriptContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubscriptContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISubscriptContext)
}

func (s *TableCallContext) AllRPARENCHAR() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserRPARENCHAR)
}

func (s *TableCallContext) RPARENCHAR(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRPARENCHAR, i)
}

func (s *TableCallContext) ReferenceModifier() IReferenceModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReferenceModifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReferenceModifierContext)
}

func (s *TableCallContext) AllCOMMACHAR() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserCOMMACHAR)
}

func (s *TableCallContext) COMMACHAR(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMMACHAR, i)
}

func (s *TableCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterTableCall(s)
	}
}

func (s *TableCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitTableCall(s)
	}
}

func (p *Cobol85Parser) TableCall() (localctx ITableCallContext) {
	localctx = NewTableCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1076, Cobol85ParserRULE_tableCall)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5984)
		p.QualifiedDataName()
	}
	p.SetState(6000)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 945, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(5985)
				p.Match(Cobol85ParserLPARENCHAR)
			}
			{
				p.SetState(5986)
				p.Subscript()
			}
			p.SetState(5993)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserADDRESS)|(1<<Cobol85ParserALL)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH)|(1<<Cobol85ParserATTRIBUTE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBINARY-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-68))|(1<<(Cobol85ParserCOBOL-68))|(1<<(Cobol85ParserCOMMITMENT-68))|(1<<(Cobol85ParserCONTROL_POINT-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(Cobol85ParserCONVENTION-100))|(1<<(Cobol85ParserCRUNCH-100))|(1<<(Cobol85ParserCURSOR-100))|(1<<(Cobol85ParserDATE-100))|(1<<(Cobol85ParserDAY-100))|(1<<(Cobol85ParserDAY_OF_WEEK-100))|(1<<(Cobol85ParserDEBUG_CONTENTS-100))|(1<<(Cobol85ParserDEBUG_ITEM-100))|(1<<(Cobol85ParserDEBUG_LINE-100))|(1<<(Cobol85ParserDEBUG_NAME-100))|(1<<(Cobol85ParserDEBUG_SUB_1-100))|(1<<(Cobol85ParserDEBUG_SUB_2-100))|(1<<(Cobol85ParserDEBUG_SUB_3-100))|(1<<(Cobol85ParserDEFAULT-100))|(1<<(Cobol85ParserDEFAULT_DISPLAY-100))|(1<<(Cobol85ParserDEFINITION-100)))) != 0) || (((_la-138)&-(0x1f+1)) == 0 && ((1<<uint((_la-138)))&((1<<(Cobol85ParserDFHRESP-138))|(1<<(Cobol85ParserDFHVALUE-138))|(1<<(Cobol85ParserDISK-138))|(1<<(Cobol85ParserDONTCARE-138))|(1<<(Cobol85ParserDOUBLE-138))|(1<<(Cobol85ParserEBCDIC-138))|(1<<(Cobol85ParserEMPTY_CHECK-138)))) != 0) || (((_la-181)&-(0x1f+1)) == 0 && ((1<<uint((_la-181)))&((1<<(Cobol85ParserENTER-181))|(1<<(Cobol85ParserENTRY_PROCEDURE-181))|(1<<(Cobol85ParserERASE-181))|(1<<(Cobol85ParserEOL-181))|(1<<(Cobol85ParserEOS-181))|(1<<(Cobol85ParserESCAPE-181))|(1<<(Cobol85ParserEVENT-181))|(1<<(Cobol85ParserEXCLUSIVE-181))|(1<<(Cobol85ParserEXPORT-181))|(1<<(Cobol85ParserEXTENDED-181))|(1<<(Cobol85ParserFALSE-181)))) != 0) || (((_la-213)&-(0x1f+1)) == 0 && ((1<<uint((_la-213)))&((1<<(Cobol85ParserFOREGROUND_COLOR-213))|(1<<(Cobol85ParserFOREGROUND_COLOUR-213))|(1<<(Cobol85ParserFULL-213))|(1<<(Cobol85ParserFUNCTION-213))|(1<<(Cobol85ParserFUNCTIONNAME-213))|(1<<(Cobol85ParserFUNCTION_POINTER-213))|(1<<(Cobol85ParserGRID-213))|(1<<(Cobol85ParserHIGHLIGHT-213))|(1<<(Cobol85ParserHIGH_VALUE-213))|(1<<(Cobol85ParserHIGH_VALUES-213))|(1<<(Cobol85ParserIMPLICIT-213))|(1<<(Cobol85ParserIMPORT-213)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(Cobol85ParserINTEGER-250))|(1<<(Cobol85ParserKEPT-250))|(1<<(Cobol85ParserKEYBOARD-250))|(1<<(Cobol85ParserLANGUAGE-250))|(1<<(Cobol85ParserLB-250))|(1<<(Cobol85ParserLD-250))|(1<<(Cobol85ParserLEFTLINE-250))|(1<<(Cobol85ParserLENGTH-250))|(1<<(Cobol85ParserLENGTH_CHECK-250))|(1<<(Cobol85ParserLIBACCESS-250))|(1<<(Cobol85ParserLIBPARAMETER-250))|(1<<(Cobol85ParserLIBRARY-250))|(1<<(Cobol85ParserLINAGE_COUNTER-250))|(1<<(Cobol85ParserLINE_COUNTER-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(Cobol85ParserLIST-283))|(1<<(Cobol85ParserLOCAL-283))|(1<<(Cobol85ParserLONG_DATE-283))|(1<<(Cobol85ParserLONG_TIME-283))|(1<<(Cobol85ParserLOWER-283))|(1<<(Cobol85ParserLOWLIGHT-283))|(1<<(Cobol85ParserLOW_VALUE-283))|(1<<(Cobol85ParserLOW_VALUES-283))|(1<<(Cobol85ParserMMDDYYYY-283))|(1<<(Cobol85ParserNAMED-283))|(1<<(Cobol85ParserNATIONAL-283))|(1<<(Cobol85ParserNATIONAL_EDITED-283))|(1<<(Cobol85ParserNETWORK-283))|(1<<(Cobol85ParserNO_ECHO-283))|(1<<(Cobol85ParserNULL-283))|(1<<(Cobol85ParserNULLS-283)))) != 0) || (((_la-317)&-(0x1f+1)) == 0 && ((1<<uint((_la-317)))&((1<<(Cobol85ParserNUMERIC_DATE-317))|(1<<(Cobol85ParserNUMERIC_TIME-317))|(1<<(Cobol85ParserODT-317))|(1<<(Cobol85ParserORDERLY-317))|(1<<(Cobol85ParserOVERLINE-317))|(1<<(Cobol85ParserOWN-317))|(1<<(Cobol85ParserPAGE_COUNTER-317))|(1<<(Cobol85ParserPASSWORD-317)))) != 0) || (((_la-352)&-(0x1f+1)) == 0 && ((1<<uint((_la-352)))&((1<<(Cobol85ParserPORT-352))|(1<<(Cobol85ParserPRINTER-352))|(1<<(Cobol85ParserPRIVATE-352))|(1<<(Cobol85ParserPROCESS-352))|(1<<(Cobol85ParserPROGRAM-352))|(1<<(Cobol85ParserPROMPT-352))|(1<<(Cobol85ParserQUOTE-352))|(1<<(Cobol85ParserQUOTES-352))|(1<<(Cobol85ParserREADER-352))|(1<<(Cobol85ParserREMOTE-352))|(1<<(Cobol85ParserREAL-352))|(1<<(Cobol85ParserRECEIVED-352))|(1<<(Cobol85ParserRECURSIVE-352))|(1<<(Cobol85ParserREF-352)))) != 0) || (((_la-391)&-(0x1f+1)) == 0 && ((1<<uint((_la-391)))&((1<<(Cobol85ParserREMOVE-391))|(1<<(Cobol85ParserREQUIRED-391))|(1<<(Cobol85ParserREVERSE_VIDEO-391))|(1<<(Cobol85ParserRETURN_CODE-391))|(1<<(Cobol85ParserSAVE-391))|(1<<(Cobol85ParserSECURE-391)))) != 0) || (((_la-431)&-(0x1f+1)) == 0 && ((1<<uint((_la-431)))&((1<<(Cobol85ParserSHARED-431))|(1<<(Cobol85ParserSHAREDBYALL-431))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-431))|(1<<(Cobol85ParserSHARING-431))|(1<<(Cobol85ParserSHIFT_IN-431))|(1<<(Cobol85ParserSHIFT_OUT-431))|(1<<(Cobol85ParserSHORT_DATE-431))|(1<<(Cobol85ParserSORT_CONTROL-431))|(1<<(Cobol85ParserSORT_CORE_SIZE-431))|(1<<(Cobol85ParserSORT_FILE_SIZE-431))|(1<<(Cobol85ParserSORT_MESSAGE-431))|(1<<(Cobol85ParserSORT_MODE_SIZE-431))|(1<<(Cobol85ParserSORT_RETURN-431))|(1<<(Cobol85ParserSPACE-431))|(1<<(Cobol85ParserSPACES-431)))) != 0) || (((_la-466)&-(0x1f+1)) == 0 && ((1<<uint((_la-466)))&((1<<(Cobol85ParserSYMBOL-466))|(1<<(Cobol85ParserTALLY-466))|(1<<(Cobol85ParserTASK-466))|(1<<(Cobol85ParserTHREAD-466))|(1<<(Cobol85ParserTHREAD_LOCAL-466))|(1<<(Cobol85ParserTIME-466))|(1<<(Cobol85ParserTIMER-466))|(1<<(Cobol85ParserTODAYS_DATE-466))|(1<<(Cobol85ParserTODAYS_NAME-466))|(1<<(Cobol85ParserTRUE-466))|(1<<(Cobol85ParserTRUNCATED-466))|(1<<(Cobol85ParserTYPEDEF-466)))) != 0) || (((_la-498)&-(0x1f+1)) == 0 && ((1<<uint((_la-498)))&((1<<(Cobol85ParserUNDERLINE-498))|(1<<(Cobol85ParserVIRTUAL-498))|(1<<(Cobol85ParserWAIT-498))|(1<<(Cobol85ParserWHEN_COMPILED-498))|(1<<(Cobol85ParserYEAR-498))|(1<<(Cobol85ParserYYYYMMDD-498))|(1<<(Cobol85ParserYYYYDDD-498))|(1<<(Cobol85ParserZERO-498))|(1<<(Cobol85ParserZERO_FILL-498))|(1<<(Cobol85ParserZEROS-498))|(1<<(Cobol85ParserZEROES-498))|(1<<(Cobol85ParserCOMMACHAR-498)))) != 0) || (((_la-542)&-(0x1f+1)) == 0 && ((1<<uint((_la-542)))&((1<<(Cobol85ParserLPARENCHAR-542))|(1<<(Cobol85ParserMINUSCHAR-542))|(1<<(Cobol85ParserPLUSCHAR-542))|(1<<(Cobol85ParserNONNUMERICLITERAL-542))|(1<<(Cobol85ParserLEVEL_NUMBER_66-542))|(1<<(Cobol85ParserLEVEL_NUMBER_77-542))|(1<<(Cobol85ParserLEVEL_NUMBER_88-542))|(1<<(Cobol85ParserINTEGERLITERAL-542))|(1<<(Cobol85ParserNUMERICLITERAL-542))|(1<<(Cobol85ParserIDENTIFIER-542)))) != 0) {
				p.SetState(5988)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == Cobol85ParserCOMMACHAR {
					{
						p.SetState(5987)
						p.Match(Cobol85ParserCOMMACHAR)
					}

				}
				{
					p.SetState(5990)
					p.Subscript()
				}

				p.SetState(5995)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(5996)
				p.Match(Cobol85ParserRPARENCHAR)
			}

		}
		p.SetState(6002)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 945, p.GetParserRuleContext())
	}
	p.SetState(6004)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 946, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(6003)
			p.ReferenceModifier()
		}

	}

	return localctx
}

// IFunctionCallContext is an interface to support dynamic dispatch.
type IFunctionCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionCallContext differentiates from other interfaces.
	IsFunctionCallContext()
}

type FunctionCallContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionCallContext() *FunctionCallContext {
	var p = new(FunctionCallContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_functionCall
	return p
}

func (*FunctionCallContext) IsFunctionCallContext() {}

func NewFunctionCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionCallContext {
	var p = new(FunctionCallContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_functionCall

	return p
}

func (s *FunctionCallContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionCallContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFUNCTION, 0)
}

func (s *FunctionCallContext) FunctionName() IFunctionNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionNameContext)
}

func (s *FunctionCallContext) AllLPARENCHAR() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserLPARENCHAR)
}

func (s *FunctionCallContext) LPARENCHAR(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLPARENCHAR, i)
}

func (s *FunctionCallContext) AllArgument() []IArgumentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IArgumentContext)(nil)).Elem())
	var tst = make([]IArgumentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IArgumentContext)
		}
	}

	return tst
}

func (s *FunctionCallContext) Argument(i int) IArgumentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IArgumentContext)
}

func (s *FunctionCallContext) AllRPARENCHAR() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserRPARENCHAR)
}

func (s *FunctionCallContext) RPARENCHAR(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRPARENCHAR, i)
}

func (s *FunctionCallContext) ReferenceModifier() IReferenceModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReferenceModifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReferenceModifierContext)
}

func (s *FunctionCallContext) AllCOMMACHAR() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserCOMMACHAR)
}

func (s *FunctionCallContext) COMMACHAR(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMMACHAR, i)
}

func (s *FunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterFunctionCall(s)
	}
}

func (s *FunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitFunctionCall(s)
	}
}

func (p *Cobol85Parser) FunctionCall() (localctx IFunctionCallContext) {
	localctx = NewFunctionCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1078, Cobol85ParserRULE_functionCall)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6006)
		p.Match(Cobol85ParserFUNCTION)
	}
	{
		p.SetState(6007)
		p.FunctionName()
	}
	p.SetState(6023)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 949, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(6008)
				p.Match(Cobol85ParserLPARENCHAR)
			}
			{
				p.SetState(6009)
				p.Argument()
			}
			p.SetState(6016)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserADDRESS)|(1<<Cobol85ParserALL)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH)|(1<<Cobol85ParserATTRIBUTE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBINARY-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-68))|(1<<(Cobol85ParserCOBOL-68))|(1<<(Cobol85ParserCOMMITMENT-68))|(1<<(Cobol85ParserCONTROL_POINT-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(Cobol85ParserCONVENTION-100))|(1<<(Cobol85ParserCRUNCH-100))|(1<<(Cobol85ParserCURSOR-100))|(1<<(Cobol85ParserDATE-100))|(1<<(Cobol85ParserDAY-100))|(1<<(Cobol85ParserDAY_OF_WEEK-100))|(1<<(Cobol85ParserDEBUG_CONTENTS-100))|(1<<(Cobol85ParserDEBUG_ITEM-100))|(1<<(Cobol85ParserDEBUG_LINE-100))|(1<<(Cobol85ParserDEBUG_NAME-100))|(1<<(Cobol85ParserDEBUG_SUB_1-100))|(1<<(Cobol85ParserDEBUG_SUB_2-100))|(1<<(Cobol85ParserDEBUG_SUB_3-100))|(1<<(Cobol85ParserDEFAULT-100))|(1<<(Cobol85ParserDEFAULT_DISPLAY-100))|(1<<(Cobol85ParserDEFINITION-100)))) != 0) || (((_la-138)&-(0x1f+1)) == 0 && ((1<<uint((_la-138)))&((1<<(Cobol85ParserDFHRESP-138))|(1<<(Cobol85ParserDFHVALUE-138))|(1<<(Cobol85ParserDISK-138))|(1<<(Cobol85ParserDONTCARE-138))|(1<<(Cobol85ParserDOUBLE-138))|(1<<(Cobol85ParserEBCDIC-138))|(1<<(Cobol85ParserEMPTY_CHECK-138)))) != 0) || (((_la-181)&-(0x1f+1)) == 0 && ((1<<uint((_la-181)))&((1<<(Cobol85ParserENTER-181))|(1<<(Cobol85ParserENTRY_PROCEDURE-181))|(1<<(Cobol85ParserERASE-181))|(1<<(Cobol85ParserEOL-181))|(1<<(Cobol85ParserEOS-181))|(1<<(Cobol85ParserESCAPE-181))|(1<<(Cobol85ParserEVENT-181))|(1<<(Cobol85ParserEXCLUSIVE-181))|(1<<(Cobol85ParserEXPORT-181))|(1<<(Cobol85ParserEXTENDED-181))|(1<<(Cobol85ParserFALSE-181)))) != 0) || (((_la-213)&-(0x1f+1)) == 0 && ((1<<uint((_la-213)))&((1<<(Cobol85ParserFOREGROUND_COLOR-213))|(1<<(Cobol85ParserFOREGROUND_COLOUR-213))|(1<<(Cobol85ParserFULL-213))|(1<<(Cobol85ParserFUNCTION-213))|(1<<(Cobol85ParserFUNCTIONNAME-213))|(1<<(Cobol85ParserFUNCTION_POINTER-213))|(1<<(Cobol85ParserGRID-213))|(1<<(Cobol85ParserHIGHLIGHT-213))|(1<<(Cobol85ParserHIGH_VALUE-213))|(1<<(Cobol85ParserHIGH_VALUES-213))|(1<<(Cobol85ParserIMPLICIT-213))|(1<<(Cobol85ParserIMPORT-213)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(Cobol85ParserINTEGER-250))|(1<<(Cobol85ParserKEPT-250))|(1<<(Cobol85ParserKEYBOARD-250))|(1<<(Cobol85ParserLANGUAGE-250))|(1<<(Cobol85ParserLB-250))|(1<<(Cobol85ParserLD-250))|(1<<(Cobol85ParserLEFTLINE-250))|(1<<(Cobol85ParserLENGTH-250))|(1<<(Cobol85ParserLENGTH_CHECK-250))|(1<<(Cobol85ParserLIBACCESS-250))|(1<<(Cobol85ParserLIBPARAMETER-250))|(1<<(Cobol85ParserLIBRARY-250))|(1<<(Cobol85ParserLINAGE_COUNTER-250))|(1<<(Cobol85ParserLINE_COUNTER-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(Cobol85ParserLIST-283))|(1<<(Cobol85ParserLOCAL-283))|(1<<(Cobol85ParserLONG_DATE-283))|(1<<(Cobol85ParserLONG_TIME-283))|(1<<(Cobol85ParserLOWER-283))|(1<<(Cobol85ParserLOWLIGHT-283))|(1<<(Cobol85ParserLOW_VALUE-283))|(1<<(Cobol85ParserLOW_VALUES-283))|(1<<(Cobol85ParserMMDDYYYY-283))|(1<<(Cobol85ParserNAMED-283))|(1<<(Cobol85ParserNATIONAL-283))|(1<<(Cobol85ParserNATIONAL_EDITED-283))|(1<<(Cobol85ParserNETWORK-283))|(1<<(Cobol85ParserNO_ECHO-283))|(1<<(Cobol85ParserNULL-283))|(1<<(Cobol85ParserNULLS-283)))) != 0) || (((_la-317)&-(0x1f+1)) == 0 && ((1<<uint((_la-317)))&((1<<(Cobol85ParserNUMERIC_DATE-317))|(1<<(Cobol85ParserNUMERIC_TIME-317))|(1<<(Cobol85ParserODT-317))|(1<<(Cobol85ParserORDERLY-317))|(1<<(Cobol85ParserOVERLINE-317))|(1<<(Cobol85ParserOWN-317))|(1<<(Cobol85ParserPAGE_COUNTER-317))|(1<<(Cobol85ParserPASSWORD-317)))) != 0) || (((_la-352)&-(0x1f+1)) == 0 && ((1<<uint((_la-352)))&((1<<(Cobol85ParserPORT-352))|(1<<(Cobol85ParserPRINTER-352))|(1<<(Cobol85ParserPRIVATE-352))|(1<<(Cobol85ParserPROCESS-352))|(1<<(Cobol85ParserPROGRAM-352))|(1<<(Cobol85ParserPROMPT-352))|(1<<(Cobol85ParserQUOTE-352))|(1<<(Cobol85ParserQUOTES-352))|(1<<(Cobol85ParserREADER-352))|(1<<(Cobol85ParserREMOTE-352))|(1<<(Cobol85ParserREAL-352))|(1<<(Cobol85ParserRECEIVED-352))|(1<<(Cobol85ParserRECURSIVE-352))|(1<<(Cobol85ParserREF-352)))) != 0) || (((_la-391)&-(0x1f+1)) == 0 && ((1<<uint((_la-391)))&((1<<(Cobol85ParserREMOVE-391))|(1<<(Cobol85ParserREQUIRED-391))|(1<<(Cobol85ParserREVERSE_VIDEO-391))|(1<<(Cobol85ParserRETURN_CODE-391))|(1<<(Cobol85ParserSAVE-391))|(1<<(Cobol85ParserSECURE-391)))) != 0) || (((_la-431)&-(0x1f+1)) == 0 && ((1<<uint((_la-431)))&((1<<(Cobol85ParserSHARED-431))|(1<<(Cobol85ParserSHAREDBYALL-431))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-431))|(1<<(Cobol85ParserSHARING-431))|(1<<(Cobol85ParserSHIFT_IN-431))|(1<<(Cobol85ParserSHIFT_OUT-431))|(1<<(Cobol85ParserSHORT_DATE-431))|(1<<(Cobol85ParserSORT_CONTROL-431))|(1<<(Cobol85ParserSORT_CORE_SIZE-431))|(1<<(Cobol85ParserSORT_FILE_SIZE-431))|(1<<(Cobol85ParserSORT_MESSAGE-431))|(1<<(Cobol85ParserSORT_MODE_SIZE-431))|(1<<(Cobol85ParserSORT_RETURN-431))|(1<<(Cobol85ParserSPACE-431))|(1<<(Cobol85ParserSPACES-431)))) != 0) || (((_la-466)&-(0x1f+1)) == 0 && ((1<<uint((_la-466)))&((1<<(Cobol85ParserSYMBOL-466))|(1<<(Cobol85ParserTALLY-466))|(1<<(Cobol85ParserTASK-466))|(1<<(Cobol85ParserTHREAD-466))|(1<<(Cobol85ParserTHREAD_LOCAL-466))|(1<<(Cobol85ParserTIME-466))|(1<<(Cobol85ParserTIMER-466))|(1<<(Cobol85ParserTODAYS_DATE-466))|(1<<(Cobol85ParserTODAYS_NAME-466))|(1<<(Cobol85ParserTRUE-466))|(1<<(Cobol85ParserTRUNCATED-466))|(1<<(Cobol85ParserTYPEDEF-466)))) != 0) || (((_la-498)&-(0x1f+1)) == 0 && ((1<<uint((_la-498)))&((1<<(Cobol85ParserUNDERLINE-498))|(1<<(Cobol85ParserVIRTUAL-498))|(1<<(Cobol85ParserWAIT-498))|(1<<(Cobol85ParserWHEN_COMPILED-498))|(1<<(Cobol85ParserYEAR-498))|(1<<(Cobol85ParserYYYYMMDD-498))|(1<<(Cobol85ParserYYYYDDD-498))|(1<<(Cobol85ParserZERO-498))|(1<<(Cobol85ParserZERO_FILL-498))|(1<<(Cobol85ParserZEROS-498))|(1<<(Cobol85ParserZEROES-498))|(1<<(Cobol85ParserCOMMACHAR-498)))) != 0) || (((_la-542)&-(0x1f+1)) == 0 && ((1<<uint((_la-542)))&((1<<(Cobol85ParserLPARENCHAR-542))|(1<<(Cobol85ParserMINUSCHAR-542))|(1<<(Cobol85ParserPLUSCHAR-542))|(1<<(Cobol85ParserNONNUMERICLITERAL-542))|(1<<(Cobol85ParserLEVEL_NUMBER_66-542))|(1<<(Cobol85ParserLEVEL_NUMBER_77-542))|(1<<(Cobol85ParserLEVEL_NUMBER_88-542))|(1<<(Cobol85ParserINTEGERLITERAL-542))|(1<<(Cobol85ParserNUMERICLITERAL-542))|(1<<(Cobol85ParserIDENTIFIER-542)))) != 0) {
				p.SetState(6011)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == Cobol85ParserCOMMACHAR {
					{
						p.SetState(6010)
						p.Match(Cobol85ParserCOMMACHAR)
					}

				}
				{
					p.SetState(6013)
					p.Argument()
				}

				p.SetState(6018)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(6019)
				p.Match(Cobol85ParserRPARENCHAR)
			}

		}
		p.SetState(6025)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 949, p.GetParserRuleContext())
	}
	p.SetState(6027)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 950, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(6026)
			p.ReferenceModifier()
		}

	}

	return localctx
}

// IReferenceModifierContext is an interface to support dynamic dispatch.
type IReferenceModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReferenceModifierContext differentiates from other interfaces.
	IsReferenceModifierContext()
}

type ReferenceModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReferenceModifierContext() *ReferenceModifierContext {
	var p = new(ReferenceModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_referenceModifier
	return p
}

func (*ReferenceModifierContext) IsReferenceModifierContext() {}

func NewReferenceModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReferenceModifierContext {
	var p = new(ReferenceModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_referenceModifier

	return p
}

func (s *ReferenceModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ReferenceModifierContext) LPARENCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLPARENCHAR, 0)
}

func (s *ReferenceModifierContext) CharacterPosition() ICharacterPositionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICharacterPositionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICharacterPositionContext)
}

func (s *ReferenceModifierContext) COLONCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOLONCHAR, 0)
}

func (s *ReferenceModifierContext) RPARENCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRPARENCHAR, 0)
}

func (s *ReferenceModifierContext) Length() ILengthContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILengthContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILengthContext)
}

func (s *ReferenceModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReferenceModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReferenceModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReferenceModifier(s)
	}
}

func (s *ReferenceModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReferenceModifier(s)
	}
}

func (p *Cobol85Parser) ReferenceModifier() (localctx IReferenceModifierContext) {
	localctx = NewReferenceModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1080, Cobol85ParserRULE_referenceModifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6029)
		p.Match(Cobol85ParserLPARENCHAR)
	}
	{
		p.SetState(6030)
		p.CharacterPosition()
	}
	{
		p.SetState(6031)
		p.Match(Cobol85ParserCOLONCHAR)
	}
	p.SetState(6033)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserADDRESS)|(1<<Cobol85ParserALL)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH)|(1<<Cobol85ParserATTRIBUTE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBINARY-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-68))|(1<<(Cobol85ParserCOBOL-68))|(1<<(Cobol85ParserCOMMITMENT-68))|(1<<(Cobol85ParserCONTROL_POINT-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(Cobol85ParserCONVENTION-100))|(1<<(Cobol85ParserCRUNCH-100))|(1<<(Cobol85ParserCURSOR-100))|(1<<(Cobol85ParserDATE-100))|(1<<(Cobol85ParserDAY-100))|(1<<(Cobol85ParserDAY_OF_WEEK-100))|(1<<(Cobol85ParserDEBUG_CONTENTS-100))|(1<<(Cobol85ParserDEBUG_ITEM-100))|(1<<(Cobol85ParserDEBUG_LINE-100))|(1<<(Cobol85ParserDEBUG_NAME-100))|(1<<(Cobol85ParserDEBUG_SUB_1-100))|(1<<(Cobol85ParserDEBUG_SUB_2-100))|(1<<(Cobol85ParserDEBUG_SUB_3-100))|(1<<(Cobol85ParserDEFAULT-100))|(1<<(Cobol85ParserDEFAULT_DISPLAY-100))|(1<<(Cobol85ParserDEFINITION-100)))) != 0) || (((_la-138)&-(0x1f+1)) == 0 && ((1<<uint((_la-138)))&((1<<(Cobol85ParserDFHRESP-138))|(1<<(Cobol85ParserDFHVALUE-138))|(1<<(Cobol85ParserDISK-138))|(1<<(Cobol85ParserDONTCARE-138))|(1<<(Cobol85ParserDOUBLE-138))|(1<<(Cobol85ParserEBCDIC-138))|(1<<(Cobol85ParserEMPTY_CHECK-138)))) != 0) || (((_la-181)&-(0x1f+1)) == 0 && ((1<<uint((_la-181)))&((1<<(Cobol85ParserENTER-181))|(1<<(Cobol85ParserENTRY_PROCEDURE-181))|(1<<(Cobol85ParserERASE-181))|(1<<(Cobol85ParserEOL-181))|(1<<(Cobol85ParserEOS-181))|(1<<(Cobol85ParserESCAPE-181))|(1<<(Cobol85ParserEVENT-181))|(1<<(Cobol85ParserEXCLUSIVE-181))|(1<<(Cobol85ParserEXPORT-181))|(1<<(Cobol85ParserEXTENDED-181))|(1<<(Cobol85ParserFALSE-181)))) != 0) || (((_la-213)&-(0x1f+1)) == 0 && ((1<<uint((_la-213)))&((1<<(Cobol85ParserFOREGROUND_COLOR-213))|(1<<(Cobol85ParserFOREGROUND_COLOUR-213))|(1<<(Cobol85ParserFULL-213))|(1<<(Cobol85ParserFUNCTION-213))|(1<<(Cobol85ParserFUNCTIONNAME-213))|(1<<(Cobol85ParserFUNCTION_POINTER-213))|(1<<(Cobol85ParserGRID-213))|(1<<(Cobol85ParserHIGHLIGHT-213))|(1<<(Cobol85ParserHIGH_VALUE-213))|(1<<(Cobol85ParserHIGH_VALUES-213))|(1<<(Cobol85ParserIMPLICIT-213))|(1<<(Cobol85ParserIMPORT-213)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(Cobol85ParserINTEGER-250))|(1<<(Cobol85ParserKEPT-250))|(1<<(Cobol85ParserKEYBOARD-250))|(1<<(Cobol85ParserLANGUAGE-250))|(1<<(Cobol85ParserLB-250))|(1<<(Cobol85ParserLD-250))|(1<<(Cobol85ParserLEFTLINE-250))|(1<<(Cobol85ParserLENGTH-250))|(1<<(Cobol85ParserLENGTH_CHECK-250))|(1<<(Cobol85ParserLIBACCESS-250))|(1<<(Cobol85ParserLIBPARAMETER-250))|(1<<(Cobol85ParserLIBRARY-250))|(1<<(Cobol85ParserLINAGE_COUNTER-250))|(1<<(Cobol85ParserLINE_COUNTER-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(Cobol85ParserLIST-283))|(1<<(Cobol85ParserLOCAL-283))|(1<<(Cobol85ParserLONG_DATE-283))|(1<<(Cobol85ParserLONG_TIME-283))|(1<<(Cobol85ParserLOWER-283))|(1<<(Cobol85ParserLOWLIGHT-283))|(1<<(Cobol85ParserLOW_VALUE-283))|(1<<(Cobol85ParserLOW_VALUES-283))|(1<<(Cobol85ParserMMDDYYYY-283))|(1<<(Cobol85ParserNAMED-283))|(1<<(Cobol85ParserNATIONAL-283))|(1<<(Cobol85ParserNATIONAL_EDITED-283))|(1<<(Cobol85ParserNETWORK-283))|(1<<(Cobol85ParserNO_ECHO-283))|(1<<(Cobol85ParserNULL-283))|(1<<(Cobol85ParserNULLS-283)))) != 0) || (((_la-317)&-(0x1f+1)) == 0 && ((1<<uint((_la-317)))&((1<<(Cobol85ParserNUMERIC_DATE-317))|(1<<(Cobol85ParserNUMERIC_TIME-317))|(1<<(Cobol85ParserODT-317))|(1<<(Cobol85ParserORDERLY-317))|(1<<(Cobol85ParserOVERLINE-317))|(1<<(Cobol85ParserOWN-317))|(1<<(Cobol85ParserPAGE_COUNTER-317))|(1<<(Cobol85ParserPASSWORD-317)))) != 0) || (((_la-352)&-(0x1f+1)) == 0 && ((1<<uint((_la-352)))&((1<<(Cobol85ParserPORT-352))|(1<<(Cobol85ParserPRINTER-352))|(1<<(Cobol85ParserPRIVATE-352))|(1<<(Cobol85ParserPROCESS-352))|(1<<(Cobol85ParserPROGRAM-352))|(1<<(Cobol85ParserPROMPT-352))|(1<<(Cobol85ParserQUOTE-352))|(1<<(Cobol85ParserQUOTES-352))|(1<<(Cobol85ParserREADER-352))|(1<<(Cobol85ParserREMOTE-352))|(1<<(Cobol85ParserREAL-352))|(1<<(Cobol85ParserRECEIVED-352))|(1<<(Cobol85ParserRECURSIVE-352))|(1<<(Cobol85ParserREF-352)))) != 0) || (((_la-391)&-(0x1f+1)) == 0 && ((1<<uint((_la-391)))&((1<<(Cobol85ParserREMOVE-391))|(1<<(Cobol85ParserREQUIRED-391))|(1<<(Cobol85ParserREVERSE_VIDEO-391))|(1<<(Cobol85ParserRETURN_CODE-391))|(1<<(Cobol85ParserSAVE-391))|(1<<(Cobol85ParserSECURE-391)))) != 0) || (((_la-431)&-(0x1f+1)) == 0 && ((1<<uint((_la-431)))&((1<<(Cobol85ParserSHARED-431))|(1<<(Cobol85ParserSHAREDBYALL-431))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-431))|(1<<(Cobol85ParserSHARING-431))|(1<<(Cobol85ParserSHIFT_IN-431))|(1<<(Cobol85ParserSHIFT_OUT-431))|(1<<(Cobol85ParserSHORT_DATE-431))|(1<<(Cobol85ParserSORT_CONTROL-431))|(1<<(Cobol85ParserSORT_CORE_SIZE-431))|(1<<(Cobol85ParserSORT_FILE_SIZE-431))|(1<<(Cobol85ParserSORT_MESSAGE-431))|(1<<(Cobol85ParserSORT_MODE_SIZE-431))|(1<<(Cobol85ParserSORT_RETURN-431))|(1<<(Cobol85ParserSPACE-431))|(1<<(Cobol85ParserSPACES-431)))) != 0) || (((_la-466)&-(0x1f+1)) == 0 && ((1<<uint((_la-466)))&((1<<(Cobol85ParserSYMBOL-466))|(1<<(Cobol85ParserTALLY-466))|(1<<(Cobol85ParserTASK-466))|(1<<(Cobol85ParserTHREAD-466))|(1<<(Cobol85ParserTHREAD_LOCAL-466))|(1<<(Cobol85ParserTIME-466))|(1<<(Cobol85ParserTIMER-466))|(1<<(Cobol85ParserTODAYS_DATE-466))|(1<<(Cobol85ParserTODAYS_NAME-466))|(1<<(Cobol85ParserTRUE-466))|(1<<(Cobol85ParserTRUNCATED-466))|(1<<(Cobol85ParserTYPEDEF-466)))) != 0) || (((_la-498)&-(0x1f+1)) == 0 && ((1<<uint((_la-498)))&((1<<(Cobol85ParserUNDERLINE-498))|(1<<(Cobol85ParserVIRTUAL-498))|(1<<(Cobol85ParserWAIT-498))|(1<<(Cobol85ParserWHEN_COMPILED-498))|(1<<(Cobol85ParserYEAR-498))|(1<<(Cobol85ParserYYYYMMDD-498))|(1<<(Cobol85ParserYYYYDDD-498))|(1<<(Cobol85ParserZERO-498))|(1<<(Cobol85ParserZERO_FILL-498))|(1<<(Cobol85ParserZEROS-498))|(1<<(Cobol85ParserZEROES-498)))) != 0) || (((_la-542)&-(0x1f+1)) == 0 && ((1<<uint((_la-542)))&((1<<(Cobol85ParserLPARENCHAR-542))|(1<<(Cobol85ParserMINUSCHAR-542))|(1<<(Cobol85ParserPLUSCHAR-542))|(1<<(Cobol85ParserNONNUMERICLITERAL-542))|(1<<(Cobol85ParserLEVEL_NUMBER_66-542))|(1<<(Cobol85ParserLEVEL_NUMBER_77-542))|(1<<(Cobol85ParserLEVEL_NUMBER_88-542))|(1<<(Cobol85ParserINTEGERLITERAL-542))|(1<<(Cobol85ParserNUMERICLITERAL-542))|(1<<(Cobol85ParserIDENTIFIER-542)))) != 0) {
		{
			p.SetState(6032)
			p.Length()
		}

	}
	{
		p.SetState(6035)
		p.Match(Cobol85ParserRPARENCHAR)
	}

	return localctx
}

// ICharacterPositionContext is an interface to support dynamic dispatch.
type ICharacterPositionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCharacterPositionContext differentiates from other interfaces.
	IsCharacterPositionContext()
}

type CharacterPositionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharacterPositionContext() *CharacterPositionContext {
	var p = new(CharacterPositionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_characterPosition
	return p
}

func (*CharacterPositionContext) IsCharacterPositionContext() {}

func NewCharacterPositionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CharacterPositionContext {
	var p = new(CharacterPositionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_characterPosition

	return p
}

func (s *CharacterPositionContext) GetParser() antlr.Parser { return s.parser }

func (s *CharacterPositionContext) ArithmeticExpression() IArithmeticExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArithmeticExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArithmeticExpressionContext)
}

func (s *CharacterPositionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CharacterPositionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CharacterPositionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCharacterPosition(s)
	}
}

func (s *CharacterPositionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCharacterPosition(s)
	}
}

func (p *Cobol85Parser) CharacterPosition() (localctx ICharacterPositionContext) {
	localctx = NewCharacterPositionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1082, Cobol85ParserRULE_characterPosition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6037)
		p.ArithmeticExpression()
	}

	return localctx
}

// ILengthContext is an interface to support dynamic dispatch.
type ILengthContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLengthContext differentiates from other interfaces.
	IsLengthContext()
}

type LengthContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLengthContext() *LengthContext {
	var p = new(LengthContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_length
	return p
}

func (*LengthContext) IsLengthContext() {}

func NewLengthContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LengthContext {
	var p = new(LengthContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_length

	return p
}

func (s *LengthContext) GetParser() antlr.Parser { return s.parser }

func (s *LengthContext) ArithmeticExpression() IArithmeticExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArithmeticExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArithmeticExpressionContext)
}

func (s *LengthContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LengthContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LengthContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLength(s)
	}
}

func (s *LengthContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLength(s)
	}
}

func (p *Cobol85Parser) Length() (localctx ILengthContext) {
	localctx = NewLengthContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1084, Cobol85ParserRULE_length)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6039)
		p.ArithmeticExpression()
	}

	return localctx
}

// ISubscriptContext is an interface to support dynamic dispatch.
type ISubscriptContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubscriptContext differentiates from other interfaces.
	IsSubscriptContext()
}

type SubscriptContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubscriptContext() *SubscriptContext {
	var p = new(SubscriptContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_subscript
	return p
}

func (*SubscriptContext) IsSubscriptContext() {}

func NewSubscriptContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubscriptContext {
	var p = new(SubscriptContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_subscript

	return p
}

func (s *SubscriptContext) GetParser() antlr.Parser { return s.parser }

func (s *SubscriptContext) ALL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALL, 0)
}

func (s *SubscriptContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *SubscriptContext) QualifiedDataName() IQualifiedDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *SubscriptContext) IndexName() IIndexNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIndexNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIndexNameContext)
}

func (s *SubscriptContext) ArithmeticExpression() IArithmeticExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArithmeticExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArithmeticExpressionContext)
}

func (s *SubscriptContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubscriptContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubscriptContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSubscript(s)
	}
}

func (s *SubscriptContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSubscript(s)
	}
}

func (p *Cobol85Parser) Subscript() (localctx ISubscriptContext) {
	localctx = NewSubscriptContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1086, Cobol85ParserRULE_subscript)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6052)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 954, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6041)
			p.Match(Cobol85ParserALL)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6042)
			p.IntegerLiteral()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6043)
			p.QualifiedDataName()
		}
		p.SetState(6045)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 952, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6044)
				p.IntegerLiteral()
			}

		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6047)
			p.IndexName()
		}
		p.SetState(6049)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 953, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6048)
				p.IntegerLiteral()
			}

		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6051)
			p.ArithmeticExpression()
		}

	}

	return localctx
}

// IArgumentContext is an interface to support dynamic dispatch.
type IArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArgumentContext differentiates from other interfaces.
	IsArgumentContext()
}

type ArgumentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentContext() *ArgumentContext {
	var p = new(ArgumentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_argument
	return p
}

func (*ArgumentContext) IsArgumentContext() {}

func NewArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentContext {
	var p = new(ArgumentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_argument

	return p
}

func (s *ArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *ArgumentContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ArgumentContext) QualifiedDataName() IQualifiedDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *ArgumentContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ArgumentContext) IndexName() IIndexNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIndexNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIndexNameContext)
}

func (s *ArgumentContext) ArithmeticExpression() IArithmeticExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArithmeticExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArithmeticExpressionContext)
}

func (s *ArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterArgument(s)
	}
}

func (s *ArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitArgument(s)
	}
}

func (p *Cobol85Parser) Argument() (localctx IArgumentContext) {
	localctx = NewArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1088, Cobol85ParserRULE_argument)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6065)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 957, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6054)
			p.Literal()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6055)
			p.Identifier()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6056)
			p.QualifiedDataName()
		}
		p.SetState(6058)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 955, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6057)
				p.IntegerLiteral()
			}

		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6060)
			p.IndexName()
		}
		p.SetState(6062)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 956, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6061)
				p.IntegerLiteral()
			}

		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6064)
			p.ArithmeticExpression()
		}

	}

	return localctx
}

// IQualifiedDataNameContext is an interface to support dynamic dispatch.
type IQualifiedDataNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQualifiedDataNameContext differentiates from other interfaces.
	IsQualifiedDataNameContext()
}

type QualifiedDataNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedDataNameContext() *QualifiedDataNameContext {
	var p = new(QualifiedDataNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_qualifiedDataName
	return p
}

func (*QualifiedDataNameContext) IsQualifiedDataNameContext() {}

func NewQualifiedDataNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedDataNameContext {
	var p = new(QualifiedDataNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_qualifiedDataName

	return p
}

func (s *QualifiedDataNameContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedDataNameContext) QualifiedDataNameFormat1() IQualifiedDataNameFormat1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedDataNameFormat1Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameFormat1Context)
}

func (s *QualifiedDataNameContext) QualifiedDataNameFormat2() IQualifiedDataNameFormat2Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedDataNameFormat2Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameFormat2Context)
}

func (s *QualifiedDataNameContext) QualifiedDataNameFormat3() IQualifiedDataNameFormat3Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedDataNameFormat3Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameFormat3Context)
}

func (s *QualifiedDataNameContext) QualifiedDataNameFormat4() IQualifiedDataNameFormat4Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedDataNameFormat4Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameFormat4Context)
}

func (s *QualifiedDataNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedDataNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedDataNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterQualifiedDataName(s)
	}
}

func (s *QualifiedDataNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitQualifiedDataName(s)
	}
}

func (p *Cobol85Parser) QualifiedDataName() (localctx IQualifiedDataNameContext) {
	localctx = NewQualifiedDataNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1090, Cobol85ParserRULE_qualifiedDataName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6071)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 958, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6067)
			p.QualifiedDataNameFormat1()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6068)
			p.QualifiedDataNameFormat2()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6069)
			p.QualifiedDataNameFormat3()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6070)
			p.QualifiedDataNameFormat4()
		}

	}

	return localctx
}

// IQualifiedDataNameFormat1Context is an interface to support dynamic dispatch.
type IQualifiedDataNameFormat1Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQualifiedDataNameFormat1Context differentiates from other interfaces.
	IsQualifiedDataNameFormat1Context()
}

type QualifiedDataNameFormat1Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedDataNameFormat1Context() *QualifiedDataNameFormat1Context {
	var p = new(QualifiedDataNameFormat1Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_qualifiedDataNameFormat1
	return p
}

func (*QualifiedDataNameFormat1Context) IsQualifiedDataNameFormat1Context() {}

func NewQualifiedDataNameFormat1Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedDataNameFormat1Context {
	var p = new(QualifiedDataNameFormat1Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_qualifiedDataNameFormat1

	return p
}

func (s *QualifiedDataNameFormat1Context) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedDataNameFormat1Context) DataName() IDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *QualifiedDataNameFormat1Context) ConditionName() IConditionNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditionNameContext)
}

func (s *QualifiedDataNameFormat1Context) InFile() IInFileContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInFileContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInFileContext)
}

func (s *QualifiedDataNameFormat1Context) AllQualifiedInData() []IQualifiedInDataContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IQualifiedInDataContext)(nil)).Elem())
	var tst = make([]IQualifiedInDataContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IQualifiedInDataContext)
		}
	}

	return tst
}

func (s *QualifiedDataNameFormat1Context) QualifiedInData(i int) IQualifiedInDataContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedInDataContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IQualifiedInDataContext)
}

func (s *QualifiedDataNameFormat1Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedDataNameFormat1Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedDataNameFormat1Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterQualifiedDataNameFormat1(s)
	}
}

func (s *QualifiedDataNameFormat1Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitQualifiedDataNameFormat1(s)
	}
}

func (p *Cobol85Parser) QualifiedDataNameFormat1() (localctx IQualifiedDataNameFormat1Context) {
	localctx = NewQualifiedDataNameFormat1Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1092, Cobol85ParserRULE_qualifiedDataNameFormat1)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(6075)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 959, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(6073)
			p.DataName()
		}

	case 2:
		{
			p.SetState(6074)
			p.ConditionName()
		}

	}
	p.SetState(6086)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 962, p.GetParserRuleContext()) == 1 {
		p.SetState(6078)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(6077)
					p.QualifiedInData()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(6080)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 960, p.GetParserRuleContext())
		}
		p.SetState(6083)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 961, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6082)
				p.InFile()
			}

		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 962, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(6085)
			p.InFile()
		}

	}

	return localctx
}

// IQualifiedDataNameFormat2Context is an interface to support dynamic dispatch.
type IQualifiedDataNameFormat2Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQualifiedDataNameFormat2Context differentiates from other interfaces.
	IsQualifiedDataNameFormat2Context()
}

type QualifiedDataNameFormat2Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedDataNameFormat2Context() *QualifiedDataNameFormat2Context {
	var p = new(QualifiedDataNameFormat2Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_qualifiedDataNameFormat2
	return p
}

func (*QualifiedDataNameFormat2Context) IsQualifiedDataNameFormat2Context() {}

func NewQualifiedDataNameFormat2Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedDataNameFormat2Context {
	var p = new(QualifiedDataNameFormat2Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_qualifiedDataNameFormat2

	return p
}

func (s *QualifiedDataNameFormat2Context) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedDataNameFormat2Context) ParagraphName() IParagraphNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParagraphNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParagraphNameContext)
}

func (s *QualifiedDataNameFormat2Context) InSection() IInSectionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInSectionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInSectionContext)
}

func (s *QualifiedDataNameFormat2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedDataNameFormat2Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedDataNameFormat2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterQualifiedDataNameFormat2(s)
	}
}

func (s *QualifiedDataNameFormat2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitQualifiedDataNameFormat2(s)
	}
}

func (p *Cobol85Parser) QualifiedDataNameFormat2() (localctx IQualifiedDataNameFormat2Context) {
	localctx = NewQualifiedDataNameFormat2Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1094, Cobol85ParserRULE_qualifiedDataNameFormat2)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6088)
		p.ParagraphName()
	}
	{
		p.SetState(6089)
		p.InSection()
	}

	return localctx
}

// IQualifiedDataNameFormat3Context is an interface to support dynamic dispatch.
type IQualifiedDataNameFormat3Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQualifiedDataNameFormat3Context differentiates from other interfaces.
	IsQualifiedDataNameFormat3Context()
}

type QualifiedDataNameFormat3Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedDataNameFormat3Context() *QualifiedDataNameFormat3Context {
	var p = new(QualifiedDataNameFormat3Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_qualifiedDataNameFormat3
	return p
}

func (*QualifiedDataNameFormat3Context) IsQualifiedDataNameFormat3Context() {}

func NewQualifiedDataNameFormat3Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedDataNameFormat3Context {
	var p = new(QualifiedDataNameFormat3Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_qualifiedDataNameFormat3

	return p
}

func (s *QualifiedDataNameFormat3Context) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedDataNameFormat3Context) TextName() ITextNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITextNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITextNameContext)
}

func (s *QualifiedDataNameFormat3Context) InLibrary() IInLibraryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInLibraryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInLibraryContext)
}

func (s *QualifiedDataNameFormat3Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedDataNameFormat3Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedDataNameFormat3Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterQualifiedDataNameFormat3(s)
	}
}

func (s *QualifiedDataNameFormat3Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitQualifiedDataNameFormat3(s)
	}
}

func (p *Cobol85Parser) QualifiedDataNameFormat3() (localctx IQualifiedDataNameFormat3Context) {
	localctx = NewQualifiedDataNameFormat3Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1096, Cobol85ParserRULE_qualifiedDataNameFormat3)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6091)
		p.TextName()
	}
	{
		p.SetState(6092)
		p.InLibrary()
	}

	return localctx
}

// IQualifiedDataNameFormat4Context is an interface to support dynamic dispatch.
type IQualifiedDataNameFormat4Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQualifiedDataNameFormat4Context differentiates from other interfaces.
	IsQualifiedDataNameFormat4Context()
}

type QualifiedDataNameFormat4Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedDataNameFormat4Context() *QualifiedDataNameFormat4Context {
	var p = new(QualifiedDataNameFormat4Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_qualifiedDataNameFormat4
	return p
}

func (*QualifiedDataNameFormat4Context) IsQualifiedDataNameFormat4Context() {}

func NewQualifiedDataNameFormat4Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedDataNameFormat4Context {
	var p = new(QualifiedDataNameFormat4Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_qualifiedDataNameFormat4

	return p
}

func (s *QualifiedDataNameFormat4Context) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedDataNameFormat4Context) LINAGE_COUNTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLINAGE_COUNTER, 0)
}

func (s *QualifiedDataNameFormat4Context) InFile() IInFileContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInFileContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInFileContext)
}

func (s *QualifiedDataNameFormat4Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedDataNameFormat4Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedDataNameFormat4Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterQualifiedDataNameFormat4(s)
	}
}

func (s *QualifiedDataNameFormat4Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitQualifiedDataNameFormat4(s)
	}
}

func (p *Cobol85Parser) QualifiedDataNameFormat4() (localctx IQualifiedDataNameFormat4Context) {
	localctx = NewQualifiedDataNameFormat4Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1098, Cobol85ParserRULE_qualifiedDataNameFormat4)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6094)
		p.Match(Cobol85ParserLINAGE_COUNTER)
	}
	{
		p.SetState(6095)
		p.InFile()
	}

	return localctx
}

// IQualifiedInDataContext is an interface to support dynamic dispatch.
type IQualifiedInDataContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQualifiedInDataContext differentiates from other interfaces.
	IsQualifiedInDataContext()
}

type QualifiedInDataContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedInDataContext() *QualifiedInDataContext {
	var p = new(QualifiedInDataContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_qualifiedInData
	return p
}

func (*QualifiedInDataContext) IsQualifiedInDataContext() {}

func NewQualifiedInDataContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedInDataContext {
	var p = new(QualifiedInDataContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_qualifiedInData

	return p
}

func (s *QualifiedInDataContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedInDataContext) InData() IInDataContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInDataContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInDataContext)
}

func (s *QualifiedInDataContext) InTable() IInTableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInTableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInTableContext)
}

func (s *QualifiedInDataContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedInDataContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedInDataContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterQualifiedInData(s)
	}
}

func (s *QualifiedInDataContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitQualifiedInData(s)
	}
}

func (p *Cobol85Parser) QualifiedInData() (localctx IQualifiedInDataContext) {
	localctx = NewQualifiedInDataContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1100, Cobol85ParserRULE_qualifiedInData)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6099)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 963, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6097)
			p.InData()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6098)
			p.InTable()
		}

	}

	return localctx
}

// IInDataContext is an interface to support dynamic dispatch.
type IInDataContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInDataContext differentiates from other interfaces.
	IsInDataContext()
}

type InDataContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInDataContext() *InDataContext {
	var p = new(InDataContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_inData
	return p
}

func (*InDataContext) IsInDataContext() {}

func NewInDataContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InDataContext {
	var p = new(InDataContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_inData

	return p
}

func (s *InDataContext) GetParser() antlr.Parser { return s.parser }

func (s *InDataContext) DataName() IDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *InDataContext) IN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIN, 0)
}

func (s *InDataContext) OF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOF, 0)
}

func (s *InDataContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InDataContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InDataContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInData(s)
	}
}

func (s *InDataContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInData(s)
	}
}

func (p *Cobol85Parser) InData() (localctx IInDataContext) {
	localctx = NewInDataContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1102, Cobol85ParserRULE_inData)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6101)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserIN || _la == Cobol85ParserOF) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(6102)
		p.DataName()
	}

	return localctx
}

// IInFileContext is an interface to support dynamic dispatch.
type IInFileContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInFileContext differentiates from other interfaces.
	IsInFileContext()
}

type InFileContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInFileContext() *InFileContext {
	var p = new(InFileContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_inFile
	return p
}

func (*InFileContext) IsInFileContext() {}

func NewInFileContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InFileContext {
	var p = new(InFileContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_inFile

	return p
}

func (s *InFileContext) GetParser() antlr.Parser { return s.parser }

func (s *InFileContext) FileName() IFileNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *InFileContext) IN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIN, 0)
}

func (s *InFileContext) OF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOF, 0)
}

func (s *InFileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InFileContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InFileContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInFile(s)
	}
}

func (s *InFileContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInFile(s)
	}
}

func (p *Cobol85Parser) InFile() (localctx IInFileContext) {
	localctx = NewInFileContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1104, Cobol85ParserRULE_inFile)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6104)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserIN || _la == Cobol85ParserOF) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(6105)
		p.FileName()
	}

	return localctx
}

// IInMnemonicContext is an interface to support dynamic dispatch.
type IInMnemonicContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInMnemonicContext differentiates from other interfaces.
	IsInMnemonicContext()
}

type InMnemonicContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInMnemonicContext() *InMnemonicContext {
	var p = new(InMnemonicContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_inMnemonic
	return p
}

func (*InMnemonicContext) IsInMnemonicContext() {}

func NewInMnemonicContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InMnemonicContext {
	var p = new(InMnemonicContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_inMnemonic

	return p
}

func (s *InMnemonicContext) GetParser() antlr.Parser { return s.parser }

func (s *InMnemonicContext) MnemonicName() IMnemonicNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMnemonicNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMnemonicNameContext)
}

func (s *InMnemonicContext) IN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIN, 0)
}

func (s *InMnemonicContext) OF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOF, 0)
}

func (s *InMnemonicContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InMnemonicContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InMnemonicContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInMnemonic(s)
	}
}

func (s *InMnemonicContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInMnemonic(s)
	}
}

func (p *Cobol85Parser) InMnemonic() (localctx IInMnemonicContext) {
	localctx = NewInMnemonicContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1106, Cobol85ParserRULE_inMnemonic)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6107)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserIN || _la == Cobol85ParserOF) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(6108)
		p.MnemonicName()
	}

	return localctx
}

// IInSectionContext is an interface to support dynamic dispatch.
type IInSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInSectionContext differentiates from other interfaces.
	IsInSectionContext()
}

type InSectionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInSectionContext() *InSectionContext {
	var p = new(InSectionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_inSection
	return p
}

func (*InSectionContext) IsInSectionContext() {}

func NewInSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InSectionContext {
	var p = new(InSectionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_inSection

	return p
}

func (s *InSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *InSectionContext) SectionName() ISectionNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISectionNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISectionNameContext)
}

func (s *InSectionContext) IN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIN, 0)
}

func (s *InSectionContext) OF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOF, 0)
}

func (s *InSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInSection(s)
	}
}

func (s *InSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInSection(s)
	}
}

func (p *Cobol85Parser) InSection() (localctx IInSectionContext) {
	localctx = NewInSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1108, Cobol85ParserRULE_inSection)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6110)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserIN || _la == Cobol85ParserOF) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(6111)
		p.SectionName()
	}

	return localctx
}

// IInLibraryContext is an interface to support dynamic dispatch.
type IInLibraryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInLibraryContext differentiates from other interfaces.
	IsInLibraryContext()
}

type InLibraryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInLibraryContext() *InLibraryContext {
	var p = new(InLibraryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_inLibrary
	return p
}

func (*InLibraryContext) IsInLibraryContext() {}

func NewInLibraryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InLibraryContext {
	var p = new(InLibraryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_inLibrary

	return p
}

func (s *InLibraryContext) GetParser() antlr.Parser { return s.parser }

func (s *InLibraryContext) LibraryName() ILibraryNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILibraryNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILibraryNameContext)
}

func (s *InLibraryContext) IN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIN, 0)
}

func (s *InLibraryContext) OF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOF, 0)
}

func (s *InLibraryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InLibraryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InLibraryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInLibrary(s)
	}
}

func (s *InLibraryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInLibrary(s)
	}
}

func (p *Cobol85Parser) InLibrary() (localctx IInLibraryContext) {
	localctx = NewInLibraryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1110, Cobol85ParserRULE_inLibrary)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6113)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserIN || _la == Cobol85ParserOF) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(6114)
		p.LibraryName()
	}

	return localctx
}

// IInTableContext is an interface to support dynamic dispatch.
type IInTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInTableContext differentiates from other interfaces.
	IsInTableContext()
}

type InTableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInTableContext() *InTableContext {
	var p = new(InTableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_inTable
	return p
}

func (*InTableContext) IsInTableContext() {}

func NewInTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InTableContext {
	var p = new(InTableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_inTable

	return p
}

func (s *InTableContext) GetParser() antlr.Parser { return s.parser }

func (s *InTableContext) TableCall() ITableCallContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableCallContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableCallContext)
}

func (s *InTableContext) IN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIN, 0)
}

func (s *InTableContext) OF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOF, 0)
}

func (s *InTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInTable(s)
	}
}

func (s *InTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInTable(s)
	}
}

func (p *Cobol85Parser) InTable() (localctx IInTableContext) {
	localctx = NewInTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1112, Cobol85ParserRULE_inTable)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6116)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserIN || _la == Cobol85ParserOF) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(6117)
		p.TableCall()
	}

	return localctx
}

// IAlphabetNameContext is an interface to support dynamic dispatch.
type IAlphabetNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlphabetNameContext differentiates from other interfaces.
	IsAlphabetNameContext()
}

type AlphabetNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlphabetNameContext() *AlphabetNameContext {
	var p = new(AlphabetNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_alphabetName
	return p
}

func (*AlphabetNameContext) IsAlphabetNameContext() {}

func NewAlphabetNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlphabetNameContext {
	var p = new(AlphabetNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_alphabetName

	return p
}

func (s *AlphabetNameContext) GetParser() antlr.Parser { return s.parser }

func (s *AlphabetNameContext) CobolWord() ICobolWordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICobolWordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *AlphabetNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlphabetNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlphabetNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAlphabetName(s)
	}
}

func (s *AlphabetNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAlphabetName(s)
	}
}

func (p *Cobol85Parser) AlphabetName() (localctx IAlphabetNameContext) {
	localctx = NewAlphabetNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1114, Cobol85ParserRULE_alphabetName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6119)
		p.CobolWord()
	}

	return localctx
}

// IAssignmentNameContext is an interface to support dynamic dispatch.
type IAssignmentNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignmentNameContext differentiates from other interfaces.
	IsAssignmentNameContext()
}

type AssignmentNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentNameContext() *AssignmentNameContext {
	var p = new(AssignmentNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_assignmentName
	return p
}

func (*AssignmentNameContext) IsAssignmentNameContext() {}

func NewAssignmentNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentNameContext {
	var p = new(AssignmentNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_assignmentName

	return p
}

func (s *AssignmentNameContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentNameContext) SystemName() ISystemNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISystemNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISystemNameContext)
}

func (s *AssignmentNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAssignmentName(s)
	}
}

func (s *AssignmentNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAssignmentName(s)
	}
}

func (p *Cobol85Parser) AssignmentName() (localctx IAssignmentNameContext) {
	localctx = NewAssignmentNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1116, Cobol85ParserRULE_assignmentName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6121)
		p.SystemName()
	}

	return localctx
}

// IBasisNameContext is an interface to support dynamic dispatch.
type IBasisNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBasisNameContext differentiates from other interfaces.
	IsBasisNameContext()
}

type BasisNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBasisNameContext() *BasisNameContext {
	var p = new(BasisNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_basisName
	return p
}

func (*BasisNameContext) IsBasisNameContext() {}

func NewBasisNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BasisNameContext {
	var p = new(BasisNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_basisName

	return p
}

func (s *BasisNameContext) GetParser() antlr.Parser { return s.parser }

func (s *BasisNameContext) ProgramName() IProgramNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProgramNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProgramNameContext)
}

func (s *BasisNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BasisNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BasisNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterBasisName(s)
	}
}

func (s *BasisNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitBasisName(s)
	}
}

func (p *Cobol85Parser) BasisName() (localctx IBasisNameContext) {
	localctx = NewBasisNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1118, Cobol85ParserRULE_basisName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6123)
		p.ProgramName()
	}

	return localctx
}

// ICdNameContext is an interface to support dynamic dispatch.
type ICdNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCdNameContext differentiates from other interfaces.
	IsCdNameContext()
}

type CdNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCdNameContext() *CdNameContext {
	var p = new(CdNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_cdName
	return p
}

func (*CdNameContext) IsCdNameContext() {}

func NewCdNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CdNameContext {
	var p = new(CdNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_cdName

	return p
}

func (s *CdNameContext) GetParser() antlr.Parser { return s.parser }

func (s *CdNameContext) CobolWord() ICobolWordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICobolWordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *CdNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CdNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CdNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCdName(s)
	}
}

func (s *CdNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCdName(s)
	}
}

func (p *Cobol85Parser) CdName() (localctx ICdNameContext) {
	localctx = NewCdNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1120, Cobol85ParserRULE_cdName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6125)
		p.CobolWord()
	}

	return localctx
}

// IClassNameContext is an interface to support dynamic dispatch.
type IClassNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassNameContext differentiates from other interfaces.
	IsClassNameContext()
}

type ClassNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassNameContext() *ClassNameContext {
	var p = new(ClassNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_className
	return p
}

func (*ClassNameContext) IsClassNameContext() {}

func NewClassNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassNameContext {
	var p = new(ClassNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_className

	return p
}

func (s *ClassNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassNameContext) CobolWord() ICobolWordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICobolWordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *ClassNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterClassName(s)
	}
}

func (s *ClassNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitClassName(s)
	}
}

func (p *Cobol85Parser) ClassName() (localctx IClassNameContext) {
	localctx = NewClassNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1122, Cobol85ParserRULE_className)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6127)
		p.CobolWord()
	}

	return localctx
}

// IComputerNameContext is an interface to support dynamic dispatch.
type IComputerNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComputerNameContext differentiates from other interfaces.
	IsComputerNameContext()
}

type ComputerNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComputerNameContext() *ComputerNameContext {
	var p = new(ComputerNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_computerName
	return p
}

func (*ComputerNameContext) IsComputerNameContext() {}

func NewComputerNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComputerNameContext {
	var p = new(ComputerNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_computerName

	return p
}

func (s *ComputerNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ComputerNameContext) SystemName() ISystemNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISystemNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISystemNameContext)
}

func (s *ComputerNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComputerNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComputerNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterComputerName(s)
	}
}

func (s *ComputerNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitComputerName(s)
	}
}

func (p *Cobol85Parser) ComputerName() (localctx IComputerNameContext) {
	localctx = NewComputerNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1124, Cobol85ParserRULE_computerName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6129)
		p.SystemName()
	}

	return localctx
}

// IConditionNameContext is an interface to support dynamic dispatch.
type IConditionNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConditionNameContext differentiates from other interfaces.
	IsConditionNameContext()
}

type ConditionNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditionNameContext() *ConditionNameContext {
	var p = new(ConditionNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_conditionName
	return p
}

func (*ConditionNameContext) IsConditionNameContext() {}

func NewConditionNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConditionNameContext {
	var p = new(ConditionNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_conditionName

	return p
}

func (s *ConditionNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ConditionNameContext) CobolWord() ICobolWordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICobolWordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *ConditionNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConditionNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConditionNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterConditionName(s)
	}
}

func (s *ConditionNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitConditionName(s)
	}
}

func (p *Cobol85Parser) ConditionName() (localctx IConditionNameContext) {
	localctx = NewConditionNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1126, Cobol85ParserRULE_conditionName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6131)
		p.CobolWord()
	}

	return localctx
}

// IDataNameContext is an interface to support dynamic dispatch.
type IDataNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataNameContext differentiates from other interfaces.
	IsDataNameContext()
}

type DataNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataNameContext() *DataNameContext {
	var p = new(DataNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataName
	return p
}

func (*DataNameContext) IsDataNameContext() {}

func NewDataNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataNameContext {
	var p = new(DataNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataName

	return p
}

func (s *DataNameContext) GetParser() antlr.Parser { return s.parser }

func (s *DataNameContext) CobolWord() ICobolWordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICobolWordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *DataNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataName(s)
	}
}

func (s *DataNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataName(s)
	}
}

func (p *Cobol85Parser) DataName() (localctx IDataNameContext) {
	localctx = NewDataNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1128, Cobol85ParserRULE_dataName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6133)
		p.CobolWord()
	}

	return localctx
}

// IDataDescNameContext is an interface to support dynamic dispatch.
type IDataDescNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataDescNameContext differentiates from other interfaces.
	IsDataDescNameContext()
}

type DataDescNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataDescNameContext() *DataDescNameContext {
	var p = new(DataDescNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataDescName
	return p
}

func (*DataDescNameContext) IsDataDescNameContext() {}

func NewDataDescNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataDescNameContext {
	var p = new(DataDescNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataDescName

	return p
}

func (s *DataDescNameContext) GetParser() antlr.Parser { return s.parser }

func (s *DataDescNameContext) FILLER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFILLER, 0)
}

func (s *DataDescNameContext) CURSOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCURSOR, 0)
}

func (s *DataDescNameContext) DataName() IDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *DataDescNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataDescNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataDescNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataDescName(s)
	}
}

func (s *DataDescNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataDescName(s)
	}
}

func (p *Cobol85Parser) DataDescName() (localctx IDataDescNameContext) {
	localctx = NewDataDescNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1130, Cobol85ParserRULE_dataDescName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6138)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 964, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6135)
			p.Match(Cobol85ParserFILLER)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6136)
			p.Match(Cobol85ParserCURSOR)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6137)
			p.DataName()
		}

	}

	return localctx
}

// IEnvironmentNameContext is an interface to support dynamic dispatch.
type IEnvironmentNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnvironmentNameContext differentiates from other interfaces.
	IsEnvironmentNameContext()
}

type EnvironmentNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnvironmentNameContext() *EnvironmentNameContext {
	var p = new(EnvironmentNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_environmentName
	return p
}

func (*EnvironmentNameContext) IsEnvironmentNameContext() {}

func NewEnvironmentNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnvironmentNameContext {
	var p = new(EnvironmentNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_environmentName

	return p
}

func (s *EnvironmentNameContext) GetParser() antlr.Parser { return s.parser }

func (s *EnvironmentNameContext) SystemName() ISystemNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISystemNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISystemNameContext)
}

func (s *EnvironmentNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnvironmentNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnvironmentNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterEnvironmentName(s)
	}
}

func (s *EnvironmentNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitEnvironmentName(s)
	}
}

func (p *Cobol85Parser) EnvironmentName() (localctx IEnvironmentNameContext) {
	localctx = NewEnvironmentNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1132, Cobol85ParserRULE_environmentName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6140)
		p.SystemName()
	}

	return localctx
}

// IFileNameContext is an interface to support dynamic dispatch.
type IFileNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFileNameContext differentiates from other interfaces.
	IsFileNameContext()
}

type FileNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFileNameContext() *FileNameContext {
	var p = new(FileNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_fileName
	return p
}

func (*FileNameContext) IsFileNameContext() {}

func NewFileNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FileNameContext {
	var p = new(FileNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_fileName

	return p
}

func (s *FileNameContext) GetParser() antlr.Parser { return s.parser }

func (s *FileNameContext) CobolWord() ICobolWordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICobolWordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *FileNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FileNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FileNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterFileName(s)
	}
}

func (s *FileNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitFileName(s)
	}
}

func (p *Cobol85Parser) FileName() (localctx IFileNameContext) {
	localctx = NewFileNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1134, Cobol85ParserRULE_fileName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6142)
		p.CobolWord()
	}

	return localctx
}

// IFunctionNameContext is an interface to support dynamic dispatch.
type IFunctionNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionNameContext differentiates from other interfaces.
	IsFunctionNameContext()
}

type FunctionNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionNameContext() *FunctionNameContext {
	var p = new(FunctionNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_functionName
	return p
}

func (*FunctionNameContext) IsFunctionNameContext() {}

func NewFunctionNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionNameContext {
	var p = new(FunctionNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_functionName

	return p
}

func (s *FunctionNameContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionNameContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINTEGER, 0)
}

func (s *FunctionNameContext) LENGTH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLENGTH, 0)
}

func (s *FunctionNameContext) RANDOM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRANDOM, 0)
}

func (s *FunctionNameContext) SUM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSUM, 0)
}

func (s *FunctionNameContext) WHEN_COMPILED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWHEN_COMPILED, 0)
}

func (s *FunctionNameContext) CobolWord() ICobolWordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICobolWordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *FunctionNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterFunctionName(s)
	}
}

func (s *FunctionNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitFunctionName(s)
	}
}

func (p *Cobol85Parser) FunctionName() (localctx IFunctionNameContext) {
	localctx = NewFunctionNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1136, Cobol85ParserRULE_functionName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6150)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 965, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6144)
			p.Match(Cobol85ParserINTEGER)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6145)
			p.Match(Cobol85ParserLENGTH)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6146)
			p.Match(Cobol85ParserRANDOM)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6147)
			p.Match(Cobol85ParserSUM)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6148)
			p.Match(Cobol85ParserWHEN_COMPILED)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(6149)
			p.CobolWord()
		}

	}

	return localctx
}

// IIndexNameContext is an interface to support dynamic dispatch.
type IIndexNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIndexNameContext differentiates from other interfaces.
	IsIndexNameContext()
}

type IndexNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexNameContext() *IndexNameContext {
	var p = new(IndexNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_indexName
	return p
}

func (*IndexNameContext) IsIndexNameContext() {}

func NewIndexNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexNameContext {
	var p = new(IndexNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_indexName

	return p
}

func (s *IndexNameContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexNameContext) CobolWord() ICobolWordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICobolWordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *IndexNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterIndexName(s)
	}
}

func (s *IndexNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitIndexName(s)
	}
}

func (p *Cobol85Parser) IndexName() (localctx IIndexNameContext) {
	localctx = NewIndexNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1138, Cobol85ParserRULE_indexName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6152)
		p.CobolWord()
	}

	return localctx
}

// ILanguageNameContext is an interface to support dynamic dispatch.
type ILanguageNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLanguageNameContext differentiates from other interfaces.
	IsLanguageNameContext()
}

type LanguageNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLanguageNameContext() *LanguageNameContext {
	var p = new(LanguageNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_languageName
	return p
}

func (*LanguageNameContext) IsLanguageNameContext() {}

func NewLanguageNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LanguageNameContext {
	var p = new(LanguageNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_languageName

	return p
}

func (s *LanguageNameContext) GetParser() antlr.Parser { return s.parser }

func (s *LanguageNameContext) SystemName() ISystemNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISystemNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISystemNameContext)
}

func (s *LanguageNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LanguageNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LanguageNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLanguageName(s)
	}
}

func (s *LanguageNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLanguageName(s)
	}
}

func (p *Cobol85Parser) LanguageName() (localctx ILanguageNameContext) {
	localctx = NewLanguageNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1140, Cobol85ParserRULE_languageName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6154)
		p.SystemName()
	}

	return localctx
}

// ILibraryNameContext is an interface to support dynamic dispatch.
type ILibraryNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibraryNameContext differentiates from other interfaces.
	IsLibraryNameContext()
}

type LibraryNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibraryNameContext() *LibraryNameContext {
	var p = new(LibraryNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_libraryName
	return p
}

func (*LibraryNameContext) IsLibraryNameContext() {}

func NewLibraryNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LibraryNameContext {
	var p = new(LibraryNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_libraryName

	return p
}

func (s *LibraryNameContext) GetParser() antlr.Parser { return s.parser }

func (s *LibraryNameContext) CobolWord() ICobolWordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICobolWordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *LibraryNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LibraryNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LibraryNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLibraryName(s)
	}
}

func (s *LibraryNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLibraryName(s)
	}
}

func (p *Cobol85Parser) LibraryName() (localctx ILibraryNameContext) {
	localctx = NewLibraryNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1142, Cobol85ParserRULE_libraryName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6156)
		p.CobolWord()
	}

	return localctx
}

// ILocalNameContext is an interface to support dynamic dispatch.
type ILocalNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLocalNameContext differentiates from other interfaces.
	IsLocalNameContext()
}

type LocalNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLocalNameContext() *LocalNameContext {
	var p = new(LocalNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_localName
	return p
}

func (*LocalNameContext) IsLocalNameContext() {}

func NewLocalNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LocalNameContext {
	var p = new(LocalNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_localName

	return p
}

func (s *LocalNameContext) GetParser() antlr.Parser { return s.parser }

func (s *LocalNameContext) CobolWord() ICobolWordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICobolWordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *LocalNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LocalNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LocalNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLocalName(s)
	}
}

func (s *LocalNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLocalName(s)
	}
}

func (p *Cobol85Parser) LocalName() (localctx ILocalNameContext) {
	localctx = NewLocalNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1144, Cobol85ParserRULE_localName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6158)
		p.CobolWord()
	}

	return localctx
}

// IMnemonicNameContext is an interface to support dynamic dispatch.
type IMnemonicNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMnemonicNameContext differentiates from other interfaces.
	IsMnemonicNameContext()
}

type MnemonicNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMnemonicNameContext() *MnemonicNameContext {
	var p = new(MnemonicNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_mnemonicName
	return p
}

func (*MnemonicNameContext) IsMnemonicNameContext() {}

func NewMnemonicNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MnemonicNameContext {
	var p = new(MnemonicNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_mnemonicName

	return p
}

func (s *MnemonicNameContext) GetParser() antlr.Parser { return s.parser }

func (s *MnemonicNameContext) CobolWord() ICobolWordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICobolWordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *MnemonicNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MnemonicNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MnemonicNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMnemonicName(s)
	}
}

func (s *MnemonicNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMnemonicName(s)
	}
}

func (p *Cobol85Parser) MnemonicName() (localctx IMnemonicNameContext) {
	localctx = NewMnemonicNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1146, Cobol85ParserRULE_mnemonicName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6160)
		p.CobolWord()
	}

	return localctx
}

// IParagraphNameContext is an interface to support dynamic dispatch.
type IParagraphNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParagraphNameContext differentiates from other interfaces.
	IsParagraphNameContext()
}

type ParagraphNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParagraphNameContext() *ParagraphNameContext {
	var p = new(ParagraphNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_paragraphName
	return p
}

func (*ParagraphNameContext) IsParagraphNameContext() {}

func NewParagraphNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParagraphNameContext {
	var p = new(ParagraphNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_paragraphName

	return p
}

func (s *ParagraphNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ParagraphNameContext) CobolWord() ICobolWordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICobolWordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *ParagraphNameContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ParagraphNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParagraphNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParagraphNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterParagraphName(s)
	}
}

func (s *ParagraphNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitParagraphName(s)
	}
}

func (p *Cobol85Parser) ParagraphName() (localctx IParagraphNameContext) {
	localctx = NewParagraphNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1148, Cobol85ParserRULE_paragraphName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6164)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserABORT, Cobol85ParserAS, Cobol85ParserASCII, Cobol85ParserASSOCIATED_DATA, Cobol85ParserASSOCIATED_DATA_LENGTH, Cobol85ParserATTRIBUTE, Cobol85ParserAUTO, Cobol85ParserAUTO_SKIP, Cobol85ParserBACKGROUND_COLOR, Cobol85ParserBACKGROUND_COLOUR, Cobol85ParserBEEP, Cobol85ParserBELL, Cobol85ParserBINARY, Cobol85ParserBIT, Cobol85ParserBLINK, Cobol85ParserBOUNDS, Cobol85ParserCAPABLE, Cobol85ParserCCSVERSION, Cobol85ParserCHANGED, Cobol85ParserCHANNEL, Cobol85ParserCLOSE_DISPOSITION, Cobol85ParserCOBOL, Cobol85ParserCOMMITMENT, Cobol85ParserCONTROL_POINT, Cobol85ParserCONVENTION, Cobol85ParserCRUNCH, Cobol85ParserCURSOR, Cobol85ParserDEFAULT, Cobol85ParserDEFAULT_DISPLAY, Cobol85ParserDEFINITION, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserDISK, Cobol85ParserDONTCARE, Cobol85ParserDOUBLE, Cobol85ParserEBCDIC, Cobol85ParserEMPTY_CHECK, Cobol85ParserENTER, Cobol85ParserENTRY_PROCEDURE, Cobol85ParserERASE, Cobol85ParserEOL, Cobol85ParserEOS, Cobol85ParserESCAPE, Cobol85ParserEVENT, Cobol85ParserEXCLUSIVE, Cobol85ParserEXPORT, Cobol85ParserEXTENDED, Cobol85ParserFOREGROUND_COLOR, Cobol85ParserFOREGROUND_COLOUR, Cobol85ParserFULL, Cobol85ParserFUNCTIONNAME, Cobol85ParserFUNCTION_POINTER, Cobol85ParserGRID, Cobol85ParserHIGHLIGHT, Cobol85ParserIMPLICIT, Cobol85ParserIMPORT, Cobol85ParserINTEGER, Cobol85ParserKEPT, Cobol85ParserKEYBOARD, Cobol85ParserLANGUAGE, Cobol85ParserLB, Cobol85ParserLD, Cobol85ParserLEFTLINE, Cobol85ParserLENGTH_CHECK, Cobol85ParserLIBACCESS, Cobol85ParserLIBPARAMETER, Cobol85ParserLIBRARY, Cobol85ParserLIST, Cobol85ParserLOCAL, Cobol85ParserLONG_DATE, Cobol85ParserLONG_TIME, Cobol85ParserLOWER, Cobol85ParserLOWLIGHT, Cobol85ParserMMDDYYYY, Cobol85ParserNAMED, Cobol85ParserNATIONAL, Cobol85ParserNATIONAL_EDITED, Cobol85ParserNETWORK, Cobol85ParserNO_ECHO, Cobol85ParserNUMERIC_DATE, Cobol85ParserNUMERIC_TIME, Cobol85ParserODT, Cobol85ParserORDERLY, Cobol85ParserOVERLINE, Cobol85ParserOWN, Cobol85ParserPASSWORD, Cobol85ParserPORT, Cobol85ParserPRINTER, Cobol85ParserPRIVATE, Cobol85ParserPROCESS, Cobol85ParserPROGRAM, Cobol85ParserPROMPT, Cobol85ParserREADER, Cobol85ParserREMOTE, Cobol85ParserREAL, Cobol85ParserRECEIVED, Cobol85ParserRECURSIVE, Cobol85ParserREF, Cobol85ParserREMOVE, Cobol85ParserREQUIRED, Cobol85ParserREVERSE_VIDEO, Cobol85ParserSAVE, Cobol85ParserSECURE, Cobol85ParserSHARED, Cobol85ParserSHAREDBYALL, Cobol85ParserSHAREDBYRUNUNIT, Cobol85ParserSHARING, Cobol85ParserSHORT_DATE, Cobol85ParserSYMBOL, Cobol85ParserTASK, Cobol85ParserTHREAD, Cobol85ParserTHREAD_LOCAL, Cobol85ParserTIMER, Cobol85ParserTODAYS_DATE, Cobol85ParserTODAYS_NAME, Cobol85ParserTRUNCATED, Cobol85ParserTYPEDEF, Cobol85ParserUNDERLINE, Cobol85ParserVIRTUAL, Cobol85ParserWAIT, Cobol85ParserYEAR, Cobol85ParserYYYYMMDD, Cobol85ParserYYYYDDD, Cobol85ParserZERO_FILL, Cobol85ParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6162)
			p.CobolWord()
		}

	case Cobol85ParserLEVEL_NUMBER_66, Cobol85ParserLEVEL_NUMBER_77, Cobol85ParserLEVEL_NUMBER_88, Cobol85ParserINTEGERLITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6163)
			p.IntegerLiteral()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IProcedureNameContext is an interface to support dynamic dispatch.
type IProcedureNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedureNameContext differentiates from other interfaces.
	IsProcedureNameContext()
}

type ProcedureNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureNameContext() *ProcedureNameContext {
	var p = new(ProcedureNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_procedureName
	return p
}

func (*ProcedureNameContext) IsProcedureNameContext() {}

func NewProcedureNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureNameContext {
	var p = new(ProcedureNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_procedureName

	return p
}

func (s *ProcedureNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureNameContext) ParagraphName() IParagraphNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParagraphNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParagraphNameContext)
}

func (s *ProcedureNameContext) InSection() IInSectionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInSectionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInSectionContext)
}

func (s *ProcedureNameContext) SectionName() ISectionNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISectionNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISectionNameContext)
}

func (s *ProcedureNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterProcedureName(s)
	}
}

func (s *ProcedureNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitProcedureName(s)
	}
}

func (p *Cobol85Parser) ProcedureName() (localctx IProcedureNameContext) {
	localctx = NewProcedureNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1150, Cobol85ParserRULE_procedureName)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6171)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 968, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6166)
			p.ParagraphName()
		}
		p.SetState(6168)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserIN || _la == Cobol85ParserOF {
			{
				p.SetState(6167)
				p.InSection()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6170)
			p.SectionName()
		}

	}

	return localctx
}

// IProgramNameContext is an interface to support dynamic dispatch.
type IProgramNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProgramNameContext differentiates from other interfaces.
	IsProgramNameContext()
}

type ProgramNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProgramNameContext() *ProgramNameContext {
	var p = new(ProgramNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_programName
	return p
}

func (*ProgramNameContext) IsProgramNameContext() {}

func NewProgramNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProgramNameContext {
	var p = new(ProgramNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_programName

	return p
}

func (s *ProgramNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ProgramNameContext) NONNUMERICLITERAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNONNUMERICLITERAL, 0)
}

func (s *ProgramNameContext) CobolWord() ICobolWordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICobolWordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *ProgramNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProgramNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProgramNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterProgramName(s)
	}
}

func (s *ProgramNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitProgramName(s)
	}
}

func (p *Cobol85Parser) ProgramName() (localctx IProgramNameContext) {
	localctx = NewProgramNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1152, Cobol85ParserRULE_programName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6175)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserNONNUMERICLITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6173)
			p.Match(Cobol85ParserNONNUMERICLITERAL)
		}

	case Cobol85ParserABORT, Cobol85ParserAS, Cobol85ParserASCII, Cobol85ParserASSOCIATED_DATA, Cobol85ParserASSOCIATED_DATA_LENGTH, Cobol85ParserATTRIBUTE, Cobol85ParserAUTO, Cobol85ParserAUTO_SKIP, Cobol85ParserBACKGROUND_COLOR, Cobol85ParserBACKGROUND_COLOUR, Cobol85ParserBEEP, Cobol85ParserBELL, Cobol85ParserBINARY, Cobol85ParserBIT, Cobol85ParserBLINK, Cobol85ParserBOUNDS, Cobol85ParserCAPABLE, Cobol85ParserCCSVERSION, Cobol85ParserCHANGED, Cobol85ParserCHANNEL, Cobol85ParserCLOSE_DISPOSITION, Cobol85ParserCOBOL, Cobol85ParserCOMMITMENT, Cobol85ParserCONTROL_POINT, Cobol85ParserCONVENTION, Cobol85ParserCRUNCH, Cobol85ParserCURSOR, Cobol85ParserDEFAULT, Cobol85ParserDEFAULT_DISPLAY, Cobol85ParserDEFINITION, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserDISK, Cobol85ParserDONTCARE, Cobol85ParserDOUBLE, Cobol85ParserEBCDIC, Cobol85ParserEMPTY_CHECK, Cobol85ParserENTER, Cobol85ParserENTRY_PROCEDURE, Cobol85ParserERASE, Cobol85ParserEOL, Cobol85ParserEOS, Cobol85ParserESCAPE, Cobol85ParserEVENT, Cobol85ParserEXCLUSIVE, Cobol85ParserEXPORT, Cobol85ParserEXTENDED, Cobol85ParserFOREGROUND_COLOR, Cobol85ParserFOREGROUND_COLOUR, Cobol85ParserFULL, Cobol85ParserFUNCTIONNAME, Cobol85ParserFUNCTION_POINTER, Cobol85ParserGRID, Cobol85ParserHIGHLIGHT, Cobol85ParserIMPLICIT, Cobol85ParserIMPORT, Cobol85ParserINTEGER, Cobol85ParserKEPT, Cobol85ParserKEYBOARD, Cobol85ParserLANGUAGE, Cobol85ParserLB, Cobol85ParserLD, Cobol85ParserLEFTLINE, Cobol85ParserLENGTH_CHECK, Cobol85ParserLIBACCESS, Cobol85ParserLIBPARAMETER, Cobol85ParserLIBRARY, Cobol85ParserLIST, Cobol85ParserLOCAL, Cobol85ParserLONG_DATE, Cobol85ParserLONG_TIME, Cobol85ParserLOWER, Cobol85ParserLOWLIGHT, Cobol85ParserMMDDYYYY, Cobol85ParserNAMED, Cobol85ParserNATIONAL, Cobol85ParserNATIONAL_EDITED, Cobol85ParserNETWORK, Cobol85ParserNO_ECHO, Cobol85ParserNUMERIC_DATE, Cobol85ParserNUMERIC_TIME, Cobol85ParserODT, Cobol85ParserORDERLY, Cobol85ParserOVERLINE, Cobol85ParserOWN, Cobol85ParserPASSWORD, Cobol85ParserPORT, Cobol85ParserPRINTER, Cobol85ParserPRIVATE, Cobol85ParserPROCESS, Cobol85ParserPROGRAM, Cobol85ParserPROMPT, Cobol85ParserREADER, Cobol85ParserREMOTE, Cobol85ParserREAL, Cobol85ParserRECEIVED, Cobol85ParserRECURSIVE, Cobol85ParserREF, Cobol85ParserREMOVE, Cobol85ParserREQUIRED, Cobol85ParserREVERSE_VIDEO, Cobol85ParserSAVE, Cobol85ParserSECURE, Cobol85ParserSHARED, Cobol85ParserSHAREDBYALL, Cobol85ParserSHAREDBYRUNUNIT, Cobol85ParserSHARING, Cobol85ParserSHORT_DATE, Cobol85ParserSYMBOL, Cobol85ParserTASK, Cobol85ParserTHREAD, Cobol85ParserTHREAD_LOCAL, Cobol85ParserTIMER, Cobol85ParserTODAYS_DATE, Cobol85ParserTODAYS_NAME, Cobol85ParserTRUNCATED, Cobol85ParserTYPEDEF, Cobol85ParserUNDERLINE, Cobol85ParserVIRTUAL, Cobol85ParserWAIT, Cobol85ParserYEAR, Cobol85ParserYYYYMMDD, Cobol85ParserYYYYDDD, Cobol85ParserZERO_FILL, Cobol85ParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6174)
			p.CobolWord()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IRecordNameContext is an interface to support dynamic dispatch.
type IRecordNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRecordNameContext differentiates from other interfaces.
	IsRecordNameContext()
}

type RecordNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordNameContext() *RecordNameContext {
	var p = new(RecordNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_recordName
	return p
}

func (*RecordNameContext) IsRecordNameContext() {}

func NewRecordNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordNameContext {
	var p = new(RecordNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_recordName

	return p
}

func (s *RecordNameContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordNameContext) QualifiedDataName() IQualifiedDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *RecordNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterRecordName(s)
	}
}

func (s *RecordNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitRecordName(s)
	}
}

func (p *Cobol85Parser) RecordName() (localctx IRecordNameContext) {
	localctx = NewRecordNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1154, Cobol85ParserRULE_recordName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6177)
		p.QualifiedDataName()
	}

	return localctx
}

// IReportNameContext is an interface to support dynamic dispatch.
type IReportNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportNameContext differentiates from other interfaces.
	IsReportNameContext()
}

type ReportNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportNameContext() *ReportNameContext {
	var p = new(ReportNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportName
	return p
}

func (*ReportNameContext) IsReportNameContext() {}

func NewReportNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportNameContext {
	var p = new(ReportNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportName

	return p
}

func (s *ReportNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportNameContext) QualifiedDataName() IQualifiedDataNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedDataNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *ReportNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportName(s)
	}
}

func (s *ReportNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportName(s)
	}
}

func (p *Cobol85Parser) ReportName() (localctx IReportNameContext) {
	localctx = NewReportNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1156, Cobol85ParserRULE_reportName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6179)
		p.QualifiedDataName()
	}

	return localctx
}

// IRoutineNameContext is an interface to support dynamic dispatch.
type IRoutineNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRoutineNameContext differentiates from other interfaces.
	IsRoutineNameContext()
}

type RoutineNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRoutineNameContext() *RoutineNameContext {
	var p = new(RoutineNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_routineName
	return p
}

func (*RoutineNameContext) IsRoutineNameContext() {}

func NewRoutineNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RoutineNameContext {
	var p = new(RoutineNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_routineName

	return p
}

func (s *RoutineNameContext) GetParser() antlr.Parser { return s.parser }

func (s *RoutineNameContext) CobolWord() ICobolWordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICobolWordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *RoutineNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoutineNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RoutineNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterRoutineName(s)
	}
}

func (s *RoutineNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitRoutineName(s)
	}
}

func (p *Cobol85Parser) RoutineName() (localctx IRoutineNameContext) {
	localctx = NewRoutineNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1158, Cobol85ParserRULE_routineName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6181)
		p.CobolWord()
	}

	return localctx
}

// IScreenNameContext is an interface to support dynamic dispatch.
type IScreenNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenNameContext differentiates from other interfaces.
	IsScreenNameContext()
}

type ScreenNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenNameContext() *ScreenNameContext {
	var p = new(ScreenNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenName
	return p
}

func (*ScreenNameContext) IsScreenNameContext() {}

func NewScreenNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenNameContext {
	var p = new(ScreenNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenName

	return p
}

func (s *ScreenNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenNameContext) CobolWord() ICobolWordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICobolWordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *ScreenNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenName(s)
	}
}

func (s *ScreenNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenName(s)
	}
}

func (p *Cobol85Parser) ScreenName() (localctx IScreenNameContext) {
	localctx = NewScreenNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1160, Cobol85ParserRULE_screenName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6183)
		p.CobolWord()
	}

	return localctx
}

// ISectionNameContext is an interface to support dynamic dispatch.
type ISectionNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSectionNameContext differentiates from other interfaces.
	IsSectionNameContext()
}

type SectionNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySectionNameContext() *SectionNameContext {
	var p = new(SectionNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sectionName
	return p
}

func (*SectionNameContext) IsSectionNameContext() {}

func NewSectionNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SectionNameContext {
	var p = new(SectionNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sectionName

	return p
}

func (s *SectionNameContext) GetParser() antlr.Parser { return s.parser }

func (s *SectionNameContext) CobolWord() ICobolWordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICobolWordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *SectionNameContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *SectionNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SectionNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SectionNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSectionName(s)
	}
}

func (s *SectionNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSectionName(s)
	}
}

func (p *Cobol85Parser) SectionName() (localctx ISectionNameContext) {
	localctx = NewSectionNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1162, Cobol85ParserRULE_sectionName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6187)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserABORT, Cobol85ParserAS, Cobol85ParserASCII, Cobol85ParserASSOCIATED_DATA, Cobol85ParserASSOCIATED_DATA_LENGTH, Cobol85ParserATTRIBUTE, Cobol85ParserAUTO, Cobol85ParserAUTO_SKIP, Cobol85ParserBACKGROUND_COLOR, Cobol85ParserBACKGROUND_COLOUR, Cobol85ParserBEEP, Cobol85ParserBELL, Cobol85ParserBINARY, Cobol85ParserBIT, Cobol85ParserBLINK, Cobol85ParserBOUNDS, Cobol85ParserCAPABLE, Cobol85ParserCCSVERSION, Cobol85ParserCHANGED, Cobol85ParserCHANNEL, Cobol85ParserCLOSE_DISPOSITION, Cobol85ParserCOBOL, Cobol85ParserCOMMITMENT, Cobol85ParserCONTROL_POINT, Cobol85ParserCONVENTION, Cobol85ParserCRUNCH, Cobol85ParserCURSOR, Cobol85ParserDEFAULT, Cobol85ParserDEFAULT_DISPLAY, Cobol85ParserDEFINITION, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserDISK, Cobol85ParserDONTCARE, Cobol85ParserDOUBLE, Cobol85ParserEBCDIC, Cobol85ParserEMPTY_CHECK, Cobol85ParserENTER, Cobol85ParserENTRY_PROCEDURE, Cobol85ParserERASE, Cobol85ParserEOL, Cobol85ParserEOS, Cobol85ParserESCAPE, Cobol85ParserEVENT, Cobol85ParserEXCLUSIVE, Cobol85ParserEXPORT, Cobol85ParserEXTENDED, Cobol85ParserFOREGROUND_COLOR, Cobol85ParserFOREGROUND_COLOUR, Cobol85ParserFULL, Cobol85ParserFUNCTIONNAME, Cobol85ParserFUNCTION_POINTER, Cobol85ParserGRID, Cobol85ParserHIGHLIGHT, Cobol85ParserIMPLICIT, Cobol85ParserIMPORT, Cobol85ParserINTEGER, Cobol85ParserKEPT, Cobol85ParserKEYBOARD, Cobol85ParserLANGUAGE, Cobol85ParserLB, Cobol85ParserLD, Cobol85ParserLEFTLINE, Cobol85ParserLENGTH_CHECK, Cobol85ParserLIBACCESS, Cobol85ParserLIBPARAMETER, Cobol85ParserLIBRARY, Cobol85ParserLIST, Cobol85ParserLOCAL, Cobol85ParserLONG_DATE, Cobol85ParserLONG_TIME, Cobol85ParserLOWER, Cobol85ParserLOWLIGHT, Cobol85ParserMMDDYYYY, Cobol85ParserNAMED, Cobol85ParserNATIONAL, Cobol85ParserNATIONAL_EDITED, Cobol85ParserNETWORK, Cobol85ParserNO_ECHO, Cobol85ParserNUMERIC_DATE, Cobol85ParserNUMERIC_TIME, Cobol85ParserODT, Cobol85ParserORDERLY, Cobol85ParserOVERLINE, Cobol85ParserOWN, Cobol85ParserPASSWORD, Cobol85ParserPORT, Cobol85ParserPRINTER, Cobol85ParserPRIVATE, Cobol85ParserPROCESS, Cobol85ParserPROGRAM, Cobol85ParserPROMPT, Cobol85ParserREADER, Cobol85ParserREMOTE, Cobol85ParserREAL, Cobol85ParserRECEIVED, Cobol85ParserRECURSIVE, Cobol85ParserREF, Cobol85ParserREMOVE, Cobol85ParserREQUIRED, Cobol85ParserREVERSE_VIDEO, Cobol85ParserSAVE, Cobol85ParserSECURE, Cobol85ParserSHARED, Cobol85ParserSHAREDBYALL, Cobol85ParserSHAREDBYRUNUNIT, Cobol85ParserSHARING, Cobol85ParserSHORT_DATE, Cobol85ParserSYMBOL, Cobol85ParserTASK, Cobol85ParserTHREAD, Cobol85ParserTHREAD_LOCAL, Cobol85ParserTIMER, Cobol85ParserTODAYS_DATE, Cobol85ParserTODAYS_NAME, Cobol85ParserTRUNCATED, Cobol85ParserTYPEDEF, Cobol85ParserUNDERLINE, Cobol85ParserVIRTUAL, Cobol85ParserWAIT, Cobol85ParserYEAR, Cobol85ParserYYYYMMDD, Cobol85ParserYYYYDDD, Cobol85ParserZERO_FILL, Cobol85ParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6185)
			p.CobolWord()
		}

	case Cobol85ParserLEVEL_NUMBER_66, Cobol85ParserLEVEL_NUMBER_77, Cobol85ParserLEVEL_NUMBER_88, Cobol85ParserINTEGERLITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6186)
			p.IntegerLiteral()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISystemNameContext is an interface to support dynamic dispatch.
type ISystemNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSystemNameContext differentiates from other interfaces.
	IsSystemNameContext()
}

type SystemNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySystemNameContext() *SystemNameContext {
	var p = new(SystemNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_systemName
	return p
}

func (*SystemNameContext) IsSystemNameContext() {}

func NewSystemNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SystemNameContext {
	var p = new(SystemNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_systemName

	return p
}

func (s *SystemNameContext) GetParser() antlr.Parser { return s.parser }

func (s *SystemNameContext) CobolWord() ICobolWordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICobolWordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *SystemNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SystemNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SystemNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSystemName(s)
	}
}

func (s *SystemNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSystemName(s)
	}
}

func (p *Cobol85Parser) SystemName() (localctx ISystemNameContext) {
	localctx = NewSystemNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1164, Cobol85ParserRULE_systemName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6189)
		p.CobolWord()
	}

	return localctx
}

// ISymbolicCharacterContext is an interface to support dynamic dispatch.
type ISymbolicCharacterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSymbolicCharacterContext differentiates from other interfaces.
	IsSymbolicCharacterContext()
}

type SymbolicCharacterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySymbolicCharacterContext() *SymbolicCharacterContext {
	var p = new(SymbolicCharacterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_symbolicCharacter
	return p
}

func (*SymbolicCharacterContext) IsSymbolicCharacterContext() {}

func NewSymbolicCharacterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SymbolicCharacterContext {
	var p = new(SymbolicCharacterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_symbolicCharacter

	return p
}

func (s *SymbolicCharacterContext) GetParser() antlr.Parser { return s.parser }

func (s *SymbolicCharacterContext) CobolWord() ICobolWordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICobolWordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *SymbolicCharacterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SymbolicCharacterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SymbolicCharacterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSymbolicCharacter(s)
	}
}

func (s *SymbolicCharacterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSymbolicCharacter(s)
	}
}

func (p *Cobol85Parser) SymbolicCharacter() (localctx ISymbolicCharacterContext) {
	localctx = NewSymbolicCharacterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1166, Cobol85ParserRULE_symbolicCharacter)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6191)
		p.CobolWord()
	}

	return localctx
}

// ITextNameContext is an interface to support dynamic dispatch.
type ITextNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTextNameContext differentiates from other interfaces.
	IsTextNameContext()
}

type TextNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTextNameContext() *TextNameContext {
	var p = new(TextNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_textName
	return p
}

func (*TextNameContext) IsTextNameContext() {}

func NewTextNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TextNameContext {
	var p = new(TextNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_textName

	return p
}

func (s *TextNameContext) GetParser() antlr.Parser { return s.parser }

func (s *TextNameContext) CobolWord() ICobolWordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICobolWordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *TextNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TextNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TextNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterTextName(s)
	}
}

func (s *TextNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitTextName(s)
	}
}

func (p *Cobol85Parser) TextName() (localctx ITextNameContext) {
	localctx = NewTextNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1168, Cobol85ParserRULE_textName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6193)
		p.CobolWord()
	}

	return localctx
}

// ICobolWordContext is an interface to support dynamic dispatch.
type ICobolWordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCobolWordContext differentiates from other interfaces.
	IsCobolWordContext()
}

type CobolWordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCobolWordContext() *CobolWordContext {
	var p = new(CobolWordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_cobolWord
	return p
}

func (*CobolWordContext) IsCobolWordContext() {}

func NewCobolWordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CobolWordContext {
	var p = new(CobolWordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_cobolWord

	return p
}

func (s *CobolWordContext) GetParser() antlr.Parser { return s.parser }

func (s *CobolWordContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIDENTIFIER, 0)
}

func (s *CobolWordContext) COBOL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOBOL, 0)
}

func (s *CobolWordContext) PROGRAM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPROGRAM, 0)
}

func (s *CobolWordContext) ABORT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserABORT, 0)
}

func (s *CobolWordContext) AS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAS, 0)
}

func (s *CobolWordContext) ASCII() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserASCII, 0)
}

func (s *CobolWordContext) ASSOCIATED_DATA() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserASSOCIATED_DATA, 0)
}

func (s *CobolWordContext) ASSOCIATED_DATA_LENGTH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserASSOCIATED_DATA_LENGTH, 0)
}

func (s *CobolWordContext) ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserATTRIBUTE, 0)
}

func (s *CobolWordContext) AUTO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAUTO, 0)
}

func (s *CobolWordContext) AUTO_SKIP() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAUTO_SKIP, 0)
}

func (s *CobolWordContext) BACKGROUND_COLOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBACKGROUND_COLOR, 0)
}

func (s *CobolWordContext) BACKGROUND_COLOUR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBACKGROUND_COLOUR, 0)
}

func (s *CobolWordContext) BEEP() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBEEP, 0)
}

func (s *CobolWordContext) BELL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBELL, 0)
}

func (s *CobolWordContext) BINARY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBINARY, 0)
}

func (s *CobolWordContext) BIT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBIT, 0)
}

func (s *CobolWordContext) BLINK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBLINK, 0)
}

func (s *CobolWordContext) BOUNDS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBOUNDS, 0)
}

func (s *CobolWordContext) CAPABLE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCAPABLE, 0)
}

func (s *CobolWordContext) CCSVERSION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCCSVERSION, 0)
}

func (s *CobolWordContext) CHANGED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCHANGED, 0)
}

func (s *CobolWordContext) CHANNEL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCHANNEL, 0)
}

func (s *CobolWordContext) CLOSE_DISPOSITION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCLOSE_DISPOSITION, 0)
}

func (s *CobolWordContext) COMMITMENT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMMITMENT, 0)
}

func (s *CobolWordContext) CONTROL_POINT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCONTROL_POINT, 0)
}

func (s *CobolWordContext) CONVENTION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCONVENTION, 0)
}

func (s *CobolWordContext) CRUNCH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCRUNCH, 0)
}

func (s *CobolWordContext) CURSOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCURSOR, 0)
}

func (s *CobolWordContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDEFAULT, 0)
}

func (s *CobolWordContext) DEFAULT_DISPLAY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDEFAULT_DISPLAY, 0)
}

func (s *CobolWordContext) DEFINITION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDEFINITION, 0)
}

func (s *CobolWordContext) DFHRESP() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDFHRESP, 0)
}

func (s *CobolWordContext) DFHVALUE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDFHVALUE, 0)
}

func (s *CobolWordContext) DISK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDISK, 0)
}

func (s *CobolWordContext) DONTCARE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDONTCARE, 0)
}

func (s *CobolWordContext) DOUBLE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOUBLE, 0)
}

func (s *CobolWordContext) EBCDIC() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEBCDIC, 0)
}

func (s *CobolWordContext) EMPTY_CHECK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEMPTY_CHECK, 0)
}

func (s *CobolWordContext) ENTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserENTER, 0)
}

func (s *CobolWordContext) ENTRY_PROCEDURE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserENTRY_PROCEDURE, 0)
}

func (s *CobolWordContext) EOL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEOL, 0)
}

func (s *CobolWordContext) EOS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEOS, 0)
}

func (s *CobolWordContext) ERASE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserERASE, 0)
}

func (s *CobolWordContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserESCAPE, 0)
}

func (s *CobolWordContext) EVENT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEVENT, 0)
}

func (s *CobolWordContext) EXCLUSIVE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEXCLUSIVE, 0)
}

func (s *CobolWordContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEXPORT, 0)
}

func (s *CobolWordContext) EXTENDED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEXTENDED, 0)
}

func (s *CobolWordContext) FOREGROUND_COLOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOREGROUND_COLOR, 0)
}

func (s *CobolWordContext) FOREGROUND_COLOUR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOREGROUND_COLOUR, 0)
}

func (s *CobolWordContext) FULL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFULL, 0)
}

func (s *CobolWordContext) FUNCTIONNAME() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFUNCTIONNAME, 0)
}

func (s *CobolWordContext) FUNCTION_POINTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFUNCTION_POINTER, 0)
}

func (s *CobolWordContext) GRID() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserGRID, 0)
}

func (s *CobolWordContext) HIGHLIGHT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserHIGHLIGHT, 0)
}

func (s *CobolWordContext) IMPLICIT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIMPLICIT, 0)
}

func (s *CobolWordContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIMPORT, 0)
}

func (s *CobolWordContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINTEGER, 0)
}

func (s *CobolWordContext) KEPT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserKEPT, 0)
}

func (s *CobolWordContext) KEYBOARD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserKEYBOARD, 0)
}

func (s *CobolWordContext) LANGUAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLANGUAGE, 0)
}

func (s *CobolWordContext) LB() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLB, 0)
}

func (s *CobolWordContext) LD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLD, 0)
}

func (s *CobolWordContext) LEFTLINE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLEFTLINE, 0)
}

func (s *CobolWordContext) LENGTH_CHECK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLENGTH_CHECK, 0)
}

func (s *CobolWordContext) LIBACCESS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLIBACCESS, 0)
}

func (s *CobolWordContext) LIBPARAMETER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLIBPARAMETER, 0)
}

func (s *CobolWordContext) LIBRARY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLIBRARY, 0)
}

func (s *CobolWordContext) LIST() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLIST, 0)
}

func (s *CobolWordContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLOCAL, 0)
}

func (s *CobolWordContext) LONG_DATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLONG_DATE, 0)
}

func (s *CobolWordContext) LONG_TIME() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLONG_TIME, 0)
}

func (s *CobolWordContext) LOWER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLOWER, 0)
}

func (s *CobolWordContext) LOWLIGHT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLOWLIGHT, 0)
}

func (s *CobolWordContext) MMDDYYYY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMMDDYYYY, 0)
}

func (s *CobolWordContext) NAMED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNAMED, 0)
}

func (s *CobolWordContext) NATIONAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNATIONAL, 0)
}

func (s *CobolWordContext) NATIONAL_EDITED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNATIONAL_EDITED, 0)
}

func (s *CobolWordContext) NETWORK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNETWORK, 0)
}

func (s *CobolWordContext) NO_ECHO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNO_ECHO, 0)
}

func (s *CobolWordContext) NUMERIC_DATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNUMERIC_DATE, 0)
}

func (s *CobolWordContext) NUMERIC_TIME() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNUMERIC_TIME, 0)
}

func (s *CobolWordContext) ODT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserODT, 0)
}

func (s *CobolWordContext) ORDERLY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserORDERLY, 0)
}

func (s *CobolWordContext) OVERLINE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOVERLINE, 0)
}

func (s *CobolWordContext) OWN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOWN, 0)
}

func (s *CobolWordContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPASSWORD, 0)
}

func (s *CobolWordContext) PORT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPORT, 0)
}

func (s *CobolWordContext) PRINTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPRINTER, 0)
}

func (s *CobolWordContext) PRIVATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPRIVATE, 0)
}

func (s *CobolWordContext) PROCESS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPROCESS, 0)
}

func (s *CobolWordContext) PROMPT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPROMPT, 0)
}

func (s *CobolWordContext) READER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREADER, 0)
}

func (s *CobolWordContext) REAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREAL, 0)
}

func (s *CobolWordContext) RECEIVED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRECEIVED, 0)
}

func (s *CobolWordContext) RECURSIVE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRECURSIVE, 0)
}

func (s *CobolWordContext) REF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREF, 0)
}

func (s *CobolWordContext) REMOTE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREMOTE, 0)
}

func (s *CobolWordContext) REMOVE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREMOVE, 0)
}

func (s *CobolWordContext) REQUIRED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREQUIRED, 0)
}

func (s *CobolWordContext) REVERSE_VIDEO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREVERSE_VIDEO, 0)
}

func (s *CobolWordContext) SAVE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSAVE, 0)
}

func (s *CobolWordContext) SECURE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSECURE, 0)
}

func (s *CobolWordContext) SHARED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSHARED, 0)
}

func (s *CobolWordContext) SHAREDBYALL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSHAREDBYALL, 0)
}

func (s *CobolWordContext) SHAREDBYRUNUNIT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSHAREDBYRUNUNIT, 0)
}

func (s *CobolWordContext) SHARING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSHARING, 0)
}

func (s *CobolWordContext) SHORT_DATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSHORT_DATE, 0)
}

func (s *CobolWordContext) SYMBOL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSYMBOL, 0)
}

func (s *CobolWordContext) TASK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTASK, 0)
}

func (s *CobolWordContext) THREAD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHREAD, 0)
}

func (s *CobolWordContext) THREAD_LOCAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHREAD_LOCAL, 0)
}

func (s *CobolWordContext) TIMER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTIMER, 0)
}

func (s *CobolWordContext) TODAYS_DATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTODAYS_DATE, 0)
}

func (s *CobolWordContext) TODAYS_NAME() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTODAYS_NAME, 0)
}

func (s *CobolWordContext) TRUNCATED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTRUNCATED, 0)
}

func (s *CobolWordContext) TYPEDEF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTYPEDEF, 0)
}

func (s *CobolWordContext) UNDERLINE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserUNDERLINE, 0)
}

func (s *CobolWordContext) VIRTUAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserVIRTUAL, 0)
}

func (s *CobolWordContext) WAIT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWAIT, 0)
}

func (s *CobolWordContext) YEAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserYEAR, 0)
}

func (s *CobolWordContext) YYYYMMDD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserYYYYMMDD, 0)
}

func (s *CobolWordContext) YYYYDDD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserYYYYDDD, 0)
}

func (s *CobolWordContext) ZERO_FILL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserZERO_FILL, 0)
}

func (s *CobolWordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CobolWordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CobolWordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCobolWord(s)
	}
}

func (s *CobolWordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCobolWord(s)
	}
}

func (p *Cobol85Parser) CobolWord() (localctx ICobolWordContext) {
	localctx = NewCobolWordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1170, Cobol85ParserRULE_cobolWord)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6195)
		_la = p.GetTokenStream().LA(1)

		if !((((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Cobol85ParserABORT)|(1<<Cobol85ParserAS)|(1<<Cobol85ParserASCII)|(1<<Cobol85ParserASSOCIATED_DATA)|(1<<Cobol85ParserASSOCIATED_DATA_LENGTH)|(1<<Cobol85ParserATTRIBUTE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(Cobol85ParserAUTO-33))|(1<<(Cobol85ParserAUTO_SKIP-33))|(1<<(Cobol85ParserBACKGROUND_COLOR-33))|(1<<(Cobol85ParserBACKGROUND_COLOUR-33))|(1<<(Cobol85ParserBEEP-33))|(1<<(Cobol85ParserBELL-33))|(1<<(Cobol85ParserBINARY-33))|(1<<(Cobol85ParserBIT-33))|(1<<(Cobol85ParserBLINK-33))|(1<<(Cobol85ParserBOUNDS-33))|(1<<(Cobol85ParserCAPABLE-33))|(1<<(Cobol85ParserCCSVERSION-33))|(1<<(Cobol85ParserCHANGED-33))|(1<<(Cobol85ParserCHANNEL-33)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(Cobol85ParserCLOSE_DISPOSITION-68))|(1<<(Cobol85ParserCOBOL-68))|(1<<(Cobol85ParserCOMMITMENT-68))|(1<<(Cobol85ParserCONTROL_POINT-68)))) != 0) || (((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(Cobol85ParserCONVENTION-100))|(1<<(Cobol85ParserCRUNCH-100))|(1<<(Cobol85ParserCURSOR-100))|(1<<(Cobol85ParserDEFAULT-100))|(1<<(Cobol85ParserDEFAULT_DISPLAY-100))|(1<<(Cobol85ParserDEFINITION-100)))) != 0) || (((_la-138)&-(0x1f+1)) == 0 && ((1<<uint((_la-138)))&((1<<(Cobol85ParserDFHRESP-138))|(1<<(Cobol85ParserDFHVALUE-138))|(1<<(Cobol85ParserDISK-138))|(1<<(Cobol85ParserDONTCARE-138))|(1<<(Cobol85ParserDOUBLE-138))|(1<<(Cobol85ParserEBCDIC-138))|(1<<(Cobol85ParserEMPTY_CHECK-138)))) != 0) || (((_la-181)&-(0x1f+1)) == 0 && ((1<<uint((_la-181)))&((1<<(Cobol85ParserENTER-181))|(1<<(Cobol85ParserENTRY_PROCEDURE-181))|(1<<(Cobol85ParserERASE-181))|(1<<(Cobol85ParserEOL-181))|(1<<(Cobol85ParserEOS-181))|(1<<(Cobol85ParserESCAPE-181))|(1<<(Cobol85ParserEVENT-181))|(1<<(Cobol85ParserEXCLUSIVE-181))|(1<<(Cobol85ParserEXPORT-181))|(1<<(Cobol85ParserEXTENDED-181)))) != 0) || (((_la-213)&-(0x1f+1)) == 0 && ((1<<uint((_la-213)))&((1<<(Cobol85ParserFOREGROUND_COLOR-213))|(1<<(Cobol85ParserFOREGROUND_COLOUR-213))|(1<<(Cobol85ParserFULL-213))|(1<<(Cobol85ParserFUNCTIONNAME-213))|(1<<(Cobol85ParserFUNCTION_POINTER-213))|(1<<(Cobol85ParserGRID-213))|(1<<(Cobol85ParserHIGHLIGHT-213))|(1<<(Cobol85ParserIMPLICIT-213))|(1<<(Cobol85ParserIMPORT-213)))) != 0) || (((_la-250)&-(0x1f+1)) == 0 && ((1<<uint((_la-250)))&((1<<(Cobol85ParserINTEGER-250))|(1<<(Cobol85ParserKEPT-250))|(1<<(Cobol85ParserKEYBOARD-250))|(1<<(Cobol85ParserLANGUAGE-250))|(1<<(Cobol85ParserLB-250))|(1<<(Cobol85ParserLD-250))|(1<<(Cobol85ParserLEFTLINE-250))|(1<<(Cobol85ParserLENGTH_CHECK-250))|(1<<(Cobol85ParserLIBACCESS-250))|(1<<(Cobol85ParserLIBPARAMETER-250))|(1<<(Cobol85ParserLIBRARY-250)))) != 0) || (((_la-283)&-(0x1f+1)) == 0 && ((1<<uint((_la-283)))&((1<<(Cobol85ParserLIST-283))|(1<<(Cobol85ParserLOCAL-283))|(1<<(Cobol85ParserLONG_DATE-283))|(1<<(Cobol85ParserLONG_TIME-283))|(1<<(Cobol85ParserLOWER-283))|(1<<(Cobol85ParserLOWLIGHT-283))|(1<<(Cobol85ParserMMDDYYYY-283))|(1<<(Cobol85ParserNAMED-283))|(1<<(Cobol85ParserNATIONAL-283))|(1<<(Cobol85ParserNATIONAL_EDITED-283))|(1<<(Cobol85ParserNETWORK-283))|(1<<(Cobol85ParserNO_ECHO-283)))) != 0) || (((_la-317)&-(0x1f+1)) == 0 && ((1<<uint((_la-317)))&((1<<(Cobol85ParserNUMERIC_DATE-317))|(1<<(Cobol85ParserNUMERIC_TIME-317))|(1<<(Cobol85ParserODT-317))|(1<<(Cobol85ParserORDERLY-317))|(1<<(Cobol85ParserOVERLINE-317))|(1<<(Cobol85ParserOWN-317))|(1<<(Cobol85ParserPASSWORD-317)))) != 0) || (((_la-352)&-(0x1f+1)) == 0 && ((1<<uint((_la-352)))&((1<<(Cobol85ParserPORT-352))|(1<<(Cobol85ParserPRINTER-352))|(1<<(Cobol85ParserPRIVATE-352))|(1<<(Cobol85ParserPROCESS-352))|(1<<(Cobol85ParserPROGRAM-352))|(1<<(Cobol85ParserPROMPT-352))|(1<<(Cobol85ParserREADER-352))|(1<<(Cobol85ParserREMOTE-352))|(1<<(Cobol85ParserREAL-352))|(1<<(Cobol85ParserRECEIVED-352))|(1<<(Cobol85ParserRECURSIVE-352))|(1<<(Cobol85ParserREF-352)))) != 0) || (((_la-391)&-(0x1f+1)) == 0 && ((1<<uint((_la-391)))&((1<<(Cobol85ParserREMOVE-391))|(1<<(Cobol85ParserREQUIRED-391))|(1<<(Cobol85ParserREVERSE_VIDEO-391))|(1<<(Cobol85ParserSAVE-391))|(1<<(Cobol85ParserSECURE-391)))) != 0) || (((_la-431)&-(0x1f+1)) == 0 && ((1<<uint((_la-431)))&((1<<(Cobol85ParserSHARED-431))|(1<<(Cobol85ParserSHAREDBYALL-431))|(1<<(Cobol85ParserSHAREDBYRUNUNIT-431))|(1<<(Cobol85ParserSHARING-431))|(1<<(Cobol85ParserSHORT_DATE-431)))) != 0) || (((_la-466)&-(0x1f+1)) == 0 && ((1<<uint((_la-466)))&((1<<(Cobol85ParserSYMBOL-466))|(1<<(Cobol85ParserTASK-466))|(1<<(Cobol85ParserTHREAD-466))|(1<<(Cobol85ParserTHREAD_LOCAL-466))|(1<<(Cobol85ParserTIMER-466))|(1<<(Cobol85ParserTODAYS_DATE-466))|(1<<(Cobol85ParserTODAYS_NAME-466))|(1<<(Cobol85ParserTRUNCATED-466))|(1<<(Cobol85ParserTYPEDEF-466)))) != 0) || (((_la-498)&-(0x1f+1)) == 0 && ((1<<uint((_la-498)))&((1<<(Cobol85ParserUNDERLINE-498))|(1<<(Cobol85ParserVIRTUAL-498))|(1<<(Cobol85ParserWAIT-498))|(1<<(Cobol85ParserYEAR-498))|(1<<(Cobol85ParserYYYYMMDD-498))|(1<<(Cobol85ParserYYYYDDD-498))|(1<<(Cobol85ParserZERO_FILL-498)))) != 0) || _la == Cobol85ParserIDENTIFIER) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_literal
	return p
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) NONNUMERICLITERAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNONNUMERICLITERAL, 0)
}

func (s *LiteralContext) FigurativeConstant() IFigurativeConstantContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFigurativeConstantContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFigurativeConstantContext)
}

func (s *LiteralContext) NumericLiteral() INumericLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumericLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumericLiteralContext)
}

func (s *LiteralContext) BooleanLiteral() IBooleanLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBooleanLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBooleanLiteralContext)
}

func (s *LiteralContext) CicsDfhRespLiteral() ICicsDfhRespLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICicsDfhRespLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICicsDfhRespLiteralContext)
}

func (s *LiteralContext) CicsDfhValueLiteral() ICicsDfhValueLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICicsDfhValueLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICicsDfhValueLiteralContext)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLiteral(s)
	}
}

func (s *LiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLiteral(s)
	}
}

func (p *Cobol85Parser) Literal() (localctx ILiteralContext) {
	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1172, Cobol85ParserRULE_literal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6203)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 971, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6197)
			p.Match(Cobol85ParserNONNUMERICLITERAL)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6198)
			p.FigurativeConstant()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6199)
			p.NumericLiteral()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6200)
			p.BooleanLiteral()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6201)
			p.CicsDfhRespLiteral()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(6202)
			p.CicsDfhValueLiteral()
		}

	}

	return localctx
}

// IBooleanLiteralContext is an interface to support dynamic dispatch.
type IBooleanLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBooleanLiteralContext differentiates from other interfaces.
	IsBooleanLiteralContext()
}

type BooleanLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanLiteralContext() *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_booleanLiteral
	return p
}

func (*BooleanLiteralContext) IsBooleanLiteralContext() {}

func NewBooleanLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_booleanLiteral

	return p
}

func (s *BooleanLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanLiteralContext) TRUE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTRUE, 0)
}

func (s *BooleanLiteralContext) FALSE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFALSE, 0)
}

func (s *BooleanLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BooleanLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterBooleanLiteral(s)
	}
}

func (s *BooleanLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitBooleanLiteral(s)
	}
}

func (p *Cobol85Parser) BooleanLiteral() (localctx IBooleanLiteralContext) {
	localctx = NewBooleanLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1174, Cobol85ParserRULE_booleanLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6205)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserFALSE || _la == Cobol85ParserTRUE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// INumericLiteralContext is an interface to support dynamic dispatch.
type INumericLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNumericLiteralContext differentiates from other interfaces.
	IsNumericLiteralContext()
}

type NumericLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumericLiteralContext() *NumericLiteralContext {
	var p = new(NumericLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_numericLiteral
	return p
}

func (*NumericLiteralContext) IsNumericLiteralContext() {}

func NewNumericLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumericLiteralContext {
	var p = new(NumericLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_numericLiteral

	return p
}

func (s *NumericLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *NumericLiteralContext) NUMERICLITERAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNUMERICLITERAL, 0)
}

func (s *NumericLiteralContext) ZERO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserZERO, 0)
}

func (s *NumericLiteralContext) IntegerLiteral() IIntegerLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *NumericLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumericLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NumericLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterNumericLiteral(s)
	}
}

func (s *NumericLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitNumericLiteral(s)
	}
}

func (p *Cobol85Parser) NumericLiteral() (localctx INumericLiteralContext) {
	localctx = NewNumericLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1176, Cobol85ParserRULE_numericLiteral)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6210)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserNUMERICLITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6207)
			p.Match(Cobol85ParserNUMERICLITERAL)
		}

	case Cobol85ParserZERO:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6208)
			p.Match(Cobol85ParserZERO)
		}

	case Cobol85ParserLEVEL_NUMBER_66, Cobol85ParserLEVEL_NUMBER_77, Cobol85ParserLEVEL_NUMBER_88, Cobol85ParserINTEGERLITERAL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6209)
			p.IntegerLiteral()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IIntegerLiteralContext is an interface to support dynamic dispatch.
type IIntegerLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIntegerLiteralContext differentiates from other interfaces.
	IsIntegerLiteralContext()
}

type IntegerLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntegerLiteralContext() *IntegerLiteralContext {
	var p = new(IntegerLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_integerLiteral
	return p
}

func (*IntegerLiteralContext) IsIntegerLiteralContext() {}

func NewIntegerLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntegerLiteralContext {
	var p = new(IntegerLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_integerLiteral

	return p
}

func (s *IntegerLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *IntegerLiteralContext) INTEGERLITERAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINTEGERLITERAL, 0)
}

func (s *IntegerLiteralContext) LEVEL_NUMBER_66() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLEVEL_NUMBER_66, 0)
}

func (s *IntegerLiteralContext) LEVEL_NUMBER_77() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLEVEL_NUMBER_77, 0)
}

func (s *IntegerLiteralContext) LEVEL_NUMBER_88() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLEVEL_NUMBER_88, 0)
}

func (s *IntegerLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntegerLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntegerLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterIntegerLiteral(s)
	}
}

func (s *IntegerLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitIntegerLiteral(s)
	}
}

func (p *Cobol85Parser) IntegerLiteral() (localctx IIntegerLiteralContext) {
	localctx = NewIntegerLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1178, Cobol85ParserRULE_integerLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6212)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-552)&-(0x1f+1)) == 0 && ((1<<uint((_la-552)))&((1<<(Cobol85ParserLEVEL_NUMBER_66-552))|(1<<(Cobol85ParserLEVEL_NUMBER_77-552))|(1<<(Cobol85ParserLEVEL_NUMBER_88-552))|(1<<(Cobol85ParserINTEGERLITERAL-552)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ICicsDfhRespLiteralContext is an interface to support dynamic dispatch.
type ICicsDfhRespLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCicsDfhRespLiteralContext differentiates from other interfaces.
	IsCicsDfhRespLiteralContext()
}

type CicsDfhRespLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCicsDfhRespLiteralContext() *CicsDfhRespLiteralContext {
	var p = new(CicsDfhRespLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_cicsDfhRespLiteral
	return p
}

func (*CicsDfhRespLiteralContext) IsCicsDfhRespLiteralContext() {}

func NewCicsDfhRespLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CicsDfhRespLiteralContext {
	var p = new(CicsDfhRespLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_cicsDfhRespLiteral

	return p
}

func (s *CicsDfhRespLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *CicsDfhRespLiteralContext) DFHRESP() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDFHRESP, 0)
}

func (s *CicsDfhRespLiteralContext) LPARENCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLPARENCHAR, 0)
}

func (s *CicsDfhRespLiteralContext) RPARENCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRPARENCHAR, 0)
}

func (s *CicsDfhRespLiteralContext) CobolWord() ICobolWordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICobolWordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *CicsDfhRespLiteralContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *CicsDfhRespLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CicsDfhRespLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CicsDfhRespLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCicsDfhRespLiteral(s)
	}
}

func (s *CicsDfhRespLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCicsDfhRespLiteral(s)
	}
}

func (p *Cobol85Parser) CicsDfhRespLiteral() (localctx ICicsDfhRespLiteralContext) {
	localctx = NewCicsDfhRespLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1180, Cobol85ParserRULE_cicsDfhRespLiteral)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6214)
		p.Match(Cobol85ParserDFHRESP)
	}
	{
		p.SetState(6215)
		p.Match(Cobol85ParserLPARENCHAR)
	}
	p.SetState(6218)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 973, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(6216)
			p.CobolWord()
		}

	case 2:
		{
			p.SetState(6217)
			p.Literal()
		}

	}
	{
		p.SetState(6220)
		p.Match(Cobol85ParserRPARENCHAR)
	}

	return localctx
}

// ICicsDfhValueLiteralContext is an interface to support dynamic dispatch.
type ICicsDfhValueLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCicsDfhValueLiteralContext differentiates from other interfaces.
	IsCicsDfhValueLiteralContext()
}

type CicsDfhValueLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCicsDfhValueLiteralContext() *CicsDfhValueLiteralContext {
	var p = new(CicsDfhValueLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_cicsDfhValueLiteral
	return p
}

func (*CicsDfhValueLiteralContext) IsCicsDfhValueLiteralContext() {}

func NewCicsDfhValueLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CicsDfhValueLiteralContext {
	var p = new(CicsDfhValueLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_cicsDfhValueLiteral

	return p
}

func (s *CicsDfhValueLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *CicsDfhValueLiteralContext) DFHVALUE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDFHVALUE, 0)
}

func (s *CicsDfhValueLiteralContext) LPARENCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLPARENCHAR, 0)
}

func (s *CicsDfhValueLiteralContext) RPARENCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRPARENCHAR, 0)
}

func (s *CicsDfhValueLiteralContext) CobolWord() ICobolWordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICobolWordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *CicsDfhValueLiteralContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *CicsDfhValueLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CicsDfhValueLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CicsDfhValueLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCicsDfhValueLiteral(s)
	}
}

func (s *CicsDfhValueLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCicsDfhValueLiteral(s)
	}
}

func (p *Cobol85Parser) CicsDfhValueLiteral() (localctx ICicsDfhValueLiteralContext) {
	localctx = NewCicsDfhValueLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1182, Cobol85ParserRULE_cicsDfhValueLiteral)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6222)
		p.Match(Cobol85ParserDFHVALUE)
	}
	{
		p.SetState(6223)
		p.Match(Cobol85ParserLPARENCHAR)
	}
	p.SetState(6226)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 974, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(6224)
			p.CobolWord()
		}

	case 2:
		{
			p.SetState(6225)
			p.Literal()
		}

	}
	{
		p.SetState(6228)
		p.Match(Cobol85ParserRPARENCHAR)
	}

	return localctx
}

// IFigurativeConstantContext is an interface to support dynamic dispatch.
type IFigurativeConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFigurativeConstantContext differentiates from other interfaces.
	IsFigurativeConstantContext()
}

type FigurativeConstantContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFigurativeConstantContext() *FigurativeConstantContext {
	var p = new(FigurativeConstantContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_figurativeConstant
	return p
}

func (*FigurativeConstantContext) IsFigurativeConstantContext() {}

func NewFigurativeConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FigurativeConstantContext {
	var p = new(FigurativeConstantContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_figurativeConstant

	return p
}

func (s *FigurativeConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *FigurativeConstantContext) ALL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALL, 0)
}

func (s *FigurativeConstantContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *FigurativeConstantContext) HIGH_VALUE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserHIGH_VALUE, 0)
}

func (s *FigurativeConstantContext) HIGH_VALUES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserHIGH_VALUES, 0)
}

func (s *FigurativeConstantContext) LOW_VALUE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLOW_VALUE, 0)
}

func (s *FigurativeConstantContext) LOW_VALUES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLOW_VALUES, 0)
}

func (s *FigurativeConstantContext) NULL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNULL, 0)
}

func (s *FigurativeConstantContext) NULLS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNULLS, 0)
}

func (s *FigurativeConstantContext) QUOTE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserQUOTE, 0)
}

func (s *FigurativeConstantContext) QUOTES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserQUOTES, 0)
}

func (s *FigurativeConstantContext) SPACE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSPACE, 0)
}

func (s *FigurativeConstantContext) SPACES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSPACES, 0)
}

func (s *FigurativeConstantContext) ZERO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserZERO, 0)
}

func (s *FigurativeConstantContext) ZEROS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserZEROS, 0)
}

func (s *FigurativeConstantContext) ZEROES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserZEROES, 0)
}

func (s *FigurativeConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FigurativeConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FigurativeConstantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterFigurativeConstant(s)
	}
}

func (s *FigurativeConstantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitFigurativeConstant(s)
	}
}

func (p *Cobol85Parser) FigurativeConstant() (localctx IFigurativeConstantContext) {
	localctx = NewFigurativeConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1184, Cobol85ParserRULE_figurativeConstant)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6245)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserALL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6230)
			p.Match(Cobol85ParserALL)
		}
		{
			p.SetState(6231)
			p.Literal()
		}

	case Cobol85ParserHIGH_VALUE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6232)
			p.Match(Cobol85ParserHIGH_VALUE)
		}

	case Cobol85ParserHIGH_VALUES:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6233)
			p.Match(Cobol85ParserHIGH_VALUES)
		}

	case Cobol85ParserLOW_VALUE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6234)
			p.Match(Cobol85ParserLOW_VALUE)
		}

	case Cobol85ParserLOW_VALUES:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6235)
			p.Match(Cobol85ParserLOW_VALUES)
		}

	case Cobol85ParserNULL:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(6236)
			p.Match(Cobol85ParserNULL)
		}

	case Cobol85ParserNULLS:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(6237)
			p.Match(Cobol85ParserNULLS)
		}

	case Cobol85ParserQUOTE:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(6238)
			p.Match(Cobol85ParserQUOTE)
		}

	case Cobol85ParserQUOTES:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(6239)
			p.Match(Cobol85ParserQUOTES)
		}

	case Cobol85ParserSPACE:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(6240)
			p.Match(Cobol85ParserSPACE)
		}

	case Cobol85ParserSPACES:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(6241)
			p.Match(Cobol85ParserSPACES)
		}

	case Cobol85ParserZERO:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(6242)
			p.Match(Cobol85ParserZERO)
		}

	case Cobol85ParserZEROS:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(6243)
			p.Match(Cobol85ParserZEROS)
		}

	case Cobol85ParserZEROES:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(6244)
			p.Match(Cobol85ParserZEROES)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISpecialRegisterContext is an interface to support dynamic dispatch.
type ISpecialRegisterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSpecialRegisterContext differentiates from other interfaces.
	IsSpecialRegisterContext()
}

type SpecialRegisterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpecialRegisterContext() *SpecialRegisterContext {
	var p = new(SpecialRegisterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_specialRegister
	return p
}

func (*SpecialRegisterContext) IsSpecialRegisterContext() {}

func NewSpecialRegisterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SpecialRegisterContext {
	var p = new(SpecialRegisterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_specialRegister

	return p
}

func (s *SpecialRegisterContext) GetParser() antlr.Parser { return s.parser }

func (s *SpecialRegisterContext) ADDRESS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserADDRESS, 0)
}

func (s *SpecialRegisterContext) OF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOF, 0)
}

func (s *SpecialRegisterContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SpecialRegisterContext) DATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDATE, 0)
}

func (s *SpecialRegisterContext) DAY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDAY, 0)
}

func (s *SpecialRegisterContext) DAY_OF_WEEK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDAY_OF_WEEK, 0)
}

func (s *SpecialRegisterContext) DEBUG_CONTENTS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDEBUG_CONTENTS, 0)
}

func (s *SpecialRegisterContext) DEBUG_ITEM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDEBUG_ITEM, 0)
}

func (s *SpecialRegisterContext) DEBUG_LINE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDEBUG_LINE, 0)
}

func (s *SpecialRegisterContext) DEBUG_NAME() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDEBUG_NAME, 0)
}

func (s *SpecialRegisterContext) DEBUG_SUB_1() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDEBUG_SUB_1, 0)
}

func (s *SpecialRegisterContext) DEBUG_SUB_2() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDEBUG_SUB_2, 0)
}

func (s *SpecialRegisterContext) DEBUG_SUB_3() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDEBUG_SUB_3, 0)
}

func (s *SpecialRegisterContext) LENGTH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLENGTH, 0)
}

func (s *SpecialRegisterContext) LINAGE_COUNTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLINAGE_COUNTER, 0)
}

func (s *SpecialRegisterContext) LINE_COUNTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLINE_COUNTER, 0)
}

func (s *SpecialRegisterContext) PAGE_COUNTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPAGE_COUNTER, 0)
}

func (s *SpecialRegisterContext) RETURN_CODE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRETURN_CODE, 0)
}

func (s *SpecialRegisterContext) SHIFT_IN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSHIFT_IN, 0)
}

func (s *SpecialRegisterContext) SHIFT_OUT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSHIFT_OUT, 0)
}

func (s *SpecialRegisterContext) SORT_CONTROL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSORT_CONTROL, 0)
}

func (s *SpecialRegisterContext) SORT_CORE_SIZE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSORT_CORE_SIZE, 0)
}

func (s *SpecialRegisterContext) SORT_FILE_SIZE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSORT_FILE_SIZE, 0)
}

func (s *SpecialRegisterContext) SORT_MESSAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSORT_MESSAGE, 0)
}

func (s *SpecialRegisterContext) SORT_MODE_SIZE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSORT_MODE_SIZE, 0)
}

func (s *SpecialRegisterContext) SORT_RETURN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSORT_RETURN, 0)
}

func (s *SpecialRegisterContext) TALLY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTALLY, 0)
}

func (s *SpecialRegisterContext) TIME() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTIME, 0)
}

func (s *SpecialRegisterContext) WHEN_COMPILED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWHEN_COMPILED, 0)
}

func (s *SpecialRegisterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpecialRegisterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SpecialRegisterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSpecialRegister(s)
	}
}

func (s *SpecialRegisterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSpecialRegister(s)
	}
}

func (p *Cobol85Parser) SpecialRegister() (localctx ISpecialRegisterContext) {
	localctx = NewSpecialRegisterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1186, Cobol85ParserRULE_specialRegister)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6280)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserADDRESS:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6247)
			p.Match(Cobol85ParserADDRESS)
		}
		{
			p.SetState(6248)
			p.Match(Cobol85ParserOF)
		}
		{
			p.SetState(6249)
			p.Identifier()
		}

	case Cobol85ParserDATE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6250)
			p.Match(Cobol85ParserDATE)
		}

	case Cobol85ParserDAY:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6251)
			p.Match(Cobol85ParserDAY)
		}

	case Cobol85ParserDAY_OF_WEEK:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6252)
			p.Match(Cobol85ParserDAY_OF_WEEK)
		}

	case Cobol85ParserDEBUG_CONTENTS:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6253)
			p.Match(Cobol85ParserDEBUG_CONTENTS)
		}

	case Cobol85ParserDEBUG_ITEM:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(6254)
			p.Match(Cobol85ParserDEBUG_ITEM)
		}

	case Cobol85ParserDEBUG_LINE:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(6255)
			p.Match(Cobol85ParserDEBUG_LINE)
		}

	case Cobol85ParserDEBUG_NAME:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(6256)
			p.Match(Cobol85ParserDEBUG_NAME)
		}

	case Cobol85ParserDEBUG_SUB_1:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(6257)
			p.Match(Cobol85ParserDEBUG_SUB_1)
		}

	case Cobol85ParserDEBUG_SUB_2:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(6258)
			p.Match(Cobol85ParserDEBUG_SUB_2)
		}

	case Cobol85ParserDEBUG_SUB_3:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(6259)
			p.Match(Cobol85ParserDEBUG_SUB_3)
		}

	case Cobol85ParserLENGTH:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(6260)
			p.Match(Cobol85ParserLENGTH)
		}
		p.SetState(6262)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserOF {
			{
				p.SetState(6261)
				p.Match(Cobol85ParserOF)
			}

		}
		{
			p.SetState(6264)
			p.Identifier()
		}

	case Cobol85ParserLINAGE_COUNTER:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(6265)
			p.Match(Cobol85ParserLINAGE_COUNTER)
		}

	case Cobol85ParserLINE_COUNTER:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(6266)
			p.Match(Cobol85ParserLINE_COUNTER)
		}

	case Cobol85ParserPAGE_COUNTER:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(6267)
			p.Match(Cobol85ParserPAGE_COUNTER)
		}

	case Cobol85ParserRETURN_CODE:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(6268)
			p.Match(Cobol85ParserRETURN_CODE)
		}

	case Cobol85ParserSHIFT_IN:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(6269)
			p.Match(Cobol85ParserSHIFT_IN)
		}

	case Cobol85ParserSHIFT_OUT:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(6270)
			p.Match(Cobol85ParserSHIFT_OUT)
		}

	case Cobol85ParserSORT_CONTROL:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(6271)
			p.Match(Cobol85ParserSORT_CONTROL)
		}

	case Cobol85ParserSORT_CORE_SIZE:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(6272)
			p.Match(Cobol85ParserSORT_CORE_SIZE)
		}

	case Cobol85ParserSORT_FILE_SIZE:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(6273)
			p.Match(Cobol85ParserSORT_FILE_SIZE)
		}

	case Cobol85ParserSORT_MESSAGE:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(6274)
			p.Match(Cobol85ParserSORT_MESSAGE)
		}

	case Cobol85ParserSORT_MODE_SIZE:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(6275)
			p.Match(Cobol85ParserSORT_MODE_SIZE)
		}

	case Cobol85ParserSORT_RETURN:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(6276)
			p.Match(Cobol85ParserSORT_RETURN)
		}

	case Cobol85ParserTALLY:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(6277)
			p.Match(Cobol85ParserTALLY)
		}

	case Cobol85ParserTIME:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(6278)
			p.Match(Cobol85ParserTIME)
		}

	case Cobol85ParserWHEN_COMPILED:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(6279)
			p.Match(Cobol85ParserWHEN_COMPILED)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICommentEntryContext is an interface to support dynamic dispatch.
type ICommentEntryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCommentEntryContext differentiates from other interfaces.
	IsCommentEntryContext()
}

type CommentEntryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommentEntryContext() *CommentEntryContext {
	var p = new(CommentEntryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_commentEntry
	return p
}

func (*CommentEntryContext) IsCommentEntryContext() {}

func NewCommentEntryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommentEntryContext {
	var p = new(CommentEntryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_commentEntry

	return p
}

func (s *CommentEntryContext) GetParser() antlr.Parser { return s.parser }

func (s *CommentEntryContext) AllCOMMENTENTRYLINE() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserCOMMENTENTRYLINE)
}

func (s *CommentEntryContext) COMMENTENTRYLINE(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMMENTENTRYLINE, i)
}

func (s *CommentEntryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommentEntryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommentEntryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCommentEntry(s)
	}
}

func (s *CommentEntryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCommentEntry(s)
	}
}

func (p *Cobol85Parser) CommentEntry() (localctx ICommentEntryContext) {
	localctx = NewCommentEntryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1188, Cobol85ParserRULE_commentEntry)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(6283)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == Cobol85ParserCOMMENTENTRYLINE {
		{
			p.SetState(6282)
			p.Match(Cobol85ParserCOMMENTENTRYLINE)
		}

		p.SetState(6285)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}
