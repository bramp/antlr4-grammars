// Code generated from css3.g4 by ANTLR 4.9.3. DO NOT EDIT.

package css3 // css3
import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 64, 1114,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4,
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55,
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9,
	60, 4, 61, 9, 61, 4, 62, 9, 62, 4, 63, 9, 63, 4, 64, 9, 64, 4, 65, 9, 65,
	4, 66, 9, 66, 4, 67, 9, 67, 4, 68, 9, 68, 4, 69, 9, 69, 4, 70, 9, 70, 4,
	71, 9, 71, 4, 72, 9, 72, 4, 73, 9, 73, 4, 74, 9, 74, 4, 75, 9, 75, 4, 76,
	9, 76, 4, 77, 9, 77, 4, 78, 9, 78, 4, 79, 9, 79, 4, 80, 9, 80, 3, 2, 3,
	2, 3, 2, 7, 2, 164, 10, 2, 12, 2, 14, 2, 167, 11, 2, 7, 2, 169, 10, 2,
	12, 2, 14, 2, 172, 11, 2, 3, 2, 3, 2, 7, 2, 176, 10, 2, 12, 2, 14, 2, 179,
	11, 2, 7, 2, 181, 10, 2, 12, 2, 14, 2, 184, 11, 2, 3, 2, 3, 2, 7, 2, 188,
	10, 2, 12, 2, 14, 2, 191, 11, 2, 7, 2, 193, 10, 2, 12, 2, 14, 2, 196, 11,
	2, 3, 2, 3, 2, 7, 2, 200, 10, 2, 12, 2, 14, 2, 203, 11, 2, 7, 2, 205, 10,
	2, 12, 2, 14, 2, 208, 11, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 5, 3, 222, 10, 3, 3, 4, 3, 4, 3, 4, 3, 4,
	3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4,
	3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 5, 4, 250,
	10, 4, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 257, 10, 5, 3, 5, 3, 5, 3, 5,
	3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 269, 10, 5, 3, 5, 3, 5,
	3, 5, 5, 5, 274, 10, 5, 3, 6, 3, 6, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7,
	3, 8, 3, 8, 3, 8, 3, 8, 3, 8, 7, 8, 289, 10, 8, 12, 8, 14, 8, 292, 11,
	8, 5, 8, 294, 10, 8, 3, 8, 3, 8, 3, 9, 5, 9, 299, 10, 9, 3, 9, 3, 9, 3,
	9, 3, 9, 3, 9, 3, 9, 3, 9, 7, 9, 308, 10, 9, 12, 9, 14, 9, 311, 11, 9,
	3, 9, 3, 9, 3, 9, 3, 9, 3, 9, 7, 9, 318, 10, 9, 12, 9, 14, 9, 321, 11,
	9, 5, 9, 323, 10, 9, 3, 10, 3, 10, 3, 11, 3, 11, 3, 11, 3, 11, 3, 11, 3,
	11, 3, 11, 5, 11, 334, 10, 11, 3, 11, 3, 11, 3, 11, 3, 12, 3, 12, 3, 12,
	3, 13, 3, 13, 3, 13, 5, 13, 345, 10, 13, 3, 13, 3, 13, 3, 13, 5, 13, 350,
	10, 13, 3, 13, 3, 13, 3, 13, 5, 13, 355, 10, 13, 7, 13, 357, 10, 13, 12,
	13, 14, 13, 360, 11, 13, 3, 13, 3, 13, 3, 13, 3, 14, 3, 14, 3, 14, 3, 14,
	3, 15, 3, 15, 3, 15, 3, 15, 3, 15, 7, 15, 374, 10, 15, 12, 15, 14, 15,
	377, 11, 15, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 7, 16, 385, 10,
	16, 12, 16, 14, 16, 388, 11, 16, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3,
	17, 3, 17, 3, 17, 5, 17, 398, 10, 17, 3, 18, 3, 18, 5, 18, 402, 10, 18,
	3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 7, 18, 409, 10, 18, 12, 18, 14, 18,
	412, 11, 18, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 6, 18, 419, 10, 18, 13,
	18, 14, 18, 420, 5, 18, 423, 10, 18, 3, 19, 5, 19, 426, 10, 19, 3, 19,
	3, 19, 3, 20, 3, 20, 5, 20, 432, 10, 20, 3, 20, 3, 20, 3, 21, 3, 21, 3,
	22, 5, 22, 439, 10, 22, 3, 22, 3, 22, 3, 23, 3, 23, 3, 23, 3, 24, 3, 24,
	3, 24, 5, 24, 449, 10, 24, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24, 5,
	24, 457, 10, 24, 3, 24, 3, 24, 5, 24, 461, 10, 24, 3, 24, 3, 24, 3, 25,
	3, 25, 5, 25, 467, 10, 25, 3, 25, 3, 25, 5, 25, 471, 10, 25, 3, 26, 3,
	26, 3, 26, 3, 26, 3, 26, 3, 27, 3, 27, 3, 27, 3, 27, 3, 27, 3, 27, 3, 27,
	5, 27, 485, 10, 27, 3, 27, 6, 27, 488, 10, 27, 13, 27, 14, 27, 489, 3,
	28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29,
	3, 29, 5, 29, 504, 10, 29, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3,
	30, 3, 30, 5, 30, 514, 10, 30, 3, 31, 3, 31, 3, 31, 3, 31, 3, 31, 3, 31,
	3, 31, 3, 31, 3, 31, 5, 31, 525, 10, 31, 3, 32, 3, 32, 3, 32, 3, 32, 5,
	32, 531, 10, 32, 3, 32, 3, 32, 3, 32, 3, 32, 7, 32, 537, 10, 32, 12, 32,
	14, 32, 540, 11, 32, 3, 32, 3, 32, 3, 32, 5, 32, 545, 10, 32, 3, 32, 3,
	32, 3, 32, 5, 32, 550, 10, 32, 3, 33, 3, 33, 7, 33, 554, 10, 33, 12, 33,
	14, 33, 557, 11, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 5, 33, 564, 10,
	33, 7, 33, 566, 10, 33, 12, 33, 14, 33, 569, 11, 33, 3, 34, 3, 34, 3, 34,
	3, 34, 3, 34, 5, 34, 576, 10, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 5,
	34, 583, 10, 34, 3, 35, 3, 35, 3, 35, 3, 36, 3, 36, 3, 36, 3, 36, 3, 36,
	6, 36, 593, 10, 36, 13, 36, 14, 36, 594, 3, 37, 3, 37, 5, 37, 599, 10,
	37, 3, 37, 7, 37, 602, 10, 37, 12, 37, 14, 37, 605, 11, 37, 3, 38, 3, 38,
	3, 38, 3, 38, 3, 38, 3, 38, 3, 38, 3, 38, 3, 38, 3, 38, 3, 38, 3, 38, 3,
	38, 3, 38, 3, 38, 3, 38, 3, 38, 3, 38, 3, 38, 3, 38, 3, 38, 3, 38, 3, 38,
	3, 38, 3, 38, 3, 38, 5, 38, 633, 10, 38, 3, 39, 3, 39, 3, 39, 3, 39, 3,
	39, 3, 39, 3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 3, 41, 3, 41, 3, 41,
	3, 42, 5, 42, 651, 10, 42, 3, 42, 3, 42, 3, 43, 5, 43, 656, 10, 43, 3,
	43, 3, 43, 3, 44, 5, 44, 661, 10, 44, 3, 44, 3, 44, 3, 45, 5, 45, 666,
	10, 45, 3, 45, 3, 45, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46,
	3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3,
	46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46,
	3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 7, 46, 703, 10, 46, 12, 46, 14, 46,
	706, 11, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 7, 46, 715,
	10, 46, 12, 46, 14, 46, 718, 11, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46,
	3, 46, 3, 46, 7, 46, 727, 10, 46, 12, 46, 14, 46, 730, 11, 46, 3, 46, 3,
	46, 3, 46, 5, 46, 735, 10, 46, 3, 47, 3, 47, 3, 47, 7, 47, 740, 10, 47,
	12, 47, 14, 47, 743, 11, 47, 3, 47, 3, 47, 3, 47, 5, 47, 748, 10, 47, 3,
	48, 3, 48, 3, 48, 3, 49, 3, 49, 3, 49, 3, 49, 3, 49, 3, 49, 3, 49, 3, 49,
	3, 49, 3, 49, 5, 49, 763, 10, 49, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3,
	50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 7, 50, 776, 10, 50, 12, 50, 14,
	50, 779, 11, 50, 3, 50, 3, 50, 3, 50, 3, 51, 3, 51, 3, 51, 3, 51, 3, 51,
	3, 51, 3, 51, 3, 51, 3, 51, 3, 51, 5, 51, 794, 10, 51, 3, 52, 3, 52, 3,
	52, 7, 52, 799, 10, 52, 12, 52, 14, 52, 802, 11, 52, 3, 52, 3, 52, 3, 52,
	3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 54, 3, 54, 3, 54, 3, 54, 5,
	54, 817, 10, 54, 3, 55, 3, 55, 3, 55, 3, 55, 3, 55, 3, 55, 3, 55, 3, 55,
	5, 55, 827, 10, 55, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 57, 3,
	57, 3, 57, 3, 57, 3, 57, 3, 57, 3, 57, 3, 57, 3, 57, 3, 57, 6, 57, 845,
	10, 57, 13, 57, 14, 57, 846, 3, 58, 3, 58, 3, 58, 3, 58, 3, 58, 3, 58,
	3, 58, 3, 58, 3, 58, 3, 58, 6, 58, 859, 10, 58, 13, 58, 14, 58, 860, 3,
	59, 3, 59, 3, 59, 3, 59, 3, 59, 3, 60, 3, 60, 3, 60, 7, 60, 871, 10, 60,
	12, 60, 14, 60, 874, 11, 60, 3, 60, 3, 60, 3, 61, 3, 61, 3, 61, 3, 61,
	3, 61, 3, 61, 3, 61, 3, 62, 3, 62, 3, 62, 3, 62, 3, 62, 3, 62, 3, 63, 3,
	63, 3, 63, 3, 63, 3, 63, 3, 63, 3, 63, 3, 63, 3, 63, 7, 63, 900, 10, 63,
	12, 63, 14, 63, 903, 11, 63, 3, 64, 3, 64, 3, 64, 3, 64, 3, 64, 3, 64,
	3, 64, 3, 64, 3, 64, 3, 64, 7, 64, 915, 10, 64, 12, 64, 14, 64, 918, 11,
	64, 3, 65, 3, 65, 3, 65, 3, 65, 3, 65, 3, 65, 3, 65, 3, 65, 3, 65, 3, 65,
	3, 65, 3, 65, 3, 65, 3, 65, 3, 65, 3, 65, 3, 65, 3, 65, 5, 65, 938, 10,
	65, 3, 66, 3, 66, 3, 66, 3, 66, 3, 66, 5, 66, 945, 10, 66, 3, 66, 3, 66,
	3, 66, 5, 66, 950, 10, 66, 7, 66, 952, 10, 66, 12, 66, 14, 66, 955, 11,
	66, 3, 66, 3, 66, 3, 66, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67,
	3, 67, 3, 67, 3, 67, 5, 67, 970, 10, 67, 3, 68, 3, 68, 3, 68, 3, 68, 3,
	68, 3, 68, 3, 68, 3, 68, 3, 68, 3, 68, 3, 68, 3, 68, 3, 69, 3, 69, 3, 69,
	3, 69, 5, 69, 988, 10, 69, 3, 69, 3, 69, 3, 69, 7, 69, 993, 10, 69, 12,
	69, 14, 69, 996, 11, 69, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70,
	7, 70, 1005, 10, 70, 12, 70, 14, 70, 1008, 11, 70, 3, 71, 3, 71, 3, 71,
	3, 71, 3, 71, 5, 71, 1015, 10, 71, 3, 71, 3, 71, 3, 71, 3, 72, 3, 72, 3,
	72, 3, 72, 3, 72, 3, 72, 3, 72, 5, 72, 1027, 10, 72, 3, 72, 3, 72, 3, 72,
	3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 7, 73, 1039, 10, 73, 12,
	73, 14, 73, 1042, 11, 73, 3, 73, 3, 73, 3, 73, 3, 74, 3, 74, 3, 74, 3,
	74, 3, 74, 3, 74, 7, 74, 1053, 10, 74, 12, 74, 14, 74, 1056, 11, 74, 3,
	75, 3, 75, 3, 75, 3, 75, 3, 75, 7, 75, 1063, 10, 75, 12, 75, 14, 75, 1066,
	11, 75, 5, 75, 1068, 10, 75, 3, 76, 3, 76, 3, 76, 3, 76, 3, 76, 5, 76,
	1075, 10, 76, 3, 76, 3, 76, 3, 76, 3, 76, 5, 76, 1081, 10, 76, 7, 76, 1083,
	10, 76, 12, 76, 14, 76, 1086, 11, 76, 3, 76, 3, 76, 3, 76, 3, 77, 3, 77,
	3, 78, 3, 78, 3, 78, 3, 78, 3, 78, 3, 78, 3, 78, 3, 78, 7, 78, 1101, 10,
	78, 12, 78, 14, 78, 1104, 11, 78, 3, 79, 3, 79, 3, 80, 7, 80, 1109, 10,
	80, 12, 80, 14, 80, 1112, 11, 80, 3, 80, 2, 2, 81, 2, 4, 6, 8, 10, 12,
	14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48,
	50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84,
	86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116,
	118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146,
	148, 150, 152, 154, 156, 158, 2, 11, 3, 2, 18, 21, 4, 2, 32, 32, 46, 46,
	3, 2, 34, 35, 5, 2, 13, 13, 22, 23, 47, 49, 3, 2, 39, 40, 4, 2, 4, 4, 64,
	64, 4, 2, 31, 31, 54, 55, 6, 2, 34, 36, 52, 52, 54, 55, 63, 63, 3, 2, 18,
	19, 2, 1210, 2, 160, 3, 2, 2, 2, 4, 221, 3, 2, 2, 2, 6, 249, 3, 2, 2, 2,
	8, 273, 3, 2, 2, 2, 10, 275, 3, 2, 2, 2, 12, 277, 3, 2, 2, 2, 14, 293,
	3, 2, 2, 2, 16, 322, 3, 2, 2, 2, 18, 324, 3, 2, 2, 2, 20, 326, 3, 2, 2,
	2, 22, 338, 3, 2, 2, 2, 24, 341, 3, 2, 2, 2, 26, 364, 3, 2, 2, 2, 28, 368,
	3, 2, 2, 2, 30, 378, 3, 2, 2, 2, 32, 397, 3, 2, 2, 2, 34, 422, 3, 2, 2,
	2, 36, 425, 3, 2, 2, 2, 38, 431, 3, 2, 2, 2, 40, 435, 3, 2, 2, 2, 42, 438,
	3, 2, 2, 2, 44, 442, 3, 2, 2, 2, 46, 445, 3, 2, 2, 2, 48, 464, 3, 2, 2,
	2, 50, 472, 3, 2, 2, 2, 52, 487, 3, 2, 2, 2, 54, 491, 3, 2, 2, 2, 56, 503,
	3, 2, 2, 2, 58, 513, 3, 2, 2, 2, 60, 524, 3, 2, 2, 2, 62, 549, 3, 2, 2,
	2, 64, 555, 3, 2, 2, 2, 66, 582, 3, 2, 2, 2, 68, 584, 3, 2, 2, 2, 70, 592,
	3, 2, 2, 2, 72, 596, 3, 2, 2, 2, 74, 632, 3, 2, 2, 2, 76, 634, 3, 2, 2,
	2, 78, 640, 3, 2, 2, 2, 80, 646, 3, 2, 2, 2, 82, 650, 3, 2, 2, 2, 84, 655,
	3, 2, 2, 2, 86, 660, 3, 2, 2, 2, 88, 665, 3, 2, 2, 2, 90, 734, 3, 2, 2,
	2, 92, 736, 3, 2, 2, 2, 94, 749, 3, 2, 2, 2, 96, 762, 3, 2, 2, 2, 98, 764,
	3, 2, 2, 2, 100, 793, 3, 2, 2, 2, 102, 795, 3, 2, 2, 2, 104, 806, 3, 2,
	2, 2, 106, 816, 3, 2, 2, 2, 108, 826, 3, 2, 2, 2, 110, 828, 3, 2, 2, 2,
	112, 834, 3, 2, 2, 2, 114, 848, 3, 2, 2, 2, 116, 862, 3, 2, 2, 2, 118,
	867, 3, 2, 2, 2, 120, 877, 3, 2, 2, 2, 122, 884, 3, 2, 2, 2, 124, 890,
	3, 2, 2, 2, 126, 904, 3, 2, 2, 2, 128, 937, 3, 2, 2, 2, 130, 939, 3, 2,
	2, 2, 132, 969, 3, 2, 2, 2, 134, 971, 3, 2, 2, 2, 136, 994, 3, 2, 2, 2,
	138, 997, 3, 2, 2, 2, 140, 1009, 3, 2, 2, 2, 142, 1019, 3, 2, 2, 2, 144,
	1031, 3, 2, 2, 2, 146, 1046, 3, 2, 2, 2, 148, 1067, 3, 2, 2, 2, 150, 1069,
	3, 2, 2, 2, 152, 1090, 3, 2, 2, 2, 154, 1092, 3, 2, 2, 2, 156, 1105, 3,
	2, 2, 2, 158, 1110, 3, 2, 2, 2, 160, 170, 5, 158, 80, 2, 161, 165, 5, 4,
	3, 2, 162, 164, 9, 2, 2, 2, 163, 162, 3, 2, 2, 2, 164, 167, 3, 2, 2, 2,
	165, 163, 3, 2, 2, 2, 165, 166, 3, 2, 2, 2, 166, 169, 3, 2, 2, 2, 167,
	165, 3, 2, 2, 2, 168, 161, 3, 2, 2, 2, 169, 172, 3, 2, 2, 2, 170, 168,
	3, 2, 2, 2, 170, 171, 3, 2, 2, 2, 171, 182, 3, 2, 2, 2, 172, 170, 3, 2,
	2, 2, 173, 177, 5, 6, 4, 2, 174, 176, 9, 2, 2, 2, 175, 174, 3, 2, 2, 2,
	176, 179, 3, 2, 2, 2, 177, 175, 3, 2, 2, 2, 177, 178, 3, 2, 2, 2, 178,
	181, 3, 2, 2, 2, 179, 177, 3, 2, 2, 2, 180, 173, 3, 2, 2, 2, 181, 184,
	3, 2, 2, 2, 182, 180, 3, 2, 2, 2, 182, 183, 3, 2, 2, 2, 183, 194, 3, 2,
	2, 2, 184, 182, 3, 2, 2, 2, 185, 189, 5, 8, 5, 2, 186, 188, 9, 2, 2, 2,
	187, 186, 3, 2, 2, 2, 188, 191, 3, 2, 2, 2, 189, 187, 3, 2, 2, 2, 189,
	190, 3, 2, 2, 2, 190, 193, 3, 2, 2, 2, 191, 189, 3, 2, 2, 2, 192, 185,
	3, 2, 2, 2, 193, 196, 3, 2, 2, 2, 194, 192, 3, 2, 2, 2, 194, 195, 3, 2,
	2, 2, 195, 206, 3, 2, 2, 2, 196, 194, 3, 2, 2, 2, 197, 201, 5, 100, 51,
	2, 198, 200, 9, 2, 2, 2, 199, 198, 3, 2, 2, 2, 200, 203, 3, 2, 2, 2, 201,
	199, 3, 2, 2, 2, 201, 202, 3, 2, 2, 2, 202, 205, 3, 2, 2, 2, 203, 201,
	3, 2, 2, 2, 204, 197, 3, 2, 2, 2, 205, 208, 3, 2, 2, 2, 206, 204, 3, 2,
	2, 2, 206, 207, 3, 2, 2, 2, 207, 3, 3, 2, 2, 2, 208, 206, 3, 2, 2, 2, 209,
	210, 7, 29, 2, 2, 210, 211, 5, 158, 80, 2, 211, 212, 7, 46, 2, 2, 212,
	213, 5, 158, 80, 2, 213, 214, 7, 3, 2, 2, 214, 215, 5, 158, 80, 2, 215,
	222, 3, 2, 2, 2, 216, 217, 7, 29, 2, 2, 217, 218, 5, 158, 80, 2, 218, 219,
	7, 46, 2, 2, 219, 220, 5, 158, 80, 2, 220, 222, 3, 2, 2, 2, 221, 209, 3,
	2, 2, 2, 221, 216, 3, 2, 2, 2, 222, 5, 3, 2, 2, 2, 223, 224, 7, 25, 2,
	2, 224, 225, 5, 158, 80, 2, 225, 226, 9, 3, 2, 2, 226, 227, 5, 158, 80,
	2, 227, 228, 5, 14, 8, 2, 228, 229, 7, 3, 2, 2, 229, 230, 5, 158, 80, 2,
	230, 250, 3, 2, 2, 2, 231, 232, 7, 25, 2, 2, 232, 233, 5, 158, 80, 2, 233,
	234, 9, 3, 2, 2, 234, 235, 5, 158, 80, 2, 235, 236, 7, 3, 2, 2, 236, 237,
	5, 158, 80, 2, 237, 250, 3, 2, 2, 2, 238, 239, 7, 25, 2, 2, 239, 240, 5,
	158, 80, 2, 240, 241, 9, 3, 2, 2, 241, 242, 5, 158, 80, 2, 242, 243, 5,
	14, 8, 2, 243, 250, 3, 2, 2, 2, 244, 245, 7, 25, 2, 2, 245, 246, 5, 158,
	80, 2, 246, 247, 9, 3, 2, 2, 247, 248, 5, 158, 80, 2, 248, 250, 3, 2, 2,
	2, 249, 223, 3, 2, 2, 2, 249, 231, 3, 2, 2, 2, 249, 238, 3, 2, 2, 2, 249,
	244, 3, 2, 2, 2, 250, 7, 3, 2, 2, 2, 251, 252, 7, 28, 2, 2, 252, 256, 5,
	158, 80, 2, 253, 254, 5, 10, 6, 2, 254, 255, 5, 158, 80, 2, 255, 257, 3,
	2, 2, 2, 256, 253, 3, 2, 2, 2, 256, 257, 3, 2, 2, 2, 257, 258, 3, 2, 2,
	2, 258, 259, 9, 3, 2, 2, 259, 260, 5, 158, 80, 2, 260, 261, 7, 3, 2, 2,
	261, 262, 5, 158, 80, 2, 262, 274, 3, 2, 2, 2, 263, 264, 7, 28, 2, 2, 264,
	268, 5, 158, 80, 2, 265, 266, 5, 10, 6, 2, 266, 267, 5, 158, 80, 2, 267,
	269, 3, 2, 2, 2, 268, 265, 3, 2, 2, 2, 268, 269, 3, 2, 2, 2, 269, 270,
	3, 2, 2, 2, 270, 271, 9, 3, 2, 2, 271, 272, 5, 158, 80, 2, 272, 274, 3,
	2, 2, 2, 273, 251, 3, 2, 2, 2, 273, 263, 3, 2, 2, 2, 274, 9, 3, 2, 2, 2,
	275, 276, 5, 156, 79, 2, 276, 11, 3, 2, 2, 2, 277, 278, 7, 27, 2, 2, 278,
	279, 5, 158, 80, 2, 279, 280, 5, 14, 8, 2, 280, 281, 5, 102, 52, 2, 281,
	282, 5, 158, 80, 2, 282, 13, 3, 2, 2, 2, 283, 290, 5, 16, 9, 2, 284, 285,
	7, 42, 2, 2, 285, 286, 5, 158, 80, 2, 286, 287, 5, 16, 9, 2, 287, 289,
	3, 2, 2, 2, 288, 284, 3, 2, 2, 2, 289, 292, 3, 2, 2, 2, 290, 288, 3, 2,
	2, 2, 290, 291, 3, 2, 2, 2, 291, 294, 3, 2, 2, 2, 292, 290, 3, 2, 2, 2,
	293, 283, 3, 2, 2, 2, 293, 294, 3, 2, 2, 2, 294, 295, 3, 2, 2, 2, 295,
	296, 5, 158, 80, 2, 296, 15, 3, 2, 2, 2, 297, 299, 9, 4, 2, 2, 298, 297,
	3, 2, 2, 2, 298, 299, 3, 2, 2, 2, 299, 300, 3, 2, 2, 2, 300, 301, 5, 158,
	80, 2, 301, 302, 5, 18, 10, 2, 302, 309, 5, 158, 80, 2, 303, 304, 7, 36,
	2, 2, 304, 305, 5, 158, 80, 2, 305, 306, 5, 20, 11, 2, 306, 308, 3, 2,
	2, 2, 307, 303, 3, 2, 2, 2, 308, 311, 3, 2, 2, 2, 309, 307, 3, 2, 2, 2,
	309, 310, 3, 2, 2, 2, 310, 323, 3, 2, 2, 2, 311, 309, 3, 2, 2, 2, 312,
	319, 5, 20, 11, 2, 313, 314, 7, 36, 2, 2, 314, 315, 5, 158, 80, 2, 315,
	316, 5, 20, 11, 2, 316, 318, 3, 2, 2, 2, 317, 313, 3, 2, 2, 2, 318, 321,
	3, 2, 2, 2, 319, 317, 3, 2, 2, 2, 319, 320, 3, 2, 2, 2, 320, 323, 3, 2,
	2, 2, 321, 319, 3, 2, 2, 2, 322, 298, 3, 2, 2, 2, 322, 312, 3, 2, 2, 2,
	323, 17, 3, 2, 2, 2, 324, 325, 5, 156, 79, 2, 325, 19, 3, 2, 2, 2, 326,
	327, 7, 4, 2, 2, 327, 328, 5, 158, 80, 2, 328, 333, 5, 22, 12, 2, 329,
	330, 7, 5, 2, 2, 330, 331, 5, 158, 80, 2, 331, 332, 5, 72, 37, 2, 332,
	334, 3, 2, 2, 2, 333, 329, 3, 2, 2, 2, 333, 334, 3, 2, 2, 2, 334, 335,
	3, 2, 2, 2, 335, 336, 7, 6, 2, 2, 336, 337, 5, 158, 80, 2, 337, 21, 3,
	2, 2, 2, 338, 339, 5, 156, 79, 2, 339, 340, 5, 158, 80, 2, 340, 23, 3,
	2, 2, 2, 341, 342, 7, 26, 2, 2, 342, 344, 5, 158, 80, 2, 343, 345, 5, 26,
	14, 2, 344, 343, 3, 2, 2, 2, 344, 345, 3, 2, 2, 2, 345, 346, 3, 2, 2, 2,
	346, 347, 7, 7, 2, 2, 347, 349, 5, 158, 80, 2, 348, 350, 5, 66, 34, 2,
	349, 348, 3, 2, 2, 2, 349, 350, 3, 2, 2, 2, 350, 358, 3, 2, 2, 2, 351,
	352, 7, 3, 2, 2, 352, 354, 5, 158, 80, 2, 353, 355, 5, 66, 34, 2, 354,
	353, 3, 2, 2, 2, 354, 355, 3, 2, 2, 2, 355, 357, 3, 2, 2, 2, 356, 351,
	3, 2, 2, 2, 357, 360, 3, 2, 2, 2, 358, 356, 3, 2, 2, 2, 358, 359, 3, 2,
	2, 2, 359, 361, 3, 2, 2, 2, 360, 358, 3, 2, 2, 2, 361, 362, 7, 8, 2, 2,
	362, 363, 5, 158, 80, 2, 363, 25, 3, 2, 2, 2, 364, 365, 7, 5, 2, 2, 365,
	366, 5, 156, 79, 2, 366, 367, 5, 158, 80, 2, 367, 27, 3, 2, 2, 2, 368,
	375, 5, 30, 16, 2, 369, 370, 7, 42, 2, 2, 370, 371, 5, 158, 80, 2, 371,
	372, 5, 30, 16, 2, 372, 374, 3, 2, 2, 2, 373, 369, 3, 2, 2, 2, 374, 377,
	3, 2, 2, 2, 375, 373, 3, 2, 2, 2, 375, 376, 3, 2, 2, 2, 376, 29, 3, 2,
	2, 2, 377, 375, 3, 2, 2, 2, 378, 379, 5, 34, 18, 2, 379, 386, 5, 158, 80,
	2, 380, 381, 5, 32, 17, 2, 381, 382, 5, 34, 18, 2, 382, 383, 5, 158, 80,
	2, 383, 385, 3, 2, 2, 2, 384, 380, 3, 2, 2, 2, 385, 388, 3, 2, 2, 2, 386,
	384, 3, 2, 2, 2, 386, 387, 3, 2, 2, 2, 387, 31, 3, 2, 2, 2, 388, 386, 3,
	2, 2, 2, 389, 390, 7, 39, 2, 2, 390, 398, 5, 158, 80, 2, 391, 392, 7, 41,
	2, 2, 392, 398, 5, 158, 80, 2, 393, 394, 7, 43, 2, 2, 394, 398, 5, 158,
	80, 2, 395, 396, 7, 19, 2, 2, 396, 398, 5, 158, 80, 2, 397, 389, 3, 2,
	2, 2, 397, 391, 3, 2, 2, 2, 397, 393, 3, 2, 2, 2, 397, 395, 3, 2, 2, 2,
	398, 33, 3, 2, 2, 2, 399, 402, 5, 36, 19, 2, 400, 402, 5, 42, 22, 2, 401,
	399, 3, 2, 2, 2, 401, 400, 3, 2, 2, 2, 402, 410, 3, 2, 2, 2, 403, 409,
	7, 24, 2, 2, 404, 409, 5, 44, 23, 2, 405, 409, 5, 46, 24, 2, 406, 409,
	5, 48, 25, 2, 407, 409, 5, 54, 28, 2, 408, 403, 3, 2, 2, 2, 408, 404, 3,
	2, 2, 2, 408, 405, 3, 2, 2, 2, 408, 406, 3, 2, 2, 2, 408, 407, 3, 2, 2,
	2, 409, 412, 3, 2, 2, 2, 410, 408, 3, 2, 2, 2, 410, 411, 3, 2, 2, 2, 411,
	423, 3, 2, 2, 2, 412, 410, 3, 2, 2, 2, 413, 419, 7, 24, 2, 2, 414, 419,
	5, 44, 23, 2, 415, 419, 5, 46, 24, 2, 416, 419, 5, 48, 25, 2, 417, 419,
	5, 54, 28, 2, 418, 413, 3, 2, 2, 2, 418, 414, 3, 2, 2, 2, 418, 415, 3,
	2, 2, 2, 418, 416, 3, 2, 2, 2, 418, 417, 3, 2, 2, 2, 419, 420, 3, 2, 2,
	2, 420, 418, 3, 2, 2, 2, 420, 421, 3, 2, 2, 2, 421, 423, 3, 2, 2, 2, 422,
	401, 3, 2, 2, 2, 422, 418, 3, 2, 2, 2, 423, 35, 3, 2, 2, 2, 424, 426, 5,
	38, 20, 2, 425, 424, 3, 2, 2, 2, 425, 426, 3, 2, 2, 2, 426, 427, 3, 2,
	2, 2, 427, 428, 5, 40, 21, 2, 428, 37, 3, 2, 2, 2, 429, 432, 5, 156, 79,
	2, 430, 432, 7, 9, 2, 2, 431, 429, 3, 2, 2, 2, 431, 430, 3, 2, 2, 2, 431,
	432, 3, 2, 2, 2, 432, 433, 3, 2, 2, 2, 433, 434, 7, 10, 2, 2, 434, 39,
	3, 2, 2, 2, 435, 436, 5, 156, 79, 2, 436, 41, 3, 2, 2, 2, 437, 439, 5,
	38, 20, 2, 438, 437, 3, 2, 2, 2, 438, 439, 3, 2, 2, 2, 439, 440, 3, 2,
	2, 2, 440, 441, 7, 9, 2, 2, 441, 43, 3, 2, 2, 2, 442, 443, 7, 11, 2, 2,
	443, 444, 5, 156, 79, 2, 444, 45, 3, 2, 2, 2, 445, 446, 7, 12, 2, 2, 446,
	448, 5, 158, 80, 2, 447, 449, 5, 38, 20, 2, 448, 447, 3, 2, 2, 2, 448,
	449, 3, 2, 2, 2, 449, 450, 3, 2, 2, 2, 450, 451, 5, 156, 79, 2, 451, 460,
	5, 158, 80, 2, 452, 453, 9, 5, 2, 2, 453, 456, 5, 158, 80, 2, 454, 457,
	5, 156, 79, 2, 455, 457, 7, 46, 2, 2, 456, 454, 3, 2, 2, 2, 456, 455, 3,
	2, 2, 2, 457, 458, 3, 2, 2, 2, 458, 459, 5, 158, 80, 2, 459, 461, 3, 2,
	2, 2, 460, 452, 3, 2, 2, 2, 460, 461, 3, 2, 2, 2, 461, 462, 3, 2, 2, 2,
	462, 463, 7, 14, 2, 2, 463, 47, 3, 2, 2, 2, 464, 466, 7, 5, 2, 2, 465,
	467, 7, 5, 2, 2, 466, 465, 3, 2, 2, 2, 466, 467, 3, 2, 2, 2, 467, 470,
	3, 2, 2, 2, 468, 471, 5, 156, 79, 2, 469, 471, 5, 50, 26, 2, 470, 468,
	3, 2, 2, 2, 470, 469, 3, 2, 2, 2, 471, 49, 3, 2, 2, 2, 472, 473, 7, 64,
	2, 2, 473, 474, 5, 158, 80, 2, 474, 475, 5, 52, 27, 2, 475, 476, 7, 6,
	2, 2, 476, 51, 3, 2, 2, 2, 477, 485, 7, 39, 2, 2, 478, 485, 7, 40, 2, 2,
	479, 485, 7, 37, 2, 2, 480, 485, 7, 38, 2, 2, 481, 485, 7, 45, 2, 2, 482,
	485, 7, 46, 2, 2, 483, 485, 5, 156, 79, 2, 484, 477, 3, 2, 2, 2, 484, 478,
	3, 2, 2, 2, 484, 479, 3, 2, 2, 2, 484, 480, 3, 2, 2, 2, 484, 481, 3, 2,
	2, 2, 484, 482, 3, 2, 2, 2, 484, 483, 3, 2, 2, 2, 485, 486, 3, 2, 2, 2,
	486, 488, 5, 158, 80, 2, 487, 484, 3, 2, 2, 2, 488, 489, 3, 2, 2, 2, 489,
	487, 3, 2, 2, 2, 489, 490, 3, 2, 2, 2, 490, 53, 3, 2, 2, 2, 491, 492, 7,
	44, 2, 2, 492, 493, 5, 158, 80, 2, 493, 494, 5, 56, 29, 2, 494, 495, 5,
	158, 80, 2, 495, 496, 7, 6, 2, 2, 496, 55, 3, 2, 2, 2, 497, 504, 5, 36,
	19, 2, 498, 504, 5, 42, 22, 2, 499, 504, 7, 24, 2, 2, 500, 504, 5, 44,
	23, 2, 501, 504, 5, 46, 24, 2, 502, 504, 5, 48, 25, 2, 503, 497, 3, 2,
	2, 2, 503, 498, 3, 2, 2, 2, 503, 499, 3, 2, 2, 2, 503, 500, 3, 2, 2, 2,
	503, 501, 3, 2, 2, 2, 503, 502, 3, 2, 2, 2, 504, 57, 3, 2, 2, 2, 505, 506,
	7, 15, 2, 2, 506, 514, 5, 158, 80, 2, 507, 508, 7, 42, 2, 2, 508, 514,
	5, 158, 80, 2, 509, 510, 7, 19, 2, 2, 510, 514, 5, 158, 80, 2, 511, 512,
	7, 13, 2, 2, 512, 514, 5, 158, 80, 2, 513, 505, 3, 2, 2, 2, 513, 507, 3,
	2, 2, 2, 513, 509, 3, 2, 2, 2, 513, 511, 3, 2, 2, 2, 514, 59, 3, 2, 2,
	2, 515, 516, 5, 156, 79, 2, 516, 517, 5, 158, 80, 2, 517, 525, 3, 2, 2,
	2, 518, 519, 7, 61, 2, 2, 519, 525, 5, 158, 80, 2, 520, 521, 7, 9, 2, 2,
	521, 525, 5, 156, 79, 2, 522, 523, 7, 16, 2, 2, 523, 525, 5, 156, 79, 2,
	524, 515, 3, 2, 2, 2, 524, 518, 3, 2, 2, 2, 524, 520, 3, 2, 2, 2, 524,
	522, 3, 2, 2, 2, 525, 61, 3, 2, 2, 2, 526, 527, 5, 28, 15, 2, 527, 528,
	7, 7, 2, 2, 528, 530, 5, 158, 80, 2, 529, 531, 5, 64, 33, 2, 530, 529,
	3, 2, 2, 2, 530, 531, 3, 2, 2, 2, 531, 532, 3, 2, 2, 2, 532, 533, 7, 8,
	2, 2, 533, 534, 5, 158, 80, 2, 534, 550, 3, 2, 2, 2, 535, 537, 5, 90, 46,
	2, 536, 535, 3, 2, 2, 2, 537, 540, 3, 2, 2, 2, 538, 536, 3, 2, 2, 2, 538,
	539, 3, 2, 2, 2, 539, 541, 3, 2, 2, 2, 540, 538, 3, 2, 2, 2, 541, 542,
	7, 7, 2, 2, 542, 544, 5, 158, 80, 2, 543, 545, 5, 64, 33, 2, 544, 543,
	3, 2, 2, 2, 544, 545, 3, 2, 2, 2, 545, 546, 3, 2, 2, 2, 546, 547, 7, 8,
	2, 2, 547, 548, 5, 158, 80, 2, 548, 550, 3, 2, 2, 2, 549, 526, 3, 2, 2,
	2, 549, 538, 3, 2, 2, 2, 550, 63, 3, 2, 2, 2, 551, 552, 7, 3, 2, 2, 552,
	554, 5, 158, 80, 2, 553, 551, 3, 2, 2, 2, 554, 557, 3, 2, 2, 2, 555, 553,
	3, 2, 2, 2, 555, 556, 3, 2, 2, 2, 556, 558, 3, 2, 2, 2, 557, 555, 3, 2,
	2, 2, 558, 559, 5, 66, 34, 2, 559, 567, 5, 158, 80, 2, 560, 561, 7, 3,
	2, 2, 561, 563, 5, 158, 80, 2, 562, 564, 5, 66, 34, 2, 563, 562, 3, 2,
	2, 2, 563, 564, 3, 2, 2, 2, 564, 566, 3, 2, 2, 2, 565, 560, 3, 2, 2, 2,
	566, 569, 3, 2, 2, 2, 567, 565, 3, 2, 2, 2, 567, 568, 3, 2, 2, 2, 568,
	65, 3, 2, 2, 2, 569, 567, 3, 2, 2, 2, 570, 571, 5, 60, 31, 2, 571, 572,
	7, 5, 2, 2, 572, 573, 5, 158, 80, 2, 573, 575, 5, 72, 37, 2, 574, 576,
	5, 68, 35, 2, 575, 574, 3, 2, 2, 2, 575, 576, 3, 2, 2, 2, 576, 583, 3,
	2, 2, 2, 577, 578, 5, 60, 31, 2, 578, 579, 7, 5, 2, 2, 579, 580, 5, 158,
	80, 2, 580, 581, 5, 70, 36, 2, 581, 583, 3, 2, 2, 2, 582, 570, 3, 2, 2,
	2, 582, 577, 3, 2, 2, 2, 583, 67, 3, 2, 2, 2, 584, 585, 7, 30, 2, 2, 585,
	586, 5, 158, 80, 2, 586, 69, 3, 2, 2, 2, 587, 593, 5, 90, 46, 2, 588, 593,
	5, 98, 50, 2, 589, 590, 5, 94, 48, 2, 590, 591, 5, 158, 80, 2, 591, 593,
	3, 2, 2, 2, 592, 587, 3, 2, 2, 2, 592, 588, 3, 2, 2, 2, 592, 589, 3, 2,
	2, 2, 593, 594, 3, 2, 2, 2, 594, 592, 3, 2, 2, 2, 594, 595, 3, 2, 2, 2,
	595, 71, 3, 2, 2, 2, 596, 603, 5, 74, 38, 2, 597, 599, 5, 58, 30, 2, 598,
	597, 3, 2, 2, 2, 598, 599, 3, 2, 2, 2, 599, 600, 3, 2, 2, 2, 600, 602,
	5, 74, 38, 2, 601, 598, 3, 2, 2, 2, 602, 605, 3, 2, 2, 2, 603, 601, 3,
	2, 2, 2, 603, 604, 3, 2, 2, 2, 604, 73, 3, 2, 2, 2, 605, 603, 3, 2, 2,
	2, 606, 607, 5, 82, 42, 2, 607, 608, 5, 158, 80, 2, 608, 633, 3, 2, 2,
	2, 609, 610, 5, 84, 43, 2, 610, 611, 5, 158, 80, 2, 611, 633, 3, 2, 2,
	2, 612, 613, 5, 86, 44, 2, 613, 614, 5, 158, 80, 2, 614, 633, 3, 2, 2,
	2, 615, 616, 7, 46, 2, 2, 616, 633, 5, 158, 80, 2, 617, 618, 7, 33, 2,
	2, 618, 633, 5, 158, 80, 2, 619, 620, 5, 156, 79, 2, 620, 621, 5, 158,
	80, 2, 621, 633, 3, 2, 2, 2, 622, 633, 5, 120, 61, 2, 623, 624, 7, 32,
	2, 2, 624, 633, 5, 158, 80, 2, 625, 633, 5, 80, 41, 2, 626, 633, 5, 122,
	62, 2, 627, 633, 5, 76, 39, 2, 628, 629, 5, 88, 45, 2, 629, 630, 5, 158,
	80, 2, 630, 633, 3, 2, 2, 2, 631, 633, 5, 78, 40, 2, 632, 606, 3, 2, 2,
	2, 632, 609, 3, 2, 2, 2, 632, 612, 3, 2, 2, 2, 632, 615, 3, 2, 2, 2, 632,
	617, 3, 2, 2, 2, 632, 619, 3, 2, 2, 2, 632, 622, 3, 2, 2, 2, 632, 623,
	3, 2, 2, 2, 632, 625, 3, 2, 2, 2, 632, 626, 3, 2, 2, 2, 632, 627, 3, 2,
	2, 2, 632, 628, 3, 2, 2, 2, 632, 631, 3, 2, 2, 2, 633, 75, 3, 2, 2, 2,
	634, 635, 7, 64, 2, 2, 635, 636, 5, 158, 80, 2, 636, 637, 5, 72, 37, 2,
	637, 638, 7, 6, 2, 2, 638, 639, 5, 158, 80, 2, 639, 77, 3, 2, 2, 2, 640,
	641, 7, 60, 2, 2, 641, 642, 5, 158, 80, 2, 642, 643, 5, 72, 37, 2, 643,
	644, 7, 6, 2, 2, 644, 645, 5, 158, 80, 2, 645, 79, 3, 2, 2, 2, 646, 647,
	7, 24, 2, 2, 647, 648, 5, 158, 80, 2, 648, 81, 3, 2, 2, 2, 649, 651, 9,
	6, 2, 2, 650, 649, 3, 2, 2, 2, 650, 651, 3, 2, 2, 2, 651, 652, 3, 2, 2,
	2, 652, 653, 7, 45, 2, 2, 653, 83, 3, 2, 2, 2, 654, 656, 9, 6, 2, 2, 655,
	654, 3, 2, 2, 2, 655, 656, 3, 2, 2, 2, 656, 657, 3, 2, 2, 2, 657, 658,
	7, 31, 2, 2, 658, 85, 3, 2, 2, 2, 659, 661, 9, 6, 2, 2, 660, 659, 3, 2,
	2, 2, 660, 661, 3, 2, 2, 2, 661, 662, 3, 2, 2, 2, 662, 663, 7, 37, 2, 2,
	663, 87, 3, 2, 2, 2, 664, 666, 9, 6, 2, 2, 665, 664, 3, 2, 2, 2, 665, 666,
	3, 2, 2, 2, 666, 667, 3, 2, 2, 2, 667, 668, 7, 38, 2, 2, 668, 89, 3, 2,
	2, 2, 669, 670, 5, 156, 79, 2, 670, 671, 5, 158, 80, 2, 671, 735, 3, 2,
	2, 2, 672, 673, 5, 82, 42, 2, 673, 674, 5, 158, 80, 2, 674, 735, 3, 2,
	2, 2, 675, 676, 5, 84, 43, 2, 676, 677, 5, 158, 80, 2, 677, 735, 3, 2,
	2, 2, 678, 679, 5, 86, 44, 2, 679, 680, 5, 158, 80, 2, 680, 735, 3, 2,
	2, 2, 681, 682, 5, 88, 45, 2, 682, 683, 5, 158, 80, 2, 683, 735, 3, 2,
	2, 2, 684, 685, 7, 46, 2, 2, 685, 735, 5, 158, 80, 2, 686, 687, 7, 32,
	2, 2, 687, 735, 5, 158, 80, 2, 688, 689, 7, 24, 2, 2, 689, 735, 5, 158,
	80, 2, 690, 691, 7, 33, 2, 2, 691, 735, 5, 158, 80, 2, 692, 693, 7, 22,
	2, 2, 693, 735, 5, 158, 80, 2, 694, 695, 7, 23, 2, 2, 695, 735, 5, 158,
	80, 2, 696, 697, 7, 5, 2, 2, 697, 735, 5, 158, 80, 2, 698, 699, 7, 64,
	2, 2, 699, 704, 5, 158, 80, 2, 700, 703, 5, 90, 46, 2, 701, 703, 5, 96,
	49, 2, 702, 700, 3, 2, 2, 2, 702, 701, 3, 2, 2, 2, 703, 706, 3, 2, 2, 2,
	704, 702, 3, 2, 2, 2, 704, 705, 3, 2, 2, 2, 705, 707, 3, 2, 2, 2, 706,
	704, 3, 2, 2, 2, 707, 708, 7, 6, 2, 2, 708, 709, 5, 158, 80, 2, 709, 735,
	3, 2, 2, 2, 710, 711, 7, 4, 2, 2, 711, 716, 5, 158, 80, 2, 712, 715, 5,
	90, 46, 2, 713, 715, 5, 96, 49, 2, 714, 712, 3, 2, 2, 2, 714, 713, 3, 2,
	2, 2, 715, 718, 3, 2, 2, 2, 716, 714, 3, 2, 2, 2, 716, 717, 3, 2, 2, 2,
	717, 719, 3, 2, 2, 2, 718, 716, 3, 2, 2, 2, 719, 720, 7, 6, 2, 2, 720,
	721, 5, 158, 80, 2, 721, 735, 3, 2, 2, 2, 722, 723, 7, 12, 2, 2, 723, 728,
	5, 158, 80, 2, 724, 727, 5, 90, 46, 2, 725, 727, 5, 96, 49, 2, 726, 724,
	3, 2, 2, 2, 726, 725, 3, 2, 2, 2, 727, 730, 3, 2, 2, 2, 728, 726, 3, 2,
	2, 2, 728, 729, 3, 2, 2, 2, 729, 731, 3, 2, 2, 2, 730, 728, 3, 2, 2, 2,
	731, 732, 7, 14, 2, 2, 732, 733, 5, 158, 80, 2, 733, 735, 3, 2, 2, 2, 734,
	669, 3, 2, 2, 2, 734, 672, 3, 2, 2, 2, 734, 675, 3, 2, 2, 2, 734, 678,
	3, 2, 2, 2, 734, 681, 3, 2, 2, 2, 734, 684, 3, 2, 2, 2, 734, 686, 3, 2,
	2, 2, 734, 688, 3, 2, 2, 2, 734, 690, 3, 2, 2, 2, 734, 692, 3, 2, 2, 2,
	734, 694, 3, 2, 2, 2, 734, 696, 3, 2, 2, 2, 734, 698, 3, 2, 2, 2, 734,
	710, 3, 2, 2, 2, 734, 722, 3, 2, 2, 2, 735, 91, 3, 2, 2, 2, 736, 737, 5,
	94, 48, 2, 737, 741, 5, 158, 80, 2, 738, 740, 5, 90, 46, 2, 739, 738, 3,
	2, 2, 2, 740, 743, 3, 2, 2, 2, 741, 739, 3, 2, 2, 2, 741, 742, 3, 2, 2,
	2, 742, 747, 3, 2, 2, 2, 743, 741, 3, 2, 2, 2, 744, 748, 5, 98, 50, 2,
	745, 746, 7, 3, 2, 2, 746, 748, 5, 158, 80, 2, 747, 744, 3, 2, 2, 2, 747,
	745, 3, 2, 2, 2, 748, 93, 3, 2, 2, 2, 749, 750, 7, 17, 2, 2, 750, 751,
	5, 156, 79, 2, 751, 95, 3, 2, 2, 2, 752, 763, 5, 98, 50, 2, 753, 754, 5,
	94, 48, 2, 754, 755, 5, 158, 80, 2, 755, 763, 3, 2, 2, 2, 756, 757, 7,
	3, 2, 2, 757, 763, 5, 158, 80, 2, 758, 759, 7, 20, 2, 2, 759, 763, 5, 158,
	80, 2, 760, 761, 7, 21, 2, 2, 761, 763, 5, 158, 80, 2, 762, 752, 3, 2,
	2, 2, 762, 753, 3, 2, 2, 2, 762, 756, 3, 2, 2, 2, 762, 758, 3, 2, 2, 2,
	762, 760, 3, 2, 2, 2, 763, 97, 3, 2, 2, 2, 764, 765, 7, 7, 2, 2, 765, 777,
	5, 158, 80, 2, 766, 776, 5, 64, 33, 2, 767, 776, 5, 100, 51, 2, 768, 776,
	5, 90, 46, 2, 769, 776, 5, 98, 50, 2, 770, 771, 5, 94, 48, 2, 771, 772,
	5, 158, 80, 2, 772, 776, 3, 2, 2, 2, 773, 774, 7, 3, 2, 2, 774, 776, 5,
	158, 80, 2, 775, 766, 3, 2, 2, 2, 775, 767, 3, 2, 2, 2, 775, 768, 3, 2,
	2, 2, 775, 769, 3, 2, 2, 2, 775, 770, 3, 2, 2, 2, 775, 773, 3, 2, 2, 2,
	776, 779, 3, 2, 2, 2, 777, 775, 3, 2, 2, 2, 777, 778, 3, 2, 2, 2, 778,
	780, 3, 2, 2, 2, 779, 777, 3, 2, 2, 2, 780, 781, 7, 8, 2, 2, 781, 782,
	5, 158, 80, 2, 782, 99, 3, 2, 2, 2, 783, 794, 5, 62, 32, 2, 784, 794, 5,
	12, 7, 2, 785, 794, 5, 24, 13, 2, 786, 794, 5, 130, 66, 2, 787, 794, 5,
	134, 68, 2, 788, 794, 5, 104, 53, 2, 789, 794, 5, 140, 71, 2, 790, 794,
	5, 142, 72, 2, 791, 794, 5, 144, 73, 2, 792, 794, 5, 92, 47, 2, 793, 783,
	3, 2, 2, 2, 793, 784, 3, 2, 2, 2, 793, 785, 3, 2, 2, 2, 793, 786, 3, 2,
	2, 2, 793, 787, 3, 2, 2, 2, 793, 788, 3, 2, 2, 2, 793, 789, 3, 2, 2, 2,
	793, 790, 3, 2, 2, 2, 793, 791, 3, 2, 2, 2, 793, 792, 3, 2, 2, 2, 794,
	101, 3, 2, 2, 2, 795, 796, 7, 7, 2, 2, 796, 800, 5, 158, 80, 2, 797, 799,
	5, 100, 51, 2, 798, 797, 3, 2, 2, 2, 799, 802, 3, 2, 2, 2, 800, 798, 3,
	2, 2, 2, 800, 801, 3, 2, 2, 2, 801, 803, 3, 2, 2, 2, 802, 800, 3, 2, 2,
	2, 803, 804, 7, 8, 2, 2, 804, 805, 5, 158, 80, 2, 805, 103, 3, 2, 2, 2,
	806, 807, 7, 51, 2, 2, 807, 808, 5, 158, 80, 2, 808, 809, 5, 106, 54, 2,
	809, 810, 5, 158, 80, 2, 810, 811, 5, 102, 52, 2, 811, 105, 3, 2, 2, 2,
	812, 817, 5, 110, 56, 2, 813, 817, 5, 112, 57, 2, 814, 817, 5, 114, 58,
	2, 815, 817, 5, 108, 55, 2, 816, 812, 3, 2, 2, 2, 816, 813, 3, 2, 2, 2,
	816, 814, 3, 2, 2, 2, 816, 815, 3, 2, 2, 2, 817, 107, 3, 2, 2, 2, 818,
	819, 7, 4, 2, 2, 819, 820, 5, 158, 80, 2, 820, 821, 5, 106, 54, 2, 821,
	822, 5, 158, 80, 2, 822, 823, 7, 6, 2, 2, 823, 827, 3, 2, 2, 2, 824, 827,
	5, 116, 59, 2, 825, 827, 5, 118, 60, 2, 826, 818, 3, 2, 2, 2, 826, 824,
	3, 2, 2, 2, 826, 825, 3, 2, 2, 2, 827, 109, 3, 2, 2, 2, 828, 829, 7, 35,
	2, 2, 829, 830, 5, 158, 80, 2, 830, 831, 7, 19, 2, 2, 831, 832, 5, 158,
	80, 2, 832, 833, 5, 108, 55, 2, 833, 111, 3, 2, 2, 2, 834, 844, 5, 108,
	55, 2, 835, 836, 5, 158, 80, 2, 836, 837, 7, 19, 2, 2, 837, 838, 5, 158,
	80, 2, 838, 839, 7, 36, 2, 2, 839, 840, 5, 158, 80, 2, 840, 841, 7, 19,
	2, 2, 841, 842, 5, 158, 80, 2, 842, 843, 5, 108, 55, 2, 843, 845, 3, 2,
	2, 2, 844, 835, 3, 2, 2, 2, 845, 846, 3, 2, 2, 2, 846, 844, 3, 2, 2, 2,
	846, 847, 3, 2, 2, 2, 847, 113, 3, 2, 2, 2, 848, 858, 5, 108, 55, 2, 849,
	850, 5, 158, 80, 2, 850, 851, 7, 19, 2, 2, 851, 852, 5, 158, 80, 2, 852,
	853, 7, 52, 2, 2, 853, 854, 5, 158, 80, 2, 854, 855, 7, 19, 2, 2, 855,
	856, 5, 158, 80, 2, 856, 857, 5, 108, 55, 2, 857, 859, 3, 2, 2, 2, 858,
	849, 3, 2, 2, 2, 859, 860, 3, 2, 2, 2, 860, 858, 3, 2, 2, 2, 860, 861,
	3, 2, 2, 2, 861, 115, 3, 2, 2, 2, 862, 863, 7, 4, 2, 2, 863, 864, 5, 158,
	80, 2, 864, 865, 5, 66, 34, 2, 865, 866, 7, 6, 2, 2, 866, 117, 3, 2, 2,
	2, 867, 872, 9, 7, 2, 2, 868, 871, 5, 90, 46, 2, 869, 871, 5, 96, 49, 2,
	870, 868, 3, 2, 2, 2, 870, 869, 3, 2, 2, 2, 871, 874, 3, 2, 2, 2, 872,
	870, 3, 2, 2, 2, 872, 873, 3, 2, 2, 2, 873, 875, 3, 2, 2, 2, 874, 872,
	3, 2, 2, 2, 875, 876, 7, 6, 2, 2, 876, 119, 3, 2, 2, 2, 877, 878, 7, 62,
	2, 2, 878, 879, 5, 158, 80, 2, 879, 880, 7, 61, 2, 2, 880, 881, 5, 158,
	80, 2, 881, 882, 7, 6, 2, 2, 882, 883, 5, 158, 80, 2, 883, 121, 3, 2, 2,
	2, 884, 885, 7, 56, 2, 2, 885, 886, 5, 158, 80, 2, 886, 887, 5, 124, 63,
	2, 887, 888, 7, 6, 2, 2, 888, 889, 5, 158, 80, 2, 889, 123, 3, 2, 2, 2,
	890, 901, 5, 126, 64, 2, 891, 892, 7, 19, 2, 2, 892, 893, 5, 158, 80, 2,
	893, 894, 9, 6, 2, 2, 894, 895, 5, 158, 80, 2, 895, 896, 7, 19, 2, 2, 896,
	897, 5, 158, 80, 2, 897, 898, 5, 126, 64, 2, 898, 900, 3, 2, 2, 2, 899,
	891, 3, 2, 2, 2, 900, 903, 3, 2, 2, 2, 901, 899, 3, 2, 2, 2, 901, 902,
	3, 2, 2, 2, 902, 125, 3, 2, 2, 2, 903, 901, 3, 2, 2, 2, 904, 916, 5, 128,
	65, 2, 905, 906, 7, 9, 2, 2, 906, 907, 5, 158, 80, 2, 907, 908, 5, 128,
	65, 2, 908, 915, 3, 2, 2, 2, 909, 910, 7, 15, 2, 2, 910, 911, 5, 158, 80,
	2, 911, 912, 5, 82, 42, 2, 912, 913, 5, 158, 80, 2, 913, 915, 3, 2, 2,
	2, 914, 905, 3, 2, 2, 2, 914, 909, 3, 2, 2, 2, 915, 918, 3, 2, 2, 2, 916,
	914, 3, 2, 2, 2, 916, 917, 3, 2, 2, 2, 917, 127, 3, 2, 2, 2, 918, 916,
	3, 2, 2, 2, 919, 920, 5, 82, 42, 2, 920, 921, 5, 158, 80, 2, 921, 938,
	3, 2, 2, 2, 922, 923, 5, 86, 44, 2, 923, 924, 5, 158, 80, 2, 924, 938,
	3, 2, 2, 2, 925, 926, 5, 88, 45, 2, 926, 927, 5, 158, 80, 2, 927, 938,
	3, 2, 2, 2, 928, 929, 5, 84, 43, 2, 929, 930, 5, 158, 80, 2, 930, 938,
	3, 2, 2, 2, 931, 932, 7, 4, 2, 2, 932, 933, 5, 158, 80, 2, 933, 934, 5,
	124, 63, 2, 934, 935, 7, 6, 2, 2, 935, 936, 5, 158, 80, 2, 936, 938, 3,
	2, 2, 2, 937, 919, 3, 2, 2, 2, 937, 922, 3, 2, 2, 2, 937, 925, 3, 2, 2,
	2, 937, 928, 3, 2, 2, 2, 937, 931, 3, 2, 2, 2, 938, 129, 3, 2, 2, 2, 939,
	940, 7, 50, 2, 2, 940, 941, 5, 158, 80, 2, 941, 942, 7, 7, 2, 2, 942, 944,
	5, 158, 80, 2, 943, 945, 5, 132, 67, 2, 944, 943, 3, 2, 2, 2, 944, 945,
	3, 2, 2, 2, 945, 953, 3, 2, 2, 2, 946, 947, 7, 3, 2, 2, 947, 949, 5, 158,
	80, 2, 948, 950, 5, 132, 67, 2, 949, 948, 3, 2, 2, 2, 949, 950, 3, 2, 2,
	2, 950, 952, 3, 2, 2, 2, 951, 946, 3, 2, 2, 2, 952, 955, 3, 2, 2, 2, 953,
	951, 3, 2, 2, 2, 953, 954, 3, 2, 2, 2, 954, 956, 3, 2, 2, 2, 955, 953,
	3, 2, 2, 2, 956, 957, 7, 8, 2, 2, 957, 958, 5, 158, 80, 2, 958, 131, 3,
	2, 2, 2, 959, 960, 5, 60, 31, 2, 960, 961, 7, 5, 2, 2, 961, 962, 5, 158,
	80, 2, 962, 963, 5, 72, 37, 2, 963, 970, 3, 2, 2, 2, 964, 965, 5, 60, 31,
	2, 965, 966, 7, 5, 2, 2, 966, 967, 5, 158, 80, 2, 967, 968, 5, 70, 36,
	2, 968, 970, 3, 2, 2, 2, 969, 959, 3, 2, 2, 2, 969, 964, 3, 2, 2, 2, 970,
	133, 3, 2, 2, 2, 971, 972, 7, 53, 2, 2, 972, 973, 5, 158, 80, 2, 973, 974,
	7, 19, 2, 2, 974, 975, 5, 158, 80, 2, 975, 976, 5, 156, 79, 2, 976, 977,
	5, 158, 80, 2, 977, 978, 7, 7, 2, 2, 978, 979, 5, 158, 80, 2, 979, 980,
	5, 136, 69, 2, 980, 981, 7, 8, 2, 2, 981, 982, 5, 158, 80, 2, 982, 135,
	3, 2, 2, 2, 983, 984, 5, 138, 70, 2, 984, 985, 7, 7, 2, 2, 985, 987, 5,
	158, 80, 2, 986, 988, 5, 64, 33, 2, 987, 986, 3, 2, 2, 2, 987, 988, 3,
	2, 2, 2, 988, 989, 3, 2, 2, 2, 989, 990, 7, 8, 2, 2, 990, 991, 5, 158,
	80, 2, 991, 993, 3, 2, 2, 2, 992, 983, 3, 2, 2, 2, 993, 996, 3, 2, 2, 2,
	994, 992, 3, 2, 2, 2, 994, 995, 3, 2, 2, 2, 995, 137, 3, 2, 2, 2, 996,
	994, 3, 2, 2, 2, 997, 998, 9, 8, 2, 2, 998, 1006, 5, 158, 80, 2, 999, 1000,
	7, 42, 2, 2, 1000, 1001, 5, 158, 80, 2, 1001, 1002, 9, 8, 2, 2, 1002, 1003,
	5, 158, 80, 2, 1003, 1005, 3, 2, 2, 2, 1004, 999, 3, 2, 2, 2, 1005, 1008,
	3, 2, 2, 2, 1006, 1004, 3, 2, 2, 2, 1006, 1007, 3, 2, 2, 2, 1007, 139,
	3, 2, 2, 2, 1008, 1006, 3, 2, 2, 2, 1009, 1010, 7, 57, 2, 2, 1010, 1011,
	5, 158, 80, 2, 1011, 1012, 7, 7, 2, 2, 1012, 1014, 5, 158, 80, 2, 1013,
	1015, 5, 64, 33, 2, 1014, 1013, 3, 2, 2, 2, 1014, 1015, 3, 2, 2, 2, 1015,
	1016, 3, 2, 2, 2, 1016, 1017, 7, 8, 2, 2, 1017, 1018, 5, 158, 80, 2, 1018,
	141, 3, 2, 2, 2, 1019, 1020, 7, 58, 2, 2, 1020, 1021, 5, 158, 80, 2, 1021,
	1022, 5, 156, 79, 2, 1022, 1023, 5, 158, 80, 2, 1023, 1024, 7, 7, 2, 2,
	1024, 1026, 5, 158, 80, 2, 1025, 1027, 5, 64, 33, 2, 1026, 1025, 3, 2,
	2, 2, 1026, 1027, 3, 2, 2, 2, 1027, 1028, 3, 2, 2, 2, 1028, 1029, 7, 8,
	2, 2, 1029, 1030, 5, 158, 80, 2, 1030, 143, 3, 2, 2, 2, 1031, 1032, 7,
	59, 2, 2, 1032, 1033, 5, 158, 80, 2, 1033, 1034, 5, 146, 74, 2, 1034, 1035,
	5, 158, 80, 2, 1035, 1036, 7, 7, 2, 2, 1036, 1040, 5, 158, 80, 2, 1037,
	1039, 5, 150, 76, 2, 1038, 1037, 3, 2, 2, 2, 1039, 1042, 3, 2, 2, 2, 1040,
	1038, 3, 2, 2, 2, 1040, 1041, 3, 2, 2, 2, 1041, 1043, 3, 2, 2, 2, 1042,
	1040, 3, 2, 2, 2, 1043, 1044, 7, 8, 2, 2, 1044, 1045, 5, 158, 80, 2, 1045,
	145, 3, 2, 2, 2, 1046, 1054, 5, 148, 75, 2, 1047, 1048, 5, 158, 80, 2,
	1048, 1049, 7, 42, 2, 2, 1049, 1050, 5, 158, 80, 2, 1050, 1051, 5, 148,
	75, 2, 1051, 1053, 3, 2, 2, 2, 1052, 1047, 3, 2, 2, 2, 1053, 1056, 3, 2,
	2, 2, 1054, 1052, 3, 2, 2, 2, 1054, 1055, 3, 2, 2, 2, 1055, 147, 3, 2,
	2, 2, 1056, 1054, 3, 2, 2, 2, 1057, 1068, 7, 46, 2, 2, 1058, 1064, 5, 156,
	79, 2, 1059, 1060, 5, 158, 80, 2, 1060, 1061, 5, 156, 79, 2, 1061, 1063,
	3, 2, 2, 2, 1062, 1059, 3, 2, 2, 2, 1063, 1066, 3, 2, 2, 2, 1064, 1062,
	3, 2, 2, 2, 1064, 1065, 3, 2, 2, 2, 1065, 1068, 3, 2, 2, 2, 1066, 1064,
	3, 2, 2, 2, 1067, 1057, 3, 2, 2, 2, 1067, 1058, 3, 2, 2, 2, 1068, 149,
	3, 2, 2, 2, 1069, 1070, 5, 152, 77, 2, 1070, 1071, 5, 158, 80, 2, 1071,
	1072, 7, 7, 2, 2, 1072, 1074, 5, 158, 80, 2, 1073, 1075, 5, 154, 78, 2,
	1074, 1073, 3, 2, 2, 2, 1074, 1075, 3, 2, 2, 2, 1075, 1084, 3, 2, 2, 2,
	1076, 1077, 5, 158, 80, 2, 1077, 1078, 7, 3, 2, 2, 1078, 1080, 5, 158,
	80, 2, 1079, 1081, 5, 154, 78, 2, 1080, 1079, 3, 2, 2, 2, 1080, 1081, 3,
	2, 2, 2, 1081, 1083, 3, 2, 2, 2, 1082, 1076, 3, 2, 2, 2, 1083, 1086, 3,
	2, 2, 2, 1084, 1082, 3, 2, 2, 2, 1084, 1085, 3, 2, 2, 2, 1085, 1087, 3,
	2, 2, 2, 1086, 1084, 3, 2, 2, 2, 1087, 1088, 7, 8, 2, 2, 1088, 1089, 5,
	158, 80, 2, 1089, 151, 3, 2, 2, 2, 1090, 1091, 5, 94, 48, 2, 1091, 153,
	3, 2, 2, 2, 1092, 1093, 5, 156, 79, 2, 1093, 1094, 5, 158, 80, 2, 1094,
	1095, 7, 5, 2, 2, 1095, 1096, 5, 158, 80, 2, 1096, 1102, 5, 82, 42, 2,
	1097, 1098, 5, 158, 80, 2, 1098, 1099, 5, 82, 42, 2, 1099, 1101, 3, 2,
	2, 2, 1100, 1097, 3, 2, 2, 2, 1101, 1104, 3, 2, 2, 2, 1102, 1100, 3, 2,
	2, 2, 1102, 1103, 3, 2, 2, 2, 1103, 155, 3, 2, 2, 2, 1104, 1102, 3, 2,
	2, 2, 1105, 1106, 9, 9, 2, 2, 1106, 157, 3, 2, 2, 2, 1107, 1109, 9, 10,
	2, 2, 1108, 1107, 3, 2, 2, 2, 1109, 1112, 3, 2, 2, 2, 1110, 1108, 3, 2,
	2, 2, 1110, 1111, 3, 2, 2, 2, 1111, 159, 3, 2, 2, 2, 1112, 1110, 3, 2,
	2, 2, 108, 165, 170, 177, 182, 189, 194, 201, 206, 221, 249, 256, 268,
	273, 290, 293, 298, 309, 319, 322, 333, 344, 349, 354, 358, 375, 386, 397,
	401, 408, 410, 418, 420, 422, 425, 431, 438, 448, 456, 460, 466, 470, 484,
	489, 503, 513, 524, 530, 538, 544, 549, 555, 563, 567, 575, 582, 592, 594,
	598, 603, 632, 650, 655, 660, 665, 702, 704, 714, 716, 726, 728, 734, 741,
	747, 762, 775, 777, 793, 800, 816, 826, 846, 860, 870, 872, 901, 914, 916,
	937, 944, 949, 953, 969, 987, 994, 1006, 1014, 1026, 1040, 1054, 1064,
	1067, 1074, 1080, 1084, 1102, 1110,
}
var literalNames = []string{
	"", "';'", "'('", "':'", "')'", "'{'", "'}'", "'*'", "'|'", "'.'", "'['",
	"'='", "']'", "'/'", "'_'", "'@'", "", "", "'<!--'", "'-->'", "'~='", "'|='",
	"", "", "", "", "", "'@charset '", "", "", "", "", "", "", "", "", "",
	"'+'", "'-'", "'>'", "','", "'~'", "", "", "", "'^='", "'$='", "'*='",
	"", "", "", "", "", "", "'calc('", "", "", "", "", "", "'var('",
}
var symbolicNames = []string{
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "Comment",
	"Space", "Cdo", "Cdc", "Includes", "DashMatch", "Hash", "Import", "Page",
	"Media", "Namespace", "Charset", "Important", "Percentage", "Uri", "UnicodeRange",
	"MediaOnly", "Not", "And", "Dimension", "UnknownDimension", "Plus", "Minus",
	"Greater", "Comma", "Tilde", "PseudoNot", "Number", "String_", "PrefixMatch",
	"SuffixMatch", "SubstringMatch", "FontFace", "Supports", "Or", "Keyframes",
	"From", "To", "Calc", "Viewport", "CounterStyle", "FontFeatureValues",
	"DxImageTransform", "Variable", "Var", "Ident", "Function_",
}

var ruleNames = []string{
	"stylesheet", "charset", "imports", "namespace_", "namespacePrefix", "media",
	"mediaQueryList", "mediaQuery", "mediaType", "mediaExpression", "mediaFeature",
	"page", "pseudoPage", "selectorGroup", "selector", "combinator", "simpleSelectorSequence",
	"typeSelector", "typeNamespacePrefix", "elementName", "universal", "className",
	"attrib", "pseudo", "functionalPseudo", "expression", "negation", "negationArg",
	"operator_", "property_", "ruleset", "declarationList", "declaration",
	"prio", "value", "expr", "term", "function_", "dxImageTransform", "hexcolor",
	"number", "percentage", "dimension", "unknownDimension", "any_", "atRule",
	"atKeyword", "unused", "block", "nestedStatement", "groupRuleBody", "supportsRule",
	"supportsCondition", "supportsConditionInParens", "supportsNegation", "supportsConjunction",
	"supportsDisjunction", "supportsDeclarationCondition", "generalEnclosed",
	"var_", "calc", "calcSum", "calcProduct", "calcValue", "fontFaceRule",
	"fontFaceDeclaration", "keyframesRule", "keyframesBlocks", "keyframeSelector",
	"viewport", "counterStyle", "fontFeatureValuesRule", "fontFamilyNameList",
	"fontFamilyName", "featureValueBlock", "featureType", "featureValueDefinition",
	"ident", "ws",
}

type css3Parser struct {
	*antlr.BaseParser
}

// Newcss3Parser produces a new parser instance for the optional input antlr.TokenStream.
//
// The *css3Parser instance produced may be reused by calling the SetInputStream method.
// The initial parser configuration is expensive to construct, and the object is not thread-safe;
// however, if used within a Golang sync.Pool, the construction cost amortizes well and the
// objects can be used in a thread-safe manner.
func Newcss3Parser(input antlr.TokenStream) *css3Parser {
	this := new(css3Parser)
	deserializer := antlr.NewATNDeserializer(nil)
	deserializedATN := deserializer.DeserializeFromUInt16(parserATN)
	decisionToDFA := make([]*antlr.DFA, len(deserializedATN.DecisionToState))
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "css3.g4"

	return this
}

// css3Parser tokens.
const (
	css3ParserEOF               = antlr.TokenEOF
	css3ParserT__0              = 1
	css3ParserT__1              = 2
	css3ParserT__2              = 3
	css3ParserT__3              = 4
	css3ParserT__4              = 5
	css3ParserT__5              = 6
	css3ParserT__6              = 7
	css3ParserT__7              = 8
	css3ParserT__8              = 9
	css3ParserT__9              = 10
	css3ParserT__10             = 11
	css3ParserT__11             = 12
	css3ParserT__12             = 13
	css3ParserT__13             = 14
	css3ParserT__14             = 15
	css3ParserComment           = 16
	css3ParserSpace             = 17
	css3ParserCdo               = 18
	css3ParserCdc               = 19
	css3ParserIncludes          = 20
	css3ParserDashMatch         = 21
	css3ParserHash              = 22
	css3ParserImport            = 23
	css3ParserPage              = 24
	css3ParserMedia             = 25
	css3ParserNamespace         = 26
	css3ParserCharset           = 27
	css3ParserImportant         = 28
	css3ParserPercentage        = 29
	css3ParserUri               = 30
	css3ParserUnicodeRange      = 31
	css3ParserMediaOnly         = 32
	css3ParserNot               = 33
	css3ParserAnd               = 34
	css3ParserDimension         = 35
	css3ParserUnknownDimension  = 36
	css3ParserPlus              = 37
	css3ParserMinus             = 38
	css3ParserGreater           = 39
	css3ParserComma             = 40
	css3ParserTilde             = 41
	css3ParserPseudoNot         = 42
	css3ParserNumber            = 43
	css3ParserString_           = 44
	css3ParserPrefixMatch       = 45
	css3ParserSuffixMatch       = 46
	css3ParserSubstringMatch    = 47
	css3ParserFontFace          = 48
	css3ParserSupports          = 49
	css3ParserOr                = 50
	css3ParserKeyframes         = 51
	css3ParserFrom              = 52
	css3ParserTo                = 53
	css3ParserCalc              = 54
	css3ParserViewport          = 55
	css3ParserCounterStyle      = 56
	css3ParserFontFeatureValues = 57
	css3ParserDxImageTransform  = 58
	css3ParserVariable          = 59
	css3ParserVar               = 60
	css3ParserIdent             = 61
	css3ParserFunction_         = 62
)

// css3Parser rules.
const (
	css3ParserRULE_stylesheet                   = 0
	css3ParserRULE_charset                      = 1
	css3ParserRULE_imports                      = 2
	css3ParserRULE_namespace_                   = 3
	css3ParserRULE_namespacePrefix              = 4
	css3ParserRULE_media                        = 5
	css3ParserRULE_mediaQueryList               = 6
	css3ParserRULE_mediaQuery                   = 7
	css3ParserRULE_mediaType                    = 8
	css3ParserRULE_mediaExpression              = 9
	css3ParserRULE_mediaFeature                 = 10
	css3ParserRULE_page                         = 11
	css3ParserRULE_pseudoPage                   = 12
	css3ParserRULE_selectorGroup                = 13
	css3ParserRULE_selector                     = 14
	css3ParserRULE_combinator                   = 15
	css3ParserRULE_simpleSelectorSequence       = 16
	css3ParserRULE_typeSelector                 = 17
	css3ParserRULE_typeNamespacePrefix          = 18
	css3ParserRULE_elementName                  = 19
	css3ParserRULE_universal                    = 20
	css3ParserRULE_className                    = 21
	css3ParserRULE_attrib                       = 22
	css3ParserRULE_pseudo                       = 23
	css3ParserRULE_functionalPseudo             = 24
	css3ParserRULE_expression                   = 25
	css3ParserRULE_negation                     = 26
	css3ParserRULE_negationArg                  = 27
	css3ParserRULE_operator_                    = 28
	css3ParserRULE_property_                    = 29
	css3ParserRULE_ruleset                      = 30
	css3ParserRULE_declarationList              = 31
	css3ParserRULE_declaration                  = 32
	css3ParserRULE_prio                         = 33
	css3ParserRULE_value                        = 34
	css3ParserRULE_expr                         = 35
	css3ParserRULE_term                         = 36
	css3ParserRULE_function_                    = 37
	css3ParserRULE_dxImageTransform             = 38
	css3ParserRULE_hexcolor                     = 39
	css3ParserRULE_number                       = 40
	css3ParserRULE_percentage                   = 41
	css3ParserRULE_dimension                    = 42
	css3ParserRULE_unknownDimension             = 43
	css3ParserRULE_any_                         = 44
	css3ParserRULE_atRule                       = 45
	css3ParserRULE_atKeyword                    = 46
	css3ParserRULE_unused                       = 47
	css3ParserRULE_block                        = 48
	css3ParserRULE_nestedStatement              = 49
	css3ParserRULE_groupRuleBody                = 50
	css3ParserRULE_supportsRule                 = 51
	css3ParserRULE_supportsCondition            = 52
	css3ParserRULE_supportsConditionInParens    = 53
	css3ParserRULE_supportsNegation             = 54
	css3ParserRULE_supportsConjunction          = 55
	css3ParserRULE_supportsDisjunction          = 56
	css3ParserRULE_supportsDeclarationCondition = 57
	css3ParserRULE_generalEnclosed              = 58
	css3ParserRULE_var_                         = 59
	css3ParserRULE_calc                         = 60
	css3ParserRULE_calcSum                      = 61
	css3ParserRULE_calcProduct                  = 62
	css3ParserRULE_calcValue                    = 63
	css3ParserRULE_fontFaceRule                 = 64
	css3ParserRULE_fontFaceDeclaration          = 65
	css3ParserRULE_keyframesRule                = 66
	css3ParserRULE_keyframesBlocks              = 67
	css3ParserRULE_keyframeSelector             = 68
	css3ParserRULE_viewport                     = 69
	css3ParserRULE_counterStyle                 = 70
	css3ParserRULE_fontFeatureValuesRule        = 71
	css3ParserRULE_fontFamilyNameList           = 72
	css3ParserRULE_fontFamilyName               = 73
	css3ParserRULE_featureValueBlock            = 74
	css3ParserRULE_featureType                  = 75
	css3ParserRULE_featureValueDefinition       = 76
	css3ParserRULE_ident                        = 77
	css3ParserRULE_ws                           = 78
)

// IStylesheetContext is an interface to support dynamic dispatch.
type IStylesheetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStylesheetContext differentiates from other interfaces.
	IsStylesheetContext()
}

type StylesheetContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStylesheetContext() *StylesheetContext {
	var p = new(StylesheetContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_stylesheet
	return p
}

func (*StylesheetContext) IsStylesheetContext() {}

func NewStylesheetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StylesheetContext {
	var p = new(StylesheetContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_stylesheet

	return p
}

func (s *StylesheetContext) GetParser() antlr.Parser { return s.parser }

func (s *StylesheetContext) Ws() IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *StylesheetContext) AllCharset() []ICharsetContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICharsetContext)(nil)).Elem())
	var tst = make([]ICharsetContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICharsetContext)
		}
	}

	return tst
}

func (s *StylesheetContext) Charset(i int) ICharsetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICharsetContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICharsetContext)
}

func (s *StylesheetContext) AllImports() []IImportsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IImportsContext)(nil)).Elem())
	var tst = make([]IImportsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IImportsContext)
		}
	}

	return tst
}

func (s *StylesheetContext) Imports(i int) IImportsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImportsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IImportsContext)
}

func (s *StylesheetContext) AllNamespace_() []INamespace_Context {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INamespace_Context)(nil)).Elem())
	var tst = make([]INamespace_Context, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INamespace_Context)
		}
	}

	return tst
}

func (s *StylesheetContext) Namespace_(i int) INamespace_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamespace_Context)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INamespace_Context)
}

func (s *StylesheetContext) AllNestedStatement() []INestedStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INestedStatementContext)(nil)).Elem())
	var tst = make([]INestedStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INestedStatementContext)
		}
	}

	return tst
}

func (s *StylesheetContext) NestedStatement(i int) INestedStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INestedStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INestedStatementContext)
}

func (s *StylesheetContext) AllComment() []antlr.TerminalNode {
	return s.GetTokens(css3ParserComment)
}

func (s *StylesheetContext) Comment(i int) antlr.TerminalNode {
	return s.GetToken(css3ParserComment, i)
}

func (s *StylesheetContext) AllSpace() []antlr.TerminalNode {
	return s.GetTokens(css3ParserSpace)
}

func (s *StylesheetContext) Space(i int) antlr.TerminalNode {
	return s.GetToken(css3ParserSpace, i)
}

func (s *StylesheetContext) AllCdo() []antlr.TerminalNode {
	return s.GetTokens(css3ParserCdo)
}

func (s *StylesheetContext) Cdo(i int) antlr.TerminalNode {
	return s.GetToken(css3ParserCdo, i)
}

func (s *StylesheetContext) AllCdc() []antlr.TerminalNode {
	return s.GetTokens(css3ParserCdc)
}

func (s *StylesheetContext) Cdc(i int) antlr.TerminalNode {
	return s.GetToken(css3ParserCdc, i)
}

func (s *StylesheetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StylesheetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StylesheetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterStylesheet(s)
	}
}

func (s *StylesheetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitStylesheet(s)
	}
}

func (p *css3Parser) Stylesheet() (localctx IStylesheetContext) {
	this := p
	_ = this

	localctx = NewStylesheetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, css3ParserRULE_stylesheet)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(158)
		p.Ws()
	}
	p.SetState(168)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == css3ParserCharset {
		{
			p.SetState(159)
			p.Charset()
		}
		p.SetState(163)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<css3ParserComment)|(1<<css3ParserSpace)|(1<<css3ParserCdo)|(1<<css3ParserCdc))) != 0 {
			{
				p.SetState(160)
				_la = p.GetTokenStream().LA(1)

				if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<css3ParserComment)|(1<<css3ParserSpace)|(1<<css3ParserCdo)|(1<<css3ParserCdc))) != 0) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

			p.SetState(165)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

		p.SetState(170)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(180)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == css3ParserImport {
		{
			p.SetState(171)
			p.Imports()
		}
		p.SetState(175)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<css3ParserComment)|(1<<css3ParserSpace)|(1<<css3ParserCdo)|(1<<css3ParserCdc))) != 0 {
			{
				p.SetState(172)
				_la = p.GetTokenStream().LA(1)

				if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<css3ParserComment)|(1<<css3ParserSpace)|(1<<css3ParserCdo)|(1<<css3ParserCdc))) != 0) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

			p.SetState(177)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

		p.SetState(182)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(192)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == css3ParserNamespace {
		{
			p.SetState(183)
			p.Namespace_()
		}
		p.SetState(187)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<css3ParserComment)|(1<<css3ParserSpace)|(1<<css3ParserCdo)|(1<<css3ParserCdc))) != 0 {
			{
				p.SetState(184)
				_la = p.GetTokenStream().LA(1)

				if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<css3ParserComment)|(1<<css3ParserSpace)|(1<<css3ParserCdo)|(1<<css3ParserCdc))) != 0) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

			p.SetState(189)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

		p.SetState(194)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(204)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<css3ParserT__1)|(1<<css3ParserT__2)|(1<<css3ParserT__4)|(1<<css3ParserT__6)|(1<<css3ParserT__7)|(1<<css3ParserT__8)|(1<<css3ParserT__9)|(1<<css3ParserT__14)|(1<<css3ParserIncludes)|(1<<css3ParserDashMatch)|(1<<css3ParserHash)|(1<<css3ParserPage)|(1<<css3ParserMedia)|(1<<css3ParserPercentage)|(1<<css3ParserUri)|(1<<css3ParserUnicodeRange))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(css3ParserMediaOnly-32))|(1<<(css3ParserNot-32))|(1<<(css3ParserAnd-32))|(1<<(css3ParserDimension-32))|(1<<(css3ParserUnknownDimension-32))|(1<<(css3ParserPlus-32))|(1<<(css3ParserMinus-32))|(1<<(css3ParserPseudoNot-32))|(1<<(css3ParserNumber-32))|(1<<(css3ParserString_-32))|(1<<(css3ParserFontFace-32))|(1<<(css3ParserSupports-32))|(1<<(css3ParserOr-32))|(1<<(css3ParserKeyframes-32))|(1<<(css3ParserFrom-32))|(1<<(css3ParserTo-32))|(1<<(css3ParserViewport-32))|(1<<(css3ParserCounterStyle-32))|(1<<(css3ParserFontFeatureValues-32))|(1<<(css3ParserIdent-32))|(1<<(css3ParserFunction_-32)))) != 0) {
		{
			p.SetState(195)
			p.NestedStatement()
		}
		p.SetState(199)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<css3ParserComment)|(1<<css3ParserSpace)|(1<<css3ParserCdo)|(1<<css3ParserCdc))) != 0 {
			{
				p.SetState(196)
				_la = p.GetTokenStream().LA(1)

				if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<css3ParserComment)|(1<<css3ParserSpace)|(1<<css3ParserCdo)|(1<<css3ParserCdc))) != 0) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

			p.SetState(201)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

		p.SetState(206)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ICharsetContext is an interface to support dynamic dispatch.
type ICharsetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCharsetContext differentiates from other interfaces.
	IsCharsetContext()
}

type CharsetContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharsetContext() *CharsetContext {
	var p = new(CharsetContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_charset
	return p
}

func (*CharsetContext) IsCharsetContext() {}

func NewCharsetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CharsetContext {
	var p = new(CharsetContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_charset

	return p
}

func (s *CharsetContext) GetParser() antlr.Parser { return s.parser }

func (s *CharsetContext) CopyFrom(ctx *CharsetContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *CharsetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CharsetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type BadCharsetContext struct {
	*CharsetContext
}

func NewBadCharsetContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BadCharsetContext {
	var p = new(BadCharsetContext)

	p.CharsetContext = NewEmptyCharsetContext()
	p.parser = parser
	p.CopyFrom(ctx.(*CharsetContext))

	return p
}

func (s *BadCharsetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BadCharsetContext) Charset() antlr.TerminalNode {
	return s.GetToken(css3ParserCharset, 0)
}

func (s *BadCharsetContext) AllWs() []IWsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWsContext)(nil)).Elem())
	var tst = make([]IWsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWsContext)
		}
	}

	return tst
}

func (s *BadCharsetContext) Ws(i int) IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *BadCharsetContext) String_() antlr.TerminalNode {
	return s.GetToken(css3ParserString_, 0)
}

func (s *BadCharsetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterBadCharset(s)
	}
}

func (s *BadCharsetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitBadCharset(s)
	}
}

type GoodCharsetContext struct {
	*CharsetContext
}

func NewGoodCharsetContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GoodCharsetContext {
	var p = new(GoodCharsetContext)

	p.CharsetContext = NewEmptyCharsetContext()
	p.parser = parser
	p.CopyFrom(ctx.(*CharsetContext))

	return p
}

func (s *GoodCharsetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GoodCharsetContext) Charset() antlr.TerminalNode {
	return s.GetToken(css3ParserCharset, 0)
}

func (s *GoodCharsetContext) AllWs() []IWsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWsContext)(nil)).Elem())
	var tst = make([]IWsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWsContext)
		}
	}

	return tst
}

func (s *GoodCharsetContext) Ws(i int) IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *GoodCharsetContext) String_() antlr.TerminalNode {
	return s.GetToken(css3ParserString_, 0)
}

func (s *GoodCharsetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterGoodCharset(s)
	}
}

func (s *GoodCharsetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitGoodCharset(s)
	}
}

func (p *css3Parser) Charset() (localctx ICharsetContext) {
	this := p
	_ = this

	localctx = NewCharsetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, css3ParserRULE_charset)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(219)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 8, p.GetParserRuleContext()) {
	case 1:
		localctx = NewGoodCharsetContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(207)
			p.Match(css3ParserCharset)
		}
		{
			p.SetState(208)
			p.Ws()
		}
		{
			p.SetState(209)
			p.Match(css3ParserString_)
		}
		{
			p.SetState(210)
			p.Ws()
		}
		{
			p.SetState(211)
			p.Match(css3ParserT__0)
		}
		{
			p.SetState(212)
			p.Ws()
		}

	case 2:
		localctx = NewBadCharsetContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(214)
			p.Match(css3ParserCharset)
		}
		{
			p.SetState(215)
			p.Ws()
		}
		{
			p.SetState(216)
			p.Match(css3ParserString_)
		}
		{
			p.SetState(217)
			p.Ws()
		}

	}

	return localctx
}

// IImportsContext is an interface to support dynamic dispatch.
type IImportsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImportsContext differentiates from other interfaces.
	IsImportsContext()
}

type ImportsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportsContext() *ImportsContext {
	var p = new(ImportsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_imports
	return p
}

func (*ImportsContext) IsImportsContext() {}

func NewImportsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportsContext {
	var p = new(ImportsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_imports

	return p
}

func (s *ImportsContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportsContext) CopyFrom(ctx *ImportsContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *ImportsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type BadImportContext struct {
	*ImportsContext
}

func NewBadImportContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BadImportContext {
	var p = new(BadImportContext)

	p.ImportsContext = NewEmptyImportsContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ImportsContext))

	return p
}

func (s *BadImportContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BadImportContext) Import() antlr.TerminalNode {
	return s.GetToken(css3ParserImport, 0)
}

func (s *BadImportContext) AllWs() []IWsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWsContext)(nil)).Elem())
	var tst = make([]IWsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWsContext)
		}
	}

	return tst
}

func (s *BadImportContext) Ws(i int) IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *BadImportContext) MediaQueryList() IMediaQueryListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMediaQueryListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMediaQueryListContext)
}

func (s *BadImportContext) String_() antlr.TerminalNode {
	return s.GetToken(css3ParserString_, 0)
}

func (s *BadImportContext) Uri() antlr.TerminalNode {
	return s.GetToken(css3ParserUri, 0)
}

func (s *BadImportContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterBadImport(s)
	}
}

func (s *BadImportContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitBadImport(s)
	}
}

type GoodImportContext struct {
	*ImportsContext
}

func NewGoodImportContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GoodImportContext {
	var p = new(GoodImportContext)

	p.ImportsContext = NewEmptyImportsContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ImportsContext))

	return p
}

func (s *GoodImportContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GoodImportContext) Import() antlr.TerminalNode {
	return s.GetToken(css3ParserImport, 0)
}

func (s *GoodImportContext) AllWs() []IWsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWsContext)(nil)).Elem())
	var tst = make([]IWsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWsContext)
		}
	}

	return tst
}

func (s *GoodImportContext) Ws(i int) IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *GoodImportContext) MediaQueryList() IMediaQueryListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMediaQueryListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMediaQueryListContext)
}

func (s *GoodImportContext) String_() antlr.TerminalNode {
	return s.GetToken(css3ParserString_, 0)
}

func (s *GoodImportContext) Uri() antlr.TerminalNode {
	return s.GetToken(css3ParserUri, 0)
}

func (s *GoodImportContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterGoodImport(s)
	}
}

func (s *GoodImportContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitGoodImport(s)
	}
}

func (p *css3Parser) Imports() (localctx IImportsContext) {
	this := p
	_ = this

	localctx = NewImportsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, css3ParserRULE_imports)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(247)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 9, p.GetParserRuleContext()) {
	case 1:
		localctx = NewGoodImportContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(221)
			p.Match(css3ParserImport)
		}
		{
			p.SetState(222)
			p.Ws()
		}
		{
			p.SetState(223)
			_la = p.GetTokenStream().LA(1)

			if !(_la == css3ParserUri || _la == css3ParserString_) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(224)
			p.Ws()
		}
		{
			p.SetState(225)
			p.MediaQueryList()
		}
		{
			p.SetState(226)
			p.Match(css3ParserT__0)
		}
		{
			p.SetState(227)
			p.Ws()
		}

	case 2:
		localctx = NewGoodImportContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(229)
			p.Match(css3ParserImport)
		}
		{
			p.SetState(230)
			p.Ws()
		}
		{
			p.SetState(231)
			_la = p.GetTokenStream().LA(1)

			if !(_la == css3ParserUri || _la == css3ParserString_) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(232)
			p.Ws()
		}
		{
			p.SetState(233)
			p.Match(css3ParserT__0)
		}
		{
			p.SetState(234)
			p.Ws()
		}

	case 3:
		localctx = NewBadImportContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(236)
			p.Match(css3ParserImport)
		}
		{
			p.SetState(237)
			p.Ws()
		}
		{
			p.SetState(238)
			_la = p.GetTokenStream().LA(1)

			if !(_la == css3ParserUri || _la == css3ParserString_) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(239)
			p.Ws()
		}
		{
			p.SetState(240)
			p.MediaQueryList()
		}

	case 4:
		localctx = NewBadImportContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(242)
			p.Match(css3ParserImport)
		}
		{
			p.SetState(243)
			p.Ws()
		}
		{
			p.SetState(244)
			_la = p.GetTokenStream().LA(1)

			if !(_la == css3ParserUri || _la == css3ParserString_) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(245)
			p.Ws()
		}

	}

	return localctx
}

// INamespace_Context is an interface to support dynamic dispatch.
type INamespace_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNamespace_Context differentiates from other interfaces.
	IsNamespace_Context()
}

type Namespace_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamespace_Context() *Namespace_Context {
	var p = new(Namespace_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_namespace_
	return p
}

func (*Namespace_Context) IsNamespace_Context() {}

func NewNamespace_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Namespace_Context {
	var p = new(Namespace_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_namespace_

	return p
}

func (s *Namespace_Context) GetParser() antlr.Parser { return s.parser }

func (s *Namespace_Context) CopyFrom(ctx *Namespace_Context) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *Namespace_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Namespace_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type GoodNamespaceContext struct {
	*Namespace_Context
}

func NewGoodNamespaceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GoodNamespaceContext {
	var p = new(GoodNamespaceContext)

	p.Namespace_Context = NewEmptyNamespace_Context()
	p.parser = parser
	p.CopyFrom(ctx.(*Namespace_Context))

	return p
}

func (s *GoodNamespaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GoodNamespaceContext) Namespace() antlr.TerminalNode {
	return s.GetToken(css3ParserNamespace, 0)
}

func (s *GoodNamespaceContext) AllWs() []IWsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWsContext)(nil)).Elem())
	var tst = make([]IWsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWsContext)
		}
	}

	return tst
}

func (s *GoodNamespaceContext) Ws(i int) IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *GoodNamespaceContext) String_() antlr.TerminalNode {
	return s.GetToken(css3ParserString_, 0)
}

func (s *GoodNamespaceContext) Uri() antlr.TerminalNode {
	return s.GetToken(css3ParserUri, 0)
}

func (s *GoodNamespaceContext) NamespacePrefix() INamespacePrefixContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamespacePrefixContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INamespacePrefixContext)
}

func (s *GoodNamespaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterGoodNamespace(s)
	}
}

func (s *GoodNamespaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitGoodNamespace(s)
	}
}

type BadNamespaceContext struct {
	*Namespace_Context
}

func NewBadNamespaceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BadNamespaceContext {
	var p = new(BadNamespaceContext)

	p.Namespace_Context = NewEmptyNamespace_Context()
	p.parser = parser
	p.CopyFrom(ctx.(*Namespace_Context))

	return p
}

func (s *BadNamespaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BadNamespaceContext) Namespace() antlr.TerminalNode {
	return s.GetToken(css3ParserNamespace, 0)
}

func (s *BadNamespaceContext) AllWs() []IWsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWsContext)(nil)).Elem())
	var tst = make([]IWsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWsContext)
		}
	}

	return tst
}

func (s *BadNamespaceContext) Ws(i int) IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *BadNamespaceContext) String_() antlr.TerminalNode {
	return s.GetToken(css3ParserString_, 0)
}

func (s *BadNamespaceContext) Uri() antlr.TerminalNode {
	return s.GetToken(css3ParserUri, 0)
}

func (s *BadNamespaceContext) NamespacePrefix() INamespacePrefixContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamespacePrefixContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INamespacePrefixContext)
}

func (s *BadNamespaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterBadNamespace(s)
	}
}

func (s *BadNamespaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitBadNamespace(s)
	}
}

func (p *css3Parser) Namespace_() (localctx INamespace_Context) {
	this := p
	_ = this

	localctx = NewNamespace_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, css3ParserRULE_namespace_)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(271)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 12, p.GetParserRuleContext()) {
	case 1:
		localctx = NewGoodNamespaceContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(249)
			p.Match(css3ParserNamespace)
		}
		{
			p.SetState(250)
			p.Ws()
		}
		p.SetState(254)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(css3ParserMediaOnly-32))|(1<<(css3ParserNot-32))|(1<<(css3ParserAnd-32))|(1<<(css3ParserOr-32))|(1<<(css3ParserFrom-32))|(1<<(css3ParserTo-32))|(1<<(css3ParserIdent-32)))) != 0 {
			{
				p.SetState(251)
				p.NamespacePrefix()
			}
			{
				p.SetState(252)
				p.Ws()
			}

		}
		{
			p.SetState(256)
			_la = p.GetTokenStream().LA(1)

			if !(_la == css3ParserUri || _la == css3ParserString_) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(257)
			p.Ws()
		}
		{
			p.SetState(258)
			p.Match(css3ParserT__0)
		}
		{
			p.SetState(259)
			p.Ws()
		}

	case 2:
		localctx = NewBadNamespaceContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(261)
			p.Match(css3ParserNamespace)
		}
		{
			p.SetState(262)
			p.Ws()
		}
		p.SetState(266)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(css3ParserMediaOnly-32))|(1<<(css3ParserNot-32))|(1<<(css3ParserAnd-32))|(1<<(css3ParserOr-32))|(1<<(css3ParserFrom-32))|(1<<(css3ParserTo-32))|(1<<(css3ParserIdent-32)))) != 0 {
			{
				p.SetState(263)
				p.NamespacePrefix()
			}
			{
				p.SetState(264)
				p.Ws()
			}

		}
		{
			p.SetState(268)
			_la = p.GetTokenStream().LA(1)

			if !(_la == css3ParserUri || _la == css3ParserString_) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(269)
			p.Ws()
		}

	}

	return localctx
}

// INamespacePrefixContext is an interface to support dynamic dispatch.
type INamespacePrefixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNamespacePrefixContext differentiates from other interfaces.
	IsNamespacePrefixContext()
}

type NamespacePrefixContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamespacePrefixContext() *NamespacePrefixContext {
	var p = new(NamespacePrefixContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_namespacePrefix
	return p
}

func (*NamespacePrefixContext) IsNamespacePrefixContext() {}

func NewNamespacePrefixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamespacePrefixContext {
	var p = new(NamespacePrefixContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_namespacePrefix

	return p
}

func (s *NamespacePrefixContext) GetParser() antlr.Parser { return s.parser }

func (s *NamespacePrefixContext) Ident() IIdentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *NamespacePrefixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamespacePrefixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamespacePrefixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterNamespacePrefix(s)
	}
}

func (s *NamespacePrefixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitNamespacePrefix(s)
	}
}

func (p *css3Parser) NamespacePrefix() (localctx INamespacePrefixContext) {
	this := p
	_ = this

	localctx = NewNamespacePrefixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, css3ParserRULE_namespacePrefix)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(273)
		p.Ident()
	}

	return localctx
}

// IMediaContext is an interface to support dynamic dispatch.
type IMediaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMediaContext differentiates from other interfaces.
	IsMediaContext()
}

type MediaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMediaContext() *MediaContext {
	var p = new(MediaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_media
	return p
}

func (*MediaContext) IsMediaContext() {}

func NewMediaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MediaContext {
	var p = new(MediaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_media

	return p
}

func (s *MediaContext) GetParser() antlr.Parser { return s.parser }

func (s *MediaContext) Media() antlr.TerminalNode {
	return s.GetToken(css3ParserMedia, 0)
}

func (s *MediaContext) AllWs() []IWsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWsContext)(nil)).Elem())
	var tst = make([]IWsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWsContext)
		}
	}

	return tst
}

func (s *MediaContext) Ws(i int) IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *MediaContext) MediaQueryList() IMediaQueryListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMediaQueryListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMediaQueryListContext)
}

func (s *MediaContext) GroupRuleBody() IGroupRuleBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroupRuleBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGroupRuleBodyContext)
}

func (s *MediaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MediaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MediaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterMedia(s)
	}
}

func (s *MediaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitMedia(s)
	}
}

func (p *css3Parser) Media() (localctx IMediaContext) {
	this := p
	_ = this

	localctx = NewMediaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, css3ParserRULE_media)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(275)
		p.Match(css3ParserMedia)
	}
	{
		p.SetState(276)
		p.Ws()
	}
	{
		p.SetState(277)
		p.MediaQueryList()
	}
	{
		p.SetState(278)
		p.GroupRuleBody()
	}
	{
		p.SetState(279)
		p.Ws()
	}

	return localctx
}

// IMediaQueryListContext is an interface to support dynamic dispatch.
type IMediaQueryListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMediaQueryListContext differentiates from other interfaces.
	IsMediaQueryListContext()
}

type MediaQueryListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMediaQueryListContext() *MediaQueryListContext {
	var p = new(MediaQueryListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_mediaQueryList
	return p
}

func (*MediaQueryListContext) IsMediaQueryListContext() {}

func NewMediaQueryListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MediaQueryListContext {
	var p = new(MediaQueryListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_mediaQueryList

	return p
}

func (s *MediaQueryListContext) GetParser() antlr.Parser { return s.parser }

func (s *MediaQueryListContext) AllWs() []IWsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWsContext)(nil)).Elem())
	var tst = make([]IWsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWsContext)
		}
	}

	return tst
}

func (s *MediaQueryListContext) Ws(i int) IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *MediaQueryListContext) AllMediaQuery() []IMediaQueryContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMediaQueryContext)(nil)).Elem())
	var tst = make([]IMediaQueryContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMediaQueryContext)
		}
	}

	return tst
}

func (s *MediaQueryListContext) MediaQuery(i int) IMediaQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMediaQueryContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMediaQueryContext)
}

func (s *MediaQueryListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(css3ParserComma)
}

func (s *MediaQueryListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(css3ParserComma, i)
}

func (s *MediaQueryListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MediaQueryListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MediaQueryListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterMediaQueryList(s)
	}
}

func (s *MediaQueryListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitMediaQueryList(s)
	}
}

func (p *css3Parser) MediaQueryList() (localctx IMediaQueryListContext) {
	this := p
	_ = this

	localctx = NewMediaQueryListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, css3ParserRULE_mediaQueryList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(291)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 14, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(281)
			p.MediaQuery()
		}
		p.SetState(288)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == css3ParserComma {
			{
				p.SetState(282)
				p.Match(css3ParserComma)
			}
			{
				p.SetState(283)
				p.Ws()
			}
			{
				p.SetState(284)
				p.MediaQuery()
			}

			p.SetState(290)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(293)
		p.Ws()
	}

	return localctx
}

// IMediaQueryContext is an interface to support dynamic dispatch.
type IMediaQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMediaQueryContext differentiates from other interfaces.
	IsMediaQueryContext()
}

type MediaQueryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMediaQueryContext() *MediaQueryContext {
	var p = new(MediaQueryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_mediaQuery
	return p
}

func (*MediaQueryContext) IsMediaQueryContext() {}

func NewMediaQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MediaQueryContext {
	var p = new(MediaQueryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_mediaQuery

	return p
}

func (s *MediaQueryContext) GetParser() antlr.Parser { return s.parser }

func (s *MediaQueryContext) AllWs() []IWsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWsContext)(nil)).Elem())
	var tst = make([]IWsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWsContext)
		}
	}

	return tst
}

func (s *MediaQueryContext) Ws(i int) IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *MediaQueryContext) MediaType() IMediaTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMediaTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMediaTypeContext)
}

func (s *MediaQueryContext) AllAnd() []antlr.TerminalNode {
	return s.GetTokens(css3ParserAnd)
}

func (s *MediaQueryContext) And(i int) antlr.TerminalNode {
	return s.GetToken(css3ParserAnd, i)
}

func (s *MediaQueryContext) AllMediaExpression() []IMediaExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMediaExpressionContext)(nil)).Elem())
	var tst = make([]IMediaExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMediaExpressionContext)
		}
	}

	return tst
}

func (s *MediaQueryContext) MediaExpression(i int) IMediaExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMediaExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMediaExpressionContext)
}

func (s *MediaQueryContext) MediaOnly() antlr.TerminalNode {
	return s.GetToken(css3ParserMediaOnly, 0)
}

func (s *MediaQueryContext) Not() antlr.TerminalNode {
	return s.GetToken(css3ParserNot, 0)
}

func (s *MediaQueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MediaQueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MediaQueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterMediaQuery(s)
	}
}

func (s *MediaQueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitMediaQuery(s)
	}
}

func (p *css3Parser) MediaQuery() (localctx IMediaQueryContext) {
	this := p
	_ = this

	localctx = NewMediaQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, css3ParserRULE_mediaQuery)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(320)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case css3ParserComment, css3ParserSpace, css3ParserMediaOnly, css3ParserNot, css3ParserAnd, css3ParserOr, css3ParserFrom, css3ParserTo, css3ParserIdent:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(296)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 15, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(295)
				_la = p.GetTokenStream().LA(1)

				if !(_la == css3ParserMediaOnly || _la == css3ParserNot) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(298)
			p.Ws()
		}
		{
			p.SetState(299)
			p.MediaType()
		}
		{
			p.SetState(300)
			p.Ws()
		}
		p.SetState(307)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 16, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(301)
					p.Match(css3ParserAnd)
				}
				{
					p.SetState(302)
					p.Ws()
				}
				{
					p.SetState(303)
					p.MediaExpression()
				}

			}
			p.SetState(309)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 16, p.GetParserRuleContext())
		}

	case css3ParserT__1:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(310)
			p.MediaExpression()
		}
		p.SetState(317)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 17, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(311)
					p.Match(css3ParserAnd)
				}
				{
					p.SetState(312)
					p.Ws()
				}
				{
					p.SetState(313)
					p.MediaExpression()
				}

			}
			p.SetState(319)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 17, p.GetParserRuleContext())
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IMediaTypeContext is an interface to support dynamic dispatch.
type IMediaTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMediaTypeContext differentiates from other interfaces.
	IsMediaTypeContext()
}

type MediaTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMediaTypeContext() *MediaTypeContext {
	var p = new(MediaTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_mediaType
	return p
}

func (*MediaTypeContext) IsMediaTypeContext() {}

func NewMediaTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MediaTypeContext {
	var p = new(MediaTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_mediaType

	return p
}

func (s *MediaTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *MediaTypeContext) Ident() IIdentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *MediaTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MediaTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MediaTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterMediaType(s)
	}
}

func (s *MediaTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitMediaType(s)
	}
}

func (p *css3Parser) MediaType() (localctx IMediaTypeContext) {
	this := p
	_ = this

	localctx = NewMediaTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, css3ParserRULE_mediaType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(322)
		p.Ident()
	}

	return localctx
}

// IMediaExpressionContext is an interface to support dynamic dispatch.
type IMediaExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMediaExpressionContext differentiates from other interfaces.
	IsMediaExpressionContext()
}

type MediaExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMediaExpressionContext() *MediaExpressionContext {
	var p = new(MediaExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_mediaExpression
	return p
}

func (*MediaExpressionContext) IsMediaExpressionContext() {}

func NewMediaExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MediaExpressionContext {
	var p = new(MediaExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_mediaExpression

	return p
}

func (s *MediaExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *MediaExpressionContext) AllWs() []IWsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWsContext)(nil)).Elem())
	var tst = make([]IWsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWsContext)
		}
	}

	return tst
}

func (s *MediaExpressionContext) Ws(i int) IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *MediaExpressionContext) MediaFeature() IMediaFeatureContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMediaFeatureContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMediaFeatureContext)
}

func (s *MediaExpressionContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *MediaExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MediaExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MediaExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterMediaExpression(s)
	}
}

func (s *MediaExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitMediaExpression(s)
	}
}

func (p *css3Parser) MediaExpression() (localctx IMediaExpressionContext) {
	this := p
	_ = this

	localctx = NewMediaExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, css3ParserRULE_mediaExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(324)
		p.Match(css3ParserT__1)
	}
	{
		p.SetState(325)
		p.Ws()
	}
	{
		p.SetState(326)
		p.MediaFeature()
	}
	p.SetState(331)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == css3ParserT__2 {
		{
			p.SetState(327)
			p.Match(css3ParserT__2)
		}
		{
			p.SetState(328)
			p.Ws()
		}
		{
			p.SetState(329)
			p.Expr()
		}

	}
	{
		p.SetState(333)
		p.Match(css3ParserT__3)
	}
	{
		p.SetState(334)
		p.Ws()
	}

	return localctx
}

// IMediaFeatureContext is an interface to support dynamic dispatch.
type IMediaFeatureContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMediaFeatureContext differentiates from other interfaces.
	IsMediaFeatureContext()
}

type MediaFeatureContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMediaFeatureContext() *MediaFeatureContext {
	var p = new(MediaFeatureContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_mediaFeature
	return p
}

func (*MediaFeatureContext) IsMediaFeatureContext() {}

func NewMediaFeatureContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MediaFeatureContext {
	var p = new(MediaFeatureContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_mediaFeature

	return p
}

func (s *MediaFeatureContext) GetParser() antlr.Parser { return s.parser }

func (s *MediaFeatureContext) Ident() IIdentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *MediaFeatureContext) Ws() IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *MediaFeatureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MediaFeatureContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MediaFeatureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterMediaFeature(s)
	}
}

func (s *MediaFeatureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitMediaFeature(s)
	}
}

func (p *css3Parser) MediaFeature() (localctx IMediaFeatureContext) {
	this := p
	_ = this

	localctx = NewMediaFeatureContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, css3ParserRULE_mediaFeature)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(336)
		p.Ident()
	}
	{
		p.SetState(337)
		p.Ws()
	}

	return localctx
}

// IPageContext is an interface to support dynamic dispatch.
type IPageContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPageContext differentiates from other interfaces.
	IsPageContext()
}

type PageContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPageContext() *PageContext {
	var p = new(PageContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_page
	return p
}

func (*PageContext) IsPageContext() {}

func NewPageContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PageContext {
	var p = new(PageContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_page

	return p
}

func (s *PageContext) GetParser() antlr.Parser { return s.parser }

func (s *PageContext) Page() antlr.TerminalNode {
	return s.GetToken(css3ParserPage, 0)
}

func (s *PageContext) AllWs() []IWsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWsContext)(nil)).Elem())
	var tst = make([]IWsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWsContext)
		}
	}

	return tst
}

func (s *PageContext) Ws(i int) IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *PageContext) PseudoPage() IPseudoPageContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPseudoPageContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPseudoPageContext)
}

func (s *PageContext) AllDeclaration() []IDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDeclarationContext)(nil)).Elem())
	var tst = make([]IDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDeclarationContext)
		}
	}

	return tst
}

func (s *PageContext) Declaration(i int) IDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDeclarationContext)
}

func (s *PageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PageContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PageContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterPage(s)
	}
}

func (s *PageContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitPage(s)
	}
}

func (p *css3Parser) Page() (localctx IPageContext) {
	this := p
	_ = this

	localctx = NewPageContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, css3ParserRULE_page)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(339)
		p.Match(css3ParserPage)
	}
	{
		p.SetState(340)
		p.Ws()
	}
	p.SetState(342)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == css3ParserT__2 {
		{
			p.SetState(341)
			p.PseudoPage()
		}

	}
	{
		p.SetState(344)
		p.Match(css3ParserT__4)
	}
	{
		p.SetState(345)
		p.Ws()
	}
	p.SetState(347)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == css3ParserT__6 || _la == css3ParserT__13 || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(css3ParserMediaOnly-32))|(1<<(css3ParserNot-32))|(1<<(css3ParserAnd-32))|(1<<(css3ParserOr-32))|(1<<(css3ParserFrom-32))|(1<<(css3ParserTo-32))|(1<<(css3ParserVariable-32))|(1<<(css3ParserIdent-32)))) != 0) {
		{
			p.SetState(346)
			p.Declaration()
		}

	}
	p.SetState(356)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == css3ParserT__0 {
		{
			p.SetState(349)
			p.Match(css3ParserT__0)
		}
		{
			p.SetState(350)
			p.Ws()
		}
		p.SetState(352)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == css3ParserT__6 || _la == css3ParserT__13 || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(css3ParserMediaOnly-32))|(1<<(css3ParserNot-32))|(1<<(css3ParserAnd-32))|(1<<(css3ParserOr-32))|(1<<(css3ParserFrom-32))|(1<<(css3ParserTo-32))|(1<<(css3ParserVariable-32))|(1<<(css3ParserIdent-32)))) != 0) {
			{
				p.SetState(351)
				p.Declaration()
			}

		}

		p.SetState(358)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(359)
		p.Match(css3ParserT__5)
	}
	{
		p.SetState(360)
		p.Ws()
	}

	return localctx
}

// IPseudoPageContext is an interface to support dynamic dispatch.
type IPseudoPageContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPseudoPageContext differentiates from other interfaces.
	IsPseudoPageContext()
}

type PseudoPageContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPseudoPageContext() *PseudoPageContext {
	var p = new(PseudoPageContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_pseudoPage
	return p
}

func (*PseudoPageContext) IsPseudoPageContext() {}

func NewPseudoPageContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PseudoPageContext {
	var p = new(PseudoPageContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_pseudoPage

	return p
}

func (s *PseudoPageContext) GetParser() antlr.Parser { return s.parser }

func (s *PseudoPageContext) Ident() IIdentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *PseudoPageContext) Ws() IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *PseudoPageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PseudoPageContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PseudoPageContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterPseudoPage(s)
	}
}

func (s *PseudoPageContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitPseudoPage(s)
	}
}

func (p *css3Parser) PseudoPage() (localctx IPseudoPageContext) {
	this := p
	_ = this

	localctx = NewPseudoPageContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, css3ParserRULE_pseudoPage)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(362)
		p.Match(css3ParserT__2)
	}
	{
		p.SetState(363)
		p.Ident()
	}
	{
		p.SetState(364)
		p.Ws()
	}

	return localctx
}

// ISelectorGroupContext is an interface to support dynamic dispatch.
type ISelectorGroupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelectorGroupContext differentiates from other interfaces.
	IsSelectorGroupContext()
}

type SelectorGroupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectorGroupContext() *SelectorGroupContext {
	var p = new(SelectorGroupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_selectorGroup
	return p
}

func (*SelectorGroupContext) IsSelectorGroupContext() {}

func NewSelectorGroupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectorGroupContext {
	var p = new(SelectorGroupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_selectorGroup

	return p
}

func (s *SelectorGroupContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectorGroupContext) AllSelector() []ISelectorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISelectorContext)(nil)).Elem())
	var tst = make([]ISelectorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISelectorContext)
		}
	}

	return tst
}

func (s *SelectorGroupContext) Selector(i int) ISelectorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISelectorContext)
}

func (s *SelectorGroupContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(css3ParserComma)
}

func (s *SelectorGroupContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(css3ParserComma, i)
}

func (s *SelectorGroupContext) AllWs() []IWsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWsContext)(nil)).Elem())
	var tst = make([]IWsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWsContext)
		}
	}

	return tst
}

func (s *SelectorGroupContext) Ws(i int) IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *SelectorGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectorGroupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectorGroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterSelectorGroup(s)
	}
}

func (s *SelectorGroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitSelectorGroup(s)
	}
}

func (p *css3Parser) SelectorGroup() (localctx ISelectorGroupContext) {
	this := p
	_ = this

	localctx = NewSelectorGroupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, css3ParserRULE_selectorGroup)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(366)
		p.Selector()
	}
	p.SetState(373)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == css3ParserComma {
		{
			p.SetState(367)
			p.Match(css3ParserComma)
		}
		{
			p.SetState(368)
			p.Ws()
		}
		{
			p.SetState(369)
			p.Selector()
		}

		p.SetState(375)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISelectorContext is an interface to support dynamic dispatch.
type ISelectorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelectorContext differentiates from other interfaces.
	IsSelectorContext()
}

type SelectorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectorContext() *SelectorContext {
	var p = new(SelectorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_selector
	return p
}

func (*SelectorContext) IsSelectorContext() {}

func NewSelectorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectorContext {
	var p = new(SelectorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_selector

	return p
}

func (s *SelectorContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectorContext) AllSimpleSelectorSequence() []ISimpleSelectorSequenceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISimpleSelectorSequenceContext)(nil)).Elem())
	var tst = make([]ISimpleSelectorSequenceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISimpleSelectorSequenceContext)
		}
	}

	return tst
}

func (s *SelectorContext) SimpleSelectorSequence(i int) ISimpleSelectorSequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleSelectorSequenceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISimpleSelectorSequenceContext)
}

func (s *SelectorContext) AllWs() []IWsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWsContext)(nil)).Elem())
	var tst = make([]IWsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWsContext)
		}
	}

	return tst
}

func (s *SelectorContext) Ws(i int) IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *SelectorContext) AllCombinator() []ICombinatorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICombinatorContext)(nil)).Elem())
	var tst = make([]ICombinatorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICombinatorContext)
		}
	}

	return tst
}

func (s *SelectorContext) Combinator(i int) ICombinatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICombinatorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICombinatorContext)
}

func (s *SelectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterSelector(s)
	}
}

func (s *SelectorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitSelector(s)
	}
}

func (p *css3Parser) Selector() (localctx ISelectorContext) {
	this := p
	_ = this

	localctx = NewSelectorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, css3ParserRULE_selector)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(376)
		p.SimpleSelectorSequence()
	}
	{
		p.SetState(377)
		p.Ws()
	}
	p.SetState(384)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ((_la-17)&-(0x1f+1)) == 0 && ((1<<uint((_la-17)))&((1<<(css3ParserSpace-17))|(1<<(css3ParserPlus-17))|(1<<(css3ParserGreater-17))|(1<<(css3ParserTilde-17)))) != 0 {
		{
			p.SetState(378)
			p.Combinator()
		}
		{
			p.SetState(379)
			p.SimpleSelectorSequence()
		}
		{
			p.SetState(380)
			p.Ws()
		}

		p.SetState(386)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ICombinatorContext is an interface to support dynamic dispatch.
type ICombinatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCombinatorContext differentiates from other interfaces.
	IsCombinatorContext()
}

type CombinatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCombinatorContext() *CombinatorContext {
	var p = new(CombinatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_combinator
	return p
}

func (*CombinatorContext) IsCombinatorContext() {}

func NewCombinatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CombinatorContext {
	var p = new(CombinatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_combinator

	return p
}

func (s *CombinatorContext) GetParser() antlr.Parser { return s.parser }

func (s *CombinatorContext) Plus() antlr.TerminalNode {
	return s.GetToken(css3ParserPlus, 0)
}

func (s *CombinatorContext) Ws() IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *CombinatorContext) Greater() antlr.TerminalNode {
	return s.GetToken(css3ParserGreater, 0)
}

func (s *CombinatorContext) Tilde() antlr.TerminalNode {
	return s.GetToken(css3ParserTilde, 0)
}

func (s *CombinatorContext) Space() antlr.TerminalNode {
	return s.GetToken(css3ParserSpace, 0)
}

func (s *CombinatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CombinatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CombinatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterCombinator(s)
	}
}

func (s *CombinatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitCombinator(s)
	}
}

func (p *css3Parser) Combinator() (localctx ICombinatorContext) {
	this := p
	_ = this

	localctx = NewCombinatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, css3ParserRULE_combinator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(395)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case css3ParserPlus:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(387)
			p.Match(css3ParserPlus)
		}
		{
			p.SetState(388)
			p.Ws()
		}

	case css3ParserGreater:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(389)
			p.Match(css3ParserGreater)
		}
		{
			p.SetState(390)
			p.Ws()
		}

	case css3ParserTilde:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(391)
			p.Match(css3ParserTilde)
		}
		{
			p.SetState(392)
			p.Ws()
		}

	case css3ParserSpace:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(393)
			p.Match(css3ParserSpace)
		}
		{
			p.SetState(394)
			p.Ws()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISimpleSelectorSequenceContext is an interface to support dynamic dispatch.
type ISimpleSelectorSequenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimpleSelectorSequenceContext differentiates from other interfaces.
	IsSimpleSelectorSequenceContext()
}

type SimpleSelectorSequenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleSelectorSequenceContext() *SimpleSelectorSequenceContext {
	var p = new(SimpleSelectorSequenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_simpleSelectorSequence
	return p
}

func (*SimpleSelectorSequenceContext) IsSimpleSelectorSequenceContext() {}

func NewSimpleSelectorSequenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleSelectorSequenceContext {
	var p = new(SimpleSelectorSequenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_simpleSelectorSequence

	return p
}

func (s *SimpleSelectorSequenceContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleSelectorSequenceContext) TypeSelector() ITypeSelectorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeSelectorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeSelectorContext)
}

func (s *SimpleSelectorSequenceContext) Universal() IUniversalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUniversalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUniversalContext)
}

func (s *SimpleSelectorSequenceContext) AllHash() []antlr.TerminalNode {
	return s.GetTokens(css3ParserHash)
}

func (s *SimpleSelectorSequenceContext) Hash(i int) antlr.TerminalNode {
	return s.GetToken(css3ParserHash, i)
}

func (s *SimpleSelectorSequenceContext) AllClassName() []IClassNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IClassNameContext)(nil)).Elem())
	var tst = make([]IClassNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IClassNameContext)
		}
	}

	return tst
}

func (s *SimpleSelectorSequenceContext) ClassName(i int) IClassNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IClassNameContext)
}

func (s *SimpleSelectorSequenceContext) AllAttrib() []IAttribContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribContext)(nil)).Elem())
	var tst = make([]IAttribContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribContext)
		}
	}

	return tst
}

func (s *SimpleSelectorSequenceContext) Attrib(i int) IAttribContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribContext)
}

func (s *SimpleSelectorSequenceContext) AllPseudo() []IPseudoContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPseudoContext)(nil)).Elem())
	var tst = make([]IPseudoContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPseudoContext)
		}
	}

	return tst
}

func (s *SimpleSelectorSequenceContext) Pseudo(i int) IPseudoContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPseudoContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPseudoContext)
}

func (s *SimpleSelectorSequenceContext) AllNegation() []INegationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INegationContext)(nil)).Elem())
	var tst = make([]INegationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INegationContext)
		}
	}

	return tst
}

func (s *SimpleSelectorSequenceContext) Negation(i int) INegationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INegationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INegationContext)
}

func (s *SimpleSelectorSequenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleSelectorSequenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleSelectorSequenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterSimpleSelectorSequence(s)
	}
}

func (s *SimpleSelectorSequenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitSimpleSelectorSequence(s)
	}
}

func (p *css3Parser) SimpleSelectorSequence() (localctx ISimpleSelectorSequenceContext) {
	this := p
	_ = this

	localctx = NewSimpleSelectorSequenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, css3ParserRULE_simpleSelectorSequence)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(420)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case css3ParserT__6, css3ParserT__7, css3ParserMediaOnly, css3ParserNot, css3ParserAnd, css3ParserOr, css3ParserFrom, css3ParserTo, css3ParserIdent:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(399)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 27, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(397)
				p.TypeSelector()
			}

		case 2:
			{
				p.SetState(398)
				p.Universal()
			}

		}
		p.SetState(408)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<css3ParserT__2)|(1<<css3ParserT__8)|(1<<css3ParserT__9)|(1<<css3ParserHash))) != 0) || _la == css3ParserPseudoNot {
			p.SetState(406)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case css3ParserHash:
				{
					p.SetState(401)
					p.Match(css3ParserHash)
				}

			case css3ParserT__8:
				{
					p.SetState(402)
					p.ClassName()
				}

			case css3ParserT__9:
				{
					p.SetState(403)
					p.Attrib()
				}

			case css3ParserT__2:
				{
					p.SetState(404)
					p.Pseudo()
				}

			case css3ParserPseudoNot:
				{
					p.SetState(405)
					p.Negation()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(410)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case css3ParserT__2, css3ParserT__8, css3ParserT__9, css3ParserHash, css3ParserPseudoNot:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(416)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<css3ParserT__2)|(1<<css3ParserT__8)|(1<<css3ParserT__9)|(1<<css3ParserHash))) != 0) || _la == css3ParserPseudoNot {
			p.SetState(416)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case css3ParserHash:
				{
					p.SetState(411)
					p.Match(css3ParserHash)
				}

			case css3ParserT__8:
				{
					p.SetState(412)
					p.ClassName()
				}

			case css3ParserT__9:
				{
					p.SetState(413)
					p.Attrib()
				}

			case css3ParserT__2:
				{
					p.SetState(414)
					p.Pseudo()
				}

			case css3ParserPseudoNot:
				{
					p.SetState(415)
					p.Negation()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(418)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITypeSelectorContext is an interface to support dynamic dispatch.
type ITypeSelectorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeSelectorContext differentiates from other interfaces.
	IsTypeSelectorContext()
}

type TypeSelectorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeSelectorContext() *TypeSelectorContext {
	var p = new(TypeSelectorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_typeSelector
	return p
}

func (*TypeSelectorContext) IsTypeSelectorContext() {}

func NewTypeSelectorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeSelectorContext {
	var p = new(TypeSelectorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_typeSelector

	return p
}

func (s *TypeSelectorContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeSelectorContext) ElementName() IElementNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElementNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElementNameContext)
}

func (s *TypeSelectorContext) TypeNamespacePrefix() ITypeNamespacePrefixContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeNamespacePrefixContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeNamespacePrefixContext)
}

func (s *TypeSelectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeSelectorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeSelectorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterTypeSelector(s)
	}
}

func (s *TypeSelectorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitTypeSelector(s)
	}
}

func (p *css3Parser) TypeSelector() (localctx ITypeSelectorContext) {
	this := p
	_ = this

	localctx = NewTypeSelectorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, css3ParserRULE_typeSelector)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(423)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 33, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(422)
			p.TypeNamespacePrefix()
		}

	}
	{
		p.SetState(425)
		p.ElementName()
	}

	return localctx
}

// ITypeNamespacePrefixContext is an interface to support dynamic dispatch.
type ITypeNamespacePrefixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeNamespacePrefixContext differentiates from other interfaces.
	IsTypeNamespacePrefixContext()
}

type TypeNamespacePrefixContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeNamespacePrefixContext() *TypeNamespacePrefixContext {
	var p = new(TypeNamespacePrefixContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_typeNamespacePrefix
	return p
}

func (*TypeNamespacePrefixContext) IsTypeNamespacePrefixContext() {}

func NewTypeNamespacePrefixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeNamespacePrefixContext {
	var p = new(TypeNamespacePrefixContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_typeNamespacePrefix

	return p
}

func (s *TypeNamespacePrefixContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeNamespacePrefixContext) Ident() IIdentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *TypeNamespacePrefixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeNamespacePrefixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeNamespacePrefixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterTypeNamespacePrefix(s)
	}
}

func (s *TypeNamespacePrefixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitTypeNamespacePrefix(s)
	}
}

func (p *css3Parser) TypeNamespacePrefix() (localctx ITypeNamespacePrefixContext) {
	this := p
	_ = this

	localctx = NewTypeNamespacePrefixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, css3ParserRULE_typeNamespacePrefix)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(429)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case css3ParserMediaOnly, css3ParserNot, css3ParserAnd, css3ParserOr, css3ParserFrom, css3ParserTo, css3ParserIdent:
		{
			p.SetState(427)
			p.Ident()
		}

	case css3ParserT__6:
		{
			p.SetState(428)
			p.Match(css3ParserT__6)
		}

	case css3ParserT__7:

	default:
	}
	{
		p.SetState(431)
		p.Match(css3ParserT__7)
	}

	return localctx
}

// IElementNameContext is an interface to support dynamic dispatch.
type IElementNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElementNameContext differentiates from other interfaces.
	IsElementNameContext()
}

type ElementNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementNameContext() *ElementNameContext {
	var p = new(ElementNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_elementName
	return p
}

func (*ElementNameContext) IsElementNameContext() {}

func NewElementNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementNameContext {
	var p = new(ElementNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_elementName

	return p
}

func (s *ElementNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementNameContext) Ident() IIdentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *ElementNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterElementName(s)
	}
}

func (s *ElementNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitElementName(s)
	}
}

func (p *css3Parser) ElementName() (localctx IElementNameContext) {
	this := p
	_ = this

	localctx = NewElementNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, css3ParserRULE_elementName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(433)
		p.Ident()
	}

	return localctx
}

// IUniversalContext is an interface to support dynamic dispatch.
type IUniversalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUniversalContext differentiates from other interfaces.
	IsUniversalContext()
}

type UniversalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUniversalContext() *UniversalContext {
	var p = new(UniversalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_universal
	return p
}

func (*UniversalContext) IsUniversalContext() {}

func NewUniversalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UniversalContext {
	var p = new(UniversalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_universal

	return p
}

func (s *UniversalContext) GetParser() antlr.Parser { return s.parser }

func (s *UniversalContext) TypeNamespacePrefix() ITypeNamespacePrefixContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeNamespacePrefixContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeNamespacePrefixContext)
}

func (s *UniversalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UniversalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UniversalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterUniversal(s)
	}
}

func (s *UniversalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitUniversal(s)
	}
}

func (p *css3Parser) Universal() (localctx IUniversalContext) {
	this := p
	_ = this

	localctx = NewUniversalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, css3ParserRULE_universal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(436)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 35, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(435)
			p.TypeNamespacePrefix()
		}

	}
	{
		p.SetState(438)
		p.Match(css3ParserT__6)
	}

	return localctx
}

// IClassNameContext is an interface to support dynamic dispatch.
type IClassNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassNameContext differentiates from other interfaces.
	IsClassNameContext()
}

type ClassNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassNameContext() *ClassNameContext {
	var p = new(ClassNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_className
	return p
}

func (*ClassNameContext) IsClassNameContext() {}

func NewClassNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassNameContext {
	var p = new(ClassNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_className

	return p
}

func (s *ClassNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassNameContext) Ident() IIdentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *ClassNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterClassName(s)
	}
}

func (s *ClassNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitClassName(s)
	}
}

func (p *css3Parser) ClassName() (localctx IClassNameContext) {
	this := p
	_ = this

	localctx = NewClassNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, css3ParserRULE_className)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(440)
		p.Match(css3ParserT__8)
	}
	{
		p.SetState(441)
		p.Ident()
	}

	return localctx
}

// IAttribContext is an interface to support dynamic dispatch.
type IAttribContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttribContext differentiates from other interfaces.
	IsAttribContext()
}

type AttribContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttribContext() *AttribContext {
	var p = new(AttribContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_attrib
	return p
}

func (*AttribContext) IsAttribContext() {}

func NewAttribContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttribContext {
	var p = new(AttribContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_attrib

	return p
}

func (s *AttribContext) GetParser() antlr.Parser { return s.parser }

func (s *AttribContext) AllWs() []IWsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWsContext)(nil)).Elem())
	var tst = make([]IWsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWsContext)
		}
	}

	return tst
}

func (s *AttribContext) Ws(i int) IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *AttribContext) AllIdent() []IIdentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentContext)(nil)).Elem())
	var tst = make([]IIdentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentContext)
		}
	}

	return tst
}

func (s *AttribContext) Ident(i int) IIdentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *AttribContext) TypeNamespacePrefix() ITypeNamespacePrefixContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeNamespacePrefixContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeNamespacePrefixContext)
}

func (s *AttribContext) PrefixMatch() antlr.TerminalNode {
	return s.GetToken(css3ParserPrefixMatch, 0)
}

func (s *AttribContext) SuffixMatch() antlr.TerminalNode {
	return s.GetToken(css3ParserSuffixMatch, 0)
}

func (s *AttribContext) SubstringMatch() antlr.TerminalNode {
	return s.GetToken(css3ParserSubstringMatch, 0)
}

func (s *AttribContext) Includes() antlr.TerminalNode {
	return s.GetToken(css3ParserIncludes, 0)
}

func (s *AttribContext) DashMatch() antlr.TerminalNode {
	return s.GetToken(css3ParserDashMatch, 0)
}

func (s *AttribContext) String_() antlr.TerminalNode {
	return s.GetToken(css3ParserString_, 0)
}

func (s *AttribContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttribContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttribContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterAttrib(s)
	}
}

func (s *AttribContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitAttrib(s)
	}
}

func (p *css3Parser) Attrib() (localctx IAttribContext) {
	this := p
	_ = this

	localctx = NewAttribContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, css3ParserRULE_attrib)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(443)
		p.Match(css3ParserT__9)
	}
	{
		p.SetState(444)
		p.Ws()
	}
	p.SetState(446)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 36, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(445)
			p.TypeNamespacePrefix()
		}

	}
	{
		p.SetState(448)
		p.Ident()
	}
	{
		p.SetState(449)
		p.Ws()
	}
	p.SetState(458)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<css3ParserT__10)|(1<<css3ParserIncludes)|(1<<css3ParserDashMatch))) != 0) || (((_la-45)&-(0x1f+1)) == 0 && ((1<<uint((_la-45)))&((1<<(css3ParserPrefixMatch-45))|(1<<(css3ParserSuffixMatch-45))|(1<<(css3ParserSubstringMatch-45)))) != 0) {
		{
			p.SetState(450)
			_la = p.GetTokenStream().LA(1)

			if !((((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<css3ParserT__10)|(1<<css3ParserIncludes)|(1<<css3ParserDashMatch))) != 0) || (((_la-45)&-(0x1f+1)) == 0 && ((1<<uint((_la-45)))&((1<<(css3ParserPrefixMatch-45))|(1<<(css3ParserSuffixMatch-45))|(1<<(css3ParserSubstringMatch-45)))) != 0)) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(451)
			p.Ws()
		}
		p.SetState(454)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case css3ParserMediaOnly, css3ParserNot, css3ParserAnd, css3ParserOr, css3ParserFrom, css3ParserTo, css3ParserIdent:
			{
				p.SetState(452)
				p.Ident()
			}

		case css3ParserString_:
			{
				p.SetState(453)
				p.Match(css3ParserString_)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(456)
			p.Ws()
		}

	}
	{
		p.SetState(460)
		p.Match(css3ParserT__11)
	}

	return localctx
}

// IPseudoContext is an interface to support dynamic dispatch.
type IPseudoContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPseudoContext differentiates from other interfaces.
	IsPseudoContext()
}

type PseudoContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPseudoContext() *PseudoContext {
	var p = new(PseudoContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_pseudo
	return p
}

func (*PseudoContext) IsPseudoContext() {}

func NewPseudoContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PseudoContext {
	var p = new(PseudoContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_pseudo

	return p
}

func (s *PseudoContext) GetParser() antlr.Parser { return s.parser }

func (s *PseudoContext) Ident() IIdentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *PseudoContext) FunctionalPseudo() IFunctionalPseudoContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionalPseudoContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionalPseudoContext)
}

func (s *PseudoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PseudoContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PseudoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterPseudo(s)
	}
}

func (s *PseudoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitPseudo(s)
	}
}

func (p *css3Parser) Pseudo() (localctx IPseudoContext) {
	this := p
	_ = this

	localctx = NewPseudoContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, css3ParserRULE_pseudo)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(462)
		p.Match(css3ParserT__2)
	}
	p.SetState(464)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == css3ParserT__2 {
		{
			p.SetState(463)
			p.Match(css3ParserT__2)
		}

	}
	p.SetState(468)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case css3ParserMediaOnly, css3ParserNot, css3ParserAnd, css3ParserOr, css3ParserFrom, css3ParserTo, css3ParserIdent:
		{
			p.SetState(466)
			p.Ident()
		}

	case css3ParserFunction_:
		{
			p.SetState(467)
			p.FunctionalPseudo()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFunctionalPseudoContext is an interface to support dynamic dispatch.
type IFunctionalPseudoContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionalPseudoContext differentiates from other interfaces.
	IsFunctionalPseudoContext()
}

type FunctionalPseudoContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionalPseudoContext() *FunctionalPseudoContext {
	var p = new(FunctionalPseudoContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_functionalPseudo
	return p
}

func (*FunctionalPseudoContext) IsFunctionalPseudoContext() {}

func NewFunctionalPseudoContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionalPseudoContext {
	var p = new(FunctionalPseudoContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_functionalPseudo

	return p
}

func (s *FunctionalPseudoContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionalPseudoContext) Function_() antlr.TerminalNode {
	return s.GetToken(css3ParserFunction_, 0)
}

func (s *FunctionalPseudoContext) Ws() IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *FunctionalPseudoContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FunctionalPseudoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionalPseudoContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionalPseudoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterFunctionalPseudo(s)
	}
}

func (s *FunctionalPseudoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitFunctionalPseudo(s)
	}
}

func (p *css3Parser) FunctionalPseudo() (localctx IFunctionalPseudoContext) {
	this := p
	_ = this

	localctx = NewFunctionalPseudoContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, css3ParserRULE_functionalPseudo)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(470)
		p.Match(css3ParserFunction_)
	}
	{
		p.SetState(471)
		p.Ws()
	}
	{
		p.SetState(472)
		p.Expression()
	}
	{
		p.SetState(473)
		p.Match(css3ParserT__3)
	}

	return localctx
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_expression
	return p
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) AllWs() []IWsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWsContext)(nil)).Elem())
	var tst = make([]IWsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWsContext)
		}
	}

	return tst
}

func (s *ExpressionContext) Ws(i int) IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *ExpressionContext) AllPlus() []antlr.TerminalNode {
	return s.GetTokens(css3ParserPlus)
}

func (s *ExpressionContext) Plus(i int) antlr.TerminalNode {
	return s.GetToken(css3ParserPlus, i)
}

func (s *ExpressionContext) AllMinus() []antlr.TerminalNode {
	return s.GetTokens(css3ParserMinus)
}

func (s *ExpressionContext) Minus(i int) antlr.TerminalNode {
	return s.GetToken(css3ParserMinus, i)
}

func (s *ExpressionContext) AllDimension() []antlr.TerminalNode {
	return s.GetTokens(css3ParserDimension)
}

func (s *ExpressionContext) Dimension(i int) antlr.TerminalNode {
	return s.GetToken(css3ParserDimension, i)
}

func (s *ExpressionContext) AllUnknownDimension() []antlr.TerminalNode {
	return s.GetTokens(css3ParserUnknownDimension)
}

func (s *ExpressionContext) UnknownDimension(i int) antlr.TerminalNode {
	return s.GetToken(css3ParserUnknownDimension, i)
}

func (s *ExpressionContext) AllNumber() []antlr.TerminalNode {
	return s.GetTokens(css3ParserNumber)
}

func (s *ExpressionContext) Number(i int) antlr.TerminalNode {
	return s.GetToken(css3ParserNumber, i)
}

func (s *ExpressionContext) AllString_() []antlr.TerminalNode {
	return s.GetTokens(css3ParserString_)
}

func (s *ExpressionContext) String_(i int) antlr.TerminalNode {
	return s.GetToken(css3ParserString_, i)
}

func (s *ExpressionContext) AllIdent() []IIdentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentContext)(nil)).Elem())
	var tst = make([]IIdentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentContext)
		}
	}

	return tst
}

func (s *ExpressionContext) Ident(i int) IIdentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterExpression(s)
	}
}

func (s *ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitExpression(s)
	}
}

func (p *css3Parser) Expression() (localctx IExpressionContext) {
	this := p
	_ = this

	localctx = NewExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, css3ParserRULE_expression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(485)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(css3ParserMediaOnly-32))|(1<<(css3ParserNot-32))|(1<<(css3ParserAnd-32))|(1<<(css3ParserDimension-32))|(1<<(css3ParserUnknownDimension-32))|(1<<(css3ParserPlus-32))|(1<<(css3ParserMinus-32))|(1<<(css3ParserNumber-32))|(1<<(css3ParserString_-32))|(1<<(css3ParserOr-32))|(1<<(css3ParserFrom-32))|(1<<(css3ParserTo-32))|(1<<(css3ParserIdent-32)))) != 0) {
		p.SetState(482)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case css3ParserPlus:
			{
				p.SetState(475)
				p.Match(css3ParserPlus)
			}

		case css3ParserMinus:
			{
				p.SetState(476)
				p.Match(css3ParserMinus)
			}

		case css3ParserDimension:
			{
				p.SetState(477)
				p.Match(css3ParserDimension)
			}

		case css3ParserUnknownDimension:
			{
				p.SetState(478)
				p.Match(css3ParserUnknownDimension)
			}

		case css3ParserNumber:
			{
				p.SetState(479)
				p.Match(css3ParserNumber)
			}

		case css3ParserString_:
			{
				p.SetState(480)
				p.Match(css3ParserString_)
			}

		case css3ParserMediaOnly, css3ParserNot, css3ParserAnd, css3ParserOr, css3ParserFrom, css3ParserTo, css3ParserIdent:
			{
				p.SetState(481)
				p.Ident()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(484)
			p.Ws()
		}

		p.SetState(487)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// INegationContext is an interface to support dynamic dispatch.
type INegationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNegationContext differentiates from other interfaces.
	IsNegationContext()
}

type NegationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNegationContext() *NegationContext {
	var p = new(NegationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_negation
	return p
}

func (*NegationContext) IsNegationContext() {}

func NewNegationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NegationContext {
	var p = new(NegationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_negation

	return p
}

func (s *NegationContext) GetParser() antlr.Parser { return s.parser }

func (s *NegationContext) PseudoNot() antlr.TerminalNode {
	return s.GetToken(css3ParserPseudoNot, 0)
}

func (s *NegationContext) AllWs() []IWsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWsContext)(nil)).Elem())
	var tst = make([]IWsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWsContext)
		}
	}

	return tst
}

func (s *NegationContext) Ws(i int) IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *NegationContext) NegationArg() INegationArgContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INegationArgContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INegationArgContext)
}

func (s *NegationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NegationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NegationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterNegation(s)
	}
}

func (s *NegationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitNegation(s)
	}
}

func (p *css3Parser) Negation() (localctx INegationContext) {
	this := p
	_ = this

	localctx = NewNegationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, css3ParserRULE_negation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(489)
		p.Match(css3ParserPseudoNot)
	}
	{
		p.SetState(490)
		p.Ws()
	}
	{
		p.SetState(491)
		p.NegationArg()
	}
	{
		p.SetState(492)
		p.Ws()
	}
	{
		p.SetState(493)
		p.Match(css3ParserT__3)
	}

	return localctx
}

// INegationArgContext is an interface to support dynamic dispatch.
type INegationArgContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNegationArgContext differentiates from other interfaces.
	IsNegationArgContext()
}

type NegationArgContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNegationArgContext() *NegationArgContext {
	var p = new(NegationArgContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_negationArg
	return p
}

func (*NegationArgContext) IsNegationArgContext() {}

func NewNegationArgContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NegationArgContext {
	var p = new(NegationArgContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_negationArg

	return p
}

func (s *NegationArgContext) GetParser() antlr.Parser { return s.parser }

func (s *NegationArgContext) TypeSelector() ITypeSelectorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeSelectorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeSelectorContext)
}

func (s *NegationArgContext) Universal() IUniversalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUniversalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUniversalContext)
}

func (s *NegationArgContext) Hash() antlr.TerminalNode {
	return s.GetToken(css3ParserHash, 0)
}

func (s *NegationArgContext) ClassName() IClassNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassNameContext)
}

func (s *NegationArgContext) Attrib() IAttribContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribContext)
}

func (s *NegationArgContext) Pseudo() IPseudoContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPseudoContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPseudoContext)
}

func (s *NegationArgContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NegationArgContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NegationArgContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterNegationArg(s)
	}
}

func (s *NegationArgContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitNegationArg(s)
	}
}

func (p *css3Parser) NegationArg() (localctx INegationArgContext) {
	this := p
	_ = this

	localctx = NewNegationArgContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, css3ParserRULE_negationArg)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(501)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 43, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(495)
			p.TypeSelector()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(496)
			p.Universal()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(497)
			p.Match(css3ParserHash)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(498)
			p.ClassName()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(499)
			p.Attrib()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(500)
			p.Pseudo()
		}

	}

	return localctx
}

// IOperator_Context is an interface to support dynamic dispatch.
type IOperator_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOperator_Context differentiates from other interfaces.
	IsOperator_Context()
}

type Operator_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOperator_Context() *Operator_Context {
	var p = new(Operator_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_operator_
	return p
}

func (*Operator_Context) IsOperator_Context() {}

func NewOperator_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Operator_Context {
	var p = new(Operator_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_operator_

	return p
}

func (s *Operator_Context) GetParser() antlr.Parser { return s.parser }

func (s *Operator_Context) CopyFrom(ctx *Operator_Context) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *Operator_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Operator_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type BadOperatorContext struct {
	*Operator_Context
}

func NewBadOperatorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BadOperatorContext {
	var p = new(BadOperatorContext)

	p.Operator_Context = NewEmptyOperator_Context()
	p.parser = parser
	p.CopyFrom(ctx.(*Operator_Context))

	return p
}

func (s *BadOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BadOperatorContext) Ws() IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *BadOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterBadOperator(s)
	}
}

func (s *BadOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitBadOperator(s)
	}
}

type GoodOperatorContext struct {
	*Operator_Context
}

func NewGoodOperatorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GoodOperatorContext {
	var p = new(GoodOperatorContext)

	p.Operator_Context = NewEmptyOperator_Context()
	p.parser = parser
	p.CopyFrom(ctx.(*Operator_Context))

	return p
}

func (s *GoodOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GoodOperatorContext) Ws() IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *GoodOperatorContext) Comma() antlr.TerminalNode {
	return s.GetToken(css3ParserComma, 0)
}

func (s *GoodOperatorContext) Space() antlr.TerminalNode {
	return s.GetToken(css3ParserSpace, 0)
}

func (s *GoodOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterGoodOperator(s)
	}
}

func (s *GoodOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitGoodOperator(s)
	}
}

func (p *css3Parser) Operator_() (localctx IOperator_Context) {
	this := p
	_ = this

	localctx = NewOperator_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, css3ParserRULE_operator_)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(511)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case css3ParserT__12:
		localctx = NewGoodOperatorContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(503)
			p.Match(css3ParserT__12)
		}
		{
			p.SetState(504)
			p.Ws()
		}

	case css3ParserComma:
		localctx = NewGoodOperatorContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(505)
			p.Match(css3ParserComma)
		}
		{
			p.SetState(506)
			p.Ws()
		}

	case css3ParserSpace:
		localctx = NewGoodOperatorContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(507)
			p.Match(css3ParserSpace)
		}
		{
			p.SetState(508)
			p.Ws()
		}

	case css3ParserT__10:
		localctx = NewBadOperatorContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(509)
			p.Match(css3ParserT__10)
		}
		{
			p.SetState(510)
			p.Ws()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IProperty_Context is an interface to support dynamic dispatch.
type IProperty_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProperty_Context differentiates from other interfaces.
	IsProperty_Context()
}

type Property_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProperty_Context() *Property_Context {
	var p = new(Property_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_property_
	return p
}

func (*Property_Context) IsProperty_Context() {}

func NewProperty_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Property_Context {
	var p = new(Property_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_property_

	return p
}

func (s *Property_Context) GetParser() antlr.Parser { return s.parser }

func (s *Property_Context) CopyFrom(ctx *Property_Context) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *Property_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Property_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type BadPropertyContext struct {
	*Property_Context
}

func NewBadPropertyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BadPropertyContext {
	var p = new(BadPropertyContext)

	p.Property_Context = NewEmptyProperty_Context()
	p.parser = parser
	p.CopyFrom(ctx.(*Property_Context))

	return p
}

func (s *BadPropertyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BadPropertyContext) Ident() IIdentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *BadPropertyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterBadProperty(s)
	}
}

func (s *BadPropertyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitBadProperty(s)
	}
}

type GoodPropertyContext struct {
	*Property_Context
}

func NewGoodPropertyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GoodPropertyContext {
	var p = new(GoodPropertyContext)

	p.Property_Context = NewEmptyProperty_Context()
	p.parser = parser
	p.CopyFrom(ctx.(*Property_Context))

	return p
}

func (s *GoodPropertyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GoodPropertyContext) Ident() IIdentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *GoodPropertyContext) Ws() IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *GoodPropertyContext) Variable() antlr.TerminalNode {
	return s.GetToken(css3ParserVariable, 0)
}

func (s *GoodPropertyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterGoodProperty(s)
	}
}

func (s *GoodPropertyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitGoodProperty(s)
	}
}

func (p *css3Parser) Property_() (localctx IProperty_Context) {
	this := p
	_ = this

	localctx = NewProperty_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, css3ParserRULE_property_)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(522)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case css3ParserMediaOnly, css3ParserNot, css3ParserAnd, css3ParserOr, css3ParserFrom, css3ParserTo, css3ParserIdent:
		localctx = NewGoodPropertyContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(513)
			p.Ident()
		}
		{
			p.SetState(514)
			p.Ws()
		}

	case css3ParserVariable:
		localctx = NewGoodPropertyContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(516)
			p.Match(css3ParserVariable)
		}
		{
			p.SetState(517)
			p.Ws()
		}

	case css3ParserT__6:
		localctx = NewBadPropertyContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(518)
			p.Match(css3ParserT__6)
		}
		{
			p.SetState(519)
			p.Ident()
		}

	case css3ParserT__13:
		localctx = NewBadPropertyContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(520)
			p.Match(css3ParserT__13)
		}
		{
			p.SetState(521)
			p.Ident()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IRulesetContext is an interface to support dynamic dispatch.
type IRulesetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRulesetContext differentiates from other interfaces.
	IsRulesetContext()
}

type RulesetContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRulesetContext() *RulesetContext {
	var p = new(RulesetContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_ruleset
	return p
}

func (*RulesetContext) IsRulesetContext() {}

func NewRulesetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RulesetContext {
	var p = new(RulesetContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_ruleset

	return p
}

func (s *RulesetContext) GetParser() antlr.Parser { return s.parser }

func (s *RulesetContext) CopyFrom(ctx *RulesetContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *RulesetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RulesetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type UnknownRulesetContext struct {
	*RulesetContext
}

func NewUnknownRulesetContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnknownRulesetContext {
	var p = new(UnknownRulesetContext)

	p.RulesetContext = NewEmptyRulesetContext()
	p.parser = parser
	p.CopyFrom(ctx.(*RulesetContext))

	return p
}

func (s *UnknownRulesetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnknownRulesetContext) AllWs() []IWsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWsContext)(nil)).Elem())
	var tst = make([]IWsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWsContext)
		}
	}

	return tst
}

func (s *UnknownRulesetContext) Ws(i int) IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *UnknownRulesetContext) AllAny_() []IAny_Context {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAny_Context)(nil)).Elem())
	var tst = make([]IAny_Context, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAny_Context)
		}
	}

	return tst
}

func (s *UnknownRulesetContext) Any_(i int) IAny_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAny_Context)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAny_Context)
}

func (s *UnknownRulesetContext) DeclarationList() IDeclarationListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclarationListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclarationListContext)
}

func (s *UnknownRulesetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterUnknownRuleset(s)
	}
}

func (s *UnknownRulesetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitUnknownRuleset(s)
	}
}

type KnownRulesetContext struct {
	*RulesetContext
}

func NewKnownRulesetContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *KnownRulesetContext {
	var p = new(KnownRulesetContext)

	p.RulesetContext = NewEmptyRulesetContext()
	p.parser = parser
	p.CopyFrom(ctx.(*RulesetContext))

	return p
}

func (s *KnownRulesetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KnownRulesetContext) SelectorGroup() ISelectorGroupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectorGroupContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelectorGroupContext)
}

func (s *KnownRulesetContext) AllWs() []IWsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWsContext)(nil)).Elem())
	var tst = make([]IWsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWsContext)
		}
	}

	return tst
}

func (s *KnownRulesetContext) Ws(i int) IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *KnownRulesetContext) DeclarationList() IDeclarationListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclarationListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclarationListContext)
}

func (s *KnownRulesetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterKnownRuleset(s)
	}
}

func (s *KnownRulesetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitKnownRuleset(s)
	}
}

func (p *css3Parser) Ruleset() (localctx IRulesetContext) {
	this := p
	_ = this

	localctx = NewRulesetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, css3ParserRULE_ruleset)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(547)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 49, p.GetParserRuleContext()) {
	case 1:
		localctx = NewKnownRulesetContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(524)
			p.SelectorGroup()
		}
		{
			p.SetState(525)
			p.Match(css3ParserT__4)
		}
		{
			p.SetState(526)
			p.Ws()
		}
		p.SetState(528)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<css3ParserT__0)|(1<<css3ParserT__6)|(1<<css3ParserT__13))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(css3ParserMediaOnly-32))|(1<<(css3ParserNot-32))|(1<<(css3ParserAnd-32))|(1<<(css3ParserOr-32))|(1<<(css3ParserFrom-32))|(1<<(css3ParserTo-32))|(1<<(css3ParserVariable-32))|(1<<(css3ParserIdent-32)))) != 0) {
			{
				p.SetState(527)
				p.DeclarationList()
			}

		}
		{
			p.SetState(530)
			p.Match(css3ParserT__5)
		}
		{
			p.SetState(531)
			p.Ws()
		}

	case 2:
		localctx = NewUnknownRulesetContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(536)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<css3ParserT__1)|(1<<css3ParserT__2)|(1<<css3ParserT__9)|(1<<css3ParserIncludes)|(1<<css3ParserDashMatch)|(1<<css3ParserHash)|(1<<css3ParserPercentage)|(1<<css3ParserUri)|(1<<css3ParserUnicodeRange))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(css3ParserMediaOnly-32))|(1<<(css3ParserNot-32))|(1<<(css3ParserAnd-32))|(1<<(css3ParserDimension-32))|(1<<(css3ParserUnknownDimension-32))|(1<<(css3ParserPlus-32))|(1<<(css3ParserMinus-32))|(1<<(css3ParserNumber-32))|(1<<(css3ParserString_-32))|(1<<(css3ParserOr-32))|(1<<(css3ParserFrom-32))|(1<<(css3ParserTo-32))|(1<<(css3ParserIdent-32))|(1<<(css3ParserFunction_-32)))) != 0) {
			{
				p.SetState(533)
				p.Any_()
			}

			p.SetState(538)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(539)
			p.Match(css3ParserT__4)
		}
		{
			p.SetState(540)
			p.Ws()
		}
		p.SetState(542)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<css3ParserT__0)|(1<<css3ParserT__6)|(1<<css3ParserT__13))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(css3ParserMediaOnly-32))|(1<<(css3ParserNot-32))|(1<<(css3ParserAnd-32))|(1<<(css3ParserOr-32))|(1<<(css3ParserFrom-32))|(1<<(css3ParserTo-32))|(1<<(css3ParserVariable-32))|(1<<(css3ParserIdent-32)))) != 0) {
			{
				p.SetState(541)
				p.DeclarationList()
			}

		}
		{
			p.SetState(544)
			p.Match(css3ParserT__5)
		}
		{
			p.SetState(545)
			p.Ws()
		}

	}

	return localctx
}

// IDeclarationListContext is an interface to support dynamic dispatch.
type IDeclarationListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeclarationListContext differentiates from other interfaces.
	IsDeclarationListContext()
}

type DeclarationListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclarationListContext() *DeclarationListContext {
	var p = new(DeclarationListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_declarationList
	return p
}

func (*DeclarationListContext) IsDeclarationListContext() {}

func NewDeclarationListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclarationListContext {
	var p = new(DeclarationListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_declarationList

	return p
}

func (s *DeclarationListContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclarationListContext) AllDeclaration() []IDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDeclarationContext)(nil)).Elem())
	var tst = make([]IDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDeclarationContext)
		}
	}

	return tst
}

func (s *DeclarationListContext) Declaration(i int) IDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDeclarationContext)
}

func (s *DeclarationListContext) AllWs() []IWsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWsContext)(nil)).Elem())
	var tst = make([]IWsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWsContext)
		}
	}

	return tst
}

func (s *DeclarationListContext) Ws(i int) IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *DeclarationListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclarationListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclarationListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterDeclarationList(s)
	}
}

func (s *DeclarationListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitDeclarationList(s)
	}
}

func (p *css3Parser) DeclarationList() (localctx IDeclarationListContext) {
	this := p
	_ = this

	localctx = NewDeclarationListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, css3ParserRULE_declarationList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(553)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == css3ParserT__0 {
		{
			p.SetState(549)
			p.Match(css3ParserT__0)
		}
		{
			p.SetState(550)
			p.Ws()
		}

		p.SetState(555)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(556)
		p.Declaration()
	}
	{
		p.SetState(557)
		p.Ws()
	}
	p.SetState(565)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 52, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(558)
				p.Match(css3ParserT__0)
			}
			{
				p.SetState(559)
				p.Ws()
			}
			p.SetState(561)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 51, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(560)
					p.Declaration()
				}

			}

		}
		p.SetState(567)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 52, p.GetParserRuleContext())
	}

	return localctx
}

// IDeclarationContext is an interface to support dynamic dispatch.
type IDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeclarationContext differentiates from other interfaces.
	IsDeclarationContext()
}

type DeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclarationContext() *DeclarationContext {
	var p = new(DeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_declaration
	return p
}

func (*DeclarationContext) IsDeclarationContext() {}

func NewDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclarationContext {
	var p = new(DeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_declaration

	return p
}

func (s *DeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclarationContext) CopyFrom(ctx *DeclarationContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *DeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type UnknownDeclarationContext struct {
	*DeclarationContext
}

func NewUnknownDeclarationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnknownDeclarationContext {
	var p = new(UnknownDeclarationContext)

	p.DeclarationContext = NewEmptyDeclarationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*DeclarationContext))

	return p
}

func (s *UnknownDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnknownDeclarationContext) Property_() IProperty_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProperty_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProperty_Context)
}

func (s *UnknownDeclarationContext) Ws() IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *UnknownDeclarationContext) Value() IValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueContext)
}

func (s *UnknownDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterUnknownDeclaration(s)
	}
}

func (s *UnknownDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitUnknownDeclaration(s)
	}
}

type KnownDeclarationContext struct {
	*DeclarationContext
}

func NewKnownDeclarationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *KnownDeclarationContext {
	var p = new(KnownDeclarationContext)

	p.DeclarationContext = NewEmptyDeclarationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*DeclarationContext))

	return p
}

func (s *KnownDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KnownDeclarationContext) Property_() IProperty_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProperty_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProperty_Context)
}

func (s *KnownDeclarationContext) Ws() IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *KnownDeclarationContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *KnownDeclarationContext) Prio() IPrioContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrioContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrioContext)
}

func (s *KnownDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterKnownDeclaration(s)
	}
}

func (s *KnownDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitKnownDeclaration(s)
	}
}

func (p *css3Parser) Declaration() (localctx IDeclarationContext) {
	this := p
	_ = this

	localctx = NewDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, css3ParserRULE_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(580)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 54, p.GetParserRuleContext()) {
	case 1:
		localctx = NewKnownDeclarationContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(568)
			p.Property_()
		}
		{
			p.SetState(569)
			p.Match(css3ParserT__2)
		}
		{
			p.SetState(570)
			p.Ws()
		}
		{
			p.SetState(571)
			p.Expr()
		}
		p.SetState(573)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == css3ParserImportant {
			{
				p.SetState(572)
				p.Prio()
			}

		}

	case 2:
		localctx = NewUnknownDeclarationContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(575)
			p.Property_()
		}
		{
			p.SetState(576)
			p.Match(css3ParserT__2)
		}
		{
			p.SetState(577)
			p.Ws()
		}
		{
			p.SetState(578)
			p.Value()
		}

	}

	return localctx
}

// IPrioContext is an interface to support dynamic dispatch.
type IPrioContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrioContext differentiates from other interfaces.
	IsPrioContext()
}

type PrioContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrioContext() *PrioContext {
	var p = new(PrioContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_prio
	return p
}

func (*PrioContext) IsPrioContext() {}

func NewPrioContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrioContext {
	var p = new(PrioContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_prio

	return p
}

func (s *PrioContext) GetParser() antlr.Parser { return s.parser }

func (s *PrioContext) Important() antlr.TerminalNode {
	return s.GetToken(css3ParserImportant, 0)
}

func (s *PrioContext) Ws() IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *PrioContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrioContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrioContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterPrio(s)
	}
}

func (s *PrioContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitPrio(s)
	}
}

func (p *css3Parser) Prio() (localctx IPrioContext) {
	this := p
	_ = this

	localctx = NewPrioContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, css3ParserRULE_prio)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(582)
		p.Match(css3ParserImportant)
	}
	{
		p.SetState(583)
		p.Ws()
	}

	return localctx
}

// IValueContext is an interface to support dynamic dispatch.
type IValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsValueContext differentiates from other interfaces.
	IsValueContext()
}

type ValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueContext() *ValueContext {
	var p = new(ValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_value
	return p
}

func (*ValueContext) IsValueContext() {}

func NewValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueContext {
	var p = new(ValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_value

	return p
}

func (s *ValueContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueContext) AllAny_() []IAny_Context {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAny_Context)(nil)).Elem())
	var tst = make([]IAny_Context, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAny_Context)
		}
	}

	return tst
}

func (s *ValueContext) Any_(i int) IAny_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAny_Context)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAny_Context)
}

func (s *ValueContext) AllBlock() []IBlockContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBlockContext)(nil)).Elem())
	var tst = make([]IBlockContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBlockContext)
		}
	}

	return tst
}

func (s *ValueContext) Block(i int) IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *ValueContext) AllAtKeyword() []IAtKeywordContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAtKeywordContext)(nil)).Elem())
	var tst = make([]IAtKeywordContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAtKeywordContext)
		}
	}

	return tst
}

func (s *ValueContext) AtKeyword(i int) IAtKeywordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtKeywordContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAtKeywordContext)
}

func (s *ValueContext) AllWs() []IWsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWsContext)(nil)).Elem())
	var tst = make([]IWsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWsContext)
		}
	}

	return tst
}

func (s *ValueContext) Ws(i int) IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *ValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterValue(s)
	}
}

func (s *ValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitValue(s)
	}
}

func (p *css3Parser) Value() (localctx IValueContext) {
	this := p
	_ = this

	localctx = NewValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, css3ParserRULE_value)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(590)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			p.SetState(590)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case css3ParserT__1, css3ParserT__2, css3ParserT__9, css3ParserIncludes, css3ParserDashMatch, css3ParserHash, css3ParserPercentage, css3ParserUri, css3ParserUnicodeRange, css3ParserMediaOnly, css3ParserNot, css3ParserAnd, css3ParserDimension, css3ParserUnknownDimension, css3ParserPlus, css3ParserMinus, css3ParserNumber, css3ParserString_, css3ParserOr, css3ParserFrom, css3ParserTo, css3ParserIdent, css3ParserFunction_:
				{
					p.SetState(585)
					p.Any_()
				}

			case css3ParserT__4:
				{
					p.SetState(586)
					p.Block()
				}

			case css3ParserT__14:
				{
					p.SetState(587)
					p.AtKeyword()
				}
				{
					p.SetState(588)
					p.Ws()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(592)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 56, p.GetParserRuleContext())
	}

	return localctx
}

// IExprContext is an interface to support dynamic dispatch.
type IExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExprContext differentiates from other interfaces.
	IsExprContext()
}

type ExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprContext() *ExprContext {
	var p = new(ExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_expr
	return p
}

func (*ExprContext) IsExprContext() {}

func NewExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprContext {
	var p = new(ExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_expr

	return p
}

func (s *ExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprContext) AllTerm() []ITermContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITermContext)(nil)).Elem())
	var tst = make([]ITermContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITermContext)
		}
	}

	return tst
}

func (s *ExprContext) Term(i int) ITermContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITermContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *ExprContext) AllOperator_() []IOperator_Context {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOperator_Context)(nil)).Elem())
	var tst = make([]IOperator_Context, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOperator_Context)
		}
	}

	return tst
}

func (s *ExprContext) Operator_(i int) IOperator_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOperator_Context)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOperator_Context)
}

func (s *ExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterExpr(s)
	}
}

func (s *ExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitExpr(s)
	}
}

func (p *css3Parser) Expr() (localctx IExprContext) {
	this := p
	_ = this

	localctx = NewExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, css3ParserRULE_expr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(594)
		p.Term()
	}
	p.SetState(601)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 58, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(596)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if ((_la-11)&-(0x1f+1)) == 0 && ((1<<uint((_la-11)))&((1<<(css3ParserT__10-11))|(1<<(css3ParserT__12-11))|(1<<(css3ParserSpace-11))|(1<<(css3ParserComma-11)))) != 0 {
				{
					p.SetState(595)
					p.Operator_()
				}

			}
			{
				p.SetState(598)
				p.Term()
			}

		}
		p.SetState(603)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 58, p.GetParserRuleContext())
	}

	return localctx
}

// ITermContext is an interface to support dynamic dispatch.
type ITermContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTermContext differentiates from other interfaces.
	IsTermContext()
}

type TermContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTermContext() *TermContext {
	var p = new(TermContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_term
	return p
}

func (*TermContext) IsTermContext() {}

func NewTermContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TermContext {
	var p = new(TermContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_term

	return p
}

func (s *TermContext) GetParser() antlr.Parser { return s.parser }

func (s *TermContext) CopyFrom(ctx *TermContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *TermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TermContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type BadTermContext struct {
	*TermContext
}

func NewBadTermContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BadTermContext {
	var p = new(BadTermContext)

	p.TermContext = NewEmptyTermContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TermContext))

	return p
}

func (s *BadTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BadTermContext) DxImageTransform() IDxImageTransformContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDxImageTransformContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDxImageTransformContext)
}

func (s *BadTermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterBadTerm(s)
	}
}

func (s *BadTermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitBadTerm(s)
	}
}

type KnownTermContext struct {
	*TermContext
}

func NewKnownTermContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *KnownTermContext {
	var p = new(KnownTermContext)

	p.TermContext = NewEmptyTermContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TermContext))

	return p
}

func (s *KnownTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KnownTermContext) Number() INumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *KnownTermContext) Ws() IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *KnownTermContext) Percentage() IPercentageContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPercentageContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPercentageContext)
}

func (s *KnownTermContext) Dimension() IDimensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDimensionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDimensionContext)
}

func (s *KnownTermContext) String_() antlr.TerminalNode {
	return s.GetToken(css3ParserString_, 0)
}

func (s *KnownTermContext) UnicodeRange() antlr.TerminalNode {
	return s.GetToken(css3ParserUnicodeRange, 0)
}

func (s *KnownTermContext) Ident() IIdentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *KnownTermContext) Var_() IVar_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVar_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVar_Context)
}

func (s *KnownTermContext) Uri() antlr.TerminalNode {
	return s.GetToken(css3ParserUri, 0)
}

func (s *KnownTermContext) Hexcolor() IHexcolorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHexcolorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHexcolorContext)
}

func (s *KnownTermContext) Calc() ICalcContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICalcContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICalcContext)
}

func (s *KnownTermContext) Function_() IFunction_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_Context)
}

func (s *KnownTermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterKnownTerm(s)
	}
}

func (s *KnownTermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitKnownTerm(s)
	}
}

type UnknownTermContext struct {
	*TermContext
}

func NewUnknownTermContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnknownTermContext {
	var p = new(UnknownTermContext)

	p.TermContext = NewEmptyTermContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TermContext))

	return p
}

func (s *UnknownTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnknownTermContext) UnknownDimension() IUnknownDimensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnknownDimensionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnknownDimensionContext)
}

func (s *UnknownTermContext) Ws() IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *UnknownTermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterUnknownTerm(s)
	}
}

func (s *UnknownTermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitUnknownTerm(s)
	}
}

func (p *css3Parser) Term() (localctx ITermContext) {
	this := p
	_ = this

	localctx = NewTermContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, css3ParserRULE_term)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(630)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 59, p.GetParserRuleContext()) {
	case 1:
		localctx = NewKnownTermContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(604)
			p.Number()
		}
		{
			p.SetState(605)
			p.Ws()
		}

	case 2:
		localctx = NewKnownTermContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(607)
			p.Percentage()
		}
		{
			p.SetState(608)
			p.Ws()
		}

	case 3:
		localctx = NewKnownTermContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(610)
			p.Dimension()
		}
		{
			p.SetState(611)
			p.Ws()
		}

	case 4:
		localctx = NewKnownTermContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(613)
			p.Match(css3ParserString_)
		}
		{
			p.SetState(614)
			p.Ws()
		}

	case 5:
		localctx = NewKnownTermContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(615)
			p.Match(css3ParserUnicodeRange)
		}
		{
			p.SetState(616)
			p.Ws()
		}

	case 6:
		localctx = NewKnownTermContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(617)
			p.Ident()
		}
		{
			p.SetState(618)
			p.Ws()
		}

	case 7:
		localctx = NewKnownTermContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(620)
			p.Var_()
		}

	case 8:
		localctx = NewKnownTermContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(621)
			p.Match(css3ParserUri)
		}
		{
			p.SetState(622)
			p.Ws()
		}

	case 9:
		localctx = NewKnownTermContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(623)
			p.Hexcolor()
		}

	case 10:
		localctx = NewKnownTermContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(624)
			p.Calc()
		}

	case 11:
		localctx = NewKnownTermContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(625)
			p.Function_()
		}

	case 12:
		localctx = NewUnknownTermContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(626)
			p.UnknownDimension()
		}
		{
			p.SetState(627)
			p.Ws()
		}

	case 13:
		localctx = NewBadTermContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(629)
			p.DxImageTransform()
		}

	}

	return localctx
}

// IFunction_Context is an interface to support dynamic dispatch.
type IFunction_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_Context differentiates from other interfaces.
	IsFunction_Context()
}

type Function_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_Context() *Function_Context {
	var p = new(Function_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_function_
	return p
}

func (*Function_Context) IsFunction_Context() {}

func NewFunction_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_Context {
	var p = new(Function_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_function_

	return p
}

func (s *Function_Context) GetParser() antlr.Parser { return s.parser }

func (s *Function_Context) Function_() antlr.TerminalNode {
	return s.GetToken(css3ParserFunction_, 0)
}

func (s *Function_Context) AllWs() []IWsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWsContext)(nil)).Elem())
	var tst = make([]IWsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWsContext)
		}
	}

	return tst
}

func (s *Function_Context) Ws(i int) IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *Function_Context) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Function_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterFunction_(s)
	}
}

func (s *Function_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitFunction_(s)
	}
}

func (p *css3Parser) Function_() (localctx IFunction_Context) {
	this := p
	_ = this

	localctx = NewFunction_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, css3ParserRULE_function_)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(632)
		p.Match(css3ParserFunction_)
	}
	{
		p.SetState(633)
		p.Ws()
	}
	{
		p.SetState(634)
		p.Expr()
	}
	{
		p.SetState(635)
		p.Match(css3ParserT__3)
	}
	{
		p.SetState(636)
		p.Ws()
	}

	return localctx
}

// IDxImageTransformContext is an interface to support dynamic dispatch.
type IDxImageTransformContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDxImageTransformContext differentiates from other interfaces.
	IsDxImageTransformContext()
}

type DxImageTransformContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDxImageTransformContext() *DxImageTransformContext {
	var p = new(DxImageTransformContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_dxImageTransform
	return p
}

func (*DxImageTransformContext) IsDxImageTransformContext() {}

func NewDxImageTransformContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DxImageTransformContext {
	var p = new(DxImageTransformContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_dxImageTransform

	return p
}

func (s *DxImageTransformContext) GetParser() antlr.Parser { return s.parser }

func (s *DxImageTransformContext) DxImageTransform() antlr.TerminalNode {
	return s.GetToken(css3ParserDxImageTransform, 0)
}

func (s *DxImageTransformContext) AllWs() []IWsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWsContext)(nil)).Elem())
	var tst = make([]IWsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWsContext)
		}
	}

	return tst
}

func (s *DxImageTransformContext) Ws(i int) IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *DxImageTransformContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *DxImageTransformContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DxImageTransformContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DxImageTransformContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterDxImageTransform(s)
	}
}

func (s *DxImageTransformContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitDxImageTransform(s)
	}
}

func (p *css3Parser) DxImageTransform() (localctx IDxImageTransformContext) {
	this := p
	_ = this

	localctx = NewDxImageTransformContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, css3ParserRULE_dxImageTransform)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(638)
		p.Match(css3ParserDxImageTransform)
	}
	{
		p.SetState(639)
		p.Ws()
	}
	{
		p.SetState(640)
		p.Expr()
	}
	{
		p.SetState(641)
		p.Match(css3ParserT__3)
	}
	{
		p.SetState(642)
		p.Ws()
	}

	return localctx
}

// IHexcolorContext is an interface to support dynamic dispatch.
type IHexcolorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHexcolorContext differentiates from other interfaces.
	IsHexcolorContext()
}

type HexcolorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHexcolorContext() *HexcolorContext {
	var p = new(HexcolorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_hexcolor
	return p
}

func (*HexcolorContext) IsHexcolorContext() {}

func NewHexcolorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HexcolorContext {
	var p = new(HexcolorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_hexcolor

	return p
}

func (s *HexcolorContext) GetParser() antlr.Parser { return s.parser }

func (s *HexcolorContext) Hash() antlr.TerminalNode {
	return s.GetToken(css3ParserHash, 0)
}

func (s *HexcolorContext) Ws() IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *HexcolorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HexcolorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HexcolorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterHexcolor(s)
	}
}

func (s *HexcolorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitHexcolor(s)
	}
}

func (p *css3Parser) Hexcolor() (localctx IHexcolorContext) {
	this := p
	_ = this

	localctx = NewHexcolorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, css3ParserRULE_hexcolor)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(644)
		p.Match(css3ParserHash)
	}
	{
		p.SetState(645)
		p.Ws()
	}

	return localctx
}

// INumberContext is an interface to support dynamic dispatch.
type INumberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNumberContext differentiates from other interfaces.
	IsNumberContext()
}

type NumberContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumberContext() *NumberContext {
	var p = new(NumberContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_number
	return p
}

func (*NumberContext) IsNumberContext() {}

func NewNumberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumberContext {
	var p = new(NumberContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_number

	return p
}

func (s *NumberContext) GetParser() antlr.Parser { return s.parser }

func (s *NumberContext) Number() antlr.TerminalNode {
	return s.GetToken(css3ParserNumber, 0)
}

func (s *NumberContext) Plus() antlr.TerminalNode {
	return s.GetToken(css3ParserPlus, 0)
}

func (s *NumberContext) Minus() antlr.TerminalNode {
	return s.GetToken(css3ParserMinus, 0)
}

func (s *NumberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NumberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterNumber(s)
	}
}

func (s *NumberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitNumber(s)
	}
}

func (p *css3Parser) Number() (localctx INumberContext) {
	this := p
	_ = this

	localctx = NewNumberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, css3ParserRULE_number)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(648)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == css3ParserPlus || _la == css3ParserMinus {
		{
			p.SetState(647)
			_la = p.GetTokenStream().LA(1)

			if !(_la == css3ParserPlus || _la == css3ParserMinus) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(650)
		p.Match(css3ParserNumber)
	}

	return localctx
}

// IPercentageContext is an interface to support dynamic dispatch.
type IPercentageContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPercentageContext differentiates from other interfaces.
	IsPercentageContext()
}

type PercentageContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPercentageContext() *PercentageContext {
	var p = new(PercentageContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_percentage
	return p
}

func (*PercentageContext) IsPercentageContext() {}

func NewPercentageContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PercentageContext {
	var p = new(PercentageContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_percentage

	return p
}

func (s *PercentageContext) GetParser() antlr.Parser { return s.parser }

func (s *PercentageContext) Percentage() antlr.TerminalNode {
	return s.GetToken(css3ParserPercentage, 0)
}

func (s *PercentageContext) Plus() antlr.TerminalNode {
	return s.GetToken(css3ParserPlus, 0)
}

func (s *PercentageContext) Minus() antlr.TerminalNode {
	return s.GetToken(css3ParserMinus, 0)
}

func (s *PercentageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PercentageContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PercentageContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterPercentage(s)
	}
}

func (s *PercentageContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitPercentage(s)
	}
}

func (p *css3Parser) Percentage() (localctx IPercentageContext) {
	this := p
	_ = this

	localctx = NewPercentageContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, css3ParserRULE_percentage)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(653)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == css3ParserPlus || _la == css3ParserMinus {
		{
			p.SetState(652)
			_la = p.GetTokenStream().LA(1)

			if !(_la == css3ParserPlus || _la == css3ParserMinus) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(655)
		p.Match(css3ParserPercentage)
	}

	return localctx
}

// IDimensionContext is an interface to support dynamic dispatch.
type IDimensionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDimensionContext differentiates from other interfaces.
	IsDimensionContext()
}

type DimensionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDimensionContext() *DimensionContext {
	var p = new(DimensionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_dimension
	return p
}

func (*DimensionContext) IsDimensionContext() {}

func NewDimensionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DimensionContext {
	var p = new(DimensionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_dimension

	return p
}

func (s *DimensionContext) GetParser() antlr.Parser { return s.parser }

func (s *DimensionContext) Dimension() antlr.TerminalNode {
	return s.GetToken(css3ParserDimension, 0)
}

func (s *DimensionContext) Plus() antlr.TerminalNode {
	return s.GetToken(css3ParserPlus, 0)
}

func (s *DimensionContext) Minus() antlr.TerminalNode {
	return s.GetToken(css3ParserMinus, 0)
}

func (s *DimensionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DimensionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DimensionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterDimension(s)
	}
}

func (s *DimensionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitDimension(s)
	}
}

func (p *css3Parser) Dimension() (localctx IDimensionContext) {
	this := p
	_ = this

	localctx = NewDimensionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, css3ParserRULE_dimension)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(658)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == css3ParserPlus || _la == css3ParserMinus {
		{
			p.SetState(657)
			_la = p.GetTokenStream().LA(1)

			if !(_la == css3ParserPlus || _la == css3ParserMinus) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(660)
		p.Match(css3ParserDimension)
	}

	return localctx
}

// IUnknownDimensionContext is an interface to support dynamic dispatch.
type IUnknownDimensionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnknownDimensionContext differentiates from other interfaces.
	IsUnknownDimensionContext()
}

type UnknownDimensionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnknownDimensionContext() *UnknownDimensionContext {
	var p = new(UnknownDimensionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_unknownDimension
	return p
}

func (*UnknownDimensionContext) IsUnknownDimensionContext() {}

func NewUnknownDimensionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnknownDimensionContext {
	var p = new(UnknownDimensionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_unknownDimension

	return p
}

func (s *UnknownDimensionContext) GetParser() antlr.Parser { return s.parser }

func (s *UnknownDimensionContext) UnknownDimension() antlr.TerminalNode {
	return s.GetToken(css3ParserUnknownDimension, 0)
}

func (s *UnknownDimensionContext) Plus() antlr.TerminalNode {
	return s.GetToken(css3ParserPlus, 0)
}

func (s *UnknownDimensionContext) Minus() antlr.TerminalNode {
	return s.GetToken(css3ParserMinus, 0)
}

func (s *UnknownDimensionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnknownDimensionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnknownDimensionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterUnknownDimension(s)
	}
}

func (s *UnknownDimensionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitUnknownDimension(s)
	}
}

func (p *css3Parser) UnknownDimension() (localctx IUnknownDimensionContext) {
	this := p
	_ = this

	localctx = NewUnknownDimensionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, css3ParserRULE_unknownDimension)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(663)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == css3ParserPlus || _la == css3ParserMinus {
		{
			p.SetState(662)
			_la = p.GetTokenStream().LA(1)

			if !(_la == css3ParserPlus || _la == css3ParserMinus) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(665)
		p.Match(css3ParserUnknownDimension)
	}

	return localctx
}

// IAny_Context is an interface to support dynamic dispatch.
type IAny_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAny_Context differentiates from other interfaces.
	IsAny_Context()
}

type Any_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAny_Context() *Any_Context {
	var p = new(Any_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_any_
	return p
}

func (*Any_Context) IsAny_Context() {}

func NewAny_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Any_Context {
	var p = new(Any_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_any_

	return p
}

func (s *Any_Context) GetParser() antlr.Parser { return s.parser }

func (s *Any_Context) Ident() IIdentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Any_Context) AllWs() []IWsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWsContext)(nil)).Elem())
	var tst = make([]IWsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWsContext)
		}
	}

	return tst
}

func (s *Any_Context) Ws(i int) IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *Any_Context) Number() INumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *Any_Context) Percentage() IPercentageContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPercentageContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPercentageContext)
}

func (s *Any_Context) Dimension() IDimensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDimensionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDimensionContext)
}

func (s *Any_Context) UnknownDimension() IUnknownDimensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnknownDimensionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnknownDimensionContext)
}

func (s *Any_Context) String_() antlr.TerminalNode {
	return s.GetToken(css3ParserString_, 0)
}

func (s *Any_Context) Uri() antlr.TerminalNode {
	return s.GetToken(css3ParserUri, 0)
}

func (s *Any_Context) Hash() antlr.TerminalNode {
	return s.GetToken(css3ParserHash, 0)
}

func (s *Any_Context) UnicodeRange() antlr.TerminalNode {
	return s.GetToken(css3ParserUnicodeRange, 0)
}

func (s *Any_Context) Includes() antlr.TerminalNode {
	return s.GetToken(css3ParserIncludes, 0)
}

func (s *Any_Context) DashMatch() antlr.TerminalNode {
	return s.GetToken(css3ParserDashMatch, 0)
}

func (s *Any_Context) Function_() antlr.TerminalNode {
	return s.GetToken(css3ParserFunction_, 0)
}

func (s *Any_Context) AllAny_() []IAny_Context {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAny_Context)(nil)).Elem())
	var tst = make([]IAny_Context, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAny_Context)
		}
	}

	return tst
}

func (s *Any_Context) Any_(i int) IAny_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAny_Context)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAny_Context)
}

func (s *Any_Context) AllUnused() []IUnusedContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IUnusedContext)(nil)).Elem())
	var tst = make([]IUnusedContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IUnusedContext)
		}
	}

	return tst
}

func (s *Any_Context) Unused(i int) IUnusedContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnusedContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IUnusedContext)
}

func (s *Any_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Any_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Any_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterAny_(s)
	}
}

func (s *Any_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitAny_(s)
	}
}

func (p *css3Parser) Any_() (localctx IAny_Context) {
	this := p
	_ = this

	localctx = NewAny_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, css3ParserRULE_any_)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(732)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 70, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(667)
			p.Ident()
		}
		{
			p.SetState(668)
			p.Ws()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(670)
			p.Number()
		}
		{
			p.SetState(671)
			p.Ws()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(673)
			p.Percentage()
		}
		{
			p.SetState(674)
			p.Ws()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(676)
			p.Dimension()
		}
		{
			p.SetState(677)
			p.Ws()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(679)
			p.UnknownDimension()
		}
		{
			p.SetState(680)
			p.Ws()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(682)
			p.Match(css3ParserString_)
		}
		{
			p.SetState(683)
			p.Ws()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(684)
			p.Match(css3ParserUri)
		}
		{
			p.SetState(685)
			p.Ws()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(686)
			p.Match(css3ParserHash)
		}
		{
			p.SetState(687)
			p.Ws()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(688)
			p.Match(css3ParserUnicodeRange)
		}
		{
			p.SetState(689)
			p.Ws()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(690)
			p.Match(css3ParserIncludes)
		}
		{
			p.SetState(691)
			p.Ws()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(692)
			p.Match(css3ParserDashMatch)
		}
		{
			p.SetState(693)
			p.Ws()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(694)
			p.Match(css3ParserT__2)
		}
		{
			p.SetState(695)
			p.Ws()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(696)
			p.Match(css3ParserFunction_)
		}
		{
			p.SetState(697)
			p.Ws()
		}
		p.SetState(702)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<css3ParserT__0)|(1<<css3ParserT__1)|(1<<css3ParserT__2)|(1<<css3ParserT__4)|(1<<css3ParserT__9)|(1<<css3ParserT__14)|(1<<css3ParserCdo)|(1<<css3ParserCdc)|(1<<css3ParserIncludes)|(1<<css3ParserDashMatch)|(1<<css3ParserHash)|(1<<css3ParserPercentage)|(1<<css3ParserUri)|(1<<css3ParserUnicodeRange))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(css3ParserMediaOnly-32))|(1<<(css3ParserNot-32))|(1<<(css3ParserAnd-32))|(1<<(css3ParserDimension-32))|(1<<(css3ParserUnknownDimension-32))|(1<<(css3ParserPlus-32))|(1<<(css3ParserMinus-32))|(1<<(css3ParserNumber-32))|(1<<(css3ParserString_-32))|(1<<(css3ParserOr-32))|(1<<(css3ParserFrom-32))|(1<<(css3ParserTo-32))|(1<<(css3ParserIdent-32))|(1<<(css3ParserFunction_-32)))) != 0) {
			p.SetState(700)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case css3ParserT__1, css3ParserT__2, css3ParserT__9, css3ParserIncludes, css3ParserDashMatch, css3ParserHash, css3ParserPercentage, css3ParserUri, css3ParserUnicodeRange, css3ParserMediaOnly, css3ParserNot, css3ParserAnd, css3ParserDimension, css3ParserUnknownDimension, css3ParserPlus, css3ParserMinus, css3ParserNumber, css3ParserString_, css3ParserOr, css3ParserFrom, css3ParserTo, css3ParserIdent, css3ParserFunction_:
				{
					p.SetState(698)
					p.Any_()
				}

			case css3ParserT__0, css3ParserT__4, css3ParserT__14, css3ParserCdo, css3ParserCdc:
				{
					p.SetState(699)
					p.Unused()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(704)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(705)
			p.Match(css3ParserT__3)
		}
		{
			p.SetState(706)
			p.Ws()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(708)
			p.Match(css3ParserT__1)
		}
		{
			p.SetState(709)
			p.Ws()
		}
		p.SetState(714)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<css3ParserT__0)|(1<<css3ParserT__1)|(1<<css3ParserT__2)|(1<<css3ParserT__4)|(1<<css3ParserT__9)|(1<<css3ParserT__14)|(1<<css3ParserCdo)|(1<<css3ParserCdc)|(1<<css3ParserIncludes)|(1<<css3ParserDashMatch)|(1<<css3ParserHash)|(1<<css3ParserPercentage)|(1<<css3ParserUri)|(1<<css3ParserUnicodeRange))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(css3ParserMediaOnly-32))|(1<<(css3ParserNot-32))|(1<<(css3ParserAnd-32))|(1<<(css3ParserDimension-32))|(1<<(css3ParserUnknownDimension-32))|(1<<(css3ParserPlus-32))|(1<<(css3ParserMinus-32))|(1<<(css3ParserNumber-32))|(1<<(css3ParserString_-32))|(1<<(css3ParserOr-32))|(1<<(css3ParserFrom-32))|(1<<(css3ParserTo-32))|(1<<(css3ParserIdent-32))|(1<<(css3ParserFunction_-32)))) != 0) {
			p.SetState(712)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case css3ParserT__1, css3ParserT__2, css3ParserT__9, css3ParserIncludes, css3ParserDashMatch, css3ParserHash, css3ParserPercentage, css3ParserUri, css3ParserUnicodeRange, css3ParserMediaOnly, css3ParserNot, css3ParserAnd, css3ParserDimension, css3ParserUnknownDimension, css3ParserPlus, css3ParserMinus, css3ParserNumber, css3ParserString_, css3ParserOr, css3ParserFrom, css3ParserTo, css3ParserIdent, css3ParserFunction_:
				{
					p.SetState(710)
					p.Any_()
				}

			case css3ParserT__0, css3ParserT__4, css3ParserT__14, css3ParserCdo, css3ParserCdc:
				{
					p.SetState(711)
					p.Unused()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(716)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(717)
			p.Match(css3ParserT__3)
		}
		{
			p.SetState(718)
			p.Ws()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(720)
			p.Match(css3ParserT__9)
		}
		{
			p.SetState(721)
			p.Ws()
		}
		p.SetState(726)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<css3ParserT__0)|(1<<css3ParserT__1)|(1<<css3ParserT__2)|(1<<css3ParserT__4)|(1<<css3ParserT__9)|(1<<css3ParserT__14)|(1<<css3ParserCdo)|(1<<css3ParserCdc)|(1<<css3ParserIncludes)|(1<<css3ParserDashMatch)|(1<<css3ParserHash)|(1<<css3ParserPercentage)|(1<<css3ParserUri)|(1<<css3ParserUnicodeRange))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(css3ParserMediaOnly-32))|(1<<(css3ParserNot-32))|(1<<(css3ParserAnd-32))|(1<<(css3ParserDimension-32))|(1<<(css3ParserUnknownDimension-32))|(1<<(css3ParserPlus-32))|(1<<(css3ParserMinus-32))|(1<<(css3ParserNumber-32))|(1<<(css3ParserString_-32))|(1<<(css3ParserOr-32))|(1<<(css3ParserFrom-32))|(1<<(css3ParserTo-32))|(1<<(css3ParserIdent-32))|(1<<(css3ParserFunction_-32)))) != 0) {
			p.SetState(724)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case css3ParserT__1, css3ParserT__2, css3ParserT__9, css3ParserIncludes, css3ParserDashMatch, css3ParserHash, css3ParserPercentage, css3ParserUri, css3ParserUnicodeRange, css3ParserMediaOnly, css3ParserNot, css3ParserAnd, css3ParserDimension, css3ParserUnknownDimension, css3ParserPlus, css3ParserMinus, css3ParserNumber, css3ParserString_, css3ParserOr, css3ParserFrom, css3ParserTo, css3ParserIdent, css3ParserFunction_:
				{
					p.SetState(722)
					p.Any_()
				}

			case css3ParserT__0, css3ParserT__4, css3ParserT__14, css3ParserCdo, css3ParserCdc:
				{
					p.SetState(723)
					p.Unused()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(728)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(729)
			p.Match(css3ParserT__11)
		}
		{
			p.SetState(730)
			p.Ws()
		}

	}

	return localctx
}

// IAtRuleContext is an interface to support dynamic dispatch.
type IAtRuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtRuleContext differentiates from other interfaces.
	IsAtRuleContext()
}

type AtRuleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtRuleContext() *AtRuleContext {
	var p = new(AtRuleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_atRule
	return p
}

func (*AtRuleContext) IsAtRuleContext() {}

func NewAtRuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtRuleContext {
	var p = new(AtRuleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_atRule

	return p
}

func (s *AtRuleContext) GetParser() antlr.Parser { return s.parser }

func (s *AtRuleContext) CopyFrom(ctx *AtRuleContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *AtRuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtRuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type UnknownAtRuleContext struct {
	*AtRuleContext
}

func NewUnknownAtRuleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnknownAtRuleContext {
	var p = new(UnknownAtRuleContext)

	p.AtRuleContext = NewEmptyAtRuleContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AtRuleContext))

	return p
}

func (s *UnknownAtRuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnknownAtRuleContext) AtKeyword() IAtKeywordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtKeywordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtKeywordContext)
}

func (s *UnknownAtRuleContext) AllWs() []IWsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWsContext)(nil)).Elem())
	var tst = make([]IWsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWsContext)
		}
	}

	return tst
}

func (s *UnknownAtRuleContext) Ws(i int) IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *UnknownAtRuleContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *UnknownAtRuleContext) AllAny_() []IAny_Context {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAny_Context)(nil)).Elem())
	var tst = make([]IAny_Context, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAny_Context)
		}
	}

	return tst
}

func (s *UnknownAtRuleContext) Any_(i int) IAny_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAny_Context)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAny_Context)
}

func (s *UnknownAtRuleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterUnknownAtRule(s)
	}
}

func (s *UnknownAtRuleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitUnknownAtRule(s)
	}
}

func (p *css3Parser) AtRule() (localctx IAtRuleContext) {
	this := p
	_ = this

	localctx = NewAtRuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, css3ParserRULE_atRule)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	localctx = NewUnknownAtRuleContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(734)
		p.AtKeyword()
	}
	{
		p.SetState(735)
		p.Ws()
	}
	p.SetState(739)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<css3ParserT__1)|(1<<css3ParserT__2)|(1<<css3ParserT__9)|(1<<css3ParserIncludes)|(1<<css3ParserDashMatch)|(1<<css3ParserHash)|(1<<css3ParserPercentage)|(1<<css3ParserUri)|(1<<css3ParserUnicodeRange))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(css3ParserMediaOnly-32))|(1<<(css3ParserNot-32))|(1<<(css3ParserAnd-32))|(1<<(css3ParserDimension-32))|(1<<(css3ParserUnknownDimension-32))|(1<<(css3ParserPlus-32))|(1<<(css3ParserMinus-32))|(1<<(css3ParserNumber-32))|(1<<(css3ParserString_-32))|(1<<(css3ParserOr-32))|(1<<(css3ParserFrom-32))|(1<<(css3ParserTo-32))|(1<<(css3ParserIdent-32))|(1<<(css3ParserFunction_-32)))) != 0) {
		{
			p.SetState(736)
			p.Any_()
		}

		p.SetState(741)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(745)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case css3ParserT__4:
		{
			p.SetState(742)
			p.Block()
		}

	case css3ParserT__0:
		{
			p.SetState(743)
			p.Match(css3ParserT__0)
		}
		{
			p.SetState(744)
			p.Ws()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAtKeywordContext is an interface to support dynamic dispatch.
type IAtKeywordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtKeywordContext differentiates from other interfaces.
	IsAtKeywordContext()
}

type AtKeywordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtKeywordContext() *AtKeywordContext {
	var p = new(AtKeywordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_atKeyword
	return p
}

func (*AtKeywordContext) IsAtKeywordContext() {}

func NewAtKeywordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtKeywordContext {
	var p = new(AtKeywordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_atKeyword

	return p
}

func (s *AtKeywordContext) GetParser() antlr.Parser { return s.parser }

func (s *AtKeywordContext) Ident() IIdentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *AtKeywordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtKeywordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AtKeywordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterAtKeyword(s)
	}
}

func (s *AtKeywordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitAtKeyword(s)
	}
}

func (p *css3Parser) AtKeyword() (localctx IAtKeywordContext) {
	this := p
	_ = this

	localctx = NewAtKeywordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, css3ParserRULE_atKeyword)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(747)
		p.Match(css3ParserT__14)
	}
	{
		p.SetState(748)
		p.Ident()
	}

	return localctx
}

// IUnusedContext is an interface to support dynamic dispatch.
type IUnusedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnusedContext differentiates from other interfaces.
	IsUnusedContext()
}

type UnusedContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnusedContext() *UnusedContext {
	var p = new(UnusedContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_unused
	return p
}

func (*UnusedContext) IsUnusedContext() {}

func NewUnusedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnusedContext {
	var p = new(UnusedContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_unused

	return p
}

func (s *UnusedContext) GetParser() antlr.Parser { return s.parser }

func (s *UnusedContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *UnusedContext) AtKeyword() IAtKeywordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtKeywordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtKeywordContext)
}

func (s *UnusedContext) Ws() IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *UnusedContext) Cdo() antlr.TerminalNode {
	return s.GetToken(css3ParserCdo, 0)
}

func (s *UnusedContext) Cdc() antlr.TerminalNode {
	return s.GetToken(css3ParserCdc, 0)
}

func (s *UnusedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnusedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnusedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterUnused(s)
	}
}

func (s *UnusedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitUnused(s)
	}
}

func (p *css3Parser) Unused() (localctx IUnusedContext) {
	this := p
	_ = this

	localctx = NewUnusedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, css3ParserRULE_unused)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(760)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case css3ParserT__4:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(750)
			p.Block()
		}

	case css3ParserT__14:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(751)
			p.AtKeyword()
		}
		{
			p.SetState(752)
			p.Ws()
		}

	case css3ParserT__0:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(754)
			p.Match(css3ParserT__0)
		}
		{
			p.SetState(755)
			p.Ws()
		}

	case css3ParserCdo:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(756)
			p.Match(css3ParserCdo)
		}
		{
			p.SetState(757)
			p.Ws()
		}

	case css3ParserCdc:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(758)
			p.Match(css3ParserCdc)
		}
		{
			p.SetState(759)
			p.Ws()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IBlockContext is an interface to support dynamic dispatch.
type IBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlockContext differentiates from other interfaces.
	IsBlockContext()
}

type BlockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockContext() *BlockContext {
	var p = new(BlockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_block
	return p
}

func (*BlockContext) IsBlockContext() {}

func NewBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockContext {
	var p = new(BlockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_block

	return p
}

func (s *BlockContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockContext) AllWs() []IWsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWsContext)(nil)).Elem())
	var tst = make([]IWsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWsContext)
		}
	}

	return tst
}

func (s *BlockContext) Ws(i int) IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *BlockContext) AllDeclarationList() []IDeclarationListContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDeclarationListContext)(nil)).Elem())
	var tst = make([]IDeclarationListContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDeclarationListContext)
		}
	}

	return tst
}

func (s *BlockContext) DeclarationList(i int) IDeclarationListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclarationListContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDeclarationListContext)
}

func (s *BlockContext) AllNestedStatement() []INestedStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INestedStatementContext)(nil)).Elem())
	var tst = make([]INestedStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INestedStatementContext)
		}
	}

	return tst
}

func (s *BlockContext) NestedStatement(i int) INestedStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INestedStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INestedStatementContext)
}

func (s *BlockContext) AllAny_() []IAny_Context {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAny_Context)(nil)).Elem())
	var tst = make([]IAny_Context, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAny_Context)
		}
	}

	return tst
}

func (s *BlockContext) Any_(i int) IAny_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAny_Context)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAny_Context)
}

func (s *BlockContext) AllBlock() []IBlockContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBlockContext)(nil)).Elem())
	var tst = make([]IBlockContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBlockContext)
		}
	}

	return tst
}

func (s *BlockContext) Block(i int) IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *BlockContext) AllAtKeyword() []IAtKeywordContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAtKeywordContext)(nil)).Elem())
	var tst = make([]IAtKeywordContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAtKeywordContext)
		}
	}

	return tst
}

func (s *BlockContext) AtKeyword(i int) IAtKeywordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtKeywordContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAtKeywordContext)
}

func (s *BlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterBlock(s)
	}
}

func (s *BlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitBlock(s)
	}
}

func (p *css3Parser) Block() (localctx IBlockContext) {
	this := p
	_ = this

	localctx = NewBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, css3ParserRULE_block)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(762)
		p.Match(css3ParserT__4)
	}
	{
		p.SetState(763)
		p.Ws()
	}
	p.SetState(775)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<css3ParserT__0)|(1<<css3ParserT__1)|(1<<css3ParserT__2)|(1<<css3ParserT__4)|(1<<css3ParserT__6)|(1<<css3ParserT__7)|(1<<css3ParserT__8)|(1<<css3ParserT__9)|(1<<css3ParserT__13)|(1<<css3ParserT__14)|(1<<css3ParserIncludes)|(1<<css3ParserDashMatch)|(1<<css3ParserHash)|(1<<css3ParserPage)|(1<<css3ParserMedia)|(1<<css3ParserPercentage)|(1<<css3ParserUri)|(1<<css3ParserUnicodeRange))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(css3ParserMediaOnly-32))|(1<<(css3ParserNot-32))|(1<<(css3ParserAnd-32))|(1<<(css3ParserDimension-32))|(1<<(css3ParserUnknownDimension-32))|(1<<(css3ParserPlus-32))|(1<<(css3ParserMinus-32))|(1<<(css3ParserPseudoNot-32))|(1<<(css3ParserNumber-32))|(1<<(css3ParserString_-32))|(1<<(css3ParserFontFace-32))|(1<<(css3ParserSupports-32))|(1<<(css3ParserOr-32))|(1<<(css3ParserKeyframes-32))|(1<<(css3ParserFrom-32))|(1<<(css3ParserTo-32))|(1<<(css3ParserViewport-32))|(1<<(css3ParserCounterStyle-32))|(1<<(css3ParserFontFeatureValues-32))|(1<<(css3ParserVariable-32))|(1<<(css3ParserIdent-32))|(1<<(css3ParserFunction_-32)))) != 0) {
		p.SetState(773)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 74, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(764)
				p.DeclarationList()
			}

		case 2:
			{
				p.SetState(765)
				p.NestedStatement()
			}

		case 3:
			{
				p.SetState(766)
				p.Any_()
			}

		case 4:
			{
				p.SetState(767)
				p.Block()
			}

		case 5:
			{
				p.SetState(768)
				p.AtKeyword()
			}
			{
				p.SetState(769)
				p.Ws()
			}

		case 6:
			{
				p.SetState(771)
				p.Match(css3ParserT__0)
			}
			{
				p.SetState(772)
				p.Ws()
			}

		}

		p.SetState(777)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(778)
		p.Match(css3ParserT__5)
	}
	{
		p.SetState(779)
		p.Ws()
	}

	return localctx
}

// INestedStatementContext is an interface to support dynamic dispatch.
type INestedStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNestedStatementContext differentiates from other interfaces.
	IsNestedStatementContext()
}

type NestedStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNestedStatementContext() *NestedStatementContext {
	var p = new(NestedStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_nestedStatement
	return p
}

func (*NestedStatementContext) IsNestedStatementContext() {}

func NewNestedStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NestedStatementContext {
	var p = new(NestedStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_nestedStatement

	return p
}

func (s *NestedStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *NestedStatementContext) Ruleset() IRulesetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRulesetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRulesetContext)
}

func (s *NestedStatementContext) Media() IMediaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMediaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMediaContext)
}

func (s *NestedStatementContext) Page() IPageContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPageContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPageContext)
}

func (s *NestedStatementContext) FontFaceRule() IFontFaceRuleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFontFaceRuleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFontFaceRuleContext)
}

func (s *NestedStatementContext) KeyframesRule() IKeyframesRuleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IKeyframesRuleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IKeyframesRuleContext)
}

func (s *NestedStatementContext) SupportsRule() ISupportsRuleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISupportsRuleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISupportsRuleContext)
}

func (s *NestedStatementContext) Viewport() IViewportContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IViewportContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IViewportContext)
}

func (s *NestedStatementContext) CounterStyle() ICounterStyleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICounterStyleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICounterStyleContext)
}

func (s *NestedStatementContext) FontFeatureValuesRule() IFontFeatureValuesRuleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFontFeatureValuesRuleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFontFeatureValuesRuleContext)
}

func (s *NestedStatementContext) AtRule() IAtRuleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtRuleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtRuleContext)
}

func (s *NestedStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NestedStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NestedStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterNestedStatement(s)
	}
}

func (s *NestedStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitNestedStatement(s)
	}
}

func (p *css3Parser) NestedStatement() (localctx INestedStatementContext) {
	this := p
	_ = this

	localctx = NewNestedStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, css3ParserRULE_nestedStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(791)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case css3ParserT__1, css3ParserT__2, css3ParserT__4, css3ParserT__6, css3ParserT__7, css3ParserT__8, css3ParserT__9, css3ParserIncludes, css3ParserDashMatch, css3ParserHash, css3ParserPercentage, css3ParserUri, css3ParserUnicodeRange, css3ParserMediaOnly, css3ParserNot, css3ParserAnd, css3ParserDimension, css3ParserUnknownDimension, css3ParserPlus, css3ParserMinus, css3ParserPseudoNot, css3ParserNumber, css3ParserString_, css3ParserOr, css3ParserFrom, css3ParserTo, css3ParserIdent, css3ParserFunction_:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(781)
			p.Ruleset()
		}

	case css3ParserMedia:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(782)
			p.Media()
		}

	case css3ParserPage:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(783)
			p.Page()
		}

	case css3ParserFontFace:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(784)
			p.FontFaceRule()
		}

	case css3ParserKeyframes:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(785)
			p.KeyframesRule()
		}

	case css3ParserSupports:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(786)
			p.SupportsRule()
		}

	case css3ParserViewport:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(787)
			p.Viewport()
		}

	case css3ParserCounterStyle:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(788)
			p.CounterStyle()
		}

	case css3ParserFontFeatureValues:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(789)
			p.FontFeatureValuesRule()
		}

	case css3ParserT__14:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(790)
			p.AtRule()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IGroupRuleBodyContext is an interface to support dynamic dispatch.
type IGroupRuleBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGroupRuleBodyContext differentiates from other interfaces.
	IsGroupRuleBodyContext()
}

type GroupRuleBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupRuleBodyContext() *GroupRuleBodyContext {
	var p = new(GroupRuleBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_groupRuleBody
	return p
}

func (*GroupRuleBodyContext) IsGroupRuleBodyContext() {}

func NewGroupRuleBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupRuleBodyContext {
	var p = new(GroupRuleBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_groupRuleBody

	return p
}

func (s *GroupRuleBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupRuleBodyContext) AllWs() []IWsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWsContext)(nil)).Elem())
	var tst = make([]IWsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWsContext)
		}
	}

	return tst
}

func (s *GroupRuleBodyContext) Ws(i int) IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *GroupRuleBodyContext) AllNestedStatement() []INestedStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INestedStatementContext)(nil)).Elem())
	var tst = make([]INestedStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INestedStatementContext)
		}
	}

	return tst
}

func (s *GroupRuleBodyContext) NestedStatement(i int) INestedStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INestedStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INestedStatementContext)
}

func (s *GroupRuleBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupRuleBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupRuleBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterGroupRuleBody(s)
	}
}

func (s *GroupRuleBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitGroupRuleBody(s)
	}
}

func (p *css3Parser) GroupRuleBody() (localctx IGroupRuleBodyContext) {
	this := p
	_ = this

	localctx = NewGroupRuleBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, css3ParserRULE_groupRuleBody)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(793)
		p.Match(css3ParserT__4)
	}
	{
		p.SetState(794)
		p.Ws()
	}
	p.SetState(798)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<css3ParserT__1)|(1<<css3ParserT__2)|(1<<css3ParserT__4)|(1<<css3ParserT__6)|(1<<css3ParserT__7)|(1<<css3ParserT__8)|(1<<css3ParserT__9)|(1<<css3ParserT__14)|(1<<css3ParserIncludes)|(1<<css3ParserDashMatch)|(1<<css3ParserHash)|(1<<css3ParserPage)|(1<<css3ParserMedia)|(1<<css3ParserPercentage)|(1<<css3ParserUri)|(1<<css3ParserUnicodeRange))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(css3ParserMediaOnly-32))|(1<<(css3ParserNot-32))|(1<<(css3ParserAnd-32))|(1<<(css3ParserDimension-32))|(1<<(css3ParserUnknownDimension-32))|(1<<(css3ParserPlus-32))|(1<<(css3ParserMinus-32))|(1<<(css3ParserPseudoNot-32))|(1<<(css3ParserNumber-32))|(1<<(css3ParserString_-32))|(1<<(css3ParserFontFace-32))|(1<<(css3ParserSupports-32))|(1<<(css3ParserOr-32))|(1<<(css3ParserKeyframes-32))|(1<<(css3ParserFrom-32))|(1<<(css3ParserTo-32))|(1<<(css3ParserViewport-32))|(1<<(css3ParserCounterStyle-32))|(1<<(css3ParserFontFeatureValues-32))|(1<<(css3ParserIdent-32))|(1<<(css3ParserFunction_-32)))) != 0) {
		{
			p.SetState(795)
			p.NestedStatement()
		}

		p.SetState(800)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(801)
		p.Match(css3ParserT__5)
	}
	{
		p.SetState(802)
		p.Ws()
	}

	return localctx
}

// ISupportsRuleContext is an interface to support dynamic dispatch.
type ISupportsRuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSupportsRuleContext differentiates from other interfaces.
	IsSupportsRuleContext()
}

type SupportsRuleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySupportsRuleContext() *SupportsRuleContext {
	var p = new(SupportsRuleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_supportsRule
	return p
}

func (*SupportsRuleContext) IsSupportsRuleContext() {}

func NewSupportsRuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SupportsRuleContext {
	var p = new(SupportsRuleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_supportsRule

	return p
}

func (s *SupportsRuleContext) GetParser() antlr.Parser { return s.parser }

func (s *SupportsRuleContext) Supports() antlr.TerminalNode {
	return s.GetToken(css3ParserSupports, 0)
}

func (s *SupportsRuleContext) AllWs() []IWsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWsContext)(nil)).Elem())
	var tst = make([]IWsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWsContext)
		}
	}

	return tst
}

func (s *SupportsRuleContext) Ws(i int) IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *SupportsRuleContext) SupportsCondition() ISupportsConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISupportsConditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISupportsConditionContext)
}

func (s *SupportsRuleContext) GroupRuleBody() IGroupRuleBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroupRuleBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGroupRuleBodyContext)
}

func (s *SupportsRuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportsRuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SupportsRuleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterSupportsRule(s)
	}
}

func (s *SupportsRuleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitSupportsRule(s)
	}
}

func (p *css3Parser) SupportsRule() (localctx ISupportsRuleContext) {
	this := p
	_ = this

	localctx = NewSupportsRuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, css3ParserRULE_supportsRule)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(804)
		p.Match(css3ParserSupports)
	}
	{
		p.SetState(805)
		p.Ws()
	}
	{
		p.SetState(806)
		p.SupportsCondition()
	}
	{
		p.SetState(807)
		p.Ws()
	}
	{
		p.SetState(808)
		p.GroupRuleBody()
	}

	return localctx
}

// ISupportsConditionContext is an interface to support dynamic dispatch.
type ISupportsConditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSupportsConditionContext differentiates from other interfaces.
	IsSupportsConditionContext()
}

type SupportsConditionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySupportsConditionContext() *SupportsConditionContext {
	var p = new(SupportsConditionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_supportsCondition
	return p
}

func (*SupportsConditionContext) IsSupportsConditionContext() {}

func NewSupportsConditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SupportsConditionContext {
	var p = new(SupportsConditionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_supportsCondition

	return p
}

func (s *SupportsConditionContext) GetParser() antlr.Parser { return s.parser }

func (s *SupportsConditionContext) SupportsNegation() ISupportsNegationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISupportsNegationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISupportsNegationContext)
}

func (s *SupportsConditionContext) SupportsConjunction() ISupportsConjunctionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISupportsConjunctionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISupportsConjunctionContext)
}

func (s *SupportsConditionContext) SupportsDisjunction() ISupportsDisjunctionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISupportsDisjunctionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISupportsDisjunctionContext)
}

func (s *SupportsConditionContext) SupportsConditionInParens() ISupportsConditionInParensContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISupportsConditionInParensContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISupportsConditionInParensContext)
}

func (s *SupportsConditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportsConditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SupportsConditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterSupportsCondition(s)
	}
}

func (s *SupportsConditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitSupportsCondition(s)
	}
}

func (p *css3Parser) SupportsCondition() (localctx ISupportsConditionContext) {
	this := p
	_ = this

	localctx = NewSupportsConditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, css3ParserRULE_supportsCondition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(814)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 78, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(810)
			p.SupportsNegation()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(811)
			p.SupportsConjunction()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(812)
			p.SupportsDisjunction()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(813)
			p.SupportsConditionInParens()
		}

	}

	return localctx
}

// ISupportsConditionInParensContext is an interface to support dynamic dispatch.
type ISupportsConditionInParensContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSupportsConditionInParensContext differentiates from other interfaces.
	IsSupportsConditionInParensContext()
}

type SupportsConditionInParensContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySupportsConditionInParensContext() *SupportsConditionInParensContext {
	var p = new(SupportsConditionInParensContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_supportsConditionInParens
	return p
}

func (*SupportsConditionInParensContext) IsSupportsConditionInParensContext() {}

func NewSupportsConditionInParensContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SupportsConditionInParensContext {
	var p = new(SupportsConditionInParensContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_supportsConditionInParens

	return p
}

func (s *SupportsConditionInParensContext) GetParser() antlr.Parser { return s.parser }

func (s *SupportsConditionInParensContext) AllWs() []IWsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWsContext)(nil)).Elem())
	var tst = make([]IWsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWsContext)
		}
	}

	return tst
}

func (s *SupportsConditionInParensContext) Ws(i int) IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *SupportsConditionInParensContext) SupportsCondition() ISupportsConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISupportsConditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISupportsConditionContext)
}

func (s *SupportsConditionInParensContext) SupportsDeclarationCondition() ISupportsDeclarationConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISupportsDeclarationConditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISupportsDeclarationConditionContext)
}

func (s *SupportsConditionInParensContext) GeneralEnclosed() IGeneralEnclosedContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGeneralEnclosedContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGeneralEnclosedContext)
}

func (s *SupportsConditionInParensContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportsConditionInParensContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SupportsConditionInParensContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterSupportsConditionInParens(s)
	}
}

func (s *SupportsConditionInParensContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitSupportsConditionInParens(s)
	}
}

func (p *css3Parser) SupportsConditionInParens() (localctx ISupportsConditionInParensContext) {
	this := p
	_ = this

	localctx = NewSupportsConditionInParensContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, css3ParserRULE_supportsConditionInParens)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(824)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 79, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(816)
			p.Match(css3ParserT__1)
		}
		{
			p.SetState(817)
			p.Ws()
		}
		{
			p.SetState(818)
			p.SupportsCondition()
		}
		{
			p.SetState(819)
			p.Ws()
		}
		{
			p.SetState(820)
			p.Match(css3ParserT__3)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(822)
			p.SupportsDeclarationCondition()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(823)
			p.GeneralEnclosed()
		}

	}

	return localctx
}

// ISupportsNegationContext is an interface to support dynamic dispatch.
type ISupportsNegationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSupportsNegationContext differentiates from other interfaces.
	IsSupportsNegationContext()
}

type SupportsNegationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySupportsNegationContext() *SupportsNegationContext {
	var p = new(SupportsNegationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_supportsNegation
	return p
}

func (*SupportsNegationContext) IsSupportsNegationContext() {}

func NewSupportsNegationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SupportsNegationContext {
	var p = new(SupportsNegationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_supportsNegation

	return p
}

func (s *SupportsNegationContext) GetParser() antlr.Parser { return s.parser }

func (s *SupportsNegationContext) Not() antlr.TerminalNode {
	return s.GetToken(css3ParserNot, 0)
}

func (s *SupportsNegationContext) AllWs() []IWsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWsContext)(nil)).Elem())
	var tst = make([]IWsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWsContext)
		}
	}

	return tst
}

func (s *SupportsNegationContext) Ws(i int) IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *SupportsNegationContext) Space() antlr.TerminalNode {
	return s.GetToken(css3ParserSpace, 0)
}

func (s *SupportsNegationContext) SupportsConditionInParens() ISupportsConditionInParensContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISupportsConditionInParensContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISupportsConditionInParensContext)
}

func (s *SupportsNegationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportsNegationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SupportsNegationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterSupportsNegation(s)
	}
}

func (s *SupportsNegationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitSupportsNegation(s)
	}
}

func (p *css3Parser) SupportsNegation() (localctx ISupportsNegationContext) {
	this := p
	_ = this

	localctx = NewSupportsNegationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, css3ParserRULE_supportsNegation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(826)
		p.Match(css3ParserNot)
	}
	{
		p.SetState(827)
		p.Ws()
	}
	{
		p.SetState(828)
		p.Match(css3ParserSpace)
	}
	{
		p.SetState(829)
		p.Ws()
	}
	{
		p.SetState(830)
		p.SupportsConditionInParens()
	}

	return localctx
}

// ISupportsConjunctionContext is an interface to support dynamic dispatch.
type ISupportsConjunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSupportsConjunctionContext differentiates from other interfaces.
	IsSupportsConjunctionContext()
}

type SupportsConjunctionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySupportsConjunctionContext() *SupportsConjunctionContext {
	var p = new(SupportsConjunctionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_supportsConjunction
	return p
}

func (*SupportsConjunctionContext) IsSupportsConjunctionContext() {}

func NewSupportsConjunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SupportsConjunctionContext {
	var p = new(SupportsConjunctionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_supportsConjunction

	return p
}

func (s *SupportsConjunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *SupportsConjunctionContext) AllSupportsConditionInParens() []ISupportsConditionInParensContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISupportsConditionInParensContext)(nil)).Elem())
	var tst = make([]ISupportsConditionInParensContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISupportsConditionInParensContext)
		}
	}

	return tst
}

func (s *SupportsConjunctionContext) SupportsConditionInParens(i int) ISupportsConditionInParensContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISupportsConditionInParensContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISupportsConditionInParensContext)
}

func (s *SupportsConjunctionContext) AllWs() []IWsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWsContext)(nil)).Elem())
	var tst = make([]IWsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWsContext)
		}
	}

	return tst
}

func (s *SupportsConjunctionContext) Ws(i int) IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *SupportsConjunctionContext) AllSpace() []antlr.TerminalNode {
	return s.GetTokens(css3ParserSpace)
}

func (s *SupportsConjunctionContext) Space(i int) antlr.TerminalNode {
	return s.GetToken(css3ParserSpace, i)
}

func (s *SupportsConjunctionContext) AllAnd() []antlr.TerminalNode {
	return s.GetTokens(css3ParserAnd)
}

func (s *SupportsConjunctionContext) And(i int) antlr.TerminalNode {
	return s.GetToken(css3ParserAnd, i)
}

func (s *SupportsConjunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportsConjunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SupportsConjunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterSupportsConjunction(s)
	}
}

func (s *SupportsConjunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitSupportsConjunction(s)
	}
}

func (p *css3Parser) SupportsConjunction() (localctx ISupportsConjunctionContext) {
	this := p
	_ = this

	localctx = NewSupportsConjunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, css3ParserRULE_supportsConjunction)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(832)
		p.SupportsConditionInParens()
	}
	p.SetState(842)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(833)
				p.Ws()
			}
			{
				p.SetState(834)
				p.Match(css3ParserSpace)
			}
			{
				p.SetState(835)
				p.Ws()
			}
			{
				p.SetState(836)
				p.Match(css3ParserAnd)
			}
			{
				p.SetState(837)
				p.Ws()
			}
			{
				p.SetState(838)
				p.Match(css3ParserSpace)
			}
			{
				p.SetState(839)
				p.Ws()
			}
			{
				p.SetState(840)
				p.SupportsConditionInParens()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(844)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 80, p.GetParserRuleContext())
	}

	return localctx
}

// ISupportsDisjunctionContext is an interface to support dynamic dispatch.
type ISupportsDisjunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSupportsDisjunctionContext differentiates from other interfaces.
	IsSupportsDisjunctionContext()
}

type SupportsDisjunctionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySupportsDisjunctionContext() *SupportsDisjunctionContext {
	var p = new(SupportsDisjunctionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_supportsDisjunction
	return p
}

func (*SupportsDisjunctionContext) IsSupportsDisjunctionContext() {}

func NewSupportsDisjunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SupportsDisjunctionContext {
	var p = new(SupportsDisjunctionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_supportsDisjunction

	return p
}

func (s *SupportsDisjunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *SupportsDisjunctionContext) AllSupportsConditionInParens() []ISupportsConditionInParensContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISupportsConditionInParensContext)(nil)).Elem())
	var tst = make([]ISupportsConditionInParensContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISupportsConditionInParensContext)
		}
	}

	return tst
}

func (s *SupportsDisjunctionContext) SupportsConditionInParens(i int) ISupportsConditionInParensContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISupportsConditionInParensContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISupportsConditionInParensContext)
}

func (s *SupportsDisjunctionContext) AllWs() []IWsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWsContext)(nil)).Elem())
	var tst = make([]IWsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWsContext)
		}
	}

	return tst
}

func (s *SupportsDisjunctionContext) Ws(i int) IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *SupportsDisjunctionContext) AllSpace() []antlr.TerminalNode {
	return s.GetTokens(css3ParserSpace)
}

func (s *SupportsDisjunctionContext) Space(i int) antlr.TerminalNode {
	return s.GetToken(css3ParserSpace, i)
}

func (s *SupportsDisjunctionContext) AllOr() []antlr.TerminalNode {
	return s.GetTokens(css3ParserOr)
}

func (s *SupportsDisjunctionContext) Or(i int) antlr.TerminalNode {
	return s.GetToken(css3ParserOr, i)
}

func (s *SupportsDisjunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportsDisjunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SupportsDisjunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterSupportsDisjunction(s)
	}
}

func (s *SupportsDisjunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitSupportsDisjunction(s)
	}
}

func (p *css3Parser) SupportsDisjunction() (localctx ISupportsDisjunctionContext) {
	this := p
	_ = this

	localctx = NewSupportsDisjunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, css3ParserRULE_supportsDisjunction)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(846)
		p.SupportsConditionInParens()
	}
	p.SetState(856)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(847)
				p.Ws()
			}
			{
				p.SetState(848)
				p.Match(css3ParserSpace)
			}
			{
				p.SetState(849)
				p.Ws()
			}
			{
				p.SetState(850)
				p.Match(css3ParserOr)
			}
			{
				p.SetState(851)
				p.Ws()
			}
			{
				p.SetState(852)
				p.Match(css3ParserSpace)
			}
			{
				p.SetState(853)
				p.Ws()
			}
			{
				p.SetState(854)
				p.SupportsConditionInParens()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(858)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 81, p.GetParserRuleContext())
	}

	return localctx
}

// ISupportsDeclarationConditionContext is an interface to support dynamic dispatch.
type ISupportsDeclarationConditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSupportsDeclarationConditionContext differentiates from other interfaces.
	IsSupportsDeclarationConditionContext()
}

type SupportsDeclarationConditionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySupportsDeclarationConditionContext() *SupportsDeclarationConditionContext {
	var p = new(SupportsDeclarationConditionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_supportsDeclarationCondition
	return p
}

func (*SupportsDeclarationConditionContext) IsSupportsDeclarationConditionContext() {}

func NewSupportsDeclarationConditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SupportsDeclarationConditionContext {
	var p = new(SupportsDeclarationConditionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_supportsDeclarationCondition

	return p
}

func (s *SupportsDeclarationConditionContext) GetParser() antlr.Parser { return s.parser }

func (s *SupportsDeclarationConditionContext) Ws() IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *SupportsDeclarationConditionContext) Declaration() IDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclarationContext)
}

func (s *SupportsDeclarationConditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportsDeclarationConditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SupportsDeclarationConditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterSupportsDeclarationCondition(s)
	}
}

func (s *SupportsDeclarationConditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitSupportsDeclarationCondition(s)
	}
}

func (p *css3Parser) SupportsDeclarationCondition() (localctx ISupportsDeclarationConditionContext) {
	this := p
	_ = this

	localctx = NewSupportsDeclarationConditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, css3ParserRULE_supportsDeclarationCondition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(860)
		p.Match(css3ParserT__1)
	}
	{
		p.SetState(861)
		p.Ws()
	}
	{
		p.SetState(862)
		p.Declaration()
	}
	{
		p.SetState(863)
		p.Match(css3ParserT__3)
	}

	return localctx
}

// IGeneralEnclosedContext is an interface to support dynamic dispatch.
type IGeneralEnclosedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGeneralEnclosedContext differentiates from other interfaces.
	IsGeneralEnclosedContext()
}

type GeneralEnclosedContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGeneralEnclosedContext() *GeneralEnclosedContext {
	var p = new(GeneralEnclosedContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_generalEnclosed
	return p
}

func (*GeneralEnclosedContext) IsGeneralEnclosedContext() {}

func NewGeneralEnclosedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GeneralEnclosedContext {
	var p = new(GeneralEnclosedContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_generalEnclosed

	return p
}

func (s *GeneralEnclosedContext) GetParser() antlr.Parser { return s.parser }

func (s *GeneralEnclosedContext) Function_() antlr.TerminalNode {
	return s.GetToken(css3ParserFunction_, 0)
}

func (s *GeneralEnclosedContext) AllAny_() []IAny_Context {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAny_Context)(nil)).Elem())
	var tst = make([]IAny_Context, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAny_Context)
		}
	}

	return tst
}

func (s *GeneralEnclosedContext) Any_(i int) IAny_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAny_Context)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAny_Context)
}

func (s *GeneralEnclosedContext) AllUnused() []IUnusedContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IUnusedContext)(nil)).Elem())
	var tst = make([]IUnusedContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IUnusedContext)
		}
	}

	return tst
}

func (s *GeneralEnclosedContext) Unused(i int) IUnusedContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnusedContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IUnusedContext)
}

func (s *GeneralEnclosedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GeneralEnclosedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GeneralEnclosedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterGeneralEnclosed(s)
	}
}

func (s *GeneralEnclosedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitGeneralEnclosed(s)
	}
}

func (p *css3Parser) GeneralEnclosed() (localctx IGeneralEnclosedContext) {
	this := p
	_ = this

	localctx = NewGeneralEnclosedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, css3ParserRULE_generalEnclosed)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(865)
		_la = p.GetTokenStream().LA(1)

		if !(_la == css3ParserT__1 || _la == css3ParserFunction_) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(870)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<css3ParserT__0)|(1<<css3ParserT__1)|(1<<css3ParserT__2)|(1<<css3ParserT__4)|(1<<css3ParserT__9)|(1<<css3ParserT__14)|(1<<css3ParserCdo)|(1<<css3ParserCdc)|(1<<css3ParserIncludes)|(1<<css3ParserDashMatch)|(1<<css3ParserHash)|(1<<css3ParserPercentage)|(1<<css3ParserUri)|(1<<css3ParserUnicodeRange))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(css3ParserMediaOnly-32))|(1<<(css3ParserNot-32))|(1<<(css3ParserAnd-32))|(1<<(css3ParserDimension-32))|(1<<(css3ParserUnknownDimension-32))|(1<<(css3ParserPlus-32))|(1<<(css3ParserMinus-32))|(1<<(css3ParserNumber-32))|(1<<(css3ParserString_-32))|(1<<(css3ParserOr-32))|(1<<(css3ParserFrom-32))|(1<<(css3ParserTo-32))|(1<<(css3ParserIdent-32))|(1<<(css3ParserFunction_-32)))) != 0) {
		p.SetState(868)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case css3ParserT__1, css3ParserT__2, css3ParserT__9, css3ParserIncludes, css3ParserDashMatch, css3ParserHash, css3ParserPercentage, css3ParserUri, css3ParserUnicodeRange, css3ParserMediaOnly, css3ParserNot, css3ParserAnd, css3ParserDimension, css3ParserUnknownDimension, css3ParserPlus, css3ParserMinus, css3ParserNumber, css3ParserString_, css3ParserOr, css3ParserFrom, css3ParserTo, css3ParserIdent, css3ParserFunction_:
			{
				p.SetState(866)
				p.Any_()
			}

		case css3ParserT__0, css3ParserT__4, css3ParserT__14, css3ParserCdo, css3ParserCdc:
			{
				p.SetState(867)
				p.Unused()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(872)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(873)
		p.Match(css3ParserT__3)
	}

	return localctx
}

// IVar_Context is an interface to support dynamic dispatch.
type IVar_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVar_Context differentiates from other interfaces.
	IsVar_Context()
}

type Var_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVar_Context() *Var_Context {
	var p = new(Var_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_var_
	return p
}

func (*Var_Context) IsVar_Context() {}

func NewVar_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Var_Context {
	var p = new(Var_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_var_

	return p
}

func (s *Var_Context) GetParser() antlr.Parser { return s.parser }

func (s *Var_Context) Var() antlr.TerminalNode {
	return s.GetToken(css3ParserVar, 0)
}

func (s *Var_Context) AllWs() []IWsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWsContext)(nil)).Elem())
	var tst = make([]IWsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWsContext)
		}
	}

	return tst
}

func (s *Var_Context) Ws(i int) IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *Var_Context) Variable() antlr.TerminalNode {
	return s.GetToken(css3ParserVariable, 0)
}

func (s *Var_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Var_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Var_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterVar_(s)
	}
}

func (s *Var_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitVar_(s)
	}
}

func (p *css3Parser) Var_() (localctx IVar_Context) {
	this := p
	_ = this

	localctx = NewVar_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, css3ParserRULE_var_)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(875)
		p.Match(css3ParserVar)
	}
	{
		p.SetState(876)
		p.Ws()
	}
	{
		p.SetState(877)
		p.Match(css3ParserVariable)
	}
	{
		p.SetState(878)
		p.Ws()
	}
	{
		p.SetState(879)
		p.Match(css3ParserT__3)
	}
	{
		p.SetState(880)
		p.Ws()
	}

	return localctx
}

// ICalcContext is an interface to support dynamic dispatch.
type ICalcContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCalcContext differentiates from other interfaces.
	IsCalcContext()
}

type CalcContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCalcContext() *CalcContext {
	var p = new(CalcContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_calc
	return p
}

func (*CalcContext) IsCalcContext() {}

func NewCalcContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CalcContext {
	var p = new(CalcContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_calc

	return p
}

func (s *CalcContext) GetParser() antlr.Parser { return s.parser }

func (s *CalcContext) Calc() antlr.TerminalNode {
	return s.GetToken(css3ParserCalc, 0)
}

func (s *CalcContext) AllWs() []IWsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWsContext)(nil)).Elem())
	var tst = make([]IWsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWsContext)
		}
	}

	return tst
}

func (s *CalcContext) Ws(i int) IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *CalcContext) CalcSum() ICalcSumContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICalcSumContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICalcSumContext)
}

func (s *CalcContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CalcContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CalcContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterCalc(s)
	}
}

func (s *CalcContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitCalc(s)
	}
}

func (p *css3Parser) Calc() (localctx ICalcContext) {
	this := p
	_ = this

	localctx = NewCalcContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, css3ParserRULE_calc)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(882)
		p.Match(css3ParserCalc)
	}
	{
		p.SetState(883)
		p.Ws()
	}
	{
		p.SetState(884)
		p.CalcSum()
	}
	{
		p.SetState(885)
		p.Match(css3ParserT__3)
	}
	{
		p.SetState(886)
		p.Ws()
	}

	return localctx
}

// ICalcSumContext is an interface to support dynamic dispatch.
type ICalcSumContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCalcSumContext differentiates from other interfaces.
	IsCalcSumContext()
}

type CalcSumContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCalcSumContext() *CalcSumContext {
	var p = new(CalcSumContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_calcSum
	return p
}

func (*CalcSumContext) IsCalcSumContext() {}

func NewCalcSumContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CalcSumContext {
	var p = new(CalcSumContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_calcSum

	return p
}

func (s *CalcSumContext) GetParser() antlr.Parser { return s.parser }

func (s *CalcSumContext) AllCalcProduct() []ICalcProductContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICalcProductContext)(nil)).Elem())
	var tst = make([]ICalcProductContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICalcProductContext)
		}
	}

	return tst
}

func (s *CalcSumContext) CalcProduct(i int) ICalcProductContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICalcProductContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICalcProductContext)
}

func (s *CalcSumContext) AllSpace() []antlr.TerminalNode {
	return s.GetTokens(css3ParserSpace)
}

func (s *CalcSumContext) Space(i int) antlr.TerminalNode {
	return s.GetToken(css3ParserSpace, i)
}

func (s *CalcSumContext) AllWs() []IWsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWsContext)(nil)).Elem())
	var tst = make([]IWsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWsContext)
		}
	}

	return tst
}

func (s *CalcSumContext) Ws(i int) IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *CalcSumContext) AllPlus() []antlr.TerminalNode {
	return s.GetTokens(css3ParserPlus)
}

func (s *CalcSumContext) Plus(i int) antlr.TerminalNode {
	return s.GetToken(css3ParserPlus, i)
}

func (s *CalcSumContext) AllMinus() []antlr.TerminalNode {
	return s.GetTokens(css3ParserMinus)
}

func (s *CalcSumContext) Minus(i int) antlr.TerminalNode {
	return s.GetToken(css3ParserMinus, i)
}

func (s *CalcSumContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CalcSumContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CalcSumContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterCalcSum(s)
	}
}

func (s *CalcSumContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitCalcSum(s)
	}
}

func (p *css3Parser) CalcSum() (localctx ICalcSumContext) {
	this := p
	_ = this

	localctx = NewCalcSumContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, css3ParserRULE_calcSum)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(888)
		p.CalcProduct()
	}
	p.SetState(899)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == css3ParserSpace {
		{
			p.SetState(889)
			p.Match(css3ParserSpace)
		}
		{
			p.SetState(890)
			p.Ws()
		}
		{
			p.SetState(891)
			_la = p.GetTokenStream().LA(1)

			if !(_la == css3ParserPlus || _la == css3ParserMinus) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(892)
			p.Ws()
		}
		{
			p.SetState(893)
			p.Match(css3ParserSpace)
		}
		{
			p.SetState(894)
			p.Ws()
		}
		{
			p.SetState(895)
			p.CalcProduct()
		}

		p.SetState(901)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ICalcProductContext is an interface to support dynamic dispatch.
type ICalcProductContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCalcProductContext differentiates from other interfaces.
	IsCalcProductContext()
}

type CalcProductContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCalcProductContext() *CalcProductContext {
	var p = new(CalcProductContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_calcProduct
	return p
}

func (*CalcProductContext) IsCalcProductContext() {}

func NewCalcProductContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CalcProductContext {
	var p = new(CalcProductContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_calcProduct

	return p
}

func (s *CalcProductContext) GetParser() antlr.Parser { return s.parser }

func (s *CalcProductContext) AllCalcValue() []ICalcValueContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICalcValueContext)(nil)).Elem())
	var tst = make([]ICalcValueContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICalcValueContext)
		}
	}

	return tst
}

func (s *CalcProductContext) CalcValue(i int) ICalcValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICalcValueContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICalcValueContext)
}

func (s *CalcProductContext) AllWs() []IWsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWsContext)(nil)).Elem())
	var tst = make([]IWsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWsContext)
		}
	}

	return tst
}

func (s *CalcProductContext) Ws(i int) IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *CalcProductContext) AllNumber() []INumberContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INumberContext)(nil)).Elem())
	var tst = make([]INumberContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INumberContext)
		}
	}

	return tst
}

func (s *CalcProductContext) Number(i int) INumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumberContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *CalcProductContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CalcProductContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CalcProductContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterCalcProduct(s)
	}
}

func (s *CalcProductContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitCalcProduct(s)
	}
}

func (p *css3Parser) CalcProduct() (localctx ICalcProductContext) {
	this := p
	_ = this

	localctx = NewCalcProductContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, css3ParserRULE_calcProduct)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(902)
		p.CalcValue()
	}
	p.SetState(914)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == css3ParserT__6 || _la == css3ParserT__12 {
		p.SetState(912)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case css3ParserT__6:
			{
				p.SetState(903)
				p.Match(css3ParserT__6)
			}
			{
				p.SetState(904)
				p.Ws()
			}
			{
				p.SetState(905)
				p.CalcValue()
			}

		case css3ParserT__12:
			{
				p.SetState(907)
				p.Match(css3ParserT__12)
			}
			{
				p.SetState(908)
				p.Ws()
			}
			{
				p.SetState(909)
				p.Number()
			}
			{
				p.SetState(910)
				p.Ws()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(916)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ICalcValueContext is an interface to support dynamic dispatch.
type ICalcValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCalcValueContext differentiates from other interfaces.
	IsCalcValueContext()
}

type CalcValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCalcValueContext() *CalcValueContext {
	var p = new(CalcValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_calcValue
	return p
}

func (*CalcValueContext) IsCalcValueContext() {}

func NewCalcValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CalcValueContext {
	var p = new(CalcValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_calcValue

	return p
}

func (s *CalcValueContext) GetParser() antlr.Parser { return s.parser }

func (s *CalcValueContext) Number() INumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *CalcValueContext) AllWs() []IWsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWsContext)(nil)).Elem())
	var tst = make([]IWsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWsContext)
		}
	}

	return tst
}

func (s *CalcValueContext) Ws(i int) IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *CalcValueContext) Dimension() IDimensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDimensionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDimensionContext)
}

func (s *CalcValueContext) UnknownDimension() IUnknownDimensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnknownDimensionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnknownDimensionContext)
}

func (s *CalcValueContext) Percentage() IPercentageContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPercentageContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPercentageContext)
}

func (s *CalcValueContext) CalcSum() ICalcSumContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICalcSumContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICalcSumContext)
}

func (s *CalcValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CalcValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CalcValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterCalcValue(s)
	}
}

func (s *CalcValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitCalcValue(s)
	}
}

func (p *css3Parser) CalcValue() (localctx ICalcValueContext) {
	this := p
	_ = this

	localctx = NewCalcValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, css3ParserRULE_calcValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(935)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 87, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(917)
			p.Number()
		}
		{
			p.SetState(918)
			p.Ws()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(920)
			p.Dimension()
		}
		{
			p.SetState(921)
			p.Ws()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(923)
			p.UnknownDimension()
		}
		{
			p.SetState(924)
			p.Ws()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(926)
			p.Percentage()
		}
		{
			p.SetState(927)
			p.Ws()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(929)
			p.Match(css3ParserT__1)
		}
		{
			p.SetState(930)
			p.Ws()
		}
		{
			p.SetState(931)
			p.CalcSum()
		}
		{
			p.SetState(932)
			p.Match(css3ParserT__3)
		}
		{
			p.SetState(933)
			p.Ws()
		}

	}

	return localctx
}

// IFontFaceRuleContext is an interface to support dynamic dispatch.
type IFontFaceRuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFontFaceRuleContext differentiates from other interfaces.
	IsFontFaceRuleContext()
}

type FontFaceRuleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFontFaceRuleContext() *FontFaceRuleContext {
	var p = new(FontFaceRuleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_fontFaceRule
	return p
}

func (*FontFaceRuleContext) IsFontFaceRuleContext() {}

func NewFontFaceRuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FontFaceRuleContext {
	var p = new(FontFaceRuleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_fontFaceRule

	return p
}

func (s *FontFaceRuleContext) GetParser() antlr.Parser { return s.parser }

func (s *FontFaceRuleContext) FontFace() antlr.TerminalNode {
	return s.GetToken(css3ParserFontFace, 0)
}

func (s *FontFaceRuleContext) AllWs() []IWsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWsContext)(nil)).Elem())
	var tst = make([]IWsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWsContext)
		}
	}

	return tst
}

func (s *FontFaceRuleContext) Ws(i int) IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *FontFaceRuleContext) AllFontFaceDeclaration() []IFontFaceDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFontFaceDeclarationContext)(nil)).Elem())
	var tst = make([]IFontFaceDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFontFaceDeclarationContext)
		}
	}

	return tst
}

func (s *FontFaceRuleContext) FontFaceDeclaration(i int) IFontFaceDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFontFaceDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFontFaceDeclarationContext)
}

func (s *FontFaceRuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FontFaceRuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FontFaceRuleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterFontFaceRule(s)
	}
}

func (s *FontFaceRuleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitFontFaceRule(s)
	}
}

func (p *css3Parser) FontFaceRule() (localctx IFontFaceRuleContext) {
	this := p
	_ = this

	localctx = NewFontFaceRuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, css3ParserRULE_fontFaceRule)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(937)
		p.Match(css3ParserFontFace)
	}
	{
		p.SetState(938)
		p.Ws()
	}
	{
		p.SetState(939)
		p.Match(css3ParserT__4)
	}
	{
		p.SetState(940)
		p.Ws()
	}
	p.SetState(942)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == css3ParserT__6 || _la == css3ParserT__13 || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(css3ParserMediaOnly-32))|(1<<(css3ParserNot-32))|(1<<(css3ParserAnd-32))|(1<<(css3ParserOr-32))|(1<<(css3ParserFrom-32))|(1<<(css3ParserTo-32))|(1<<(css3ParserVariable-32))|(1<<(css3ParserIdent-32)))) != 0) {
		{
			p.SetState(941)
			p.FontFaceDeclaration()
		}

	}
	p.SetState(951)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == css3ParserT__0 {
		{
			p.SetState(944)
			p.Match(css3ParserT__0)
		}
		{
			p.SetState(945)
			p.Ws()
		}
		p.SetState(947)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == css3ParserT__6 || _la == css3ParserT__13 || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(css3ParserMediaOnly-32))|(1<<(css3ParserNot-32))|(1<<(css3ParserAnd-32))|(1<<(css3ParserOr-32))|(1<<(css3ParserFrom-32))|(1<<(css3ParserTo-32))|(1<<(css3ParserVariable-32))|(1<<(css3ParserIdent-32)))) != 0) {
			{
				p.SetState(946)
				p.FontFaceDeclaration()
			}

		}

		p.SetState(953)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(954)
		p.Match(css3ParserT__5)
	}
	{
		p.SetState(955)
		p.Ws()
	}

	return localctx
}

// IFontFaceDeclarationContext is an interface to support dynamic dispatch.
type IFontFaceDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFontFaceDeclarationContext differentiates from other interfaces.
	IsFontFaceDeclarationContext()
}

type FontFaceDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFontFaceDeclarationContext() *FontFaceDeclarationContext {
	var p = new(FontFaceDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_fontFaceDeclaration
	return p
}

func (*FontFaceDeclarationContext) IsFontFaceDeclarationContext() {}

func NewFontFaceDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FontFaceDeclarationContext {
	var p = new(FontFaceDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_fontFaceDeclaration

	return p
}

func (s *FontFaceDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *FontFaceDeclarationContext) CopyFrom(ctx *FontFaceDeclarationContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *FontFaceDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FontFaceDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type KnownFontFaceDeclarationContext struct {
	*FontFaceDeclarationContext
}

func NewKnownFontFaceDeclarationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *KnownFontFaceDeclarationContext {
	var p = new(KnownFontFaceDeclarationContext)

	p.FontFaceDeclarationContext = NewEmptyFontFaceDeclarationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*FontFaceDeclarationContext))

	return p
}

func (s *KnownFontFaceDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KnownFontFaceDeclarationContext) Property_() IProperty_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProperty_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProperty_Context)
}

func (s *KnownFontFaceDeclarationContext) Ws() IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *KnownFontFaceDeclarationContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *KnownFontFaceDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterKnownFontFaceDeclaration(s)
	}
}

func (s *KnownFontFaceDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitKnownFontFaceDeclaration(s)
	}
}

type UnknownFontFaceDeclarationContext struct {
	*FontFaceDeclarationContext
}

func NewUnknownFontFaceDeclarationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnknownFontFaceDeclarationContext {
	var p = new(UnknownFontFaceDeclarationContext)

	p.FontFaceDeclarationContext = NewEmptyFontFaceDeclarationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*FontFaceDeclarationContext))

	return p
}

func (s *UnknownFontFaceDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnknownFontFaceDeclarationContext) Property_() IProperty_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProperty_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProperty_Context)
}

func (s *UnknownFontFaceDeclarationContext) Ws() IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *UnknownFontFaceDeclarationContext) Value() IValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueContext)
}

func (s *UnknownFontFaceDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterUnknownFontFaceDeclaration(s)
	}
}

func (s *UnknownFontFaceDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitUnknownFontFaceDeclaration(s)
	}
}

func (p *css3Parser) FontFaceDeclaration() (localctx IFontFaceDeclarationContext) {
	this := p
	_ = this

	localctx = NewFontFaceDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, css3ParserRULE_fontFaceDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(967)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 91, p.GetParserRuleContext()) {
	case 1:
		localctx = NewKnownFontFaceDeclarationContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(957)
			p.Property_()
		}
		{
			p.SetState(958)
			p.Match(css3ParserT__2)
		}
		{
			p.SetState(959)
			p.Ws()
		}
		{
			p.SetState(960)
			p.Expr()
		}

	case 2:
		localctx = NewUnknownFontFaceDeclarationContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(962)
			p.Property_()
		}
		{
			p.SetState(963)
			p.Match(css3ParserT__2)
		}
		{
			p.SetState(964)
			p.Ws()
		}
		{
			p.SetState(965)
			p.Value()
		}

	}

	return localctx
}

// IKeyframesRuleContext is an interface to support dynamic dispatch.
type IKeyframesRuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsKeyframesRuleContext differentiates from other interfaces.
	IsKeyframesRuleContext()
}

type KeyframesRuleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyframesRuleContext() *KeyframesRuleContext {
	var p = new(KeyframesRuleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_keyframesRule
	return p
}

func (*KeyframesRuleContext) IsKeyframesRuleContext() {}

func NewKeyframesRuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeyframesRuleContext {
	var p = new(KeyframesRuleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_keyframesRule

	return p
}

func (s *KeyframesRuleContext) GetParser() antlr.Parser { return s.parser }

func (s *KeyframesRuleContext) Keyframes() antlr.TerminalNode {
	return s.GetToken(css3ParserKeyframes, 0)
}

func (s *KeyframesRuleContext) AllWs() []IWsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWsContext)(nil)).Elem())
	var tst = make([]IWsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWsContext)
		}
	}

	return tst
}

func (s *KeyframesRuleContext) Ws(i int) IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *KeyframesRuleContext) Space() antlr.TerminalNode {
	return s.GetToken(css3ParserSpace, 0)
}

func (s *KeyframesRuleContext) Ident() IIdentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *KeyframesRuleContext) KeyframesBlocks() IKeyframesBlocksContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IKeyframesBlocksContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IKeyframesBlocksContext)
}

func (s *KeyframesRuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeyframesRuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeyframesRuleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterKeyframesRule(s)
	}
}

func (s *KeyframesRuleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitKeyframesRule(s)
	}
}

func (p *css3Parser) KeyframesRule() (localctx IKeyframesRuleContext) {
	this := p
	_ = this

	localctx = NewKeyframesRuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, css3ParserRULE_keyframesRule)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(969)
		p.Match(css3ParserKeyframes)
	}
	{
		p.SetState(970)
		p.Ws()
	}
	{
		p.SetState(971)
		p.Match(css3ParserSpace)
	}
	{
		p.SetState(972)
		p.Ws()
	}
	{
		p.SetState(973)
		p.Ident()
	}
	{
		p.SetState(974)
		p.Ws()
	}
	{
		p.SetState(975)
		p.Match(css3ParserT__4)
	}
	{
		p.SetState(976)
		p.Ws()
	}
	{
		p.SetState(977)
		p.KeyframesBlocks()
	}
	{
		p.SetState(978)
		p.Match(css3ParserT__5)
	}
	{
		p.SetState(979)
		p.Ws()
	}

	return localctx
}

// IKeyframesBlocksContext is an interface to support dynamic dispatch.
type IKeyframesBlocksContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsKeyframesBlocksContext differentiates from other interfaces.
	IsKeyframesBlocksContext()
}

type KeyframesBlocksContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyframesBlocksContext() *KeyframesBlocksContext {
	var p = new(KeyframesBlocksContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_keyframesBlocks
	return p
}

func (*KeyframesBlocksContext) IsKeyframesBlocksContext() {}

func NewKeyframesBlocksContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeyframesBlocksContext {
	var p = new(KeyframesBlocksContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_keyframesBlocks

	return p
}

func (s *KeyframesBlocksContext) GetParser() antlr.Parser { return s.parser }

func (s *KeyframesBlocksContext) AllKeyframeSelector() []IKeyframeSelectorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IKeyframeSelectorContext)(nil)).Elem())
	var tst = make([]IKeyframeSelectorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IKeyframeSelectorContext)
		}
	}

	return tst
}

func (s *KeyframesBlocksContext) KeyframeSelector(i int) IKeyframeSelectorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IKeyframeSelectorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IKeyframeSelectorContext)
}

func (s *KeyframesBlocksContext) AllWs() []IWsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWsContext)(nil)).Elem())
	var tst = make([]IWsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWsContext)
		}
	}

	return tst
}

func (s *KeyframesBlocksContext) Ws(i int) IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *KeyframesBlocksContext) AllDeclarationList() []IDeclarationListContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDeclarationListContext)(nil)).Elem())
	var tst = make([]IDeclarationListContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDeclarationListContext)
		}
	}

	return tst
}

func (s *KeyframesBlocksContext) DeclarationList(i int) IDeclarationListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclarationListContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDeclarationListContext)
}

func (s *KeyframesBlocksContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeyframesBlocksContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeyframesBlocksContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterKeyframesBlocks(s)
	}
}

func (s *KeyframesBlocksContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitKeyframesBlocks(s)
	}
}

func (p *css3Parser) KeyframesBlocks() (localctx IKeyframesBlocksContext) {
	this := p
	_ = this

	localctx = NewKeyframesBlocksContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, css3ParserRULE_keyframesBlocks)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(992)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ((_la-29)&-(0x1f+1)) == 0 && ((1<<uint((_la-29)))&((1<<(css3ParserPercentage-29))|(1<<(css3ParserFrom-29))|(1<<(css3ParserTo-29)))) != 0 {
		{
			p.SetState(981)
			p.KeyframeSelector()
		}
		{
			p.SetState(982)
			p.Match(css3ParserT__4)
		}
		{
			p.SetState(983)
			p.Ws()
		}
		p.SetState(985)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<css3ParserT__0)|(1<<css3ParserT__6)|(1<<css3ParserT__13))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(css3ParserMediaOnly-32))|(1<<(css3ParserNot-32))|(1<<(css3ParserAnd-32))|(1<<(css3ParserOr-32))|(1<<(css3ParserFrom-32))|(1<<(css3ParserTo-32))|(1<<(css3ParserVariable-32))|(1<<(css3ParserIdent-32)))) != 0) {
			{
				p.SetState(984)
				p.DeclarationList()
			}

		}
		{
			p.SetState(987)
			p.Match(css3ParserT__5)
		}
		{
			p.SetState(988)
			p.Ws()
		}

		p.SetState(994)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IKeyframeSelectorContext is an interface to support dynamic dispatch.
type IKeyframeSelectorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsKeyframeSelectorContext differentiates from other interfaces.
	IsKeyframeSelectorContext()
}

type KeyframeSelectorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyframeSelectorContext() *KeyframeSelectorContext {
	var p = new(KeyframeSelectorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_keyframeSelector
	return p
}

func (*KeyframeSelectorContext) IsKeyframeSelectorContext() {}

func NewKeyframeSelectorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeyframeSelectorContext {
	var p = new(KeyframeSelectorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_keyframeSelector

	return p
}

func (s *KeyframeSelectorContext) GetParser() antlr.Parser { return s.parser }

func (s *KeyframeSelectorContext) AllWs() []IWsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWsContext)(nil)).Elem())
	var tst = make([]IWsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWsContext)
		}
	}

	return tst
}

func (s *KeyframeSelectorContext) Ws(i int) IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *KeyframeSelectorContext) AllFrom() []antlr.TerminalNode {
	return s.GetTokens(css3ParserFrom)
}

func (s *KeyframeSelectorContext) From(i int) antlr.TerminalNode {
	return s.GetToken(css3ParserFrom, i)
}

func (s *KeyframeSelectorContext) AllTo() []antlr.TerminalNode {
	return s.GetTokens(css3ParserTo)
}

func (s *KeyframeSelectorContext) To(i int) antlr.TerminalNode {
	return s.GetToken(css3ParserTo, i)
}

func (s *KeyframeSelectorContext) AllPercentage() []antlr.TerminalNode {
	return s.GetTokens(css3ParserPercentage)
}

func (s *KeyframeSelectorContext) Percentage(i int) antlr.TerminalNode {
	return s.GetToken(css3ParserPercentage, i)
}

func (s *KeyframeSelectorContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(css3ParserComma)
}

func (s *KeyframeSelectorContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(css3ParserComma, i)
}

func (s *KeyframeSelectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeyframeSelectorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeyframeSelectorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterKeyframeSelector(s)
	}
}

func (s *KeyframeSelectorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitKeyframeSelector(s)
	}
}

func (p *css3Parser) KeyframeSelector() (localctx IKeyframeSelectorContext) {
	this := p
	_ = this

	localctx = NewKeyframeSelectorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, css3ParserRULE_keyframeSelector)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(995)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-29)&-(0x1f+1)) == 0 && ((1<<uint((_la-29)))&((1<<(css3ParserPercentage-29))|(1<<(css3ParserFrom-29))|(1<<(css3ParserTo-29)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(996)
		p.Ws()
	}
	p.SetState(1004)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == css3ParserComma {
		{
			p.SetState(997)
			p.Match(css3ParserComma)
		}
		{
			p.SetState(998)
			p.Ws()
		}
		{
			p.SetState(999)
			_la = p.GetTokenStream().LA(1)

			if !(((_la-29)&-(0x1f+1)) == 0 && ((1<<uint((_la-29)))&((1<<(css3ParserPercentage-29))|(1<<(css3ParserFrom-29))|(1<<(css3ParserTo-29)))) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1000)
			p.Ws()
		}

		p.SetState(1006)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IViewportContext is an interface to support dynamic dispatch.
type IViewportContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsViewportContext differentiates from other interfaces.
	IsViewportContext()
}

type ViewportContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyViewportContext() *ViewportContext {
	var p = new(ViewportContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_viewport
	return p
}

func (*ViewportContext) IsViewportContext() {}

func NewViewportContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ViewportContext {
	var p = new(ViewportContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_viewport

	return p
}

func (s *ViewportContext) GetParser() antlr.Parser { return s.parser }

func (s *ViewportContext) Viewport() antlr.TerminalNode {
	return s.GetToken(css3ParserViewport, 0)
}

func (s *ViewportContext) AllWs() []IWsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWsContext)(nil)).Elem())
	var tst = make([]IWsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWsContext)
		}
	}

	return tst
}

func (s *ViewportContext) Ws(i int) IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *ViewportContext) DeclarationList() IDeclarationListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclarationListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclarationListContext)
}

func (s *ViewportContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ViewportContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ViewportContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterViewport(s)
	}
}

func (s *ViewportContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitViewport(s)
	}
}

func (p *css3Parser) Viewport() (localctx IViewportContext) {
	this := p
	_ = this

	localctx = NewViewportContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, css3ParserRULE_viewport)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1007)
		p.Match(css3ParserViewport)
	}
	{
		p.SetState(1008)
		p.Ws()
	}
	{
		p.SetState(1009)
		p.Match(css3ParserT__4)
	}
	{
		p.SetState(1010)
		p.Ws()
	}
	p.SetState(1012)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<css3ParserT__0)|(1<<css3ParserT__6)|(1<<css3ParserT__13))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(css3ParserMediaOnly-32))|(1<<(css3ParserNot-32))|(1<<(css3ParserAnd-32))|(1<<(css3ParserOr-32))|(1<<(css3ParserFrom-32))|(1<<(css3ParserTo-32))|(1<<(css3ParserVariable-32))|(1<<(css3ParserIdent-32)))) != 0) {
		{
			p.SetState(1011)
			p.DeclarationList()
		}

	}
	{
		p.SetState(1014)
		p.Match(css3ParserT__5)
	}
	{
		p.SetState(1015)
		p.Ws()
	}

	return localctx
}

// ICounterStyleContext is an interface to support dynamic dispatch.
type ICounterStyleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCounterStyleContext differentiates from other interfaces.
	IsCounterStyleContext()
}

type CounterStyleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCounterStyleContext() *CounterStyleContext {
	var p = new(CounterStyleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_counterStyle
	return p
}

func (*CounterStyleContext) IsCounterStyleContext() {}

func NewCounterStyleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CounterStyleContext {
	var p = new(CounterStyleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_counterStyle

	return p
}

func (s *CounterStyleContext) GetParser() antlr.Parser { return s.parser }

func (s *CounterStyleContext) CounterStyle() antlr.TerminalNode {
	return s.GetToken(css3ParserCounterStyle, 0)
}

func (s *CounterStyleContext) AllWs() []IWsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWsContext)(nil)).Elem())
	var tst = make([]IWsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWsContext)
		}
	}

	return tst
}

func (s *CounterStyleContext) Ws(i int) IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *CounterStyleContext) Ident() IIdentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *CounterStyleContext) DeclarationList() IDeclarationListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclarationListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclarationListContext)
}

func (s *CounterStyleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CounterStyleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CounterStyleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterCounterStyle(s)
	}
}

func (s *CounterStyleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitCounterStyle(s)
	}
}

func (p *css3Parser) CounterStyle() (localctx ICounterStyleContext) {
	this := p
	_ = this

	localctx = NewCounterStyleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, css3ParserRULE_counterStyle)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1017)
		p.Match(css3ParserCounterStyle)
	}
	{
		p.SetState(1018)
		p.Ws()
	}
	{
		p.SetState(1019)
		p.Ident()
	}
	{
		p.SetState(1020)
		p.Ws()
	}
	{
		p.SetState(1021)
		p.Match(css3ParserT__4)
	}
	{
		p.SetState(1022)
		p.Ws()
	}
	p.SetState(1024)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<css3ParserT__0)|(1<<css3ParserT__6)|(1<<css3ParserT__13))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(css3ParserMediaOnly-32))|(1<<(css3ParserNot-32))|(1<<(css3ParserAnd-32))|(1<<(css3ParserOr-32))|(1<<(css3ParserFrom-32))|(1<<(css3ParserTo-32))|(1<<(css3ParserVariable-32))|(1<<(css3ParserIdent-32)))) != 0) {
		{
			p.SetState(1023)
			p.DeclarationList()
		}

	}
	{
		p.SetState(1026)
		p.Match(css3ParserT__5)
	}
	{
		p.SetState(1027)
		p.Ws()
	}

	return localctx
}

// IFontFeatureValuesRuleContext is an interface to support dynamic dispatch.
type IFontFeatureValuesRuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFontFeatureValuesRuleContext differentiates from other interfaces.
	IsFontFeatureValuesRuleContext()
}

type FontFeatureValuesRuleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFontFeatureValuesRuleContext() *FontFeatureValuesRuleContext {
	var p = new(FontFeatureValuesRuleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_fontFeatureValuesRule
	return p
}

func (*FontFeatureValuesRuleContext) IsFontFeatureValuesRuleContext() {}

func NewFontFeatureValuesRuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FontFeatureValuesRuleContext {
	var p = new(FontFeatureValuesRuleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_fontFeatureValuesRule

	return p
}

func (s *FontFeatureValuesRuleContext) GetParser() antlr.Parser { return s.parser }

func (s *FontFeatureValuesRuleContext) FontFeatureValues() antlr.TerminalNode {
	return s.GetToken(css3ParserFontFeatureValues, 0)
}

func (s *FontFeatureValuesRuleContext) AllWs() []IWsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWsContext)(nil)).Elem())
	var tst = make([]IWsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWsContext)
		}
	}

	return tst
}

func (s *FontFeatureValuesRuleContext) Ws(i int) IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *FontFeatureValuesRuleContext) FontFamilyNameList() IFontFamilyNameListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFontFamilyNameListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFontFamilyNameListContext)
}

func (s *FontFeatureValuesRuleContext) AllFeatureValueBlock() []IFeatureValueBlockContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFeatureValueBlockContext)(nil)).Elem())
	var tst = make([]IFeatureValueBlockContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFeatureValueBlockContext)
		}
	}

	return tst
}

func (s *FontFeatureValuesRuleContext) FeatureValueBlock(i int) IFeatureValueBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFeatureValueBlockContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFeatureValueBlockContext)
}

func (s *FontFeatureValuesRuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FontFeatureValuesRuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FontFeatureValuesRuleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterFontFeatureValuesRule(s)
	}
}

func (s *FontFeatureValuesRuleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitFontFeatureValuesRule(s)
	}
}

func (p *css3Parser) FontFeatureValuesRule() (localctx IFontFeatureValuesRuleContext) {
	this := p
	_ = this

	localctx = NewFontFeatureValuesRuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, css3ParserRULE_fontFeatureValuesRule)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1029)
		p.Match(css3ParserFontFeatureValues)
	}
	{
		p.SetState(1030)
		p.Ws()
	}
	{
		p.SetState(1031)
		p.FontFamilyNameList()
	}
	{
		p.SetState(1032)
		p.Ws()
	}
	{
		p.SetState(1033)
		p.Match(css3ParserT__4)
	}
	{
		p.SetState(1034)
		p.Ws()
	}
	p.SetState(1038)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == css3ParserT__14 {
		{
			p.SetState(1035)
			p.FeatureValueBlock()
		}

		p.SetState(1040)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1041)
		p.Match(css3ParserT__5)
	}
	{
		p.SetState(1042)
		p.Ws()
	}

	return localctx
}

// IFontFamilyNameListContext is an interface to support dynamic dispatch.
type IFontFamilyNameListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFontFamilyNameListContext differentiates from other interfaces.
	IsFontFamilyNameListContext()
}

type FontFamilyNameListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFontFamilyNameListContext() *FontFamilyNameListContext {
	var p = new(FontFamilyNameListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_fontFamilyNameList
	return p
}

func (*FontFamilyNameListContext) IsFontFamilyNameListContext() {}

func NewFontFamilyNameListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FontFamilyNameListContext {
	var p = new(FontFamilyNameListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_fontFamilyNameList

	return p
}

func (s *FontFamilyNameListContext) GetParser() antlr.Parser { return s.parser }

func (s *FontFamilyNameListContext) AllFontFamilyName() []IFontFamilyNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFontFamilyNameContext)(nil)).Elem())
	var tst = make([]IFontFamilyNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFontFamilyNameContext)
		}
	}

	return tst
}

func (s *FontFamilyNameListContext) FontFamilyName(i int) IFontFamilyNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFontFamilyNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFontFamilyNameContext)
}

func (s *FontFamilyNameListContext) AllWs() []IWsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWsContext)(nil)).Elem())
	var tst = make([]IWsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWsContext)
		}
	}

	return tst
}

func (s *FontFamilyNameListContext) Ws(i int) IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *FontFamilyNameListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(css3ParserComma)
}

func (s *FontFamilyNameListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(css3ParserComma, i)
}

func (s *FontFamilyNameListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FontFamilyNameListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FontFamilyNameListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterFontFamilyNameList(s)
	}
}

func (s *FontFamilyNameListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitFontFamilyNameList(s)
	}
}

func (p *css3Parser) FontFamilyNameList() (localctx IFontFamilyNameListContext) {
	this := p
	_ = this

	localctx = NewFontFamilyNameListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, css3ParserRULE_fontFamilyNameList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1044)
		p.FontFamilyName()
	}
	p.SetState(1052)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 98, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1045)
				p.Ws()
			}
			{
				p.SetState(1046)
				p.Match(css3ParserComma)
			}
			{
				p.SetState(1047)
				p.Ws()
			}
			{
				p.SetState(1048)
				p.FontFamilyName()
			}

		}
		p.SetState(1054)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 98, p.GetParserRuleContext())
	}

	return localctx
}

// IFontFamilyNameContext is an interface to support dynamic dispatch.
type IFontFamilyNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFontFamilyNameContext differentiates from other interfaces.
	IsFontFamilyNameContext()
}

type FontFamilyNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFontFamilyNameContext() *FontFamilyNameContext {
	var p = new(FontFamilyNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_fontFamilyName
	return p
}

func (*FontFamilyNameContext) IsFontFamilyNameContext() {}

func NewFontFamilyNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FontFamilyNameContext {
	var p = new(FontFamilyNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_fontFamilyName

	return p
}

func (s *FontFamilyNameContext) GetParser() antlr.Parser { return s.parser }

func (s *FontFamilyNameContext) String_() antlr.TerminalNode {
	return s.GetToken(css3ParserString_, 0)
}

func (s *FontFamilyNameContext) AllIdent() []IIdentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentContext)(nil)).Elem())
	var tst = make([]IIdentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentContext)
		}
	}

	return tst
}

func (s *FontFamilyNameContext) Ident(i int) IIdentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *FontFamilyNameContext) AllWs() []IWsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWsContext)(nil)).Elem())
	var tst = make([]IWsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWsContext)
		}
	}

	return tst
}

func (s *FontFamilyNameContext) Ws(i int) IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *FontFamilyNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FontFamilyNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FontFamilyNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterFontFamilyName(s)
	}
}

func (s *FontFamilyNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitFontFamilyName(s)
	}
}

func (p *css3Parser) FontFamilyName() (localctx IFontFamilyNameContext) {
	this := p
	_ = this

	localctx = NewFontFamilyNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, css3ParserRULE_fontFamilyName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(1065)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case css3ParserString_:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1055)
			p.Match(css3ParserString_)
		}

	case css3ParserMediaOnly, css3ParserNot, css3ParserAnd, css3ParserOr, css3ParserFrom, css3ParserTo, css3ParserIdent:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1056)
			p.Ident()
		}
		p.SetState(1062)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 99, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1057)
					p.Ws()
				}
				{
					p.SetState(1058)
					p.Ident()
				}

			}
			p.SetState(1064)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 99, p.GetParserRuleContext())
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFeatureValueBlockContext is an interface to support dynamic dispatch.
type IFeatureValueBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFeatureValueBlockContext differentiates from other interfaces.
	IsFeatureValueBlockContext()
}

type FeatureValueBlockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFeatureValueBlockContext() *FeatureValueBlockContext {
	var p = new(FeatureValueBlockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_featureValueBlock
	return p
}

func (*FeatureValueBlockContext) IsFeatureValueBlockContext() {}

func NewFeatureValueBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FeatureValueBlockContext {
	var p = new(FeatureValueBlockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_featureValueBlock

	return p
}

func (s *FeatureValueBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *FeatureValueBlockContext) FeatureType() IFeatureTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFeatureTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFeatureTypeContext)
}

func (s *FeatureValueBlockContext) AllWs() []IWsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWsContext)(nil)).Elem())
	var tst = make([]IWsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWsContext)
		}
	}

	return tst
}

func (s *FeatureValueBlockContext) Ws(i int) IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *FeatureValueBlockContext) AllFeatureValueDefinition() []IFeatureValueDefinitionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFeatureValueDefinitionContext)(nil)).Elem())
	var tst = make([]IFeatureValueDefinitionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFeatureValueDefinitionContext)
		}
	}

	return tst
}

func (s *FeatureValueBlockContext) FeatureValueDefinition(i int) IFeatureValueDefinitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFeatureValueDefinitionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFeatureValueDefinitionContext)
}

func (s *FeatureValueBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FeatureValueBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FeatureValueBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterFeatureValueBlock(s)
	}
}

func (s *FeatureValueBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitFeatureValueBlock(s)
	}
}

func (p *css3Parser) FeatureValueBlock() (localctx IFeatureValueBlockContext) {
	this := p
	_ = this

	localctx = NewFeatureValueBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, css3ParserRULE_featureValueBlock)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1067)
		p.FeatureType()
	}
	{
		p.SetState(1068)
		p.Ws()
	}
	{
		p.SetState(1069)
		p.Match(css3ParserT__4)
	}
	{
		p.SetState(1070)
		p.Ws()
	}
	p.SetState(1072)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(css3ParserMediaOnly-32))|(1<<(css3ParserNot-32))|(1<<(css3ParserAnd-32))|(1<<(css3ParserOr-32))|(1<<(css3ParserFrom-32))|(1<<(css3ParserTo-32))|(1<<(css3ParserIdent-32)))) != 0 {
		{
			p.SetState(1071)
			p.FeatureValueDefinition()
		}

	}
	p.SetState(1082)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<css3ParserT__0)|(1<<css3ParserComment)|(1<<css3ParserSpace))) != 0 {
		{
			p.SetState(1074)
			p.Ws()
		}
		{
			p.SetState(1075)
			p.Match(css3ParserT__0)
		}
		{
			p.SetState(1076)
			p.Ws()
		}
		p.SetState(1078)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(css3ParserMediaOnly-32))|(1<<(css3ParserNot-32))|(1<<(css3ParserAnd-32))|(1<<(css3ParserOr-32))|(1<<(css3ParserFrom-32))|(1<<(css3ParserTo-32))|(1<<(css3ParserIdent-32)))) != 0 {
			{
				p.SetState(1077)
				p.FeatureValueDefinition()
			}

		}

		p.SetState(1084)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1085)
		p.Match(css3ParserT__5)
	}
	{
		p.SetState(1086)
		p.Ws()
	}

	return localctx
}

// IFeatureTypeContext is an interface to support dynamic dispatch.
type IFeatureTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFeatureTypeContext differentiates from other interfaces.
	IsFeatureTypeContext()
}

type FeatureTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFeatureTypeContext() *FeatureTypeContext {
	var p = new(FeatureTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_featureType
	return p
}

func (*FeatureTypeContext) IsFeatureTypeContext() {}

func NewFeatureTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FeatureTypeContext {
	var p = new(FeatureTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_featureType

	return p
}

func (s *FeatureTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *FeatureTypeContext) AtKeyword() IAtKeywordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtKeywordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtKeywordContext)
}

func (s *FeatureTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FeatureTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FeatureTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterFeatureType(s)
	}
}

func (s *FeatureTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitFeatureType(s)
	}
}

func (p *css3Parser) FeatureType() (localctx IFeatureTypeContext) {
	this := p
	_ = this

	localctx = NewFeatureTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, css3ParserRULE_featureType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1088)
		p.AtKeyword()
	}

	return localctx
}

// IFeatureValueDefinitionContext is an interface to support dynamic dispatch.
type IFeatureValueDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFeatureValueDefinitionContext differentiates from other interfaces.
	IsFeatureValueDefinitionContext()
}

type FeatureValueDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFeatureValueDefinitionContext() *FeatureValueDefinitionContext {
	var p = new(FeatureValueDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_featureValueDefinition
	return p
}

func (*FeatureValueDefinitionContext) IsFeatureValueDefinitionContext() {}

func NewFeatureValueDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FeatureValueDefinitionContext {
	var p = new(FeatureValueDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_featureValueDefinition

	return p
}

func (s *FeatureValueDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *FeatureValueDefinitionContext) Ident() IIdentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *FeatureValueDefinitionContext) AllWs() []IWsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWsContext)(nil)).Elem())
	var tst = make([]IWsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWsContext)
		}
	}

	return tst
}

func (s *FeatureValueDefinitionContext) Ws(i int) IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *FeatureValueDefinitionContext) AllNumber() []INumberContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INumberContext)(nil)).Elem())
	var tst = make([]INumberContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INumberContext)
		}
	}

	return tst
}

func (s *FeatureValueDefinitionContext) Number(i int) INumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumberContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *FeatureValueDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FeatureValueDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FeatureValueDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterFeatureValueDefinition(s)
	}
}

func (s *FeatureValueDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitFeatureValueDefinition(s)
	}
}

func (p *css3Parser) FeatureValueDefinition() (localctx IFeatureValueDefinitionContext) {
	this := p
	_ = this

	localctx = NewFeatureValueDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, css3ParserRULE_featureValueDefinition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1090)
		p.Ident()
	}
	{
		p.SetState(1091)
		p.Ws()
	}
	{
		p.SetState(1092)
		p.Match(css3ParserT__2)
	}
	{
		p.SetState(1093)
		p.Ws()
	}
	{
		p.SetState(1094)
		p.Number()
	}
	p.SetState(1100)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 104, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1095)
				p.Ws()
			}
			{
				p.SetState(1096)
				p.Number()
			}

		}
		p.SetState(1102)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 104, p.GetParserRuleContext())
	}

	return localctx
}

// IIdentContext is an interface to support dynamic dispatch.
type IIdentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdentContext differentiates from other interfaces.
	IsIdentContext()
}

type IdentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentContext() *IdentContext {
	var p = new(IdentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_ident
	return p
}

func (*IdentContext) IsIdentContext() {}

func NewIdentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentContext {
	var p = new(IdentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_ident

	return p
}

func (s *IdentContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentContext) Ident() antlr.TerminalNode {
	return s.GetToken(css3ParserIdent, 0)
}

func (s *IdentContext) MediaOnly() antlr.TerminalNode {
	return s.GetToken(css3ParserMediaOnly, 0)
}

func (s *IdentContext) Not() antlr.TerminalNode {
	return s.GetToken(css3ParserNot, 0)
}

func (s *IdentContext) And() antlr.TerminalNode {
	return s.GetToken(css3ParserAnd, 0)
}

func (s *IdentContext) Or() antlr.TerminalNode {
	return s.GetToken(css3ParserOr, 0)
}

func (s *IdentContext) From() antlr.TerminalNode {
	return s.GetToken(css3ParserFrom, 0)
}

func (s *IdentContext) To() antlr.TerminalNode {
	return s.GetToken(css3ParserTo, 0)
}

func (s *IdentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterIdent(s)
	}
}

func (s *IdentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitIdent(s)
	}
}

func (p *css3Parser) Ident() (localctx IIdentContext) {
	this := p
	_ = this

	localctx = NewIdentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, css3ParserRULE_ident)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1103)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(css3ParserMediaOnly-32))|(1<<(css3ParserNot-32))|(1<<(css3ParserAnd-32))|(1<<(css3ParserOr-32))|(1<<(css3ParserFrom-32))|(1<<(css3ParserTo-32))|(1<<(css3ParserIdent-32)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IWsContext is an interface to support dynamic dispatch.
type IWsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWsContext differentiates from other interfaces.
	IsWsContext()
}

type WsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWsContext() *WsContext {
	var p = new(WsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = css3ParserRULE_ws
	return p
}

func (*WsContext) IsWsContext() {}

func NewWsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WsContext {
	var p = new(WsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = css3ParserRULE_ws

	return p
}

func (s *WsContext) GetParser() antlr.Parser { return s.parser }

func (s *WsContext) AllComment() []antlr.TerminalNode {
	return s.GetTokens(css3ParserComment)
}

func (s *WsContext) Comment(i int) antlr.TerminalNode {
	return s.GetToken(css3ParserComment, i)
}

func (s *WsContext) AllSpace() []antlr.TerminalNode {
	return s.GetTokens(css3ParserSpace)
}

func (s *WsContext) Space(i int) antlr.TerminalNode {
	return s.GetToken(css3ParserSpace, i)
}

func (s *WsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.EnterWs(s)
	}
}

func (s *WsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(css3Listener); ok {
		listenerT.ExitWs(s)
	}
}

func (p *css3Parser) Ws() (localctx IWsContext) {
	this := p
	_ = this

	localctx = NewWsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, css3ParserRULE_ws)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1108)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 105, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1105)
				_la = p.GetTokenStream().LA(1)

				if !(_la == css3ParserComment || _la == css3ParserSpace) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(1110)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 105, p.GetParserRuleContext())
	}

	return localctx
}
