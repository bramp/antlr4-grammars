// Code generated from WebIDL.g4 by ANTLR 4.9.3. DO NOT EDIT.

package webidl // WebIDL
import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 90, 906,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4,
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55,
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9,
	60, 4, 61, 9, 61, 4, 62, 9, 62, 4, 63, 9, 63, 4, 64, 9, 64, 4, 65, 9, 65,
	4, 66, 9, 66, 4, 67, 9, 67, 4, 68, 9, 68, 4, 69, 9, 69, 4, 70, 9, 70, 4,
	71, 9, 71, 4, 72, 9, 72, 4, 73, 9, 73, 4, 74, 9, 74, 4, 75, 9, 75, 4, 76,
	9, 76, 4, 77, 9, 77, 4, 78, 9, 78, 4, 79, 9, 79, 4, 80, 9, 80, 4, 81, 9,
	81, 4, 82, 9, 82, 4, 83, 9, 83, 4, 84, 9, 84, 4, 85, 9, 85, 4, 86, 9, 86,
	4, 87, 9, 87, 4, 88, 9, 88, 4, 89, 9, 89, 4, 90, 9, 90, 4, 91, 9, 91, 4,
	92, 9, 92, 4, 93, 9, 93, 4, 94, 9, 94, 4, 95, 9, 95, 4, 96, 9, 96, 4, 97,
	9, 97, 4, 98, 9, 98, 4, 99, 9, 99, 4, 100, 9, 100, 4, 101, 9, 101, 4, 102,
	9, 102, 4, 103, 9, 103, 4, 104, 9, 104, 4, 105, 9, 105, 4, 106, 9, 106,
	4, 107, 9, 107, 4, 108, 9, 108, 4, 109, 9, 109, 4, 110, 9, 110, 4, 111,
	9, 111, 4, 112, 9, 112, 4, 113, 9, 113, 4, 114, 9, 114, 3, 2, 3, 2, 3,
	2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 5, 3, 237, 10, 3, 3, 4, 3, 4, 3, 4, 3,
	4, 3, 4, 3, 4, 3, 4, 5, 4, 246, 10, 4, 3, 5, 3, 5, 3, 6, 3, 6, 3, 6, 3,
	6, 5, 6, 254, 10, 6, 3, 7, 3, 7, 5, 7, 258, 10, 7, 3, 8, 3, 8, 3, 8, 3,
	8, 3, 8, 3, 8, 3, 8, 3, 9, 3, 9, 3, 9, 3, 10, 3, 10, 3, 10, 3, 10, 5, 10,
	274, 10, 10, 3, 11, 3, 11, 5, 11, 278, 10, 11, 3, 12, 3, 12, 3, 12, 3,
	12, 3, 12, 3, 12, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 5, 13, 291, 10, 13,
	3, 14, 3, 14, 5, 14, 295, 10, 14, 3, 15, 3, 15, 3, 15, 3, 15, 3, 15, 5,
	15, 302, 10, 15, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16,
	3, 16, 3, 16, 3, 16, 5, 16, 315, 10, 16, 3, 17, 3, 17, 3, 17, 5, 17, 320,
	10, 17, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 3, 19, 3, 19,
	3, 19, 3, 19, 3, 19, 5, 19, 334, 10, 19, 3, 20, 3, 20, 3, 20, 3, 20, 3,
	20, 3, 20, 5, 20, 342, 10, 20, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 22,
	3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 5, 22, 357, 10, 22, 3,
	23, 3, 23, 3, 23, 3, 23, 3, 23, 5, 23, 364, 10, 23, 3, 24, 3, 24, 5, 24,
	368, 10, 24, 3, 25, 3, 25, 3, 25, 3, 25, 3, 25, 3, 25, 3, 25, 3, 26, 3,
	26, 3, 26, 5, 26, 380, 10, 26, 3, 27, 3, 27, 3, 28, 3, 28, 3, 29, 3, 29,
	5, 29, 388, 10, 29, 3, 30, 3, 30, 3, 30, 3, 31, 3, 31, 3, 31, 5, 31, 396,
	10, 31, 3, 32, 3, 32, 3, 33, 3, 33, 3, 33, 3, 34, 3, 34, 3, 34, 3, 34,
	3, 34, 3, 35, 3, 35, 5, 35, 410, 10, 35, 3, 36, 3, 36, 3, 37, 3, 37, 5,
	37, 416, 10, 37, 3, 38, 3, 38, 3, 38, 3, 38, 3, 38, 3, 38, 3, 38, 5, 38,
	425, 10, 38, 3, 39, 3, 39, 5, 39, 429, 10, 39, 3, 40, 3, 40, 3, 40, 3,
	41, 3, 41, 3, 41, 3, 42, 3, 42, 3, 43, 3, 43, 3, 43, 3, 43, 3, 43, 3, 43,
	3, 44, 3, 44, 5, 44, 447, 10, 44, 3, 45, 3, 45, 5, 45, 451, 10, 45, 3,
	46, 3, 46, 3, 47, 3, 47, 3, 47, 3, 47, 5, 47, 459, 10, 47, 3, 48, 3, 48,
	3, 48, 3, 48, 3, 48, 5, 48, 466, 10, 48, 3, 49, 3, 49, 3, 49, 3, 50, 3,
	50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 5, 50, 480, 10, 50,
	3, 51, 3, 51, 5, 51, 484, 10, 51, 3, 52, 3, 52, 5, 52, 488, 10, 52, 3,
	53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 54, 3, 54, 3, 54, 3, 55, 3, 55,
	3, 55, 3, 55, 3, 55, 5, 55, 504, 10, 55, 3, 56, 3, 56, 3, 56, 3, 57, 3,
	57, 3, 57, 3, 57, 5, 57, 513, 10, 57, 3, 58, 3, 58, 3, 58, 3, 58, 3, 58,
	3, 58, 3, 58, 3, 59, 3, 59, 3, 59, 5, 59, 525, 10, 59, 3, 60, 3, 60, 3,
	60, 3, 60, 3, 60, 3, 60, 3, 60, 3, 60, 3, 60, 3, 61, 3, 61, 3, 61, 3, 61,
	3, 61, 5, 61, 541, 10, 61, 3, 62, 3, 62, 3, 63, 3, 63, 3, 63, 3, 63, 3,
	63, 3, 63, 3, 63, 3, 63, 3, 64, 3, 64, 3, 65, 3, 65, 3, 65, 3, 65, 3, 65,
	3, 65, 3, 66, 3, 66, 3, 66, 3, 66, 3, 66, 3, 66, 3, 66, 3, 67, 3, 67, 3,
	67, 3, 67, 3, 67, 5, 67, 573, 10, 67, 3, 68, 3, 68, 3, 68, 3, 68, 5, 68,
	579, 10, 68, 3, 69, 3, 69, 3, 69, 3, 69, 3, 69, 3, 69, 3, 69, 3, 69, 3,
	70, 3, 70, 3, 70, 3, 70, 5, 70, 593, 10, 70, 3, 71, 3, 71, 3, 71, 3, 72,
	3, 72, 3, 72, 3, 72, 3, 72, 3, 72, 3, 72, 3, 72, 3, 72, 3, 72, 5, 72, 608,
	10, 72, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 74, 3, 74,
	3, 74, 5, 74, 620, 10, 74, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3,
	75, 3, 76, 3, 76, 3, 76, 3, 77, 3, 77, 3, 77, 5, 77, 635, 10, 77, 3, 78,
	3, 78, 3, 78, 5, 78, 640, 10, 78, 3, 79, 3, 79, 3, 79, 3, 79, 3, 79, 3,
	79, 3, 79, 3, 79, 3, 80, 3, 80, 3, 80, 3, 80, 3, 80, 3, 81, 3, 81, 3, 81,
	3, 81, 5, 81, 659, 10, 81, 3, 82, 3, 82, 3, 82, 3, 83, 3, 83, 3, 83, 5,
	83, 667, 10, 83, 3, 84, 3, 84, 3, 84, 3, 84, 3, 84, 3, 84, 3, 84, 3, 85,
	3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 5, 85, 682, 10, 85, 3, 86, 3, 86, 3,
	86, 3, 86, 3, 86, 5, 86, 689, 10, 86, 3, 87, 3, 87, 3, 87, 3, 87, 3, 87,
	3, 87, 3, 87, 3, 87, 3, 87, 3, 87, 3, 87, 3, 87, 3, 87, 3, 87, 3, 87, 3,
	87, 3, 87, 3, 87, 3, 87, 3, 87, 3, 87, 3, 87, 3, 87, 3, 87, 3, 87, 3, 87,
	3, 87, 3, 87, 3, 87, 3, 87, 3, 87, 3, 87, 3, 87, 3, 87, 3, 87, 3, 87, 5,
	87, 727, 10, 87, 3, 88, 3, 88, 3, 88, 3, 88, 3, 88, 3, 88, 3, 88, 5, 88,
	736, 10, 88, 3, 89, 3, 89, 3, 89, 5, 89, 741, 10, 89, 3, 90, 3, 90, 3,
	91, 3, 91, 3, 91, 5, 91, 748, 10, 91, 3, 92, 3, 92, 3, 92, 5, 92, 753,
	10, 92, 3, 93, 3, 93, 5, 93, 757, 10, 93, 3, 94, 3, 94, 3, 95, 3, 95, 3,
	95, 3, 95, 3, 95, 3, 96, 3, 96, 3, 96, 3, 96, 3, 96, 3, 96, 3, 96, 3, 97,
	3, 97, 5, 97, 775, 10, 97, 3, 98, 3, 98, 3, 99, 3, 99, 3, 99, 3, 99, 3,
	99, 3, 99, 5, 99, 785, 10, 99, 3, 100, 3, 100, 3, 100, 3, 100, 3, 100,
	5, 100, 792, 10, 100, 3, 101, 3, 101, 3, 101, 3, 101, 3, 101, 3, 101, 3,
	101, 5, 101, 801, 10, 101, 3, 102, 3, 102, 3, 102, 3, 102, 3, 102, 3, 102,
	3, 102, 3, 102, 3, 102, 3, 102, 3, 102, 3, 102, 3, 102, 3, 102, 3, 102,
	3, 102, 3, 102, 3, 102, 3, 102, 3, 102, 3, 102, 3, 102, 3, 102, 3, 102,
	3, 102, 3, 102, 3, 102, 3, 102, 3, 102, 3, 102, 3, 102, 3, 102, 3, 102,
	3, 102, 3, 102, 3, 102, 3, 102, 3, 102, 3, 102, 3, 102, 3, 102, 3, 102,
	3, 102, 3, 102, 3, 102, 5, 102, 848, 10, 102, 3, 103, 3, 103, 5, 103, 852,
	10, 103, 3, 104, 3, 104, 3, 104, 3, 105, 3, 105, 3, 105, 3, 105, 5, 105,
	861, 10, 105, 3, 106, 3, 106, 3, 107, 3, 107, 3, 107, 3, 107, 3, 107, 3,
	108, 3, 108, 3, 108, 3, 108, 3, 109, 3, 109, 3, 109, 3, 109, 3, 109, 3,
	109, 3, 110, 3, 110, 3, 110, 3, 110, 3, 110, 3, 110, 3, 110, 3, 111, 3,
	111, 3, 111, 3, 111, 3, 112, 3, 112, 3, 112, 3, 112, 3, 112, 3, 112, 3,
	113, 3, 113, 3, 113, 3, 114, 3, 114, 3, 114, 3, 114, 5, 114, 904, 10, 114,
	3, 114, 2, 2, 115, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28,
	30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64,
	66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100,
	102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130,
	132, 134, 136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 160,
	162, 164, 166, 168, 170, 172, 174, 176, 178, 180, 182, 184, 186, 188, 190,
	192, 194, 196, 198, 200, 202, 204, 206, 208, 210, 212, 214, 216, 218, 220,
	222, 224, 226, 2, 10, 3, 2, 3, 27, 3, 2, 33, 34, 4, 2, 35, 37, 85, 85,
	4, 2, 3, 3, 21, 21, 5, 2, 8, 8, 11, 11, 23, 23, 3, 2, 60, 61, 3, 2, 65,
	67, 3, 2, 71, 81, 2, 937, 2, 228, 3, 2, 2, 2, 4, 236, 3, 2, 2, 2, 6, 245,
	3, 2, 2, 2, 8, 247, 3, 2, 2, 2, 10, 253, 3, 2, 2, 2, 12, 257, 3, 2, 2,
	2, 14, 259, 3, 2, 2, 2, 16, 266, 3, 2, 2, 2, 18, 273, 3, 2, 2, 2, 20, 277,
	3, 2, 2, 2, 22, 279, 3, 2, 2, 2, 24, 290, 3, 2, 2, 2, 26, 294, 3, 2, 2,
	2, 28, 301, 3, 2, 2, 2, 30, 314, 3, 2, 2, 2, 32, 319, 3, 2, 2, 2, 34, 321,
	3, 2, 2, 2, 36, 333, 3, 2, 2, 2, 38, 341, 3, 2, 2, 2, 40, 343, 3, 2, 2,
	2, 42, 356, 3, 2, 2, 2, 44, 363, 3, 2, 2, 2, 46, 367, 3, 2, 2, 2, 48, 369,
	3, 2, 2, 2, 50, 379, 3, 2, 2, 2, 52, 381, 3, 2, 2, 2, 54, 383, 3, 2, 2,
	2, 56, 387, 3, 2, 2, 2, 58, 389, 3, 2, 2, 2, 60, 395, 3, 2, 2, 2, 62, 397,
	3, 2, 2, 2, 64, 399, 3, 2, 2, 2, 66, 402, 3, 2, 2, 2, 68, 409, 3, 2, 2,
	2, 70, 411, 3, 2, 2, 2, 72, 415, 3, 2, 2, 2, 74, 424, 3, 2, 2, 2, 76, 428,
	3, 2, 2, 2, 78, 430, 3, 2, 2, 2, 80, 433, 3, 2, 2, 2, 82, 436, 3, 2, 2,
	2, 84, 438, 3, 2, 2, 2, 86, 446, 3, 2, 2, 2, 88, 450, 3, 2, 2, 2, 90, 452,
	3, 2, 2, 2, 92, 458, 3, 2, 2, 2, 94, 465, 3, 2, 2, 2, 96, 467, 3, 2, 2,
	2, 98, 479, 3, 2, 2, 2, 100, 483, 3, 2, 2, 2, 102, 487, 3, 2, 2, 2, 104,
	489, 3, 2, 2, 2, 106, 495, 3, 2, 2, 2, 108, 503, 3, 2, 2, 2, 110, 505,
	3, 2, 2, 2, 112, 512, 3, 2, 2, 2, 114, 514, 3, 2, 2, 2, 116, 524, 3, 2,
	2, 2, 118, 526, 3, 2, 2, 2, 120, 540, 3, 2, 2, 2, 122, 542, 3, 2, 2, 2,
	124, 544, 3, 2, 2, 2, 126, 552, 3, 2, 2, 2, 128, 554, 3, 2, 2, 2, 130,
	560, 3, 2, 2, 2, 132, 572, 3, 2, 2, 2, 134, 578, 3, 2, 2, 2, 136, 580,
	3, 2, 2, 2, 138, 592, 3, 2, 2, 2, 140, 594, 3, 2, 2, 2, 142, 607, 3, 2,
	2, 2, 144, 609, 3, 2, 2, 2, 146, 619, 3, 2, 2, 2, 148, 621, 3, 2, 2, 2,
	150, 628, 3, 2, 2, 2, 152, 634, 3, 2, 2, 2, 154, 639, 3, 2, 2, 2, 156,
	641, 3, 2, 2, 2, 158, 649, 3, 2, 2, 2, 160, 658, 3, 2, 2, 2, 162, 660,
	3, 2, 2, 2, 164, 666, 3, 2, 2, 2, 166, 668, 3, 2, 2, 2, 168, 681, 3, 2,
	2, 2, 170, 688, 3, 2, 2, 2, 172, 726, 3, 2, 2, 2, 174, 735, 3, 2, 2, 2,
	176, 740, 3, 2, 2, 2, 178, 742, 3, 2, 2, 2, 180, 747, 3, 2, 2, 2, 182,
	752, 3, 2, 2, 2, 184, 756, 3, 2, 2, 2, 186, 758, 3, 2, 2, 2, 188, 760,
	3, 2, 2, 2, 190, 765, 3, 2, 2, 2, 192, 774, 3, 2, 2, 2, 194, 776, 3, 2,
	2, 2, 196, 784, 3, 2, 2, 2, 198, 791, 3, 2, 2, 2, 200, 800, 3, 2, 2, 2,
	202, 847, 3, 2, 2, 2, 204, 851, 3, 2, 2, 2, 206, 853, 3, 2, 2, 2, 208,
	860, 3, 2, 2, 2, 210, 862, 3, 2, 2, 2, 212, 864, 3, 2, 2, 2, 214, 869,
	3, 2, 2, 2, 216, 873, 3, 2, 2, 2, 218, 879, 3, 2, 2, 2, 220, 886, 3, 2,
	2, 2, 222, 890, 3, 2, 2, 2, 224, 896, 3, 2, 2, 2, 226, 903, 3, 2, 2, 2,
	228, 229, 5, 4, 3, 2, 229, 230, 7, 2, 2, 3, 230, 3, 3, 2, 2, 2, 231, 232,
	5, 196, 99, 2, 232, 233, 5, 6, 4, 2, 233, 234, 5, 4, 3, 2, 234, 237, 3,
	2, 2, 2, 235, 237, 3, 2, 2, 2, 236, 231, 3, 2, 2, 2, 236, 235, 3, 2, 2,
	2, 237, 5, 3, 2, 2, 2, 238, 246, 5, 10, 6, 2, 239, 246, 5, 130, 66, 2,
	240, 246, 5, 16, 9, 2, 241, 246, 5, 136, 69, 2, 242, 246, 5, 148, 75, 2,
	243, 246, 5, 158, 80, 2, 244, 246, 5, 40, 21, 2, 245, 238, 3, 2, 2, 2,
	245, 239, 3, 2, 2, 2, 245, 240, 3, 2, 2, 2, 245, 241, 3, 2, 2, 2, 245,
	242, 3, 2, 2, 2, 245, 243, 3, 2, 2, 2, 245, 244, 3, 2, 2, 2, 246, 7, 3,
	2, 2, 2, 247, 248, 9, 2, 2, 2, 248, 9, 3, 2, 2, 2, 249, 250, 7, 5, 2, 2,
	250, 254, 5, 42, 22, 2, 251, 252, 7, 14, 2, 2, 252, 254, 5, 12, 7, 2, 253,
	249, 3, 2, 2, 2, 253, 251, 3, 2, 2, 2, 254, 11, 3, 2, 2, 2, 255, 258, 5,
	14, 8, 2, 256, 258, 5, 34, 18, 2, 257, 255, 3, 2, 2, 2, 257, 256, 3, 2,
	2, 2, 258, 13, 3, 2, 2, 2, 259, 260, 7, 86, 2, 2, 260, 261, 5, 32, 17,
	2, 261, 262, 7, 28, 2, 2, 262, 263, 5, 24, 13, 2, 263, 264, 7, 29, 2, 2,
	264, 265, 7, 30, 2, 2, 265, 15, 3, 2, 2, 2, 266, 267, 7, 19, 2, 2, 267,
	268, 5, 18, 10, 2, 268, 17, 3, 2, 2, 2, 269, 270, 7, 14, 2, 2, 270, 274,
	5, 20, 11, 2, 271, 274, 5, 144, 73, 2, 272, 274, 5, 130, 66, 2, 273, 269,
	3, 2, 2, 2, 273, 271, 3, 2, 2, 2, 273, 272, 3, 2, 2, 2, 274, 19, 3, 2,
	2, 2, 275, 278, 5, 22, 12, 2, 276, 278, 5, 34, 18, 2, 277, 275, 3, 2, 2,
	2, 277, 276, 3, 2, 2, 2, 278, 21, 3, 2, 2, 2, 279, 280, 7, 86, 2, 2, 280,
	281, 7, 28, 2, 2, 281, 282, 5, 28, 15, 2, 282, 283, 7, 29, 2, 2, 283, 284,
	7, 30, 2, 2, 284, 23, 3, 2, 2, 2, 285, 286, 5, 196, 99, 2, 286, 287, 5,
	26, 14, 2, 287, 288, 5, 24, 13, 2, 288, 291, 3, 2, 2, 2, 289, 291, 3, 2,
	2, 2, 290, 285, 3, 2, 2, 2, 290, 289, 3, 2, 2, 2, 291, 25, 3, 2, 2, 2,
	292, 295, 5, 30, 16, 2, 293, 295, 5, 104, 53, 2, 294, 292, 3, 2, 2, 2,
	294, 293, 3, 2, 2, 2, 295, 27, 3, 2, 2, 2, 296, 297, 5, 196, 99, 2, 297,
	298, 5, 30, 16, 2, 298, 299, 5, 28, 15, 2, 299, 302, 3, 2, 2, 2, 300, 302,
	3, 2, 2, 2, 301, 296, 3, 2, 2, 2, 301, 300, 3, 2, 2, 2, 302, 29, 3, 2,
	2, 2, 303, 315, 5, 48, 25, 2, 304, 315, 5, 76, 39, 2, 305, 315, 5, 106,
	54, 2, 306, 315, 5, 110, 56, 2, 307, 315, 5, 114, 58, 2, 308, 315, 5, 118,
	60, 2, 309, 315, 5, 58, 30, 2, 310, 315, 5, 62, 32, 2, 311, 315, 5, 122,
	62, 2, 312, 315, 5, 126, 64, 2, 313, 315, 5, 64, 33, 2, 314, 303, 3, 2,
	2, 2, 314, 304, 3, 2, 2, 2, 314, 305, 3, 2, 2, 2, 314, 306, 3, 2, 2, 2,
	314, 307, 3, 2, 2, 2, 314, 308, 3, 2, 2, 2, 314, 309, 3, 2, 2, 2, 314,
	310, 3, 2, 2, 2, 314, 311, 3, 2, 2, 2, 314, 312, 3, 2, 2, 2, 314, 313,
	3, 2, 2, 2, 315, 31, 3, 2, 2, 2, 316, 317, 7, 31, 2, 2, 317, 320, 7, 86,
	2, 2, 318, 320, 3, 2, 2, 2, 319, 316, 3, 2, 2, 2, 319, 318, 3, 2, 2, 2,
	320, 33, 3, 2, 2, 2, 321, 322, 7, 17, 2, 2, 322, 323, 7, 86, 2, 2, 323,
	324, 7, 28, 2, 2, 324, 325, 5, 36, 19, 2, 325, 326, 7, 29, 2, 2, 326, 327,
	7, 30, 2, 2, 327, 35, 3, 2, 2, 2, 328, 329, 5, 196, 99, 2, 329, 330, 5,
	38, 20, 2, 330, 331, 5, 36, 19, 2, 331, 334, 3, 2, 2, 2, 332, 334, 3, 2,
	2, 2, 333, 328, 3, 2, 2, 2, 333, 332, 3, 2, 2, 2, 334, 37, 3, 2, 2, 2,
	335, 342, 5, 48, 25, 2, 336, 342, 5, 78, 40, 2, 337, 342, 5, 106, 54, 2,
	338, 339, 5, 72, 37, 2, 339, 340, 5, 66, 34, 2, 340, 342, 3, 2, 2, 2, 341,
	335, 3, 2, 2, 2, 341, 336, 3, 2, 2, 2, 341, 337, 3, 2, 2, 2, 341, 338,
	3, 2, 2, 2, 342, 39, 3, 2, 2, 2, 343, 344, 7, 86, 2, 2, 344, 345, 7, 12,
	2, 2, 345, 346, 7, 86, 2, 2, 346, 347, 7, 30, 2, 2, 347, 41, 3, 2, 2, 2,
	348, 357, 5, 156, 79, 2, 349, 350, 7, 14, 2, 2, 350, 351, 7, 86, 2, 2,
	351, 352, 7, 28, 2, 2, 352, 353, 5, 44, 23, 2, 353, 354, 7, 29, 2, 2, 354,
	355, 7, 30, 2, 2, 355, 357, 3, 2, 2, 2, 356, 348, 3, 2, 2, 2, 356, 349,
	3, 2, 2, 2, 357, 43, 3, 2, 2, 2, 358, 359, 5, 196, 99, 2, 359, 360, 5,
	46, 24, 2, 360, 361, 5, 44, 23, 2, 361, 364, 3, 2, 2, 2, 362, 364, 3, 2,
	2, 2, 363, 358, 3, 2, 2, 2, 363, 362, 3, 2, 2, 2, 364, 45, 3, 2, 2, 2,
	365, 368, 5, 48, 25, 2, 366, 368, 5, 78, 40, 2, 367, 365, 3, 2, 2, 2, 367,
	366, 3, 2, 2, 2, 368, 47, 3, 2, 2, 2, 369, 370, 7, 6, 2, 2, 370, 371, 5,
	56, 29, 2, 371, 372, 7, 86, 2, 2, 372, 373, 7, 32, 2, 2, 373, 374, 5, 50,
	26, 2, 374, 375, 7, 30, 2, 2, 375, 49, 3, 2, 2, 2, 376, 380, 5, 52, 27,
	2, 377, 380, 5, 54, 28, 2, 378, 380, 7, 84, 2, 2, 379, 376, 3, 2, 2, 2,
	379, 377, 3, 2, 2, 2, 379, 378, 3, 2, 2, 2, 380, 51, 3, 2, 2, 2, 381, 382,
	9, 3, 2, 2, 382, 53, 3, 2, 2, 2, 383, 384, 9, 4, 2, 2, 384, 55, 3, 2, 2,
	2, 385, 388, 5, 174, 88, 2, 386, 388, 7, 86, 2, 2, 387, 385, 3, 2, 2, 2,
	387, 386, 3, 2, 2, 2, 388, 57, 3, 2, 2, 2, 389, 390, 7, 20, 2, 2, 390,
	391, 5, 60, 31, 2, 391, 59, 3, 2, 2, 2, 392, 396, 5, 66, 34, 2, 393, 396,
	5, 124, 63, 2, 394, 396, 5, 128, 65, 2, 395, 392, 3, 2, 2, 2, 395, 393,
	3, 2, 2, 2, 395, 394, 3, 2, 2, 2, 396, 61, 3, 2, 2, 2, 397, 398, 5, 66,
	34, 2, 398, 63, 3, 2, 2, 2, 399, 400, 7, 13, 2, 2, 400, 401, 5, 66, 34,
	2, 401, 65, 3, 2, 2, 2, 402, 403, 7, 4, 2, 2, 403, 404, 5, 162, 82, 2,
	404, 405, 5, 68, 35, 2, 405, 406, 7, 30, 2, 2, 406, 67, 3, 2, 2, 2, 407,
	410, 5, 70, 36, 2, 408, 410, 7, 86, 2, 2, 409, 407, 3, 2, 2, 2, 409, 408,
	3, 2, 2, 2, 410, 69, 3, 2, 2, 2, 411, 412, 9, 5, 2, 2, 412, 71, 3, 2, 2,
	2, 413, 416, 7, 20, 2, 2, 414, 416, 3, 2, 2, 2, 415, 413, 3, 2, 2, 2, 415,
	414, 3, 2, 2, 2, 416, 73, 3, 2, 2, 2, 417, 425, 5, 50, 26, 2, 418, 425,
	7, 87, 2, 2, 419, 420, 7, 38, 2, 2, 420, 425, 7, 39, 2, 2, 421, 422, 7,
	28, 2, 2, 422, 425, 7, 29, 2, 2, 423, 425, 7, 40, 2, 2, 424, 417, 3, 2,
	2, 2, 424, 418, 3, 2, 2, 2, 424, 419, 3, 2, 2, 2, 424, 421, 3, 2, 2, 2,
	424, 423, 3, 2, 2, 2, 425, 75, 3, 2, 2, 2, 426, 429, 5, 78, 40, 2, 427,
	429, 5, 80, 41, 2, 428, 426, 3, 2, 2, 2, 428, 427, 3, 2, 2, 2, 429, 77,
	3, 2, 2, 2, 430, 431, 5, 160, 81, 2, 431, 432, 5, 84, 43, 2, 432, 79, 3,
	2, 2, 2, 433, 434, 5, 82, 42, 2, 434, 435, 5, 78, 40, 2, 435, 81, 3, 2,
	2, 2, 436, 437, 9, 6, 2, 2, 437, 83, 3, 2, 2, 2, 438, 439, 5, 86, 44, 2,
	439, 440, 7, 41, 2, 2, 440, 441, 5, 92, 47, 2, 441, 442, 7, 42, 2, 2, 442,
	443, 7, 30, 2, 2, 443, 85, 3, 2, 2, 2, 444, 447, 5, 88, 45, 2, 445, 447,
	3, 2, 2, 2, 446, 444, 3, 2, 2, 2, 446, 445, 3, 2, 2, 2, 447, 87, 3, 2,
	2, 2, 448, 451, 5, 90, 46, 2, 449, 451, 7, 86, 2, 2, 450, 448, 3, 2, 2,
	2, 450, 449, 3, 2, 2, 2, 451, 89, 3, 2, 2, 2, 452, 453, 7, 12, 2, 2, 453,
	91, 3, 2, 2, 2, 454, 455, 5, 96, 49, 2, 455, 456, 5, 94, 48, 2, 456, 459,
	3, 2, 2, 2, 457, 459, 3, 2, 2, 2, 458, 454, 3, 2, 2, 2, 458, 457, 3, 2,
	2, 2, 459, 93, 3, 2, 2, 2, 460, 461, 7, 43, 2, 2, 461, 462, 5, 96, 49,
	2, 462, 463, 5, 94, 48, 2, 463, 466, 3, 2, 2, 2, 464, 466, 3, 2, 2, 2,
	465, 460, 3, 2, 2, 2, 465, 464, 3, 2, 2, 2, 466, 95, 3, 2, 2, 2, 467, 468,
	5, 196, 99, 2, 468, 469, 5, 98, 50, 2, 469, 97, 3, 2, 2, 2, 470, 471, 7,
	44, 2, 2, 471, 472, 5, 162, 82, 2, 472, 473, 5, 100, 51, 2, 473, 474, 5,
	146, 74, 2, 474, 480, 3, 2, 2, 2, 475, 476, 5, 160, 81, 2, 476, 477, 5,
	102, 52, 2, 477, 478, 5, 100, 51, 2, 478, 480, 3, 2, 2, 2, 479, 470, 3,
	2, 2, 2, 479, 475, 3, 2, 2, 2, 480, 99, 3, 2, 2, 2, 481, 484, 5, 8, 5,
	2, 482, 484, 7, 86, 2, 2, 483, 481, 3, 2, 2, 2, 483, 482, 3, 2, 2, 2, 484,
	101, 3, 2, 2, 2, 485, 488, 7, 45, 2, 2, 486, 488, 3, 2, 2, 2, 487, 485,
	3, 2, 2, 2, 487, 486, 3, 2, 2, 2, 488, 103, 3, 2, 2, 2, 489, 490, 7, 7,
	2, 2, 490, 491, 7, 41, 2, 2, 491, 492, 5, 92, 47, 2, 492, 493, 7, 42, 2,
	2, 493, 494, 7, 30, 2, 2, 494, 105, 3, 2, 2, 2, 495, 496, 7, 25, 2, 2,
	496, 497, 5, 108, 55, 2, 497, 107, 3, 2, 2, 2, 498, 499, 5, 72, 37, 2,
	499, 500, 5, 66, 34, 2, 500, 504, 3, 2, 2, 2, 501, 504, 5, 78, 40, 2, 502,
	504, 7, 30, 2, 2, 503, 498, 3, 2, 2, 2, 503, 501, 3, 2, 2, 2, 503, 502,
	3, 2, 2, 2, 504, 109, 3, 2, 2, 2, 505, 506, 7, 24, 2, 2, 506, 507, 5, 112,
	57, 2, 507, 111, 3, 2, 2, 2, 508, 509, 5, 72, 37, 2, 509, 510, 5, 66, 34,
	2, 510, 513, 3, 2, 2, 2, 511, 513, 5, 78, 40, 2, 512, 508, 3, 2, 2, 2,
	512, 511, 3, 2, 2, 2, 513, 113, 3, 2, 2, 2, 514, 515, 7, 15, 2, 2, 515,
	516, 7, 46, 2, 2, 516, 517, 5, 162, 82, 2, 517, 518, 5, 116, 59, 2, 518,
	519, 7, 47, 2, 2, 519, 520, 7, 30, 2, 2, 520, 115, 3, 2, 2, 2, 521, 522,
	7, 43, 2, 2, 522, 525, 5, 162, 82, 2, 523, 525, 3, 2, 2, 2, 524, 521, 3,
	2, 2, 2, 524, 523, 3, 2, 2, 2, 525, 117, 3, 2, 2, 2, 526, 527, 7, 3, 2,
	2, 527, 528, 7, 15, 2, 2, 528, 529, 7, 46, 2, 2, 529, 530, 5, 162, 82,
	2, 530, 531, 5, 116, 59, 2, 531, 532, 7, 47, 2, 2, 532, 533, 5, 120, 61,
	2, 533, 534, 7, 30, 2, 2, 534, 119, 3, 2, 2, 2, 535, 536, 7, 41, 2, 2,
	536, 537, 5, 92, 47, 2, 537, 538, 7, 42, 2, 2, 538, 541, 3, 2, 2, 2, 539,
	541, 3, 2, 2, 2, 540, 535, 3, 2, 2, 2, 540, 539, 3, 2, 2, 2, 541, 121,
	3, 2, 2, 2, 542, 543, 5, 124, 63, 2, 543, 123, 3, 2, 2, 2, 544, 545, 7,
	16, 2, 2, 545, 546, 7, 46, 2, 2, 546, 547, 5, 162, 82, 2, 547, 548, 7,
	43, 2, 2, 548, 549, 5, 162, 82, 2, 549, 550, 7, 47, 2, 2, 550, 551, 7,
	30, 2, 2, 551, 125, 3, 2, 2, 2, 552, 553, 5, 128, 65, 2, 553, 127, 3, 2,
	2, 2, 554, 555, 7, 22, 2, 2, 555, 556, 7, 46, 2, 2, 556, 557, 5, 162, 82,
	2, 557, 558, 7, 47, 2, 2, 558, 559, 7, 30, 2, 2, 559, 129, 3, 2, 2, 2,
	560, 561, 7, 18, 2, 2, 561, 562, 7, 86, 2, 2, 562, 563, 7, 28, 2, 2, 563,
	564, 5, 132, 67, 2, 564, 565, 7, 29, 2, 2, 565, 566, 7, 30, 2, 2, 566,
	131, 3, 2, 2, 2, 567, 568, 5, 196, 99, 2, 568, 569, 5, 134, 68, 2, 569,
	570, 5, 132, 67, 2, 570, 573, 3, 2, 2, 2, 571, 573, 3, 2, 2, 2, 572, 567,
	3, 2, 2, 2, 572, 571, 3, 2, 2, 2, 573, 133, 3, 2, 2, 2, 574, 579, 5, 78,
	40, 2, 575, 576, 7, 20, 2, 2, 576, 579, 5, 66, 34, 2, 577, 579, 5, 48,
	25, 2, 578, 574, 3, 2, 2, 2, 578, 575, 3, 2, 2, 2, 578, 577, 3, 2, 2, 2,
	579, 135, 3, 2, 2, 2, 580, 581, 7, 9, 2, 2, 581, 582, 7, 86, 2, 2, 582,
	583, 5, 32, 17, 2, 583, 584, 7, 28, 2, 2, 584, 585, 5, 138, 70, 2, 585,
	586, 7, 29, 2, 2, 586, 587, 7, 30, 2, 2, 587, 137, 3, 2, 2, 2, 588, 589,
	5, 140, 71, 2, 589, 590, 5, 138, 70, 2, 590, 593, 3, 2, 2, 2, 591, 593,
	3, 2, 2, 2, 592, 588, 3, 2, 2, 2, 592, 591, 3, 2, 2, 2, 593, 139, 3, 2,
	2, 2, 594, 595, 5, 196, 99, 2, 595, 596, 5, 142, 72, 2, 596, 141, 3, 2,
	2, 2, 597, 598, 7, 21, 2, 2, 598, 599, 5, 162, 82, 2, 599, 600, 7, 86,
	2, 2, 600, 601, 7, 30, 2, 2, 601, 608, 3, 2, 2, 2, 602, 603, 5, 160, 81,
	2, 603, 604, 7, 86, 2, 2, 604, 605, 5, 146, 74, 2, 605, 606, 7, 30, 2,
	2, 606, 608, 3, 2, 2, 2, 607, 597, 3, 2, 2, 2, 607, 602, 3, 2, 2, 2, 608,
	143, 3, 2, 2, 2, 609, 610, 7, 9, 2, 2, 610, 611, 7, 86, 2, 2, 611, 612,
	7, 28, 2, 2, 612, 613, 5, 138, 70, 2, 613, 614, 7, 29, 2, 2, 614, 615,
	7, 30, 2, 2, 615, 145, 3, 2, 2, 2, 616, 617, 7, 32, 2, 2, 617, 620, 5,
	74, 38, 2, 618, 620, 3, 2, 2, 2, 619, 616, 3, 2, 2, 2, 619, 618, 3, 2,
	2, 2, 620, 147, 3, 2, 2, 2, 621, 622, 7, 10, 2, 2, 622, 623, 7, 86, 2,
	2, 623, 624, 7, 28, 2, 2, 624, 625, 5, 150, 76, 2, 625, 626, 7, 29, 2,
	2, 626, 627, 7, 30, 2, 2, 627, 149, 3, 2, 2, 2, 628, 629, 7, 87, 2, 2,
	629, 630, 5, 152, 77, 2, 630, 151, 3, 2, 2, 2, 631, 632, 7, 43, 2, 2, 632,
	635, 5, 154, 78, 2, 633, 635, 3, 2, 2, 2, 634, 631, 3, 2, 2, 2, 634, 633,
	3, 2, 2, 2, 635, 153, 3, 2, 2, 2, 636, 637, 7, 87, 2, 2, 637, 640, 5, 152,
	77, 2, 638, 640, 3, 2, 2, 2, 639, 636, 3, 2, 2, 2, 639, 638, 3, 2, 2, 2,
	640, 155, 3, 2, 2, 2, 641, 642, 7, 86, 2, 2, 642, 643, 7, 32, 2, 2, 643,
	644, 5, 160, 81, 2, 644, 645, 7, 41, 2, 2, 645, 646, 5, 92, 47, 2, 646,
	647, 7, 42, 2, 2, 647, 648, 7, 30, 2, 2, 648, 157, 3, 2, 2, 2, 649, 650,
	7, 26, 2, 2, 650, 651, 5, 162, 82, 2, 651, 652, 7, 86, 2, 2, 652, 653,
	7, 30, 2, 2, 653, 159, 3, 2, 2, 2, 654, 659, 5, 164, 83, 2, 655, 656, 5,
	166, 84, 2, 656, 657, 5, 192, 97, 2, 657, 659, 3, 2, 2, 2, 658, 654, 3,
	2, 2, 2, 658, 655, 3, 2, 2, 2, 659, 161, 3, 2, 2, 2, 660, 661, 5, 196,
	99, 2, 661, 662, 5, 160, 81, 2, 662, 163, 3, 2, 2, 2, 663, 667, 5, 172,
	87, 2, 664, 667, 7, 48, 2, 2, 665, 667, 5, 188, 95, 2, 666, 663, 3, 2,
	2, 2, 666, 664, 3, 2, 2, 2, 666, 665, 3, 2, 2, 2, 667, 165, 3, 2, 2, 2,
	668, 669, 7, 41, 2, 2, 669, 670, 5, 168, 85, 2, 670, 671, 7, 49, 2, 2,
	671, 672, 5, 168, 85, 2, 672, 673, 5, 170, 86, 2, 673, 674, 7, 42, 2, 2,
	674, 167, 3, 2, 2, 2, 675, 676, 5, 196, 99, 2, 676, 677, 5, 172, 87, 2,
	677, 682, 3, 2, 2, 2, 678, 679, 5, 166, 84, 2, 679, 680, 5, 192, 97, 2,
	680, 682, 3, 2, 2, 2, 681, 675, 3, 2, 2, 2, 681, 678, 3, 2, 2, 2, 682,
	169, 3, 2, 2, 2, 683, 684, 7, 49, 2, 2, 684, 685, 5, 168, 85, 2, 685, 686,
	5, 170, 86, 2, 686, 689, 3, 2, 2, 2, 687, 689, 3, 2, 2, 2, 688, 683, 3,
	2, 2, 2, 688, 687, 3, 2, 2, 2, 689, 171, 3, 2, 2, 2, 690, 691, 5, 174,
	88, 2, 691, 692, 5, 192, 97, 2, 692, 727, 3, 2, 2, 2, 693, 694, 5, 186,
	94, 2, 694, 695, 5, 192, 97, 2, 695, 727, 3, 2, 2, 2, 696, 697, 7, 86,
	2, 2, 697, 727, 5, 192, 97, 2, 698, 699, 7, 50, 2, 2, 699, 700, 7, 46,
	2, 2, 700, 701, 5, 162, 82, 2, 701, 702, 7, 47, 2, 2, 702, 703, 5, 192,
	97, 2, 703, 727, 3, 2, 2, 2, 704, 705, 7, 51, 2, 2, 705, 727, 5, 192, 97,
	2, 706, 707, 7, 52, 2, 2, 707, 727, 5, 192, 97, 2, 708, 709, 5, 194, 98,
	2, 709, 710, 5, 192, 97, 2, 710, 727, 3, 2, 2, 2, 711, 712, 7, 53, 2, 2,
	712, 713, 7, 46, 2, 2, 713, 714, 5, 162, 82, 2, 714, 715, 7, 47, 2, 2,
	715, 716, 5, 192, 97, 2, 716, 727, 3, 2, 2, 2, 717, 718, 7, 54, 2, 2, 718,
	719, 7, 46, 2, 2, 719, 720, 5, 162, 82, 2, 720, 721, 7, 47, 2, 2, 721,
	722, 5, 192, 97, 2, 722, 727, 3, 2, 2, 2, 723, 724, 5, 190, 96, 2, 724,
	725, 5, 192, 97, 2, 725, 727, 3, 2, 2, 2, 726, 690, 3, 2, 2, 2, 726, 693,
	3, 2, 2, 2, 726, 696, 3, 2, 2, 2, 726, 698, 3, 2, 2, 2, 726, 704, 3, 2,
	2, 2, 726, 706, 3, 2, 2, 2, 726, 708, 3, 2, 2, 2, 726, 711, 3, 2, 2, 2,
	726, 717, 3, 2, 2, 2, 726, 723, 3, 2, 2, 2, 727, 173, 3, 2, 2, 2, 728,
	736, 5, 180, 91, 2, 729, 736, 5, 176, 89, 2, 730, 736, 7, 55, 2, 2, 731,
	736, 7, 56, 2, 2, 732, 736, 7, 57, 2, 2, 733, 736, 7, 58, 2, 2, 734, 736,
	7, 59, 2, 2, 735, 728, 3, 2, 2, 2, 735, 729, 3, 2, 2, 2, 735, 730, 3, 2,
	2, 2, 735, 731, 3, 2, 2, 2, 735, 732, 3, 2, 2, 2, 735, 733, 3, 2, 2, 2,
	735, 734, 3, 2, 2, 2, 736, 175, 3, 2, 2, 2, 737, 738, 7, 27, 2, 2, 738,
	741, 5, 178, 90, 2, 739, 741, 5, 178, 90, 2, 740, 737, 3, 2, 2, 2, 740,
	739, 3, 2, 2, 2, 741, 177, 3, 2, 2, 2, 742, 743, 9, 7, 2, 2, 743, 179,
	3, 2, 2, 2, 744, 745, 7, 62, 2, 2, 745, 748, 5, 182, 92, 2, 746, 748, 5,
	182, 92, 2, 747, 744, 3, 2, 2, 2, 747, 746, 3, 2, 2, 2, 748, 181, 3, 2,
	2, 2, 749, 753, 7, 63, 2, 2, 750, 751, 7, 64, 2, 2, 751, 753, 5, 184, 93,
	2, 752, 749, 3, 2, 2, 2, 752, 750, 3, 2, 2, 2, 753, 183, 3, 2, 2, 2, 754,
	757, 7, 64, 2, 2, 755, 757, 3, 2, 2, 2, 756, 754, 3, 2, 2, 2, 756, 755,
	3, 2, 2, 2, 757, 185, 3, 2, 2, 2, 758, 759, 9, 8, 2, 2, 759, 187, 3, 2,
	2, 2, 760, 761, 7, 68, 2, 2, 761, 762, 7, 46, 2, 2, 762, 763, 5, 160, 81,
	2, 763, 764, 7, 47, 2, 2, 764, 189, 3, 2, 2, 2, 765, 766, 7, 69, 2, 2,
	766, 767, 7, 46, 2, 2, 767, 768, 5, 186, 94, 2, 768, 769, 7, 43, 2, 2,
	769, 770, 5, 162, 82, 2, 770, 771, 7, 47, 2, 2, 771, 191, 3, 2, 2, 2, 772,
	775, 7, 70, 2, 2, 773, 775, 3, 2, 2, 2, 774, 772, 3, 2, 2, 2, 774, 773,
	3, 2, 2, 2, 775, 193, 3, 2, 2, 2, 776, 777, 9, 9, 2, 2, 777, 195, 3, 2,
	2, 2, 778, 779, 7, 38, 2, 2, 779, 780, 5, 200, 101, 2, 780, 781, 5, 198,
	100, 2, 781, 782, 7, 39, 2, 2, 782, 785, 3, 2, 2, 2, 783, 785, 3, 2, 2,
	2, 784, 778, 3, 2, 2, 2, 784, 783, 3, 2, 2, 2, 785, 197, 3, 2, 2, 2, 786,
	787, 7, 43, 2, 2, 787, 788, 5, 200, 101, 2, 788, 789, 5, 198, 100, 2, 789,
	792, 3, 2, 2, 2, 790, 792, 3, 2, 2, 2, 791, 786, 3, 2, 2, 2, 791, 790,
	3, 2, 2, 2, 792, 199, 3, 2, 2, 2, 793, 801, 5, 210, 106, 2, 794, 801, 5,
	212, 107, 2, 795, 801, 5, 218, 110, 2, 796, 801, 5, 214, 108, 2, 797, 801,
	5, 216, 109, 2, 798, 801, 5, 220, 111, 2, 799, 801, 5, 222, 112, 2, 800,
	793, 3, 2, 2, 2, 800, 794, 3, 2, 2, 2, 800, 795, 3, 2, 2, 2, 800, 796,
	3, 2, 2, 2, 800, 797, 3, 2, 2, 2, 800, 798, 3, 2, 2, 2, 800, 799, 3, 2,
	2, 2, 801, 201, 3, 2, 2, 2, 802, 848, 7, 84, 2, 2, 803, 848, 7, 85, 2,
	2, 804, 848, 7, 86, 2, 2, 805, 848, 7, 87, 2, 2, 806, 848, 7, 90, 2, 2,
	807, 848, 7, 82, 2, 2, 808, 848, 7, 35, 2, 2, 809, 848, 7, 83, 2, 2, 810,
	848, 7, 45, 2, 2, 811, 848, 7, 31, 2, 2, 812, 848, 7, 30, 2, 2, 813, 848,
	7, 46, 2, 2, 814, 848, 7, 32, 2, 2, 815, 848, 7, 47, 2, 2, 816, 848, 7,
	70, 2, 2, 817, 848, 7, 65, 2, 2, 818, 848, 7, 66, 2, 2, 819, 848, 7, 53,
	2, 2, 820, 848, 7, 36, 2, 2, 821, 848, 7, 37, 2, 2, 822, 848, 7, 54, 2,
	2, 823, 848, 7, 68, 2, 2, 824, 848, 7, 67, 2, 2, 825, 848, 7, 48, 2, 2,
	826, 848, 7, 59, 2, 2, 827, 848, 7, 56, 2, 2, 828, 848, 7, 57, 2, 2, 829,
	848, 7, 61, 2, 2, 830, 848, 7, 34, 2, 2, 831, 848, 7, 60, 2, 2, 832, 848,
	7, 64, 2, 2, 833, 848, 7, 40, 2, 2, 834, 848, 7, 51, 2, 2, 835, 848, 7,
	58, 2, 2, 836, 848, 7, 49, 2, 2, 837, 848, 7, 44, 2, 2, 838, 848, 7, 69,
	2, 2, 839, 848, 7, 50, 2, 2, 840, 848, 7, 63, 2, 2, 841, 848, 7, 52, 2,
	2, 842, 848, 7, 33, 2, 2, 843, 848, 7, 62, 2, 2, 844, 848, 7, 55, 2, 2,
	845, 848, 5, 8, 5, 2, 846, 848, 5, 194, 98, 2, 847, 802, 3, 2, 2, 2, 847,
	803, 3, 2, 2, 2, 847, 804, 3, 2, 2, 2, 847, 805, 3, 2, 2, 2, 847, 806,
	3, 2, 2, 2, 847, 807, 3, 2, 2, 2, 847, 808, 3, 2, 2, 2, 847, 809, 3, 2,
	2, 2, 847, 810, 3, 2, 2, 2, 847, 811, 3, 2, 2, 2, 847, 812, 3, 2, 2, 2,
	847, 813, 3, 2, 2, 2, 847, 814, 3, 2, 2, 2, 847, 815, 3, 2, 2, 2, 847,
	816, 3, 2, 2, 2, 847, 817, 3, 2, 2, 2, 847, 818, 3, 2, 2, 2, 847, 819,
	3, 2, 2, 2, 847, 820, 3, 2, 2, 2, 847, 821, 3, 2, 2, 2, 847, 822, 3, 2,
	2, 2, 847, 823, 3, 2, 2, 2, 847, 824, 3, 2, 2, 2, 847, 825, 3, 2, 2, 2,
	847, 826, 3, 2, 2, 2, 847, 827, 3, 2, 2, 2, 847, 828, 3, 2, 2, 2, 847,
	829, 3, 2, 2, 2, 847, 830, 3, 2, 2, 2, 847, 831, 3, 2, 2, 2, 847, 832,
	3, 2, 2, 2, 847, 833, 3, 2, 2, 2, 847, 834, 3, 2, 2, 2, 847, 835, 3, 2,
	2, 2, 847, 836, 3, 2, 2, 2, 847, 837, 3, 2, 2, 2, 847, 838, 3, 2, 2, 2,
	847, 839, 3, 2, 2, 2, 847, 840, 3, 2, 2, 2, 847, 841, 3, 2, 2, 2, 847,
	842, 3, 2, 2, 2, 847, 843, 3, 2, 2, 2, 847, 844, 3, 2, 2, 2, 847, 845,
	3, 2, 2, 2, 847, 846, 3, 2, 2, 2, 848, 203, 3, 2, 2, 2, 849, 852, 5, 202,
	102, 2, 850, 852, 7, 43, 2, 2, 851, 849, 3, 2, 2, 2, 851, 850, 3, 2, 2,
	2, 852, 205, 3, 2, 2, 2, 853, 854, 7, 86, 2, 2, 854, 855, 5, 208, 105,
	2, 855, 207, 3, 2, 2, 2, 856, 857, 7, 43, 2, 2, 857, 858, 7, 86, 2, 2,
	858, 861, 5, 208, 105, 2, 859, 861, 3, 2, 2, 2, 860, 856, 3, 2, 2, 2, 860,
	859, 3, 2, 2, 2, 861, 209, 3, 2, 2, 2, 862, 863, 7, 86, 2, 2, 863, 211,
	3, 2, 2, 2, 864, 865, 7, 86, 2, 2, 865, 866, 7, 41, 2, 2, 866, 867, 5,
	92, 47, 2, 867, 868, 7, 42, 2, 2, 868, 213, 3, 2, 2, 2, 869, 870, 7, 86,
	2, 2, 870, 871, 7, 32, 2, 2, 871, 872, 7, 86, 2, 2, 872, 215, 3, 2, 2,
	2, 873, 874, 7, 86, 2, 2, 874, 875, 7, 32, 2, 2, 875, 876, 7, 41, 2, 2,
	876, 877, 5, 206, 104, 2, 877, 878, 7, 42, 2, 2, 878, 217, 3, 2, 2, 2,
	879, 880, 7, 86, 2, 2, 880, 881, 7, 32, 2, 2, 881, 882, 7, 86, 2, 2, 882,
	883, 7, 41, 2, 2, 883, 884, 5, 92, 47, 2, 884, 885, 7, 42, 2, 2, 885, 219,
	3, 2, 2, 2, 886, 887, 7, 86, 2, 2, 887, 888, 7, 32, 2, 2, 888, 889, 7,
	87, 2, 2, 889, 221, 3, 2, 2, 2, 890, 891, 7, 86, 2, 2, 891, 892, 7, 32,
	2, 2, 892, 893, 7, 41, 2, 2, 893, 894, 5, 224, 113, 2, 894, 895, 7, 42,
	2, 2, 895, 223, 3, 2, 2, 2, 896, 897, 7, 87, 2, 2, 897, 898, 5, 226, 114,
	2, 898, 225, 3, 2, 2, 2, 899, 900, 7, 43, 2, 2, 900, 901, 7, 87, 2, 2,
	901, 904, 5, 226, 114, 2, 902, 904, 3, 2, 2, 2, 903, 899, 3, 2, 2, 2, 903,
	902, 3, 2, 2, 2, 904, 227, 3, 2, 2, 2, 61, 236, 245, 253, 257, 273, 277,
	290, 294, 301, 314, 319, 333, 341, 356, 363, 367, 379, 387, 395, 409, 415,
	424, 428, 446, 450, 458, 465, 479, 483, 487, 503, 512, 524, 540, 572, 578,
	592, 607, 619, 634, 639, 658, 666, 681, 688, 726, 735, 740, 747, 752, 756,
	774, 784, 791, 800, 847, 851, 860, 903,
}
var literalNames = []string{
	"", "'async'", "'attribute'", "'callback'", "'const'", "'constructor'",
	"'deleter'", "'dictionary'", "'enum'", "'getter'", "'includes'", "'inherit'",
	"'interface'", "'iterable'", "'maplike'", "'mixin'", "'namespace'", "'partial'",
	"'readonly'", "'required'", "'setlike'", "'setter'", "'static'", "'stringifier'",
	"'typedef'", "'unrestricted'", "'{'", "'}'", "';'", "':'", "'='", "'true'",
	"'false'", "'-Infinity'", "'Infinity'", "'NaN'", "'['", "']'", "'null'",
	"'('", "')'", "','", "'optional'", "'...'", "'<'", "'>'", "'any'", "'or'",
	"'sequence'", "'object'", "'symbol'", "'FrozenArray'", "'ObservableArray'",
	"'undefined'", "'boolean'", "'byte'", "'octet'", "'bigint'", "'float'",
	"'double'", "'unsigned'", "'short'", "'long'", "'ByteString'", "'DOMString'",
	"'USVString'", "'Promise'", "'record'", "'?'", "'ArrayBuffer'", "'DataView'",
	"'Int8Array'", "'Int16Array'", "'Int32Array'", "'Uint8Array'", "'Uint16Array'",
	"'Uint32Array'", "'Uint8ClampedArray'", "'Float32Array'", "'Float64Array'",
	"'-'", "'.'",
}
var symbolicNames = []string{
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "INTEGER_WEBIDL", "DECIMAL_WEBIDL",
	"IDENTIFIER_WEBIDL", "STRING_WEBIDL", "WHITESPACE_WEBIDL", "COMMENT_WEBIDL",
	"OTHER_WEBIDL",
}

var ruleNames = []string{
	"webIDL", "definitions", "definition", "argumentNameKeyword", "callbackOrInterfaceOrMixin",
	"interfaceOrMixin", "interfaceRest", "partial", "partialDefinition", "partialInterfaceOrPartialMixin",
	"partialInterfaceRest", "interfaceMembers", "interfaceMember", "partialInterfaceMembers",
	"partialInterfaceMember", "inheritance", "mixinRest", "mixinMembers", "mixinMember",
	"includesStatement", "callbackRestOrInterface", "callbackInterfaceMembers",
	"callbackInterfaceMember", "const_", "constValue", "booleanLiteral", "floatLiteral",
	"constType", "readonlyMember", "readonlyMemberRest", "readWriteAttribute",
	"inheritAttribute", "attributeRest", "attributeName", "attributeNameKeyword",
	"optionalReadOnly", "defaultValue", "operation", "regularOperation", "specialOperation",
	"special", "operationRest", "optionalOperationName", "operationName", "operationNameKeyword",
	"argumentList", "arguments", "argument", "argumentRest", "argumentName",
	"ellipsis", "constructor", "stringifier", "stringifierRest", "staticMember",
	"staticMemberRest", "iterable", "optionalType", "asyncIterable", "optionalArgumentList",
	"readWriteMaplike", "maplikeRest", "readWriteSetlike", "setlikeRest", "namespace_",
	"namespaceMembers", "namespaceMember", "dictionary", "dictionaryMembers",
	"dictionaryMember", "dictionaryMemberRest", "partialDictionary", "default_",
	"enum_", "enumValueList", "enumValueListComma", "enumValueListString",
	"callbackRest", "typedef_", "type_", "typeWithExtendedAttributes", "singleType",
	"unionType", "unionMemberType", "unionMemberTypes", "distinguishableType",
	"primitiveType", "unrestrictedFloatType", "floatType", "unsignedIntegerType",
	"integerType", "optionalLong", "stringType", "promiseType", "recordType",
	"null_", "bufferRelatedType", "extendedAttributeList", "extendedAttributes",
	"extendedAttribute", "other", "otherOrComma", "identifierList", "identifiers",
	"extendedAttributeNoArgs", "extendedAttributeArgList", "extendedAttributeIdent",
	"extendedAttributeIdentList", "extendedAttributeNamedArgList", "extendedAttributeString",
	"extendedAttributeStringList", "stringList", "strings",
}

type WebIDLParser struct {
	*antlr.BaseParser
}

// NewWebIDLParser produces a new parser instance for the optional input antlr.TokenStream.
//
// The *WebIDLParser instance produced may be reused by calling the SetInputStream method.
// The initial parser configuration is expensive to construct, and the object is not thread-safe;
// however, if used within a Golang sync.Pool, the construction cost amortizes well and the
// objects can be used in a thread-safe manner.
func NewWebIDLParser(input antlr.TokenStream) *WebIDLParser {
	this := new(WebIDLParser)
	deserializer := antlr.NewATNDeserializer(nil)
	deserializedATN := deserializer.DeserializeFromUInt16(parserATN)
	decisionToDFA := make([]*antlr.DFA, len(deserializedATN.DecisionToState))
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "WebIDL.g4"

	return this
}

// WebIDLParser tokens.
const (
	WebIDLParserEOF               = antlr.TokenEOF
	WebIDLParserT__0              = 1
	WebIDLParserT__1              = 2
	WebIDLParserT__2              = 3
	WebIDLParserT__3              = 4
	WebIDLParserT__4              = 5
	WebIDLParserT__5              = 6
	WebIDLParserT__6              = 7
	WebIDLParserT__7              = 8
	WebIDLParserT__8              = 9
	WebIDLParserT__9              = 10
	WebIDLParserT__10             = 11
	WebIDLParserT__11             = 12
	WebIDLParserT__12             = 13
	WebIDLParserT__13             = 14
	WebIDLParserT__14             = 15
	WebIDLParserT__15             = 16
	WebIDLParserT__16             = 17
	WebIDLParserT__17             = 18
	WebIDLParserT__18             = 19
	WebIDLParserT__19             = 20
	WebIDLParserT__20             = 21
	WebIDLParserT__21             = 22
	WebIDLParserT__22             = 23
	WebIDLParserT__23             = 24
	WebIDLParserT__24             = 25
	WebIDLParserT__25             = 26
	WebIDLParserT__26             = 27
	WebIDLParserT__27             = 28
	WebIDLParserT__28             = 29
	WebIDLParserT__29             = 30
	WebIDLParserT__30             = 31
	WebIDLParserT__31             = 32
	WebIDLParserT__32             = 33
	WebIDLParserT__33             = 34
	WebIDLParserT__34             = 35
	WebIDLParserT__35             = 36
	WebIDLParserT__36             = 37
	WebIDLParserT__37             = 38
	WebIDLParserT__38             = 39
	WebIDLParserT__39             = 40
	WebIDLParserT__40             = 41
	WebIDLParserT__41             = 42
	WebIDLParserT__42             = 43
	WebIDLParserT__43             = 44
	WebIDLParserT__44             = 45
	WebIDLParserT__45             = 46
	WebIDLParserT__46             = 47
	WebIDLParserT__47             = 48
	WebIDLParserT__48             = 49
	WebIDLParserT__49             = 50
	WebIDLParserT__50             = 51
	WebIDLParserT__51             = 52
	WebIDLParserT__52             = 53
	WebIDLParserT__53             = 54
	WebIDLParserT__54             = 55
	WebIDLParserT__55             = 56
	WebIDLParserT__56             = 57
	WebIDLParserT__57             = 58
	WebIDLParserT__58             = 59
	WebIDLParserT__59             = 60
	WebIDLParserT__60             = 61
	WebIDLParserT__61             = 62
	WebIDLParserT__62             = 63
	WebIDLParserT__63             = 64
	WebIDLParserT__64             = 65
	WebIDLParserT__65             = 66
	WebIDLParserT__66             = 67
	WebIDLParserT__67             = 68
	WebIDLParserT__68             = 69
	WebIDLParserT__69             = 70
	WebIDLParserT__70             = 71
	WebIDLParserT__71             = 72
	WebIDLParserT__72             = 73
	WebIDLParserT__73             = 74
	WebIDLParserT__74             = 75
	WebIDLParserT__75             = 76
	WebIDLParserT__76             = 77
	WebIDLParserT__77             = 78
	WebIDLParserT__78             = 79
	WebIDLParserT__79             = 80
	WebIDLParserT__80             = 81
	WebIDLParserINTEGER_WEBIDL    = 82
	WebIDLParserDECIMAL_WEBIDL    = 83
	WebIDLParserIDENTIFIER_WEBIDL = 84
	WebIDLParserSTRING_WEBIDL     = 85
	WebIDLParserWHITESPACE_WEBIDL = 86
	WebIDLParserCOMMENT_WEBIDL    = 87
	WebIDLParserOTHER_WEBIDL      = 88
)

// WebIDLParser rules.
const (
	WebIDLParserRULE_webIDL                         = 0
	WebIDLParserRULE_definitions                    = 1
	WebIDLParserRULE_definition                     = 2
	WebIDLParserRULE_argumentNameKeyword            = 3
	WebIDLParserRULE_callbackOrInterfaceOrMixin     = 4
	WebIDLParserRULE_interfaceOrMixin               = 5
	WebIDLParserRULE_interfaceRest                  = 6
	WebIDLParserRULE_partial                        = 7
	WebIDLParserRULE_partialDefinition              = 8
	WebIDLParserRULE_partialInterfaceOrPartialMixin = 9
	WebIDLParserRULE_partialInterfaceRest           = 10
	WebIDLParserRULE_interfaceMembers               = 11
	WebIDLParserRULE_interfaceMember                = 12
	WebIDLParserRULE_partialInterfaceMembers        = 13
	WebIDLParserRULE_partialInterfaceMember         = 14
	WebIDLParserRULE_inheritance                    = 15
	WebIDLParserRULE_mixinRest                      = 16
	WebIDLParserRULE_mixinMembers                   = 17
	WebIDLParserRULE_mixinMember                    = 18
	WebIDLParserRULE_includesStatement              = 19
	WebIDLParserRULE_callbackRestOrInterface        = 20
	WebIDLParserRULE_callbackInterfaceMembers       = 21
	WebIDLParserRULE_callbackInterfaceMember        = 22
	WebIDLParserRULE_const_                         = 23
	WebIDLParserRULE_constValue                     = 24
	WebIDLParserRULE_booleanLiteral                 = 25
	WebIDLParserRULE_floatLiteral                   = 26
	WebIDLParserRULE_constType                      = 27
	WebIDLParserRULE_readonlyMember                 = 28
	WebIDLParserRULE_readonlyMemberRest             = 29
	WebIDLParserRULE_readWriteAttribute             = 30
	WebIDLParserRULE_inheritAttribute               = 31
	WebIDLParserRULE_attributeRest                  = 32
	WebIDLParserRULE_attributeName                  = 33
	WebIDLParserRULE_attributeNameKeyword           = 34
	WebIDLParserRULE_optionalReadOnly               = 35
	WebIDLParserRULE_defaultValue                   = 36
	WebIDLParserRULE_operation                      = 37
	WebIDLParserRULE_regularOperation               = 38
	WebIDLParserRULE_specialOperation               = 39
	WebIDLParserRULE_special                        = 40
	WebIDLParserRULE_operationRest                  = 41
	WebIDLParserRULE_optionalOperationName          = 42
	WebIDLParserRULE_operationName                  = 43
	WebIDLParserRULE_operationNameKeyword           = 44
	WebIDLParserRULE_argumentList                   = 45
	WebIDLParserRULE_arguments                      = 46
	WebIDLParserRULE_argument                       = 47
	WebIDLParserRULE_argumentRest                   = 48
	WebIDLParserRULE_argumentName                   = 49
	WebIDLParserRULE_ellipsis                       = 50
	WebIDLParserRULE_constructor                    = 51
	WebIDLParserRULE_stringifier                    = 52
	WebIDLParserRULE_stringifierRest                = 53
	WebIDLParserRULE_staticMember                   = 54
	WebIDLParserRULE_staticMemberRest               = 55
	WebIDLParserRULE_iterable                       = 56
	WebIDLParserRULE_optionalType                   = 57
	WebIDLParserRULE_asyncIterable                  = 58
	WebIDLParserRULE_optionalArgumentList           = 59
	WebIDLParserRULE_readWriteMaplike               = 60
	WebIDLParserRULE_maplikeRest                    = 61
	WebIDLParserRULE_readWriteSetlike               = 62
	WebIDLParserRULE_setlikeRest                    = 63
	WebIDLParserRULE_namespace_                     = 64
	WebIDLParserRULE_namespaceMembers               = 65
	WebIDLParserRULE_namespaceMember                = 66
	WebIDLParserRULE_dictionary                     = 67
	WebIDLParserRULE_dictionaryMembers              = 68
	WebIDLParserRULE_dictionaryMember               = 69
	WebIDLParserRULE_dictionaryMemberRest           = 70
	WebIDLParserRULE_partialDictionary              = 71
	WebIDLParserRULE_default_                       = 72
	WebIDLParserRULE_enum_                          = 73
	WebIDLParserRULE_enumValueList                  = 74
	WebIDLParserRULE_enumValueListComma             = 75
	WebIDLParserRULE_enumValueListString            = 76
	WebIDLParserRULE_callbackRest                   = 77
	WebIDLParserRULE_typedef_                       = 78
	WebIDLParserRULE_type_                          = 79
	WebIDLParserRULE_typeWithExtendedAttributes     = 80
	WebIDLParserRULE_singleType                     = 81
	WebIDLParserRULE_unionType                      = 82
	WebIDLParserRULE_unionMemberType                = 83
	WebIDLParserRULE_unionMemberTypes               = 84
	WebIDLParserRULE_distinguishableType            = 85
	WebIDLParserRULE_primitiveType                  = 86
	WebIDLParserRULE_unrestrictedFloatType          = 87
	WebIDLParserRULE_floatType                      = 88
	WebIDLParserRULE_unsignedIntegerType            = 89
	WebIDLParserRULE_integerType                    = 90
	WebIDLParserRULE_optionalLong                   = 91
	WebIDLParserRULE_stringType                     = 92
	WebIDLParserRULE_promiseType                    = 93
	WebIDLParserRULE_recordType                     = 94
	WebIDLParserRULE_null_                          = 95
	WebIDLParserRULE_bufferRelatedType              = 96
	WebIDLParserRULE_extendedAttributeList          = 97
	WebIDLParserRULE_extendedAttributes             = 98
	WebIDLParserRULE_extendedAttribute              = 99
	WebIDLParserRULE_other                          = 100
	WebIDLParserRULE_otherOrComma                   = 101
	WebIDLParserRULE_identifierList                 = 102
	WebIDLParserRULE_identifiers                    = 103
	WebIDLParserRULE_extendedAttributeNoArgs        = 104
	WebIDLParserRULE_extendedAttributeArgList       = 105
	WebIDLParserRULE_extendedAttributeIdent         = 106
	WebIDLParserRULE_extendedAttributeIdentList     = 107
	WebIDLParserRULE_extendedAttributeNamedArgList  = 108
	WebIDLParserRULE_extendedAttributeString        = 109
	WebIDLParserRULE_extendedAttributeStringList    = 110
	WebIDLParserRULE_stringList                     = 111
	WebIDLParserRULE_strings                        = 112
)

// IWebIDLContext is an interface to support dynamic dispatch.
type IWebIDLContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWebIDLContext differentiates from other interfaces.
	IsWebIDLContext()
}

type WebIDLContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWebIDLContext() *WebIDLContext {
	var p = new(WebIDLContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_webIDL
	return p
}

func (*WebIDLContext) IsWebIDLContext() {}

func NewWebIDLContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WebIDLContext {
	var p = new(WebIDLContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_webIDL

	return p
}

func (s *WebIDLContext) GetParser() antlr.Parser { return s.parser }

func (s *WebIDLContext) Definitions() IDefinitionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefinitionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefinitionsContext)
}

func (s *WebIDLContext) EOF() antlr.TerminalNode {
	return s.GetToken(WebIDLParserEOF, 0)
}

func (s *WebIDLContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WebIDLContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WebIDLContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterWebIDL(s)
	}
}

func (s *WebIDLContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitWebIDL(s)
	}
}

func (p *WebIDLParser) WebIDL() (localctx IWebIDLContext) {
	this := p
	_ = this

	localctx = NewWebIDLContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, WebIDLParserRULE_webIDL)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(226)
		p.Definitions()
	}
	{
		p.SetState(227)
		p.Match(WebIDLParserEOF)
	}

	return localctx
}

// IDefinitionsContext is an interface to support dynamic dispatch.
type IDefinitionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDefinitionsContext differentiates from other interfaces.
	IsDefinitionsContext()
}

type DefinitionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefinitionsContext() *DefinitionsContext {
	var p = new(DefinitionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_definitions
	return p
}

func (*DefinitionsContext) IsDefinitionsContext() {}

func NewDefinitionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefinitionsContext {
	var p = new(DefinitionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_definitions

	return p
}

func (s *DefinitionsContext) GetParser() antlr.Parser { return s.parser }

func (s *DefinitionsContext) ExtendedAttributeList() IExtendedAttributeListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtendedAttributeListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtendedAttributeListContext)
}

func (s *DefinitionsContext) Definition() IDefinitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefinitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefinitionContext)
}

func (s *DefinitionsContext) Definitions() IDefinitionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefinitionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefinitionsContext)
}

func (s *DefinitionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefinitionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefinitionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterDefinitions(s)
	}
}

func (s *DefinitionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitDefinitions(s)
	}
}

func (p *WebIDLParser) Definitions() (localctx IDefinitionsContext) {
	this := p
	_ = this

	localctx = NewDefinitionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, WebIDLParserRULE_definitions)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(234)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__2, WebIDLParserT__6, WebIDLParserT__7, WebIDLParserT__11, WebIDLParserT__15, WebIDLParserT__16, WebIDLParserT__23, WebIDLParserT__35, WebIDLParserIDENTIFIER_WEBIDL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(229)
			p.ExtendedAttributeList()
		}
		{
			p.SetState(230)
			p.Definition()
		}
		{
			p.SetState(231)
			p.Definitions()
		}

	case WebIDLParserEOF:
		p.EnterOuterAlt(localctx, 2)

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDefinitionContext is an interface to support dynamic dispatch.
type IDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDefinitionContext differentiates from other interfaces.
	IsDefinitionContext()
}

type DefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefinitionContext() *DefinitionContext {
	var p = new(DefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_definition
	return p
}

func (*DefinitionContext) IsDefinitionContext() {}

func NewDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefinitionContext {
	var p = new(DefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_definition

	return p
}

func (s *DefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *DefinitionContext) CallbackOrInterfaceOrMixin() ICallbackOrInterfaceOrMixinContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICallbackOrInterfaceOrMixinContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICallbackOrInterfaceOrMixinContext)
}

func (s *DefinitionContext) Namespace_() INamespace_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamespace_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INamespace_Context)
}

func (s *DefinitionContext) Partial() IPartialContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPartialContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPartialContext)
}

func (s *DefinitionContext) Dictionary() IDictionaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDictionaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDictionaryContext)
}

func (s *DefinitionContext) Enum_() IEnum_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnum_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnum_Context)
}

func (s *DefinitionContext) Typedef_() ITypedef_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypedef_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypedef_Context)
}

func (s *DefinitionContext) IncludesStatement() IIncludesStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIncludesStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIncludesStatementContext)
}

func (s *DefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterDefinition(s)
	}
}

func (s *DefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitDefinition(s)
	}
}

func (p *WebIDLParser) Definition() (localctx IDefinitionContext) {
	this := p
	_ = this

	localctx = NewDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, WebIDLParserRULE_definition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(243)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__2, WebIDLParserT__11:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(236)
			p.CallbackOrInterfaceOrMixin()
		}

	case WebIDLParserT__15:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(237)
			p.Namespace_()
		}

	case WebIDLParserT__16:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(238)
			p.Partial()
		}

	case WebIDLParserT__6:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(239)
			p.Dictionary()
		}

	case WebIDLParserT__7:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(240)
			p.Enum_()
		}

	case WebIDLParserT__23:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(241)
			p.Typedef_()
		}

	case WebIDLParserIDENTIFIER_WEBIDL:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(242)
			p.IncludesStatement()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IArgumentNameKeywordContext is an interface to support dynamic dispatch.
type IArgumentNameKeywordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArgumentNameKeywordContext differentiates from other interfaces.
	IsArgumentNameKeywordContext()
}

type ArgumentNameKeywordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentNameKeywordContext() *ArgumentNameKeywordContext {
	var p = new(ArgumentNameKeywordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_argumentNameKeyword
	return p
}

func (*ArgumentNameKeywordContext) IsArgumentNameKeywordContext() {}

func NewArgumentNameKeywordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentNameKeywordContext {
	var p = new(ArgumentNameKeywordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_argumentNameKeyword

	return p
}

func (s *ArgumentNameKeywordContext) GetParser() antlr.Parser { return s.parser }
func (s *ArgumentNameKeywordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentNameKeywordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentNameKeywordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterArgumentNameKeyword(s)
	}
}

func (s *ArgumentNameKeywordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitArgumentNameKeyword(s)
	}
}

func (p *WebIDLParser) ArgumentNameKeyword() (localctx IArgumentNameKeywordContext) {
	this := p
	_ = this

	localctx = NewArgumentNameKeywordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, WebIDLParserRULE_argumentNameKeyword)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(245)
		_la = p.GetTokenStream().LA(1)

		if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<WebIDLParserT__0)|(1<<WebIDLParserT__1)|(1<<WebIDLParserT__2)|(1<<WebIDLParserT__3)|(1<<WebIDLParserT__4)|(1<<WebIDLParserT__5)|(1<<WebIDLParserT__6)|(1<<WebIDLParserT__7)|(1<<WebIDLParserT__8)|(1<<WebIDLParserT__9)|(1<<WebIDLParserT__10)|(1<<WebIDLParserT__11)|(1<<WebIDLParserT__12)|(1<<WebIDLParserT__13)|(1<<WebIDLParserT__14)|(1<<WebIDLParserT__15)|(1<<WebIDLParserT__16)|(1<<WebIDLParserT__17)|(1<<WebIDLParserT__18)|(1<<WebIDLParserT__19)|(1<<WebIDLParserT__20)|(1<<WebIDLParserT__21)|(1<<WebIDLParserT__22)|(1<<WebIDLParserT__23)|(1<<WebIDLParserT__24))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ICallbackOrInterfaceOrMixinContext is an interface to support dynamic dispatch.
type ICallbackOrInterfaceOrMixinContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCallbackOrInterfaceOrMixinContext differentiates from other interfaces.
	IsCallbackOrInterfaceOrMixinContext()
}

type CallbackOrInterfaceOrMixinContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallbackOrInterfaceOrMixinContext() *CallbackOrInterfaceOrMixinContext {
	var p = new(CallbackOrInterfaceOrMixinContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_callbackOrInterfaceOrMixin
	return p
}

func (*CallbackOrInterfaceOrMixinContext) IsCallbackOrInterfaceOrMixinContext() {}

func NewCallbackOrInterfaceOrMixinContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallbackOrInterfaceOrMixinContext {
	var p = new(CallbackOrInterfaceOrMixinContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_callbackOrInterfaceOrMixin

	return p
}

func (s *CallbackOrInterfaceOrMixinContext) GetParser() antlr.Parser { return s.parser }

func (s *CallbackOrInterfaceOrMixinContext) CallbackRestOrInterface() ICallbackRestOrInterfaceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICallbackRestOrInterfaceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICallbackRestOrInterfaceContext)
}

func (s *CallbackOrInterfaceOrMixinContext) InterfaceOrMixin() IInterfaceOrMixinContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterfaceOrMixinContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterfaceOrMixinContext)
}

func (s *CallbackOrInterfaceOrMixinContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallbackOrInterfaceOrMixinContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallbackOrInterfaceOrMixinContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterCallbackOrInterfaceOrMixin(s)
	}
}

func (s *CallbackOrInterfaceOrMixinContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitCallbackOrInterfaceOrMixin(s)
	}
}

func (p *WebIDLParser) CallbackOrInterfaceOrMixin() (localctx ICallbackOrInterfaceOrMixinContext) {
	this := p
	_ = this

	localctx = NewCallbackOrInterfaceOrMixinContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, WebIDLParserRULE_callbackOrInterfaceOrMixin)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(251)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__2:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(247)
			p.Match(WebIDLParserT__2)
		}
		{
			p.SetState(248)
			p.CallbackRestOrInterface()
		}

	case WebIDLParserT__11:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(249)
			p.Match(WebIDLParserT__11)
		}
		{
			p.SetState(250)
			p.InterfaceOrMixin()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IInterfaceOrMixinContext is an interface to support dynamic dispatch.
type IInterfaceOrMixinContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterfaceOrMixinContext differentiates from other interfaces.
	IsInterfaceOrMixinContext()
}

type InterfaceOrMixinContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceOrMixinContext() *InterfaceOrMixinContext {
	var p = new(InterfaceOrMixinContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_interfaceOrMixin
	return p
}

func (*InterfaceOrMixinContext) IsInterfaceOrMixinContext() {}

func NewInterfaceOrMixinContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceOrMixinContext {
	var p = new(InterfaceOrMixinContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_interfaceOrMixin

	return p
}

func (s *InterfaceOrMixinContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceOrMixinContext) InterfaceRest() IInterfaceRestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterfaceRestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterfaceRestContext)
}

func (s *InterfaceOrMixinContext) MixinRest() IMixinRestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMixinRestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMixinRestContext)
}

func (s *InterfaceOrMixinContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceOrMixinContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceOrMixinContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterInterfaceOrMixin(s)
	}
}

func (s *InterfaceOrMixinContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitInterfaceOrMixin(s)
	}
}

func (p *WebIDLParser) InterfaceOrMixin() (localctx IInterfaceOrMixinContext) {
	this := p
	_ = this

	localctx = NewInterfaceOrMixinContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, WebIDLParserRULE_interfaceOrMixin)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(255)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserIDENTIFIER_WEBIDL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(253)
			p.InterfaceRest()
		}

	case WebIDLParserT__14:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(254)
			p.MixinRest()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IInterfaceRestContext is an interface to support dynamic dispatch.
type IInterfaceRestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterfaceRestContext differentiates from other interfaces.
	IsInterfaceRestContext()
}

type InterfaceRestContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceRestContext() *InterfaceRestContext {
	var p = new(InterfaceRestContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_interfaceRest
	return p
}

func (*InterfaceRestContext) IsInterfaceRestContext() {}

func NewInterfaceRestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceRestContext {
	var p = new(InterfaceRestContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_interfaceRest

	return p
}

func (s *InterfaceRestContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceRestContext) IDENTIFIER_WEBIDL() antlr.TerminalNode {
	return s.GetToken(WebIDLParserIDENTIFIER_WEBIDL, 0)
}

func (s *InterfaceRestContext) Inheritance() IInheritanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInheritanceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInheritanceContext)
}

func (s *InterfaceRestContext) InterfaceMembers() IInterfaceMembersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterfaceMembersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterfaceMembersContext)
}

func (s *InterfaceRestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceRestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceRestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterInterfaceRest(s)
	}
}

func (s *InterfaceRestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitInterfaceRest(s)
	}
}

func (p *WebIDLParser) InterfaceRest() (localctx IInterfaceRestContext) {
	this := p
	_ = this

	localctx = NewInterfaceRestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, WebIDLParserRULE_interfaceRest)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(257)
		p.Match(WebIDLParserIDENTIFIER_WEBIDL)
	}
	{
		p.SetState(258)
		p.Inheritance()
	}
	{
		p.SetState(259)
		p.Match(WebIDLParserT__25)
	}
	{
		p.SetState(260)
		p.InterfaceMembers()
	}
	{
		p.SetState(261)
		p.Match(WebIDLParserT__26)
	}
	{
		p.SetState(262)
		p.Match(WebIDLParserT__27)
	}

	return localctx
}

// IPartialContext is an interface to support dynamic dispatch.
type IPartialContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPartialContext differentiates from other interfaces.
	IsPartialContext()
}

type PartialContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartialContext() *PartialContext {
	var p = new(PartialContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_partial
	return p
}

func (*PartialContext) IsPartialContext() {}

func NewPartialContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartialContext {
	var p = new(PartialContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_partial

	return p
}

func (s *PartialContext) GetParser() antlr.Parser { return s.parser }

func (s *PartialContext) PartialDefinition() IPartialDefinitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPartialDefinitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPartialDefinitionContext)
}

func (s *PartialContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartialContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartialContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterPartial(s)
	}
}

func (s *PartialContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitPartial(s)
	}
}

func (p *WebIDLParser) Partial() (localctx IPartialContext) {
	this := p
	_ = this

	localctx = NewPartialContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, WebIDLParserRULE_partial)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(264)
		p.Match(WebIDLParserT__16)
	}
	{
		p.SetState(265)
		p.PartialDefinition()
	}

	return localctx
}

// IPartialDefinitionContext is an interface to support dynamic dispatch.
type IPartialDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPartialDefinitionContext differentiates from other interfaces.
	IsPartialDefinitionContext()
}

type PartialDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartialDefinitionContext() *PartialDefinitionContext {
	var p = new(PartialDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_partialDefinition
	return p
}

func (*PartialDefinitionContext) IsPartialDefinitionContext() {}

func NewPartialDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartialDefinitionContext {
	var p = new(PartialDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_partialDefinition

	return p
}

func (s *PartialDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *PartialDefinitionContext) PartialInterfaceOrPartialMixin() IPartialInterfaceOrPartialMixinContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPartialInterfaceOrPartialMixinContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPartialInterfaceOrPartialMixinContext)
}

func (s *PartialDefinitionContext) PartialDictionary() IPartialDictionaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPartialDictionaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPartialDictionaryContext)
}

func (s *PartialDefinitionContext) Namespace_() INamespace_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamespace_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INamespace_Context)
}

func (s *PartialDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartialDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartialDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterPartialDefinition(s)
	}
}

func (s *PartialDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitPartialDefinition(s)
	}
}

func (p *WebIDLParser) PartialDefinition() (localctx IPartialDefinitionContext) {
	this := p
	_ = this

	localctx = NewPartialDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, WebIDLParserRULE_partialDefinition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(271)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__11:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(267)
			p.Match(WebIDLParserT__11)
		}
		{
			p.SetState(268)
			p.PartialInterfaceOrPartialMixin()
		}

	case WebIDLParserT__6:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(269)
			p.PartialDictionary()
		}

	case WebIDLParserT__15:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(270)
			p.Namespace_()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPartialInterfaceOrPartialMixinContext is an interface to support dynamic dispatch.
type IPartialInterfaceOrPartialMixinContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPartialInterfaceOrPartialMixinContext differentiates from other interfaces.
	IsPartialInterfaceOrPartialMixinContext()
}

type PartialInterfaceOrPartialMixinContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartialInterfaceOrPartialMixinContext() *PartialInterfaceOrPartialMixinContext {
	var p = new(PartialInterfaceOrPartialMixinContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_partialInterfaceOrPartialMixin
	return p
}

func (*PartialInterfaceOrPartialMixinContext) IsPartialInterfaceOrPartialMixinContext() {}

func NewPartialInterfaceOrPartialMixinContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartialInterfaceOrPartialMixinContext {
	var p = new(PartialInterfaceOrPartialMixinContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_partialInterfaceOrPartialMixin

	return p
}

func (s *PartialInterfaceOrPartialMixinContext) GetParser() antlr.Parser { return s.parser }

func (s *PartialInterfaceOrPartialMixinContext) PartialInterfaceRest() IPartialInterfaceRestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPartialInterfaceRestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPartialInterfaceRestContext)
}

func (s *PartialInterfaceOrPartialMixinContext) MixinRest() IMixinRestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMixinRestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMixinRestContext)
}

func (s *PartialInterfaceOrPartialMixinContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartialInterfaceOrPartialMixinContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartialInterfaceOrPartialMixinContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterPartialInterfaceOrPartialMixin(s)
	}
}

func (s *PartialInterfaceOrPartialMixinContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitPartialInterfaceOrPartialMixin(s)
	}
}

func (p *WebIDLParser) PartialInterfaceOrPartialMixin() (localctx IPartialInterfaceOrPartialMixinContext) {
	this := p
	_ = this

	localctx = NewPartialInterfaceOrPartialMixinContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, WebIDLParserRULE_partialInterfaceOrPartialMixin)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(275)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserIDENTIFIER_WEBIDL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(273)
			p.PartialInterfaceRest()
		}

	case WebIDLParserT__14:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(274)
			p.MixinRest()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPartialInterfaceRestContext is an interface to support dynamic dispatch.
type IPartialInterfaceRestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPartialInterfaceRestContext differentiates from other interfaces.
	IsPartialInterfaceRestContext()
}

type PartialInterfaceRestContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartialInterfaceRestContext() *PartialInterfaceRestContext {
	var p = new(PartialInterfaceRestContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_partialInterfaceRest
	return p
}

func (*PartialInterfaceRestContext) IsPartialInterfaceRestContext() {}

func NewPartialInterfaceRestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartialInterfaceRestContext {
	var p = new(PartialInterfaceRestContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_partialInterfaceRest

	return p
}

func (s *PartialInterfaceRestContext) GetParser() antlr.Parser { return s.parser }

func (s *PartialInterfaceRestContext) IDENTIFIER_WEBIDL() antlr.TerminalNode {
	return s.GetToken(WebIDLParserIDENTIFIER_WEBIDL, 0)
}

func (s *PartialInterfaceRestContext) PartialInterfaceMembers() IPartialInterfaceMembersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPartialInterfaceMembersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPartialInterfaceMembersContext)
}

func (s *PartialInterfaceRestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartialInterfaceRestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartialInterfaceRestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterPartialInterfaceRest(s)
	}
}

func (s *PartialInterfaceRestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitPartialInterfaceRest(s)
	}
}

func (p *WebIDLParser) PartialInterfaceRest() (localctx IPartialInterfaceRestContext) {
	this := p
	_ = this

	localctx = NewPartialInterfaceRestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, WebIDLParserRULE_partialInterfaceRest)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(277)
		p.Match(WebIDLParserIDENTIFIER_WEBIDL)
	}
	{
		p.SetState(278)
		p.Match(WebIDLParserT__25)
	}
	{
		p.SetState(279)
		p.PartialInterfaceMembers()
	}
	{
		p.SetState(280)
		p.Match(WebIDLParserT__26)
	}
	{
		p.SetState(281)
		p.Match(WebIDLParserT__27)
	}

	return localctx
}

// IInterfaceMembersContext is an interface to support dynamic dispatch.
type IInterfaceMembersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterfaceMembersContext differentiates from other interfaces.
	IsInterfaceMembersContext()
}

type InterfaceMembersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceMembersContext() *InterfaceMembersContext {
	var p = new(InterfaceMembersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_interfaceMembers
	return p
}

func (*InterfaceMembersContext) IsInterfaceMembersContext() {}

func NewInterfaceMembersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceMembersContext {
	var p = new(InterfaceMembersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_interfaceMembers

	return p
}

func (s *InterfaceMembersContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceMembersContext) ExtendedAttributeList() IExtendedAttributeListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtendedAttributeListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtendedAttributeListContext)
}

func (s *InterfaceMembersContext) InterfaceMember() IInterfaceMemberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterfaceMemberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterfaceMemberContext)
}

func (s *InterfaceMembersContext) InterfaceMembers() IInterfaceMembersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterfaceMembersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterfaceMembersContext)
}

func (s *InterfaceMembersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceMembersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceMembersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterInterfaceMembers(s)
	}
}

func (s *InterfaceMembersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitInterfaceMembers(s)
	}
}

func (p *WebIDLParser) InterfaceMembers() (localctx IInterfaceMembersContext) {
	this := p
	_ = this

	localctx = NewInterfaceMembersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, WebIDLParserRULE_interfaceMembers)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(288)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__0, WebIDLParserT__1, WebIDLParserT__3, WebIDLParserT__4, WebIDLParserT__5, WebIDLParserT__8, WebIDLParserT__10, WebIDLParserT__12, WebIDLParserT__13, WebIDLParserT__17, WebIDLParserT__19, WebIDLParserT__20, WebIDLParserT__21, WebIDLParserT__22, WebIDLParserT__24, WebIDLParserT__35, WebIDLParserT__38, WebIDLParserT__45, WebIDLParserT__47, WebIDLParserT__48, WebIDLParserT__49, WebIDLParserT__50, WebIDLParserT__51, WebIDLParserT__52, WebIDLParserT__53, WebIDLParserT__54, WebIDLParserT__55, WebIDLParserT__56, WebIDLParserT__57, WebIDLParserT__58, WebIDLParserT__59, WebIDLParserT__60, WebIDLParserT__61, WebIDLParserT__62, WebIDLParserT__63, WebIDLParserT__64, WebIDLParserT__65, WebIDLParserT__66, WebIDLParserT__68, WebIDLParserT__69, WebIDLParserT__70, WebIDLParserT__71, WebIDLParserT__72, WebIDLParserT__73, WebIDLParserT__74, WebIDLParserT__75, WebIDLParserT__76, WebIDLParserT__77, WebIDLParserT__78, WebIDLParserIDENTIFIER_WEBIDL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(283)
			p.ExtendedAttributeList()
		}
		{
			p.SetState(284)
			p.InterfaceMember()
		}
		{
			p.SetState(285)
			p.InterfaceMembers()
		}

	case WebIDLParserT__26:
		p.EnterOuterAlt(localctx, 2)

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IInterfaceMemberContext is an interface to support dynamic dispatch.
type IInterfaceMemberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterfaceMemberContext differentiates from other interfaces.
	IsInterfaceMemberContext()
}

type InterfaceMemberContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceMemberContext() *InterfaceMemberContext {
	var p = new(InterfaceMemberContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_interfaceMember
	return p
}

func (*InterfaceMemberContext) IsInterfaceMemberContext() {}

func NewInterfaceMemberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceMemberContext {
	var p = new(InterfaceMemberContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_interfaceMember

	return p
}

func (s *InterfaceMemberContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceMemberContext) PartialInterfaceMember() IPartialInterfaceMemberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPartialInterfaceMemberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPartialInterfaceMemberContext)
}

func (s *InterfaceMemberContext) Constructor() IConstructorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstructorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstructorContext)
}

func (s *InterfaceMemberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceMemberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceMemberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterInterfaceMember(s)
	}
}

func (s *InterfaceMemberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitInterfaceMember(s)
	}
}

func (p *WebIDLParser) InterfaceMember() (localctx IInterfaceMemberContext) {
	this := p
	_ = this

	localctx = NewInterfaceMemberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, WebIDLParserRULE_interfaceMember)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(292)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__0, WebIDLParserT__1, WebIDLParserT__3, WebIDLParserT__5, WebIDLParserT__8, WebIDLParserT__10, WebIDLParserT__12, WebIDLParserT__13, WebIDLParserT__17, WebIDLParserT__19, WebIDLParserT__20, WebIDLParserT__21, WebIDLParserT__22, WebIDLParserT__24, WebIDLParserT__38, WebIDLParserT__45, WebIDLParserT__47, WebIDLParserT__48, WebIDLParserT__49, WebIDLParserT__50, WebIDLParserT__51, WebIDLParserT__52, WebIDLParserT__53, WebIDLParserT__54, WebIDLParserT__55, WebIDLParserT__56, WebIDLParserT__57, WebIDLParserT__58, WebIDLParserT__59, WebIDLParserT__60, WebIDLParserT__61, WebIDLParserT__62, WebIDLParserT__63, WebIDLParserT__64, WebIDLParserT__65, WebIDLParserT__66, WebIDLParserT__68, WebIDLParserT__69, WebIDLParserT__70, WebIDLParserT__71, WebIDLParserT__72, WebIDLParserT__73, WebIDLParserT__74, WebIDLParserT__75, WebIDLParserT__76, WebIDLParserT__77, WebIDLParserT__78, WebIDLParserIDENTIFIER_WEBIDL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(290)
			p.PartialInterfaceMember()
		}

	case WebIDLParserT__4:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(291)
			p.Constructor()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPartialInterfaceMembersContext is an interface to support dynamic dispatch.
type IPartialInterfaceMembersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPartialInterfaceMembersContext differentiates from other interfaces.
	IsPartialInterfaceMembersContext()
}

type PartialInterfaceMembersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartialInterfaceMembersContext() *PartialInterfaceMembersContext {
	var p = new(PartialInterfaceMembersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_partialInterfaceMembers
	return p
}

func (*PartialInterfaceMembersContext) IsPartialInterfaceMembersContext() {}

func NewPartialInterfaceMembersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartialInterfaceMembersContext {
	var p = new(PartialInterfaceMembersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_partialInterfaceMembers

	return p
}

func (s *PartialInterfaceMembersContext) GetParser() antlr.Parser { return s.parser }

func (s *PartialInterfaceMembersContext) ExtendedAttributeList() IExtendedAttributeListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtendedAttributeListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtendedAttributeListContext)
}

func (s *PartialInterfaceMembersContext) PartialInterfaceMember() IPartialInterfaceMemberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPartialInterfaceMemberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPartialInterfaceMemberContext)
}

func (s *PartialInterfaceMembersContext) PartialInterfaceMembers() IPartialInterfaceMembersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPartialInterfaceMembersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPartialInterfaceMembersContext)
}

func (s *PartialInterfaceMembersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartialInterfaceMembersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartialInterfaceMembersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterPartialInterfaceMembers(s)
	}
}

func (s *PartialInterfaceMembersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitPartialInterfaceMembers(s)
	}
}

func (p *WebIDLParser) PartialInterfaceMembers() (localctx IPartialInterfaceMembersContext) {
	this := p
	_ = this

	localctx = NewPartialInterfaceMembersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, WebIDLParserRULE_partialInterfaceMembers)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(299)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__0, WebIDLParserT__1, WebIDLParserT__3, WebIDLParserT__5, WebIDLParserT__8, WebIDLParserT__10, WebIDLParserT__12, WebIDLParserT__13, WebIDLParserT__17, WebIDLParserT__19, WebIDLParserT__20, WebIDLParserT__21, WebIDLParserT__22, WebIDLParserT__24, WebIDLParserT__35, WebIDLParserT__38, WebIDLParserT__45, WebIDLParserT__47, WebIDLParserT__48, WebIDLParserT__49, WebIDLParserT__50, WebIDLParserT__51, WebIDLParserT__52, WebIDLParserT__53, WebIDLParserT__54, WebIDLParserT__55, WebIDLParserT__56, WebIDLParserT__57, WebIDLParserT__58, WebIDLParserT__59, WebIDLParserT__60, WebIDLParserT__61, WebIDLParserT__62, WebIDLParserT__63, WebIDLParserT__64, WebIDLParserT__65, WebIDLParserT__66, WebIDLParserT__68, WebIDLParserT__69, WebIDLParserT__70, WebIDLParserT__71, WebIDLParserT__72, WebIDLParserT__73, WebIDLParserT__74, WebIDLParserT__75, WebIDLParserT__76, WebIDLParserT__77, WebIDLParserT__78, WebIDLParserIDENTIFIER_WEBIDL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(294)
			p.ExtendedAttributeList()
		}
		{
			p.SetState(295)
			p.PartialInterfaceMember()
		}
		{
			p.SetState(296)
			p.PartialInterfaceMembers()
		}

	case WebIDLParserT__26:
		p.EnterOuterAlt(localctx, 2)

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPartialInterfaceMemberContext is an interface to support dynamic dispatch.
type IPartialInterfaceMemberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPartialInterfaceMemberContext differentiates from other interfaces.
	IsPartialInterfaceMemberContext()
}

type PartialInterfaceMemberContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartialInterfaceMemberContext() *PartialInterfaceMemberContext {
	var p = new(PartialInterfaceMemberContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_partialInterfaceMember
	return p
}

func (*PartialInterfaceMemberContext) IsPartialInterfaceMemberContext() {}

func NewPartialInterfaceMemberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartialInterfaceMemberContext {
	var p = new(PartialInterfaceMemberContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_partialInterfaceMember

	return p
}

func (s *PartialInterfaceMemberContext) GetParser() antlr.Parser { return s.parser }

func (s *PartialInterfaceMemberContext) Const_() IConst_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConst_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConst_Context)
}

func (s *PartialInterfaceMemberContext) Operation() IOperationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOperationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOperationContext)
}

func (s *PartialInterfaceMemberContext) Stringifier() IStringifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStringifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStringifierContext)
}

func (s *PartialInterfaceMemberContext) StaticMember() IStaticMemberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStaticMemberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStaticMemberContext)
}

func (s *PartialInterfaceMemberContext) Iterable() IIterableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIterableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIterableContext)
}

func (s *PartialInterfaceMemberContext) AsyncIterable() IAsyncIterableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAsyncIterableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAsyncIterableContext)
}

func (s *PartialInterfaceMemberContext) ReadonlyMember() IReadonlyMemberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReadonlyMemberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReadonlyMemberContext)
}

func (s *PartialInterfaceMemberContext) ReadWriteAttribute() IReadWriteAttributeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReadWriteAttributeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReadWriteAttributeContext)
}

func (s *PartialInterfaceMemberContext) ReadWriteMaplike() IReadWriteMaplikeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReadWriteMaplikeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReadWriteMaplikeContext)
}

func (s *PartialInterfaceMemberContext) ReadWriteSetlike() IReadWriteSetlikeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReadWriteSetlikeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReadWriteSetlikeContext)
}

func (s *PartialInterfaceMemberContext) InheritAttribute() IInheritAttributeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInheritAttributeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInheritAttributeContext)
}

func (s *PartialInterfaceMemberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartialInterfaceMemberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartialInterfaceMemberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterPartialInterfaceMember(s)
	}
}

func (s *PartialInterfaceMemberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitPartialInterfaceMember(s)
	}
}

func (p *WebIDLParser) PartialInterfaceMember() (localctx IPartialInterfaceMemberContext) {
	this := p
	_ = this

	localctx = NewPartialInterfaceMemberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, WebIDLParserRULE_partialInterfaceMember)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(312)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__3:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(301)
			p.Const_()
		}

	case WebIDLParserT__5, WebIDLParserT__8, WebIDLParserT__20, WebIDLParserT__24, WebIDLParserT__38, WebIDLParserT__45, WebIDLParserT__47, WebIDLParserT__48, WebIDLParserT__49, WebIDLParserT__50, WebIDLParserT__51, WebIDLParserT__52, WebIDLParserT__53, WebIDLParserT__54, WebIDLParserT__55, WebIDLParserT__56, WebIDLParserT__57, WebIDLParserT__58, WebIDLParserT__59, WebIDLParserT__60, WebIDLParserT__61, WebIDLParserT__62, WebIDLParserT__63, WebIDLParserT__64, WebIDLParserT__65, WebIDLParserT__66, WebIDLParserT__68, WebIDLParserT__69, WebIDLParserT__70, WebIDLParserT__71, WebIDLParserT__72, WebIDLParserT__73, WebIDLParserT__74, WebIDLParserT__75, WebIDLParserT__76, WebIDLParserT__77, WebIDLParserT__78, WebIDLParserIDENTIFIER_WEBIDL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(302)
			p.Operation()
		}

	case WebIDLParserT__22:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(303)
			p.Stringifier()
		}

	case WebIDLParserT__21:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(304)
			p.StaticMember()
		}

	case WebIDLParserT__12:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(305)
			p.Iterable()
		}

	case WebIDLParserT__0:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(306)
			p.AsyncIterable()
		}

	case WebIDLParserT__17:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(307)
			p.ReadonlyMember()
		}

	case WebIDLParserT__1:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(308)
			p.ReadWriteAttribute()
		}

	case WebIDLParserT__13:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(309)
			p.ReadWriteMaplike()
		}

	case WebIDLParserT__19:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(310)
			p.ReadWriteSetlike()
		}

	case WebIDLParserT__10:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(311)
			p.InheritAttribute()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IInheritanceContext is an interface to support dynamic dispatch.
type IInheritanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInheritanceContext differentiates from other interfaces.
	IsInheritanceContext()
}

type InheritanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInheritanceContext() *InheritanceContext {
	var p = new(InheritanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_inheritance
	return p
}

func (*InheritanceContext) IsInheritanceContext() {}

func NewInheritanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InheritanceContext {
	var p = new(InheritanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_inheritance

	return p
}

func (s *InheritanceContext) GetParser() antlr.Parser { return s.parser }

func (s *InheritanceContext) IDENTIFIER_WEBIDL() antlr.TerminalNode {
	return s.GetToken(WebIDLParserIDENTIFIER_WEBIDL, 0)
}

func (s *InheritanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InheritanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InheritanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterInheritance(s)
	}
}

func (s *InheritanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitInheritance(s)
	}
}

func (p *WebIDLParser) Inheritance() (localctx IInheritanceContext) {
	this := p
	_ = this

	localctx = NewInheritanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, WebIDLParserRULE_inheritance)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(317)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__28:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(314)
			p.Match(WebIDLParserT__28)
		}
		{
			p.SetState(315)
			p.Match(WebIDLParserIDENTIFIER_WEBIDL)
		}

	case WebIDLParserT__25:
		p.EnterOuterAlt(localctx, 2)

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IMixinRestContext is an interface to support dynamic dispatch.
type IMixinRestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMixinRestContext differentiates from other interfaces.
	IsMixinRestContext()
}

type MixinRestContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMixinRestContext() *MixinRestContext {
	var p = new(MixinRestContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_mixinRest
	return p
}

func (*MixinRestContext) IsMixinRestContext() {}

func NewMixinRestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MixinRestContext {
	var p = new(MixinRestContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_mixinRest

	return p
}

func (s *MixinRestContext) GetParser() antlr.Parser { return s.parser }

func (s *MixinRestContext) IDENTIFIER_WEBIDL() antlr.TerminalNode {
	return s.GetToken(WebIDLParserIDENTIFIER_WEBIDL, 0)
}

func (s *MixinRestContext) MixinMembers() IMixinMembersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMixinMembersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMixinMembersContext)
}

func (s *MixinRestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MixinRestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MixinRestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterMixinRest(s)
	}
}

func (s *MixinRestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitMixinRest(s)
	}
}

func (p *WebIDLParser) MixinRest() (localctx IMixinRestContext) {
	this := p
	_ = this

	localctx = NewMixinRestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, WebIDLParserRULE_mixinRest)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(319)
		p.Match(WebIDLParserT__14)
	}
	{
		p.SetState(320)
		p.Match(WebIDLParserIDENTIFIER_WEBIDL)
	}
	{
		p.SetState(321)
		p.Match(WebIDLParserT__25)
	}
	{
		p.SetState(322)
		p.MixinMembers()
	}
	{
		p.SetState(323)
		p.Match(WebIDLParserT__26)
	}
	{
		p.SetState(324)
		p.Match(WebIDLParserT__27)
	}

	return localctx
}

// IMixinMembersContext is an interface to support dynamic dispatch.
type IMixinMembersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMixinMembersContext differentiates from other interfaces.
	IsMixinMembersContext()
}

type MixinMembersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMixinMembersContext() *MixinMembersContext {
	var p = new(MixinMembersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_mixinMembers
	return p
}

func (*MixinMembersContext) IsMixinMembersContext() {}

func NewMixinMembersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MixinMembersContext {
	var p = new(MixinMembersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_mixinMembers

	return p
}

func (s *MixinMembersContext) GetParser() antlr.Parser { return s.parser }

func (s *MixinMembersContext) ExtendedAttributeList() IExtendedAttributeListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtendedAttributeListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtendedAttributeListContext)
}

func (s *MixinMembersContext) MixinMember() IMixinMemberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMixinMemberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMixinMemberContext)
}

func (s *MixinMembersContext) MixinMembers() IMixinMembersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMixinMembersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMixinMembersContext)
}

func (s *MixinMembersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MixinMembersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MixinMembersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterMixinMembers(s)
	}
}

func (s *MixinMembersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitMixinMembers(s)
	}
}

func (p *WebIDLParser) MixinMembers() (localctx IMixinMembersContext) {
	this := p
	_ = this

	localctx = NewMixinMembersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, WebIDLParserRULE_mixinMembers)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(331)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__1, WebIDLParserT__3, WebIDLParserT__17, WebIDLParserT__22, WebIDLParserT__24, WebIDLParserT__35, WebIDLParserT__38, WebIDLParserT__45, WebIDLParserT__47, WebIDLParserT__48, WebIDLParserT__49, WebIDLParserT__50, WebIDLParserT__51, WebIDLParserT__52, WebIDLParserT__53, WebIDLParserT__54, WebIDLParserT__55, WebIDLParserT__56, WebIDLParserT__57, WebIDLParserT__58, WebIDLParserT__59, WebIDLParserT__60, WebIDLParserT__61, WebIDLParserT__62, WebIDLParserT__63, WebIDLParserT__64, WebIDLParserT__65, WebIDLParserT__66, WebIDLParserT__68, WebIDLParserT__69, WebIDLParserT__70, WebIDLParserT__71, WebIDLParserT__72, WebIDLParserT__73, WebIDLParserT__74, WebIDLParserT__75, WebIDLParserT__76, WebIDLParserT__77, WebIDLParserT__78, WebIDLParserIDENTIFIER_WEBIDL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(326)
			p.ExtendedAttributeList()
		}
		{
			p.SetState(327)
			p.MixinMember()
		}
		{
			p.SetState(328)
			p.MixinMembers()
		}

	case WebIDLParserT__26:
		p.EnterOuterAlt(localctx, 2)

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IMixinMemberContext is an interface to support dynamic dispatch.
type IMixinMemberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMixinMemberContext differentiates from other interfaces.
	IsMixinMemberContext()
}

type MixinMemberContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMixinMemberContext() *MixinMemberContext {
	var p = new(MixinMemberContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_mixinMember
	return p
}

func (*MixinMemberContext) IsMixinMemberContext() {}

func NewMixinMemberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MixinMemberContext {
	var p = new(MixinMemberContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_mixinMember

	return p
}

func (s *MixinMemberContext) GetParser() antlr.Parser { return s.parser }

func (s *MixinMemberContext) Const_() IConst_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConst_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConst_Context)
}

func (s *MixinMemberContext) RegularOperation() IRegularOperationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRegularOperationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRegularOperationContext)
}

func (s *MixinMemberContext) Stringifier() IStringifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStringifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStringifierContext)
}

func (s *MixinMemberContext) OptionalReadOnly() IOptionalReadOnlyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOptionalReadOnlyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOptionalReadOnlyContext)
}

func (s *MixinMemberContext) AttributeRest() IAttributeRestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttributeRestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttributeRestContext)
}

func (s *MixinMemberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MixinMemberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MixinMemberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterMixinMember(s)
	}
}

func (s *MixinMemberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitMixinMember(s)
	}
}

func (p *WebIDLParser) MixinMember() (localctx IMixinMemberContext) {
	this := p
	_ = this

	localctx = NewMixinMemberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, WebIDLParserRULE_mixinMember)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(339)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__3:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(333)
			p.Const_()
		}

	case WebIDLParserT__24, WebIDLParserT__38, WebIDLParserT__45, WebIDLParserT__47, WebIDLParserT__48, WebIDLParserT__49, WebIDLParserT__50, WebIDLParserT__51, WebIDLParserT__52, WebIDLParserT__53, WebIDLParserT__54, WebIDLParserT__55, WebIDLParserT__56, WebIDLParserT__57, WebIDLParserT__58, WebIDLParserT__59, WebIDLParserT__60, WebIDLParserT__61, WebIDLParserT__62, WebIDLParserT__63, WebIDLParserT__64, WebIDLParserT__65, WebIDLParserT__66, WebIDLParserT__68, WebIDLParserT__69, WebIDLParserT__70, WebIDLParserT__71, WebIDLParserT__72, WebIDLParserT__73, WebIDLParserT__74, WebIDLParserT__75, WebIDLParserT__76, WebIDLParserT__77, WebIDLParserT__78, WebIDLParserIDENTIFIER_WEBIDL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(334)
			p.RegularOperation()
		}

	case WebIDLParserT__22:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(335)
			p.Stringifier()
		}

	case WebIDLParserT__1, WebIDLParserT__17:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(336)
			p.OptionalReadOnly()
		}
		{
			p.SetState(337)
			p.AttributeRest()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IIncludesStatementContext is an interface to support dynamic dispatch.
type IIncludesStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIncludesStatementContext differentiates from other interfaces.
	IsIncludesStatementContext()
}

type IncludesStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIncludesStatementContext() *IncludesStatementContext {
	var p = new(IncludesStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_includesStatement
	return p
}

func (*IncludesStatementContext) IsIncludesStatementContext() {}

func NewIncludesStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IncludesStatementContext {
	var p = new(IncludesStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_includesStatement

	return p
}

func (s *IncludesStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *IncludesStatementContext) AllIDENTIFIER_WEBIDL() []antlr.TerminalNode {
	return s.GetTokens(WebIDLParserIDENTIFIER_WEBIDL)
}

func (s *IncludesStatementContext) IDENTIFIER_WEBIDL(i int) antlr.TerminalNode {
	return s.GetToken(WebIDLParserIDENTIFIER_WEBIDL, i)
}

func (s *IncludesStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IncludesStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IncludesStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterIncludesStatement(s)
	}
}

func (s *IncludesStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitIncludesStatement(s)
	}
}

func (p *WebIDLParser) IncludesStatement() (localctx IIncludesStatementContext) {
	this := p
	_ = this

	localctx = NewIncludesStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, WebIDLParserRULE_includesStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(341)
		p.Match(WebIDLParserIDENTIFIER_WEBIDL)
	}
	{
		p.SetState(342)
		p.Match(WebIDLParserT__9)
	}
	{
		p.SetState(343)
		p.Match(WebIDLParserIDENTIFIER_WEBIDL)
	}
	{
		p.SetState(344)
		p.Match(WebIDLParserT__27)
	}

	return localctx
}

// ICallbackRestOrInterfaceContext is an interface to support dynamic dispatch.
type ICallbackRestOrInterfaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCallbackRestOrInterfaceContext differentiates from other interfaces.
	IsCallbackRestOrInterfaceContext()
}

type CallbackRestOrInterfaceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallbackRestOrInterfaceContext() *CallbackRestOrInterfaceContext {
	var p = new(CallbackRestOrInterfaceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_callbackRestOrInterface
	return p
}

func (*CallbackRestOrInterfaceContext) IsCallbackRestOrInterfaceContext() {}

func NewCallbackRestOrInterfaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallbackRestOrInterfaceContext {
	var p = new(CallbackRestOrInterfaceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_callbackRestOrInterface

	return p
}

func (s *CallbackRestOrInterfaceContext) GetParser() antlr.Parser { return s.parser }

func (s *CallbackRestOrInterfaceContext) CallbackRest() ICallbackRestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICallbackRestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICallbackRestContext)
}

func (s *CallbackRestOrInterfaceContext) IDENTIFIER_WEBIDL() antlr.TerminalNode {
	return s.GetToken(WebIDLParserIDENTIFIER_WEBIDL, 0)
}

func (s *CallbackRestOrInterfaceContext) CallbackInterfaceMembers() ICallbackInterfaceMembersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICallbackInterfaceMembersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICallbackInterfaceMembersContext)
}

func (s *CallbackRestOrInterfaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallbackRestOrInterfaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallbackRestOrInterfaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterCallbackRestOrInterface(s)
	}
}

func (s *CallbackRestOrInterfaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitCallbackRestOrInterface(s)
	}
}

func (p *WebIDLParser) CallbackRestOrInterface() (localctx ICallbackRestOrInterfaceContext) {
	this := p
	_ = this

	localctx = NewCallbackRestOrInterfaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, WebIDLParserRULE_callbackRestOrInterface)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(354)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserIDENTIFIER_WEBIDL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(346)
			p.CallbackRest()
		}

	case WebIDLParserT__11:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(347)
			p.Match(WebIDLParserT__11)
		}
		{
			p.SetState(348)
			p.Match(WebIDLParserIDENTIFIER_WEBIDL)
		}
		{
			p.SetState(349)
			p.Match(WebIDLParserT__25)
		}
		{
			p.SetState(350)
			p.CallbackInterfaceMembers()
		}
		{
			p.SetState(351)
			p.Match(WebIDLParserT__26)
		}
		{
			p.SetState(352)
			p.Match(WebIDLParserT__27)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICallbackInterfaceMembersContext is an interface to support dynamic dispatch.
type ICallbackInterfaceMembersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCallbackInterfaceMembersContext differentiates from other interfaces.
	IsCallbackInterfaceMembersContext()
}

type CallbackInterfaceMembersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallbackInterfaceMembersContext() *CallbackInterfaceMembersContext {
	var p = new(CallbackInterfaceMembersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_callbackInterfaceMembers
	return p
}

func (*CallbackInterfaceMembersContext) IsCallbackInterfaceMembersContext() {}

func NewCallbackInterfaceMembersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallbackInterfaceMembersContext {
	var p = new(CallbackInterfaceMembersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_callbackInterfaceMembers

	return p
}

func (s *CallbackInterfaceMembersContext) GetParser() antlr.Parser { return s.parser }

func (s *CallbackInterfaceMembersContext) ExtendedAttributeList() IExtendedAttributeListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtendedAttributeListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtendedAttributeListContext)
}

func (s *CallbackInterfaceMembersContext) CallbackInterfaceMember() ICallbackInterfaceMemberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICallbackInterfaceMemberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICallbackInterfaceMemberContext)
}

func (s *CallbackInterfaceMembersContext) CallbackInterfaceMembers() ICallbackInterfaceMembersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICallbackInterfaceMembersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICallbackInterfaceMembersContext)
}

func (s *CallbackInterfaceMembersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallbackInterfaceMembersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallbackInterfaceMembersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterCallbackInterfaceMembers(s)
	}
}

func (s *CallbackInterfaceMembersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitCallbackInterfaceMembers(s)
	}
}

func (p *WebIDLParser) CallbackInterfaceMembers() (localctx ICallbackInterfaceMembersContext) {
	this := p
	_ = this

	localctx = NewCallbackInterfaceMembersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, WebIDLParserRULE_callbackInterfaceMembers)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(361)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__3, WebIDLParserT__24, WebIDLParserT__35, WebIDLParserT__38, WebIDLParserT__45, WebIDLParserT__47, WebIDLParserT__48, WebIDLParserT__49, WebIDLParserT__50, WebIDLParserT__51, WebIDLParserT__52, WebIDLParserT__53, WebIDLParserT__54, WebIDLParserT__55, WebIDLParserT__56, WebIDLParserT__57, WebIDLParserT__58, WebIDLParserT__59, WebIDLParserT__60, WebIDLParserT__61, WebIDLParserT__62, WebIDLParserT__63, WebIDLParserT__64, WebIDLParserT__65, WebIDLParserT__66, WebIDLParserT__68, WebIDLParserT__69, WebIDLParserT__70, WebIDLParserT__71, WebIDLParserT__72, WebIDLParserT__73, WebIDLParserT__74, WebIDLParserT__75, WebIDLParserT__76, WebIDLParserT__77, WebIDLParserT__78, WebIDLParserIDENTIFIER_WEBIDL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(356)
			p.ExtendedAttributeList()
		}
		{
			p.SetState(357)
			p.CallbackInterfaceMember()
		}
		{
			p.SetState(358)
			p.CallbackInterfaceMembers()
		}

	case WebIDLParserT__26:
		p.EnterOuterAlt(localctx, 2)

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICallbackInterfaceMemberContext is an interface to support dynamic dispatch.
type ICallbackInterfaceMemberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCallbackInterfaceMemberContext differentiates from other interfaces.
	IsCallbackInterfaceMemberContext()
}

type CallbackInterfaceMemberContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallbackInterfaceMemberContext() *CallbackInterfaceMemberContext {
	var p = new(CallbackInterfaceMemberContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_callbackInterfaceMember
	return p
}

func (*CallbackInterfaceMemberContext) IsCallbackInterfaceMemberContext() {}

func NewCallbackInterfaceMemberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallbackInterfaceMemberContext {
	var p = new(CallbackInterfaceMemberContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_callbackInterfaceMember

	return p
}

func (s *CallbackInterfaceMemberContext) GetParser() antlr.Parser { return s.parser }

func (s *CallbackInterfaceMemberContext) Const_() IConst_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConst_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConst_Context)
}

func (s *CallbackInterfaceMemberContext) RegularOperation() IRegularOperationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRegularOperationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRegularOperationContext)
}

func (s *CallbackInterfaceMemberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallbackInterfaceMemberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallbackInterfaceMemberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterCallbackInterfaceMember(s)
	}
}

func (s *CallbackInterfaceMemberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitCallbackInterfaceMember(s)
	}
}

func (p *WebIDLParser) CallbackInterfaceMember() (localctx ICallbackInterfaceMemberContext) {
	this := p
	_ = this

	localctx = NewCallbackInterfaceMemberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, WebIDLParserRULE_callbackInterfaceMember)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(365)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__3:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(363)
			p.Const_()
		}

	case WebIDLParserT__24, WebIDLParserT__38, WebIDLParserT__45, WebIDLParserT__47, WebIDLParserT__48, WebIDLParserT__49, WebIDLParserT__50, WebIDLParserT__51, WebIDLParserT__52, WebIDLParserT__53, WebIDLParserT__54, WebIDLParserT__55, WebIDLParserT__56, WebIDLParserT__57, WebIDLParserT__58, WebIDLParserT__59, WebIDLParserT__60, WebIDLParserT__61, WebIDLParserT__62, WebIDLParserT__63, WebIDLParserT__64, WebIDLParserT__65, WebIDLParserT__66, WebIDLParserT__68, WebIDLParserT__69, WebIDLParserT__70, WebIDLParserT__71, WebIDLParserT__72, WebIDLParserT__73, WebIDLParserT__74, WebIDLParserT__75, WebIDLParserT__76, WebIDLParserT__77, WebIDLParserT__78, WebIDLParserIDENTIFIER_WEBIDL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(364)
			p.RegularOperation()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IConst_Context is an interface to support dynamic dispatch.
type IConst_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConst_Context differentiates from other interfaces.
	IsConst_Context()
}

type Const_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConst_Context() *Const_Context {
	var p = new(Const_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_const_
	return p
}

func (*Const_Context) IsConst_Context() {}

func NewConst_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Const_Context {
	var p = new(Const_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_const_

	return p
}

func (s *Const_Context) GetParser() antlr.Parser { return s.parser }

func (s *Const_Context) ConstType() IConstTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstTypeContext)
}

func (s *Const_Context) IDENTIFIER_WEBIDL() antlr.TerminalNode {
	return s.GetToken(WebIDLParserIDENTIFIER_WEBIDL, 0)
}

func (s *Const_Context) ConstValue() IConstValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstValueContext)
}

func (s *Const_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Const_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Const_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterConst_(s)
	}
}

func (s *Const_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitConst_(s)
	}
}

func (p *WebIDLParser) Const_() (localctx IConst_Context) {
	this := p
	_ = this

	localctx = NewConst_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, WebIDLParserRULE_const_)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(367)
		p.Match(WebIDLParserT__3)
	}
	{
		p.SetState(368)
		p.ConstType()
	}
	{
		p.SetState(369)
		p.Match(WebIDLParserIDENTIFIER_WEBIDL)
	}
	{
		p.SetState(370)
		p.Match(WebIDLParserT__29)
	}
	{
		p.SetState(371)
		p.ConstValue()
	}
	{
		p.SetState(372)
		p.Match(WebIDLParserT__27)
	}

	return localctx
}

// IConstValueContext is an interface to support dynamic dispatch.
type IConstValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstValueContext differentiates from other interfaces.
	IsConstValueContext()
}

type ConstValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstValueContext() *ConstValueContext {
	var p = new(ConstValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_constValue
	return p
}

func (*ConstValueContext) IsConstValueContext() {}

func NewConstValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstValueContext {
	var p = new(ConstValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_constValue

	return p
}

func (s *ConstValueContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstValueContext) BooleanLiteral() IBooleanLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBooleanLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBooleanLiteralContext)
}

func (s *ConstValueContext) FloatLiteral() IFloatLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFloatLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFloatLiteralContext)
}

func (s *ConstValueContext) INTEGER_WEBIDL() antlr.TerminalNode {
	return s.GetToken(WebIDLParserINTEGER_WEBIDL, 0)
}

func (s *ConstValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterConstValue(s)
	}
}

func (s *ConstValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitConstValue(s)
	}
}

func (p *WebIDLParser) ConstValue() (localctx IConstValueContext) {
	this := p
	_ = this

	localctx = NewConstValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, WebIDLParserRULE_constValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(377)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__30, WebIDLParserT__31:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(374)
			p.BooleanLiteral()
		}

	case WebIDLParserT__32, WebIDLParserT__33, WebIDLParserT__34, WebIDLParserDECIMAL_WEBIDL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(375)
			p.FloatLiteral()
		}

	case WebIDLParserINTEGER_WEBIDL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(376)
			p.Match(WebIDLParserINTEGER_WEBIDL)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IBooleanLiteralContext is an interface to support dynamic dispatch.
type IBooleanLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBooleanLiteralContext differentiates from other interfaces.
	IsBooleanLiteralContext()
}

type BooleanLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanLiteralContext() *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_booleanLiteral
	return p
}

func (*BooleanLiteralContext) IsBooleanLiteralContext() {}

func NewBooleanLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_booleanLiteral

	return p
}

func (s *BooleanLiteralContext) GetParser() antlr.Parser { return s.parser }
func (s *BooleanLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BooleanLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterBooleanLiteral(s)
	}
}

func (s *BooleanLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitBooleanLiteral(s)
	}
}

func (p *WebIDLParser) BooleanLiteral() (localctx IBooleanLiteralContext) {
	this := p
	_ = this

	localctx = NewBooleanLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, WebIDLParserRULE_booleanLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(379)
		_la = p.GetTokenStream().LA(1)

		if !(_la == WebIDLParserT__30 || _la == WebIDLParserT__31) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IFloatLiteralContext is an interface to support dynamic dispatch.
type IFloatLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFloatLiteralContext differentiates from other interfaces.
	IsFloatLiteralContext()
}

type FloatLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFloatLiteralContext() *FloatLiteralContext {
	var p = new(FloatLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_floatLiteral
	return p
}

func (*FloatLiteralContext) IsFloatLiteralContext() {}

func NewFloatLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FloatLiteralContext {
	var p = new(FloatLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_floatLiteral

	return p
}

func (s *FloatLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *FloatLiteralContext) DECIMAL_WEBIDL() antlr.TerminalNode {
	return s.GetToken(WebIDLParserDECIMAL_WEBIDL, 0)
}

func (s *FloatLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FloatLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FloatLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterFloatLiteral(s)
	}
}

func (s *FloatLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitFloatLiteral(s)
	}
}

func (p *WebIDLParser) FloatLiteral() (localctx IFloatLiteralContext) {
	this := p
	_ = this

	localctx = NewFloatLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, WebIDLParserRULE_floatLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(381)
		_la = p.GetTokenStream().LA(1)

		if !((((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(WebIDLParserT__32-33))|(1<<(WebIDLParserT__33-33))|(1<<(WebIDLParserT__34-33)))) != 0) || _la == WebIDLParserDECIMAL_WEBIDL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IConstTypeContext is an interface to support dynamic dispatch.
type IConstTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstTypeContext differentiates from other interfaces.
	IsConstTypeContext()
}

type ConstTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstTypeContext() *ConstTypeContext {
	var p = new(ConstTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_constType
	return p
}

func (*ConstTypeContext) IsConstTypeContext() {}

func NewConstTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstTypeContext {
	var p = new(ConstTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_constType

	return p
}

func (s *ConstTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstTypeContext) PrimitiveType() IPrimitiveTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimitiveTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimitiveTypeContext)
}

func (s *ConstTypeContext) IDENTIFIER_WEBIDL() antlr.TerminalNode {
	return s.GetToken(WebIDLParserIDENTIFIER_WEBIDL, 0)
}

func (s *ConstTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterConstType(s)
	}
}

func (s *ConstTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitConstType(s)
	}
}

func (p *WebIDLParser) ConstType() (localctx IConstTypeContext) {
	this := p
	_ = this

	localctx = NewConstTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, WebIDLParserRULE_constType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(385)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__24, WebIDLParserT__52, WebIDLParserT__53, WebIDLParserT__54, WebIDLParserT__55, WebIDLParserT__56, WebIDLParserT__57, WebIDLParserT__58, WebIDLParserT__59, WebIDLParserT__60, WebIDLParserT__61:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(383)
			p.PrimitiveType()
		}

	case WebIDLParserIDENTIFIER_WEBIDL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(384)
			p.Match(WebIDLParserIDENTIFIER_WEBIDL)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IReadonlyMemberContext is an interface to support dynamic dispatch.
type IReadonlyMemberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReadonlyMemberContext differentiates from other interfaces.
	IsReadonlyMemberContext()
}

type ReadonlyMemberContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReadonlyMemberContext() *ReadonlyMemberContext {
	var p = new(ReadonlyMemberContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_readonlyMember
	return p
}

func (*ReadonlyMemberContext) IsReadonlyMemberContext() {}

func NewReadonlyMemberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReadonlyMemberContext {
	var p = new(ReadonlyMemberContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_readonlyMember

	return p
}

func (s *ReadonlyMemberContext) GetParser() antlr.Parser { return s.parser }

func (s *ReadonlyMemberContext) ReadonlyMemberRest() IReadonlyMemberRestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReadonlyMemberRestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReadonlyMemberRestContext)
}

func (s *ReadonlyMemberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReadonlyMemberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReadonlyMemberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterReadonlyMember(s)
	}
}

func (s *ReadonlyMemberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitReadonlyMember(s)
	}
}

func (p *WebIDLParser) ReadonlyMember() (localctx IReadonlyMemberContext) {
	this := p
	_ = this

	localctx = NewReadonlyMemberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, WebIDLParserRULE_readonlyMember)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(387)
		p.Match(WebIDLParserT__17)
	}
	{
		p.SetState(388)
		p.ReadonlyMemberRest()
	}

	return localctx
}

// IReadonlyMemberRestContext is an interface to support dynamic dispatch.
type IReadonlyMemberRestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReadonlyMemberRestContext differentiates from other interfaces.
	IsReadonlyMemberRestContext()
}

type ReadonlyMemberRestContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReadonlyMemberRestContext() *ReadonlyMemberRestContext {
	var p = new(ReadonlyMemberRestContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_readonlyMemberRest
	return p
}

func (*ReadonlyMemberRestContext) IsReadonlyMemberRestContext() {}

func NewReadonlyMemberRestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReadonlyMemberRestContext {
	var p = new(ReadonlyMemberRestContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_readonlyMemberRest

	return p
}

func (s *ReadonlyMemberRestContext) GetParser() antlr.Parser { return s.parser }

func (s *ReadonlyMemberRestContext) AttributeRest() IAttributeRestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttributeRestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttributeRestContext)
}

func (s *ReadonlyMemberRestContext) MaplikeRest() IMaplikeRestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMaplikeRestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMaplikeRestContext)
}

func (s *ReadonlyMemberRestContext) SetlikeRest() ISetlikeRestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetlikeRestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISetlikeRestContext)
}

func (s *ReadonlyMemberRestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReadonlyMemberRestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReadonlyMemberRestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterReadonlyMemberRest(s)
	}
}

func (s *ReadonlyMemberRestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitReadonlyMemberRest(s)
	}
}

func (p *WebIDLParser) ReadonlyMemberRest() (localctx IReadonlyMemberRestContext) {
	this := p
	_ = this

	localctx = NewReadonlyMemberRestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, WebIDLParserRULE_readonlyMemberRest)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(393)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(390)
			p.AttributeRest()
		}

	case WebIDLParserT__13:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(391)
			p.MaplikeRest()
		}

	case WebIDLParserT__19:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(392)
			p.SetlikeRest()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IReadWriteAttributeContext is an interface to support dynamic dispatch.
type IReadWriteAttributeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReadWriteAttributeContext differentiates from other interfaces.
	IsReadWriteAttributeContext()
}

type ReadWriteAttributeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReadWriteAttributeContext() *ReadWriteAttributeContext {
	var p = new(ReadWriteAttributeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_readWriteAttribute
	return p
}

func (*ReadWriteAttributeContext) IsReadWriteAttributeContext() {}

func NewReadWriteAttributeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReadWriteAttributeContext {
	var p = new(ReadWriteAttributeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_readWriteAttribute

	return p
}

func (s *ReadWriteAttributeContext) GetParser() antlr.Parser { return s.parser }

func (s *ReadWriteAttributeContext) AttributeRest() IAttributeRestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttributeRestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttributeRestContext)
}

func (s *ReadWriteAttributeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReadWriteAttributeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReadWriteAttributeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterReadWriteAttribute(s)
	}
}

func (s *ReadWriteAttributeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitReadWriteAttribute(s)
	}
}

func (p *WebIDLParser) ReadWriteAttribute() (localctx IReadWriteAttributeContext) {
	this := p
	_ = this

	localctx = NewReadWriteAttributeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, WebIDLParserRULE_readWriteAttribute)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(395)
		p.AttributeRest()
	}

	return localctx
}

// IInheritAttributeContext is an interface to support dynamic dispatch.
type IInheritAttributeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInheritAttributeContext differentiates from other interfaces.
	IsInheritAttributeContext()
}

type InheritAttributeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInheritAttributeContext() *InheritAttributeContext {
	var p = new(InheritAttributeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_inheritAttribute
	return p
}

func (*InheritAttributeContext) IsInheritAttributeContext() {}

func NewInheritAttributeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InheritAttributeContext {
	var p = new(InheritAttributeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_inheritAttribute

	return p
}

func (s *InheritAttributeContext) GetParser() antlr.Parser { return s.parser }

func (s *InheritAttributeContext) AttributeRest() IAttributeRestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttributeRestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttributeRestContext)
}

func (s *InheritAttributeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InheritAttributeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InheritAttributeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterInheritAttribute(s)
	}
}

func (s *InheritAttributeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitInheritAttribute(s)
	}
}

func (p *WebIDLParser) InheritAttribute() (localctx IInheritAttributeContext) {
	this := p
	_ = this

	localctx = NewInheritAttributeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, WebIDLParserRULE_inheritAttribute)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(397)
		p.Match(WebIDLParserT__10)
	}
	{
		p.SetState(398)
		p.AttributeRest()
	}

	return localctx
}

// IAttributeRestContext is an interface to support dynamic dispatch.
type IAttributeRestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttributeRestContext differentiates from other interfaces.
	IsAttributeRestContext()
}

type AttributeRestContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeRestContext() *AttributeRestContext {
	var p = new(AttributeRestContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_attributeRest
	return p
}

func (*AttributeRestContext) IsAttributeRestContext() {}

func NewAttributeRestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeRestContext {
	var p = new(AttributeRestContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_attributeRest

	return p
}

func (s *AttributeRestContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeRestContext) TypeWithExtendedAttributes() ITypeWithExtendedAttributesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeWithExtendedAttributesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeWithExtendedAttributesContext)
}

func (s *AttributeRestContext) AttributeName() IAttributeNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttributeNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttributeNameContext)
}

func (s *AttributeRestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeRestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributeRestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterAttributeRest(s)
	}
}

func (s *AttributeRestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitAttributeRest(s)
	}
}

func (p *WebIDLParser) AttributeRest() (localctx IAttributeRestContext) {
	this := p
	_ = this

	localctx = NewAttributeRestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, WebIDLParserRULE_attributeRest)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(400)
		p.Match(WebIDLParserT__1)
	}
	{
		p.SetState(401)
		p.TypeWithExtendedAttributes()
	}
	{
		p.SetState(402)
		p.AttributeName()
	}
	{
		p.SetState(403)
		p.Match(WebIDLParserT__27)
	}

	return localctx
}

// IAttributeNameContext is an interface to support dynamic dispatch.
type IAttributeNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttributeNameContext differentiates from other interfaces.
	IsAttributeNameContext()
}

type AttributeNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeNameContext() *AttributeNameContext {
	var p = new(AttributeNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_attributeName
	return p
}

func (*AttributeNameContext) IsAttributeNameContext() {}

func NewAttributeNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeNameContext {
	var p = new(AttributeNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_attributeName

	return p
}

func (s *AttributeNameContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeNameContext) AttributeNameKeyword() IAttributeNameKeywordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttributeNameKeywordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttributeNameKeywordContext)
}

func (s *AttributeNameContext) IDENTIFIER_WEBIDL() antlr.TerminalNode {
	return s.GetToken(WebIDLParserIDENTIFIER_WEBIDL, 0)
}

func (s *AttributeNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributeNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterAttributeName(s)
	}
}

func (s *AttributeNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitAttributeName(s)
	}
}

func (p *WebIDLParser) AttributeName() (localctx IAttributeNameContext) {
	this := p
	_ = this

	localctx = NewAttributeNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, WebIDLParserRULE_attributeName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(407)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__0, WebIDLParserT__18:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(405)
			p.AttributeNameKeyword()
		}

	case WebIDLParserIDENTIFIER_WEBIDL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(406)
			p.Match(WebIDLParserIDENTIFIER_WEBIDL)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAttributeNameKeywordContext is an interface to support dynamic dispatch.
type IAttributeNameKeywordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttributeNameKeywordContext differentiates from other interfaces.
	IsAttributeNameKeywordContext()
}

type AttributeNameKeywordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeNameKeywordContext() *AttributeNameKeywordContext {
	var p = new(AttributeNameKeywordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_attributeNameKeyword
	return p
}

func (*AttributeNameKeywordContext) IsAttributeNameKeywordContext() {}

func NewAttributeNameKeywordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeNameKeywordContext {
	var p = new(AttributeNameKeywordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_attributeNameKeyword

	return p
}

func (s *AttributeNameKeywordContext) GetParser() antlr.Parser { return s.parser }
func (s *AttributeNameKeywordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeNameKeywordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributeNameKeywordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterAttributeNameKeyword(s)
	}
}

func (s *AttributeNameKeywordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitAttributeNameKeyword(s)
	}
}

func (p *WebIDLParser) AttributeNameKeyword() (localctx IAttributeNameKeywordContext) {
	this := p
	_ = this

	localctx = NewAttributeNameKeywordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, WebIDLParserRULE_attributeNameKeyword)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(409)
		_la = p.GetTokenStream().LA(1)

		if !(_la == WebIDLParserT__0 || _la == WebIDLParserT__18) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IOptionalReadOnlyContext is an interface to support dynamic dispatch.
type IOptionalReadOnlyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOptionalReadOnlyContext differentiates from other interfaces.
	IsOptionalReadOnlyContext()
}

type OptionalReadOnlyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptionalReadOnlyContext() *OptionalReadOnlyContext {
	var p = new(OptionalReadOnlyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_optionalReadOnly
	return p
}

func (*OptionalReadOnlyContext) IsOptionalReadOnlyContext() {}

func NewOptionalReadOnlyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptionalReadOnlyContext {
	var p = new(OptionalReadOnlyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_optionalReadOnly

	return p
}

func (s *OptionalReadOnlyContext) GetParser() antlr.Parser { return s.parser }
func (s *OptionalReadOnlyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptionalReadOnlyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptionalReadOnlyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterOptionalReadOnly(s)
	}
}

func (s *OptionalReadOnlyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitOptionalReadOnly(s)
	}
}

func (p *WebIDLParser) OptionalReadOnly() (localctx IOptionalReadOnlyContext) {
	this := p
	_ = this

	localctx = NewOptionalReadOnlyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, WebIDLParserRULE_optionalReadOnly)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(413)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__17:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(411)
			p.Match(WebIDLParserT__17)
		}

	case WebIDLParserT__1:
		p.EnterOuterAlt(localctx, 2)

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDefaultValueContext is an interface to support dynamic dispatch.
type IDefaultValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDefaultValueContext differentiates from other interfaces.
	IsDefaultValueContext()
}

type DefaultValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefaultValueContext() *DefaultValueContext {
	var p = new(DefaultValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_defaultValue
	return p
}

func (*DefaultValueContext) IsDefaultValueContext() {}

func NewDefaultValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefaultValueContext {
	var p = new(DefaultValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_defaultValue

	return p
}

func (s *DefaultValueContext) GetParser() antlr.Parser { return s.parser }

func (s *DefaultValueContext) ConstValue() IConstValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstValueContext)
}

func (s *DefaultValueContext) STRING_WEBIDL() antlr.TerminalNode {
	return s.GetToken(WebIDLParserSTRING_WEBIDL, 0)
}

func (s *DefaultValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefaultValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterDefaultValue(s)
	}
}

func (s *DefaultValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitDefaultValue(s)
	}
}

func (p *WebIDLParser) DefaultValue() (localctx IDefaultValueContext) {
	this := p
	_ = this

	localctx = NewDefaultValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, WebIDLParserRULE_defaultValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(422)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__30, WebIDLParserT__31, WebIDLParserT__32, WebIDLParserT__33, WebIDLParserT__34, WebIDLParserINTEGER_WEBIDL, WebIDLParserDECIMAL_WEBIDL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(415)
			p.ConstValue()
		}

	case WebIDLParserSTRING_WEBIDL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(416)
			p.Match(WebIDLParserSTRING_WEBIDL)
		}

	case WebIDLParserT__35:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(417)
			p.Match(WebIDLParserT__35)
		}
		{
			p.SetState(418)
			p.Match(WebIDLParserT__36)
		}

	case WebIDLParserT__25:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(419)
			p.Match(WebIDLParserT__25)
		}
		{
			p.SetState(420)
			p.Match(WebIDLParserT__26)
		}

	case WebIDLParserT__37:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(421)
			p.Match(WebIDLParserT__37)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IOperationContext is an interface to support dynamic dispatch.
type IOperationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOperationContext differentiates from other interfaces.
	IsOperationContext()
}

type OperationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOperationContext() *OperationContext {
	var p = new(OperationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_operation
	return p
}

func (*OperationContext) IsOperationContext() {}

func NewOperationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OperationContext {
	var p = new(OperationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_operation

	return p
}

func (s *OperationContext) GetParser() antlr.Parser { return s.parser }

func (s *OperationContext) RegularOperation() IRegularOperationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRegularOperationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRegularOperationContext)
}

func (s *OperationContext) SpecialOperation() ISpecialOperationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecialOperationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpecialOperationContext)
}

func (s *OperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OperationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OperationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterOperation(s)
	}
}

func (s *OperationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitOperation(s)
	}
}

func (p *WebIDLParser) Operation() (localctx IOperationContext) {
	this := p
	_ = this

	localctx = NewOperationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, WebIDLParserRULE_operation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(426)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__24, WebIDLParserT__38, WebIDLParserT__45, WebIDLParserT__47, WebIDLParserT__48, WebIDLParserT__49, WebIDLParserT__50, WebIDLParserT__51, WebIDLParserT__52, WebIDLParserT__53, WebIDLParserT__54, WebIDLParserT__55, WebIDLParserT__56, WebIDLParserT__57, WebIDLParserT__58, WebIDLParserT__59, WebIDLParserT__60, WebIDLParserT__61, WebIDLParserT__62, WebIDLParserT__63, WebIDLParserT__64, WebIDLParserT__65, WebIDLParserT__66, WebIDLParserT__68, WebIDLParserT__69, WebIDLParserT__70, WebIDLParserT__71, WebIDLParserT__72, WebIDLParserT__73, WebIDLParserT__74, WebIDLParserT__75, WebIDLParserT__76, WebIDLParserT__77, WebIDLParserT__78, WebIDLParserIDENTIFIER_WEBIDL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(424)
			p.RegularOperation()
		}

	case WebIDLParserT__5, WebIDLParserT__8, WebIDLParserT__20:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(425)
			p.SpecialOperation()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IRegularOperationContext is an interface to support dynamic dispatch.
type IRegularOperationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRegularOperationContext differentiates from other interfaces.
	IsRegularOperationContext()
}

type RegularOperationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRegularOperationContext() *RegularOperationContext {
	var p = new(RegularOperationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_regularOperation
	return p
}

func (*RegularOperationContext) IsRegularOperationContext() {}

func NewRegularOperationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RegularOperationContext {
	var p = new(RegularOperationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_regularOperation

	return p
}

func (s *RegularOperationContext) GetParser() antlr.Parser { return s.parser }

func (s *RegularOperationContext) Type_() IType_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *RegularOperationContext) OperationRest() IOperationRestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOperationRestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOperationRestContext)
}

func (s *RegularOperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RegularOperationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RegularOperationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterRegularOperation(s)
	}
}

func (s *RegularOperationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitRegularOperation(s)
	}
}

func (p *WebIDLParser) RegularOperation() (localctx IRegularOperationContext) {
	this := p
	_ = this

	localctx = NewRegularOperationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, WebIDLParserRULE_regularOperation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(428)
		p.Type_()
	}
	{
		p.SetState(429)
		p.OperationRest()
	}

	return localctx
}

// ISpecialOperationContext is an interface to support dynamic dispatch.
type ISpecialOperationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSpecialOperationContext differentiates from other interfaces.
	IsSpecialOperationContext()
}

type SpecialOperationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpecialOperationContext() *SpecialOperationContext {
	var p = new(SpecialOperationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_specialOperation
	return p
}

func (*SpecialOperationContext) IsSpecialOperationContext() {}

func NewSpecialOperationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SpecialOperationContext {
	var p = new(SpecialOperationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_specialOperation

	return p
}

func (s *SpecialOperationContext) GetParser() antlr.Parser { return s.parser }

func (s *SpecialOperationContext) Special() ISpecialContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecialContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpecialContext)
}

func (s *SpecialOperationContext) RegularOperation() IRegularOperationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRegularOperationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRegularOperationContext)
}

func (s *SpecialOperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpecialOperationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SpecialOperationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterSpecialOperation(s)
	}
}

func (s *SpecialOperationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitSpecialOperation(s)
	}
}

func (p *WebIDLParser) SpecialOperation() (localctx ISpecialOperationContext) {
	this := p
	_ = this

	localctx = NewSpecialOperationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, WebIDLParserRULE_specialOperation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(431)
		p.Special()
	}
	{
		p.SetState(432)
		p.RegularOperation()
	}

	return localctx
}

// ISpecialContext is an interface to support dynamic dispatch.
type ISpecialContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSpecialContext differentiates from other interfaces.
	IsSpecialContext()
}

type SpecialContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpecialContext() *SpecialContext {
	var p = new(SpecialContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_special
	return p
}

func (*SpecialContext) IsSpecialContext() {}

func NewSpecialContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SpecialContext {
	var p = new(SpecialContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_special

	return p
}

func (s *SpecialContext) GetParser() antlr.Parser { return s.parser }
func (s *SpecialContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpecialContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SpecialContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterSpecial(s)
	}
}

func (s *SpecialContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitSpecial(s)
	}
}

func (p *WebIDLParser) Special() (localctx ISpecialContext) {
	this := p
	_ = this

	localctx = NewSpecialContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, WebIDLParserRULE_special)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(434)
		_la = p.GetTokenStream().LA(1)

		if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<WebIDLParserT__5)|(1<<WebIDLParserT__8)|(1<<WebIDLParserT__20))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IOperationRestContext is an interface to support dynamic dispatch.
type IOperationRestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOperationRestContext differentiates from other interfaces.
	IsOperationRestContext()
}

type OperationRestContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOperationRestContext() *OperationRestContext {
	var p = new(OperationRestContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_operationRest
	return p
}

func (*OperationRestContext) IsOperationRestContext() {}

func NewOperationRestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OperationRestContext {
	var p = new(OperationRestContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_operationRest

	return p
}

func (s *OperationRestContext) GetParser() antlr.Parser { return s.parser }

func (s *OperationRestContext) OptionalOperationName() IOptionalOperationNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOptionalOperationNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOptionalOperationNameContext)
}

func (s *OperationRestContext) ArgumentList() IArgumentListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgumentListContext)
}

func (s *OperationRestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OperationRestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OperationRestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterOperationRest(s)
	}
}

func (s *OperationRestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitOperationRest(s)
	}
}

func (p *WebIDLParser) OperationRest() (localctx IOperationRestContext) {
	this := p
	_ = this

	localctx = NewOperationRestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, WebIDLParserRULE_operationRest)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(436)
		p.OptionalOperationName()
	}
	{
		p.SetState(437)
		p.Match(WebIDLParserT__38)
	}
	{
		p.SetState(438)
		p.ArgumentList()
	}
	{
		p.SetState(439)
		p.Match(WebIDLParserT__39)
	}
	{
		p.SetState(440)
		p.Match(WebIDLParserT__27)
	}

	return localctx
}

// IOptionalOperationNameContext is an interface to support dynamic dispatch.
type IOptionalOperationNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOptionalOperationNameContext differentiates from other interfaces.
	IsOptionalOperationNameContext()
}

type OptionalOperationNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptionalOperationNameContext() *OptionalOperationNameContext {
	var p = new(OptionalOperationNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_optionalOperationName
	return p
}

func (*OptionalOperationNameContext) IsOptionalOperationNameContext() {}

func NewOptionalOperationNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptionalOperationNameContext {
	var p = new(OptionalOperationNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_optionalOperationName

	return p
}

func (s *OptionalOperationNameContext) GetParser() antlr.Parser { return s.parser }

func (s *OptionalOperationNameContext) OperationName() IOperationNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOperationNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOperationNameContext)
}

func (s *OptionalOperationNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptionalOperationNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptionalOperationNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterOptionalOperationName(s)
	}
}

func (s *OptionalOperationNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitOptionalOperationName(s)
	}
}

func (p *WebIDLParser) OptionalOperationName() (localctx IOptionalOperationNameContext) {
	this := p
	_ = this

	localctx = NewOptionalOperationNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, WebIDLParserRULE_optionalOperationName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(444)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__9, WebIDLParserIDENTIFIER_WEBIDL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(442)
			p.OperationName()
		}

	case WebIDLParserT__38:
		p.EnterOuterAlt(localctx, 2)

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IOperationNameContext is an interface to support dynamic dispatch.
type IOperationNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOperationNameContext differentiates from other interfaces.
	IsOperationNameContext()
}

type OperationNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOperationNameContext() *OperationNameContext {
	var p = new(OperationNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_operationName
	return p
}

func (*OperationNameContext) IsOperationNameContext() {}

func NewOperationNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OperationNameContext {
	var p = new(OperationNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_operationName

	return p
}

func (s *OperationNameContext) GetParser() antlr.Parser { return s.parser }

func (s *OperationNameContext) OperationNameKeyword() IOperationNameKeywordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOperationNameKeywordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOperationNameKeywordContext)
}

func (s *OperationNameContext) IDENTIFIER_WEBIDL() antlr.TerminalNode {
	return s.GetToken(WebIDLParserIDENTIFIER_WEBIDL, 0)
}

func (s *OperationNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OperationNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OperationNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterOperationName(s)
	}
}

func (s *OperationNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitOperationName(s)
	}
}

func (p *WebIDLParser) OperationName() (localctx IOperationNameContext) {
	this := p
	_ = this

	localctx = NewOperationNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, WebIDLParserRULE_operationName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(448)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__9:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(446)
			p.OperationNameKeyword()
		}

	case WebIDLParserIDENTIFIER_WEBIDL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(447)
			p.Match(WebIDLParserIDENTIFIER_WEBIDL)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IOperationNameKeywordContext is an interface to support dynamic dispatch.
type IOperationNameKeywordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOperationNameKeywordContext differentiates from other interfaces.
	IsOperationNameKeywordContext()
}

type OperationNameKeywordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOperationNameKeywordContext() *OperationNameKeywordContext {
	var p = new(OperationNameKeywordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_operationNameKeyword
	return p
}

func (*OperationNameKeywordContext) IsOperationNameKeywordContext() {}

func NewOperationNameKeywordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OperationNameKeywordContext {
	var p = new(OperationNameKeywordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_operationNameKeyword

	return p
}

func (s *OperationNameKeywordContext) GetParser() antlr.Parser { return s.parser }
func (s *OperationNameKeywordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OperationNameKeywordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OperationNameKeywordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterOperationNameKeyword(s)
	}
}

func (s *OperationNameKeywordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitOperationNameKeyword(s)
	}
}

func (p *WebIDLParser) OperationNameKeyword() (localctx IOperationNameKeywordContext) {
	this := p
	_ = this

	localctx = NewOperationNameKeywordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, WebIDLParserRULE_operationNameKeyword)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(450)
		p.Match(WebIDLParserT__9)
	}

	return localctx
}

// IArgumentListContext is an interface to support dynamic dispatch.
type IArgumentListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArgumentListContext differentiates from other interfaces.
	IsArgumentListContext()
}

type ArgumentListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentListContext() *ArgumentListContext {
	var p = new(ArgumentListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_argumentList
	return p
}

func (*ArgumentListContext) IsArgumentListContext() {}

func NewArgumentListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentListContext {
	var p = new(ArgumentListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_argumentList

	return p
}

func (s *ArgumentListContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentListContext) Argument() IArgumentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgumentContext)
}

func (s *ArgumentListContext) Arguments() IArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *ArgumentListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterArgumentList(s)
	}
}

func (s *ArgumentListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitArgumentList(s)
	}
}

func (p *WebIDLParser) ArgumentList() (localctx IArgumentListContext) {
	this := p
	_ = this

	localctx = NewArgumentListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, WebIDLParserRULE_argumentList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(456)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__24, WebIDLParserT__35, WebIDLParserT__38, WebIDLParserT__41, WebIDLParserT__45, WebIDLParserT__47, WebIDLParserT__48, WebIDLParserT__49, WebIDLParserT__50, WebIDLParserT__51, WebIDLParserT__52, WebIDLParserT__53, WebIDLParserT__54, WebIDLParserT__55, WebIDLParserT__56, WebIDLParserT__57, WebIDLParserT__58, WebIDLParserT__59, WebIDLParserT__60, WebIDLParserT__61, WebIDLParserT__62, WebIDLParserT__63, WebIDLParserT__64, WebIDLParserT__65, WebIDLParserT__66, WebIDLParserT__68, WebIDLParserT__69, WebIDLParserT__70, WebIDLParserT__71, WebIDLParserT__72, WebIDLParserT__73, WebIDLParserT__74, WebIDLParserT__75, WebIDLParserT__76, WebIDLParserT__77, WebIDLParserT__78, WebIDLParserIDENTIFIER_WEBIDL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(452)
			p.Argument()
		}
		{
			p.SetState(453)
			p.Arguments()
		}

	case WebIDLParserT__39:
		p.EnterOuterAlt(localctx, 2)

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IArgumentsContext is an interface to support dynamic dispatch.
type IArgumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArgumentsContext differentiates from other interfaces.
	IsArgumentsContext()
}

type ArgumentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentsContext() *ArgumentsContext {
	var p = new(ArgumentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_arguments
	return p
}

func (*ArgumentsContext) IsArgumentsContext() {}

func NewArgumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentsContext {
	var p = new(ArgumentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_arguments

	return p
}

func (s *ArgumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentsContext) Argument() IArgumentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgumentContext)
}

func (s *ArgumentsContext) Arguments() IArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *ArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterArguments(s)
	}
}

func (s *ArgumentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitArguments(s)
	}
}

func (p *WebIDLParser) Arguments() (localctx IArgumentsContext) {
	this := p
	_ = this

	localctx = NewArgumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, WebIDLParserRULE_arguments)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(463)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__40:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(458)
			p.Match(WebIDLParserT__40)
		}
		{
			p.SetState(459)
			p.Argument()
		}
		{
			p.SetState(460)
			p.Arguments()
		}

	case WebIDLParserT__39:
		p.EnterOuterAlt(localctx, 2)

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IArgumentContext is an interface to support dynamic dispatch.
type IArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArgumentContext differentiates from other interfaces.
	IsArgumentContext()
}

type ArgumentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentContext() *ArgumentContext {
	var p = new(ArgumentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_argument
	return p
}

func (*ArgumentContext) IsArgumentContext() {}

func NewArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentContext {
	var p = new(ArgumentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_argument

	return p
}

func (s *ArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentContext) ExtendedAttributeList() IExtendedAttributeListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtendedAttributeListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtendedAttributeListContext)
}

func (s *ArgumentContext) ArgumentRest() IArgumentRestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentRestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgumentRestContext)
}

func (s *ArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterArgument(s)
	}
}

func (s *ArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitArgument(s)
	}
}

func (p *WebIDLParser) Argument() (localctx IArgumentContext) {
	this := p
	_ = this

	localctx = NewArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, WebIDLParserRULE_argument)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(465)
		p.ExtendedAttributeList()
	}
	{
		p.SetState(466)
		p.ArgumentRest()
	}

	return localctx
}

// IArgumentRestContext is an interface to support dynamic dispatch.
type IArgumentRestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArgumentRestContext differentiates from other interfaces.
	IsArgumentRestContext()
}

type ArgumentRestContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentRestContext() *ArgumentRestContext {
	var p = new(ArgumentRestContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_argumentRest
	return p
}

func (*ArgumentRestContext) IsArgumentRestContext() {}

func NewArgumentRestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentRestContext {
	var p = new(ArgumentRestContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_argumentRest

	return p
}

func (s *ArgumentRestContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentRestContext) TypeWithExtendedAttributes() ITypeWithExtendedAttributesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeWithExtendedAttributesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeWithExtendedAttributesContext)
}

func (s *ArgumentRestContext) ArgumentName() IArgumentNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgumentNameContext)
}

func (s *ArgumentRestContext) Default_() IDefault_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefault_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefault_Context)
}

func (s *ArgumentRestContext) Type_() IType_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *ArgumentRestContext) Ellipsis() IEllipsisContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEllipsisContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEllipsisContext)
}

func (s *ArgumentRestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentRestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentRestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterArgumentRest(s)
	}
}

func (s *ArgumentRestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitArgumentRest(s)
	}
}

func (p *WebIDLParser) ArgumentRest() (localctx IArgumentRestContext) {
	this := p
	_ = this

	localctx = NewArgumentRestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, WebIDLParserRULE_argumentRest)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(477)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__41:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(468)
			p.Match(WebIDLParserT__41)
		}
		{
			p.SetState(469)
			p.TypeWithExtendedAttributes()
		}
		{
			p.SetState(470)
			p.ArgumentName()
		}
		{
			p.SetState(471)
			p.Default_()
		}

	case WebIDLParserT__24, WebIDLParserT__38, WebIDLParserT__45, WebIDLParserT__47, WebIDLParserT__48, WebIDLParserT__49, WebIDLParserT__50, WebIDLParserT__51, WebIDLParserT__52, WebIDLParserT__53, WebIDLParserT__54, WebIDLParserT__55, WebIDLParserT__56, WebIDLParserT__57, WebIDLParserT__58, WebIDLParserT__59, WebIDLParserT__60, WebIDLParserT__61, WebIDLParserT__62, WebIDLParserT__63, WebIDLParserT__64, WebIDLParserT__65, WebIDLParserT__66, WebIDLParserT__68, WebIDLParserT__69, WebIDLParserT__70, WebIDLParserT__71, WebIDLParserT__72, WebIDLParserT__73, WebIDLParserT__74, WebIDLParserT__75, WebIDLParserT__76, WebIDLParserT__77, WebIDLParserT__78, WebIDLParserIDENTIFIER_WEBIDL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(473)
			p.Type_()
		}
		{
			p.SetState(474)
			p.Ellipsis()
		}
		{
			p.SetState(475)
			p.ArgumentName()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IArgumentNameContext is an interface to support dynamic dispatch.
type IArgumentNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArgumentNameContext differentiates from other interfaces.
	IsArgumentNameContext()
}

type ArgumentNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentNameContext() *ArgumentNameContext {
	var p = new(ArgumentNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_argumentName
	return p
}

func (*ArgumentNameContext) IsArgumentNameContext() {}

func NewArgumentNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentNameContext {
	var p = new(ArgumentNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_argumentName

	return p
}

func (s *ArgumentNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentNameContext) ArgumentNameKeyword() IArgumentNameKeywordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentNameKeywordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgumentNameKeywordContext)
}

func (s *ArgumentNameContext) IDENTIFIER_WEBIDL() antlr.TerminalNode {
	return s.GetToken(WebIDLParserIDENTIFIER_WEBIDL, 0)
}

func (s *ArgumentNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterArgumentName(s)
	}
}

func (s *ArgumentNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitArgumentName(s)
	}
}

func (p *WebIDLParser) ArgumentName() (localctx IArgumentNameContext) {
	this := p
	_ = this

	localctx = NewArgumentNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, WebIDLParserRULE_argumentName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(481)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__0, WebIDLParserT__1, WebIDLParserT__2, WebIDLParserT__3, WebIDLParserT__4, WebIDLParserT__5, WebIDLParserT__6, WebIDLParserT__7, WebIDLParserT__8, WebIDLParserT__9, WebIDLParserT__10, WebIDLParserT__11, WebIDLParserT__12, WebIDLParserT__13, WebIDLParserT__14, WebIDLParserT__15, WebIDLParserT__16, WebIDLParserT__17, WebIDLParserT__18, WebIDLParserT__19, WebIDLParserT__20, WebIDLParserT__21, WebIDLParserT__22, WebIDLParserT__23, WebIDLParserT__24:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(479)
			p.ArgumentNameKeyword()
		}

	case WebIDLParserIDENTIFIER_WEBIDL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(480)
			p.Match(WebIDLParserIDENTIFIER_WEBIDL)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IEllipsisContext is an interface to support dynamic dispatch.
type IEllipsisContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEllipsisContext differentiates from other interfaces.
	IsEllipsisContext()
}

type EllipsisContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEllipsisContext() *EllipsisContext {
	var p = new(EllipsisContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_ellipsis
	return p
}

func (*EllipsisContext) IsEllipsisContext() {}

func NewEllipsisContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EllipsisContext {
	var p = new(EllipsisContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_ellipsis

	return p
}

func (s *EllipsisContext) GetParser() antlr.Parser { return s.parser }
func (s *EllipsisContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EllipsisContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EllipsisContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterEllipsis(s)
	}
}

func (s *EllipsisContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitEllipsis(s)
	}
}

func (p *WebIDLParser) Ellipsis() (localctx IEllipsisContext) {
	this := p
	_ = this

	localctx = NewEllipsisContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, WebIDLParserRULE_ellipsis)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(485)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__42:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(483)
			p.Match(WebIDLParserT__42)
		}

	case WebIDLParserT__0, WebIDLParserT__1, WebIDLParserT__2, WebIDLParserT__3, WebIDLParserT__4, WebIDLParserT__5, WebIDLParserT__6, WebIDLParserT__7, WebIDLParserT__8, WebIDLParserT__9, WebIDLParserT__10, WebIDLParserT__11, WebIDLParserT__12, WebIDLParserT__13, WebIDLParserT__14, WebIDLParserT__15, WebIDLParserT__16, WebIDLParserT__17, WebIDLParserT__18, WebIDLParserT__19, WebIDLParserT__20, WebIDLParserT__21, WebIDLParserT__22, WebIDLParserT__23, WebIDLParserT__24, WebIDLParserIDENTIFIER_WEBIDL:
		p.EnterOuterAlt(localctx, 2)

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IConstructorContext is an interface to support dynamic dispatch.
type IConstructorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstructorContext differentiates from other interfaces.
	IsConstructorContext()
}

type ConstructorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstructorContext() *ConstructorContext {
	var p = new(ConstructorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_constructor
	return p
}

func (*ConstructorContext) IsConstructorContext() {}

func NewConstructorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstructorContext {
	var p = new(ConstructorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_constructor

	return p
}

func (s *ConstructorContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstructorContext) ArgumentList() IArgumentListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgumentListContext)
}

func (s *ConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstructorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterConstructor(s)
	}
}

func (s *ConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitConstructor(s)
	}
}

func (p *WebIDLParser) Constructor() (localctx IConstructorContext) {
	this := p
	_ = this

	localctx = NewConstructorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, WebIDLParserRULE_constructor)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(487)
		p.Match(WebIDLParserT__4)
	}
	{
		p.SetState(488)
		p.Match(WebIDLParserT__38)
	}
	{
		p.SetState(489)
		p.ArgumentList()
	}
	{
		p.SetState(490)
		p.Match(WebIDLParserT__39)
	}
	{
		p.SetState(491)
		p.Match(WebIDLParserT__27)
	}

	return localctx
}

// IStringifierContext is an interface to support dynamic dispatch.
type IStringifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStringifierContext differentiates from other interfaces.
	IsStringifierContext()
}

type StringifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringifierContext() *StringifierContext {
	var p = new(StringifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_stringifier
	return p
}

func (*StringifierContext) IsStringifierContext() {}

func NewStringifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringifierContext {
	var p = new(StringifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_stringifier

	return p
}

func (s *StringifierContext) GetParser() antlr.Parser { return s.parser }

func (s *StringifierContext) StringifierRest() IStringifierRestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStringifierRestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStringifierRestContext)
}

func (s *StringifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterStringifier(s)
	}
}

func (s *StringifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitStringifier(s)
	}
}

func (p *WebIDLParser) Stringifier() (localctx IStringifierContext) {
	this := p
	_ = this

	localctx = NewStringifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, WebIDLParserRULE_stringifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(493)
		p.Match(WebIDLParserT__22)
	}
	{
		p.SetState(494)
		p.StringifierRest()
	}

	return localctx
}

// IStringifierRestContext is an interface to support dynamic dispatch.
type IStringifierRestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStringifierRestContext differentiates from other interfaces.
	IsStringifierRestContext()
}

type StringifierRestContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringifierRestContext() *StringifierRestContext {
	var p = new(StringifierRestContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_stringifierRest
	return p
}

func (*StringifierRestContext) IsStringifierRestContext() {}

func NewStringifierRestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringifierRestContext {
	var p = new(StringifierRestContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_stringifierRest

	return p
}

func (s *StringifierRestContext) GetParser() antlr.Parser { return s.parser }

func (s *StringifierRestContext) OptionalReadOnly() IOptionalReadOnlyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOptionalReadOnlyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOptionalReadOnlyContext)
}

func (s *StringifierRestContext) AttributeRest() IAttributeRestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttributeRestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttributeRestContext)
}

func (s *StringifierRestContext) RegularOperation() IRegularOperationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRegularOperationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRegularOperationContext)
}

func (s *StringifierRestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringifierRestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringifierRestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterStringifierRest(s)
	}
}

func (s *StringifierRestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitStringifierRest(s)
	}
}

func (p *WebIDLParser) StringifierRest() (localctx IStringifierRestContext) {
	this := p
	_ = this

	localctx = NewStringifierRestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, WebIDLParserRULE_stringifierRest)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(501)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__1, WebIDLParserT__17:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(496)
			p.OptionalReadOnly()
		}
		{
			p.SetState(497)
			p.AttributeRest()
		}

	case WebIDLParserT__24, WebIDLParserT__38, WebIDLParserT__45, WebIDLParserT__47, WebIDLParserT__48, WebIDLParserT__49, WebIDLParserT__50, WebIDLParserT__51, WebIDLParserT__52, WebIDLParserT__53, WebIDLParserT__54, WebIDLParserT__55, WebIDLParserT__56, WebIDLParserT__57, WebIDLParserT__58, WebIDLParserT__59, WebIDLParserT__60, WebIDLParserT__61, WebIDLParserT__62, WebIDLParserT__63, WebIDLParserT__64, WebIDLParserT__65, WebIDLParserT__66, WebIDLParserT__68, WebIDLParserT__69, WebIDLParserT__70, WebIDLParserT__71, WebIDLParserT__72, WebIDLParserT__73, WebIDLParserT__74, WebIDLParserT__75, WebIDLParserT__76, WebIDLParserT__77, WebIDLParserT__78, WebIDLParserIDENTIFIER_WEBIDL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(499)
			p.RegularOperation()
		}

	case WebIDLParserT__27:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(500)
			p.Match(WebIDLParserT__27)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IStaticMemberContext is an interface to support dynamic dispatch.
type IStaticMemberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStaticMemberContext differentiates from other interfaces.
	IsStaticMemberContext()
}

type StaticMemberContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStaticMemberContext() *StaticMemberContext {
	var p = new(StaticMemberContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_staticMember
	return p
}

func (*StaticMemberContext) IsStaticMemberContext() {}

func NewStaticMemberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StaticMemberContext {
	var p = new(StaticMemberContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_staticMember

	return p
}

func (s *StaticMemberContext) GetParser() antlr.Parser { return s.parser }

func (s *StaticMemberContext) StaticMemberRest() IStaticMemberRestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStaticMemberRestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStaticMemberRestContext)
}

func (s *StaticMemberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StaticMemberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StaticMemberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterStaticMember(s)
	}
}

func (s *StaticMemberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitStaticMember(s)
	}
}

func (p *WebIDLParser) StaticMember() (localctx IStaticMemberContext) {
	this := p
	_ = this

	localctx = NewStaticMemberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, WebIDLParserRULE_staticMember)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(503)
		p.Match(WebIDLParserT__21)
	}
	{
		p.SetState(504)
		p.StaticMemberRest()
	}

	return localctx
}

// IStaticMemberRestContext is an interface to support dynamic dispatch.
type IStaticMemberRestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStaticMemberRestContext differentiates from other interfaces.
	IsStaticMemberRestContext()
}

type StaticMemberRestContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStaticMemberRestContext() *StaticMemberRestContext {
	var p = new(StaticMemberRestContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_staticMemberRest
	return p
}

func (*StaticMemberRestContext) IsStaticMemberRestContext() {}

func NewStaticMemberRestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StaticMemberRestContext {
	var p = new(StaticMemberRestContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_staticMemberRest

	return p
}

func (s *StaticMemberRestContext) GetParser() antlr.Parser { return s.parser }

func (s *StaticMemberRestContext) OptionalReadOnly() IOptionalReadOnlyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOptionalReadOnlyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOptionalReadOnlyContext)
}

func (s *StaticMemberRestContext) AttributeRest() IAttributeRestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttributeRestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttributeRestContext)
}

func (s *StaticMemberRestContext) RegularOperation() IRegularOperationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRegularOperationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRegularOperationContext)
}

func (s *StaticMemberRestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StaticMemberRestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StaticMemberRestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterStaticMemberRest(s)
	}
}

func (s *StaticMemberRestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitStaticMemberRest(s)
	}
}

func (p *WebIDLParser) StaticMemberRest() (localctx IStaticMemberRestContext) {
	this := p
	_ = this

	localctx = NewStaticMemberRestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, WebIDLParserRULE_staticMemberRest)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(510)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__1, WebIDLParserT__17:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(506)
			p.OptionalReadOnly()
		}
		{
			p.SetState(507)
			p.AttributeRest()
		}

	case WebIDLParserT__24, WebIDLParserT__38, WebIDLParserT__45, WebIDLParserT__47, WebIDLParserT__48, WebIDLParserT__49, WebIDLParserT__50, WebIDLParserT__51, WebIDLParserT__52, WebIDLParserT__53, WebIDLParserT__54, WebIDLParserT__55, WebIDLParserT__56, WebIDLParserT__57, WebIDLParserT__58, WebIDLParserT__59, WebIDLParserT__60, WebIDLParserT__61, WebIDLParserT__62, WebIDLParserT__63, WebIDLParserT__64, WebIDLParserT__65, WebIDLParserT__66, WebIDLParserT__68, WebIDLParserT__69, WebIDLParserT__70, WebIDLParserT__71, WebIDLParserT__72, WebIDLParserT__73, WebIDLParserT__74, WebIDLParserT__75, WebIDLParserT__76, WebIDLParserT__77, WebIDLParserT__78, WebIDLParserIDENTIFIER_WEBIDL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(509)
			p.RegularOperation()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IIterableContext is an interface to support dynamic dispatch.
type IIterableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIterableContext differentiates from other interfaces.
	IsIterableContext()
}

type IterableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIterableContext() *IterableContext {
	var p = new(IterableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_iterable
	return p
}

func (*IterableContext) IsIterableContext() {}

func NewIterableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IterableContext {
	var p = new(IterableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_iterable

	return p
}

func (s *IterableContext) GetParser() antlr.Parser { return s.parser }

func (s *IterableContext) TypeWithExtendedAttributes() ITypeWithExtendedAttributesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeWithExtendedAttributesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeWithExtendedAttributesContext)
}

func (s *IterableContext) OptionalType() IOptionalTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOptionalTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOptionalTypeContext)
}

func (s *IterableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IterableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IterableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterIterable(s)
	}
}

func (s *IterableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitIterable(s)
	}
}

func (p *WebIDLParser) Iterable() (localctx IIterableContext) {
	this := p
	_ = this

	localctx = NewIterableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, WebIDLParserRULE_iterable)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(512)
		p.Match(WebIDLParserT__12)
	}
	{
		p.SetState(513)
		p.Match(WebIDLParserT__43)
	}
	{
		p.SetState(514)
		p.TypeWithExtendedAttributes()
	}
	{
		p.SetState(515)
		p.OptionalType()
	}
	{
		p.SetState(516)
		p.Match(WebIDLParserT__44)
	}
	{
		p.SetState(517)
		p.Match(WebIDLParserT__27)
	}

	return localctx
}

// IOptionalTypeContext is an interface to support dynamic dispatch.
type IOptionalTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOptionalTypeContext differentiates from other interfaces.
	IsOptionalTypeContext()
}

type OptionalTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptionalTypeContext() *OptionalTypeContext {
	var p = new(OptionalTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_optionalType
	return p
}

func (*OptionalTypeContext) IsOptionalTypeContext() {}

func NewOptionalTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptionalTypeContext {
	var p = new(OptionalTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_optionalType

	return p
}

func (s *OptionalTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *OptionalTypeContext) TypeWithExtendedAttributes() ITypeWithExtendedAttributesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeWithExtendedAttributesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeWithExtendedAttributesContext)
}

func (s *OptionalTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptionalTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptionalTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterOptionalType(s)
	}
}

func (s *OptionalTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitOptionalType(s)
	}
}

func (p *WebIDLParser) OptionalType() (localctx IOptionalTypeContext) {
	this := p
	_ = this

	localctx = NewOptionalTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, WebIDLParserRULE_optionalType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(522)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__40:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(519)
			p.Match(WebIDLParserT__40)
		}
		{
			p.SetState(520)
			p.TypeWithExtendedAttributes()
		}

	case WebIDLParserT__44:
		p.EnterOuterAlt(localctx, 2)

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAsyncIterableContext is an interface to support dynamic dispatch.
type IAsyncIterableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAsyncIterableContext differentiates from other interfaces.
	IsAsyncIterableContext()
}

type AsyncIterableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAsyncIterableContext() *AsyncIterableContext {
	var p = new(AsyncIterableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_asyncIterable
	return p
}

func (*AsyncIterableContext) IsAsyncIterableContext() {}

func NewAsyncIterableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AsyncIterableContext {
	var p = new(AsyncIterableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_asyncIterable

	return p
}

func (s *AsyncIterableContext) GetParser() antlr.Parser { return s.parser }

func (s *AsyncIterableContext) TypeWithExtendedAttributes() ITypeWithExtendedAttributesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeWithExtendedAttributesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeWithExtendedAttributesContext)
}

func (s *AsyncIterableContext) OptionalType() IOptionalTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOptionalTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOptionalTypeContext)
}

func (s *AsyncIterableContext) OptionalArgumentList() IOptionalArgumentListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOptionalArgumentListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOptionalArgumentListContext)
}

func (s *AsyncIterableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AsyncIterableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AsyncIterableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterAsyncIterable(s)
	}
}

func (s *AsyncIterableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitAsyncIterable(s)
	}
}

func (p *WebIDLParser) AsyncIterable() (localctx IAsyncIterableContext) {
	this := p
	_ = this

	localctx = NewAsyncIterableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, WebIDLParserRULE_asyncIterable)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(524)
		p.Match(WebIDLParserT__0)
	}
	{
		p.SetState(525)
		p.Match(WebIDLParserT__12)
	}
	{
		p.SetState(526)
		p.Match(WebIDLParserT__43)
	}
	{
		p.SetState(527)
		p.TypeWithExtendedAttributes()
	}
	{
		p.SetState(528)
		p.OptionalType()
	}
	{
		p.SetState(529)
		p.Match(WebIDLParserT__44)
	}
	{
		p.SetState(530)
		p.OptionalArgumentList()
	}
	{
		p.SetState(531)
		p.Match(WebIDLParserT__27)
	}

	return localctx
}

// IOptionalArgumentListContext is an interface to support dynamic dispatch.
type IOptionalArgumentListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOptionalArgumentListContext differentiates from other interfaces.
	IsOptionalArgumentListContext()
}

type OptionalArgumentListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptionalArgumentListContext() *OptionalArgumentListContext {
	var p = new(OptionalArgumentListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_optionalArgumentList
	return p
}

func (*OptionalArgumentListContext) IsOptionalArgumentListContext() {}

func NewOptionalArgumentListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptionalArgumentListContext {
	var p = new(OptionalArgumentListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_optionalArgumentList

	return p
}

func (s *OptionalArgumentListContext) GetParser() antlr.Parser { return s.parser }

func (s *OptionalArgumentListContext) ArgumentList() IArgumentListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgumentListContext)
}

func (s *OptionalArgumentListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptionalArgumentListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptionalArgumentListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterOptionalArgumentList(s)
	}
}

func (s *OptionalArgumentListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitOptionalArgumentList(s)
	}
}

func (p *WebIDLParser) OptionalArgumentList() (localctx IOptionalArgumentListContext) {
	this := p
	_ = this

	localctx = NewOptionalArgumentListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, WebIDLParserRULE_optionalArgumentList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(538)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__38:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(533)
			p.Match(WebIDLParserT__38)
		}
		{
			p.SetState(534)
			p.ArgumentList()
		}
		{
			p.SetState(535)
			p.Match(WebIDLParserT__39)
		}

	case WebIDLParserT__27:
		p.EnterOuterAlt(localctx, 2)

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IReadWriteMaplikeContext is an interface to support dynamic dispatch.
type IReadWriteMaplikeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReadWriteMaplikeContext differentiates from other interfaces.
	IsReadWriteMaplikeContext()
}

type ReadWriteMaplikeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReadWriteMaplikeContext() *ReadWriteMaplikeContext {
	var p = new(ReadWriteMaplikeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_readWriteMaplike
	return p
}

func (*ReadWriteMaplikeContext) IsReadWriteMaplikeContext() {}

func NewReadWriteMaplikeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReadWriteMaplikeContext {
	var p = new(ReadWriteMaplikeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_readWriteMaplike

	return p
}

func (s *ReadWriteMaplikeContext) GetParser() antlr.Parser { return s.parser }

func (s *ReadWriteMaplikeContext) MaplikeRest() IMaplikeRestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMaplikeRestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMaplikeRestContext)
}

func (s *ReadWriteMaplikeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReadWriteMaplikeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReadWriteMaplikeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterReadWriteMaplike(s)
	}
}

func (s *ReadWriteMaplikeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitReadWriteMaplike(s)
	}
}

func (p *WebIDLParser) ReadWriteMaplike() (localctx IReadWriteMaplikeContext) {
	this := p
	_ = this

	localctx = NewReadWriteMaplikeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, WebIDLParserRULE_readWriteMaplike)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(540)
		p.MaplikeRest()
	}

	return localctx
}

// IMaplikeRestContext is an interface to support dynamic dispatch.
type IMaplikeRestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMaplikeRestContext differentiates from other interfaces.
	IsMaplikeRestContext()
}

type MaplikeRestContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMaplikeRestContext() *MaplikeRestContext {
	var p = new(MaplikeRestContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_maplikeRest
	return p
}

func (*MaplikeRestContext) IsMaplikeRestContext() {}

func NewMaplikeRestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MaplikeRestContext {
	var p = new(MaplikeRestContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_maplikeRest

	return p
}

func (s *MaplikeRestContext) GetParser() antlr.Parser { return s.parser }

func (s *MaplikeRestContext) AllTypeWithExtendedAttributes() []ITypeWithExtendedAttributesContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITypeWithExtendedAttributesContext)(nil)).Elem())
	var tst = make([]ITypeWithExtendedAttributesContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITypeWithExtendedAttributesContext)
		}
	}

	return tst
}

func (s *MaplikeRestContext) TypeWithExtendedAttributes(i int) ITypeWithExtendedAttributesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeWithExtendedAttributesContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITypeWithExtendedAttributesContext)
}

func (s *MaplikeRestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MaplikeRestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MaplikeRestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterMaplikeRest(s)
	}
}

func (s *MaplikeRestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitMaplikeRest(s)
	}
}

func (p *WebIDLParser) MaplikeRest() (localctx IMaplikeRestContext) {
	this := p
	_ = this

	localctx = NewMaplikeRestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, WebIDLParserRULE_maplikeRest)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(542)
		p.Match(WebIDLParserT__13)
	}
	{
		p.SetState(543)
		p.Match(WebIDLParserT__43)
	}
	{
		p.SetState(544)
		p.TypeWithExtendedAttributes()
	}
	{
		p.SetState(545)
		p.Match(WebIDLParserT__40)
	}
	{
		p.SetState(546)
		p.TypeWithExtendedAttributes()
	}
	{
		p.SetState(547)
		p.Match(WebIDLParserT__44)
	}
	{
		p.SetState(548)
		p.Match(WebIDLParserT__27)
	}

	return localctx
}

// IReadWriteSetlikeContext is an interface to support dynamic dispatch.
type IReadWriteSetlikeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReadWriteSetlikeContext differentiates from other interfaces.
	IsReadWriteSetlikeContext()
}

type ReadWriteSetlikeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReadWriteSetlikeContext() *ReadWriteSetlikeContext {
	var p = new(ReadWriteSetlikeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_readWriteSetlike
	return p
}

func (*ReadWriteSetlikeContext) IsReadWriteSetlikeContext() {}

func NewReadWriteSetlikeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReadWriteSetlikeContext {
	var p = new(ReadWriteSetlikeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_readWriteSetlike

	return p
}

func (s *ReadWriteSetlikeContext) GetParser() antlr.Parser { return s.parser }

func (s *ReadWriteSetlikeContext) SetlikeRest() ISetlikeRestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetlikeRestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISetlikeRestContext)
}

func (s *ReadWriteSetlikeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReadWriteSetlikeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReadWriteSetlikeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterReadWriteSetlike(s)
	}
}

func (s *ReadWriteSetlikeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitReadWriteSetlike(s)
	}
}

func (p *WebIDLParser) ReadWriteSetlike() (localctx IReadWriteSetlikeContext) {
	this := p
	_ = this

	localctx = NewReadWriteSetlikeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, WebIDLParserRULE_readWriteSetlike)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(550)
		p.SetlikeRest()
	}

	return localctx
}

// ISetlikeRestContext is an interface to support dynamic dispatch.
type ISetlikeRestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSetlikeRestContext differentiates from other interfaces.
	IsSetlikeRestContext()
}

type SetlikeRestContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetlikeRestContext() *SetlikeRestContext {
	var p = new(SetlikeRestContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_setlikeRest
	return p
}

func (*SetlikeRestContext) IsSetlikeRestContext() {}

func NewSetlikeRestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetlikeRestContext {
	var p = new(SetlikeRestContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_setlikeRest

	return p
}

func (s *SetlikeRestContext) GetParser() antlr.Parser { return s.parser }

func (s *SetlikeRestContext) TypeWithExtendedAttributes() ITypeWithExtendedAttributesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeWithExtendedAttributesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeWithExtendedAttributesContext)
}

func (s *SetlikeRestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetlikeRestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetlikeRestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterSetlikeRest(s)
	}
}

func (s *SetlikeRestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitSetlikeRest(s)
	}
}

func (p *WebIDLParser) SetlikeRest() (localctx ISetlikeRestContext) {
	this := p
	_ = this

	localctx = NewSetlikeRestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, WebIDLParserRULE_setlikeRest)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(552)
		p.Match(WebIDLParserT__19)
	}
	{
		p.SetState(553)
		p.Match(WebIDLParserT__43)
	}
	{
		p.SetState(554)
		p.TypeWithExtendedAttributes()
	}
	{
		p.SetState(555)
		p.Match(WebIDLParserT__44)
	}
	{
		p.SetState(556)
		p.Match(WebIDLParserT__27)
	}

	return localctx
}

// INamespace_Context is an interface to support dynamic dispatch.
type INamespace_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNamespace_Context differentiates from other interfaces.
	IsNamespace_Context()
}

type Namespace_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamespace_Context() *Namespace_Context {
	var p = new(Namespace_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_namespace_
	return p
}

func (*Namespace_Context) IsNamespace_Context() {}

func NewNamespace_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Namespace_Context {
	var p = new(Namespace_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_namespace_

	return p
}

func (s *Namespace_Context) GetParser() antlr.Parser { return s.parser }

func (s *Namespace_Context) IDENTIFIER_WEBIDL() antlr.TerminalNode {
	return s.GetToken(WebIDLParserIDENTIFIER_WEBIDL, 0)
}

func (s *Namespace_Context) NamespaceMembers() INamespaceMembersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamespaceMembersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INamespaceMembersContext)
}

func (s *Namespace_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Namespace_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Namespace_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterNamespace_(s)
	}
}

func (s *Namespace_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitNamespace_(s)
	}
}

func (p *WebIDLParser) Namespace_() (localctx INamespace_Context) {
	this := p
	_ = this

	localctx = NewNamespace_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, WebIDLParserRULE_namespace_)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(558)
		p.Match(WebIDLParserT__15)
	}
	{
		p.SetState(559)
		p.Match(WebIDLParserIDENTIFIER_WEBIDL)
	}
	{
		p.SetState(560)
		p.Match(WebIDLParserT__25)
	}
	{
		p.SetState(561)
		p.NamespaceMembers()
	}
	{
		p.SetState(562)
		p.Match(WebIDLParserT__26)
	}
	{
		p.SetState(563)
		p.Match(WebIDLParserT__27)
	}

	return localctx
}

// INamespaceMembersContext is an interface to support dynamic dispatch.
type INamespaceMembersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNamespaceMembersContext differentiates from other interfaces.
	IsNamespaceMembersContext()
}

type NamespaceMembersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamespaceMembersContext() *NamespaceMembersContext {
	var p = new(NamespaceMembersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_namespaceMembers
	return p
}

func (*NamespaceMembersContext) IsNamespaceMembersContext() {}

func NewNamespaceMembersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamespaceMembersContext {
	var p = new(NamespaceMembersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_namespaceMembers

	return p
}

func (s *NamespaceMembersContext) GetParser() antlr.Parser { return s.parser }

func (s *NamespaceMembersContext) ExtendedAttributeList() IExtendedAttributeListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtendedAttributeListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtendedAttributeListContext)
}

func (s *NamespaceMembersContext) NamespaceMember() INamespaceMemberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamespaceMemberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INamespaceMemberContext)
}

func (s *NamespaceMembersContext) NamespaceMembers() INamespaceMembersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamespaceMembersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INamespaceMembersContext)
}

func (s *NamespaceMembersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamespaceMembersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamespaceMembersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterNamespaceMembers(s)
	}
}

func (s *NamespaceMembersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitNamespaceMembers(s)
	}
}

func (p *WebIDLParser) NamespaceMembers() (localctx INamespaceMembersContext) {
	this := p
	_ = this

	localctx = NewNamespaceMembersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, WebIDLParserRULE_namespaceMembers)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(570)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__3, WebIDLParserT__17, WebIDLParserT__24, WebIDLParserT__35, WebIDLParserT__38, WebIDLParserT__45, WebIDLParserT__47, WebIDLParserT__48, WebIDLParserT__49, WebIDLParserT__50, WebIDLParserT__51, WebIDLParserT__52, WebIDLParserT__53, WebIDLParserT__54, WebIDLParserT__55, WebIDLParserT__56, WebIDLParserT__57, WebIDLParserT__58, WebIDLParserT__59, WebIDLParserT__60, WebIDLParserT__61, WebIDLParserT__62, WebIDLParserT__63, WebIDLParserT__64, WebIDLParserT__65, WebIDLParserT__66, WebIDLParserT__68, WebIDLParserT__69, WebIDLParserT__70, WebIDLParserT__71, WebIDLParserT__72, WebIDLParserT__73, WebIDLParserT__74, WebIDLParserT__75, WebIDLParserT__76, WebIDLParserT__77, WebIDLParserT__78, WebIDLParserIDENTIFIER_WEBIDL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(565)
			p.ExtendedAttributeList()
		}
		{
			p.SetState(566)
			p.NamespaceMember()
		}
		{
			p.SetState(567)
			p.NamespaceMembers()
		}

	case WebIDLParserT__26:
		p.EnterOuterAlt(localctx, 2)

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// INamespaceMemberContext is an interface to support dynamic dispatch.
type INamespaceMemberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNamespaceMemberContext differentiates from other interfaces.
	IsNamespaceMemberContext()
}

type NamespaceMemberContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamespaceMemberContext() *NamespaceMemberContext {
	var p = new(NamespaceMemberContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_namespaceMember
	return p
}

func (*NamespaceMemberContext) IsNamespaceMemberContext() {}

func NewNamespaceMemberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamespaceMemberContext {
	var p = new(NamespaceMemberContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_namespaceMember

	return p
}

func (s *NamespaceMemberContext) GetParser() antlr.Parser { return s.parser }

func (s *NamespaceMemberContext) RegularOperation() IRegularOperationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRegularOperationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRegularOperationContext)
}

func (s *NamespaceMemberContext) AttributeRest() IAttributeRestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttributeRestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttributeRestContext)
}

func (s *NamespaceMemberContext) Const_() IConst_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConst_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConst_Context)
}

func (s *NamespaceMemberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamespaceMemberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamespaceMemberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterNamespaceMember(s)
	}
}

func (s *NamespaceMemberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitNamespaceMember(s)
	}
}

func (p *WebIDLParser) NamespaceMember() (localctx INamespaceMemberContext) {
	this := p
	_ = this

	localctx = NewNamespaceMemberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, WebIDLParserRULE_namespaceMember)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(576)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__24, WebIDLParserT__38, WebIDLParserT__45, WebIDLParserT__47, WebIDLParserT__48, WebIDLParserT__49, WebIDLParserT__50, WebIDLParserT__51, WebIDLParserT__52, WebIDLParserT__53, WebIDLParserT__54, WebIDLParserT__55, WebIDLParserT__56, WebIDLParserT__57, WebIDLParserT__58, WebIDLParserT__59, WebIDLParserT__60, WebIDLParserT__61, WebIDLParserT__62, WebIDLParserT__63, WebIDLParserT__64, WebIDLParserT__65, WebIDLParserT__66, WebIDLParserT__68, WebIDLParserT__69, WebIDLParserT__70, WebIDLParserT__71, WebIDLParserT__72, WebIDLParserT__73, WebIDLParserT__74, WebIDLParserT__75, WebIDLParserT__76, WebIDLParserT__77, WebIDLParserT__78, WebIDLParserIDENTIFIER_WEBIDL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(572)
			p.RegularOperation()
		}

	case WebIDLParserT__17:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(573)
			p.Match(WebIDLParserT__17)
		}
		{
			p.SetState(574)
			p.AttributeRest()
		}

	case WebIDLParserT__3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(575)
			p.Const_()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDictionaryContext is an interface to support dynamic dispatch.
type IDictionaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDictionaryContext differentiates from other interfaces.
	IsDictionaryContext()
}

type DictionaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDictionaryContext() *DictionaryContext {
	var p = new(DictionaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_dictionary
	return p
}

func (*DictionaryContext) IsDictionaryContext() {}

func NewDictionaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DictionaryContext {
	var p = new(DictionaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_dictionary

	return p
}

func (s *DictionaryContext) GetParser() antlr.Parser { return s.parser }

func (s *DictionaryContext) IDENTIFIER_WEBIDL() antlr.TerminalNode {
	return s.GetToken(WebIDLParserIDENTIFIER_WEBIDL, 0)
}

func (s *DictionaryContext) Inheritance() IInheritanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInheritanceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInheritanceContext)
}

func (s *DictionaryContext) DictionaryMembers() IDictionaryMembersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDictionaryMembersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDictionaryMembersContext)
}

func (s *DictionaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DictionaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DictionaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterDictionary(s)
	}
}

func (s *DictionaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitDictionary(s)
	}
}

func (p *WebIDLParser) Dictionary() (localctx IDictionaryContext) {
	this := p
	_ = this

	localctx = NewDictionaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, WebIDLParserRULE_dictionary)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(578)
		p.Match(WebIDLParserT__6)
	}
	{
		p.SetState(579)
		p.Match(WebIDLParserIDENTIFIER_WEBIDL)
	}
	{
		p.SetState(580)
		p.Inheritance()
	}
	{
		p.SetState(581)
		p.Match(WebIDLParserT__25)
	}
	{
		p.SetState(582)
		p.DictionaryMembers()
	}
	{
		p.SetState(583)
		p.Match(WebIDLParserT__26)
	}
	{
		p.SetState(584)
		p.Match(WebIDLParserT__27)
	}

	return localctx
}

// IDictionaryMembersContext is an interface to support dynamic dispatch.
type IDictionaryMembersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDictionaryMembersContext differentiates from other interfaces.
	IsDictionaryMembersContext()
}

type DictionaryMembersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDictionaryMembersContext() *DictionaryMembersContext {
	var p = new(DictionaryMembersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_dictionaryMembers
	return p
}

func (*DictionaryMembersContext) IsDictionaryMembersContext() {}

func NewDictionaryMembersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DictionaryMembersContext {
	var p = new(DictionaryMembersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_dictionaryMembers

	return p
}

func (s *DictionaryMembersContext) GetParser() antlr.Parser { return s.parser }

func (s *DictionaryMembersContext) DictionaryMember() IDictionaryMemberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDictionaryMemberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDictionaryMemberContext)
}

func (s *DictionaryMembersContext) DictionaryMembers() IDictionaryMembersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDictionaryMembersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDictionaryMembersContext)
}

func (s *DictionaryMembersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DictionaryMembersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DictionaryMembersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterDictionaryMembers(s)
	}
}

func (s *DictionaryMembersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitDictionaryMembers(s)
	}
}

func (p *WebIDLParser) DictionaryMembers() (localctx IDictionaryMembersContext) {
	this := p
	_ = this

	localctx = NewDictionaryMembersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, WebIDLParserRULE_dictionaryMembers)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(590)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__18, WebIDLParserT__24, WebIDLParserT__35, WebIDLParserT__38, WebIDLParserT__45, WebIDLParserT__47, WebIDLParserT__48, WebIDLParserT__49, WebIDLParserT__50, WebIDLParserT__51, WebIDLParserT__52, WebIDLParserT__53, WebIDLParserT__54, WebIDLParserT__55, WebIDLParserT__56, WebIDLParserT__57, WebIDLParserT__58, WebIDLParserT__59, WebIDLParserT__60, WebIDLParserT__61, WebIDLParserT__62, WebIDLParserT__63, WebIDLParserT__64, WebIDLParserT__65, WebIDLParserT__66, WebIDLParserT__68, WebIDLParserT__69, WebIDLParserT__70, WebIDLParserT__71, WebIDLParserT__72, WebIDLParserT__73, WebIDLParserT__74, WebIDLParserT__75, WebIDLParserT__76, WebIDLParserT__77, WebIDLParserT__78, WebIDLParserIDENTIFIER_WEBIDL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(586)
			p.DictionaryMember()
		}
		{
			p.SetState(587)
			p.DictionaryMembers()
		}

	case WebIDLParserT__26:
		p.EnterOuterAlt(localctx, 2)

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDictionaryMemberContext is an interface to support dynamic dispatch.
type IDictionaryMemberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDictionaryMemberContext differentiates from other interfaces.
	IsDictionaryMemberContext()
}

type DictionaryMemberContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDictionaryMemberContext() *DictionaryMemberContext {
	var p = new(DictionaryMemberContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_dictionaryMember
	return p
}

func (*DictionaryMemberContext) IsDictionaryMemberContext() {}

func NewDictionaryMemberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DictionaryMemberContext {
	var p = new(DictionaryMemberContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_dictionaryMember

	return p
}

func (s *DictionaryMemberContext) GetParser() antlr.Parser { return s.parser }

func (s *DictionaryMemberContext) ExtendedAttributeList() IExtendedAttributeListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtendedAttributeListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtendedAttributeListContext)
}

func (s *DictionaryMemberContext) DictionaryMemberRest() IDictionaryMemberRestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDictionaryMemberRestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDictionaryMemberRestContext)
}

func (s *DictionaryMemberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DictionaryMemberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DictionaryMemberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterDictionaryMember(s)
	}
}

func (s *DictionaryMemberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitDictionaryMember(s)
	}
}

func (p *WebIDLParser) DictionaryMember() (localctx IDictionaryMemberContext) {
	this := p
	_ = this

	localctx = NewDictionaryMemberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, WebIDLParserRULE_dictionaryMember)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(592)
		p.ExtendedAttributeList()
	}
	{
		p.SetState(593)
		p.DictionaryMemberRest()
	}

	return localctx
}

// IDictionaryMemberRestContext is an interface to support dynamic dispatch.
type IDictionaryMemberRestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDictionaryMemberRestContext differentiates from other interfaces.
	IsDictionaryMemberRestContext()
}

type DictionaryMemberRestContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDictionaryMemberRestContext() *DictionaryMemberRestContext {
	var p = new(DictionaryMemberRestContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_dictionaryMemberRest
	return p
}

func (*DictionaryMemberRestContext) IsDictionaryMemberRestContext() {}

func NewDictionaryMemberRestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DictionaryMemberRestContext {
	var p = new(DictionaryMemberRestContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_dictionaryMemberRest

	return p
}

func (s *DictionaryMemberRestContext) GetParser() antlr.Parser { return s.parser }

func (s *DictionaryMemberRestContext) TypeWithExtendedAttributes() ITypeWithExtendedAttributesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeWithExtendedAttributesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeWithExtendedAttributesContext)
}

func (s *DictionaryMemberRestContext) IDENTIFIER_WEBIDL() antlr.TerminalNode {
	return s.GetToken(WebIDLParserIDENTIFIER_WEBIDL, 0)
}

func (s *DictionaryMemberRestContext) Type_() IType_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *DictionaryMemberRestContext) Default_() IDefault_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefault_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefault_Context)
}

func (s *DictionaryMemberRestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DictionaryMemberRestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DictionaryMemberRestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterDictionaryMemberRest(s)
	}
}

func (s *DictionaryMemberRestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitDictionaryMemberRest(s)
	}
}

func (p *WebIDLParser) DictionaryMemberRest() (localctx IDictionaryMemberRestContext) {
	this := p
	_ = this

	localctx = NewDictionaryMemberRestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, WebIDLParserRULE_dictionaryMemberRest)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(605)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__18:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(595)
			p.Match(WebIDLParserT__18)
		}
		{
			p.SetState(596)
			p.TypeWithExtendedAttributes()
		}
		{
			p.SetState(597)
			p.Match(WebIDLParserIDENTIFIER_WEBIDL)
		}
		{
			p.SetState(598)
			p.Match(WebIDLParserT__27)
		}

	case WebIDLParserT__24, WebIDLParserT__38, WebIDLParserT__45, WebIDLParserT__47, WebIDLParserT__48, WebIDLParserT__49, WebIDLParserT__50, WebIDLParserT__51, WebIDLParserT__52, WebIDLParserT__53, WebIDLParserT__54, WebIDLParserT__55, WebIDLParserT__56, WebIDLParserT__57, WebIDLParserT__58, WebIDLParserT__59, WebIDLParserT__60, WebIDLParserT__61, WebIDLParserT__62, WebIDLParserT__63, WebIDLParserT__64, WebIDLParserT__65, WebIDLParserT__66, WebIDLParserT__68, WebIDLParserT__69, WebIDLParserT__70, WebIDLParserT__71, WebIDLParserT__72, WebIDLParserT__73, WebIDLParserT__74, WebIDLParserT__75, WebIDLParserT__76, WebIDLParserT__77, WebIDLParserT__78, WebIDLParserIDENTIFIER_WEBIDL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(600)
			p.Type_()
		}
		{
			p.SetState(601)
			p.Match(WebIDLParserIDENTIFIER_WEBIDL)
		}
		{
			p.SetState(602)
			p.Default_()
		}
		{
			p.SetState(603)
			p.Match(WebIDLParserT__27)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPartialDictionaryContext is an interface to support dynamic dispatch.
type IPartialDictionaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPartialDictionaryContext differentiates from other interfaces.
	IsPartialDictionaryContext()
}

type PartialDictionaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartialDictionaryContext() *PartialDictionaryContext {
	var p = new(PartialDictionaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_partialDictionary
	return p
}

func (*PartialDictionaryContext) IsPartialDictionaryContext() {}

func NewPartialDictionaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartialDictionaryContext {
	var p = new(PartialDictionaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_partialDictionary

	return p
}

func (s *PartialDictionaryContext) GetParser() antlr.Parser { return s.parser }

func (s *PartialDictionaryContext) IDENTIFIER_WEBIDL() antlr.TerminalNode {
	return s.GetToken(WebIDLParserIDENTIFIER_WEBIDL, 0)
}

func (s *PartialDictionaryContext) DictionaryMembers() IDictionaryMembersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDictionaryMembersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDictionaryMembersContext)
}

func (s *PartialDictionaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartialDictionaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartialDictionaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterPartialDictionary(s)
	}
}

func (s *PartialDictionaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitPartialDictionary(s)
	}
}

func (p *WebIDLParser) PartialDictionary() (localctx IPartialDictionaryContext) {
	this := p
	_ = this

	localctx = NewPartialDictionaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, WebIDLParserRULE_partialDictionary)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(607)
		p.Match(WebIDLParserT__6)
	}
	{
		p.SetState(608)
		p.Match(WebIDLParserIDENTIFIER_WEBIDL)
	}
	{
		p.SetState(609)
		p.Match(WebIDLParserT__25)
	}
	{
		p.SetState(610)
		p.DictionaryMembers()
	}
	{
		p.SetState(611)
		p.Match(WebIDLParserT__26)
	}
	{
		p.SetState(612)
		p.Match(WebIDLParserT__27)
	}

	return localctx
}

// IDefault_Context is an interface to support dynamic dispatch.
type IDefault_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDefault_Context differentiates from other interfaces.
	IsDefault_Context()
}

type Default_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefault_Context() *Default_Context {
	var p = new(Default_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_default_
	return p
}

func (*Default_Context) IsDefault_Context() {}

func NewDefault_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Default_Context {
	var p = new(Default_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_default_

	return p
}

func (s *Default_Context) GetParser() antlr.Parser { return s.parser }

func (s *Default_Context) DefaultValue() IDefaultValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefaultValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefaultValueContext)
}

func (s *Default_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Default_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Default_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterDefault_(s)
	}
}

func (s *Default_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitDefault_(s)
	}
}

func (p *WebIDLParser) Default_() (localctx IDefault_Context) {
	this := p
	_ = this

	localctx = NewDefault_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, WebIDLParserRULE_default_)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(617)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__29:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(614)
			p.Match(WebIDLParserT__29)
		}
		{
			p.SetState(615)
			p.DefaultValue()
		}

	case WebIDLParserT__27, WebIDLParserT__39, WebIDLParserT__40:
		p.EnterOuterAlt(localctx, 2)

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IEnum_Context is an interface to support dynamic dispatch.
type IEnum_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnum_Context differentiates from other interfaces.
	IsEnum_Context()
}

type Enum_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnum_Context() *Enum_Context {
	var p = new(Enum_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_enum_
	return p
}

func (*Enum_Context) IsEnum_Context() {}

func NewEnum_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Enum_Context {
	var p = new(Enum_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_enum_

	return p
}

func (s *Enum_Context) GetParser() antlr.Parser { return s.parser }

func (s *Enum_Context) IDENTIFIER_WEBIDL() antlr.TerminalNode {
	return s.GetToken(WebIDLParserIDENTIFIER_WEBIDL, 0)
}

func (s *Enum_Context) EnumValueList() IEnumValueListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumValueListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnumValueListContext)
}

func (s *Enum_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Enum_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Enum_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterEnum_(s)
	}
}

func (s *Enum_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitEnum_(s)
	}
}

func (p *WebIDLParser) Enum_() (localctx IEnum_Context) {
	this := p
	_ = this

	localctx = NewEnum_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, WebIDLParserRULE_enum_)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(619)
		p.Match(WebIDLParserT__7)
	}
	{
		p.SetState(620)
		p.Match(WebIDLParserIDENTIFIER_WEBIDL)
	}
	{
		p.SetState(621)
		p.Match(WebIDLParserT__25)
	}
	{
		p.SetState(622)
		p.EnumValueList()
	}
	{
		p.SetState(623)
		p.Match(WebIDLParserT__26)
	}
	{
		p.SetState(624)
		p.Match(WebIDLParserT__27)
	}

	return localctx
}

// IEnumValueListContext is an interface to support dynamic dispatch.
type IEnumValueListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumValueListContext differentiates from other interfaces.
	IsEnumValueListContext()
}

type EnumValueListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumValueListContext() *EnumValueListContext {
	var p = new(EnumValueListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_enumValueList
	return p
}

func (*EnumValueListContext) IsEnumValueListContext() {}

func NewEnumValueListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumValueListContext {
	var p = new(EnumValueListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_enumValueList

	return p
}

func (s *EnumValueListContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumValueListContext) STRING_WEBIDL() antlr.TerminalNode {
	return s.GetToken(WebIDLParserSTRING_WEBIDL, 0)
}

func (s *EnumValueListContext) EnumValueListComma() IEnumValueListCommaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumValueListCommaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnumValueListCommaContext)
}

func (s *EnumValueListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumValueListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumValueListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterEnumValueList(s)
	}
}

func (s *EnumValueListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitEnumValueList(s)
	}
}

func (p *WebIDLParser) EnumValueList() (localctx IEnumValueListContext) {
	this := p
	_ = this

	localctx = NewEnumValueListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, WebIDLParserRULE_enumValueList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(626)
		p.Match(WebIDLParserSTRING_WEBIDL)
	}
	{
		p.SetState(627)
		p.EnumValueListComma()
	}

	return localctx
}

// IEnumValueListCommaContext is an interface to support dynamic dispatch.
type IEnumValueListCommaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumValueListCommaContext differentiates from other interfaces.
	IsEnumValueListCommaContext()
}

type EnumValueListCommaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumValueListCommaContext() *EnumValueListCommaContext {
	var p = new(EnumValueListCommaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_enumValueListComma
	return p
}

func (*EnumValueListCommaContext) IsEnumValueListCommaContext() {}

func NewEnumValueListCommaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumValueListCommaContext {
	var p = new(EnumValueListCommaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_enumValueListComma

	return p
}

func (s *EnumValueListCommaContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumValueListCommaContext) EnumValueListString() IEnumValueListStringContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumValueListStringContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnumValueListStringContext)
}

func (s *EnumValueListCommaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumValueListCommaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumValueListCommaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterEnumValueListComma(s)
	}
}

func (s *EnumValueListCommaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitEnumValueListComma(s)
	}
}

func (p *WebIDLParser) EnumValueListComma() (localctx IEnumValueListCommaContext) {
	this := p
	_ = this

	localctx = NewEnumValueListCommaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, WebIDLParserRULE_enumValueListComma)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(632)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__40:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(629)
			p.Match(WebIDLParserT__40)
		}
		{
			p.SetState(630)
			p.EnumValueListString()
		}

	case WebIDLParserT__26:
		p.EnterOuterAlt(localctx, 2)

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IEnumValueListStringContext is an interface to support dynamic dispatch.
type IEnumValueListStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumValueListStringContext differentiates from other interfaces.
	IsEnumValueListStringContext()
}

type EnumValueListStringContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumValueListStringContext() *EnumValueListStringContext {
	var p = new(EnumValueListStringContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_enumValueListString
	return p
}

func (*EnumValueListStringContext) IsEnumValueListStringContext() {}

func NewEnumValueListStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumValueListStringContext {
	var p = new(EnumValueListStringContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_enumValueListString

	return p
}

func (s *EnumValueListStringContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumValueListStringContext) STRING_WEBIDL() antlr.TerminalNode {
	return s.GetToken(WebIDLParserSTRING_WEBIDL, 0)
}

func (s *EnumValueListStringContext) EnumValueListComma() IEnumValueListCommaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumValueListCommaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnumValueListCommaContext)
}

func (s *EnumValueListStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumValueListStringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumValueListStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterEnumValueListString(s)
	}
}

func (s *EnumValueListStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitEnumValueListString(s)
	}
}

func (p *WebIDLParser) EnumValueListString() (localctx IEnumValueListStringContext) {
	this := p
	_ = this

	localctx = NewEnumValueListStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, WebIDLParserRULE_enumValueListString)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(637)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserSTRING_WEBIDL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(634)
			p.Match(WebIDLParserSTRING_WEBIDL)
		}
		{
			p.SetState(635)
			p.EnumValueListComma()
		}

	case WebIDLParserT__26:
		p.EnterOuterAlt(localctx, 2)

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICallbackRestContext is an interface to support dynamic dispatch.
type ICallbackRestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCallbackRestContext differentiates from other interfaces.
	IsCallbackRestContext()
}

type CallbackRestContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallbackRestContext() *CallbackRestContext {
	var p = new(CallbackRestContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_callbackRest
	return p
}

func (*CallbackRestContext) IsCallbackRestContext() {}

func NewCallbackRestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallbackRestContext {
	var p = new(CallbackRestContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_callbackRest

	return p
}

func (s *CallbackRestContext) GetParser() antlr.Parser { return s.parser }

func (s *CallbackRestContext) IDENTIFIER_WEBIDL() antlr.TerminalNode {
	return s.GetToken(WebIDLParserIDENTIFIER_WEBIDL, 0)
}

func (s *CallbackRestContext) Type_() IType_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *CallbackRestContext) ArgumentList() IArgumentListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgumentListContext)
}

func (s *CallbackRestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallbackRestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallbackRestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterCallbackRest(s)
	}
}

func (s *CallbackRestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitCallbackRest(s)
	}
}

func (p *WebIDLParser) CallbackRest() (localctx ICallbackRestContext) {
	this := p
	_ = this

	localctx = NewCallbackRestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, WebIDLParserRULE_callbackRest)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(639)
		p.Match(WebIDLParserIDENTIFIER_WEBIDL)
	}
	{
		p.SetState(640)
		p.Match(WebIDLParserT__29)
	}
	{
		p.SetState(641)
		p.Type_()
	}
	{
		p.SetState(642)
		p.Match(WebIDLParserT__38)
	}
	{
		p.SetState(643)
		p.ArgumentList()
	}
	{
		p.SetState(644)
		p.Match(WebIDLParserT__39)
	}
	{
		p.SetState(645)
		p.Match(WebIDLParserT__27)
	}

	return localctx
}

// ITypedef_Context is an interface to support dynamic dispatch.
type ITypedef_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypedef_Context differentiates from other interfaces.
	IsTypedef_Context()
}

type Typedef_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypedef_Context() *Typedef_Context {
	var p = new(Typedef_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_typedef_
	return p
}

func (*Typedef_Context) IsTypedef_Context() {}

func NewTypedef_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Typedef_Context {
	var p = new(Typedef_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_typedef_

	return p
}

func (s *Typedef_Context) GetParser() antlr.Parser { return s.parser }

func (s *Typedef_Context) TypeWithExtendedAttributes() ITypeWithExtendedAttributesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeWithExtendedAttributesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeWithExtendedAttributesContext)
}

func (s *Typedef_Context) IDENTIFIER_WEBIDL() antlr.TerminalNode {
	return s.GetToken(WebIDLParserIDENTIFIER_WEBIDL, 0)
}

func (s *Typedef_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Typedef_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Typedef_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterTypedef_(s)
	}
}

func (s *Typedef_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitTypedef_(s)
	}
}

func (p *WebIDLParser) Typedef_() (localctx ITypedef_Context) {
	this := p
	_ = this

	localctx = NewTypedef_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, WebIDLParserRULE_typedef_)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(647)
		p.Match(WebIDLParserT__23)
	}
	{
		p.SetState(648)
		p.TypeWithExtendedAttributes()
	}
	{
		p.SetState(649)
		p.Match(WebIDLParserIDENTIFIER_WEBIDL)
	}
	{
		p.SetState(650)
		p.Match(WebIDLParserT__27)
	}

	return localctx
}

// IType_Context is an interface to support dynamic dispatch.
type IType_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsType_Context differentiates from other interfaces.
	IsType_Context()
}

type Type_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_Context() *Type_Context {
	var p = new(Type_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_type_
	return p
}

func (*Type_Context) IsType_Context() {}

func NewType_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_Context {
	var p = new(Type_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_type_

	return p
}

func (s *Type_Context) GetParser() antlr.Parser { return s.parser }

func (s *Type_Context) SingleType() ISingleTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingleTypeContext)
}

func (s *Type_Context) UnionType() IUnionTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnionTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnionTypeContext)
}

func (s *Type_Context) Null_() INull_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INull_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INull_Context)
}

func (s *Type_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterType_(s)
	}
}

func (s *Type_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitType_(s)
	}
}

func (p *WebIDLParser) Type_() (localctx IType_Context) {
	this := p
	_ = this

	localctx = NewType_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, WebIDLParserRULE_type_)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(656)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__24, WebIDLParserT__45, WebIDLParserT__47, WebIDLParserT__48, WebIDLParserT__49, WebIDLParserT__50, WebIDLParserT__51, WebIDLParserT__52, WebIDLParserT__53, WebIDLParserT__54, WebIDLParserT__55, WebIDLParserT__56, WebIDLParserT__57, WebIDLParserT__58, WebIDLParserT__59, WebIDLParserT__60, WebIDLParserT__61, WebIDLParserT__62, WebIDLParserT__63, WebIDLParserT__64, WebIDLParserT__65, WebIDLParserT__66, WebIDLParserT__68, WebIDLParserT__69, WebIDLParserT__70, WebIDLParserT__71, WebIDLParserT__72, WebIDLParserT__73, WebIDLParserT__74, WebIDLParserT__75, WebIDLParserT__76, WebIDLParserT__77, WebIDLParserT__78, WebIDLParserIDENTIFIER_WEBIDL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(652)
			p.SingleType()
		}

	case WebIDLParserT__38:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(653)
			p.UnionType()
		}
		{
			p.SetState(654)
			p.Null_()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITypeWithExtendedAttributesContext is an interface to support dynamic dispatch.
type ITypeWithExtendedAttributesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeWithExtendedAttributesContext differentiates from other interfaces.
	IsTypeWithExtendedAttributesContext()
}

type TypeWithExtendedAttributesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeWithExtendedAttributesContext() *TypeWithExtendedAttributesContext {
	var p = new(TypeWithExtendedAttributesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_typeWithExtendedAttributes
	return p
}

func (*TypeWithExtendedAttributesContext) IsTypeWithExtendedAttributesContext() {}

func NewTypeWithExtendedAttributesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeWithExtendedAttributesContext {
	var p = new(TypeWithExtendedAttributesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_typeWithExtendedAttributes

	return p
}

func (s *TypeWithExtendedAttributesContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeWithExtendedAttributesContext) ExtendedAttributeList() IExtendedAttributeListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtendedAttributeListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtendedAttributeListContext)
}

func (s *TypeWithExtendedAttributesContext) Type_() IType_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *TypeWithExtendedAttributesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeWithExtendedAttributesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeWithExtendedAttributesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterTypeWithExtendedAttributes(s)
	}
}

func (s *TypeWithExtendedAttributesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitTypeWithExtendedAttributes(s)
	}
}

func (p *WebIDLParser) TypeWithExtendedAttributes() (localctx ITypeWithExtendedAttributesContext) {
	this := p
	_ = this

	localctx = NewTypeWithExtendedAttributesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, WebIDLParserRULE_typeWithExtendedAttributes)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(658)
		p.ExtendedAttributeList()
	}
	{
		p.SetState(659)
		p.Type_()
	}

	return localctx
}

// ISingleTypeContext is an interface to support dynamic dispatch.
type ISingleTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSingleTypeContext differentiates from other interfaces.
	IsSingleTypeContext()
}

type SingleTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleTypeContext() *SingleTypeContext {
	var p = new(SingleTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_singleType
	return p
}

func (*SingleTypeContext) IsSingleTypeContext() {}

func NewSingleTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleTypeContext {
	var p = new(SingleTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_singleType

	return p
}

func (s *SingleTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleTypeContext) DistinguishableType() IDistinguishableTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDistinguishableTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDistinguishableTypeContext)
}

func (s *SingleTypeContext) PromiseType() IPromiseTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPromiseTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPromiseTypeContext)
}

func (s *SingleTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterSingleType(s)
	}
}

func (s *SingleTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitSingleType(s)
	}
}

func (p *WebIDLParser) SingleType() (localctx ISingleTypeContext) {
	this := p
	_ = this

	localctx = NewSingleTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, WebIDLParserRULE_singleType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(664)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__24, WebIDLParserT__47, WebIDLParserT__48, WebIDLParserT__49, WebIDLParserT__50, WebIDLParserT__51, WebIDLParserT__52, WebIDLParserT__53, WebIDLParserT__54, WebIDLParserT__55, WebIDLParserT__56, WebIDLParserT__57, WebIDLParserT__58, WebIDLParserT__59, WebIDLParserT__60, WebIDLParserT__61, WebIDLParserT__62, WebIDLParserT__63, WebIDLParserT__64, WebIDLParserT__66, WebIDLParserT__68, WebIDLParserT__69, WebIDLParserT__70, WebIDLParserT__71, WebIDLParserT__72, WebIDLParserT__73, WebIDLParserT__74, WebIDLParserT__75, WebIDLParserT__76, WebIDLParserT__77, WebIDLParserT__78, WebIDLParserIDENTIFIER_WEBIDL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(661)
			p.DistinguishableType()
		}

	case WebIDLParserT__45:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(662)
			p.Match(WebIDLParserT__45)
		}

	case WebIDLParserT__65:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(663)
			p.PromiseType()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IUnionTypeContext is an interface to support dynamic dispatch.
type IUnionTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnionTypeContext differentiates from other interfaces.
	IsUnionTypeContext()
}

type UnionTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnionTypeContext() *UnionTypeContext {
	var p = new(UnionTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_unionType
	return p
}

func (*UnionTypeContext) IsUnionTypeContext() {}

func NewUnionTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnionTypeContext {
	var p = new(UnionTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_unionType

	return p
}

func (s *UnionTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *UnionTypeContext) AllUnionMemberType() []IUnionMemberTypeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IUnionMemberTypeContext)(nil)).Elem())
	var tst = make([]IUnionMemberTypeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IUnionMemberTypeContext)
		}
	}

	return tst
}

func (s *UnionTypeContext) UnionMemberType(i int) IUnionMemberTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnionMemberTypeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IUnionMemberTypeContext)
}

func (s *UnionTypeContext) UnionMemberTypes() IUnionMemberTypesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnionMemberTypesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnionMemberTypesContext)
}

func (s *UnionTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnionTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnionTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterUnionType(s)
	}
}

func (s *UnionTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitUnionType(s)
	}
}

func (p *WebIDLParser) UnionType() (localctx IUnionTypeContext) {
	this := p
	_ = this

	localctx = NewUnionTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, WebIDLParserRULE_unionType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(666)
		p.Match(WebIDLParserT__38)
	}
	{
		p.SetState(667)
		p.UnionMemberType()
	}
	{
		p.SetState(668)
		p.Match(WebIDLParserT__46)
	}
	{
		p.SetState(669)
		p.UnionMemberType()
	}
	{
		p.SetState(670)
		p.UnionMemberTypes()
	}
	{
		p.SetState(671)
		p.Match(WebIDLParserT__39)
	}

	return localctx
}

// IUnionMemberTypeContext is an interface to support dynamic dispatch.
type IUnionMemberTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnionMemberTypeContext differentiates from other interfaces.
	IsUnionMemberTypeContext()
}

type UnionMemberTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnionMemberTypeContext() *UnionMemberTypeContext {
	var p = new(UnionMemberTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_unionMemberType
	return p
}

func (*UnionMemberTypeContext) IsUnionMemberTypeContext() {}

func NewUnionMemberTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnionMemberTypeContext {
	var p = new(UnionMemberTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_unionMemberType

	return p
}

func (s *UnionMemberTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *UnionMemberTypeContext) ExtendedAttributeList() IExtendedAttributeListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtendedAttributeListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtendedAttributeListContext)
}

func (s *UnionMemberTypeContext) DistinguishableType() IDistinguishableTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDistinguishableTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDistinguishableTypeContext)
}

func (s *UnionMemberTypeContext) UnionType() IUnionTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnionTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnionTypeContext)
}

func (s *UnionMemberTypeContext) Null_() INull_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INull_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INull_Context)
}

func (s *UnionMemberTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnionMemberTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnionMemberTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterUnionMemberType(s)
	}
}

func (s *UnionMemberTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitUnionMemberType(s)
	}
}

func (p *WebIDLParser) UnionMemberType() (localctx IUnionMemberTypeContext) {
	this := p
	_ = this

	localctx = NewUnionMemberTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, WebIDLParserRULE_unionMemberType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(679)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__24, WebIDLParserT__35, WebIDLParserT__47, WebIDLParserT__48, WebIDLParserT__49, WebIDLParserT__50, WebIDLParserT__51, WebIDLParserT__52, WebIDLParserT__53, WebIDLParserT__54, WebIDLParserT__55, WebIDLParserT__56, WebIDLParserT__57, WebIDLParserT__58, WebIDLParserT__59, WebIDLParserT__60, WebIDLParserT__61, WebIDLParserT__62, WebIDLParserT__63, WebIDLParserT__64, WebIDLParserT__66, WebIDLParserT__68, WebIDLParserT__69, WebIDLParserT__70, WebIDLParserT__71, WebIDLParserT__72, WebIDLParserT__73, WebIDLParserT__74, WebIDLParserT__75, WebIDLParserT__76, WebIDLParserT__77, WebIDLParserT__78, WebIDLParserIDENTIFIER_WEBIDL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(673)
			p.ExtendedAttributeList()
		}
		{
			p.SetState(674)
			p.DistinguishableType()
		}

	case WebIDLParserT__38:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(676)
			p.UnionType()
		}
		{
			p.SetState(677)
			p.Null_()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IUnionMemberTypesContext is an interface to support dynamic dispatch.
type IUnionMemberTypesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnionMemberTypesContext differentiates from other interfaces.
	IsUnionMemberTypesContext()
}

type UnionMemberTypesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnionMemberTypesContext() *UnionMemberTypesContext {
	var p = new(UnionMemberTypesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_unionMemberTypes
	return p
}

func (*UnionMemberTypesContext) IsUnionMemberTypesContext() {}

func NewUnionMemberTypesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnionMemberTypesContext {
	var p = new(UnionMemberTypesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_unionMemberTypes

	return p
}

func (s *UnionMemberTypesContext) GetParser() antlr.Parser { return s.parser }

func (s *UnionMemberTypesContext) UnionMemberType() IUnionMemberTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnionMemberTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnionMemberTypeContext)
}

func (s *UnionMemberTypesContext) UnionMemberTypes() IUnionMemberTypesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnionMemberTypesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnionMemberTypesContext)
}

func (s *UnionMemberTypesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnionMemberTypesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnionMemberTypesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterUnionMemberTypes(s)
	}
}

func (s *UnionMemberTypesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitUnionMemberTypes(s)
	}
}

func (p *WebIDLParser) UnionMemberTypes() (localctx IUnionMemberTypesContext) {
	this := p
	_ = this

	localctx = NewUnionMemberTypesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, WebIDLParserRULE_unionMemberTypes)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(686)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__46:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(681)
			p.Match(WebIDLParserT__46)
		}
		{
			p.SetState(682)
			p.UnionMemberType()
		}
		{
			p.SetState(683)
			p.UnionMemberTypes()
		}

	case WebIDLParserT__39:
		p.EnterOuterAlt(localctx, 2)

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDistinguishableTypeContext is an interface to support dynamic dispatch.
type IDistinguishableTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDistinguishableTypeContext differentiates from other interfaces.
	IsDistinguishableTypeContext()
}

type DistinguishableTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDistinguishableTypeContext() *DistinguishableTypeContext {
	var p = new(DistinguishableTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_distinguishableType
	return p
}

func (*DistinguishableTypeContext) IsDistinguishableTypeContext() {}

func NewDistinguishableTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DistinguishableTypeContext {
	var p = new(DistinguishableTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_distinguishableType

	return p
}

func (s *DistinguishableTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *DistinguishableTypeContext) PrimitiveType() IPrimitiveTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimitiveTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimitiveTypeContext)
}

func (s *DistinguishableTypeContext) Null_() INull_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INull_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INull_Context)
}

func (s *DistinguishableTypeContext) StringType() IStringTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStringTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStringTypeContext)
}

func (s *DistinguishableTypeContext) IDENTIFIER_WEBIDL() antlr.TerminalNode {
	return s.GetToken(WebIDLParserIDENTIFIER_WEBIDL, 0)
}

func (s *DistinguishableTypeContext) TypeWithExtendedAttributes() ITypeWithExtendedAttributesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeWithExtendedAttributesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeWithExtendedAttributesContext)
}

func (s *DistinguishableTypeContext) BufferRelatedType() IBufferRelatedTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBufferRelatedTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBufferRelatedTypeContext)
}

func (s *DistinguishableTypeContext) RecordType() IRecordTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRecordTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRecordTypeContext)
}

func (s *DistinguishableTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DistinguishableTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DistinguishableTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterDistinguishableType(s)
	}
}

func (s *DistinguishableTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitDistinguishableType(s)
	}
}

func (p *WebIDLParser) DistinguishableType() (localctx IDistinguishableTypeContext) {
	this := p
	_ = this

	localctx = NewDistinguishableTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, WebIDLParserRULE_distinguishableType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(724)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__24, WebIDLParserT__52, WebIDLParserT__53, WebIDLParserT__54, WebIDLParserT__55, WebIDLParserT__56, WebIDLParserT__57, WebIDLParserT__58, WebIDLParserT__59, WebIDLParserT__60, WebIDLParserT__61:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(688)
			p.PrimitiveType()
		}
		{
			p.SetState(689)
			p.Null_()
		}

	case WebIDLParserT__62, WebIDLParserT__63, WebIDLParserT__64:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(691)
			p.StringType()
		}
		{
			p.SetState(692)
			p.Null_()
		}

	case WebIDLParserIDENTIFIER_WEBIDL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(694)
			p.Match(WebIDLParserIDENTIFIER_WEBIDL)
		}
		{
			p.SetState(695)
			p.Null_()
		}

	case WebIDLParserT__47:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(696)
			p.Match(WebIDLParserT__47)
		}
		{
			p.SetState(697)
			p.Match(WebIDLParserT__43)
		}
		{
			p.SetState(698)
			p.TypeWithExtendedAttributes()
		}
		{
			p.SetState(699)
			p.Match(WebIDLParserT__44)
		}
		{
			p.SetState(700)
			p.Null_()
		}

	case WebIDLParserT__48:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(702)
			p.Match(WebIDLParserT__48)
		}
		{
			p.SetState(703)
			p.Null_()
		}

	case WebIDLParserT__49:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(704)
			p.Match(WebIDLParserT__49)
		}
		{
			p.SetState(705)
			p.Null_()
		}

	case WebIDLParserT__68, WebIDLParserT__69, WebIDLParserT__70, WebIDLParserT__71, WebIDLParserT__72, WebIDLParserT__73, WebIDLParserT__74, WebIDLParserT__75, WebIDLParserT__76, WebIDLParserT__77, WebIDLParserT__78:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(706)
			p.BufferRelatedType()
		}
		{
			p.SetState(707)
			p.Null_()
		}

	case WebIDLParserT__50:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(709)
			p.Match(WebIDLParserT__50)
		}
		{
			p.SetState(710)
			p.Match(WebIDLParserT__43)
		}
		{
			p.SetState(711)
			p.TypeWithExtendedAttributes()
		}
		{
			p.SetState(712)
			p.Match(WebIDLParserT__44)
		}
		{
			p.SetState(713)
			p.Null_()
		}

	case WebIDLParserT__51:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(715)
			p.Match(WebIDLParserT__51)
		}
		{
			p.SetState(716)
			p.Match(WebIDLParserT__43)
		}
		{
			p.SetState(717)
			p.TypeWithExtendedAttributes()
		}
		{
			p.SetState(718)
			p.Match(WebIDLParserT__44)
		}
		{
			p.SetState(719)
			p.Null_()
		}

	case WebIDLParserT__66:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(721)
			p.RecordType()
		}
		{
			p.SetState(722)
			p.Null_()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPrimitiveTypeContext is an interface to support dynamic dispatch.
type IPrimitiveTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimitiveTypeContext differentiates from other interfaces.
	IsPrimitiveTypeContext()
}

type PrimitiveTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimitiveTypeContext() *PrimitiveTypeContext {
	var p = new(PrimitiveTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_primitiveType
	return p
}

func (*PrimitiveTypeContext) IsPrimitiveTypeContext() {}

func NewPrimitiveTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimitiveTypeContext {
	var p = new(PrimitiveTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_primitiveType

	return p
}

func (s *PrimitiveTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimitiveTypeContext) UnsignedIntegerType() IUnsignedIntegerTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnsignedIntegerTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnsignedIntegerTypeContext)
}

func (s *PrimitiveTypeContext) UnrestrictedFloatType() IUnrestrictedFloatTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnrestrictedFloatTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnrestrictedFloatTypeContext)
}

func (s *PrimitiveTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimitiveTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimitiveTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterPrimitiveType(s)
	}
}

func (s *PrimitiveTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitPrimitiveType(s)
	}
}

func (p *WebIDLParser) PrimitiveType() (localctx IPrimitiveTypeContext) {
	this := p
	_ = this

	localctx = NewPrimitiveTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, WebIDLParserRULE_primitiveType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(733)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__59, WebIDLParserT__60, WebIDLParserT__61:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(726)
			p.UnsignedIntegerType()
		}

	case WebIDLParserT__24, WebIDLParserT__57, WebIDLParserT__58:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(727)
			p.UnrestrictedFloatType()
		}

	case WebIDLParserT__52:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(728)
			p.Match(WebIDLParserT__52)
		}

	case WebIDLParserT__53:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(729)
			p.Match(WebIDLParserT__53)
		}

	case WebIDLParserT__54:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(730)
			p.Match(WebIDLParserT__54)
		}

	case WebIDLParserT__55:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(731)
			p.Match(WebIDLParserT__55)
		}

	case WebIDLParserT__56:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(732)
			p.Match(WebIDLParserT__56)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IUnrestrictedFloatTypeContext is an interface to support dynamic dispatch.
type IUnrestrictedFloatTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnrestrictedFloatTypeContext differentiates from other interfaces.
	IsUnrestrictedFloatTypeContext()
}

type UnrestrictedFloatTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnrestrictedFloatTypeContext() *UnrestrictedFloatTypeContext {
	var p = new(UnrestrictedFloatTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_unrestrictedFloatType
	return p
}

func (*UnrestrictedFloatTypeContext) IsUnrestrictedFloatTypeContext() {}

func NewUnrestrictedFloatTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnrestrictedFloatTypeContext {
	var p = new(UnrestrictedFloatTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_unrestrictedFloatType

	return p
}

func (s *UnrestrictedFloatTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *UnrestrictedFloatTypeContext) FloatType() IFloatTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFloatTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFloatTypeContext)
}

func (s *UnrestrictedFloatTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnrestrictedFloatTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnrestrictedFloatTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterUnrestrictedFloatType(s)
	}
}

func (s *UnrestrictedFloatTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitUnrestrictedFloatType(s)
	}
}

func (p *WebIDLParser) UnrestrictedFloatType() (localctx IUnrestrictedFloatTypeContext) {
	this := p
	_ = this

	localctx = NewUnrestrictedFloatTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, WebIDLParserRULE_unrestrictedFloatType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(738)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__24:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(735)
			p.Match(WebIDLParserT__24)
		}
		{
			p.SetState(736)
			p.FloatType()
		}

	case WebIDLParserT__57, WebIDLParserT__58:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(737)
			p.FloatType()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFloatTypeContext is an interface to support dynamic dispatch.
type IFloatTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFloatTypeContext differentiates from other interfaces.
	IsFloatTypeContext()
}

type FloatTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFloatTypeContext() *FloatTypeContext {
	var p = new(FloatTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_floatType
	return p
}

func (*FloatTypeContext) IsFloatTypeContext() {}

func NewFloatTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FloatTypeContext {
	var p = new(FloatTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_floatType

	return p
}

func (s *FloatTypeContext) GetParser() antlr.Parser { return s.parser }
func (s *FloatTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FloatTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FloatTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterFloatType(s)
	}
}

func (s *FloatTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitFloatType(s)
	}
}

func (p *WebIDLParser) FloatType() (localctx IFloatTypeContext) {
	this := p
	_ = this

	localctx = NewFloatTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, WebIDLParserRULE_floatType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(740)
		_la = p.GetTokenStream().LA(1)

		if !(_la == WebIDLParserT__57 || _la == WebIDLParserT__58) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IUnsignedIntegerTypeContext is an interface to support dynamic dispatch.
type IUnsignedIntegerTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnsignedIntegerTypeContext differentiates from other interfaces.
	IsUnsignedIntegerTypeContext()
}

type UnsignedIntegerTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsignedIntegerTypeContext() *UnsignedIntegerTypeContext {
	var p = new(UnsignedIntegerTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_unsignedIntegerType
	return p
}

func (*UnsignedIntegerTypeContext) IsUnsignedIntegerTypeContext() {}

func NewUnsignedIntegerTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsignedIntegerTypeContext {
	var p = new(UnsignedIntegerTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_unsignedIntegerType

	return p
}

func (s *UnsignedIntegerTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsignedIntegerTypeContext) IntegerType() IIntegerTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerTypeContext)
}

func (s *UnsignedIntegerTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsignedIntegerTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnsignedIntegerTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterUnsignedIntegerType(s)
	}
}

func (s *UnsignedIntegerTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitUnsignedIntegerType(s)
	}
}

func (p *WebIDLParser) UnsignedIntegerType() (localctx IUnsignedIntegerTypeContext) {
	this := p
	_ = this

	localctx = NewUnsignedIntegerTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, WebIDLParserRULE_unsignedIntegerType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(745)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__59:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(742)
			p.Match(WebIDLParserT__59)
		}
		{
			p.SetState(743)
			p.IntegerType()
		}

	case WebIDLParserT__60, WebIDLParserT__61:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(744)
			p.IntegerType()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IIntegerTypeContext is an interface to support dynamic dispatch.
type IIntegerTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIntegerTypeContext differentiates from other interfaces.
	IsIntegerTypeContext()
}

type IntegerTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntegerTypeContext() *IntegerTypeContext {
	var p = new(IntegerTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_integerType
	return p
}

func (*IntegerTypeContext) IsIntegerTypeContext() {}

func NewIntegerTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntegerTypeContext {
	var p = new(IntegerTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_integerType

	return p
}

func (s *IntegerTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *IntegerTypeContext) OptionalLong() IOptionalLongContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOptionalLongContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOptionalLongContext)
}

func (s *IntegerTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntegerTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntegerTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterIntegerType(s)
	}
}

func (s *IntegerTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitIntegerType(s)
	}
}

func (p *WebIDLParser) IntegerType() (localctx IIntegerTypeContext) {
	this := p
	_ = this

	localctx = NewIntegerTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, WebIDLParserRULE_integerType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(750)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__60:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(747)
			p.Match(WebIDLParserT__60)
		}

	case WebIDLParserT__61:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(748)
			p.Match(WebIDLParserT__61)
		}
		{
			p.SetState(749)
			p.OptionalLong()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IOptionalLongContext is an interface to support dynamic dispatch.
type IOptionalLongContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOptionalLongContext differentiates from other interfaces.
	IsOptionalLongContext()
}

type OptionalLongContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptionalLongContext() *OptionalLongContext {
	var p = new(OptionalLongContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_optionalLong
	return p
}

func (*OptionalLongContext) IsOptionalLongContext() {}

func NewOptionalLongContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptionalLongContext {
	var p = new(OptionalLongContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_optionalLong

	return p
}

func (s *OptionalLongContext) GetParser() antlr.Parser { return s.parser }
func (s *OptionalLongContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptionalLongContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptionalLongContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterOptionalLong(s)
	}
}

func (s *OptionalLongContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitOptionalLong(s)
	}
}

func (p *WebIDLParser) OptionalLong() (localctx IOptionalLongContext) {
	this := p
	_ = this

	localctx = NewOptionalLongContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, WebIDLParserRULE_optionalLong)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(754)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__61:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(752)
			p.Match(WebIDLParserT__61)
		}

	case WebIDLParserT__0, WebIDLParserT__1, WebIDLParserT__2, WebIDLParserT__3, WebIDLParserT__4, WebIDLParserT__5, WebIDLParserT__6, WebIDLParserT__7, WebIDLParserT__8, WebIDLParserT__9, WebIDLParserT__10, WebIDLParserT__11, WebIDLParserT__12, WebIDLParserT__13, WebIDLParserT__14, WebIDLParserT__15, WebIDLParserT__16, WebIDLParserT__17, WebIDLParserT__18, WebIDLParserT__19, WebIDLParserT__20, WebIDLParserT__21, WebIDLParserT__22, WebIDLParserT__23, WebIDLParserT__24, WebIDLParserT__38, WebIDLParserT__39, WebIDLParserT__40, WebIDLParserT__42, WebIDLParserT__44, WebIDLParserT__46, WebIDLParserT__67, WebIDLParserIDENTIFIER_WEBIDL:
		p.EnterOuterAlt(localctx, 2)

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IStringTypeContext is an interface to support dynamic dispatch.
type IStringTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStringTypeContext differentiates from other interfaces.
	IsStringTypeContext()
}

type StringTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringTypeContext() *StringTypeContext {
	var p = new(StringTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_stringType
	return p
}

func (*StringTypeContext) IsStringTypeContext() {}

func NewStringTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringTypeContext {
	var p = new(StringTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_stringType

	return p
}

func (s *StringTypeContext) GetParser() antlr.Parser { return s.parser }
func (s *StringTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterStringType(s)
	}
}

func (s *StringTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitStringType(s)
	}
}

func (p *WebIDLParser) StringType() (localctx IStringTypeContext) {
	this := p
	_ = this

	localctx = NewStringTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, WebIDLParserRULE_stringType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(756)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-63)&-(0x1f+1)) == 0 && ((1<<uint((_la-63)))&((1<<(WebIDLParserT__62-63))|(1<<(WebIDLParserT__63-63))|(1<<(WebIDLParserT__64-63)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IPromiseTypeContext is an interface to support dynamic dispatch.
type IPromiseTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPromiseTypeContext differentiates from other interfaces.
	IsPromiseTypeContext()
}

type PromiseTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPromiseTypeContext() *PromiseTypeContext {
	var p = new(PromiseTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_promiseType
	return p
}

func (*PromiseTypeContext) IsPromiseTypeContext() {}

func NewPromiseTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PromiseTypeContext {
	var p = new(PromiseTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_promiseType

	return p
}

func (s *PromiseTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *PromiseTypeContext) Type_() IType_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *PromiseTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PromiseTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PromiseTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterPromiseType(s)
	}
}

func (s *PromiseTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitPromiseType(s)
	}
}

func (p *WebIDLParser) PromiseType() (localctx IPromiseTypeContext) {
	this := p
	_ = this

	localctx = NewPromiseTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, WebIDLParserRULE_promiseType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(758)
		p.Match(WebIDLParserT__65)
	}
	{
		p.SetState(759)
		p.Match(WebIDLParserT__43)
	}
	{
		p.SetState(760)
		p.Type_()
	}
	{
		p.SetState(761)
		p.Match(WebIDLParserT__44)
	}

	return localctx
}

// IRecordTypeContext is an interface to support dynamic dispatch.
type IRecordTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRecordTypeContext differentiates from other interfaces.
	IsRecordTypeContext()
}

type RecordTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordTypeContext() *RecordTypeContext {
	var p = new(RecordTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_recordType
	return p
}

func (*RecordTypeContext) IsRecordTypeContext() {}

func NewRecordTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordTypeContext {
	var p = new(RecordTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_recordType

	return p
}

func (s *RecordTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordTypeContext) StringType() IStringTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStringTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStringTypeContext)
}

func (s *RecordTypeContext) TypeWithExtendedAttributes() ITypeWithExtendedAttributesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeWithExtendedAttributesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeWithExtendedAttributesContext)
}

func (s *RecordTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterRecordType(s)
	}
}

func (s *RecordTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitRecordType(s)
	}
}

func (p *WebIDLParser) RecordType() (localctx IRecordTypeContext) {
	this := p
	_ = this

	localctx = NewRecordTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, WebIDLParserRULE_recordType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(763)
		p.Match(WebIDLParserT__66)
	}
	{
		p.SetState(764)
		p.Match(WebIDLParserT__43)
	}
	{
		p.SetState(765)
		p.StringType()
	}
	{
		p.SetState(766)
		p.Match(WebIDLParserT__40)
	}
	{
		p.SetState(767)
		p.TypeWithExtendedAttributes()
	}
	{
		p.SetState(768)
		p.Match(WebIDLParserT__44)
	}

	return localctx
}

// INull_Context is an interface to support dynamic dispatch.
type INull_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNull_Context differentiates from other interfaces.
	IsNull_Context()
}

type Null_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNull_Context() *Null_Context {
	var p = new(Null_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_null_
	return p
}

func (*Null_Context) IsNull_Context() {}

func NewNull_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Null_Context {
	var p = new(Null_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_null_

	return p
}

func (s *Null_Context) GetParser() antlr.Parser { return s.parser }
func (s *Null_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Null_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Null_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterNull_(s)
	}
}

func (s *Null_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitNull_(s)
	}
}

func (p *WebIDLParser) Null_() (localctx INull_Context) {
	this := p
	_ = this

	localctx = NewNull_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, WebIDLParserRULE_null_)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(772)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__67:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(770)
			p.Match(WebIDLParserT__67)
		}

	case WebIDLParserT__0, WebIDLParserT__1, WebIDLParserT__2, WebIDLParserT__3, WebIDLParserT__4, WebIDLParserT__5, WebIDLParserT__6, WebIDLParserT__7, WebIDLParserT__8, WebIDLParserT__9, WebIDLParserT__10, WebIDLParserT__11, WebIDLParserT__12, WebIDLParserT__13, WebIDLParserT__14, WebIDLParserT__15, WebIDLParserT__16, WebIDLParserT__17, WebIDLParserT__18, WebIDLParserT__19, WebIDLParserT__20, WebIDLParserT__21, WebIDLParserT__22, WebIDLParserT__23, WebIDLParserT__24, WebIDLParserT__38, WebIDLParserT__39, WebIDLParserT__40, WebIDLParserT__42, WebIDLParserT__44, WebIDLParserT__46, WebIDLParserIDENTIFIER_WEBIDL:
		p.EnterOuterAlt(localctx, 2)

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IBufferRelatedTypeContext is an interface to support dynamic dispatch.
type IBufferRelatedTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBufferRelatedTypeContext differentiates from other interfaces.
	IsBufferRelatedTypeContext()
}

type BufferRelatedTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBufferRelatedTypeContext() *BufferRelatedTypeContext {
	var p = new(BufferRelatedTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_bufferRelatedType
	return p
}

func (*BufferRelatedTypeContext) IsBufferRelatedTypeContext() {}

func NewBufferRelatedTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BufferRelatedTypeContext {
	var p = new(BufferRelatedTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_bufferRelatedType

	return p
}

func (s *BufferRelatedTypeContext) GetParser() antlr.Parser { return s.parser }
func (s *BufferRelatedTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BufferRelatedTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BufferRelatedTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterBufferRelatedType(s)
	}
}

func (s *BufferRelatedTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitBufferRelatedType(s)
	}
}

func (p *WebIDLParser) BufferRelatedType() (localctx IBufferRelatedTypeContext) {
	this := p
	_ = this

	localctx = NewBufferRelatedTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, WebIDLParserRULE_bufferRelatedType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(774)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-69)&-(0x1f+1)) == 0 && ((1<<uint((_la-69)))&((1<<(WebIDLParserT__68-69))|(1<<(WebIDLParserT__69-69))|(1<<(WebIDLParserT__70-69))|(1<<(WebIDLParserT__71-69))|(1<<(WebIDLParserT__72-69))|(1<<(WebIDLParserT__73-69))|(1<<(WebIDLParserT__74-69))|(1<<(WebIDLParserT__75-69))|(1<<(WebIDLParserT__76-69))|(1<<(WebIDLParserT__77-69))|(1<<(WebIDLParserT__78-69)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IExtendedAttributeListContext is an interface to support dynamic dispatch.
type IExtendedAttributeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExtendedAttributeListContext differentiates from other interfaces.
	IsExtendedAttributeListContext()
}

type ExtendedAttributeListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtendedAttributeListContext() *ExtendedAttributeListContext {
	var p = new(ExtendedAttributeListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_extendedAttributeList
	return p
}

func (*ExtendedAttributeListContext) IsExtendedAttributeListContext() {}

func NewExtendedAttributeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtendedAttributeListContext {
	var p = new(ExtendedAttributeListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_extendedAttributeList

	return p
}

func (s *ExtendedAttributeListContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtendedAttributeListContext) ExtendedAttribute() IExtendedAttributeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtendedAttributeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtendedAttributeContext)
}

func (s *ExtendedAttributeListContext) ExtendedAttributes() IExtendedAttributesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtendedAttributesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtendedAttributesContext)
}

func (s *ExtendedAttributeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtendedAttributeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtendedAttributeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterExtendedAttributeList(s)
	}
}

func (s *ExtendedAttributeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitExtendedAttributeList(s)
	}
}

func (p *WebIDLParser) ExtendedAttributeList() (localctx IExtendedAttributeListContext) {
	this := p
	_ = this

	localctx = NewExtendedAttributeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, WebIDLParserRULE_extendedAttributeList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(782)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__35:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(776)
			p.Match(WebIDLParserT__35)
		}
		{
			p.SetState(777)
			p.ExtendedAttribute()
		}
		{
			p.SetState(778)
			p.ExtendedAttributes()
		}
		{
			p.SetState(779)
			p.Match(WebIDLParserT__36)
		}

	case WebIDLParserT__0, WebIDLParserT__1, WebIDLParserT__2, WebIDLParserT__3, WebIDLParserT__4, WebIDLParserT__5, WebIDLParserT__6, WebIDLParserT__7, WebIDLParserT__8, WebIDLParserT__10, WebIDLParserT__11, WebIDLParserT__12, WebIDLParserT__13, WebIDLParserT__15, WebIDLParserT__16, WebIDLParserT__17, WebIDLParserT__18, WebIDLParserT__19, WebIDLParserT__20, WebIDLParserT__21, WebIDLParserT__22, WebIDLParserT__23, WebIDLParserT__24, WebIDLParserT__38, WebIDLParserT__41, WebIDLParserT__45, WebIDLParserT__47, WebIDLParserT__48, WebIDLParserT__49, WebIDLParserT__50, WebIDLParserT__51, WebIDLParserT__52, WebIDLParserT__53, WebIDLParserT__54, WebIDLParserT__55, WebIDLParserT__56, WebIDLParserT__57, WebIDLParserT__58, WebIDLParserT__59, WebIDLParserT__60, WebIDLParserT__61, WebIDLParserT__62, WebIDLParserT__63, WebIDLParserT__64, WebIDLParserT__65, WebIDLParserT__66, WebIDLParserT__68, WebIDLParserT__69, WebIDLParserT__70, WebIDLParserT__71, WebIDLParserT__72, WebIDLParserT__73, WebIDLParserT__74, WebIDLParserT__75, WebIDLParserT__76, WebIDLParserT__77, WebIDLParserT__78, WebIDLParserIDENTIFIER_WEBIDL:
		p.EnterOuterAlt(localctx, 2)

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IExtendedAttributesContext is an interface to support dynamic dispatch.
type IExtendedAttributesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExtendedAttributesContext differentiates from other interfaces.
	IsExtendedAttributesContext()
}

type ExtendedAttributesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtendedAttributesContext() *ExtendedAttributesContext {
	var p = new(ExtendedAttributesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_extendedAttributes
	return p
}

func (*ExtendedAttributesContext) IsExtendedAttributesContext() {}

func NewExtendedAttributesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtendedAttributesContext {
	var p = new(ExtendedAttributesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_extendedAttributes

	return p
}

func (s *ExtendedAttributesContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtendedAttributesContext) ExtendedAttribute() IExtendedAttributeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtendedAttributeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtendedAttributeContext)
}

func (s *ExtendedAttributesContext) ExtendedAttributes() IExtendedAttributesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtendedAttributesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtendedAttributesContext)
}

func (s *ExtendedAttributesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtendedAttributesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtendedAttributesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterExtendedAttributes(s)
	}
}

func (s *ExtendedAttributesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitExtendedAttributes(s)
	}
}

func (p *WebIDLParser) ExtendedAttributes() (localctx IExtendedAttributesContext) {
	this := p
	_ = this

	localctx = NewExtendedAttributesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, WebIDLParserRULE_extendedAttributes)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(789)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__40:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(784)
			p.Match(WebIDLParserT__40)
		}
		{
			p.SetState(785)
			p.ExtendedAttribute()
		}
		{
			p.SetState(786)
			p.ExtendedAttributes()
		}

	case WebIDLParserT__36:
		p.EnterOuterAlt(localctx, 2)

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IExtendedAttributeContext is an interface to support dynamic dispatch.
type IExtendedAttributeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExtendedAttributeContext differentiates from other interfaces.
	IsExtendedAttributeContext()
}

type ExtendedAttributeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtendedAttributeContext() *ExtendedAttributeContext {
	var p = new(ExtendedAttributeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_extendedAttribute
	return p
}

func (*ExtendedAttributeContext) IsExtendedAttributeContext() {}

func NewExtendedAttributeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtendedAttributeContext {
	var p = new(ExtendedAttributeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_extendedAttribute

	return p
}

func (s *ExtendedAttributeContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtendedAttributeContext) ExtendedAttributeNoArgs() IExtendedAttributeNoArgsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtendedAttributeNoArgsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtendedAttributeNoArgsContext)
}

func (s *ExtendedAttributeContext) ExtendedAttributeArgList() IExtendedAttributeArgListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtendedAttributeArgListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtendedAttributeArgListContext)
}

func (s *ExtendedAttributeContext) ExtendedAttributeNamedArgList() IExtendedAttributeNamedArgListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtendedAttributeNamedArgListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtendedAttributeNamedArgListContext)
}

func (s *ExtendedAttributeContext) ExtendedAttributeIdent() IExtendedAttributeIdentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtendedAttributeIdentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtendedAttributeIdentContext)
}

func (s *ExtendedAttributeContext) ExtendedAttributeIdentList() IExtendedAttributeIdentListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtendedAttributeIdentListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtendedAttributeIdentListContext)
}

func (s *ExtendedAttributeContext) ExtendedAttributeString() IExtendedAttributeStringContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtendedAttributeStringContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtendedAttributeStringContext)
}

func (s *ExtendedAttributeContext) ExtendedAttributeStringList() IExtendedAttributeStringListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtendedAttributeStringListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtendedAttributeStringListContext)
}

func (s *ExtendedAttributeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtendedAttributeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtendedAttributeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterExtendedAttribute(s)
	}
}

func (s *ExtendedAttributeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitExtendedAttribute(s)
	}
}

func (p *WebIDLParser) ExtendedAttribute() (localctx IExtendedAttributeContext) {
	this := p
	_ = this

	localctx = NewExtendedAttributeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, WebIDLParserRULE_extendedAttribute)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(798)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 54, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(791)
			p.ExtendedAttributeNoArgs()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(792)
			p.ExtendedAttributeArgList()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(793)
			p.ExtendedAttributeNamedArgList()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(794)
			p.ExtendedAttributeIdent()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(795)
			p.ExtendedAttributeIdentList()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(796)
			p.ExtendedAttributeString()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(797)
			p.ExtendedAttributeStringList()
		}

	}

	return localctx
}

// IOtherContext is an interface to support dynamic dispatch.
type IOtherContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOtherContext differentiates from other interfaces.
	IsOtherContext()
}

type OtherContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOtherContext() *OtherContext {
	var p = new(OtherContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_other
	return p
}

func (*OtherContext) IsOtherContext() {}

func NewOtherContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OtherContext {
	var p = new(OtherContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_other

	return p
}

func (s *OtherContext) GetParser() antlr.Parser { return s.parser }

func (s *OtherContext) INTEGER_WEBIDL() antlr.TerminalNode {
	return s.GetToken(WebIDLParserINTEGER_WEBIDL, 0)
}

func (s *OtherContext) DECIMAL_WEBIDL() antlr.TerminalNode {
	return s.GetToken(WebIDLParserDECIMAL_WEBIDL, 0)
}

func (s *OtherContext) IDENTIFIER_WEBIDL() antlr.TerminalNode {
	return s.GetToken(WebIDLParserIDENTIFIER_WEBIDL, 0)
}

func (s *OtherContext) STRING_WEBIDL() antlr.TerminalNode {
	return s.GetToken(WebIDLParserSTRING_WEBIDL, 0)
}

func (s *OtherContext) OTHER_WEBIDL() antlr.TerminalNode {
	return s.GetToken(WebIDLParserOTHER_WEBIDL, 0)
}

func (s *OtherContext) ArgumentNameKeyword() IArgumentNameKeywordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentNameKeywordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgumentNameKeywordContext)
}

func (s *OtherContext) BufferRelatedType() IBufferRelatedTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBufferRelatedTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBufferRelatedTypeContext)
}

func (s *OtherContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OtherContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OtherContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterOther(s)
	}
}

func (s *OtherContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitOther(s)
	}
}

func (p *WebIDLParser) Other() (localctx IOtherContext) {
	this := p
	_ = this

	localctx = NewOtherContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, WebIDLParserRULE_other)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(845)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserINTEGER_WEBIDL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(800)
			p.Match(WebIDLParserINTEGER_WEBIDL)
		}

	case WebIDLParserDECIMAL_WEBIDL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(801)
			p.Match(WebIDLParserDECIMAL_WEBIDL)
		}

	case WebIDLParserIDENTIFIER_WEBIDL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(802)
			p.Match(WebIDLParserIDENTIFIER_WEBIDL)
		}

	case WebIDLParserSTRING_WEBIDL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(803)
			p.Match(WebIDLParserSTRING_WEBIDL)
		}

	case WebIDLParserOTHER_WEBIDL:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(804)
			p.Match(WebIDLParserOTHER_WEBIDL)
		}

	case WebIDLParserT__79:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(805)
			p.Match(WebIDLParserT__79)
		}

	case WebIDLParserT__32:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(806)
			p.Match(WebIDLParserT__32)
		}

	case WebIDLParserT__80:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(807)
			p.Match(WebIDLParserT__80)
		}

	case WebIDLParserT__42:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(808)
			p.Match(WebIDLParserT__42)
		}

	case WebIDLParserT__28:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(809)
			p.Match(WebIDLParserT__28)
		}

	case WebIDLParserT__27:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(810)
			p.Match(WebIDLParserT__27)
		}

	case WebIDLParserT__43:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(811)
			p.Match(WebIDLParserT__43)
		}

	case WebIDLParserT__29:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(812)
			p.Match(WebIDLParserT__29)
		}

	case WebIDLParserT__44:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(813)
			p.Match(WebIDLParserT__44)
		}

	case WebIDLParserT__67:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(814)
			p.Match(WebIDLParserT__67)
		}

	case WebIDLParserT__62:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(815)
			p.Match(WebIDLParserT__62)
		}

	case WebIDLParserT__63:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(816)
			p.Match(WebIDLParserT__63)
		}

	case WebIDLParserT__50:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(817)
			p.Match(WebIDLParserT__50)
		}

	case WebIDLParserT__33:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(818)
			p.Match(WebIDLParserT__33)
		}

	case WebIDLParserT__34:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(819)
			p.Match(WebIDLParserT__34)
		}

	case WebIDLParserT__51:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(820)
			p.Match(WebIDLParserT__51)
		}

	case WebIDLParserT__65:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(821)
			p.Match(WebIDLParserT__65)
		}

	case WebIDLParserT__64:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(822)
			p.Match(WebIDLParserT__64)
		}

	case WebIDLParserT__45:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(823)
			p.Match(WebIDLParserT__45)
		}

	case WebIDLParserT__56:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(824)
			p.Match(WebIDLParserT__56)
		}

	case WebIDLParserT__53:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(825)
			p.Match(WebIDLParserT__53)
		}

	case WebIDLParserT__54:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(826)
			p.Match(WebIDLParserT__54)
		}

	case WebIDLParserT__58:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(827)
			p.Match(WebIDLParserT__58)
		}

	case WebIDLParserT__31:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(828)
			p.Match(WebIDLParserT__31)
		}

	case WebIDLParserT__57:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(829)
			p.Match(WebIDLParserT__57)
		}

	case WebIDLParserT__61:
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(830)
			p.Match(WebIDLParserT__61)
		}

	case WebIDLParserT__37:
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(831)
			p.Match(WebIDLParserT__37)
		}

	case WebIDLParserT__48:
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(832)
			p.Match(WebIDLParserT__48)
		}

	case WebIDLParserT__55:
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(833)
			p.Match(WebIDLParserT__55)
		}

	case WebIDLParserT__46:
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(834)
			p.Match(WebIDLParserT__46)
		}

	case WebIDLParserT__41:
		p.EnterOuterAlt(localctx, 36)
		{
			p.SetState(835)
			p.Match(WebIDLParserT__41)
		}

	case WebIDLParserT__66:
		p.EnterOuterAlt(localctx, 37)
		{
			p.SetState(836)
			p.Match(WebIDLParserT__66)
		}

	case WebIDLParserT__47:
		p.EnterOuterAlt(localctx, 38)
		{
			p.SetState(837)
			p.Match(WebIDLParserT__47)
		}

	case WebIDLParserT__60:
		p.EnterOuterAlt(localctx, 39)
		{
			p.SetState(838)
			p.Match(WebIDLParserT__60)
		}

	case WebIDLParserT__49:
		p.EnterOuterAlt(localctx, 40)
		{
			p.SetState(839)
			p.Match(WebIDLParserT__49)
		}

	case WebIDLParserT__30:
		p.EnterOuterAlt(localctx, 41)
		{
			p.SetState(840)
			p.Match(WebIDLParserT__30)
		}

	case WebIDLParserT__59:
		p.EnterOuterAlt(localctx, 42)
		{
			p.SetState(841)
			p.Match(WebIDLParserT__59)
		}

	case WebIDLParserT__52:
		p.EnterOuterAlt(localctx, 43)
		{
			p.SetState(842)
			p.Match(WebIDLParserT__52)
		}

	case WebIDLParserT__0, WebIDLParserT__1, WebIDLParserT__2, WebIDLParserT__3, WebIDLParserT__4, WebIDLParserT__5, WebIDLParserT__6, WebIDLParserT__7, WebIDLParserT__8, WebIDLParserT__9, WebIDLParserT__10, WebIDLParserT__11, WebIDLParserT__12, WebIDLParserT__13, WebIDLParserT__14, WebIDLParserT__15, WebIDLParserT__16, WebIDLParserT__17, WebIDLParserT__18, WebIDLParserT__19, WebIDLParserT__20, WebIDLParserT__21, WebIDLParserT__22, WebIDLParserT__23, WebIDLParserT__24:
		p.EnterOuterAlt(localctx, 44)
		{
			p.SetState(843)
			p.ArgumentNameKeyword()
		}

	case WebIDLParserT__68, WebIDLParserT__69, WebIDLParserT__70, WebIDLParserT__71, WebIDLParserT__72, WebIDLParserT__73, WebIDLParserT__74, WebIDLParserT__75, WebIDLParserT__76, WebIDLParserT__77, WebIDLParserT__78:
		p.EnterOuterAlt(localctx, 45)
		{
			p.SetState(844)
			p.BufferRelatedType()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IOtherOrCommaContext is an interface to support dynamic dispatch.
type IOtherOrCommaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOtherOrCommaContext differentiates from other interfaces.
	IsOtherOrCommaContext()
}

type OtherOrCommaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOtherOrCommaContext() *OtherOrCommaContext {
	var p = new(OtherOrCommaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_otherOrComma
	return p
}

func (*OtherOrCommaContext) IsOtherOrCommaContext() {}

func NewOtherOrCommaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OtherOrCommaContext {
	var p = new(OtherOrCommaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_otherOrComma

	return p
}

func (s *OtherOrCommaContext) GetParser() antlr.Parser { return s.parser }

func (s *OtherOrCommaContext) Other() IOtherContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOtherContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOtherContext)
}

func (s *OtherOrCommaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OtherOrCommaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OtherOrCommaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterOtherOrComma(s)
	}
}

func (s *OtherOrCommaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitOtherOrComma(s)
	}
}

func (p *WebIDLParser) OtherOrComma() (localctx IOtherOrCommaContext) {
	this := p
	_ = this

	localctx = NewOtherOrCommaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, WebIDLParserRULE_otherOrComma)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(849)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__0, WebIDLParserT__1, WebIDLParserT__2, WebIDLParserT__3, WebIDLParserT__4, WebIDLParserT__5, WebIDLParserT__6, WebIDLParserT__7, WebIDLParserT__8, WebIDLParserT__9, WebIDLParserT__10, WebIDLParserT__11, WebIDLParserT__12, WebIDLParserT__13, WebIDLParserT__14, WebIDLParserT__15, WebIDLParserT__16, WebIDLParserT__17, WebIDLParserT__18, WebIDLParserT__19, WebIDLParserT__20, WebIDLParserT__21, WebIDLParserT__22, WebIDLParserT__23, WebIDLParserT__24, WebIDLParserT__27, WebIDLParserT__28, WebIDLParserT__29, WebIDLParserT__30, WebIDLParserT__31, WebIDLParserT__32, WebIDLParserT__33, WebIDLParserT__34, WebIDLParserT__37, WebIDLParserT__41, WebIDLParserT__42, WebIDLParserT__43, WebIDLParserT__44, WebIDLParserT__45, WebIDLParserT__46, WebIDLParserT__47, WebIDLParserT__48, WebIDLParserT__49, WebIDLParserT__50, WebIDLParserT__51, WebIDLParserT__52, WebIDLParserT__53, WebIDLParserT__54, WebIDLParserT__55, WebIDLParserT__56, WebIDLParserT__57, WebIDLParserT__58, WebIDLParserT__59, WebIDLParserT__60, WebIDLParserT__61, WebIDLParserT__62, WebIDLParserT__63, WebIDLParserT__64, WebIDLParserT__65, WebIDLParserT__66, WebIDLParserT__67, WebIDLParserT__68, WebIDLParserT__69, WebIDLParserT__70, WebIDLParserT__71, WebIDLParserT__72, WebIDLParserT__73, WebIDLParserT__74, WebIDLParserT__75, WebIDLParserT__76, WebIDLParserT__77, WebIDLParserT__78, WebIDLParserT__79, WebIDLParserT__80, WebIDLParserINTEGER_WEBIDL, WebIDLParserDECIMAL_WEBIDL, WebIDLParserIDENTIFIER_WEBIDL, WebIDLParserSTRING_WEBIDL, WebIDLParserOTHER_WEBIDL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(847)
			p.Other()
		}

	case WebIDLParserT__40:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(848)
			p.Match(WebIDLParserT__40)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IIdentifierListContext is an interface to support dynamic dispatch.
type IIdentifierListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdentifierListContext differentiates from other interfaces.
	IsIdentifierListContext()
}

type IdentifierListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierListContext() *IdentifierListContext {
	var p = new(IdentifierListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_identifierList
	return p
}

func (*IdentifierListContext) IsIdentifierListContext() {}

func NewIdentifierListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierListContext {
	var p = new(IdentifierListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_identifierList

	return p
}

func (s *IdentifierListContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierListContext) IDENTIFIER_WEBIDL() antlr.TerminalNode {
	return s.GetToken(WebIDLParserIDENTIFIER_WEBIDL, 0)
}

func (s *IdentifierListContext) Identifiers() IIdentifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifiersContext)
}

func (s *IdentifierListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterIdentifierList(s)
	}
}

func (s *IdentifierListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitIdentifierList(s)
	}
}

func (p *WebIDLParser) IdentifierList() (localctx IIdentifierListContext) {
	this := p
	_ = this

	localctx = NewIdentifierListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, WebIDLParserRULE_identifierList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(851)
		p.Match(WebIDLParserIDENTIFIER_WEBIDL)
	}
	{
		p.SetState(852)
		p.Identifiers()
	}

	return localctx
}

// IIdentifiersContext is an interface to support dynamic dispatch.
type IIdentifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdentifiersContext differentiates from other interfaces.
	IsIdentifiersContext()
}

type IdentifiersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifiersContext() *IdentifiersContext {
	var p = new(IdentifiersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_identifiers
	return p
}

func (*IdentifiersContext) IsIdentifiersContext() {}

func NewIdentifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifiersContext {
	var p = new(IdentifiersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_identifiers

	return p
}

func (s *IdentifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifiersContext) IDENTIFIER_WEBIDL() antlr.TerminalNode {
	return s.GetToken(WebIDLParserIDENTIFIER_WEBIDL, 0)
}

func (s *IdentifiersContext) Identifiers() IIdentifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifiersContext)
}

func (s *IdentifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterIdentifiers(s)
	}
}

func (s *IdentifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitIdentifiers(s)
	}
}

func (p *WebIDLParser) Identifiers() (localctx IIdentifiersContext) {
	this := p
	_ = this

	localctx = NewIdentifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, WebIDLParserRULE_identifiers)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(858)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__40:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(854)
			p.Match(WebIDLParserT__40)
		}
		{
			p.SetState(855)
			p.Match(WebIDLParserIDENTIFIER_WEBIDL)
		}
		{
			p.SetState(856)
			p.Identifiers()
		}

	case WebIDLParserT__39:
		p.EnterOuterAlt(localctx, 2)

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IExtendedAttributeNoArgsContext is an interface to support dynamic dispatch.
type IExtendedAttributeNoArgsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExtendedAttributeNoArgsContext differentiates from other interfaces.
	IsExtendedAttributeNoArgsContext()
}

type ExtendedAttributeNoArgsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtendedAttributeNoArgsContext() *ExtendedAttributeNoArgsContext {
	var p = new(ExtendedAttributeNoArgsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_extendedAttributeNoArgs
	return p
}

func (*ExtendedAttributeNoArgsContext) IsExtendedAttributeNoArgsContext() {}

func NewExtendedAttributeNoArgsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtendedAttributeNoArgsContext {
	var p = new(ExtendedAttributeNoArgsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_extendedAttributeNoArgs

	return p
}

func (s *ExtendedAttributeNoArgsContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtendedAttributeNoArgsContext) IDENTIFIER_WEBIDL() antlr.TerminalNode {
	return s.GetToken(WebIDLParserIDENTIFIER_WEBIDL, 0)
}

func (s *ExtendedAttributeNoArgsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtendedAttributeNoArgsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtendedAttributeNoArgsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterExtendedAttributeNoArgs(s)
	}
}

func (s *ExtendedAttributeNoArgsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitExtendedAttributeNoArgs(s)
	}
}

func (p *WebIDLParser) ExtendedAttributeNoArgs() (localctx IExtendedAttributeNoArgsContext) {
	this := p
	_ = this

	localctx = NewExtendedAttributeNoArgsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, WebIDLParserRULE_extendedAttributeNoArgs)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(860)
		p.Match(WebIDLParserIDENTIFIER_WEBIDL)
	}

	return localctx
}

// IExtendedAttributeArgListContext is an interface to support dynamic dispatch.
type IExtendedAttributeArgListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExtendedAttributeArgListContext differentiates from other interfaces.
	IsExtendedAttributeArgListContext()
}

type ExtendedAttributeArgListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtendedAttributeArgListContext() *ExtendedAttributeArgListContext {
	var p = new(ExtendedAttributeArgListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_extendedAttributeArgList
	return p
}

func (*ExtendedAttributeArgListContext) IsExtendedAttributeArgListContext() {}

func NewExtendedAttributeArgListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtendedAttributeArgListContext {
	var p = new(ExtendedAttributeArgListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_extendedAttributeArgList

	return p
}

func (s *ExtendedAttributeArgListContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtendedAttributeArgListContext) IDENTIFIER_WEBIDL() antlr.TerminalNode {
	return s.GetToken(WebIDLParserIDENTIFIER_WEBIDL, 0)
}

func (s *ExtendedAttributeArgListContext) ArgumentList() IArgumentListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgumentListContext)
}

func (s *ExtendedAttributeArgListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtendedAttributeArgListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtendedAttributeArgListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterExtendedAttributeArgList(s)
	}
}

func (s *ExtendedAttributeArgListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitExtendedAttributeArgList(s)
	}
}

func (p *WebIDLParser) ExtendedAttributeArgList() (localctx IExtendedAttributeArgListContext) {
	this := p
	_ = this

	localctx = NewExtendedAttributeArgListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, WebIDLParserRULE_extendedAttributeArgList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(862)
		p.Match(WebIDLParserIDENTIFIER_WEBIDL)
	}
	{
		p.SetState(863)
		p.Match(WebIDLParserT__38)
	}
	{
		p.SetState(864)
		p.ArgumentList()
	}
	{
		p.SetState(865)
		p.Match(WebIDLParserT__39)
	}

	return localctx
}

// IExtendedAttributeIdentContext is an interface to support dynamic dispatch.
type IExtendedAttributeIdentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExtendedAttributeIdentContext differentiates from other interfaces.
	IsExtendedAttributeIdentContext()
}

type ExtendedAttributeIdentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtendedAttributeIdentContext() *ExtendedAttributeIdentContext {
	var p = new(ExtendedAttributeIdentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_extendedAttributeIdent
	return p
}

func (*ExtendedAttributeIdentContext) IsExtendedAttributeIdentContext() {}

func NewExtendedAttributeIdentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtendedAttributeIdentContext {
	var p = new(ExtendedAttributeIdentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_extendedAttributeIdent

	return p
}

func (s *ExtendedAttributeIdentContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtendedAttributeIdentContext) AllIDENTIFIER_WEBIDL() []antlr.TerminalNode {
	return s.GetTokens(WebIDLParserIDENTIFIER_WEBIDL)
}

func (s *ExtendedAttributeIdentContext) IDENTIFIER_WEBIDL(i int) antlr.TerminalNode {
	return s.GetToken(WebIDLParserIDENTIFIER_WEBIDL, i)
}

func (s *ExtendedAttributeIdentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtendedAttributeIdentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtendedAttributeIdentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterExtendedAttributeIdent(s)
	}
}

func (s *ExtendedAttributeIdentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitExtendedAttributeIdent(s)
	}
}

func (p *WebIDLParser) ExtendedAttributeIdent() (localctx IExtendedAttributeIdentContext) {
	this := p
	_ = this

	localctx = NewExtendedAttributeIdentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, WebIDLParserRULE_extendedAttributeIdent)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(867)
		p.Match(WebIDLParserIDENTIFIER_WEBIDL)
	}
	{
		p.SetState(868)
		p.Match(WebIDLParserT__29)
	}
	{
		p.SetState(869)
		p.Match(WebIDLParserIDENTIFIER_WEBIDL)
	}

	return localctx
}

// IExtendedAttributeIdentListContext is an interface to support dynamic dispatch.
type IExtendedAttributeIdentListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExtendedAttributeIdentListContext differentiates from other interfaces.
	IsExtendedAttributeIdentListContext()
}

type ExtendedAttributeIdentListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtendedAttributeIdentListContext() *ExtendedAttributeIdentListContext {
	var p = new(ExtendedAttributeIdentListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_extendedAttributeIdentList
	return p
}

func (*ExtendedAttributeIdentListContext) IsExtendedAttributeIdentListContext() {}

func NewExtendedAttributeIdentListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtendedAttributeIdentListContext {
	var p = new(ExtendedAttributeIdentListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_extendedAttributeIdentList

	return p
}

func (s *ExtendedAttributeIdentListContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtendedAttributeIdentListContext) IDENTIFIER_WEBIDL() antlr.TerminalNode {
	return s.GetToken(WebIDLParserIDENTIFIER_WEBIDL, 0)
}

func (s *ExtendedAttributeIdentListContext) IdentifierList() IIdentifierListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *ExtendedAttributeIdentListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtendedAttributeIdentListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtendedAttributeIdentListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterExtendedAttributeIdentList(s)
	}
}

func (s *ExtendedAttributeIdentListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitExtendedAttributeIdentList(s)
	}
}

func (p *WebIDLParser) ExtendedAttributeIdentList() (localctx IExtendedAttributeIdentListContext) {
	this := p
	_ = this

	localctx = NewExtendedAttributeIdentListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, WebIDLParserRULE_extendedAttributeIdentList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(871)
		p.Match(WebIDLParserIDENTIFIER_WEBIDL)
	}
	{
		p.SetState(872)
		p.Match(WebIDLParserT__29)
	}
	{
		p.SetState(873)
		p.Match(WebIDLParserT__38)
	}
	{
		p.SetState(874)
		p.IdentifierList()
	}
	{
		p.SetState(875)
		p.Match(WebIDLParserT__39)
	}

	return localctx
}

// IExtendedAttributeNamedArgListContext is an interface to support dynamic dispatch.
type IExtendedAttributeNamedArgListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExtendedAttributeNamedArgListContext differentiates from other interfaces.
	IsExtendedAttributeNamedArgListContext()
}

type ExtendedAttributeNamedArgListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtendedAttributeNamedArgListContext() *ExtendedAttributeNamedArgListContext {
	var p = new(ExtendedAttributeNamedArgListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_extendedAttributeNamedArgList
	return p
}

func (*ExtendedAttributeNamedArgListContext) IsExtendedAttributeNamedArgListContext() {}

func NewExtendedAttributeNamedArgListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtendedAttributeNamedArgListContext {
	var p = new(ExtendedAttributeNamedArgListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_extendedAttributeNamedArgList

	return p
}

func (s *ExtendedAttributeNamedArgListContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtendedAttributeNamedArgListContext) AllIDENTIFIER_WEBIDL() []antlr.TerminalNode {
	return s.GetTokens(WebIDLParserIDENTIFIER_WEBIDL)
}

func (s *ExtendedAttributeNamedArgListContext) IDENTIFIER_WEBIDL(i int) antlr.TerminalNode {
	return s.GetToken(WebIDLParserIDENTIFIER_WEBIDL, i)
}

func (s *ExtendedAttributeNamedArgListContext) ArgumentList() IArgumentListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgumentListContext)
}

func (s *ExtendedAttributeNamedArgListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtendedAttributeNamedArgListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtendedAttributeNamedArgListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterExtendedAttributeNamedArgList(s)
	}
}

func (s *ExtendedAttributeNamedArgListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitExtendedAttributeNamedArgList(s)
	}
}

func (p *WebIDLParser) ExtendedAttributeNamedArgList() (localctx IExtendedAttributeNamedArgListContext) {
	this := p
	_ = this

	localctx = NewExtendedAttributeNamedArgListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, WebIDLParserRULE_extendedAttributeNamedArgList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(877)
		p.Match(WebIDLParserIDENTIFIER_WEBIDL)
	}
	{
		p.SetState(878)
		p.Match(WebIDLParserT__29)
	}
	{
		p.SetState(879)
		p.Match(WebIDLParserIDENTIFIER_WEBIDL)
	}
	{
		p.SetState(880)
		p.Match(WebIDLParserT__38)
	}
	{
		p.SetState(881)
		p.ArgumentList()
	}
	{
		p.SetState(882)
		p.Match(WebIDLParserT__39)
	}

	return localctx
}

// IExtendedAttributeStringContext is an interface to support dynamic dispatch.
type IExtendedAttributeStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExtendedAttributeStringContext differentiates from other interfaces.
	IsExtendedAttributeStringContext()
}

type ExtendedAttributeStringContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtendedAttributeStringContext() *ExtendedAttributeStringContext {
	var p = new(ExtendedAttributeStringContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_extendedAttributeString
	return p
}

func (*ExtendedAttributeStringContext) IsExtendedAttributeStringContext() {}

func NewExtendedAttributeStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtendedAttributeStringContext {
	var p = new(ExtendedAttributeStringContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_extendedAttributeString

	return p
}

func (s *ExtendedAttributeStringContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtendedAttributeStringContext) IDENTIFIER_WEBIDL() antlr.TerminalNode {
	return s.GetToken(WebIDLParserIDENTIFIER_WEBIDL, 0)
}

func (s *ExtendedAttributeStringContext) STRING_WEBIDL() antlr.TerminalNode {
	return s.GetToken(WebIDLParserSTRING_WEBIDL, 0)
}

func (s *ExtendedAttributeStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtendedAttributeStringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtendedAttributeStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterExtendedAttributeString(s)
	}
}

func (s *ExtendedAttributeStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitExtendedAttributeString(s)
	}
}

func (p *WebIDLParser) ExtendedAttributeString() (localctx IExtendedAttributeStringContext) {
	this := p
	_ = this

	localctx = NewExtendedAttributeStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, WebIDLParserRULE_extendedAttributeString)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(884)
		p.Match(WebIDLParserIDENTIFIER_WEBIDL)
	}
	{
		p.SetState(885)
		p.Match(WebIDLParserT__29)
	}
	{
		p.SetState(886)
		p.Match(WebIDLParserSTRING_WEBIDL)
	}

	return localctx
}

// IExtendedAttributeStringListContext is an interface to support dynamic dispatch.
type IExtendedAttributeStringListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExtendedAttributeStringListContext differentiates from other interfaces.
	IsExtendedAttributeStringListContext()
}

type ExtendedAttributeStringListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtendedAttributeStringListContext() *ExtendedAttributeStringListContext {
	var p = new(ExtendedAttributeStringListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_extendedAttributeStringList
	return p
}

func (*ExtendedAttributeStringListContext) IsExtendedAttributeStringListContext() {}

func NewExtendedAttributeStringListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtendedAttributeStringListContext {
	var p = new(ExtendedAttributeStringListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_extendedAttributeStringList

	return p
}

func (s *ExtendedAttributeStringListContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtendedAttributeStringListContext) IDENTIFIER_WEBIDL() antlr.TerminalNode {
	return s.GetToken(WebIDLParserIDENTIFIER_WEBIDL, 0)
}

func (s *ExtendedAttributeStringListContext) StringList() IStringListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStringListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStringListContext)
}

func (s *ExtendedAttributeStringListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtendedAttributeStringListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtendedAttributeStringListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterExtendedAttributeStringList(s)
	}
}

func (s *ExtendedAttributeStringListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitExtendedAttributeStringList(s)
	}
}

func (p *WebIDLParser) ExtendedAttributeStringList() (localctx IExtendedAttributeStringListContext) {
	this := p
	_ = this

	localctx = NewExtendedAttributeStringListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, WebIDLParserRULE_extendedAttributeStringList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(888)
		p.Match(WebIDLParserIDENTIFIER_WEBIDL)
	}
	{
		p.SetState(889)
		p.Match(WebIDLParserT__29)
	}
	{
		p.SetState(890)
		p.Match(WebIDLParserT__38)
	}
	{
		p.SetState(891)
		p.StringList()
	}
	{
		p.SetState(892)
		p.Match(WebIDLParserT__39)
	}

	return localctx
}

// IStringListContext is an interface to support dynamic dispatch.
type IStringListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStringListContext differentiates from other interfaces.
	IsStringListContext()
}

type StringListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringListContext() *StringListContext {
	var p = new(StringListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_stringList
	return p
}

func (*StringListContext) IsStringListContext() {}

func NewStringListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringListContext {
	var p = new(StringListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_stringList

	return p
}

func (s *StringListContext) GetParser() antlr.Parser { return s.parser }

func (s *StringListContext) STRING_WEBIDL() antlr.TerminalNode {
	return s.GetToken(WebIDLParserSTRING_WEBIDL, 0)
}

func (s *StringListContext) Strings() IStringsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStringsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStringsContext)
}

func (s *StringListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterStringList(s)
	}
}

func (s *StringListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitStringList(s)
	}
}

func (p *WebIDLParser) StringList() (localctx IStringListContext) {
	this := p
	_ = this

	localctx = NewStringListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, WebIDLParserRULE_stringList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(894)
		p.Match(WebIDLParserSTRING_WEBIDL)
	}
	{
		p.SetState(895)
		p.Strings()
	}

	return localctx
}

// IStringsContext is an interface to support dynamic dispatch.
type IStringsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStringsContext differentiates from other interfaces.
	IsStringsContext()
}

type StringsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringsContext() *StringsContext {
	var p = new(StringsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_strings
	return p
}

func (*StringsContext) IsStringsContext() {}

func NewStringsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringsContext {
	var p = new(StringsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_strings

	return p
}

func (s *StringsContext) GetParser() antlr.Parser { return s.parser }

func (s *StringsContext) STRING_WEBIDL() antlr.TerminalNode {
	return s.GetToken(WebIDLParserSTRING_WEBIDL, 0)
}

func (s *StringsContext) Strings() IStringsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStringsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStringsContext)
}

func (s *StringsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterStrings(s)
	}
}

func (s *StringsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitStrings(s)
	}
}

func (p *WebIDLParser) Strings() (localctx IStringsContext) {
	this := p
	_ = this

	localctx = NewStringsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, WebIDLParserRULE_strings)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(901)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__40:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(897)
			p.Match(WebIDLParserT__40)
		}
		{
			p.SetState(898)
			p.Match(WebIDLParserSTRING_WEBIDL)
		}
		{
			p.SetState(899)
			p.Strings()
		}

	case WebIDLParserT__39:
		p.EnterOuterAlt(localctx, 2)

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}
