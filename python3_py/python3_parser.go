// Generated from Python3.g4 by ANTLR 4.7.

package python3_py // Python3
import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 96, 1058,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4,
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55,
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9,
	60, 4, 61, 9, 61, 4, 62, 9, 62, 4, 63, 9, 63, 4, 64, 9, 64, 4, 65, 9, 65,
	4, 66, 9, 66, 4, 67, 9, 67, 4, 68, 9, 68, 4, 69, 9, 69, 4, 70, 9, 70, 4,
	71, 9, 71, 4, 72, 9, 72, 4, 73, 9, 73, 4, 74, 9, 74, 4, 75, 9, 75, 4, 76,
	9, 76, 4, 77, 9, 77, 4, 78, 9, 78, 4, 79, 9, 79, 4, 80, 9, 80, 4, 81, 9,
	81, 4, 82, 9, 82, 4, 83, 9, 83, 4, 84, 9, 84, 4, 85, 9, 85, 3, 2, 3, 2,
	3, 2, 3, 2, 3, 2, 5, 2, 176, 10, 2, 3, 3, 3, 3, 7, 3, 180, 10, 3, 12, 3,
	14, 3, 183, 11, 3, 3, 3, 3, 3, 3, 4, 3, 4, 7, 4, 189, 10, 4, 12, 4, 14,
	4, 192, 11, 4, 3, 4, 3, 4, 3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 200, 10, 5, 3,
	5, 5, 5, 203, 10, 5, 3, 5, 3, 5, 3, 6, 6, 6, 208, 10, 6, 13, 6, 14, 6,
	209, 3, 7, 3, 7, 3, 7, 5, 7, 215, 10, 7, 3, 8, 3, 8, 3, 8, 3, 8, 3, 8,
	5, 8, 222, 10, 8, 3, 8, 3, 8, 3, 8, 3, 9, 3, 9, 5, 9, 229, 10, 9, 3, 9,
	3, 9, 3, 10, 3, 10, 3, 10, 5, 10, 236, 10, 10, 3, 10, 3, 10, 3, 10, 3,
	10, 5, 10, 242, 10, 10, 7, 10, 244, 10, 10, 12, 10, 14, 10, 247, 11, 10,
	3, 10, 3, 10, 3, 10, 5, 10, 252, 10, 10, 3, 10, 3, 10, 3, 10, 3, 10, 5,
	10, 258, 10, 10, 7, 10, 260, 10, 10, 12, 10, 14, 10, 263, 11, 10, 3, 10,
	3, 10, 3, 10, 5, 10, 268, 10, 10, 3, 10, 3, 10, 5, 10, 272, 10, 10, 5,
	10, 274, 10, 10, 3, 10, 3, 10, 5, 10, 278, 10, 10, 3, 10, 3, 10, 3, 10,
	3, 10, 5, 10, 284, 10, 10, 7, 10, 286, 10, 10, 12, 10, 14, 10, 289, 11,
	10, 3, 10, 3, 10, 3, 10, 5, 10, 294, 10, 10, 3, 10, 3, 10, 5, 10, 298,
	10, 10, 3, 11, 3, 11, 3, 11, 5, 11, 303, 10, 11, 3, 12, 3, 12, 3, 12, 5,
	12, 308, 10, 12, 3, 12, 3, 12, 3, 12, 3, 12, 5, 12, 314, 10, 12, 7, 12,
	316, 10, 12, 12, 12, 14, 12, 319, 11, 12, 3, 12, 3, 12, 3, 12, 5, 12, 324,
	10, 12, 3, 12, 3, 12, 3, 12, 3, 12, 5, 12, 330, 10, 12, 7, 12, 332, 10,
	12, 12, 12, 14, 12, 335, 11, 12, 3, 12, 3, 12, 3, 12, 5, 12, 340, 10, 12,
	3, 12, 3, 12, 5, 12, 344, 10, 12, 5, 12, 346, 10, 12, 3, 12, 3, 12, 5,
	12, 350, 10, 12, 3, 12, 3, 12, 3, 12, 3, 12, 5, 12, 356, 10, 12, 7, 12,
	358, 10, 12, 12, 12, 14, 12, 361, 11, 12, 3, 12, 3, 12, 3, 12, 5, 12, 366,
	10, 12, 3, 12, 3, 12, 5, 12, 370, 10, 12, 3, 13, 3, 13, 3, 14, 3, 14, 5,
	14, 376, 10, 14, 3, 15, 3, 15, 3, 15, 7, 15, 381, 10, 15, 12, 15, 14, 15,
	384, 11, 15, 3, 15, 5, 15, 387, 10, 15, 3, 15, 3, 15, 3, 16, 3, 16, 3,
	16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 5, 16, 399, 10, 16, 3, 17, 3, 17,
	3, 17, 3, 17, 5, 17, 405, 10, 17, 3, 17, 3, 17, 3, 17, 5, 17, 410, 10,
	17, 7, 17, 412, 10, 17, 12, 17, 14, 17, 415, 11, 17, 5, 17, 417, 10, 17,
	3, 18, 3, 18, 5, 18, 421, 10, 18, 3, 18, 3, 18, 3, 18, 5, 18, 426, 10,
	18, 7, 18, 428, 10, 18, 12, 18, 14, 18, 431, 11, 18, 3, 18, 5, 18, 434,
	10, 18, 3, 19, 3, 19, 3, 20, 3, 20, 3, 20, 3, 21, 3, 21, 3, 22, 3, 22,
	3, 22, 3, 22, 3, 22, 5, 22, 448, 10, 22, 3, 23, 3, 23, 3, 24, 3, 24, 3,
	25, 3, 25, 5, 25, 456, 10, 25, 3, 26, 3, 26, 3, 27, 3, 27, 3, 27, 3, 27,
	5, 27, 464, 10, 27, 5, 27, 466, 10, 27, 3, 28, 3, 28, 5, 28, 470, 10, 28,
	3, 29, 3, 29, 3, 29, 3, 30, 3, 30, 7, 30, 477, 10, 30, 12, 30, 14, 30,
	480, 11, 30, 3, 30, 3, 30, 6, 30, 484, 10, 30, 13, 30, 14, 30, 485, 5,
	30, 488, 10, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 5, 30,
	497, 10, 30, 3, 31, 3, 31, 3, 31, 5, 31, 502, 10, 31, 3, 32, 3, 32, 3,
	32, 5, 32, 507, 10, 32, 3, 33, 3, 33, 3, 33, 7, 33, 512, 10, 33, 12, 33,
	14, 33, 515, 11, 33, 3, 33, 5, 33, 518, 10, 33, 3, 34, 3, 34, 3, 34, 7,
	34, 523, 10, 34, 12, 34, 14, 34, 526, 11, 34, 3, 35, 3, 35, 3, 35, 7, 35,
	531, 10, 35, 12, 35, 14, 35, 534, 11, 35, 3, 36, 3, 36, 3, 36, 3, 36, 7,
	36, 540, 10, 36, 12, 36, 14, 36, 543, 11, 36, 3, 37, 3, 37, 3, 37, 3, 37,
	7, 37, 549, 10, 37, 12, 37, 14, 37, 552, 11, 37, 3, 38, 3, 38, 3, 38, 3,
	38, 5, 38, 558, 10, 38, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39,
	3, 39, 5, 39, 568, 10, 39, 3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 3,
	40, 3, 40, 3, 40, 7, 40, 579, 10, 40, 12, 40, 14, 40, 582, 11, 40, 3, 40,
	3, 40, 3, 40, 5, 40, 587, 10, 40, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3,
	41, 3, 41, 5, 41, 596, 10, 41, 3, 42, 3, 42, 3, 42, 3, 42, 3, 42, 3, 42,
	3, 42, 3, 42, 3, 42, 5, 42, 607, 10, 42, 3, 43, 3, 43, 3, 43, 3, 43, 3,
	43, 3, 43, 3, 43, 6, 43, 616, 10, 43, 13, 43, 14, 43, 617, 3, 43, 3, 43,
	3, 43, 5, 43, 623, 10, 43, 3, 43, 3, 43, 3, 43, 5, 43, 628, 10, 43, 3,
	43, 3, 43, 3, 43, 5, 43, 633, 10, 43, 3, 44, 3, 44, 3, 44, 3, 44, 7, 44,
	639, 10, 44, 12, 44, 14, 44, 642, 11, 44, 3, 44, 3, 44, 3, 44, 3, 45, 3,
	45, 3, 45, 5, 45, 650, 10, 45, 3, 46, 3, 46, 3, 46, 3, 46, 5, 46, 656,
	10, 46, 5, 46, 658, 10, 46, 3, 47, 3, 47, 3, 47, 3, 47, 6, 47, 664, 10,
	47, 13, 47, 14, 47, 665, 3, 47, 3, 47, 5, 47, 670, 10, 47, 3, 48, 3, 48,
	3, 48, 3, 48, 3, 48, 3, 48, 5, 48, 678, 10, 48, 3, 48, 5, 48, 681, 10,
	48, 3, 49, 3, 49, 5, 49, 685, 10, 49, 3, 50, 3, 50, 5, 50, 689, 10, 50,
	3, 50, 3, 50, 3, 50, 3, 51, 3, 51, 5, 51, 696, 10, 51, 3, 51, 3, 51, 3,
	51, 3, 52, 3, 52, 3, 52, 7, 52, 704, 10, 52, 12, 52, 14, 52, 707, 11, 52,
	3, 53, 3, 53, 3, 53, 7, 53, 712, 10, 53, 12, 53, 14, 53, 715, 11, 53, 3,
	54, 3, 54, 3, 54, 5, 54, 720, 10, 54, 3, 55, 3, 55, 3, 55, 3, 55, 7, 55,
	726, 10, 55, 12, 55, 14, 55, 729, 11, 55, 3, 56, 3, 56, 3, 56, 3, 56, 3,
	56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 5, 56, 744,
	10, 56, 3, 57, 5, 57, 747, 10, 57, 3, 57, 3, 57, 3, 58, 3, 58, 3, 58, 7,
	58, 754, 10, 58, 12, 58, 14, 58, 757, 11, 58, 3, 59, 3, 59, 3, 59, 7, 59,
	762, 10, 59, 12, 59, 14, 59, 765, 11, 59, 3, 60, 3, 60, 3, 60, 7, 60, 770,
	10, 60, 12, 60, 14, 60, 773, 11, 60, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61,
	7, 61, 780, 10, 61, 12, 61, 14, 61, 783, 11, 61, 3, 62, 3, 62, 3, 62, 3,
	62, 3, 62, 7, 62, 790, 10, 62, 12, 62, 14, 62, 793, 11, 62, 3, 63, 3, 63,
	3, 63, 3, 63, 3, 63, 3, 63, 3, 63, 3, 63, 3, 63, 3, 63, 3, 63, 7, 63, 806,
	10, 63, 12, 63, 14, 63, 809, 11, 63, 3, 64, 3, 64, 3, 64, 3, 64, 3, 64,
	3, 64, 3, 64, 5, 64, 818, 10, 64, 3, 65, 3, 65, 7, 65, 822, 10, 65, 12,
	65, 14, 65, 825, 11, 65, 3, 65, 3, 65, 5, 65, 829, 10, 65, 3, 66, 3, 66,
	3, 66, 5, 66, 834, 10, 66, 3, 66, 3, 66, 3, 66, 5, 66, 839, 10, 66, 3,
	66, 3, 66, 3, 66, 5, 66, 844, 10, 66, 3, 66, 3, 66, 3, 66, 3, 66, 6, 66,
	850, 10, 66, 13, 66, 14, 66, 851, 3, 66, 3, 66, 3, 66, 3, 66, 5, 66, 858,
	10, 66, 3, 67, 3, 67, 3, 67, 3, 67, 7, 67, 864, 10, 67, 12, 67, 14, 67,
	867, 11, 67, 3, 67, 5, 67, 870, 10, 67, 5, 67, 872, 10, 67, 3, 68, 3, 68,
	5, 68, 876, 10, 68, 3, 68, 3, 68, 3, 68, 3, 68, 3, 68, 3, 68, 3, 68, 5,
	68, 885, 10, 68, 3, 69, 3, 69, 3, 69, 7, 69, 890, 10, 69, 12, 69, 14, 69,
	893, 11, 69, 3, 69, 5, 69, 896, 10, 69, 3, 70, 3, 70, 5, 70, 900, 10, 70,
	3, 70, 3, 70, 5, 70, 904, 10, 70, 3, 70, 5, 70, 907, 10, 70, 5, 70, 909,
	10, 70, 3, 71, 3, 71, 5, 71, 913, 10, 71, 3, 72, 3, 72, 3, 72, 7, 72, 918,
	10, 72, 12, 72, 14, 72, 921, 11, 72, 3, 72, 5, 72, 924, 10, 72, 3, 73,
	3, 73, 3, 73, 7, 73, 929, 10, 73, 12, 73, 14, 73, 932, 11, 73, 3, 73, 5,
	73, 935, 10, 73, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74,
	3, 74, 7, 74, 946, 10, 74, 12, 74, 14, 74, 949, 11, 74, 3, 74, 5, 74, 952,
	10, 74, 5, 74, 954, 10, 74, 3, 74, 3, 74, 3, 74, 3, 74, 7, 74, 960, 10,
	74, 12, 74, 14, 74, 963, 11, 74, 3, 74, 5, 74, 966, 10, 74, 5, 74, 968,
	10, 74, 5, 74, 970, 10, 74, 3, 75, 3, 75, 3, 75, 3, 75, 5, 75, 976, 10,
	75, 3, 75, 5, 75, 979, 10, 75, 3, 75, 3, 75, 3, 75, 3, 76, 3, 76, 3, 76,
	7, 76, 987, 10, 76, 12, 76, 14, 76, 990, 11, 76, 3, 76, 3, 76, 5, 76, 994,
	10, 76, 3, 76, 3, 76, 3, 76, 3, 76, 7, 76, 1000, 10, 76, 12, 76, 14, 76,
	1003, 11, 76, 3, 76, 3, 76, 3, 76, 5, 76, 1008, 10, 76, 3, 76, 3, 76, 5,
	76, 1012, 10, 76, 3, 77, 3, 77, 5, 77, 1016, 10, 77, 3, 77, 3, 77, 3, 77,
	3, 77, 5, 77, 1022, 10, 77, 3, 78, 3, 78, 5, 78, 1026, 10, 78, 3, 79, 3,
	79, 3, 79, 3, 79, 3, 79, 5, 79, 1033, 10, 79, 3, 80, 3, 80, 3, 80, 5, 80,
	1038, 10, 80, 3, 81, 3, 81, 5, 81, 1042, 10, 81, 3, 82, 3, 82, 3, 82, 5,
	82, 1047, 10, 82, 3, 83, 3, 83, 3, 84, 3, 84, 3, 84, 5, 84, 1054, 10, 84,
	3, 85, 3, 85, 3, 85, 2, 2, 86, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22,
	24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58,
	60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94,
	96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124,
	126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150, 152, 154,
	156, 158, 160, 162, 164, 166, 168, 2, 6, 3, 2, 80, 92, 3, 2, 46, 47, 3,
	2, 38, 39, 3, 2, 40, 43, 2, 1170, 2, 175, 3, 2, 2, 2, 4, 181, 3, 2, 2,
	2, 6, 186, 3, 2, 2, 2, 8, 195, 3, 2, 2, 2, 10, 207, 3, 2, 2, 2, 12, 211,
	3, 2, 2, 2, 14, 216, 3, 2, 2, 2, 16, 226, 3, 2, 2, 2, 18, 297, 3, 2, 2,
	2, 20, 299, 3, 2, 2, 2, 22, 369, 3, 2, 2, 2, 24, 371, 3, 2, 2, 2, 26, 375,
	3, 2, 2, 2, 28, 377, 3, 2, 2, 2, 30, 398, 3, 2, 2, 2, 32, 400, 3, 2, 2,
	2, 34, 420, 3, 2, 2, 2, 36, 435, 3, 2, 2, 2, 38, 437, 3, 2, 2, 2, 40, 440,
	3, 2, 2, 2, 42, 447, 3, 2, 2, 2, 44, 449, 3, 2, 2, 2, 46, 451, 3, 2, 2,
	2, 48, 453, 3, 2, 2, 2, 50, 457, 3, 2, 2, 2, 52, 459, 3, 2, 2, 2, 54, 469,
	3, 2, 2, 2, 56, 471, 3, 2, 2, 2, 58, 474, 3, 2, 2, 2, 60, 498, 3, 2, 2,
	2, 62, 503, 3, 2, 2, 2, 64, 508, 3, 2, 2, 2, 66, 519, 3, 2, 2, 2, 68, 527,
	3, 2, 2, 2, 70, 535, 3, 2, 2, 2, 72, 544, 3, 2, 2, 2, 74, 553, 3, 2, 2,
	2, 76, 567, 3, 2, 2, 2, 78, 569, 3, 2, 2, 2, 80, 588, 3, 2, 2, 2, 82, 597,
	3, 2, 2, 2, 84, 608, 3, 2, 2, 2, 86, 634, 3, 2, 2, 2, 88, 646, 3, 2, 2,
	2, 90, 651, 3, 2, 2, 2, 92, 669, 3, 2, 2, 2, 94, 680, 3, 2, 2, 2, 96, 684,
	3, 2, 2, 2, 98, 686, 3, 2, 2, 2, 100, 693, 3, 2, 2, 2, 102, 700, 3, 2,
	2, 2, 104, 708, 3, 2, 2, 2, 106, 719, 3, 2, 2, 2, 108, 721, 3, 2, 2, 2,
	110, 743, 3, 2, 2, 2, 112, 746, 3, 2, 2, 2, 114, 750, 3, 2, 2, 2, 116,
	758, 3, 2, 2, 2, 118, 766, 3, 2, 2, 2, 120, 774, 3, 2, 2, 2, 122, 784,
	3, 2, 2, 2, 124, 794, 3, 2, 2, 2, 126, 817, 3, 2, 2, 2, 128, 819, 3, 2,
	2, 2, 130, 857, 3, 2, 2, 2, 132, 859, 3, 2, 2, 2, 134, 884, 3, 2, 2, 2,
	136, 886, 3, 2, 2, 2, 138, 908, 3, 2, 2, 2, 140, 910, 3, 2, 2, 2, 142,
	914, 3, 2, 2, 2, 144, 925, 3, 2, 2, 2, 146, 969, 3, 2, 2, 2, 148, 971,
	3, 2, 2, 2, 150, 988, 3, 2, 2, 2, 152, 1021, 3, 2, 2, 2, 154, 1025, 3,
	2, 2, 2, 156, 1027, 3, 2, 2, 2, 158, 1034, 3, 2, 2, 2, 160, 1039, 3, 2,
	2, 2, 162, 1046, 3, 2, 2, 2, 164, 1048, 3, 2, 2, 2, 166, 1053, 3, 2, 2,
	2, 168, 1055, 3, 2, 2, 2, 170, 176, 7, 36, 2, 2, 171, 176, 5, 28, 15, 2,
	172, 173, 5, 76, 39, 2, 173, 174, 7, 36, 2, 2, 174, 176, 3, 2, 2, 2, 175,
	170, 3, 2, 2, 2, 175, 171, 3, 2, 2, 2, 175, 172, 3, 2, 2, 2, 176, 3, 3,
	2, 2, 2, 177, 180, 7, 36, 2, 2, 178, 180, 5, 26, 14, 2, 179, 177, 3, 2,
	2, 2, 179, 178, 3, 2, 2, 2, 180, 183, 3, 2, 2, 2, 181, 179, 3, 2, 2, 2,
	181, 182, 3, 2, 2, 2, 182, 184, 3, 2, 2, 2, 183, 181, 3, 2, 2, 2, 184,
	185, 7, 2, 2, 3, 185, 5, 3, 2, 2, 2, 186, 190, 5, 144, 73, 2, 187, 189,
	7, 36, 2, 2, 188, 187, 3, 2, 2, 2, 189, 192, 3, 2, 2, 2, 190, 188, 3, 2,
	2, 2, 190, 191, 3, 2, 2, 2, 191, 193, 3, 2, 2, 2, 192, 190, 3, 2, 2, 2,
	193, 194, 7, 2, 2, 3, 194, 7, 3, 2, 2, 2, 195, 196, 7, 78, 2, 2, 196, 202,
	5, 68, 35, 2, 197, 199, 7, 49, 2, 2, 198, 200, 5, 150, 76, 2, 199, 198,
	3, 2, 2, 2, 199, 200, 3, 2, 2, 2, 200, 201, 3, 2, 2, 2, 201, 203, 7, 50,
	2, 2, 202, 197, 3, 2, 2, 2, 202, 203, 3, 2, 2, 2, 203, 204, 3, 2, 2, 2,
	204, 205, 7, 36, 2, 2, 205, 9, 3, 2, 2, 2, 206, 208, 5, 8, 5, 2, 207, 206,
	3, 2, 2, 2, 208, 209, 3, 2, 2, 2, 209, 207, 3, 2, 2, 2, 209, 210, 3, 2,
	2, 2, 210, 11, 3, 2, 2, 2, 211, 214, 5, 10, 6, 2, 212, 215, 5, 148, 75,
	2, 213, 215, 5, 14, 8, 2, 214, 212, 3, 2, 2, 2, 214, 213, 3, 2, 2, 2, 215,
	13, 3, 2, 2, 2, 216, 217, 7, 3, 2, 2, 217, 218, 7, 37, 2, 2, 218, 221,
	5, 16, 9, 2, 219, 220, 7, 79, 2, 2, 220, 222, 5, 94, 48, 2, 221, 219, 3,
	2, 2, 2, 221, 222, 3, 2, 2, 2, 222, 223, 3, 2, 2, 2, 223, 224, 7, 52, 2,
	2, 224, 225, 5, 92, 47, 2, 225, 15, 3, 2, 2, 2, 226, 228, 7, 49, 2, 2,
	227, 229, 5, 18, 10, 2, 228, 227, 3, 2, 2, 2, 228, 229, 3, 2, 2, 2, 229,
	230, 3, 2, 2, 2, 230, 231, 7, 50, 2, 2, 231, 17, 3, 2, 2, 2, 232, 235,
	5, 20, 11, 2, 233, 234, 7, 55, 2, 2, 234, 236, 5, 94, 48, 2, 235, 233,
	3, 2, 2, 2, 235, 236, 3, 2, 2, 2, 236, 245, 3, 2, 2, 2, 237, 238, 7, 51,
	2, 2, 238, 241, 5, 20, 11, 2, 239, 240, 7, 55, 2, 2, 240, 242, 5, 94, 48,
	2, 241, 239, 3, 2, 2, 2, 241, 242, 3, 2, 2, 2, 242, 244, 3, 2, 2, 2, 243,
	237, 3, 2, 2, 2, 244, 247, 3, 2, 2, 2, 245, 243, 3, 2, 2, 2, 245, 246,
	3, 2, 2, 2, 246, 273, 3, 2, 2, 2, 247, 245, 3, 2, 2, 2, 248, 271, 7, 51,
	2, 2, 249, 251, 7, 48, 2, 2, 250, 252, 5, 20, 11, 2, 251, 250, 3, 2, 2,
	2, 251, 252, 3, 2, 2, 2, 252, 261, 3, 2, 2, 2, 253, 254, 7, 51, 2, 2, 254,
	257, 5, 20, 11, 2, 255, 256, 7, 55, 2, 2, 256, 258, 5, 94, 48, 2, 257,
	255, 3, 2, 2, 2, 257, 258, 3, 2, 2, 2, 258, 260, 3, 2, 2, 2, 259, 253,
	3, 2, 2, 2, 260, 263, 3, 2, 2, 2, 261, 259, 3, 2, 2, 2, 261, 262, 3, 2,
	2, 2, 262, 267, 3, 2, 2, 2, 263, 261, 3, 2, 2, 2, 264, 265, 7, 51, 2, 2,
	265, 266, 7, 54, 2, 2, 266, 268, 5, 20, 11, 2, 267, 264, 3, 2, 2, 2, 267,
	268, 3, 2, 2, 2, 268, 272, 3, 2, 2, 2, 269, 270, 7, 54, 2, 2, 270, 272,
	5, 20, 11, 2, 271, 249, 3, 2, 2, 2, 271, 269, 3, 2, 2, 2, 271, 272, 3,
	2, 2, 2, 272, 274, 3, 2, 2, 2, 273, 248, 3, 2, 2, 2, 273, 274, 3, 2, 2,
	2, 274, 298, 3, 2, 2, 2, 275, 277, 7, 48, 2, 2, 276, 278, 5, 20, 11, 2,
	277, 276, 3, 2, 2, 2, 277, 278, 3, 2, 2, 2, 278, 287, 3, 2, 2, 2, 279,
	280, 7, 51, 2, 2, 280, 283, 5, 20, 11, 2, 281, 282, 7, 55, 2, 2, 282, 284,
	5, 94, 48, 2, 283, 281, 3, 2, 2, 2, 283, 284, 3, 2, 2, 2, 284, 286, 3,
	2, 2, 2, 285, 279, 3, 2, 2, 2, 286, 289, 3, 2, 2, 2, 287, 285, 3, 2, 2,
	2, 287, 288, 3, 2, 2, 2, 288, 293, 3, 2, 2, 2, 289, 287, 3, 2, 2, 2, 290,
	291, 7, 51, 2, 2, 291, 292, 7, 54, 2, 2, 292, 294, 5, 20, 11, 2, 293, 290,
	3, 2, 2, 2, 293, 294, 3, 2, 2, 2, 294, 298, 3, 2, 2, 2, 295, 296, 7, 54,
	2, 2, 296, 298, 5, 20, 11, 2, 297, 232, 3, 2, 2, 2, 297, 275, 3, 2, 2,
	2, 297, 295, 3, 2, 2, 2, 298, 19, 3, 2, 2, 2, 299, 302, 7, 37, 2, 2, 300,
	301, 7, 52, 2, 2, 301, 303, 5, 94, 48, 2, 302, 300, 3, 2, 2, 2, 302, 303,
	3, 2, 2, 2, 303, 21, 3, 2, 2, 2, 304, 307, 5, 24, 13, 2, 305, 306, 7, 55,
	2, 2, 306, 308, 5, 94, 48, 2, 307, 305, 3, 2, 2, 2, 307, 308, 3, 2, 2,
	2, 308, 317, 3, 2, 2, 2, 309, 310, 7, 51, 2, 2, 310, 313, 5, 24, 13, 2,
	311, 312, 7, 55, 2, 2, 312, 314, 5, 94, 48, 2, 313, 311, 3, 2, 2, 2, 313,
	314, 3, 2, 2, 2, 314, 316, 3, 2, 2, 2, 315, 309, 3, 2, 2, 2, 316, 319,
	3, 2, 2, 2, 317, 315, 3, 2, 2, 2, 317, 318, 3, 2, 2, 2, 318, 345, 3, 2,
	2, 2, 319, 317, 3, 2, 2, 2, 320, 343, 7, 51, 2, 2, 321, 323, 7, 48, 2,
	2, 322, 324, 5, 24, 13, 2, 323, 322, 3, 2, 2, 2, 323, 324, 3, 2, 2, 2,
	324, 333, 3, 2, 2, 2, 325, 326, 7, 51, 2, 2, 326, 329, 5, 24, 13, 2, 327,
	328, 7, 55, 2, 2, 328, 330, 5, 94, 48, 2, 329, 327, 3, 2, 2, 2, 329, 330,
	3, 2, 2, 2, 330, 332, 3, 2, 2, 2, 331, 325, 3, 2, 2, 2, 332, 335, 3, 2,
	2, 2, 333, 331, 3, 2, 2, 2, 333, 334, 3, 2, 2, 2, 334, 339, 3, 2, 2, 2,
	335, 333, 3, 2, 2, 2, 336, 337, 7, 51, 2, 2, 337, 338, 7, 54, 2, 2, 338,
	340, 5, 24, 13, 2, 339, 336, 3, 2, 2, 2, 339, 340, 3, 2, 2, 2, 340, 344,
	3, 2, 2, 2, 341, 342, 7, 54, 2, 2, 342, 344, 5, 24, 13, 2, 343, 321, 3,
	2, 2, 2, 343, 341, 3, 2, 2, 2, 343, 344, 3, 2, 2, 2, 344, 346, 3, 2, 2,
	2, 345, 320, 3, 2, 2, 2, 345, 346, 3, 2, 2, 2, 346, 370, 3, 2, 2, 2, 347,
	349, 7, 48, 2, 2, 348, 350, 5, 24, 13, 2, 349, 348, 3, 2, 2, 2, 349, 350,
	3, 2, 2, 2, 350, 359, 3, 2, 2, 2, 351, 352, 7, 51, 2, 2, 352, 355, 5, 24,
	13, 2, 353, 354, 7, 55, 2, 2, 354, 356, 5, 94, 48, 2, 355, 353, 3, 2, 2,
	2, 355, 356, 3, 2, 2, 2, 356, 358, 3, 2, 2, 2, 357, 351, 3, 2, 2, 2, 358,
	361, 3, 2, 2, 2, 359, 357, 3, 2, 2, 2, 359, 360, 3, 2, 2, 2, 360, 365,
	3, 2, 2, 2, 361, 359, 3, 2, 2, 2, 362, 363, 7, 51, 2, 2, 363, 364, 7, 54,
	2, 2, 364, 366, 5, 24, 13, 2, 365, 362, 3, 2, 2, 2, 365, 366, 3, 2, 2,
	2, 366, 370, 3, 2, 2, 2, 367, 368, 7, 54, 2, 2, 368, 370, 5, 24, 13, 2,
	369, 304, 3, 2, 2, 2, 369, 347, 3, 2, 2, 2, 369, 367, 3, 2, 2, 2, 370,
	23, 3, 2, 2, 2, 371, 372, 7, 37, 2, 2, 372, 25, 3, 2, 2, 2, 373, 376, 5,
	28, 15, 2, 374, 376, 5, 76, 39, 2, 375, 373, 3, 2, 2, 2, 375, 374, 3, 2,
	2, 2, 376, 27, 3, 2, 2, 2, 377, 382, 5, 30, 16, 2, 378, 379, 7, 53, 2,
	2, 379, 381, 5, 30, 16, 2, 380, 378, 3, 2, 2, 2, 381, 384, 3, 2, 2, 2,
	382, 380, 3, 2, 2, 2, 382, 383, 3, 2, 2, 2, 383, 386, 3, 2, 2, 2, 384,
	382, 3, 2, 2, 2, 385, 387, 7, 53, 2, 2, 386, 385, 3, 2, 2, 2, 386, 387,
	3, 2, 2, 2, 387, 388, 3, 2, 2, 2, 388, 389, 7, 36, 2, 2, 389, 29, 3, 2,
	2, 2, 390, 399, 5, 32, 17, 2, 391, 399, 5, 38, 20, 2, 392, 399, 5, 40,
	21, 2, 393, 399, 5, 42, 22, 2, 394, 399, 5, 54, 28, 2, 395, 399, 5, 70,
	36, 2, 396, 399, 5, 72, 37, 2, 397, 399, 5, 74, 38, 2, 398, 390, 3, 2,
	2, 2, 398, 391, 3, 2, 2, 2, 398, 392, 3, 2, 2, 2, 398, 393, 3, 2, 2, 2,
	398, 394, 3, 2, 2, 2, 398, 395, 3, 2, 2, 2, 398, 396, 3, 2, 2, 2, 398,
	397, 3, 2, 2, 2, 399, 31, 3, 2, 2, 2, 400, 416, 5, 34, 18, 2, 401, 404,
	5, 36, 19, 2, 402, 405, 5, 160, 81, 2, 403, 405, 5, 144, 73, 2, 404, 402,
	3, 2, 2, 2, 404, 403, 3, 2, 2, 2, 405, 417, 3, 2, 2, 2, 406, 409, 7, 55,
	2, 2, 407, 410, 5, 160, 81, 2, 408, 410, 5, 34, 18, 2, 409, 407, 3, 2,
	2, 2, 409, 408, 3, 2, 2, 2, 410, 412, 3, 2, 2, 2, 411, 406, 3, 2, 2, 2,
	412, 415, 3, 2, 2, 2, 413, 411, 3, 2, 2, 2, 413, 414, 3, 2, 2, 2, 414,
	417, 3, 2, 2, 2, 415, 413, 3, 2, 2, 2, 416, 401, 3, 2, 2, 2, 416, 413,
	3, 2, 2, 2, 417, 33, 3, 2, 2, 2, 418, 421, 5, 94, 48, 2, 419, 421, 5, 112,
	57, 2, 420, 418, 3, 2, 2, 2, 420, 419, 3, 2, 2, 2, 421, 429, 3, 2, 2, 2,
	422, 425, 7, 51, 2, 2, 423, 426, 5, 94, 48, 2, 424, 426, 5, 112, 57, 2,
	425, 423, 3, 2, 2, 2, 425, 424, 3, 2, 2, 2, 426, 428, 3, 2, 2, 2, 427,
	422, 3, 2, 2, 2, 428, 431, 3, 2, 2, 2, 429, 427, 3, 2, 2, 2, 429, 430,
	3, 2, 2, 2, 430, 433, 3, 2, 2, 2, 431, 429, 3, 2, 2, 2, 432, 434, 7, 51,
	2, 2, 433, 432, 3, 2, 2, 2, 433, 434, 3, 2, 2, 2, 434, 35, 3, 2, 2, 2,
	435, 436, 9, 2, 2, 2, 436, 37, 3, 2, 2, 2, 437, 438, 7, 32, 2, 2, 438,
	439, 5, 142, 72, 2, 439, 39, 3, 2, 2, 2, 440, 441, 7, 33, 2, 2, 441, 41,
	3, 2, 2, 2, 442, 448, 5, 44, 23, 2, 443, 448, 5, 46, 24, 2, 444, 448, 5,
	48, 25, 2, 445, 448, 5, 52, 27, 2, 446, 448, 5, 50, 26, 2, 447, 442, 3,
	2, 2, 2, 447, 443, 3, 2, 2, 2, 447, 444, 3, 2, 2, 2, 447, 445, 3, 2, 2,
	2, 447, 446, 3, 2, 2, 2, 448, 43, 3, 2, 2, 2, 449, 450, 7, 35, 2, 2, 450,
	45, 3, 2, 2, 2, 451, 452, 7, 34, 2, 2, 452, 47, 3, 2, 2, 2, 453, 455, 7,
	4, 2, 2, 454, 456, 5, 144, 73, 2, 455, 454, 3, 2, 2, 2, 455, 456, 3, 2,
	2, 2, 456, 49, 3, 2, 2, 2, 457, 458, 5, 160, 81, 2, 458, 51, 3, 2, 2, 2,
	459, 465, 7, 5, 2, 2, 460, 463, 5, 94, 48, 2, 461, 462, 7, 6, 2, 2, 462,
	464, 5, 94, 48, 2, 463, 461, 3, 2, 2, 2, 463, 464, 3, 2, 2, 2, 464, 466,
	3, 2, 2, 2, 465, 460, 3, 2, 2, 2, 465, 466, 3, 2, 2, 2, 466, 53, 3, 2,
	2, 2, 467, 470, 5, 56, 29, 2, 468, 470, 5, 58, 30, 2, 469, 467, 3, 2, 2,
	2, 469, 468, 3, 2, 2, 2, 470, 55, 3, 2, 2, 2, 471, 472, 7, 7, 2, 2, 472,
	473, 5, 66, 34, 2, 473, 57, 3, 2, 2, 2, 474, 487, 7, 6, 2, 2, 475, 477,
	9, 3, 2, 2, 476, 475, 3, 2, 2, 2, 477, 480, 3, 2, 2, 2, 478, 476, 3, 2,
	2, 2, 478, 479, 3, 2, 2, 2, 479, 481, 3, 2, 2, 2, 480, 478, 3, 2, 2, 2,
	481, 488, 5, 68, 35, 2, 482, 484, 9, 3, 2, 2, 483, 482, 3, 2, 2, 2, 484,
	485, 3, 2, 2, 2, 485, 483, 3, 2, 2, 2, 485, 486, 3, 2, 2, 2, 486, 488,
	3, 2, 2, 2, 487, 478, 3, 2, 2, 2, 487, 483, 3, 2, 2, 2, 488, 489, 3, 2,
	2, 2, 489, 496, 7, 7, 2, 2, 490, 497, 7, 48, 2, 2, 491, 492, 7, 49, 2,
	2, 492, 493, 5, 64, 33, 2, 493, 494, 7, 50, 2, 2, 494, 497, 3, 2, 2, 2,
	495, 497, 5, 64, 33, 2, 496, 490, 3, 2, 2, 2, 496, 491, 3, 2, 2, 2, 496,
	495, 3, 2, 2, 2, 497, 59, 3, 2, 2, 2, 498, 501, 7, 37, 2, 2, 499, 500,
	7, 8, 2, 2, 500, 502, 7, 37, 2, 2, 501, 499, 3, 2, 2, 2, 501, 502, 3, 2,
	2, 2, 502, 61, 3, 2, 2, 2, 503, 506, 5, 68, 35, 2, 504, 505, 7, 8, 2, 2,
	505, 507, 7, 37, 2, 2, 506, 504, 3, 2, 2, 2, 506, 507, 3, 2, 2, 2, 507,
	63, 3, 2, 2, 2, 508, 513, 5, 60, 31, 2, 509, 510, 7, 51, 2, 2, 510, 512,
	5, 60, 31, 2, 511, 509, 3, 2, 2, 2, 512, 515, 3, 2, 2, 2, 513, 511, 3,
	2, 2, 2, 513, 514, 3, 2, 2, 2, 514, 517, 3, 2, 2, 2, 515, 513, 3, 2, 2,
	2, 516, 518, 7, 51, 2, 2, 517, 516, 3, 2, 2, 2, 517, 518, 3, 2, 2, 2, 518,
	65, 3, 2, 2, 2, 519, 524, 5, 62, 32, 2, 520, 521, 7, 51, 2, 2, 521, 523,
	5, 62, 32, 2, 522, 520, 3, 2, 2, 2, 523, 526, 3, 2, 2, 2, 524, 522, 3,
	2, 2, 2, 524, 525, 3, 2, 2, 2, 525, 67, 3, 2, 2, 2, 526, 524, 3, 2, 2,
	2, 527, 532, 7, 37, 2, 2, 528, 529, 7, 46, 2, 2, 529, 531, 7, 37, 2, 2,
	530, 528, 3, 2, 2, 2, 531, 534, 3, 2, 2, 2, 532, 530, 3, 2, 2, 2, 532,
	533, 3, 2, 2, 2, 533, 69, 3, 2, 2, 2, 534, 532, 3, 2, 2, 2, 535, 536, 7,
	9, 2, 2, 536, 541, 7, 37, 2, 2, 537, 538, 7, 51, 2, 2, 538, 540, 7, 37,
	2, 2, 539, 537, 3, 2, 2, 2, 540, 543, 3, 2, 2, 2, 541, 539, 3, 2, 2, 2,
	541, 542, 3, 2, 2, 2, 542, 71, 3, 2, 2, 2, 543, 541, 3, 2, 2, 2, 544, 545,
	7, 10, 2, 2, 545, 550, 7, 37, 2, 2, 546, 547, 7, 51, 2, 2, 547, 549, 7,
	37, 2, 2, 548, 546, 3, 2, 2, 2, 549, 552, 3, 2, 2, 2, 550, 548, 3, 2, 2,
	2, 550, 551, 3, 2, 2, 2, 551, 73, 3, 2, 2, 2, 552, 550, 3, 2, 2, 2, 553,
	554, 7, 11, 2, 2, 554, 557, 5, 94, 48, 2, 555, 556, 7, 51, 2, 2, 556, 558,
	5, 94, 48, 2, 557, 555, 3, 2, 2, 2, 557, 558, 3, 2, 2, 2, 558, 75, 3, 2,
	2, 2, 559, 568, 5, 78, 40, 2, 560, 568, 5, 80, 41, 2, 561, 568, 5, 82,
	42, 2, 562, 568, 5, 84, 43, 2, 563, 568, 5, 86, 44, 2, 564, 568, 5, 14,
	8, 2, 565, 568, 5, 148, 75, 2, 566, 568, 5, 12, 7, 2, 567, 559, 3, 2, 2,
	2, 567, 560, 3, 2, 2, 2, 567, 561, 3, 2, 2, 2, 567, 562, 3, 2, 2, 2, 567,
	563, 3, 2, 2, 2, 567, 564, 3, 2, 2, 2, 567, 565, 3, 2, 2, 2, 567, 566,
	3, 2, 2, 2, 568, 77, 3, 2, 2, 2, 569, 570, 7, 12, 2, 2, 570, 571, 5, 94,
	48, 2, 571, 572, 7, 52, 2, 2, 572, 580, 5, 92, 47, 2, 573, 574, 7, 13,
	2, 2, 574, 575, 5, 94, 48, 2, 575, 576, 7, 52, 2, 2, 576, 577, 5, 92, 47,
	2, 577, 579, 3, 2, 2, 2, 578, 573, 3, 2, 2, 2, 579, 582, 3, 2, 2, 2, 580,
	578, 3, 2, 2, 2, 580, 581, 3, 2, 2, 2, 581, 586, 3, 2, 2, 2, 582, 580,
	3, 2, 2, 2, 583, 584, 7, 14, 2, 2, 584, 585, 7, 52, 2, 2, 585, 587, 5,
	92, 47, 2, 586, 583, 3, 2, 2, 2, 586, 587, 3, 2, 2, 2, 587, 79, 3, 2, 2,
	2, 588, 589, 7, 15, 2, 2, 589, 590, 5, 94, 48, 2, 590, 591, 7, 52, 2, 2,
	591, 595, 5, 92, 47, 2, 592, 593, 7, 14, 2, 2, 593, 594, 7, 52, 2, 2, 594,
	596, 5, 92, 47, 2, 595, 592, 3, 2, 2, 2, 595, 596, 3, 2, 2, 2, 596, 81,
	3, 2, 2, 2, 597, 598, 7, 16, 2, 2, 598, 599, 5, 142, 72, 2, 599, 600, 7,
	17, 2, 2, 600, 601, 5, 144, 73, 2, 601, 602, 7, 52, 2, 2, 602, 606, 5,
	92, 47, 2, 603, 604, 7, 14, 2, 2, 604, 605, 7, 52, 2, 2, 605, 607, 5, 92,
	47, 2, 606, 603, 3, 2, 2, 2, 606, 607, 3, 2, 2, 2, 607, 83, 3, 2, 2, 2,
	608, 609, 7, 18, 2, 2, 609, 610, 7, 52, 2, 2, 610, 632, 5, 92, 47, 2, 611,
	612, 5, 90, 46, 2, 612, 613, 7, 52, 2, 2, 613, 614, 5, 92, 47, 2, 614,
	616, 3, 2, 2, 2, 615, 611, 3, 2, 2, 2, 616, 617, 3, 2, 2, 2, 617, 615,
	3, 2, 2, 2, 617, 618, 3, 2, 2, 2, 618, 622, 3, 2, 2, 2, 619, 620, 7, 14,
	2, 2, 620, 621, 7, 52, 2, 2, 621, 623, 5, 92, 47, 2, 622, 619, 3, 2, 2,
	2, 622, 623, 3, 2, 2, 2, 623, 627, 3, 2, 2, 2, 624, 625, 7, 19, 2, 2, 625,
	626, 7, 52, 2, 2, 626, 628, 5, 92, 47, 2, 627, 624, 3, 2, 2, 2, 627, 628,
	3, 2, 2, 2, 628, 633, 3, 2, 2, 2, 629, 630, 7, 19, 2, 2, 630, 631, 7, 52,
	2, 2, 631, 633, 5, 92, 47, 2, 632, 615, 3, 2, 2, 2, 632, 629, 3, 2, 2,
	2, 633, 85, 3, 2, 2, 2, 634, 635, 7, 20, 2, 2, 635, 640, 5, 88, 45, 2,
	636, 637, 7, 51, 2, 2, 637, 639, 5, 88, 45, 2, 638, 636, 3, 2, 2, 2, 639,
	642, 3, 2, 2, 2, 640, 638, 3, 2, 2, 2, 640, 641, 3, 2, 2, 2, 641, 643,
	3, 2, 2, 2, 642, 640, 3, 2, 2, 2, 643, 644, 7, 52, 2, 2, 644, 645, 5, 92,
	47, 2, 645, 87, 3, 2, 2, 2, 646, 649, 5, 94, 48, 2, 647, 648, 7, 8, 2,
	2, 648, 650, 5, 114, 58, 2, 649, 647, 3, 2, 2, 2, 649, 650, 3, 2, 2, 2,
	650, 89, 3, 2, 2, 2, 651, 657, 7, 21, 2, 2, 652, 655, 5, 94, 48, 2, 653,
	654, 7, 8, 2, 2, 654, 656, 7, 37, 2, 2, 655, 653, 3, 2, 2, 2, 655, 656,
	3, 2, 2, 2, 656, 658, 3, 2, 2, 2, 657, 652, 3, 2, 2, 2, 657, 658, 3, 2,
	2, 2, 658, 91, 3, 2, 2, 2, 659, 670, 5, 28, 15, 2, 660, 661, 7, 36, 2,
	2, 661, 663, 7, 95, 2, 2, 662, 664, 5, 26, 14, 2, 663, 662, 3, 2, 2, 2,
	664, 665, 3, 2, 2, 2, 665, 663, 3, 2, 2, 2, 665, 666, 3, 2, 2, 2, 666,
	667, 3, 2, 2, 2, 667, 668, 7, 96, 2, 2, 668, 670, 3, 2, 2, 2, 669, 659,
	3, 2, 2, 2, 669, 660, 3, 2, 2, 2, 670, 93, 3, 2, 2, 2, 671, 677, 5, 102,
	52, 2, 672, 673, 7, 12, 2, 2, 673, 674, 5, 102, 52, 2, 674, 675, 7, 14,
	2, 2, 675, 676, 5, 94, 48, 2, 676, 678, 3, 2, 2, 2, 677, 672, 3, 2, 2,
	2, 677, 678, 3, 2, 2, 2, 678, 681, 3, 2, 2, 2, 679, 681, 5, 98, 50, 2,
	680, 671, 3, 2, 2, 2, 680, 679, 3, 2, 2, 2, 681, 95, 3, 2, 2, 2, 682, 685,
	5, 102, 52, 2, 683, 685, 5, 100, 51, 2, 684, 682, 3, 2, 2, 2, 684, 683,
	3, 2, 2, 2, 685, 97, 3, 2, 2, 2, 686, 688, 7, 22, 2, 2, 687, 689, 5, 22,
	12, 2, 688, 687, 3, 2, 2, 2, 688, 689, 3, 2, 2, 2, 689, 690, 3, 2, 2, 2,
	690, 691, 7, 52, 2, 2, 691, 692, 5, 94, 48, 2, 692, 99, 3, 2, 2, 2, 693,
	695, 7, 22, 2, 2, 694, 696, 5, 22, 12, 2, 695, 694, 3, 2, 2, 2, 695, 696,
	3, 2, 2, 2, 696, 697, 3, 2, 2, 2, 697, 698, 7, 52, 2, 2, 698, 699, 5, 96,
	49, 2, 699, 101, 3, 2, 2, 2, 700, 705, 5, 104, 53, 2, 701, 702, 7, 23,
	2, 2, 702, 704, 5, 104, 53, 2, 703, 701, 3, 2, 2, 2, 704, 707, 3, 2, 2,
	2, 705, 703, 3, 2, 2, 2, 705, 706, 3, 2, 2, 2, 706, 103, 3, 2, 2, 2, 707,
	705, 3, 2, 2, 2, 708, 713, 5, 106, 54, 2, 709, 710, 7, 24, 2, 2, 710, 712,
	5, 106, 54, 2, 711, 709, 3, 2, 2, 2, 712, 715, 3, 2, 2, 2, 713, 711, 3,
	2, 2, 2, 713, 714, 3, 2, 2, 2, 714, 105, 3, 2, 2, 2, 715, 713, 3, 2, 2,
	2, 716, 717, 7, 25, 2, 2, 717, 720, 5, 106, 54, 2, 718, 720, 5, 108, 55,
	2, 719, 716, 3, 2, 2, 2, 719, 718, 3, 2, 2, 2, 720, 107, 3, 2, 2, 2, 721,
	727, 5, 112, 57, 2, 722, 723, 5, 110, 56, 2, 723, 724, 5, 112, 57, 2, 724,
	726, 3, 2, 2, 2, 725, 722, 3, 2, 2, 2, 726, 729, 3, 2, 2, 2, 727, 725,
	3, 2, 2, 2, 727, 728, 3, 2, 2, 2, 728, 109, 3, 2, 2, 2, 729, 727, 3, 2,
	2, 2, 730, 744, 7, 71, 2, 2, 731, 744, 7, 72, 2, 2, 732, 744, 7, 73, 2,
	2, 733, 744, 7, 74, 2, 2, 734, 744, 7, 75, 2, 2, 735, 744, 7, 76, 2, 2,
	736, 744, 7, 77, 2, 2, 737, 744, 7, 17, 2, 2, 738, 739, 7, 25, 2, 2, 739,
	744, 7, 17, 2, 2, 740, 744, 7, 26, 2, 2, 741, 742, 7, 26, 2, 2, 742, 744,
	7, 25, 2, 2, 743, 730, 3, 2, 2, 2, 743, 731, 3, 2, 2, 2, 743, 732, 3, 2,
	2, 2, 743, 733, 3, 2, 2, 2, 743, 734, 3, 2, 2, 2, 743, 735, 3, 2, 2, 2,
	743, 736, 3, 2, 2, 2, 743, 737, 3, 2, 2, 2, 743, 738, 3, 2, 2, 2, 743,
	740, 3, 2, 2, 2, 743, 741, 3, 2, 2, 2, 744, 111, 3, 2, 2, 2, 745, 747,
	7, 48, 2, 2, 746, 745, 3, 2, 2, 2, 746, 747, 3, 2, 2, 2, 747, 748, 3, 2,
	2, 2, 748, 749, 5, 114, 58, 2, 749, 113, 3, 2, 2, 2, 750, 755, 5, 116,
	59, 2, 751, 752, 7, 58, 2, 2, 752, 754, 5, 116, 59, 2, 753, 751, 3, 2,
	2, 2, 754, 757, 3, 2, 2, 2, 755, 753, 3, 2, 2, 2, 755, 756, 3, 2, 2, 2,
	756, 115, 3, 2, 2, 2, 757, 755, 3, 2, 2, 2, 758, 763, 5, 118, 60, 2, 759,
	760, 7, 59, 2, 2, 760, 762, 5, 118, 60, 2, 761, 759, 3, 2, 2, 2, 762, 765,
	3, 2, 2, 2, 763, 761, 3, 2, 2, 2, 763, 764, 3, 2, 2, 2, 764, 117, 3, 2,
	2, 2, 765, 763, 3, 2, 2, 2, 766, 771, 5, 120, 61, 2, 767, 768, 7, 60, 2,
	2, 768, 770, 5, 120, 61, 2, 769, 767, 3, 2, 2, 2, 770, 773, 3, 2, 2, 2,
	771, 769, 3, 2, 2, 2, 771, 772, 3, 2, 2, 2, 772, 119, 3, 2, 2, 2, 773,
	771, 3, 2, 2, 2, 774, 781, 5, 122, 62, 2, 775, 776, 7, 61, 2, 2, 776, 780,
	5, 122, 62, 2, 777, 778, 7, 62, 2, 2, 778, 780, 5, 122, 62, 2, 779, 775,
	3, 2, 2, 2, 779, 777, 3, 2, 2, 2, 780, 783, 3, 2, 2, 2, 781, 779, 3, 2,
	2, 2, 781, 782, 3, 2, 2, 2, 782, 121, 3, 2, 2, 2, 783, 781, 3, 2, 2, 2,
	784, 791, 5, 124, 63, 2, 785, 786, 7, 63, 2, 2, 786, 790, 5, 124, 63, 2,
	787, 788, 7, 64, 2, 2, 788, 790, 5, 124, 63, 2, 789, 785, 3, 2, 2, 2, 789,
	787, 3, 2, 2, 2, 790, 793, 3, 2, 2, 2, 791, 789, 3, 2, 2, 2, 791, 792,
	3, 2, 2, 2, 792, 123, 3, 2, 2, 2, 793, 791, 3, 2, 2, 2, 794, 807, 5, 126,
	64, 2, 795, 796, 7, 48, 2, 2, 796, 806, 5, 126, 64, 2, 797, 798, 7, 65,
	2, 2, 798, 806, 5, 126, 64, 2, 799, 800, 7, 66, 2, 2, 800, 806, 5, 126,
	64, 2, 801, 802, 7, 67, 2, 2, 802, 806, 5, 126, 64, 2, 803, 804, 7, 78,
	2, 2, 804, 806, 5, 126, 64, 2, 805, 795, 3, 2, 2, 2, 805, 797, 3, 2, 2,
	2, 805, 799, 3, 2, 2, 2, 805, 801, 3, 2, 2, 2, 805, 803, 3, 2, 2, 2, 806,
	809, 3, 2, 2, 2, 807, 805, 3, 2, 2, 2, 807, 808, 3, 2, 2, 2, 808, 125,
	3, 2, 2, 2, 809, 807, 3, 2, 2, 2, 810, 811, 7, 63, 2, 2, 811, 818, 5, 126,
	64, 2, 812, 813, 7, 64, 2, 2, 813, 818, 5, 126, 64, 2, 814, 815, 7, 68,
	2, 2, 815, 818, 5, 126, 64, 2, 816, 818, 5, 128, 65, 2, 817, 810, 3, 2,
	2, 2, 817, 812, 3, 2, 2, 2, 817, 814, 3, 2, 2, 2, 817, 816, 3, 2, 2, 2,
	818, 127, 3, 2, 2, 2, 819, 823, 5, 130, 66, 2, 820, 822, 5, 134, 68, 2,
	821, 820, 3, 2, 2, 2, 822, 825, 3, 2, 2, 2, 823, 821, 3, 2, 2, 2, 823,
	824, 3, 2, 2, 2, 824, 828, 3, 2, 2, 2, 825, 823, 3, 2, 2, 2, 826, 827,
	7, 54, 2, 2, 827, 829, 5, 126, 64, 2, 828, 826, 3, 2, 2, 2, 828, 829, 3,
	2, 2, 2, 829, 129, 3, 2, 2, 2, 830, 833, 7, 49, 2, 2, 831, 834, 5, 160,
	81, 2, 832, 834, 5, 132, 67, 2, 833, 831, 3, 2, 2, 2, 833, 832, 3, 2, 2,
	2, 833, 834, 3, 2, 2, 2, 834, 835, 3, 2, 2, 2, 835, 858, 7, 50, 2, 2, 836,
	838, 7, 56, 2, 2, 837, 839, 5, 132, 67, 2, 838, 837, 3, 2, 2, 2, 838, 839,
	3, 2, 2, 2, 839, 840, 3, 2, 2, 2, 840, 858, 7, 57, 2, 2, 841, 843, 7, 69,
	2, 2, 842, 844, 5, 146, 74, 2, 843, 842, 3, 2, 2, 2, 843, 844, 3, 2, 2,
	2, 844, 845, 3, 2, 2, 2, 845, 858, 7, 70, 2, 2, 846, 858, 7, 37, 2, 2,
	847, 858, 5, 166, 84, 2, 848, 850, 5, 164, 83, 2, 849, 848, 3, 2, 2, 2,
	850, 851, 3, 2, 2, 2, 851, 849, 3, 2, 2, 2, 851, 852, 3, 2, 2, 2, 852,
	858, 3, 2, 2, 2, 853, 858, 7, 47, 2, 2, 854, 858, 7, 27, 2, 2, 855, 858,
	7, 28, 2, 2, 856, 858, 7, 29, 2, 2, 857, 830, 3, 2, 2, 2, 857, 836, 3,
	2, 2, 2, 857, 841, 3, 2, 2, 2, 857, 846, 3, 2, 2, 2, 857, 847, 3, 2, 2,
	2, 857, 849, 3, 2, 2, 2, 857, 853, 3, 2, 2, 2, 857, 854, 3, 2, 2, 2, 857,
	855, 3, 2, 2, 2, 857, 856, 3, 2, 2, 2, 858, 131, 3, 2, 2, 2, 859, 871,
	5, 94, 48, 2, 860, 872, 5, 156, 79, 2, 861, 862, 7, 51, 2, 2, 862, 864,
	5, 94, 48, 2, 863, 861, 3, 2, 2, 2, 864, 867, 3, 2, 2, 2, 865, 863, 3,
	2, 2, 2, 865, 866, 3, 2, 2, 2, 866, 869, 3, 2, 2, 2, 867, 865, 3, 2, 2,
	2, 868, 870, 7, 51, 2, 2, 869, 868, 3, 2, 2, 2, 869, 870, 3, 2, 2, 2, 870,
	872, 3, 2, 2, 2, 871, 860, 3, 2, 2, 2, 871, 865, 3, 2, 2, 2, 872, 133,
	3, 2, 2, 2, 873, 875, 7, 49, 2, 2, 874, 876, 5, 150, 76, 2, 875, 874, 3,
	2, 2, 2, 875, 876, 3, 2, 2, 2, 876, 877, 3, 2, 2, 2, 877, 885, 7, 50, 2,
	2, 878, 879, 7, 56, 2, 2, 879, 880, 5, 136, 69, 2, 880, 881, 7, 57, 2,
	2, 881, 885, 3, 2, 2, 2, 882, 883, 7, 46, 2, 2, 883, 885, 7, 37, 2, 2,
	884, 873, 3, 2, 2, 2, 884, 878, 3, 2, 2, 2, 884, 882, 3, 2, 2, 2, 885,
	135, 3, 2, 2, 2, 886, 891, 5, 138, 70, 2, 887, 888, 7, 51, 2, 2, 888, 890,
	5, 138, 70, 2, 889, 887, 3, 2, 2, 2, 890, 893, 3, 2, 2, 2, 891, 889, 3,
	2, 2, 2, 891, 892, 3, 2, 2, 2, 892, 895, 3, 2, 2, 2, 893, 891, 3, 2, 2,
	2, 894, 896, 7, 51, 2, 2, 895, 894, 3, 2, 2, 2, 895, 896, 3, 2, 2, 2, 896,
	137, 3, 2, 2, 2, 897, 909, 5, 94, 48, 2, 898, 900, 5, 94, 48, 2, 899, 898,
	3, 2, 2, 2, 899, 900, 3, 2, 2, 2, 900, 901, 3, 2, 2, 2, 901, 903, 7, 52,
	2, 2, 902, 904, 5, 94, 48, 2, 903, 902, 3, 2, 2, 2, 903, 904, 3, 2, 2,
	2, 904, 906, 3, 2, 2, 2, 905, 907, 5, 140, 71, 2, 906, 905, 3, 2, 2, 2,
	906, 907, 3, 2, 2, 2, 907, 909, 3, 2, 2, 2, 908, 897, 3, 2, 2, 2, 908,
	899, 3, 2, 2, 2, 909, 139, 3, 2, 2, 2, 910, 912, 7, 52, 2, 2, 911, 913,
	5, 94, 48, 2, 912, 911, 3, 2, 2, 2, 912, 913, 3, 2, 2, 2, 913, 141, 3,
	2, 2, 2, 914, 919, 5, 112, 57, 2, 915, 916, 7, 51, 2, 2, 916, 918, 5, 112,
	57, 2, 917, 915, 3, 2, 2, 2, 918, 921, 3, 2, 2, 2, 919, 917, 3, 2, 2, 2,
	919, 920, 3, 2, 2, 2, 920, 923, 3, 2, 2, 2, 921, 919, 3, 2, 2, 2, 922,
	924, 7, 51, 2, 2, 923, 922, 3, 2, 2, 2, 923, 924, 3, 2, 2, 2, 924, 143,
	3, 2, 2, 2, 925, 930, 5, 94, 48, 2, 926, 927, 7, 51, 2, 2, 927, 929, 5,
	94, 48, 2, 928, 926, 3, 2, 2, 2, 929, 932, 3, 2, 2, 2, 930, 928, 3, 2,
	2, 2, 930, 931, 3, 2, 2, 2, 931, 934, 3, 2, 2, 2, 932, 930, 3, 2, 2, 2,
	933, 935, 7, 51, 2, 2, 934, 933, 3, 2, 2, 2, 934, 935, 3, 2, 2, 2, 935,
	145, 3, 2, 2, 2, 936, 937, 5, 94, 48, 2, 937, 938, 7, 52, 2, 2, 938, 953,
	5, 94, 48, 2, 939, 954, 5, 156, 79, 2, 940, 941, 7, 51, 2, 2, 941, 942,
	5, 94, 48, 2, 942, 943, 7, 52, 2, 2, 943, 944, 5, 94, 48, 2, 944, 946,
	3, 2, 2, 2, 945, 940, 3, 2, 2, 2, 946, 949, 3, 2, 2, 2, 947, 945, 3, 2,
	2, 2, 947, 948, 3, 2, 2, 2, 948, 951, 3, 2, 2, 2, 949, 947, 3, 2, 2, 2,
	950, 952, 7, 51, 2, 2, 951, 950, 3, 2, 2, 2, 951, 952, 3, 2, 2, 2, 952,
	954, 3, 2, 2, 2, 953, 939, 3, 2, 2, 2, 953, 947, 3, 2, 2, 2, 954, 970,
	3, 2, 2, 2, 955, 967, 5, 94, 48, 2, 956, 968, 5, 156, 79, 2, 957, 958,
	7, 51, 2, 2, 958, 960, 5, 94, 48, 2, 959, 957, 3, 2, 2, 2, 960, 963, 3,
	2, 2, 2, 961, 959, 3, 2, 2, 2, 961, 962, 3, 2, 2, 2, 962, 965, 3, 2, 2,
	2, 963, 961, 3, 2, 2, 2, 964, 966, 7, 51, 2, 2, 965, 964, 3, 2, 2, 2, 965,
	966, 3, 2, 2, 2, 966, 968, 3, 2, 2, 2, 967, 956, 3, 2, 2, 2, 967, 961,
	3, 2, 2, 2, 968, 970, 3, 2, 2, 2, 969, 936, 3, 2, 2, 2, 969, 955, 3, 2,
	2, 2, 970, 147, 3, 2, 2, 2, 971, 972, 7, 30, 2, 2, 972, 978, 7, 37, 2,
	2, 973, 975, 7, 49, 2, 2, 974, 976, 5, 150, 76, 2, 975, 974, 3, 2, 2, 2,
	975, 976, 3, 2, 2, 2, 976, 977, 3, 2, 2, 2, 977, 979, 7, 50, 2, 2, 978,
	973, 3, 2, 2, 2, 978, 979, 3, 2, 2, 2, 979, 980, 3, 2, 2, 2, 980, 981,
	7, 52, 2, 2, 981, 982, 5, 92, 47, 2, 982, 149, 3, 2, 2, 2, 983, 984, 5,
	152, 77, 2, 984, 985, 7, 51, 2, 2, 985, 987, 3, 2, 2, 2, 986, 983, 3, 2,
	2, 2, 987, 990, 3, 2, 2, 2, 988, 986, 3, 2, 2, 2, 988, 989, 3, 2, 2, 2,
	989, 1011, 3, 2, 2, 2, 990, 988, 3, 2, 2, 2, 991, 993, 5, 152, 77, 2, 992,
	994, 7, 51, 2, 2, 993, 992, 3, 2, 2, 2, 993, 994, 3, 2, 2, 2, 994, 1012,
	3, 2, 2, 2, 995, 996, 7, 48, 2, 2, 996, 1001, 5, 94, 48, 2, 997, 998, 7,
	51, 2, 2, 998, 1000, 5, 152, 77, 2, 999, 997, 3, 2, 2, 2, 1000, 1003, 3,
	2, 2, 2, 1001, 999, 3, 2, 2, 2, 1001, 1002, 3, 2, 2, 2, 1002, 1007, 3,
	2, 2, 2, 1003, 1001, 3, 2, 2, 2, 1004, 1005, 7, 51, 2, 2, 1005, 1006, 7,
	54, 2, 2, 1006, 1008, 5, 94, 48, 2, 1007, 1004, 3, 2, 2, 2, 1007, 1008,
	3, 2, 2, 2, 1008, 1012, 3, 2, 2, 2, 1009, 1010, 7, 54, 2, 2, 1010, 1012,
	5, 94, 48, 2, 1011, 991, 3, 2, 2, 2, 1011, 995, 3, 2, 2, 2, 1011, 1009,
	3, 2, 2, 2, 1012, 151, 3, 2, 2, 2, 1013, 1015, 5, 94, 48, 2, 1014, 1016,
	5, 156, 79, 2, 1015, 1014, 3, 2, 2, 2, 1015, 1016, 3, 2, 2, 2, 1016, 1022,
	3, 2, 2, 2, 1017, 1018, 5, 94, 48, 2, 1018, 1019, 7, 55, 2, 2, 1019, 1020,
	5, 94, 48, 2, 1020, 1022, 3, 2, 2, 2, 1021, 1013, 3, 2, 2, 2, 1021, 1017,
	3, 2, 2, 2, 1022, 153, 3, 2, 2, 2, 1023, 1026, 5, 156, 79, 2, 1024, 1026,
	5, 158, 80, 2, 1025, 1023, 3, 2, 2, 2, 1025, 1024, 3, 2, 2, 2, 1026, 155,
	3, 2, 2, 2, 1027, 1028, 7, 16, 2, 2, 1028, 1029, 5, 142, 72, 2, 1029, 1030,
	7, 17, 2, 2, 1030, 1032, 5, 102, 52, 2, 1031, 1033, 5, 154, 78, 2, 1032,
	1031, 3, 2, 2, 2, 1032, 1033, 3, 2, 2, 2, 1033, 157, 3, 2, 2, 2, 1034,
	1035, 7, 12, 2, 2, 1035, 1037, 5, 96, 49, 2, 1036, 1038, 5, 154, 78, 2,
	1037, 1036, 3, 2, 2, 2, 1037, 1038, 3, 2, 2, 2, 1038, 159, 3, 2, 2, 2,
	1039, 1041, 7, 31, 2, 2, 1040, 1042, 5, 162, 82, 2, 1041, 1040, 3, 2, 2,
	2, 1041, 1042, 3, 2, 2, 2, 1042, 161, 3, 2, 2, 2, 1043, 1044, 7, 6, 2,
	2, 1044, 1047, 5, 94, 48, 2, 1045, 1047, 5, 144, 73, 2, 1046, 1043, 3,
	2, 2, 2, 1046, 1045, 3, 2, 2, 2, 1047, 163, 3, 2, 2, 2, 1048, 1049, 9,
	4, 2, 2, 1049, 165, 3, 2, 2, 2, 1050, 1054, 5, 168, 85, 2, 1051, 1054,
	7, 44, 2, 2, 1052, 1054, 7, 45, 2, 2, 1053, 1050, 3, 2, 2, 2, 1053, 1051,
	3, 2, 2, 2, 1053, 1052, 3, 2, 2, 2, 1054, 167, 3, 2, 2, 2, 1055, 1056,
	9, 5, 2, 2, 1056, 169, 3, 2, 2, 2, 152, 175, 179, 181, 190, 199, 202, 209,
	214, 221, 228, 235, 241, 245, 251, 257, 261, 267, 271, 273, 277, 283, 287,
	293, 297, 302, 307, 313, 317, 323, 329, 333, 339, 343, 345, 349, 355, 359,
	365, 369, 375, 382, 386, 398, 404, 409, 413, 416, 420, 425, 429, 433, 447,
	455, 463, 465, 469, 478, 485, 487, 496, 501, 506, 513, 517, 524, 532, 541,
	550, 557, 567, 580, 586, 595, 606, 617, 622, 627, 632, 640, 649, 655, 657,
	665, 669, 677, 680, 684, 688, 695, 705, 713, 719, 727, 743, 746, 755, 763,
	771, 779, 781, 789, 791, 805, 807, 817, 823, 828, 833, 838, 843, 851, 857,
	865, 869, 871, 875, 884, 891, 895, 899, 903, 906, 908, 912, 919, 923, 930,
	934, 947, 951, 953, 961, 965, 967, 969, 975, 978, 988, 993, 1001, 1007,
	1011, 1015, 1021, 1025, 1032, 1037, 1041, 1046, 1053,
}
var deserializer = antlr.NewATNDeserializer(nil)
var deserializedATN = deserializer.DeserializeFromUInt16(parserATN)

var literalNames = []string{
	"", "'def'", "'return'", "'raise'", "'from'", "'import'", "'as'", "'global'",
	"'nonlocal'", "'assert'", "'if'", "'elif'", "'else'", "'while'", "'for'",
	"'in'", "'try'", "'finally'", "'with'", "'except'", "'lambda'", "'or'",
	"'and'", "'not'", "'is'", "'None'", "'True'", "'False'", "'class'", "'yield'",
	"'del'", "'pass'", "'continue'", "'break'", "", "", "", "", "", "", "",
	"", "", "", "'.'", "'...'", "'*'", "'('", "')'", "','", "':'", "';'", "'**'",
	"'='", "'['", "']'", "'|'", "'^'", "'&'", "'<<'", "'>>'", "'+'", "'-'",
	"'/'", "'%'", "'//'", "'~'", "'{'", "'}'", "'<'", "'>'", "'=='", "'>='",
	"'<='", "'<>'", "'!='", "'@'", "'->'", "'+='", "'-='", "'*='", "'@='",
	"'/='", "'%='", "'&='", "'|='", "'^='", "'<<='", "'>>='", "'**='", "'//='",
}
var symbolicNames = []string{
	"", "DEF", "RETURN", "RAISE", "FROM", "IMPORT", "AS", "GLOBAL", "NONLOCAL",
	"ASSERT", "IF", "ELIF", "ELSE", "WHILE", "FOR", "IN", "TRY", "FINALLY",
	"WITH", "EXCEPT", "LAMBDA", "OR", "AND", "NOT", "IS", "NONE", "TRUE", "FALSE",
	"CLASS", "YIELD", "DEL", "PASS", "CONTINUE", "BREAK", "NEWLINE", "NAME",
	"STRING_LITERAL", "BYTES_LITERAL", "DECIMAL_INTEGER", "OCT_INTEGER", "HEX_INTEGER",
	"BIN_INTEGER", "FLOAT_NUMBER", "IMAG_NUMBER", "DOT", "ELLIPSIS", "STAR",
	"OPEN_PAREN", "CLOSE_PAREN", "COMMA", "COLON", "SEMI_COLON", "POWER", "ASSIGN",
	"OPEN_BRACK", "CLOSE_BRACK", "OR_OP", "XOR", "AND_OP", "LEFT_SHIFT", "RIGHT_SHIFT",
	"ADD", "MINUS", "DIV", "MOD", "IDIV", "NOT_OP", "OPEN_BRACE", "CLOSE_BRACE",
	"LESS_THAN", "GREATER_THAN", "EQUALS", "GT_EQ", "LT_EQ", "NOT_EQ_1", "NOT_EQ_2",
	"AT", "ARROW", "ADD_ASSIGN", "SUB_ASSIGN", "MULT_ASSIGN", "AT_ASSIGN",
	"DIV_ASSIGN", "MOD_ASSIGN", "AND_ASSIGN", "OR_ASSIGN", "XOR_ASSIGN", "LEFT_SHIFT_ASSIGN",
	"RIGHT_SHIFT_ASSIGN", "POWER_ASSIGN", "IDIV_ASSIGN", "SKIP_", "UNKNOWN_CHAR",
	"INDENT", "DEDENT",
}

var ruleNames = []string{
	"single_input", "file_input", "eval_input", "decorator", "decorators",
	"decorated", "funcdef", "parameters", "typedargslist", "tfpdef", "varargslist",
	"vfpdef", "stmt", "simple_stmt", "small_stmt", "expr_stmt", "testlist_star_expr",
	"augassign", "del_stmt", "pass_stmt", "flow_stmt", "break_stmt", "continue_stmt",
	"return_stmt", "yield_stmt", "raise_stmt", "import_stmt", "import_name",
	"import_from", "import_as_name", "dotted_as_name", "import_as_names", "dotted_as_names",
	"dotted_name", "global_stmt", "nonlocal_stmt", "assert_stmt", "compound_stmt",
	"if_stmt", "while_stmt", "for_stmt", "try_stmt", "with_stmt", "with_item",
	"except_clause", "suite", "test", "test_nocond", "lambdef", "lambdef_nocond",
	"or_test", "and_test", "not_test", "comparison", "comp_op", "star_expr",
	"expr", "xor_expr", "and_expr", "shift_expr", "arith_expr", "term", "factor",
	"power", "atom", "testlist_comp", "trailer", "subscriptlist", "subscript",
	"sliceop", "exprlist", "testlist", "dictorsetmaker", "classdef", "arglist",
	"argument", "comp_iter", "comp_for", "comp_if", "yield_expr", "yield_arg",
	"strr", "number", "integer",
}
var decisionToDFA = make([]*antlr.DFA, len(deserializedATN.DecisionToState))

func init() {
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
}

type Python3Parser struct {
	*antlr.BaseParser
}

func NewPython3Parser(input antlr.TokenStream) *Python3Parser {
	this := new(Python3Parser)

	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "Python3.g4"

	return this
}

// Python3Parser tokens.
const (
	Python3ParserEOF                = antlr.TokenEOF
	Python3ParserDEF                = 1
	Python3ParserRETURN             = 2
	Python3ParserRAISE              = 3
	Python3ParserFROM               = 4
	Python3ParserIMPORT             = 5
	Python3ParserAS                 = 6
	Python3ParserGLOBAL             = 7
	Python3ParserNONLOCAL           = 8
	Python3ParserASSERT             = 9
	Python3ParserIF                 = 10
	Python3ParserELIF               = 11
	Python3ParserELSE               = 12
	Python3ParserWHILE              = 13
	Python3ParserFOR                = 14
	Python3ParserIN                 = 15
	Python3ParserTRY                = 16
	Python3ParserFINALLY            = 17
	Python3ParserWITH               = 18
	Python3ParserEXCEPT             = 19
	Python3ParserLAMBDA             = 20
	Python3ParserOR                 = 21
	Python3ParserAND                = 22
	Python3ParserNOT                = 23
	Python3ParserIS                 = 24
	Python3ParserNONE               = 25
	Python3ParserTRUE               = 26
	Python3ParserFALSE              = 27
	Python3ParserCLASS              = 28
	Python3ParserYIELD              = 29
	Python3ParserDEL                = 30
	Python3ParserPASS               = 31
	Python3ParserCONTINUE           = 32
	Python3ParserBREAK              = 33
	Python3ParserNEWLINE            = 34
	Python3ParserNAME               = 35
	Python3ParserSTRING_LITERAL     = 36
	Python3ParserBYTES_LITERAL      = 37
	Python3ParserDECIMAL_INTEGER    = 38
	Python3ParserOCT_INTEGER        = 39
	Python3ParserHEX_INTEGER        = 40
	Python3ParserBIN_INTEGER        = 41
	Python3ParserFLOAT_NUMBER       = 42
	Python3ParserIMAG_NUMBER        = 43
	Python3ParserDOT                = 44
	Python3ParserELLIPSIS           = 45
	Python3ParserSTAR               = 46
	Python3ParserOPEN_PAREN         = 47
	Python3ParserCLOSE_PAREN        = 48
	Python3ParserCOMMA              = 49
	Python3ParserCOLON              = 50
	Python3ParserSEMI_COLON         = 51
	Python3ParserPOWER              = 52
	Python3ParserASSIGN             = 53
	Python3ParserOPEN_BRACK         = 54
	Python3ParserCLOSE_BRACK        = 55
	Python3ParserOR_OP              = 56
	Python3ParserXOR                = 57
	Python3ParserAND_OP             = 58
	Python3ParserLEFT_SHIFT         = 59
	Python3ParserRIGHT_SHIFT        = 60
	Python3ParserADD                = 61
	Python3ParserMINUS              = 62
	Python3ParserDIV                = 63
	Python3ParserMOD                = 64
	Python3ParserIDIV               = 65
	Python3ParserNOT_OP             = 66
	Python3ParserOPEN_BRACE         = 67
	Python3ParserCLOSE_BRACE        = 68
	Python3ParserLESS_THAN          = 69
	Python3ParserGREATER_THAN       = 70
	Python3ParserEQUALS             = 71
	Python3ParserGT_EQ              = 72
	Python3ParserLT_EQ              = 73
	Python3ParserNOT_EQ_1           = 74
	Python3ParserNOT_EQ_2           = 75
	Python3ParserAT                 = 76
	Python3ParserARROW              = 77
	Python3ParserADD_ASSIGN         = 78
	Python3ParserSUB_ASSIGN         = 79
	Python3ParserMULT_ASSIGN        = 80
	Python3ParserAT_ASSIGN          = 81
	Python3ParserDIV_ASSIGN         = 82
	Python3ParserMOD_ASSIGN         = 83
	Python3ParserAND_ASSIGN         = 84
	Python3ParserOR_ASSIGN          = 85
	Python3ParserXOR_ASSIGN         = 86
	Python3ParserLEFT_SHIFT_ASSIGN  = 87
	Python3ParserRIGHT_SHIFT_ASSIGN = 88
	Python3ParserPOWER_ASSIGN       = 89
	Python3ParserIDIV_ASSIGN        = 90
	Python3ParserSKIP_              = 91
	Python3ParserUNKNOWN_CHAR       = 92
	Python3ParserINDENT             = 93
	Python3ParserDEDENT             = 94
)

// Python3Parser rules.
const (
	Python3ParserRULE_single_input       = 0
	Python3ParserRULE_file_input         = 1
	Python3ParserRULE_eval_input         = 2
	Python3ParserRULE_decorator          = 3
	Python3ParserRULE_decorators         = 4
	Python3ParserRULE_decorated          = 5
	Python3ParserRULE_funcdef            = 6
	Python3ParserRULE_parameters         = 7
	Python3ParserRULE_typedargslist      = 8
	Python3ParserRULE_tfpdef             = 9
	Python3ParserRULE_varargslist        = 10
	Python3ParserRULE_vfpdef             = 11
	Python3ParserRULE_stmt               = 12
	Python3ParserRULE_simple_stmt        = 13
	Python3ParserRULE_small_stmt         = 14
	Python3ParserRULE_expr_stmt          = 15
	Python3ParserRULE_testlist_star_expr = 16
	Python3ParserRULE_augassign          = 17
	Python3ParserRULE_del_stmt           = 18
	Python3ParserRULE_pass_stmt          = 19
	Python3ParserRULE_flow_stmt          = 20
	Python3ParserRULE_break_stmt         = 21
	Python3ParserRULE_continue_stmt      = 22
	Python3ParserRULE_return_stmt        = 23
	Python3ParserRULE_yield_stmt         = 24
	Python3ParserRULE_raise_stmt         = 25
	Python3ParserRULE_import_stmt        = 26
	Python3ParserRULE_import_name        = 27
	Python3ParserRULE_import_from        = 28
	Python3ParserRULE_import_as_name     = 29
	Python3ParserRULE_dotted_as_name     = 30
	Python3ParserRULE_import_as_names    = 31
	Python3ParserRULE_dotted_as_names    = 32
	Python3ParserRULE_dotted_name        = 33
	Python3ParserRULE_global_stmt        = 34
	Python3ParserRULE_nonlocal_stmt      = 35
	Python3ParserRULE_assert_stmt        = 36
	Python3ParserRULE_compound_stmt      = 37
	Python3ParserRULE_if_stmt            = 38
	Python3ParserRULE_while_stmt         = 39
	Python3ParserRULE_for_stmt           = 40
	Python3ParserRULE_try_stmt           = 41
	Python3ParserRULE_with_stmt          = 42
	Python3ParserRULE_with_item          = 43
	Python3ParserRULE_except_clause      = 44
	Python3ParserRULE_suite              = 45
	Python3ParserRULE_test               = 46
	Python3ParserRULE_test_nocond        = 47
	Python3ParserRULE_lambdef            = 48
	Python3ParserRULE_lambdef_nocond     = 49
	Python3ParserRULE_or_test            = 50
	Python3ParserRULE_and_test           = 51
	Python3ParserRULE_not_test           = 52
	Python3ParserRULE_comparison         = 53
	Python3ParserRULE_comp_op            = 54
	Python3ParserRULE_star_expr          = 55
	Python3ParserRULE_expr               = 56
	Python3ParserRULE_xor_expr           = 57
	Python3ParserRULE_and_expr           = 58
	Python3ParserRULE_shift_expr         = 59
	Python3ParserRULE_arith_expr         = 60
	Python3ParserRULE_term               = 61
	Python3ParserRULE_factor             = 62
	Python3ParserRULE_power              = 63
	Python3ParserRULE_atom               = 64
	Python3ParserRULE_testlist_comp      = 65
	Python3ParserRULE_trailer            = 66
	Python3ParserRULE_subscriptlist      = 67
	Python3ParserRULE_subscript          = 68
	Python3ParserRULE_sliceop            = 69
	Python3ParserRULE_exprlist           = 70
	Python3ParserRULE_testlist           = 71
	Python3ParserRULE_dictorsetmaker     = 72
	Python3ParserRULE_classdef           = 73
	Python3ParserRULE_arglist            = 74
	Python3ParserRULE_argument           = 75
	Python3ParserRULE_comp_iter          = 76
	Python3ParserRULE_comp_for           = 77
	Python3ParserRULE_comp_if            = 78
	Python3ParserRULE_yield_expr         = 79
	Python3ParserRULE_yield_arg          = 80
	Python3ParserRULE_strr               = 81
	Python3ParserRULE_number             = 82
	Python3ParserRULE_integer            = 83
)

// ISingle_inputContext is an interface to support dynamic dispatch.
type ISingle_inputContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSingle_inputContext differentiates from other interfaces.
	IsSingle_inputContext()
}

type Single_inputContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingle_inputContext() *Single_inputContext {
	var p = new(Single_inputContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_single_input
	return p
}

func (*Single_inputContext) IsSingle_inputContext() {}

func NewSingle_inputContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Single_inputContext {
	var p = new(Single_inputContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_single_input

	return p
}

func (s *Single_inputContext) GetParser() antlr.Parser { return s.parser }

func (s *Single_inputContext) NEWLINE() antlr.TerminalNode {
	return s.GetToken(Python3ParserNEWLINE, 0)
}

func (s *Single_inputContext) Simple_stmt() ISimple_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimple_stmtContext)
}

func (s *Single_inputContext) Compound_stmt() ICompound_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompound_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICompound_stmtContext)
}

func (s *Single_inputContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Single_inputContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Single_inputContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterSingle_input(s)
	}
}

func (s *Single_inputContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitSingle_input(s)
	}
}

func (s *Single_inputContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitSingle_input(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Single_input() (localctx ISingle_inputContext) {
	localctx = NewSingle_inputContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, Python3ParserRULE_single_input)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(173)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Python3ParserNEWLINE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(168)
			p.Match(Python3ParserNEWLINE)
		}

	case Python3ParserRETURN, Python3ParserRAISE, Python3ParserFROM, Python3ParserIMPORT, Python3ParserGLOBAL, Python3ParserNONLOCAL, Python3ParserASSERT, Python3ParserLAMBDA, Python3ParserNOT, Python3ParserNONE, Python3ParserTRUE, Python3ParserFALSE, Python3ParserYIELD, Python3ParserDEL, Python3ParserPASS, Python3ParserCONTINUE, Python3ParserBREAK, Python3ParserNAME, Python3ParserSTRING_LITERAL, Python3ParserBYTES_LITERAL, Python3ParserDECIMAL_INTEGER, Python3ParserOCT_INTEGER, Python3ParserHEX_INTEGER, Python3ParserBIN_INTEGER, Python3ParserFLOAT_NUMBER, Python3ParserIMAG_NUMBER, Python3ParserELLIPSIS, Python3ParserSTAR, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserOPEN_BRACE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(169)
			p.Simple_stmt()
		}

	case Python3ParserDEF, Python3ParserIF, Python3ParserWHILE, Python3ParserFOR, Python3ParserTRY, Python3ParserWITH, Python3ParserCLASS, Python3ParserAT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(170)
			p.Compound_stmt()
		}
		{
			p.SetState(171)
			p.Match(Python3ParserNEWLINE)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFile_inputContext is an interface to support dynamic dispatch.
type IFile_inputContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFile_inputContext differentiates from other interfaces.
	IsFile_inputContext()
}

type File_inputContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFile_inputContext() *File_inputContext {
	var p = new(File_inputContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_file_input
	return p
}

func (*File_inputContext) IsFile_inputContext() {}

func NewFile_inputContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *File_inputContext {
	var p = new(File_inputContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_file_input

	return p
}

func (s *File_inputContext) GetParser() antlr.Parser { return s.parser }

func (s *File_inputContext) EOF() antlr.TerminalNode {
	return s.GetToken(Python3ParserEOF, 0)
}

func (s *File_inputContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserNEWLINE)
}

func (s *File_inputContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserNEWLINE, i)
}

func (s *File_inputContext) AllStmt() []IStmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStmtContext)(nil)).Elem())
	var tst = make([]IStmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStmtContext)
		}
	}

	return tst
}

func (s *File_inputContext) Stmt(i int) IStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStmtContext)
}

func (s *File_inputContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *File_inputContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *File_inputContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterFile_input(s)
	}
}

func (s *File_inputContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitFile_input(s)
	}
}

func (s *File_inputContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitFile_input(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) File_input() (localctx IFile_inputContext) {
	localctx = NewFile_inputContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, Python3ParserRULE_file_input)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(179)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Python3ParserDEF)|(1<<Python3ParserRETURN)|(1<<Python3ParserRAISE)|(1<<Python3ParserFROM)|(1<<Python3ParserIMPORT)|(1<<Python3ParserGLOBAL)|(1<<Python3ParserNONLOCAL)|(1<<Python3ParserASSERT)|(1<<Python3ParserIF)|(1<<Python3ParserWHILE)|(1<<Python3ParserFOR)|(1<<Python3ParserTRY)|(1<<Python3ParserWITH)|(1<<Python3ParserLAMBDA)|(1<<Python3ParserNOT)|(1<<Python3ParserNONE)|(1<<Python3ParserTRUE)|(1<<Python3ParserFALSE)|(1<<Python3ParserCLASS)|(1<<Python3ParserYIELD)|(1<<Python3ParserDEL)|(1<<Python3ParserPASS))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(Python3ParserCONTINUE-32))|(1<<(Python3ParserBREAK-32))|(1<<(Python3ParserNEWLINE-32))|(1<<(Python3ParserNAME-32))|(1<<(Python3ParserSTRING_LITERAL-32))|(1<<(Python3ParserBYTES_LITERAL-32))|(1<<(Python3ParserDECIMAL_INTEGER-32))|(1<<(Python3ParserOCT_INTEGER-32))|(1<<(Python3ParserHEX_INTEGER-32))|(1<<(Python3ParserBIN_INTEGER-32))|(1<<(Python3ParserFLOAT_NUMBER-32))|(1<<(Python3ParserIMAG_NUMBER-32))|(1<<(Python3ParserELLIPSIS-32))|(1<<(Python3ParserSTAR-32))|(1<<(Python3ParserOPEN_PAREN-32))|(1<<(Python3ParserOPEN_BRACK-32))|(1<<(Python3ParserADD-32))|(1<<(Python3ParserMINUS-32)))) != 0) || (((_la-66)&-(0x1f+1)) == 0 && ((1<<uint((_la-66)))&((1<<(Python3ParserNOT_OP-66))|(1<<(Python3ParserOPEN_BRACE-66))|(1<<(Python3ParserAT-66)))) != 0) {
		p.SetState(177)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case Python3ParserNEWLINE:
			{
				p.SetState(175)
				p.Match(Python3ParserNEWLINE)
			}

		case Python3ParserDEF, Python3ParserRETURN, Python3ParserRAISE, Python3ParserFROM, Python3ParserIMPORT, Python3ParserGLOBAL, Python3ParserNONLOCAL, Python3ParserASSERT, Python3ParserIF, Python3ParserWHILE, Python3ParserFOR, Python3ParserTRY, Python3ParserWITH, Python3ParserLAMBDA, Python3ParserNOT, Python3ParserNONE, Python3ParserTRUE, Python3ParserFALSE, Python3ParserCLASS, Python3ParserYIELD, Python3ParserDEL, Python3ParserPASS, Python3ParserCONTINUE, Python3ParserBREAK, Python3ParserNAME, Python3ParserSTRING_LITERAL, Python3ParserBYTES_LITERAL, Python3ParserDECIMAL_INTEGER, Python3ParserOCT_INTEGER, Python3ParserHEX_INTEGER, Python3ParserBIN_INTEGER, Python3ParserFLOAT_NUMBER, Python3ParserIMAG_NUMBER, Python3ParserELLIPSIS, Python3ParserSTAR, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserOPEN_BRACE, Python3ParserAT:
			{
				p.SetState(176)
				p.Stmt()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(181)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(182)
		p.Match(Python3ParserEOF)
	}

	return localctx
}

// IEval_inputContext is an interface to support dynamic dispatch.
type IEval_inputContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEval_inputContext differentiates from other interfaces.
	IsEval_inputContext()
}

type Eval_inputContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEval_inputContext() *Eval_inputContext {
	var p = new(Eval_inputContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_eval_input
	return p
}

func (*Eval_inputContext) IsEval_inputContext() {}

func NewEval_inputContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Eval_inputContext {
	var p = new(Eval_inputContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_eval_input

	return p
}

func (s *Eval_inputContext) GetParser() antlr.Parser { return s.parser }

func (s *Eval_inputContext) Testlist() ITestlistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestlistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestlistContext)
}

func (s *Eval_inputContext) EOF() antlr.TerminalNode {
	return s.GetToken(Python3ParserEOF, 0)
}

func (s *Eval_inputContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserNEWLINE)
}

func (s *Eval_inputContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserNEWLINE, i)
}

func (s *Eval_inputContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Eval_inputContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Eval_inputContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterEval_input(s)
	}
}

func (s *Eval_inputContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitEval_input(s)
	}
}

func (s *Eval_inputContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitEval_input(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Eval_input() (localctx IEval_inputContext) {
	localctx = NewEval_inputContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, Python3ParserRULE_eval_input)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(184)
		p.Testlist()
	}
	p.SetState(188)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Python3ParserNEWLINE {
		{
			p.SetState(185)
			p.Match(Python3ParserNEWLINE)
		}

		p.SetState(190)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(191)
		p.Match(Python3ParserEOF)
	}

	return localctx
}

// IDecoratorContext is an interface to support dynamic dispatch.
type IDecoratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDecoratorContext differentiates from other interfaces.
	IsDecoratorContext()
}

type DecoratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDecoratorContext() *DecoratorContext {
	var p = new(DecoratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_decorator
	return p
}

func (*DecoratorContext) IsDecoratorContext() {}

func NewDecoratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DecoratorContext {
	var p = new(DecoratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_decorator

	return p
}

func (s *DecoratorContext) GetParser() antlr.Parser { return s.parser }

func (s *DecoratorContext) Dotted_name() IDotted_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDotted_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDotted_nameContext)
}

func (s *DecoratorContext) NEWLINE() antlr.TerminalNode {
	return s.GetToken(Python3ParserNEWLINE, 0)
}

func (s *DecoratorContext) Arglist() IArglistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArglistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArglistContext)
}

func (s *DecoratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecoratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DecoratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterDecorator(s)
	}
}

func (s *DecoratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitDecorator(s)
	}
}

func (s *DecoratorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitDecorator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Decorator() (localctx IDecoratorContext) {
	localctx = NewDecoratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, Python3ParserRULE_decorator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(193)
		p.Match(Python3ParserAT)
	}
	{
		p.SetState(194)
		p.Dotted_name()
	}
	p.SetState(200)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserOPEN_PAREN {
		{
			p.SetState(195)
			p.Match(Python3ParserOPEN_PAREN)
		}
		p.SetState(197)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la-20)&-(0x1f+1)) == 0 && ((1<<uint((_la-20)))&((1<<(Python3ParserLAMBDA-20))|(1<<(Python3ParserNOT-20))|(1<<(Python3ParserNONE-20))|(1<<(Python3ParserTRUE-20))|(1<<(Python3ParserFALSE-20))|(1<<(Python3ParserNAME-20))|(1<<(Python3ParserSTRING_LITERAL-20))|(1<<(Python3ParserBYTES_LITERAL-20))|(1<<(Python3ParserDECIMAL_INTEGER-20))|(1<<(Python3ParserOCT_INTEGER-20))|(1<<(Python3ParserHEX_INTEGER-20))|(1<<(Python3ParserBIN_INTEGER-20))|(1<<(Python3ParserFLOAT_NUMBER-20))|(1<<(Python3ParserIMAG_NUMBER-20))|(1<<(Python3ParserELLIPSIS-20))|(1<<(Python3ParserSTAR-20))|(1<<(Python3ParserOPEN_PAREN-20)))) != 0) || (((_la-52)&-(0x1f+1)) == 0 && ((1<<uint((_la-52)))&((1<<(Python3ParserPOWER-52))|(1<<(Python3ParserOPEN_BRACK-52))|(1<<(Python3ParserADD-52))|(1<<(Python3ParserMINUS-52))|(1<<(Python3ParserNOT_OP-52))|(1<<(Python3ParserOPEN_BRACE-52)))) != 0) {
			{
				p.SetState(196)
				p.Arglist()
			}

		}
		{
			p.SetState(199)
			p.Match(Python3ParserCLOSE_PAREN)
		}

	}
	{
		p.SetState(202)
		p.Match(Python3ParserNEWLINE)
	}

	return localctx
}

// IDecoratorsContext is an interface to support dynamic dispatch.
type IDecoratorsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDecoratorsContext differentiates from other interfaces.
	IsDecoratorsContext()
}

type DecoratorsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDecoratorsContext() *DecoratorsContext {
	var p = new(DecoratorsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_decorators
	return p
}

func (*DecoratorsContext) IsDecoratorsContext() {}

func NewDecoratorsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DecoratorsContext {
	var p = new(DecoratorsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_decorators

	return p
}

func (s *DecoratorsContext) GetParser() antlr.Parser { return s.parser }

func (s *DecoratorsContext) AllDecorator() []IDecoratorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDecoratorContext)(nil)).Elem())
	var tst = make([]IDecoratorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDecoratorContext)
		}
	}

	return tst
}

func (s *DecoratorsContext) Decorator(i int) IDecoratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDecoratorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDecoratorContext)
}

func (s *DecoratorsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecoratorsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DecoratorsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterDecorators(s)
	}
}

func (s *DecoratorsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitDecorators(s)
	}
}

func (s *DecoratorsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitDecorators(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Decorators() (localctx IDecoratorsContext) {
	localctx = NewDecoratorsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, Python3ParserRULE_decorators)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(205)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == Python3ParserAT {
		{
			p.SetState(204)
			p.Decorator()
		}

		p.SetState(207)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IDecoratedContext is an interface to support dynamic dispatch.
type IDecoratedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDecoratedContext differentiates from other interfaces.
	IsDecoratedContext()
}

type DecoratedContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDecoratedContext() *DecoratedContext {
	var p = new(DecoratedContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_decorated
	return p
}

func (*DecoratedContext) IsDecoratedContext() {}

func NewDecoratedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DecoratedContext {
	var p = new(DecoratedContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_decorated

	return p
}

func (s *DecoratedContext) GetParser() antlr.Parser { return s.parser }

func (s *DecoratedContext) Decorators() IDecoratorsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDecoratorsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDecoratorsContext)
}

func (s *DecoratedContext) Classdef() IClassdefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassdefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassdefContext)
}

func (s *DecoratedContext) Funcdef() IFuncdefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFuncdefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFuncdefContext)
}

func (s *DecoratedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecoratedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DecoratedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterDecorated(s)
	}
}

func (s *DecoratedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitDecorated(s)
	}
}

func (s *DecoratedContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitDecorated(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Decorated() (localctx IDecoratedContext) {
	localctx = NewDecoratedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, Python3ParserRULE_decorated)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(209)
		p.Decorators()
	}
	p.SetState(212)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Python3ParserCLASS:
		{
			p.SetState(210)
			p.Classdef()
		}

	case Python3ParserDEF:
		{
			p.SetState(211)
			p.Funcdef()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFuncdefContext is an interface to support dynamic dispatch.
type IFuncdefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFuncdefContext differentiates from other interfaces.
	IsFuncdefContext()
}

type FuncdefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFuncdefContext() *FuncdefContext {
	var p = new(FuncdefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_funcdef
	return p
}

func (*FuncdefContext) IsFuncdefContext() {}

func NewFuncdefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FuncdefContext {
	var p = new(FuncdefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_funcdef

	return p
}

func (s *FuncdefContext) GetParser() antlr.Parser { return s.parser }

func (s *FuncdefContext) DEF() antlr.TerminalNode {
	return s.GetToken(Python3ParserDEF, 0)
}

func (s *FuncdefContext) NAME() antlr.TerminalNode {
	return s.GetToken(Python3ParserNAME, 0)
}

func (s *FuncdefContext) Parameters() IParametersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParametersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParametersContext)
}

func (s *FuncdefContext) Suite() ISuiteContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISuiteContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISuiteContext)
}

func (s *FuncdefContext) Test() ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *FuncdefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FuncdefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FuncdefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterFuncdef(s)
	}
}

func (s *FuncdefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitFuncdef(s)
	}
}

func (s *FuncdefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitFuncdef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Funcdef() (localctx IFuncdefContext) {
	localctx = NewFuncdefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, Python3ParserRULE_funcdef)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(214)
		p.Match(Python3ParserDEF)
	}
	{
		p.SetState(215)
		p.Match(Python3ParserNAME)
	}
	{
		p.SetState(216)
		p.Parameters()
	}
	p.SetState(219)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserARROW {
		{
			p.SetState(217)
			p.Match(Python3ParserARROW)
		}
		{
			p.SetState(218)
			p.Test()
		}

	}
	{
		p.SetState(221)
		p.Match(Python3ParserCOLON)
	}
	{
		p.SetState(222)
		p.Suite()
	}

	return localctx
}

// IParametersContext is an interface to support dynamic dispatch.
type IParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParametersContext differentiates from other interfaces.
	IsParametersContext()
}

type ParametersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParametersContext() *ParametersContext {
	var p = new(ParametersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_parameters
	return p
}

func (*ParametersContext) IsParametersContext() {}

func NewParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParametersContext {
	var p = new(ParametersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_parameters

	return p
}

func (s *ParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *ParametersContext) Typedargslist() ITypedargslistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypedargslistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypedargslistContext)
}

func (s *ParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterParameters(s)
	}
}

func (s *ParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitParameters(s)
	}
}

func (s *ParametersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitParameters(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Parameters() (localctx IParametersContext) {
	localctx = NewParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, Python3ParserRULE_parameters)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(224)
		p.Match(Python3ParserOPEN_PAREN)
	}
	p.SetState(226)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la-35)&-(0x1f+1)) == 0 && ((1<<uint((_la-35)))&((1<<(Python3ParserNAME-35))|(1<<(Python3ParserSTAR-35))|(1<<(Python3ParserPOWER-35)))) != 0 {
		{
			p.SetState(225)
			p.Typedargslist()
		}

	}
	{
		p.SetState(228)
		p.Match(Python3ParserCLOSE_PAREN)
	}

	return localctx
}

// ITypedargslistContext is an interface to support dynamic dispatch.
type ITypedargslistContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypedargslistContext differentiates from other interfaces.
	IsTypedargslistContext()
}

type TypedargslistContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypedargslistContext() *TypedargslistContext {
	var p = new(TypedargslistContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_typedargslist
	return p
}

func (*TypedargslistContext) IsTypedargslistContext() {}

func NewTypedargslistContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypedargslistContext {
	var p = new(TypedargslistContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_typedargslist

	return p
}

func (s *TypedargslistContext) GetParser() antlr.Parser { return s.parser }

func (s *TypedargslistContext) AllTfpdef() []ITfpdefContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITfpdefContext)(nil)).Elem())
	var tst = make([]ITfpdefContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITfpdefContext)
		}
	}

	return tst
}

func (s *TypedargslistContext) Tfpdef(i int) ITfpdefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITfpdefContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITfpdefContext)
}

func (s *TypedargslistContext) AllTest() []ITestContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITestContext)(nil)).Elem())
	var tst = make([]ITestContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITestContext)
		}
	}

	return tst
}

func (s *TypedargslistContext) Test(i int) ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *TypedargslistContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypedargslistContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypedargslistContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterTypedargslist(s)
	}
}

func (s *TypedargslistContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitTypedargslist(s)
	}
}

func (s *TypedargslistContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitTypedargslist(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Typedargslist() (localctx ITypedargslistContext) {
	localctx = NewTypedargslistContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, Python3ParserRULE_typedargslist)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(295)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Python3ParserNAME:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(230)
			p.Tfpdef()
		}
		p.SetState(233)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserASSIGN {
			{
				p.SetState(231)
				p.Match(Python3ParserASSIGN)
			}
			{
				p.SetState(232)
				p.Test()
			}

		}
		p.SetState(243)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 12, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(235)
					p.Match(Python3ParserCOMMA)
				}
				{
					p.SetState(236)
					p.Tfpdef()
				}
				p.SetState(239)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == Python3ParserASSIGN {
					{
						p.SetState(237)
						p.Match(Python3ParserASSIGN)
					}
					{
						p.SetState(238)
						p.Test()
					}

				}

			}
			p.SetState(245)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 12, p.GetParserRuleContext())
		}
		p.SetState(271)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserCOMMA {
			{
				p.SetState(246)
				p.Match(Python3ParserCOMMA)
			}
			p.SetState(269)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case Python3ParserSTAR:
				{
					p.SetState(247)
					p.Match(Python3ParserSTAR)
				}
				p.SetState(249)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == Python3ParserNAME {
					{
						p.SetState(248)
						p.Tfpdef()
					}

				}
				p.SetState(259)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 15, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(251)
							p.Match(Python3ParserCOMMA)
						}
						{
							p.SetState(252)
							p.Tfpdef()
						}
						p.SetState(255)
						p.GetErrorHandler().Sync(p)
						_la = p.GetTokenStream().LA(1)

						if _la == Python3ParserASSIGN {
							{
								p.SetState(253)
								p.Match(Python3ParserASSIGN)
							}
							{
								p.SetState(254)
								p.Test()
							}

						}

					}
					p.SetState(261)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 15, p.GetParserRuleContext())
				}
				p.SetState(265)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == Python3ParserCOMMA {
					{
						p.SetState(262)
						p.Match(Python3ParserCOMMA)
					}
					{
						p.SetState(263)
						p.Match(Python3ParserPOWER)
					}
					{
						p.SetState(264)
						p.Tfpdef()
					}

				}

			case Python3ParserPOWER:
				{
					p.SetState(267)
					p.Match(Python3ParserPOWER)
				}
				{
					p.SetState(268)
					p.Tfpdef()
				}

			case Python3ParserCLOSE_PAREN:

			default:
			}

		}

	case Python3ParserSTAR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(273)
			p.Match(Python3ParserSTAR)
		}
		p.SetState(275)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserNAME {
			{
				p.SetState(274)
				p.Tfpdef()
			}

		}
		p.SetState(285)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 21, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(277)
					p.Match(Python3ParserCOMMA)
				}
				{
					p.SetState(278)
					p.Tfpdef()
				}
				p.SetState(281)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == Python3ParserASSIGN {
					{
						p.SetState(279)
						p.Match(Python3ParserASSIGN)
					}
					{
						p.SetState(280)
						p.Test()
					}

				}

			}
			p.SetState(287)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 21, p.GetParserRuleContext())
		}
		p.SetState(291)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserCOMMA {
			{
				p.SetState(288)
				p.Match(Python3ParserCOMMA)
			}
			{
				p.SetState(289)
				p.Match(Python3ParserPOWER)
			}
			{
				p.SetState(290)
				p.Tfpdef()
			}

		}

	case Python3ParserPOWER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(293)
			p.Match(Python3ParserPOWER)
		}
		{
			p.SetState(294)
			p.Tfpdef()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITfpdefContext is an interface to support dynamic dispatch.
type ITfpdefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTfpdefContext differentiates from other interfaces.
	IsTfpdefContext()
}

type TfpdefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTfpdefContext() *TfpdefContext {
	var p = new(TfpdefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_tfpdef
	return p
}

func (*TfpdefContext) IsTfpdefContext() {}

func NewTfpdefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TfpdefContext {
	var p = new(TfpdefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_tfpdef

	return p
}

func (s *TfpdefContext) GetParser() antlr.Parser { return s.parser }

func (s *TfpdefContext) NAME() antlr.TerminalNode {
	return s.GetToken(Python3ParserNAME, 0)
}

func (s *TfpdefContext) Test() ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *TfpdefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TfpdefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TfpdefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterTfpdef(s)
	}
}

func (s *TfpdefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitTfpdef(s)
	}
}

func (s *TfpdefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitTfpdef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Tfpdef() (localctx ITfpdefContext) {
	localctx = NewTfpdefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, Python3ParserRULE_tfpdef)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(297)
		p.Match(Python3ParserNAME)
	}
	p.SetState(300)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserCOLON {
		{
			p.SetState(298)
			p.Match(Python3ParserCOLON)
		}
		{
			p.SetState(299)
			p.Test()
		}

	}

	return localctx
}

// IVarargslistContext is an interface to support dynamic dispatch.
type IVarargslistContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVarargslistContext differentiates from other interfaces.
	IsVarargslistContext()
}

type VarargslistContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVarargslistContext() *VarargslistContext {
	var p = new(VarargslistContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_varargslist
	return p
}

func (*VarargslistContext) IsVarargslistContext() {}

func NewVarargslistContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VarargslistContext {
	var p = new(VarargslistContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_varargslist

	return p
}

func (s *VarargslistContext) GetParser() antlr.Parser { return s.parser }

func (s *VarargslistContext) AllVfpdef() []IVfpdefContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVfpdefContext)(nil)).Elem())
	var tst = make([]IVfpdefContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVfpdefContext)
		}
	}

	return tst
}

func (s *VarargslistContext) Vfpdef(i int) IVfpdefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVfpdefContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVfpdefContext)
}

func (s *VarargslistContext) AllTest() []ITestContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITestContext)(nil)).Elem())
	var tst = make([]ITestContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITestContext)
		}
	}

	return tst
}

func (s *VarargslistContext) Test(i int) ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *VarargslistContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VarargslistContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VarargslistContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterVarargslist(s)
	}
}

func (s *VarargslistContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitVarargslist(s)
	}
}

func (s *VarargslistContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitVarargslist(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Varargslist() (localctx IVarargslistContext) {
	localctx = NewVarargslistContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, Python3ParserRULE_varargslist)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(367)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Python3ParserNAME:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(302)
			p.Vfpdef()
		}
		p.SetState(305)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserASSIGN {
			{
				p.SetState(303)
				p.Match(Python3ParserASSIGN)
			}
			{
				p.SetState(304)
				p.Test()
			}

		}
		p.SetState(315)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 27, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(307)
					p.Match(Python3ParserCOMMA)
				}
				{
					p.SetState(308)
					p.Vfpdef()
				}
				p.SetState(311)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == Python3ParserASSIGN {
					{
						p.SetState(309)
						p.Match(Python3ParserASSIGN)
					}
					{
						p.SetState(310)
						p.Test()
					}

				}

			}
			p.SetState(317)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 27, p.GetParserRuleContext())
		}
		p.SetState(343)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserCOMMA {
			{
				p.SetState(318)
				p.Match(Python3ParserCOMMA)
			}
			p.SetState(341)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case Python3ParserSTAR:
				{
					p.SetState(319)
					p.Match(Python3ParserSTAR)
				}
				p.SetState(321)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == Python3ParserNAME {
					{
						p.SetState(320)
						p.Vfpdef()
					}

				}
				p.SetState(331)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 30, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(323)
							p.Match(Python3ParserCOMMA)
						}
						{
							p.SetState(324)
							p.Vfpdef()
						}
						p.SetState(327)
						p.GetErrorHandler().Sync(p)
						_la = p.GetTokenStream().LA(1)

						if _la == Python3ParserASSIGN {
							{
								p.SetState(325)
								p.Match(Python3ParserASSIGN)
							}
							{
								p.SetState(326)
								p.Test()
							}

						}

					}
					p.SetState(333)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 30, p.GetParserRuleContext())
				}
				p.SetState(337)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == Python3ParserCOMMA {
					{
						p.SetState(334)
						p.Match(Python3ParserCOMMA)
					}
					{
						p.SetState(335)
						p.Match(Python3ParserPOWER)
					}
					{
						p.SetState(336)
						p.Vfpdef()
					}

				}

			case Python3ParserPOWER:
				{
					p.SetState(339)
					p.Match(Python3ParserPOWER)
				}
				{
					p.SetState(340)
					p.Vfpdef()
				}

			case Python3ParserCOLON:

			default:
			}

		}

	case Python3ParserSTAR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(345)
			p.Match(Python3ParserSTAR)
		}
		p.SetState(347)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserNAME {
			{
				p.SetState(346)
				p.Vfpdef()
			}

		}
		p.SetState(357)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 36, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(349)
					p.Match(Python3ParserCOMMA)
				}
				{
					p.SetState(350)
					p.Vfpdef()
				}
				p.SetState(353)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == Python3ParserASSIGN {
					{
						p.SetState(351)
						p.Match(Python3ParserASSIGN)
					}
					{
						p.SetState(352)
						p.Test()
					}

				}

			}
			p.SetState(359)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 36, p.GetParserRuleContext())
		}
		p.SetState(363)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserCOMMA {
			{
				p.SetState(360)
				p.Match(Python3ParserCOMMA)
			}
			{
				p.SetState(361)
				p.Match(Python3ParserPOWER)
			}
			{
				p.SetState(362)
				p.Vfpdef()
			}

		}

	case Python3ParserPOWER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(365)
			p.Match(Python3ParserPOWER)
		}
		{
			p.SetState(366)
			p.Vfpdef()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IVfpdefContext is an interface to support dynamic dispatch.
type IVfpdefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVfpdefContext differentiates from other interfaces.
	IsVfpdefContext()
}

type VfpdefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVfpdefContext() *VfpdefContext {
	var p = new(VfpdefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_vfpdef
	return p
}

func (*VfpdefContext) IsVfpdefContext() {}

func NewVfpdefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VfpdefContext {
	var p = new(VfpdefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_vfpdef

	return p
}

func (s *VfpdefContext) GetParser() antlr.Parser { return s.parser }

func (s *VfpdefContext) NAME() antlr.TerminalNode {
	return s.GetToken(Python3ParserNAME, 0)
}

func (s *VfpdefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VfpdefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VfpdefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterVfpdef(s)
	}
}

func (s *VfpdefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitVfpdef(s)
	}
}

func (s *VfpdefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitVfpdef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Vfpdef() (localctx IVfpdefContext) {
	localctx = NewVfpdefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, Python3ParserRULE_vfpdef)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(369)
		p.Match(Python3ParserNAME)
	}

	return localctx
}

// IStmtContext is an interface to support dynamic dispatch.
type IStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStmtContext differentiates from other interfaces.
	IsStmtContext()
}

type StmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStmtContext() *StmtContext {
	var p = new(StmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_stmt
	return p
}

func (*StmtContext) IsStmtContext() {}

func NewStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StmtContext {
	var p = new(StmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_stmt

	return p
}

func (s *StmtContext) GetParser() antlr.Parser { return s.parser }

func (s *StmtContext) Simple_stmt() ISimple_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimple_stmtContext)
}

func (s *StmtContext) Compound_stmt() ICompound_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompound_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICompound_stmtContext)
}

func (s *StmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterStmt(s)
	}
}

func (s *StmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitStmt(s)
	}
}

func (s *StmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Stmt() (localctx IStmtContext) {
	localctx = NewStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, Python3ParserRULE_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(373)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Python3ParserRETURN, Python3ParserRAISE, Python3ParserFROM, Python3ParserIMPORT, Python3ParserGLOBAL, Python3ParserNONLOCAL, Python3ParserASSERT, Python3ParserLAMBDA, Python3ParserNOT, Python3ParserNONE, Python3ParserTRUE, Python3ParserFALSE, Python3ParserYIELD, Python3ParserDEL, Python3ParserPASS, Python3ParserCONTINUE, Python3ParserBREAK, Python3ParserNAME, Python3ParserSTRING_LITERAL, Python3ParserBYTES_LITERAL, Python3ParserDECIMAL_INTEGER, Python3ParserOCT_INTEGER, Python3ParserHEX_INTEGER, Python3ParserBIN_INTEGER, Python3ParserFLOAT_NUMBER, Python3ParserIMAG_NUMBER, Python3ParserELLIPSIS, Python3ParserSTAR, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserOPEN_BRACE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(371)
			p.Simple_stmt()
		}

	case Python3ParserDEF, Python3ParserIF, Python3ParserWHILE, Python3ParserFOR, Python3ParserTRY, Python3ParserWITH, Python3ParserCLASS, Python3ParserAT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(372)
			p.Compound_stmt()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISimple_stmtContext is an interface to support dynamic dispatch.
type ISimple_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimple_stmtContext differentiates from other interfaces.
	IsSimple_stmtContext()
}

type Simple_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimple_stmtContext() *Simple_stmtContext {
	var p = new(Simple_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_simple_stmt
	return p
}

func (*Simple_stmtContext) IsSimple_stmtContext() {}

func NewSimple_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Simple_stmtContext {
	var p = new(Simple_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_simple_stmt

	return p
}

func (s *Simple_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Simple_stmtContext) AllSmall_stmt() []ISmall_stmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISmall_stmtContext)(nil)).Elem())
	var tst = make([]ISmall_stmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISmall_stmtContext)
		}
	}

	return tst
}

func (s *Simple_stmtContext) Small_stmt(i int) ISmall_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISmall_stmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISmall_stmtContext)
}

func (s *Simple_stmtContext) NEWLINE() antlr.TerminalNode {
	return s.GetToken(Python3ParserNEWLINE, 0)
}

func (s *Simple_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Simple_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Simple_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterSimple_stmt(s)
	}
}

func (s *Simple_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitSimple_stmt(s)
	}
}

func (s *Simple_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitSimple_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Simple_stmt() (localctx ISimple_stmtContext) {
	localctx = NewSimple_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, Python3ParserRULE_simple_stmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(375)
		p.Small_stmt()
	}
	p.SetState(380)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 40, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(376)
				p.Match(Python3ParserSEMI_COLON)
			}
			{
				p.SetState(377)
				p.Small_stmt()
			}

		}
		p.SetState(382)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 40, p.GetParserRuleContext())
	}
	p.SetState(384)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserSEMI_COLON {
		{
			p.SetState(383)
			p.Match(Python3ParserSEMI_COLON)
		}

	}
	{
		p.SetState(386)
		p.Match(Python3ParserNEWLINE)
	}

	return localctx
}

// ISmall_stmtContext is an interface to support dynamic dispatch.
type ISmall_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSmall_stmtContext differentiates from other interfaces.
	IsSmall_stmtContext()
}

type Small_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySmall_stmtContext() *Small_stmtContext {
	var p = new(Small_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_small_stmt
	return p
}

func (*Small_stmtContext) IsSmall_stmtContext() {}

func NewSmall_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Small_stmtContext {
	var p = new(Small_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_small_stmt

	return p
}

func (s *Small_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Small_stmtContext) Expr_stmt() IExpr_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpr_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpr_stmtContext)
}

func (s *Small_stmtContext) Del_stmt() IDel_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDel_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDel_stmtContext)
}

func (s *Small_stmtContext) Pass_stmt() IPass_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPass_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPass_stmtContext)
}

func (s *Small_stmtContext) Flow_stmt() IFlow_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFlow_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFlow_stmtContext)
}

func (s *Small_stmtContext) Import_stmt() IImport_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImport_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImport_stmtContext)
}

func (s *Small_stmtContext) Global_stmt() IGlobal_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGlobal_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGlobal_stmtContext)
}

func (s *Small_stmtContext) Nonlocal_stmt() INonlocal_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INonlocal_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INonlocal_stmtContext)
}

func (s *Small_stmtContext) Assert_stmt() IAssert_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssert_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssert_stmtContext)
}

func (s *Small_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Small_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Small_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterSmall_stmt(s)
	}
}

func (s *Small_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitSmall_stmt(s)
	}
}

func (s *Small_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitSmall_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Small_stmt() (localctx ISmall_stmtContext) {
	localctx = NewSmall_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, Python3ParserRULE_small_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(396)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Python3ParserLAMBDA, Python3ParserNOT, Python3ParserNONE, Python3ParserTRUE, Python3ParserFALSE, Python3ParserNAME, Python3ParserSTRING_LITERAL, Python3ParserBYTES_LITERAL, Python3ParserDECIMAL_INTEGER, Python3ParserOCT_INTEGER, Python3ParserHEX_INTEGER, Python3ParserBIN_INTEGER, Python3ParserFLOAT_NUMBER, Python3ParserIMAG_NUMBER, Python3ParserELLIPSIS, Python3ParserSTAR, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserOPEN_BRACE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(388)
			p.Expr_stmt()
		}

	case Python3ParserDEL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(389)
			p.Del_stmt()
		}

	case Python3ParserPASS:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(390)
			p.Pass_stmt()
		}

	case Python3ParserRETURN, Python3ParserRAISE, Python3ParserYIELD, Python3ParserCONTINUE, Python3ParserBREAK:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(391)
			p.Flow_stmt()
		}

	case Python3ParserFROM, Python3ParserIMPORT:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(392)
			p.Import_stmt()
		}

	case Python3ParserGLOBAL:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(393)
			p.Global_stmt()
		}

	case Python3ParserNONLOCAL:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(394)
			p.Nonlocal_stmt()
		}

	case Python3ParserASSERT:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(395)
			p.Assert_stmt()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IExpr_stmtContext is an interface to support dynamic dispatch.
type IExpr_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpr_stmtContext differentiates from other interfaces.
	IsExpr_stmtContext()
}

type Expr_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_stmtContext() *Expr_stmtContext {
	var p = new(Expr_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_expr_stmt
	return p
}

func (*Expr_stmtContext) IsExpr_stmtContext() {}

func NewExpr_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_stmtContext {
	var p = new(Expr_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_expr_stmt

	return p
}

func (s *Expr_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_stmtContext) AllTestlist_star_expr() []ITestlist_star_exprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITestlist_star_exprContext)(nil)).Elem())
	var tst = make([]ITestlist_star_exprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITestlist_star_exprContext)
		}
	}

	return tst
}

func (s *Expr_stmtContext) Testlist_star_expr(i int) ITestlist_star_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestlist_star_exprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITestlist_star_exprContext)
}

func (s *Expr_stmtContext) Augassign() IAugassignContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAugassignContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAugassignContext)
}

func (s *Expr_stmtContext) AllYield_expr() []IYield_exprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IYield_exprContext)(nil)).Elem())
	var tst = make([]IYield_exprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IYield_exprContext)
		}
	}

	return tst
}

func (s *Expr_stmtContext) Yield_expr(i int) IYield_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IYield_exprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IYield_exprContext)
}

func (s *Expr_stmtContext) Testlist() ITestlistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestlistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestlistContext)
}

func (s *Expr_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterExpr_stmt(s)
	}
}

func (s *Expr_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitExpr_stmt(s)
	}
}

func (s *Expr_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitExpr_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Expr_stmt() (localctx IExpr_stmtContext) {
	localctx = NewExpr_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, Python3ParserRULE_expr_stmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(398)
		p.Testlist_star_expr()
	}
	p.SetState(414)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Python3ParserADD_ASSIGN, Python3ParserSUB_ASSIGN, Python3ParserMULT_ASSIGN, Python3ParserAT_ASSIGN, Python3ParserDIV_ASSIGN, Python3ParserMOD_ASSIGN, Python3ParserAND_ASSIGN, Python3ParserOR_ASSIGN, Python3ParserXOR_ASSIGN, Python3ParserLEFT_SHIFT_ASSIGN, Python3ParserRIGHT_SHIFT_ASSIGN, Python3ParserPOWER_ASSIGN, Python3ParserIDIV_ASSIGN:
		{
			p.SetState(399)
			p.Augassign()
		}
		p.SetState(402)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case Python3ParserYIELD:
			{
				p.SetState(400)
				p.Yield_expr()
			}

		case Python3ParserLAMBDA, Python3ParserNOT, Python3ParserNONE, Python3ParserTRUE, Python3ParserFALSE, Python3ParserNAME, Python3ParserSTRING_LITERAL, Python3ParserBYTES_LITERAL, Python3ParserDECIMAL_INTEGER, Python3ParserOCT_INTEGER, Python3ParserHEX_INTEGER, Python3ParserBIN_INTEGER, Python3ParserFLOAT_NUMBER, Python3ParserIMAG_NUMBER, Python3ParserELLIPSIS, Python3ParserSTAR, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserOPEN_BRACE:
			{
				p.SetState(401)
				p.Testlist()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case Python3ParserNEWLINE, Python3ParserSEMI_COLON, Python3ParserASSIGN:
		p.SetState(411)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == Python3ParserASSIGN {
			{
				p.SetState(404)
				p.Match(Python3ParserASSIGN)
			}
			p.SetState(407)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case Python3ParserYIELD:
				{
					p.SetState(405)
					p.Yield_expr()
				}

			case Python3ParserLAMBDA, Python3ParserNOT, Python3ParserNONE, Python3ParserTRUE, Python3ParserFALSE, Python3ParserNAME, Python3ParserSTRING_LITERAL, Python3ParserBYTES_LITERAL, Python3ParserDECIMAL_INTEGER, Python3ParserOCT_INTEGER, Python3ParserHEX_INTEGER, Python3ParserBIN_INTEGER, Python3ParserFLOAT_NUMBER, Python3ParserIMAG_NUMBER, Python3ParserELLIPSIS, Python3ParserSTAR, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserOPEN_BRACE:
				{
					p.SetState(406)
					p.Testlist_star_expr()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(413)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITestlist_star_exprContext is an interface to support dynamic dispatch.
type ITestlist_star_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTestlist_star_exprContext differentiates from other interfaces.
	IsTestlist_star_exprContext()
}

type Testlist_star_exprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTestlist_star_exprContext() *Testlist_star_exprContext {
	var p = new(Testlist_star_exprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_testlist_star_expr
	return p
}

func (*Testlist_star_exprContext) IsTestlist_star_exprContext() {}

func NewTestlist_star_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Testlist_star_exprContext {
	var p = new(Testlist_star_exprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_testlist_star_expr

	return p
}

func (s *Testlist_star_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Testlist_star_exprContext) AllTest() []ITestContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITestContext)(nil)).Elem())
	var tst = make([]ITestContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITestContext)
		}
	}

	return tst
}

func (s *Testlist_star_exprContext) Test(i int) ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *Testlist_star_exprContext) AllStar_expr() []IStar_exprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStar_exprContext)(nil)).Elem())
	var tst = make([]IStar_exprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStar_exprContext)
		}
	}

	return tst
}

func (s *Testlist_star_exprContext) Star_expr(i int) IStar_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStar_exprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStar_exprContext)
}

func (s *Testlist_star_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Testlist_star_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Testlist_star_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterTestlist_star_expr(s)
	}
}

func (s *Testlist_star_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitTestlist_star_expr(s)
	}
}

func (s *Testlist_star_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitTestlist_star_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Testlist_star_expr() (localctx ITestlist_star_exprContext) {
	localctx = NewTestlist_star_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, Python3ParserRULE_testlist_star_expr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(418)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 47, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(416)
			p.Test()
		}

	case 2:
		{
			p.SetState(417)
			p.Star_expr()
		}

	}
	p.SetState(427)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 49, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(420)
				p.Match(Python3ParserCOMMA)
			}
			p.SetState(423)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 48, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(421)
					p.Test()
				}

			case 2:
				{
					p.SetState(422)
					p.Star_expr()
				}

			}

		}
		p.SetState(429)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 49, p.GetParserRuleContext())
	}
	p.SetState(431)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserCOMMA {
		{
			p.SetState(430)
			p.Match(Python3ParserCOMMA)
		}

	}

	return localctx
}

// IAugassignContext is an interface to support dynamic dispatch.
type IAugassignContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAugassignContext differentiates from other interfaces.
	IsAugassignContext()
}

type AugassignContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAugassignContext() *AugassignContext {
	var p = new(AugassignContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_augassign
	return p
}

func (*AugassignContext) IsAugassignContext() {}

func NewAugassignContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AugassignContext {
	var p = new(AugassignContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_augassign

	return p
}

func (s *AugassignContext) GetParser() antlr.Parser { return s.parser }
func (s *AugassignContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AugassignContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AugassignContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterAugassign(s)
	}
}

func (s *AugassignContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitAugassign(s)
	}
}

func (s *AugassignContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitAugassign(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Augassign() (localctx IAugassignContext) {
	localctx = NewAugassignContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, Python3ParserRULE_augassign)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(433)
	_la = p.GetTokenStream().LA(1)

	if !(((_la-78)&-(0x1f+1)) == 0 && ((1<<uint((_la-78)))&((1<<(Python3ParserADD_ASSIGN-78))|(1<<(Python3ParserSUB_ASSIGN-78))|(1<<(Python3ParserMULT_ASSIGN-78))|(1<<(Python3ParserAT_ASSIGN-78))|(1<<(Python3ParserDIV_ASSIGN-78))|(1<<(Python3ParserMOD_ASSIGN-78))|(1<<(Python3ParserAND_ASSIGN-78))|(1<<(Python3ParserOR_ASSIGN-78))|(1<<(Python3ParserXOR_ASSIGN-78))|(1<<(Python3ParserLEFT_SHIFT_ASSIGN-78))|(1<<(Python3ParserRIGHT_SHIFT_ASSIGN-78))|(1<<(Python3ParserPOWER_ASSIGN-78))|(1<<(Python3ParserIDIV_ASSIGN-78)))) != 0) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// IDel_stmtContext is an interface to support dynamic dispatch.
type IDel_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDel_stmtContext differentiates from other interfaces.
	IsDel_stmtContext()
}

type Del_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDel_stmtContext() *Del_stmtContext {
	var p = new(Del_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_del_stmt
	return p
}

func (*Del_stmtContext) IsDel_stmtContext() {}

func NewDel_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Del_stmtContext {
	var p = new(Del_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_del_stmt

	return p
}

func (s *Del_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Del_stmtContext) DEL() antlr.TerminalNode {
	return s.GetToken(Python3ParserDEL, 0)
}

func (s *Del_stmtContext) Exprlist() IExprlistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprlistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprlistContext)
}

func (s *Del_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Del_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Del_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterDel_stmt(s)
	}
}

func (s *Del_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitDel_stmt(s)
	}
}

func (s *Del_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitDel_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Del_stmt() (localctx IDel_stmtContext) {
	localctx = NewDel_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, Python3ParserRULE_del_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(435)
		p.Match(Python3ParserDEL)
	}
	{
		p.SetState(436)
		p.Exprlist()
	}

	return localctx
}

// IPass_stmtContext is an interface to support dynamic dispatch.
type IPass_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPass_stmtContext differentiates from other interfaces.
	IsPass_stmtContext()
}

type Pass_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPass_stmtContext() *Pass_stmtContext {
	var p = new(Pass_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_pass_stmt
	return p
}

func (*Pass_stmtContext) IsPass_stmtContext() {}

func NewPass_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pass_stmtContext {
	var p = new(Pass_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_pass_stmt

	return p
}

func (s *Pass_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Pass_stmtContext) PASS() antlr.TerminalNode {
	return s.GetToken(Python3ParserPASS, 0)
}

func (s *Pass_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pass_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pass_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterPass_stmt(s)
	}
}

func (s *Pass_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitPass_stmt(s)
	}
}

func (s *Pass_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitPass_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Pass_stmt() (localctx IPass_stmtContext) {
	localctx = NewPass_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, Python3ParserRULE_pass_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(438)
		p.Match(Python3ParserPASS)
	}

	return localctx
}

// IFlow_stmtContext is an interface to support dynamic dispatch.
type IFlow_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFlow_stmtContext differentiates from other interfaces.
	IsFlow_stmtContext()
}

type Flow_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFlow_stmtContext() *Flow_stmtContext {
	var p = new(Flow_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_flow_stmt
	return p
}

func (*Flow_stmtContext) IsFlow_stmtContext() {}

func NewFlow_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Flow_stmtContext {
	var p = new(Flow_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_flow_stmt

	return p
}

func (s *Flow_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Flow_stmtContext) Break_stmt() IBreak_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBreak_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBreak_stmtContext)
}

func (s *Flow_stmtContext) Continue_stmt() IContinue_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IContinue_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IContinue_stmtContext)
}

func (s *Flow_stmtContext) Return_stmt() IReturn_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReturn_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReturn_stmtContext)
}

func (s *Flow_stmtContext) Raise_stmt() IRaise_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRaise_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRaise_stmtContext)
}

func (s *Flow_stmtContext) Yield_stmt() IYield_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IYield_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IYield_stmtContext)
}

func (s *Flow_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Flow_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Flow_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterFlow_stmt(s)
	}
}

func (s *Flow_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitFlow_stmt(s)
	}
}

func (s *Flow_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitFlow_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Flow_stmt() (localctx IFlow_stmtContext) {
	localctx = NewFlow_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, Python3ParserRULE_flow_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(445)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Python3ParserBREAK:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(440)
			p.Break_stmt()
		}

	case Python3ParserCONTINUE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(441)
			p.Continue_stmt()
		}

	case Python3ParserRETURN:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(442)
			p.Return_stmt()
		}

	case Python3ParserRAISE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(443)
			p.Raise_stmt()
		}

	case Python3ParserYIELD:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(444)
			p.Yield_stmt()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IBreak_stmtContext is an interface to support dynamic dispatch.
type IBreak_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBreak_stmtContext differentiates from other interfaces.
	IsBreak_stmtContext()
}

type Break_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBreak_stmtContext() *Break_stmtContext {
	var p = new(Break_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_break_stmt
	return p
}

func (*Break_stmtContext) IsBreak_stmtContext() {}

func NewBreak_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Break_stmtContext {
	var p = new(Break_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_break_stmt

	return p
}

func (s *Break_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Break_stmtContext) BREAK() antlr.TerminalNode {
	return s.GetToken(Python3ParserBREAK, 0)
}

func (s *Break_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Break_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Break_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterBreak_stmt(s)
	}
}

func (s *Break_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitBreak_stmt(s)
	}
}

func (s *Break_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitBreak_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Break_stmt() (localctx IBreak_stmtContext) {
	localctx = NewBreak_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, Python3ParserRULE_break_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(447)
		p.Match(Python3ParserBREAK)
	}

	return localctx
}

// IContinue_stmtContext is an interface to support dynamic dispatch.
type IContinue_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsContinue_stmtContext differentiates from other interfaces.
	IsContinue_stmtContext()
}

type Continue_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContinue_stmtContext() *Continue_stmtContext {
	var p = new(Continue_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_continue_stmt
	return p
}

func (*Continue_stmtContext) IsContinue_stmtContext() {}

func NewContinue_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Continue_stmtContext {
	var p = new(Continue_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_continue_stmt

	return p
}

func (s *Continue_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Continue_stmtContext) CONTINUE() antlr.TerminalNode {
	return s.GetToken(Python3ParserCONTINUE, 0)
}

func (s *Continue_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Continue_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Continue_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterContinue_stmt(s)
	}
}

func (s *Continue_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitContinue_stmt(s)
	}
}

func (s *Continue_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitContinue_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Continue_stmt() (localctx IContinue_stmtContext) {
	localctx = NewContinue_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, Python3ParserRULE_continue_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(449)
		p.Match(Python3ParserCONTINUE)
	}

	return localctx
}

// IReturn_stmtContext is an interface to support dynamic dispatch.
type IReturn_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReturn_stmtContext differentiates from other interfaces.
	IsReturn_stmtContext()
}

type Return_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturn_stmtContext() *Return_stmtContext {
	var p = new(Return_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_return_stmt
	return p
}

func (*Return_stmtContext) IsReturn_stmtContext() {}

func NewReturn_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Return_stmtContext {
	var p = new(Return_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_return_stmt

	return p
}

func (s *Return_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Return_stmtContext) RETURN() antlr.TerminalNode {
	return s.GetToken(Python3ParserRETURN, 0)
}

func (s *Return_stmtContext) Testlist() ITestlistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestlistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestlistContext)
}

func (s *Return_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Return_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Return_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterReturn_stmt(s)
	}
}

func (s *Return_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitReturn_stmt(s)
	}
}

func (s *Return_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitReturn_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Return_stmt() (localctx IReturn_stmtContext) {
	localctx = NewReturn_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, Python3ParserRULE_return_stmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(451)
		p.Match(Python3ParserRETURN)
	}
	p.SetState(453)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-20)&-(0x1f+1)) == 0 && ((1<<uint((_la-20)))&((1<<(Python3ParserLAMBDA-20))|(1<<(Python3ParserNOT-20))|(1<<(Python3ParserNONE-20))|(1<<(Python3ParserTRUE-20))|(1<<(Python3ParserFALSE-20))|(1<<(Python3ParserNAME-20))|(1<<(Python3ParserSTRING_LITERAL-20))|(1<<(Python3ParserBYTES_LITERAL-20))|(1<<(Python3ParserDECIMAL_INTEGER-20))|(1<<(Python3ParserOCT_INTEGER-20))|(1<<(Python3ParserHEX_INTEGER-20))|(1<<(Python3ParserBIN_INTEGER-20))|(1<<(Python3ParserFLOAT_NUMBER-20))|(1<<(Python3ParserIMAG_NUMBER-20))|(1<<(Python3ParserELLIPSIS-20))|(1<<(Python3ParserSTAR-20))|(1<<(Python3ParserOPEN_PAREN-20)))) != 0) || (((_la-54)&-(0x1f+1)) == 0 && ((1<<uint((_la-54)))&((1<<(Python3ParserOPEN_BRACK-54))|(1<<(Python3ParserADD-54))|(1<<(Python3ParserMINUS-54))|(1<<(Python3ParserNOT_OP-54))|(1<<(Python3ParserOPEN_BRACE-54)))) != 0) {
		{
			p.SetState(452)
			p.Testlist()
		}

	}

	return localctx
}

// IYield_stmtContext is an interface to support dynamic dispatch.
type IYield_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsYield_stmtContext differentiates from other interfaces.
	IsYield_stmtContext()
}

type Yield_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyYield_stmtContext() *Yield_stmtContext {
	var p = new(Yield_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_yield_stmt
	return p
}

func (*Yield_stmtContext) IsYield_stmtContext() {}

func NewYield_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Yield_stmtContext {
	var p = new(Yield_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_yield_stmt

	return p
}

func (s *Yield_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Yield_stmtContext) Yield_expr() IYield_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IYield_exprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IYield_exprContext)
}

func (s *Yield_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Yield_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Yield_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterYield_stmt(s)
	}
}

func (s *Yield_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitYield_stmt(s)
	}
}

func (s *Yield_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitYield_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Yield_stmt() (localctx IYield_stmtContext) {
	localctx = NewYield_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, Python3ParserRULE_yield_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(455)
		p.Yield_expr()
	}

	return localctx
}

// IRaise_stmtContext is an interface to support dynamic dispatch.
type IRaise_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRaise_stmtContext differentiates from other interfaces.
	IsRaise_stmtContext()
}

type Raise_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRaise_stmtContext() *Raise_stmtContext {
	var p = new(Raise_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_raise_stmt
	return p
}

func (*Raise_stmtContext) IsRaise_stmtContext() {}

func NewRaise_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Raise_stmtContext {
	var p = new(Raise_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_raise_stmt

	return p
}

func (s *Raise_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Raise_stmtContext) RAISE() antlr.TerminalNode {
	return s.GetToken(Python3ParserRAISE, 0)
}

func (s *Raise_stmtContext) AllTest() []ITestContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITestContext)(nil)).Elem())
	var tst = make([]ITestContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITestContext)
		}
	}

	return tst
}

func (s *Raise_stmtContext) Test(i int) ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *Raise_stmtContext) FROM() antlr.TerminalNode {
	return s.GetToken(Python3ParserFROM, 0)
}

func (s *Raise_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Raise_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Raise_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterRaise_stmt(s)
	}
}

func (s *Raise_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitRaise_stmt(s)
	}
}

func (s *Raise_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitRaise_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Raise_stmt() (localctx IRaise_stmtContext) {
	localctx = NewRaise_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, Python3ParserRULE_raise_stmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(457)
		p.Match(Python3ParserRAISE)
	}
	p.SetState(463)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-20)&-(0x1f+1)) == 0 && ((1<<uint((_la-20)))&((1<<(Python3ParserLAMBDA-20))|(1<<(Python3ParserNOT-20))|(1<<(Python3ParserNONE-20))|(1<<(Python3ParserTRUE-20))|(1<<(Python3ParserFALSE-20))|(1<<(Python3ParserNAME-20))|(1<<(Python3ParserSTRING_LITERAL-20))|(1<<(Python3ParserBYTES_LITERAL-20))|(1<<(Python3ParserDECIMAL_INTEGER-20))|(1<<(Python3ParserOCT_INTEGER-20))|(1<<(Python3ParserHEX_INTEGER-20))|(1<<(Python3ParserBIN_INTEGER-20))|(1<<(Python3ParserFLOAT_NUMBER-20))|(1<<(Python3ParserIMAG_NUMBER-20))|(1<<(Python3ParserELLIPSIS-20))|(1<<(Python3ParserSTAR-20))|(1<<(Python3ParserOPEN_PAREN-20)))) != 0) || (((_la-54)&-(0x1f+1)) == 0 && ((1<<uint((_la-54)))&((1<<(Python3ParserOPEN_BRACK-54))|(1<<(Python3ParserADD-54))|(1<<(Python3ParserMINUS-54))|(1<<(Python3ParserNOT_OP-54))|(1<<(Python3ParserOPEN_BRACE-54)))) != 0) {
		{
			p.SetState(458)
			p.Test()
		}
		p.SetState(461)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserFROM {
			{
				p.SetState(459)
				p.Match(Python3ParserFROM)
			}
			{
				p.SetState(460)
				p.Test()
			}

		}

	}

	return localctx
}

// IImport_stmtContext is an interface to support dynamic dispatch.
type IImport_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImport_stmtContext differentiates from other interfaces.
	IsImport_stmtContext()
}

type Import_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImport_stmtContext() *Import_stmtContext {
	var p = new(Import_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_import_stmt
	return p
}

func (*Import_stmtContext) IsImport_stmtContext() {}

func NewImport_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Import_stmtContext {
	var p = new(Import_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_import_stmt

	return p
}

func (s *Import_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Import_stmtContext) Import_name() IImport_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImport_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImport_nameContext)
}

func (s *Import_stmtContext) Import_from() IImport_fromContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImport_fromContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImport_fromContext)
}

func (s *Import_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Import_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Import_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterImport_stmt(s)
	}
}

func (s *Import_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitImport_stmt(s)
	}
}

func (s *Import_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitImport_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Import_stmt() (localctx IImport_stmtContext) {
	localctx = NewImport_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, Python3ParserRULE_import_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(467)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Python3ParserIMPORT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(465)
			p.Import_name()
		}

	case Python3ParserFROM:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(466)
			p.Import_from()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IImport_nameContext is an interface to support dynamic dispatch.
type IImport_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImport_nameContext differentiates from other interfaces.
	IsImport_nameContext()
}

type Import_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImport_nameContext() *Import_nameContext {
	var p = new(Import_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_import_name
	return p
}

func (*Import_nameContext) IsImport_nameContext() {}

func NewImport_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Import_nameContext {
	var p = new(Import_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_import_name

	return p
}

func (s *Import_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Import_nameContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(Python3ParserIMPORT, 0)
}

func (s *Import_nameContext) Dotted_as_names() IDotted_as_namesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDotted_as_namesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDotted_as_namesContext)
}

func (s *Import_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Import_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Import_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterImport_name(s)
	}
}

func (s *Import_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitImport_name(s)
	}
}

func (s *Import_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitImport_name(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Import_name() (localctx IImport_nameContext) {
	localctx = NewImport_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, Python3ParserRULE_import_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(469)
		p.Match(Python3ParserIMPORT)
	}
	{
		p.SetState(470)
		p.Dotted_as_names()
	}

	return localctx
}

// IImport_fromContext is an interface to support dynamic dispatch.
type IImport_fromContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImport_fromContext differentiates from other interfaces.
	IsImport_fromContext()
}

type Import_fromContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImport_fromContext() *Import_fromContext {
	var p = new(Import_fromContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_import_from
	return p
}

func (*Import_fromContext) IsImport_fromContext() {}

func NewImport_fromContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Import_fromContext {
	var p = new(Import_fromContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_import_from

	return p
}

func (s *Import_fromContext) GetParser() antlr.Parser { return s.parser }

func (s *Import_fromContext) FROM() antlr.TerminalNode {
	return s.GetToken(Python3ParserFROM, 0)
}

func (s *Import_fromContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(Python3ParserIMPORT, 0)
}

func (s *Import_fromContext) Dotted_name() IDotted_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDotted_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDotted_nameContext)
}

func (s *Import_fromContext) Import_as_names() IImport_as_namesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImport_as_namesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImport_as_namesContext)
}

func (s *Import_fromContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Import_fromContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Import_fromContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterImport_from(s)
	}
}

func (s *Import_fromContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitImport_from(s)
	}
}

func (s *Import_fromContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitImport_from(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Import_from() (localctx IImport_fromContext) {
	localctx = NewImport_fromContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, Python3ParserRULE_import_from)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(472)
		p.Match(Python3ParserFROM)
	}
	p.SetState(485)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 58, p.GetParserRuleContext()) {
	case 1:
		p.SetState(476)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == Python3ParserDOT || _la == Python3ParserELLIPSIS {
			p.SetState(473)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Python3ParserDOT || _la == Python3ParserELLIPSIS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}

			p.SetState(478)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(479)
			p.Dotted_name()
		}

	case 2:
		p.SetState(481)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == Python3ParserDOT || _la == Python3ParserELLIPSIS {
			p.SetState(480)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Python3ParserDOT || _la == Python3ParserELLIPSIS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}

			p.SetState(483)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(487)
		p.Match(Python3ParserIMPORT)
	}
	p.SetState(494)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Python3ParserSTAR:
		{
			p.SetState(488)
			p.Match(Python3ParserSTAR)
		}

	case Python3ParserOPEN_PAREN:
		{
			p.SetState(489)
			p.Match(Python3ParserOPEN_PAREN)
		}
		{
			p.SetState(490)
			p.Import_as_names()
		}
		{
			p.SetState(491)
			p.Match(Python3ParserCLOSE_PAREN)
		}

	case Python3ParserNAME:
		{
			p.SetState(493)
			p.Import_as_names()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IImport_as_nameContext is an interface to support dynamic dispatch.
type IImport_as_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImport_as_nameContext differentiates from other interfaces.
	IsImport_as_nameContext()
}

type Import_as_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImport_as_nameContext() *Import_as_nameContext {
	var p = new(Import_as_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_import_as_name
	return p
}

func (*Import_as_nameContext) IsImport_as_nameContext() {}

func NewImport_as_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Import_as_nameContext {
	var p = new(Import_as_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_import_as_name

	return p
}

func (s *Import_as_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Import_as_nameContext) AllNAME() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserNAME)
}

func (s *Import_as_nameContext) NAME(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserNAME, i)
}

func (s *Import_as_nameContext) AS() antlr.TerminalNode {
	return s.GetToken(Python3ParserAS, 0)
}

func (s *Import_as_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Import_as_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Import_as_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterImport_as_name(s)
	}
}

func (s *Import_as_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitImport_as_name(s)
	}
}

func (s *Import_as_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitImport_as_name(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Import_as_name() (localctx IImport_as_nameContext) {
	localctx = NewImport_as_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, Python3ParserRULE_import_as_name)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(496)
		p.Match(Python3ParserNAME)
	}
	p.SetState(499)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserAS {
		{
			p.SetState(497)
			p.Match(Python3ParserAS)
		}
		{
			p.SetState(498)
			p.Match(Python3ParserNAME)
		}

	}

	return localctx
}

// IDotted_as_nameContext is an interface to support dynamic dispatch.
type IDotted_as_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDotted_as_nameContext differentiates from other interfaces.
	IsDotted_as_nameContext()
}

type Dotted_as_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDotted_as_nameContext() *Dotted_as_nameContext {
	var p = new(Dotted_as_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_dotted_as_name
	return p
}

func (*Dotted_as_nameContext) IsDotted_as_nameContext() {}

func NewDotted_as_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dotted_as_nameContext {
	var p = new(Dotted_as_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_dotted_as_name

	return p
}

func (s *Dotted_as_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Dotted_as_nameContext) Dotted_name() IDotted_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDotted_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDotted_nameContext)
}

func (s *Dotted_as_nameContext) AS() antlr.TerminalNode {
	return s.GetToken(Python3ParserAS, 0)
}

func (s *Dotted_as_nameContext) NAME() antlr.TerminalNode {
	return s.GetToken(Python3ParserNAME, 0)
}

func (s *Dotted_as_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dotted_as_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dotted_as_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterDotted_as_name(s)
	}
}

func (s *Dotted_as_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitDotted_as_name(s)
	}
}

func (s *Dotted_as_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitDotted_as_name(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Dotted_as_name() (localctx IDotted_as_nameContext) {
	localctx = NewDotted_as_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, Python3ParserRULE_dotted_as_name)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(501)
		p.Dotted_name()
	}
	p.SetState(504)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserAS {
		{
			p.SetState(502)
			p.Match(Python3ParserAS)
		}
		{
			p.SetState(503)
			p.Match(Python3ParserNAME)
		}

	}

	return localctx
}

// IImport_as_namesContext is an interface to support dynamic dispatch.
type IImport_as_namesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImport_as_namesContext differentiates from other interfaces.
	IsImport_as_namesContext()
}

type Import_as_namesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImport_as_namesContext() *Import_as_namesContext {
	var p = new(Import_as_namesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_import_as_names
	return p
}

func (*Import_as_namesContext) IsImport_as_namesContext() {}

func NewImport_as_namesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Import_as_namesContext {
	var p = new(Import_as_namesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_import_as_names

	return p
}

func (s *Import_as_namesContext) GetParser() antlr.Parser { return s.parser }

func (s *Import_as_namesContext) AllImport_as_name() []IImport_as_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IImport_as_nameContext)(nil)).Elem())
	var tst = make([]IImport_as_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IImport_as_nameContext)
		}
	}

	return tst
}

func (s *Import_as_namesContext) Import_as_name(i int) IImport_as_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImport_as_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IImport_as_nameContext)
}

func (s *Import_as_namesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Import_as_namesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Import_as_namesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterImport_as_names(s)
	}
}

func (s *Import_as_namesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitImport_as_names(s)
	}
}

func (s *Import_as_namesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitImport_as_names(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Import_as_names() (localctx IImport_as_namesContext) {
	localctx = NewImport_as_namesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, Python3ParserRULE_import_as_names)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(506)
		p.Import_as_name()
	}
	p.SetState(511)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 62, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(507)
				p.Match(Python3ParserCOMMA)
			}
			{
				p.SetState(508)
				p.Import_as_name()
			}

		}
		p.SetState(513)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 62, p.GetParserRuleContext())
	}
	p.SetState(515)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserCOMMA {
		{
			p.SetState(514)
			p.Match(Python3ParserCOMMA)
		}

	}

	return localctx
}

// IDotted_as_namesContext is an interface to support dynamic dispatch.
type IDotted_as_namesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDotted_as_namesContext differentiates from other interfaces.
	IsDotted_as_namesContext()
}

type Dotted_as_namesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDotted_as_namesContext() *Dotted_as_namesContext {
	var p = new(Dotted_as_namesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_dotted_as_names
	return p
}

func (*Dotted_as_namesContext) IsDotted_as_namesContext() {}

func NewDotted_as_namesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dotted_as_namesContext {
	var p = new(Dotted_as_namesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_dotted_as_names

	return p
}

func (s *Dotted_as_namesContext) GetParser() antlr.Parser { return s.parser }

func (s *Dotted_as_namesContext) AllDotted_as_name() []IDotted_as_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDotted_as_nameContext)(nil)).Elem())
	var tst = make([]IDotted_as_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDotted_as_nameContext)
		}
	}

	return tst
}

func (s *Dotted_as_namesContext) Dotted_as_name(i int) IDotted_as_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDotted_as_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDotted_as_nameContext)
}

func (s *Dotted_as_namesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dotted_as_namesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dotted_as_namesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterDotted_as_names(s)
	}
}

func (s *Dotted_as_namesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitDotted_as_names(s)
	}
}

func (s *Dotted_as_namesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitDotted_as_names(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Dotted_as_names() (localctx IDotted_as_namesContext) {
	localctx = NewDotted_as_namesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, Python3ParserRULE_dotted_as_names)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(517)
		p.Dotted_as_name()
	}
	p.SetState(522)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Python3ParserCOMMA {
		{
			p.SetState(518)
			p.Match(Python3ParserCOMMA)
		}
		{
			p.SetState(519)
			p.Dotted_as_name()
		}

		p.SetState(524)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IDotted_nameContext is an interface to support dynamic dispatch.
type IDotted_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDotted_nameContext differentiates from other interfaces.
	IsDotted_nameContext()
}

type Dotted_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDotted_nameContext() *Dotted_nameContext {
	var p = new(Dotted_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_dotted_name
	return p
}

func (*Dotted_nameContext) IsDotted_nameContext() {}

func NewDotted_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dotted_nameContext {
	var p = new(Dotted_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_dotted_name

	return p
}

func (s *Dotted_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Dotted_nameContext) AllNAME() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserNAME)
}

func (s *Dotted_nameContext) NAME(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserNAME, i)
}

func (s *Dotted_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dotted_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dotted_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterDotted_name(s)
	}
}

func (s *Dotted_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitDotted_name(s)
	}
}

func (s *Dotted_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitDotted_name(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Dotted_name() (localctx IDotted_nameContext) {
	localctx = NewDotted_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, Python3ParserRULE_dotted_name)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(525)
		p.Match(Python3ParserNAME)
	}
	p.SetState(530)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Python3ParserDOT {
		{
			p.SetState(526)
			p.Match(Python3ParserDOT)
		}
		{
			p.SetState(527)
			p.Match(Python3ParserNAME)
		}

		p.SetState(532)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IGlobal_stmtContext is an interface to support dynamic dispatch.
type IGlobal_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGlobal_stmtContext differentiates from other interfaces.
	IsGlobal_stmtContext()
}

type Global_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGlobal_stmtContext() *Global_stmtContext {
	var p = new(Global_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_global_stmt
	return p
}

func (*Global_stmtContext) IsGlobal_stmtContext() {}

func NewGlobal_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Global_stmtContext {
	var p = new(Global_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_global_stmt

	return p
}

func (s *Global_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Global_stmtContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(Python3ParserGLOBAL, 0)
}

func (s *Global_stmtContext) AllNAME() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserNAME)
}

func (s *Global_stmtContext) NAME(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserNAME, i)
}

func (s *Global_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Global_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Global_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterGlobal_stmt(s)
	}
}

func (s *Global_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitGlobal_stmt(s)
	}
}

func (s *Global_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitGlobal_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Global_stmt() (localctx IGlobal_stmtContext) {
	localctx = NewGlobal_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, Python3ParserRULE_global_stmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(533)
		p.Match(Python3ParserGLOBAL)
	}
	{
		p.SetState(534)
		p.Match(Python3ParserNAME)
	}
	p.SetState(539)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Python3ParserCOMMA {
		{
			p.SetState(535)
			p.Match(Python3ParserCOMMA)
		}
		{
			p.SetState(536)
			p.Match(Python3ParserNAME)
		}

		p.SetState(541)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// INonlocal_stmtContext is an interface to support dynamic dispatch.
type INonlocal_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNonlocal_stmtContext differentiates from other interfaces.
	IsNonlocal_stmtContext()
}

type Nonlocal_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNonlocal_stmtContext() *Nonlocal_stmtContext {
	var p = new(Nonlocal_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_nonlocal_stmt
	return p
}

func (*Nonlocal_stmtContext) IsNonlocal_stmtContext() {}

func NewNonlocal_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Nonlocal_stmtContext {
	var p = new(Nonlocal_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_nonlocal_stmt

	return p
}

func (s *Nonlocal_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Nonlocal_stmtContext) NONLOCAL() antlr.TerminalNode {
	return s.GetToken(Python3ParserNONLOCAL, 0)
}

func (s *Nonlocal_stmtContext) AllNAME() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserNAME)
}

func (s *Nonlocal_stmtContext) NAME(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserNAME, i)
}

func (s *Nonlocal_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Nonlocal_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Nonlocal_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterNonlocal_stmt(s)
	}
}

func (s *Nonlocal_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitNonlocal_stmt(s)
	}
}

func (s *Nonlocal_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitNonlocal_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Nonlocal_stmt() (localctx INonlocal_stmtContext) {
	localctx = NewNonlocal_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, Python3ParserRULE_nonlocal_stmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(542)
		p.Match(Python3ParserNONLOCAL)
	}
	{
		p.SetState(543)
		p.Match(Python3ParserNAME)
	}
	p.SetState(548)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Python3ParserCOMMA {
		{
			p.SetState(544)
			p.Match(Python3ParserCOMMA)
		}
		{
			p.SetState(545)
			p.Match(Python3ParserNAME)
		}

		p.SetState(550)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IAssert_stmtContext is an interface to support dynamic dispatch.
type IAssert_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssert_stmtContext differentiates from other interfaces.
	IsAssert_stmtContext()
}

type Assert_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssert_stmtContext() *Assert_stmtContext {
	var p = new(Assert_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_assert_stmt
	return p
}

func (*Assert_stmtContext) IsAssert_stmtContext() {}

func NewAssert_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Assert_stmtContext {
	var p = new(Assert_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_assert_stmt

	return p
}

func (s *Assert_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Assert_stmtContext) ASSERT() antlr.TerminalNode {
	return s.GetToken(Python3ParserASSERT, 0)
}

func (s *Assert_stmtContext) AllTest() []ITestContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITestContext)(nil)).Elem())
	var tst = make([]ITestContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITestContext)
		}
	}

	return tst
}

func (s *Assert_stmtContext) Test(i int) ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *Assert_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Assert_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Assert_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterAssert_stmt(s)
	}
}

func (s *Assert_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitAssert_stmt(s)
	}
}

func (s *Assert_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitAssert_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Assert_stmt() (localctx IAssert_stmtContext) {
	localctx = NewAssert_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, Python3ParserRULE_assert_stmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(551)
		p.Match(Python3ParserASSERT)
	}
	{
		p.SetState(552)
		p.Test()
	}
	p.SetState(555)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserCOMMA {
		{
			p.SetState(553)
			p.Match(Python3ParserCOMMA)
		}
		{
			p.SetState(554)
			p.Test()
		}

	}

	return localctx
}

// ICompound_stmtContext is an interface to support dynamic dispatch.
type ICompound_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCompound_stmtContext differentiates from other interfaces.
	IsCompound_stmtContext()
}

type Compound_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompound_stmtContext() *Compound_stmtContext {
	var p = new(Compound_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_compound_stmt
	return p
}

func (*Compound_stmtContext) IsCompound_stmtContext() {}

func NewCompound_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Compound_stmtContext {
	var p = new(Compound_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_compound_stmt

	return p
}

func (s *Compound_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Compound_stmtContext) If_stmt() IIf_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIf_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIf_stmtContext)
}

func (s *Compound_stmtContext) While_stmt() IWhile_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhile_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWhile_stmtContext)
}

func (s *Compound_stmtContext) For_stmt() IFor_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFor_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFor_stmtContext)
}

func (s *Compound_stmtContext) Try_stmt() ITry_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITry_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITry_stmtContext)
}

func (s *Compound_stmtContext) With_stmt() IWith_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWith_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWith_stmtContext)
}

func (s *Compound_stmtContext) Funcdef() IFuncdefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFuncdefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFuncdefContext)
}

func (s *Compound_stmtContext) Classdef() IClassdefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassdefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassdefContext)
}

func (s *Compound_stmtContext) Decorated() IDecoratedContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDecoratedContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDecoratedContext)
}

func (s *Compound_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Compound_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Compound_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterCompound_stmt(s)
	}
}

func (s *Compound_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitCompound_stmt(s)
	}
}

func (s *Compound_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitCompound_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Compound_stmt() (localctx ICompound_stmtContext) {
	localctx = NewCompound_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, Python3ParserRULE_compound_stmt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(565)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Python3ParserIF:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(557)
			p.If_stmt()
		}

	case Python3ParserWHILE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(558)
			p.While_stmt()
		}

	case Python3ParserFOR:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(559)
			p.For_stmt()
		}

	case Python3ParserTRY:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(560)
			p.Try_stmt()
		}

	case Python3ParserWITH:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(561)
			p.With_stmt()
		}

	case Python3ParserDEF:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(562)
			p.Funcdef()
		}

	case Python3ParserCLASS:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(563)
			p.Classdef()
		}

	case Python3ParserAT:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(564)
			p.Decorated()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IIf_stmtContext is an interface to support dynamic dispatch.
type IIf_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIf_stmtContext differentiates from other interfaces.
	IsIf_stmtContext()
}

type If_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIf_stmtContext() *If_stmtContext {
	var p = new(If_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_if_stmt
	return p
}

func (*If_stmtContext) IsIf_stmtContext() {}

func NewIf_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *If_stmtContext {
	var p = new(If_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_if_stmt

	return p
}

func (s *If_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *If_stmtContext) IF() antlr.TerminalNode {
	return s.GetToken(Python3ParserIF, 0)
}

func (s *If_stmtContext) AllTest() []ITestContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITestContext)(nil)).Elem())
	var tst = make([]ITestContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITestContext)
		}
	}

	return tst
}

func (s *If_stmtContext) Test(i int) ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *If_stmtContext) AllSuite() []ISuiteContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISuiteContext)(nil)).Elem())
	var tst = make([]ISuiteContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISuiteContext)
		}
	}

	return tst
}

func (s *If_stmtContext) Suite(i int) ISuiteContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISuiteContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISuiteContext)
}

func (s *If_stmtContext) AllELIF() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserELIF)
}

func (s *If_stmtContext) ELIF(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserELIF, i)
}

func (s *If_stmtContext) ELSE() antlr.TerminalNode {
	return s.GetToken(Python3ParserELSE, 0)
}

func (s *If_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *If_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *If_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterIf_stmt(s)
	}
}

func (s *If_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitIf_stmt(s)
	}
}

func (s *If_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitIf_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) If_stmt() (localctx IIf_stmtContext) {
	localctx = NewIf_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, Python3ParserRULE_if_stmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(567)
		p.Match(Python3ParserIF)
	}
	{
		p.SetState(568)
		p.Test()
	}
	{
		p.SetState(569)
		p.Match(Python3ParserCOLON)
	}
	{
		p.SetState(570)
		p.Suite()
	}
	p.SetState(578)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Python3ParserELIF {
		{
			p.SetState(571)
			p.Match(Python3ParserELIF)
		}
		{
			p.SetState(572)
			p.Test()
		}
		{
			p.SetState(573)
			p.Match(Python3ParserCOLON)
		}
		{
			p.SetState(574)
			p.Suite()
		}

		p.SetState(580)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(584)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserELSE {
		{
			p.SetState(581)
			p.Match(Python3ParserELSE)
		}
		{
			p.SetState(582)
			p.Match(Python3ParserCOLON)
		}
		{
			p.SetState(583)
			p.Suite()
		}

	}

	return localctx
}

// IWhile_stmtContext is an interface to support dynamic dispatch.
type IWhile_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWhile_stmtContext differentiates from other interfaces.
	IsWhile_stmtContext()
}

type While_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhile_stmtContext() *While_stmtContext {
	var p = new(While_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_while_stmt
	return p
}

func (*While_stmtContext) IsWhile_stmtContext() {}

func NewWhile_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *While_stmtContext {
	var p = new(While_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_while_stmt

	return p
}

func (s *While_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *While_stmtContext) WHILE() antlr.TerminalNode {
	return s.GetToken(Python3ParserWHILE, 0)
}

func (s *While_stmtContext) Test() ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *While_stmtContext) AllSuite() []ISuiteContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISuiteContext)(nil)).Elem())
	var tst = make([]ISuiteContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISuiteContext)
		}
	}

	return tst
}

func (s *While_stmtContext) Suite(i int) ISuiteContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISuiteContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISuiteContext)
}

func (s *While_stmtContext) ELSE() antlr.TerminalNode {
	return s.GetToken(Python3ParserELSE, 0)
}

func (s *While_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *While_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *While_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterWhile_stmt(s)
	}
}

func (s *While_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitWhile_stmt(s)
	}
}

func (s *While_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitWhile_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) While_stmt() (localctx IWhile_stmtContext) {
	localctx = NewWhile_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, Python3ParserRULE_while_stmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(586)
		p.Match(Python3ParserWHILE)
	}
	{
		p.SetState(587)
		p.Test()
	}
	{
		p.SetState(588)
		p.Match(Python3ParserCOLON)
	}
	{
		p.SetState(589)
		p.Suite()
	}
	p.SetState(593)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserELSE {
		{
			p.SetState(590)
			p.Match(Python3ParserELSE)
		}
		{
			p.SetState(591)
			p.Match(Python3ParserCOLON)
		}
		{
			p.SetState(592)
			p.Suite()
		}

	}

	return localctx
}

// IFor_stmtContext is an interface to support dynamic dispatch.
type IFor_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFor_stmtContext differentiates from other interfaces.
	IsFor_stmtContext()
}

type For_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFor_stmtContext() *For_stmtContext {
	var p = new(For_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_for_stmt
	return p
}

func (*For_stmtContext) IsFor_stmtContext() {}

func NewFor_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *For_stmtContext {
	var p = new(For_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_for_stmt

	return p
}

func (s *For_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *For_stmtContext) FOR() antlr.TerminalNode {
	return s.GetToken(Python3ParserFOR, 0)
}

func (s *For_stmtContext) Exprlist() IExprlistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprlistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprlistContext)
}

func (s *For_stmtContext) IN() antlr.TerminalNode {
	return s.GetToken(Python3ParserIN, 0)
}

func (s *For_stmtContext) Testlist() ITestlistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestlistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestlistContext)
}

func (s *For_stmtContext) AllSuite() []ISuiteContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISuiteContext)(nil)).Elem())
	var tst = make([]ISuiteContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISuiteContext)
		}
	}

	return tst
}

func (s *For_stmtContext) Suite(i int) ISuiteContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISuiteContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISuiteContext)
}

func (s *For_stmtContext) ELSE() antlr.TerminalNode {
	return s.GetToken(Python3ParserELSE, 0)
}

func (s *For_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *For_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *For_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterFor_stmt(s)
	}
}

func (s *For_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitFor_stmt(s)
	}
}

func (s *For_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitFor_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) For_stmt() (localctx IFor_stmtContext) {
	localctx = NewFor_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, Python3ParserRULE_for_stmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(595)
		p.Match(Python3ParserFOR)
	}
	{
		p.SetState(596)
		p.Exprlist()
	}
	{
		p.SetState(597)
		p.Match(Python3ParserIN)
	}
	{
		p.SetState(598)
		p.Testlist()
	}
	{
		p.SetState(599)
		p.Match(Python3ParserCOLON)
	}
	{
		p.SetState(600)
		p.Suite()
	}
	p.SetState(604)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserELSE {
		{
			p.SetState(601)
			p.Match(Python3ParserELSE)
		}
		{
			p.SetState(602)
			p.Match(Python3ParserCOLON)
		}
		{
			p.SetState(603)
			p.Suite()
		}

	}

	return localctx
}

// ITry_stmtContext is an interface to support dynamic dispatch.
type ITry_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTry_stmtContext differentiates from other interfaces.
	IsTry_stmtContext()
}

type Try_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTry_stmtContext() *Try_stmtContext {
	var p = new(Try_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_try_stmt
	return p
}

func (*Try_stmtContext) IsTry_stmtContext() {}

func NewTry_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Try_stmtContext {
	var p = new(Try_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_try_stmt

	return p
}

func (s *Try_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Try_stmtContext) TRY() antlr.TerminalNode {
	return s.GetToken(Python3ParserTRY, 0)
}

func (s *Try_stmtContext) AllSuite() []ISuiteContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISuiteContext)(nil)).Elem())
	var tst = make([]ISuiteContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISuiteContext)
		}
	}

	return tst
}

func (s *Try_stmtContext) Suite(i int) ISuiteContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISuiteContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISuiteContext)
}

func (s *Try_stmtContext) FINALLY() antlr.TerminalNode {
	return s.GetToken(Python3ParserFINALLY, 0)
}

func (s *Try_stmtContext) AllExcept_clause() []IExcept_clauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExcept_clauseContext)(nil)).Elem())
	var tst = make([]IExcept_clauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExcept_clauseContext)
		}
	}

	return tst
}

func (s *Try_stmtContext) Except_clause(i int) IExcept_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExcept_clauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExcept_clauseContext)
}

func (s *Try_stmtContext) ELSE() antlr.TerminalNode {
	return s.GetToken(Python3ParserELSE, 0)
}

func (s *Try_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Try_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Try_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterTry_stmt(s)
	}
}

func (s *Try_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitTry_stmt(s)
	}
}

func (s *Try_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitTry_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Try_stmt() (localctx ITry_stmtContext) {
	localctx = NewTry_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, Python3ParserRULE_try_stmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(606)
		p.Match(Python3ParserTRY)
	}
	{
		p.SetState(607)
		p.Match(Python3ParserCOLON)
	}
	{
		p.SetState(608)
		p.Suite()
	}
	p.SetState(630)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Python3ParserEXCEPT:
		p.SetState(613)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == Python3ParserEXCEPT {
			{
				p.SetState(609)
				p.Except_clause()
			}
			{
				p.SetState(610)
				p.Match(Python3ParserCOLON)
			}
			{
				p.SetState(611)
				p.Suite()
			}

			p.SetState(615)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(620)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserELSE {
			{
				p.SetState(617)
				p.Match(Python3ParserELSE)
			}
			{
				p.SetState(618)
				p.Match(Python3ParserCOLON)
			}
			{
				p.SetState(619)
				p.Suite()
			}

		}
		p.SetState(625)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserFINALLY {
			{
				p.SetState(622)
				p.Match(Python3ParserFINALLY)
			}
			{
				p.SetState(623)
				p.Match(Python3ParserCOLON)
			}
			{
				p.SetState(624)
				p.Suite()
			}

		}

	case Python3ParserFINALLY:
		{
			p.SetState(627)
			p.Match(Python3ParserFINALLY)
		}
		{
			p.SetState(628)
			p.Match(Python3ParserCOLON)
		}
		{
			p.SetState(629)
			p.Suite()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IWith_stmtContext is an interface to support dynamic dispatch.
type IWith_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWith_stmtContext differentiates from other interfaces.
	IsWith_stmtContext()
}

type With_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWith_stmtContext() *With_stmtContext {
	var p = new(With_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_with_stmt
	return p
}

func (*With_stmtContext) IsWith_stmtContext() {}

func NewWith_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *With_stmtContext {
	var p = new(With_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_with_stmt

	return p
}

func (s *With_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *With_stmtContext) WITH() antlr.TerminalNode {
	return s.GetToken(Python3ParserWITH, 0)
}

func (s *With_stmtContext) AllWith_item() []IWith_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWith_itemContext)(nil)).Elem())
	var tst = make([]IWith_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWith_itemContext)
		}
	}

	return tst
}

func (s *With_stmtContext) With_item(i int) IWith_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWith_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWith_itemContext)
}

func (s *With_stmtContext) Suite() ISuiteContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISuiteContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISuiteContext)
}

func (s *With_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *With_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *With_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterWith_stmt(s)
	}
}

func (s *With_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitWith_stmt(s)
	}
}

func (s *With_stmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitWith_stmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) With_stmt() (localctx IWith_stmtContext) {
	localctx = NewWith_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, Python3ParserRULE_with_stmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(632)
		p.Match(Python3ParserWITH)
	}
	{
		p.SetState(633)
		p.With_item()
	}
	p.SetState(638)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Python3ParserCOMMA {
		{
			p.SetState(634)
			p.Match(Python3ParserCOMMA)
		}
		{
			p.SetState(635)
			p.With_item()
		}

		p.SetState(640)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(641)
		p.Match(Python3ParserCOLON)
	}
	{
		p.SetState(642)
		p.Suite()
	}

	return localctx
}

// IWith_itemContext is an interface to support dynamic dispatch.
type IWith_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWith_itemContext differentiates from other interfaces.
	IsWith_itemContext()
}

type With_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWith_itemContext() *With_itemContext {
	var p = new(With_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_with_item
	return p
}

func (*With_itemContext) IsWith_itemContext() {}

func NewWith_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *With_itemContext {
	var p = new(With_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_with_item

	return p
}

func (s *With_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *With_itemContext) Test() ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *With_itemContext) AS() antlr.TerminalNode {
	return s.GetToken(Python3ParserAS, 0)
}

func (s *With_itemContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *With_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *With_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *With_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterWith_item(s)
	}
}

func (s *With_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitWith_item(s)
	}
}

func (s *With_itemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitWith_item(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) With_item() (localctx IWith_itemContext) {
	localctx = NewWith_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, Python3ParserRULE_with_item)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(644)
		p.Test()
	}
	p.SetState(647)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserAS {
		{
			p.SetState(645)
			p.Match(Python3ParserAS)
		}
		{
			p.SetState(646)
			p.Expr()
		}

	}

	return localctx
}

// IExcept_clauseContext is an interface to support dynamic dispatch.
type IExcept_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExcept_clauseContext differentiates from other interfaces.
	IsExcept_clauseContext()
}

type Except_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExcept_clauseContext() *Except_clauseContext {
	var p = new(Except_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_except_clause
	return p
}

func (*Except_clauseContext) IsExcept_clauseContext() {}

func NewExcept_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Except_clauseContext {
	var p = new(Except_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_except_clause

	return p
}

func (s *Except_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Except_clauseContext) EXCEPT() antlr.TerminalNode {
	return s.GetToken(Python3ParserEXCEPT, 0)
}

func (s *Except_clauseContext) Test() ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *Except_clauseContext) AS() antlr.TerminalNode {
	return s.GetToken(Python3ParserAS, 0)
}

func (s *Except_clauseContext) NAME() antlr.TerminalNode {
	return s.GetToken(Python3ParserNAME, 0)
}

func (s *Except_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Except_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Except_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterExcept_clause(s)
	}
}

func (s *Except_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitExcept_clause(s)
	}
}

func (s *Except_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitExcept_clause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Except_clause() (localctx IExcept_clauseContext) {
	localctx = NewExcept_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, Python3ParserRULE_except_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(649)
		p.Match(Python3ParserEXCEPT)
	}
	p.SetState(655)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-20)&-(0x1f+1)) == 0 && ((1<<uint((_la-20)))&((1<<(Python3ParserLAMBDA-20))|(1<<(Python3ParserNOT-20))|(1<<(Python3ParserNONE-20))|(1<<(Python3ParserTRUE-20))|(1<<(Python3ParserFALSE-20))|(1<<(Python3ParserNAME-20))|(1<<(Python3ParserSTRING_LITERAL-20))|(1<<(Python3ParserBYTES_LITERAL-20))|(1<<(Python3ParserDECIMAL_INTEGER-20))|(1<<(Python3ParserOCT_INTEGER-20))|(1<<(Python3ParserHEX_INTEGER-20))|(1<<(Python3ParserBIN_INTEGER-20))|(1<<(Python3ParserFLOAT_NUMBER-20))|(1<<(Python3ParserIMAG_NUMBER-20))|(1<<(Python3ParserELLIPSIS-20))|(1<<(Python3ParserSTAR-20))|(1<<(Python3ParserOPEN_PAREN-20)))) != 0) || (((_la-54)&-(0x1f+1)) == 0 && ((1<<uint((_la-54)))&((1<<(Python3ParserOPEN_BRACK-54))|(1<<(Python3ParserADD-54))|(1<<(Python3ParserMINUS-54))|(1<<(Python3ParserNOT_OP-54))|(1<<(Python3ParserOPEN_BRACE-54)))) != 0) {
		{
			p.SetState(650)
			p.Test()
		}
		p.SetState(653)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserAS {
			{
				p.SetState(651)
				p.Match(Python3ParserAS)
			}
			{
				p.SetState(652)
				p.Match(Python3ParserNAME)
			}

		}

	}

	return localctx
}

// ISuiteContext is an interface to support dynamic dispatch.
type ISuiteContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSuiteContext differentiates from other interfaces.
	IsSuiteContext()
}

type SuiteContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySuiteContext() *SuiteContext {
	var p = new(SuiteContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_suite
	return p
}

func (*SuiteContext) IsSuiteContext() {}

func NewSuiteContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SuiteContext {
	var p = new(SuiteContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_suite

	return p
}

func (s *SuiteContext) GetParser() antlr.Parser { return s.parser }

func (s *SuiteContext) Simple_stmt() ISimple_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_stmtContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimple_stmtContext)
}

func (s *SuiteContext) NEWLINE() antlr.TerminalNode {
	return s.GetToken(Python3ParserNEWLINE, 0)
}

func (s *SuiteContext) INDENT() antlr.TerminalNode {
	return s.GetToken(Python3ParserINDENT, 0)
}

func (s *SuiteContext) DEDENT() antlr.TerminalNode {
	return s.GetToken(Python3ParserDEDENT, 0)
}

func (s *SuiteContext) AllStmt() []IStmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStmtContext)(nil)).Elem())
	var tst = make([]IStmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStmtContext)
		}
	}

	return tst
}

func (s *SuiteContext) Stmt(i int) IStmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStmtContext)
}

func (s *SuiteContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SuiteContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SuiteContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterSuite(s)
	}
}

func (s *SuiteContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitSuite(s)
	}
}

func (s *SuiteContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitSuite(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Suite() (localctx ISuiteContext) {
	localctx = NewSuiteContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, Python3ParserRULE_suite)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(667)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Python3ParserRETURN, Python3ParserRAISE, Python3ParserFROM, Python3ParserIMPORT, Python3ParserGLOBAL, Python3ParserNONLOCAL, Python3ParserASSERT, Python3ParserLAMBDA, Python3ParserNOT, Python3ParserNONE, Python3ParserTRUE, Python3ParserFALSE, Python3ParserYIELD, Python3ParserDEL, Python3ParserPASS, Python3ParserCONTINUE, Python3ParserBREAK, Python3ParserNAME, Python3ParserSTRING_LITERAL, Python3ParserBYTES_LITERAL, Python3ParserDECIMAL_INTEGER, Python3ParserOCT_INTEGER, Python3ParserHEX_INTEGER, Python3ParserBIN_INTEGER, Python3ParserFLOAT_NUMBER, Python3ParserIMAG_NUMBER, Python3ParserELLIPSIS, Python3ParserSTAR, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserOPEN_BRACE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(657)
			p.Simple_stmt()
		}

	case Python3ParserNEWLINE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(658)
			p.Match(Python3ParserNEWLINE)
		}
		{
			p.SetState(659)
			p.Match(Python3ParserINDENT)
		}
		p.SetState(661)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Python3ParserDEF)|(1<<Python3ParserRETURN)|(1<<Python3ParserRAISE)|(1<<Python3ParserFROM)|(1<<Python3ParserIMPORT)|(1<<Python3ParserGLOBAL)|(1<<Python3ParserNONLOCAL)|(1<<Python3ParserASSERT)|(1<<Python3ParserIF)|(1<<Python3ParserWHILE)|(1<<Python3ParserFOR)|(1<<Python3ParserTRY)|(1<<Python3ParserWITH)|(1<<Python3ParserLAMBDA)|(1<<Python3ParserNOT)|(1<<Python3ParserNONE)|(1<<Python3ParserTRUE)|(1<<Python3ParserFALSE)|(1<<Python3ParserCLASS)|(1<<Python3ParserYIELD)|(1<<Python3ParserDEL)|(1<<Python3ParserPASS))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(Python3ParserCONTINUE-32))|(1<<(Python3ParserBREAK-32))|(1<<(Python3ParserNAME-32))|(1<<(Python3ParserSTRING_LITERAL-32))|(1<<(Python3ParserBYTES_LITERAL-32))|(1<<(Python3ParserDECIMAL_INTEGER-32))|(1<<(Python3ParserOCT_INTEGER-32))|(1<<(Python3ParserHEX_INTEGER-32))|(1<<(Python3ParserBIN_INTEGER-32))|(1<<(Python3ParserFLOAT_NUMBER-32))|(1<<(Python3ParserIMAG_NUMBER-32))|(1<<(Python3ParserELLIPSIS-32))|(1<<(Python3ParserSTAR-32))|(1<<(Python3ParserOPEN_PAREN-32))|(1<<(Python3ParserOPEN_BRACK-32))|(1<<(Python3ParserADD-32))|(1<<(Python3ParserMINUS-32)))) != 0) || (((_la-66)&-(0x1f+1)) == 0 && ((1<<uint((_la-66)))&((1<<(Python3ParserNOT_OP-66))|(1<<(Python3ParserOPEN_BRACE-66))|(1<<(Python3ParserAT-66)))) != 0) {
			{
				p.SetState(660)
				p.Stmt()
			}

			p.SetState(663)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(665)
			p.Match(Python3ParserDEDENT)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITestContext is an interface to support dynamic dispatch.
type ITestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTestContext differentiates from other interfaces.
	IsTestContext()
}

type TestContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTestContext() *TestContext {
	var p = new(TestContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_test
	return p
}

func (*TestContext) IsTestContext() {}

func NewTestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TestContext {
	var p = new(TestContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_test

	return p
}

func (s *TestContext) GetParser() antlr.Parser { return s.parser }

func (s *TestContext) AllOr_test() []IOr_testContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOr_testContext)(nil)).Elem())
	var tst = make([]IOr_testContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOr_testContext)
		}
	}

	return tst
}

func (s *TestContext) Or_test(i int) IOr_testContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOr_testContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOr_testContext)
}

func (s *TestContext) IF() antlr.TerminalNode {
	return s.GetToken(Python3ParserIF, 0)
}

func (s *TestContext) ELSE() antlr.TerminalNode {
	return s.GetToken(Python3ParserELSE, 0)
}

func (s *TestContext) Test() ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *TestContext) Lambdef() ILambdefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILambdefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILambdefContext)
}

func (s *TestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterTest(s)
	}
}

func (s *TestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitTest(s)
	}
}

func (s *TestContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitTest(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Test() (localctx ITestContext) {
	localctx = NewTestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, Python3ParserRULE_test)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(678)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Python3ParserNOT, Python3ParserNONE, Python3ParserTRUE, Python3ParserFALSE, Python3ParserNAME, Python3ParserSTRING_LITERAL, Python3ParserBYTES_LITERAL, Python3ParserDECIMAL_INTEGER, Python3ParserOCT_INTEGER, Python3ParserHEX_INTEGER, Python3ParserBIN_INTEGER, Python3ParserFLOAT_NUMBER, Python3ParserIMAG_NUMBER, Python3ParserELLIPSIS, Python3ParserSTAR, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserOPEN_BRACE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(669)
			p.Or_test()
		}
		p.SetState(675)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserIF {
			{
				p.SetState(670)
				p.Match(Python3ParserIF)
			}
			{
				p.SetState(671)
				p.Or_test()
			}
			{
				p.SetState(672)
				p.Match(Python3ParserELSE)
			}
			{
				p.SetState(673)
				p.Test()
			}

		}

	case Python3ParserLAMBDA:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(677)
			p.Lambdef()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITest_nocondContext is an interface to support dynamic dispatch.
type ITest_nocondContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTest_nocondContext differentiates from other interfaces.
	IsTest_nocondContext()
}

type Test_nocondContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTest_nocondContext() *Test_nocondContext {
	var p = new(Test_nocondContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_test_nocond
	return p
}

func (*Test_nocondContext) IsTest_nocondContext() {}

func NewTest_nocondContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Test_nocondContext {
	var p = new(Test_nocondContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_test_nocond

	return p
}

func (s *Test_nocondContext) GetParser() antlr.Parser { return s.parser }

func (s *Test_nocondContext) Or_test() IOr_testContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOr_testContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOr_testContext)
}

func (s *Test_nocondContext) Lambdef_nocond() ILambdef_nocondContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILambdef_nocondContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILambdef_nocondContext)
}

func (s *Test_nocondContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Test_nocondContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Test_nocondContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterTest_nocond(s)
	}
}

func (s *Test_nocondContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitTest_nocond(s)
	}
}

func (s *Test_nocondContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitTest_nocond(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Test_nocond() (localctx ITest_nocondContext) {
	localctx = NewTest_nocondContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, Python3ParserRULE_test_nocond)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(682)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Python3ParserNOT, Python3ParserNONE, Python3ParserTRUE, Python3ParserFALSE, Python3ParserNAME, Python3ParserSTRING_LITERAL, Python3ParserBYTES_LITERAL, Python3ParserDECIMAL_INTEGER, Python3ParserOCT_INTEGER, Python3ParserHEX_INTEGER, Python3ParserBIN_INTEGER, Python3ParserFLOAT_NUMBER, Python3ParserIMAG_NUMBER, Python3ParserELLIPSIS, Python3ParserSTAR, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserOPEN_BRACE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(680)
			p.Or_test()
		}

	case Python3ParserLAMBDA:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(681)
			p.Lambdef_nocond()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ILambdefContext is an interface to support dynamic dispatch.
type ILambdefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLambdefContext differentiates from other interfaces.
	IsLambdefContext()
}

type LambdefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdefContext() *LambdefContext {
	var p = new(LambdefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_lambdef
	return p
}

func (*LambdefContext) IsLambdefContext() {}

func NewLambdefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdefContext {
	var p = new(LambdefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_lambdef

	return p
}

func (s *LambdefContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdefContext) LAMBDA() antlr.TerminalNode {
	return s.GetToken(Python3ParserLAMBDA, 0)
}

func (s *LambdefContext) Test() ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *LambdefContext) Varargslist() IVarargslistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVarargslistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVarargslistContext)
}

func (s *LambdefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LambdefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterLambdef(s)
	}
}

func (s *LambdefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitLambdef(s)
	}
}

func (s *LambdefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitLambdef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Lambdef() (localctx ILambdefContext) {
	localctx = NewLambdefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, Python3ParserRULE_lambdef)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(684)
		p.Match(Python3ParserLAMBDA)
	}
	p.SetState(686)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la-35)&-(0x1f+1)) == 0 && ((1<<uint((_la-35)))&((1<<(Python3ParserNAME-35))|(1<<(Python3ParserSTAR-35))|(1<<(Python3ParserPOWER-35)))) != 0 {
		{
			p.SetState(685)
			p.Varargslist()
		}

	}
	{
		p.SetState(688)
		p.Match(Python3ParserCOLON)
	}
	{
		p.SetState(689)
		p.Test()
	}

	return localctx
}

// ILambdef_nocondContext is an interface to support dynamic dispatch.
type ILambdef_nocondContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLambdef_nocondContext differentiates from other interfaces.
	IsLambdef_nocondContext()
}

type Lambdef_nocondContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdef_nocondContext() *Lambdef_nocondContext {
	var p = new(Lambdef_nocondContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_lambdef_nocond
	return p
}

func (*Lambdef_nocondContext) IsLambdef_nocondContext() {}

func NewLambdef_nocondContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Lambdef_nocondContext {
	var p = new(Lambdef_nocondContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_lambdef_nocond

	return p
}

func (s *Lambdef_nocondContext) GetParser() antlr.Parser { return s.parser }

func (s *Lambdef_nocondContext) LAMBDA() antlr.TerminalNode {
	return s.GetToken(Python3ParserLAMBDA, 0)
}

func (s *Lambdef_nocondContext) Test_nocond() ITest_nocondContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITest_nocondContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITest_nocondContext)
}

func (s *Lambdef_nocondContext) Varargslist() IVarargslistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVarargslistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVarargslistContext)
}

func (s *Lambdef_nocondContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Lambdef_nocondContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Lambdef_nocondContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterLambdef_nocond(s)
	}
}

func (s *Lambdef_nocondContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitLambdef_nocond(s)
	}
}

func (s *Lambdef_nocondContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitLambdef_nocond(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Lambdef_nocond() (localctx ILambdef_nocondContext) {
	localctx = NewLambdef_nocondContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, Python3ParserRULE_lambdef_nocond)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(691)
		p.Match(Python3ParserLAMBDA)
	}
	p.SetState(693)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la-35)&-(0x1f+1)) == 0 && ((1<<uint((_la-35)))&((1<<(Python3ParserNAME-35))|(1<<(Python3ParserSTAR-35))|(1<<(Python3ParserPOWER-35)))) != 0 {
		{
			p.SetState(692)
			p.Varargslist()
		}

	}
	{
		p.SetState(695)
		p.Match(Python3ParserCOLON)
	}
	{
		p.SetState(696)
		p.Test_nocond()
	}

	return localctx
}

// IOr_testContext is an interface to support dynamic dispatch.
type IOr_testContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOr_testContext differentiates from other interfaces.
	IsOr_testContext()
}

type Or_testContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOr_testContext() *Or_testContext {
	var p = new(Or_testContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_or_test
	return p
}

func (*Or_testContext) IsOr_testContext() {}

func NewOr_testContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Or_testContext {
	var p = new(Or_testContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_or_test

	return p
}

func (s *Or_testContext) GetParser() antlr.Parser { return s.parser }

func (s *Or_testContext) AllAnd_test() []IAnd_testContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnd_testContext)(nil)).Elem())
	var tst = make([]IAnd_testContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnd_testContext)
		}
	}

	return tst
}

func (s *Or_testContext) And_test(i int) IAnd_testContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnd_testContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnd_testContext)
}

func (s *Or_testContext) AllOR() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserOR)
}

func (s *Or_testContext) OR(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserOR, i)
}

func (s *Or_testContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Or_testContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Or_testContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterOr_test(s)
	}
}

func (s *Or_testContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitOr_test(s)
	}
}

func (s *Or_testContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitOr_test(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Or_test() (localctx IOr_testContext) {
	localctx = NewOr_testContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, Python3ParserRULE_or_test)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(698)
		p.And_test()
	}
	p.SetState(703)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Python3ParserOR {
		{
			p.SetState(699)
			p.Match(Python3ParserOR)
		}
		{
			p.SetState(700)
			p.And_test()
		}

		p.SetState(705)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IAnd_testContext is an interface to support dynamic dispatch.
type IAnd_testContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnd_testContext differentiates from other interfaces.
	IsAnd_testContext()
}

type And_testContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnd_testContext() *And_testContext {
	var p = new(And_testContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_and_test
	return p
}

func (*And_testContext) IsAnd_testContext() {}

func NewAnd_testContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *And_testContext {
	var p = new(And_testContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_and_test

	return p
}

func (s *And_testContext) GetParser() antlr.Parser { return s.parser }

func (s *And_testContext) AllNot_test() []INot_testContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INot_testContext)(nil)).Elem())
	var tst = make([]INot_testContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INot_testContext)
		}
	}

	return tst
}

func (s *And_testContext) Not_test(i int) INot_testContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INot_testContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INot_testContext)
}

func (s *And_testContext) AllAND() []antlr.TerminalNode {
	return s.GetTokens(Python3ParserAND)
}

func (s *And_testContext) AND(i int) antlr.TerminalNode {
	return s.GetToken(Python3ParserAND, i)
}

func (s *And_testContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *And_testContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *And_testContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterAnd_test(s)
	}
}

func (s *And_testContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitAnd_test(s)
	}
}

func (s *And_testContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitAnd_test(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) And_test() (localctx IAnd_testContext) {
	localctx = NewAnd_testContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, Python3ParserRULE_and_test)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(706)
		p.Not_test()
	}
	p.SetState(711)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Python3ParserAND {
		{
			p.SetState(707)
			p.Match(Python3ParserAND)
		}
		{
			p.SetState(708)
			p.Not_test()
		}

		p.SetState(713)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// INot_testContext is an interface to support dynamic dispatch.
type INot_testContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNot_testContext differentiates from other interfaces.
	IsNot_testContext()
}

type Not_testContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNot_testContext() *Not_testContext {
	var p = new(Not_testContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_not_test
	return p
}

func (*Not_testContext) IsNot_testContext() {}

func NewNot_testContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Not_testContext {
	var p = new(Not_testContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_not_test

	return p
}

func (s *Not_testContext) GetParser() antlr.Parser { return s.parser }

func (s *Not_testContext) NOT() antlr.TerminalNode {
	return s.GetToken(Python3ParserNOT, 0)
}

func (s *Not_testContext) Not_test() INot_testContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INot_testContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INot_testContext)
}

func (s *Not_testContext) Comparison() IComparisonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComparisonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComparisonContext)
}

func (s *Not_testContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Not_testContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Not_testContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterNot_test(s)
	}
}

func (s *Not_testContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitNot_test(s)
	}
}

func (s *Not_testContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitNot_test(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Not_test() (localctx INot_testContext) {
	localctx = NewNot_testContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, Python3ParserRULE_not_test)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(717)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Python3ParserNOT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(714)
			p.Match(Python3ParserNOT)
		}
		{
			p.SetState(715)
			p.Not_test()
		}

	case Python3ParserNONE, Python3ParserTRUE, Python3ParserFALSE, Python3ParserNAME, Python3ParserSTRING_LITERAL, Python3ParserBYTES_LITERAL, Python3ParserDECIMAL_INTEGER, Python3ParserOCT_INTEGER, Python3ParserHEX_INTEGER, Python3ParserBIN_INTEGER, Python3ParserFLOAT_NUMBER, Python3ParserIMAG_NUMBER, Python3ParserELLIPSIS, Python3ParserSTAR, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserOPEN_BRACE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(716)
			p.Comparison()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IComparisonContext is an interface to support dynamic dispatch.
type IComparisonContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComparisonContext differentiates from other interfaces.
	IsComparisonContext()
}

type ComparisonContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonContext() *ComparisonContext {
	var p = new(ComparisonContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_comparison
	return p
}

func (*ComparisonContext) IsComparisonContext() {}

func NewComparisonContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonContext {
	var p = new(ComparisonContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_comparison

	return p
}

func (s *ComparisonContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonContext) AllStar_expr() []IStar_exprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStar_exprContext)(nil)).Elem())
	var tst = make([]IStar_exprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStar_exprContext)
		}
	}

	return tst
}

func (s *ComparisonContext) Star_expr(i int) IStar_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStar_exprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStar_exprContext)
}

func (s *ComparisonContext) AllComp_op() []IComp_opContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IComp_opContext)(nil)).Elem())
	var tst = make([]IComp_opContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IComp_opContext)
		}
	}

	return tst
}

func (s *ComparisonContext) Comp_op(i int) IComp_opContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComp_opContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IComp_opContext)
}

func (s *ComparisonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterComparison(s)
	}
}

func (s *ComparisonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitComparison(s)
	}
}

func (s *ComparisonContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitComparison(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Comparison() (localctx IComparisonContext) {
	localctx = NewComparisonContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, Python3ParserRULE_comparison)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(719)
		p.Star_expr()
	}
	p.SetState(725)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Python3ParserIN)|(1<<Python3ParserNOT)|(1<<Python3ParserIS))) != 0) || (((_la-69)&-(0x1f+1)) == 0 && ((1<<uint((_la-69)))&((1<<(Python3ParserLESS_THAN-69))|(1<<(Python3ParserGREATER_THAN-69))|(1<<(Python3ParserEQUALS-69))|(1<<(Python3ParserGT_EQ-69))|(1<<(Python3ParserLT_EQ-69))|(1<<(Python3ParserNOT_EQ_1-69))|(1<<(Python3ParserNOT_EQ_2-69)))) != 0) {
		{
			p.SetState(720)
			p.Comp_op()
		}
		{
			p.SetState(721)
			p.Star_expr()
		}

		p.SetState(727)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IComp_opContext is an interface to support dynamic dispatch.
type IComp_opContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComp_opContext differentiates from other interfaces.
	IsComp_opContext()
}

type Comp_opContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComp_opContext() *Comp_opContext {
	var p = new(Comp_opContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_comp_op
	return p
}

func (*Comp_opContext) IsComp_opContext() {}

func NewComp_opContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comp_opContext {
	var p = new(Comp_opContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_comp_op

	return p
}

func (s *Comp_opContext) GetParser() antlr.Parser { return s.parser }

func (s *Comp_opContext) IN() antlr.TerminalNode {
	return s.GetToken(Python3ParserIN, 0)
}

func (s *Comp_opContext) NOT() antlr.TerminalNode {
	return s.GetToken(Python3ParserNOT, 0)
}

func (s *Comp_opContext) IS() antlr.TerminalNode {
	return s.GetToken(Python3ParserIS, 0)
}

func (s *Comp_opContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comp_opContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comp_opContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterComp_op(s)
	}
}

func (s *Comp_opContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitComp_op(s)
	}
}

func (s *Comp_opContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitComp_op(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Comp_op() (localctx IComp_opContext) {
	localctx = NewComp_opContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, Python3ParserRULE_comp_op)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(741)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 93, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(728)
			p.Match(Python3ParserLESS_THAN)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(729)
			p.Match(Python3ParserGREATER_THAN)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(730)
			p.Match(Python3ParserEQUALS)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(731)
			p.Match(Python3ParserGT_EQ)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(732)
			p.Match(Python3ParserLT_EQ)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(733)
			p.Match(Python3ParserNOT_EQ_1)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(734)
			p.Match(Python3ParserNOT_EQ_2)
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(735)
			p.Match(Python3ParserIN)
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(736)
			p.Match(Python3ParserNOT)
		}
		{
			p.SetState(737)
			p.Match(Python3ParserIN)
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(738)
			p.Match(Python3ParserIS)
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(739)
			p.Match(Python3ParserIS)
		}
		{
			p.SetState(740)
			p.Match(Python3ParserNOT)
		}

	}

	return localctx
}

// IStar_exprContext is an interface to support dynamic dispatch.
type IStar_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStar_exprContext differentiates from other interfaces.
	IsStar_exprContext()
}

type Star_exprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStar_exprContext() *Star_exprContext {
	var p = new(Star_exprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_star_expr
	return p
}

func (*Star_exprContext) IsStar_exprContext() {}

func NewStar_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Star_exprContext {
	var p = new(Star_exprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_star_expr

	return p
}

func (s *Star_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Star_exprContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Star_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Star_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Star_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterStar_expr(s)
	}
}

func (s *Star_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitStar_expr(s)
	}
}

func (s *Star_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitStar_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Star_expr() (localctx IStar_exprContext) {
	localctx = NewStar_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, Python3ParserRULE_star_expr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(744)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserSTAR {
		{
			p.SetState(743)
			p.Match(Python3ParserSTAR)
		}

	}
	{
		p.SetState(746)
		p.Expr()
	}

	return localctx
}

// IExprContext is an interface to support dynamic dispatch.
type IExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExprContext differentiates from other interfaces.
	IsExprContext()
}

type ExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprContext() *ExprContext {
	var p = new(ExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_expr
	return p
}

func (*ExprContext) IsExprContext() {}

func NewExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprContext {
	var p = new(ExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_expr

	return p
}

func (s *ExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprContext) AllXor_expr() []IXor_exprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IXor_exprContext)(nil)).Elem())
	var tst = make([]IXor_exprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IXor_exprContext)
		}
	}

	return tst
}

func (s *ExprContext) Xor_expr(i int) IXor_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IXor_exprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IXor_exprContext)
}

func (s *ExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterExpr(s)
	}
}

func (s *ExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitExpr(s)
	}
}

func (s *ExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Expr() (localctx IExprContext) {
	localctx = NewExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, Python3ParserRULE_expr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(748)
		p.Xor_expr()
	}
	p.SetState(753)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Python3ParserOR_OP {
		{
			p.SetState(749)
			p.Match(Python3ParserOR_OP)
		}
		{
			p.SetState(750)
			p.Xor_expr()
		}

		p.SetState(755)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IXor_exprContext is an interface to support dynamic dispatch.
type IXor_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsXor_exprContext differentiates from other interfaces.
	IsXor_exprContext()
}

type Xor_exprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyXor_exprContext() *Xor_exprContext {
	var p = new(Xor_exprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_xor_expr
	return p
}

func (*Xor_exprContext) IsXor_exprContext() {}

func NewXor_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Xor_exprContext {
	var p = new(Xor_exprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_xor_expr

	return p
}

func (s *Xor_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Xor_exprContext) AllAnd_expr() []IAnd_exprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnd_exprContext)(nil)).Elem())
	var tst = make([]IAnd_exprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnd_exprContext)
		}
	}

	return tst
}

func (s *Xor_exprContext) And_expr(i int) IAnd_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnd_exprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnd_exprContext)
}

func (s *Xor_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Xor_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Xor_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterXor_expr(s)
	}
}

func (s *Xor_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitXor_expr(s)
	}
}

func (s *Xor_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitXor_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Xor_expr() (localctx IXor_exprContext) {
	localctx = NewXor_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, Python3ParserRULE_xor_expr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(756)
		p.And_expr()
	}
	p.SetState(761)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Python3ParserXOR {
		{
			p.SetState(757)
			p.Match(Python3ParserXOR)
		}
		{
			p.SetState(758)
			p.And_expr()
		}

		p.SetState(763)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IAnd_exprContext is an interface to support dynamic dispatch.
type IAnd_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnd_exprContext differentiates from other interfaces.
	IsAnd_exprContext()
}

type And_exprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnd_exprContext() *And_exprContext {
	var p = new(And_exprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_and_expr
	return p
}

func (*And_exprContext) IsAnd_exprContext() {}

func NewAnd_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *And_exprContext {
	var p = new(And_exprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_and_expr

	return p
}

func (s *And_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *And_exprContext) AllShift_expr() []IShift_exprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IShift_exprContext)(nil)).Elem())
	var tst = make([]IShift_exprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IShift_exprContext)
		}
	}

	return tst
}

func (s *And_exprContext) Shift_expr(i int) IShift_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IShift_exprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IShift_exprContext)
}

func (s *And_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *And_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *And_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterAnd_expr(s)
	}
}

func (s *And_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitAnd_expr(s)
	}
}

func (s *And_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitAnd_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) And_expr() (localctx IAnd_exprContext) {
	localctx = NewAnd_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, Python3ParserRULE_and_expr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(764)
		p.Shift_expr()
	}
	p.SetState(769)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Python3ParserAND_OP {
		{
			p.SetState(765)
			p.Match(Python3ParserAND_OP)
		}
		{
			p.SetState(766)
			p.Shift_expr()
		}

		p.SetState(771)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IShift_exprContext is an interface to support dynamic dispatch.
type IShift_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsShift_exprContext differentiates from other interfaces.
	IsShift_exprContext()
}

type Shift_exprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShift_exprContext() *Shift_exprContext {
	var p = new(Shift_exprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_shift_expr
	return p
}

func (*Shift_exprContext) IsShift_exprContext() {}

func NewShift_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Shift_exprContext {
	var p = new(Shift_exprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_shift_expr

	return p
}

func (s *Shift_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Shift_exprContext) AllArith_expr() []IArith_exprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IArith_exprContext)(nil)).Elem())
	var tst = make([]IArith_exprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IArith_exprContext)
		}
	}

	return tst
}

func (s *Shift_exprContext) Arith_expr(i int) IArith_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArith_exprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IArith_exprContext)
}

func (s *Shift_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Shift_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Shift_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterShift_expr(s)
	}
}

func (s *Shift_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitShift_expr(s)
	}
}

func (s *Shift_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitShift_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Shift_expr() (localctx IShift_exprContext) {
	localctx = NewShift_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, Python3ParserRULE_shift_expr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(772)
		p.Arith_expr()
	}
	p.SetState(779)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Python3ParserLEFT_SHIFT || _la == Python3ParserRIGHT_SHIFT {
		p.SetState(777)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case Python3ParserLEFT_SHIFT:
			{
				p.SetState(773)
				p.Match(Python3ParserLEFT_SHIFT)
			}
			{
				p.SetState(774)
				p.Arith_expr()
			}

		case Python3ParserRIGHT_SHIFT:
			{
				p.SetState(775)
				p.Match(Python3ParserRIGHT_SHIFT)
			}
			{
				p.SetState(776)
				p.Arith_expr()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(781)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IArith_exprContext is an interface to support dynamic dispatch.
type IArith_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArith_exprContext differentiates from other interfaces.
	IsArith_exprContext()
}

type Arith_exprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArith_exprContext() *Arith_exprContext {
	var p = new(Arith_exprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_arith_expr
	return p
}

func (*Arith_exprContext) IsArith_exprContext() {}

func NewArith_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Arith_exprContext {
	var p = new(Arith_exprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_arith_expr

	return p
}

func (s *Arith_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Arith_exprContext) AllTerm() []ITermContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITermContext)(nil)).Elem())
	var tst = make([]ITermContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITermContext)
		}
	}

	return tst
}

func (s *Arith_exprContext) Term(i int) ITermContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITermContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *Arith_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Arith_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Arith_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterArith_expr(s)
	}
}

func (s *Arith_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitArith_expr(s)
	}
}

func (s *Arith_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitArith_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Arith_expr() (localctx IArith_exprContext) {
	localctx = NewArith_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, Python3ParserRULE_arith_expr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(782)
		p.Term()
	}
	p.SetState(789)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Python3ParserADD || _la == Python3ParserMINUS {
		p.SetState(787)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case Python3ParserADD:
			{
				p.SetState(783)
				p.Match(Python3ParserADD)
			}
			{
				p.SetState(784)
				p.Term()
			}

		case Python3ParserMINUS:
			{
				p.SetState(785)
				p.Match(Python3ParserMINUS)
			}
			{
				p.SetState(786)
				p.Term()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(791)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ITermContext is an interface to support dynamic dispatch.
type ITermContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTermContext differentiates from other interfaces.
	IsTermContext()
}

type TermContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTermContext() *TermContext {
	var p = new(TermContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_term
	return p
}

func (*TermContext) IsTermContext() {}

func NewTermContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TermContext {
	var p = new(TermContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_term

	return p
}

func (s *TermContext) GetParser() antlr.Parser { return s.parser }

func (s *TermContext) AllFactor() []IFactorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFactorContext)(nil)).Elem())
	var tst = make([]IFactorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFactorContext)
		}
	}

	return tst
}

func (s *TermContext) Factor(i int) IFactorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFactorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFactorContext)
}

func (s *TermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TermContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterTerm(s)
	}
}

func (s *TermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitTerm(s)
	}
}

func (s *TermContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitTerm(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Term() (localctx ITermContext) {
	localctx = NewTermContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, Python3ParserRULE_term)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(792)
		p.Factor()
	}
	p.SetState(805)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ((_la-46)&-(0x1f+1)) == 0 && ((1<<uint((_la-46)))&((1<<(Python3ParserSTAR-46))|(1<<(Python3ParserDIV-46))|(1<<(Python3ParserMOD-46))|(1<<(Python3ParserIDIV-46))|(1<<(Python3ParserAT-46)))) != 0 {
		p.SetState(803)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case Python3ParserSTAR:
			{
				p.SetState(793)
				p.Match(Python3ParserSTAR)
			}
			{
				p.SetState(794)
				p.Factor()
			}

		case Python3ParserDIV:
			{
				p.SetState(795)
				p.Match(Python3ParserDIV)
			}
			{
				p.SetState(796)
				p.Factor()
			}

		case Python3ParserMOD:
			{
				p.SetState(797)
				p.Match(Python3ParserMOD)
			}
			{
				p.SetState(798)
				p.Factor()
			}

		case Python3ParserIDIV:
			{
				p.SetState(799)
				p.Match(Python3ParserIDIV)
			}
			{
				p.SetState(800)
				p.Factor()
			}

		case Python3ParserAT:
			{
				p.SetState(801)
				p.Match(Python3ParserAT)
			}
			{
				p.SetState(802)
				p.Factor()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(807)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IFactorContext is an interface to support dynamic dispatch.
type IFactorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFactorContext differentiates from other interfaces.
	IsFactorContext()
}

type FactorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFactorContext() *FactorContext {
	var p = new(FactorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_factor
	return p
}

func (*FactorContext) IsFactorContext() {}

func NewFactorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FactorContext {
	var p = new(FactorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_factor

	return p
}

func (s *FactorContext) GetParser() antlr.Parser { return s.parser }

func (s *FactorContext) Factor() IFactorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFactorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFactorContext)
}

func (s *FactorContext) Power() IPowerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPowerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPowerContext)
}

func (s *FactorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FactorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FactorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterFactor(s)
	}
}

func (s *FactorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitFactor(s)
	}
}

func (s *FactorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitFactor(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Factor() (localctx IFactorContext) {
	localctx = NewFactorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, Python3ParserRULE_factor)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(815)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Python3ParserADD:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(808)
			p.Match(Python3ParserADD)
		}
		{
			p.SetState(809)
			p.Factor()
		}

	case Python3ParserMINUS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(810)
			p.Match(Python3ParserMINUS)
		}
		{
			p.SetState(811)
			p.Factor()
		}

	case Python3ParserNOT_OP:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(812)
			p.Match(Python3ParserNOT_OP)
		}
		{
			p.SetState(813)
			p.Factor()
		}

	case Python3ParserNONE, Python3ParserTRUE, Python3ParserFALSE, Python3ParserNAME, Python3ParserSTRING_LITERAL, Python3ParserBYTES_LITERAL, Python3ParserDECIMAL_INTEGER, Python3ParserOCT_INTEGER, Python3ParserHEX_INTEGER, Python3ParserBIN_INTEGER, Python3ParserFLOAT_NUMBER, Python3ParserIMAG_NUMBER, Python3ParserELLIPSIS, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserOPEN_BRACE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(814)
			p.Power()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPowerContext is an interface to support dynamic dispatch.
type IPowerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPowerContext differentiates from other interfaces.
	IsPowerContext()
}

type PowerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPowerContext() *PowerContext {
	var p = new(PowerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_power
	return p
}

func (*PowerContext) IsPowerContext() {}

func NewPowerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PowerContext {
	var p = new(PowerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_power

	return p
}

func (s *PowerContext) GetParser() antlr.Parser { return s.parser }

func (s *PowerContext) Atom() IAtomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtomContext)
}

func (s *PowerContext) AllTrailer() []ITrailerContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITrailerContext)(nil)).Elem())
	var tst = make([]ITrailerContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITrailerContext)
		}
	}

	return tst
}

func (s *PowerContext) Trailer(i int) ITrailerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITrailerContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITrailerContext)
}

func (s *PowerContext) Factor() IFactorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFactorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFactorContext)
}

func (s *PowerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PowerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PowerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterPower(s)
	}
}

func (s *PowerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitPower(s)
	}
}

func (s *PowerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitPower(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Power() (localctx IPowerContext) {
	localctx = NewPowerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, Python3ParserRULE_power)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(817)
		p.Atom()
	}
	p.SetState(821)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ((_la-44)&-(0x1f+1)) == 0 && ((1<<uint((_la-44)))&((1<<(Python3ParserDOT-44))|(1<<(Python3ParserOPEN_PAREN-44))|(1<<(Python3ParserOPEN_BRACK-44)))) != 0 {
		{
			p.SetState(818)
			p.Trailer()
		}

		p.SetState(823)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(826)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserPOWER {
		{
			p.SetState(824)
			p.Match(Python3ParserPOWER)
		}
		{
			p.SetState(825)
			p.Factor()
		}

	}

	return localctx
}

// IAtomContext is an interface to support dynamic dispatch.
type IAtomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtomContext differentiates from other interfaces.
	IsAtomContext()
}

type AtomContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtomContext() *AtomContext {
	var p = new(AtomContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_atom
	return p
}

func (*AtomContext) IsAtomContext() {}

func NewAtomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtomContext {
	var p = new(AtomContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_atom

	return p
}

func (s *AtomContext) GetParser() antlr.Parser { return s.parser }

func (s *AtomContext) Yield_expr() IYield_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IYield_exprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IYield_exprContext)
}

func (s *AtomContext) Testlist_comp() ITestlist_compContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestlist_compContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestlist_compContext)
}

func (s *AtomContext) Dictorsetmaker() IDictorsetmakerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDictorsetmakerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDictorsetmakerContext)
}

func (s *AtomContext) NAME() antlr.TerminalNode {
	return s.GetToken(Python3ParserNAME, 0)
}

func (s *AtomContext) Number() INumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *AtomContext) AllStrr() []IStrrContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStrrContext)(nil)).Elem())
	var tst = make([]IStrrContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStrrContext)
		}
	}

	return tst
}

func (s *AtomContext) Strr(i int) IStrrContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStrrContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStrrContext)
}

func (s *AtomContext) NONE() antlr.TerminalNode {
	return s.GetToken(Python3ParserNONE, 0)
}

func (s *AtomContext) TRUE() antlr.TerminalNode {
	return s.GetToken(Python3ParserTRUE, 0)
}

func (s *AtomContext) FALSE() antlr.TerminalNode {
	return s.GetToken(Python3ParserFALSE, 0)
}

func (s *AtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterAtom(s)
	}
}

func (s *AtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitAtom(s)
	}
}

func (s *AtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitAtom(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Atom() (localctx IAtomContext) {
	localctx = NewAtomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, Python3ParserRULE_atom)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(855)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Python3ParserOPEN_PAREN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(828)
			p.Match(Python3ParserOPEN_PAREN)
		}
		p.SetState(831)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case Python3ParserYIELD:
			{
				p.SetState(829)
				p.Yield_expr()
			}

		case Python3ParserLAMBDA, Python3ParserNOT, Python3ParserNONE, Python3ParserTRUE, Python3ParserFALSE, Python3ParserNAME, Python3ParserSTRING_LITERAL, Python3ParserBYTES_LITERAL, Python3ParserDECIMAL_INTEGER, Python3ParserOCT_INTEGER, Python3ParserHEX_INTEGER, Python3ParserBIN_INTEGER, Python3ParserFLOAT_NUMBER, Python3ParserIMAG_NUMBER, Python3ParserELLIPSIS, Python3ParserSTAR, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserOPEN_BRACE:
			{
				p.SetState(830)
				p.Testlist_comp()
			}

		case Python3ParserCLOSE_PAREN:

		default:
		}
		{
			p.SetState(833)
			p.Match(Python3ParserCLOSE_PAREN)
		}

	case Python3ParserOPEN_BRACK:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(834)
			p.Match(Python3ParserOPEN_BRACK)
		}
		p.SetState(836)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la-20)&-(0x1f+1)) == 0 && ((1<<uint((_la-20)))&((1<<(Python3ParserLAMBDA-20))|(1<<(Python3ParserNOT-20))|(1<<(Python3ParserNONE-20))|(1<<(Python3ParserTRUE-20))|(1<<(Python3ParserFALSE-20))|(1<<(Python3ParserNAME-20))|(1<<(Python3ParserSTRING_LITERAL-20))|(1<<(Python3ParserBYTES_LITERAL-20))|(1<<(Python3ParserDECIMAL_INTEGER-20))|(1<<(Python3ParserOCT_INTEGER-20))|(1<<(Python3ParserHEX_INTEGER-20))|(1<<(Python3ParserBIN_INTEGER-20))|(1<<(Python3ParserFLOAT_NUMBER-20))|(1<<(Python3ParserIMAG_NUMBER-20))|(1<<(Python3ParserELLIPSIS-20))|(1<<(Python3ParserSTAR-20))|(1<<(Python3ParserOPEN_PAREN-20)))) != 0) || (((_la-54)&-(0x1f+1)) == 0 && ((1<<uint((_la-54)))&((1<<(Python3ParserOPEN_BRACK-54))|(1<<(Python3ParserADD-54))|(1<<(Python3ParserMINUS-54))|(1<<(Python3ParserNOT_OP-54))|(1<<(Python3ParserOPEN_BRACE-54)))) != 0) {
			{
				p.SetState(835)
				p.Testlist_comp()
			}

		}
		{
			p.SetState(838)
			p.Match(Python3ParserCLOSE_BRACK)
		}

	case Python3ParserOPEN_BRACE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(839)
			p.Match(Python3ParserOPEN_BRACE)
		}
		p.SetState(841)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la-20)&-(0x1f+1)) == 0 && ((1<<uint((_la-20)))&((1<<(Python3ParserLAMBDA-20))|(1<<(Python3ParserNOT-20))|(1<<(Python3ParserNONE-20))|(1<<(Python3ParserTRUE-20))|(1<<(Python3ParserFALSE-20))|(1<<(Python3ParserNAME-20))|(1<<(Python3ParserSTRING_LITERAL-20))|(1<<(Python3ParserBYTES_LITERAL-20))|(1<<(Python3ParserDECIMAL_INTEGER-20))|(1<<(Python3ParserOCT_INTEGER-20))|(1<<(Python3ParserHEX_INTEGER-20))|(1<<(Python3ParserBIN_INTEGER-20))|(1<<(Python3ParserFLOAT_NUMBER-20))|(1<<(Python3ParserIMAG_NUMBER-20))|(1<<(Python3ParserELLIPSIS-20))|(1<<(Python3ParserSTAR-20))|(1<<(Python3ParserOPEN_PAREN-20)))) != 0) || (((_la-54)&-(0x1f+1)) == 0 && ((1<<uint((_la-54)))&((1<<(Python3ParserOPEN_BRACK-54))|(1<<(Python3ParserADD-54))|(1<<(Python3ParserMINUS-54))|(1<<(Python3ParserNOT_OP-54))|(1<<(Python3ParserOPEN_BRACE-54)))) != 0) {
			{
				p.SetState(840)
				p.Dictorsetmaker()
			}

		}
		{
			p.SetState(843)
			p.Match(Python3ParserCLOSE_BRACE)
		}

	case Python3ParserNAME:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(844)
			p.Match(Python3ParserNAME)
		}

	case Python3ParserDECIMAL_INTEGER, Python3ParserOCT_INTEGER, Python3ParserHEX_INTEGER, Python3ParserBIN_INTEGER, Python3ParserFLOAT_NUMBER, Python3ParserIMAG_NUMBER:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(845)
			p.Number()
		}

	case Python3ParserSTRING_LITERAL, Python3ParserBYTES_LITERAL:
		p.EnterOuterAlt(localctx, 6)
		p.SetState(847)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == Python3ParserSTRING_LITERAL || _la == Python3ParserBYTES_LITERAL {
			{
				p.SetState(846)
				p.Strr()
			}

			p.SetState(849)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case Python3ParserELLIPSIS:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(851)
			p.Match(Python3ParserELLIPSIS)
		}

	case Python3ParserNONE:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(852)
			p.Match(Python3ParserNONE)
		}

	case Python3ParserTRUE:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(853)
			p.Match(Python3ParserTRUE)
		}

	case Python3ParserFALSE:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(854)
			p.Match(Python3ParserFALSE)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITestlist_compContext is an interface to support dynamic dispatch.
type ITestlist_compContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTestlist_compContext differentiates from other interfaces.
	IsTestlist_compContext()
}

type Testlist_compContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTestlist_compContext() *Testlist_compContext {
	var p = new(Testlist_compContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_testlist_comp
	return p
}

func (*Testlist_compContext) IsTestlist_compContext() {}

func NewTestlist_compContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Testlist_compContext {
	var p = new(Testlist_compContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_testlist_comp

	return p
}

func (s *Testlist_compContext) GetParser() antlr.Parser { return s.parser }

func (s *Testlist_compContext) AllTest() []ITestContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITestContext)(nil)).Elem())
	var tst = make([]ITestContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITestContext)
		}
	}

	return tst
}

func (s *Testlist_compContext) Test(i int) ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *Testlist_compContext) Comp_for() IComp_forContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComp_forContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComp_forContext)
}

func (s *Testlist_compContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Testlist_compContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Testlist_compContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterTestlist_comp(s)
	}
}

func (s *Testlist_compContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitTestlist_comp(s)
	}
}

func (s *Testlist_compContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitTestlist_comp(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Testlist_comp() (localctx ITestlist_compContext) {
	localctx = NewTestlist_compContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, Python3ParserRULE_testlist_comp)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(857)
		p.Test()
	}
	p.SetState(869)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Python3ParserFOR:
		{
			p.SetState(858)
			p.Comp_for()
		}

	case Python3ParserCLOSE_PAREN, Python3ParserCOMMA, Python3ParserCLOSE_BRACK:
		p.SetState(863)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 112, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(859)
					p.Match(Python3ParserCOMMA)
				}
				{
					p.SetState(860)
					p.Test()
				}

			}
			p.SetState(865)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 112, p.GetParserRuleContext())
		}
		p.SetState(867)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserCOMMA {
			{
				p.SetState(866)
				p.Match(Python3ParserCOMMA)
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITrailerContext is an interface to support dynamic dispatch.
type ITrailerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTrailerContext differentiates from other interfaces.
	IsTrailerContext()
}

type TrailerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTrailerContext() *TrailerContext {
	var p = new(TrailerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_trailer
	return p
}

func (*TrailerContext) IsTrailerContext() {}

func NewTrailerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TrailerContext {
	var p = new(TrailerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_trailer

	return p
}

func (s *TrailerContext) GetParser() antlr.Parser { return s.parser }

func (s *TrailerContext) Arglist() IArglistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArglistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArglistContext)
}

func (s *TrailerContext) Subscriptlist() ISubscriptlistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubscriptlistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubscriptlistContext)
}

func (s *TrailerContext) NAME() antlr.TerminalNode {
	return s.GetToken(Python3ParserNAME, 0)
}

func (s *TrailerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TrailerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TrailerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterTrailer(s)
	}
}

func (s *TrailerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitTrailer(s)
	}
}

func (s *TrailerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitTrailer(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Trailer() (localctx ITrailerContext) {
	localctx = NewTrailerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, Python3ParserRULE_trailer)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(882)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Python3ParserOPEN_PAREN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(871)
			p.Match(Python3ParserOPEN_PAREN)
		}
		p.SetState(873)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la-20)&-(0x1f+1)) == 0 && ((1<<uint((_la-20)))&((1<<(Python3ParserLAMBDA-20))|(1<<(Python3ParserNOT-20))|(1<<(Python3ParserNONE-20))|(1<<(Python3ParserTRUE-20))|(1<<(Python3ParserFALSE-20))|(1<<(Python3ParserNAME-20))|(1<<(Python3ParserSTRING_LITERAL-20))|(1<<(Python3ParserBYTES_LITERAL-20))|(1<<(Python3ParserDECIMAL_INTEGER-20))|(1<<(Python3ParserOCT_INTEGER-20))|(1<<(Python3ParserHEX_INTEGER-20))|(1<<(Python3ParserBIN_INTEGER-20))|(1<<(Python3ParserFLOAT_NUMBER-20))|(1<<(Python3ParserIMAG_NUMBER-20))|(1<<(Python3ParserELLIPSIS-20))|(1<<(Python3ParserSTAR-20))|(1<<(Python3ParserOPEN_PAREN-20)))) != 0) || (((_la-52)&-(0x1f+1)) == 0 && ((1<<uint((_la-52)))&((1<<(Python3ParserPOWER-52))|(1<<(Python3ParserOPEN_BRACK-52))|(1<<(Python3ParserADD-52))|(1<<(Python3ParserMINUS-52))|(1<<(Python3ParserNOT_OP-52))|(1<<(Python3ParserOPEN_BRACE-52)))) != 0) {
			{
				p.SetState(872)
				p.Arglist()
			}

		}
		{
			p.SetState(875)
			p.Match(Python3ParserCLOSE_PAREN)
		}

	case Python3ParserOPEN_BRACK:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(876)
			p.Match(Python3ParserOPEN_BRACK)
		}
		{
			p.SetState(877)
			p.Subscriptlist()
		}
		{
			p.SetState(878)
			p.Match(Python3ParserCLOSE_BRACK)
		}

	case Python3ParserDOT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(880)
			p.Match(Python3ParserDOT)
		}
		{
			p.SetState(881)
			p.Match(Python3ParserNAME)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISubscriptlistContext is an interface to support dynamic dispatch.
type ISubscriptlistContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubscriptlistContext differentiates from other interfaces.
	IsSubscriptlistContext()
}

type SubscriptlistContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubscriptlistContext() *SubscriptlistContext {
	var p = new(SubscriptlistContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_subscriptlist
	return p
}

func (*SubscriptlistContext) IsSubscriptlistContext() {}

func NewSubscriptlistContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubscriptlistContext {
	var p = new(SubscriptlistContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_subscriptlist

	return p
}

func (s *SubscriptlistContext) GetParser() antlr.Parser { return s.parser }

func (s *SubscriptlistContext) AllSubscript() []ISubscriptContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISubscriptContext)(nil)).Elem())
	var tst = make([]ISubscriptContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISubscriptContext)
		}
	}

	return tst
}

func (s *SubscriptlistContext) Subscript(i int) ISubscriptContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubscriptContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISubscriptContext)
}

func (s *SubscriptlistContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubscriptlistContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubscriptlistContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterSubscriptlist(s)
	}
}

func (s *SubscriptlistContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitSubscriptlist(s)
	}
}

func (s *SubscriptlistContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitSubscriptlist(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Subscriptlist() (localctx ISubscriptlistContext) {
	localctx = NewSubscriptlistContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, Python3ParserRULE_subscriptlist)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(884)
		p.Subscript()
	}
	p.SetState(889)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 117, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(885)
				p.Match(Python3ParserCOMMA)
			}
			{
				p.SetState(886)
				p.Subscript()
			}

		}
		p.SetState(891)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 117, p.GetParserRuleContext())
	}
	p.SetState(893)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserCOMMA {
		{
			p.SetState(892)
			p.Match(Python3ParserCOMMA)
		}

	}

	return localctx
}

// ISubscriptContext is an interface to support dynamic dispatch.
type ISubscriptContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubscriptContext differentiates from other interfaces.
	IsSubscriptContext()
}

type SubscriptContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubscriptContext() *SubscriptContext {
	var p = new(SubscriptContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_subscript
	return p
}

func (*SubscriptContext) IsSubscriptContext() {}

func NewSubscriptContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubscriptContext {
	var p = new(SubscriptContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_subscript

	return p
}

func (s *SubscriptContext) GetParser() antlr.Parser { return s.parser }

func (s *SubscriptContext) AllTest() []ITestContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITestContext)(nil)).Elem())
	var tst = make([]ITestContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITestContext)
		}
	}

	return tst
}

func (s *SubscriptContext) Test(i int) ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *SubscriptContext) Sliceop() ISliceopContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISliceopContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISliceopContext)
}

func (s *SubscriptContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubscriptContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubscriptContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterSubscript(s)
	}
}

func (s *SubscriptContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitSubscript(s)
	}
}

func (s *SubscriptContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitSubscript(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Subscript() (localctx ISubscriptContext) {
	localctx = NewSubscriptContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, Python3ParserRULE_subscript)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(906)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 122, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(895)
			p.Test()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(897)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la-20)&-(0x1f+1)) == 0 && ((1<<uint((_la-20)))&((1<<(Python3ParserLAMBDA-20))|(1<<(Python3ParserNOT-20))|(1<<(Python3ParserNONE-20))|(1<<(Python3ParserTRUE-20))|(1<<(Python3ParserFALSE-20))|(1<<(Python3ParserNAME-20))|(1<<(Python3ParserSTRING_LITERAL-20))|(1<<(Python3ParserBYTES_LITERAL-20))|(1<<(Python3ParserDECIMAL_INTEGER-20))|(1<<(Python3ParserOCT_INTEGER-20))|(1<<(Python3ParserHEX_INTEGER-20))|(1<<(Python3ParserBIN_INTEGER-20))|(1<<(Python3ParserFLOAT_NUMBER-20))|(1<<(Python3ParserIMAG_NUMBER-20))|(1<<(Python3ParserELLIPSIS-20))|(1<<(Python3ParserSTAR-20))|(1<<(Python3ParserOPEN_PAREN-20)))) != 0) || (((_la-54)&-(0x1f+1)) == 0 && ((1<<uint((_la-54)))&((1<<(Python3ParserOPEN_BRACK-54))|(1<<(Python3ParserADD-54))|(1<<(Python3ParserMINUS-54))|(1<<(Python3ParserNOT_OP-54))|(1<<(Python3ParserOPEN_BRACE-54)))) != 0) {
			{
				p.SetState(896)
				p.Test()
			}

		}
		{
			p.SetState(899)
			p.Match(Python3ParserCOLON)
		}
		p.SetState(901)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la-20)&-(0x1f+1)) == 0 && ((1<<uint((_la-20)))&((1<<(Python3ParserLAMBDA-20))|(1<<(Python3ParserNOT-20))|(1<<(Python3ParserNONE-20))|(1<<(Python3ParserTRUE-20))|(1<<(Python3ParserFALSE-20))|(1<<(Python3ParserNAME-20))|(1<<(Python3ParserSTRING_LITERAL-20))|(1<<(Python3ParserBYTES_LITERAL-20))|(1<<(Python3ParserDECIMAL_INTEGER-20))|(1<<(Python3ParserOCT_INTEGER-20))|(1<<(Python3ParserHEX_INTEGER-20))|(1<<(Python3ParserBIN_INTEGER-20))|(1<<(Python3ParserFLOAT_NUMBER-20))|(1<<(Python3ParserIMAG_NUMBER-20))|(1<<(Python3ParserELLIPSIS-20))|(1<<(Python3ParserSTAR-20))|(1<<(Python3ParserOPEN_PAREN-20)))) != 0) || (((_la-54)&-(0x1f+1)) == 0 && ((1<<uint((_la-54)))&((1<<(Python3ParserOPEN_BRACK-54))|(1<<(Python3ParserADD-54))|(1<<(Python3ParserMINUS-54))|(1<<(Python3ParserNOT_OP-54))|(1<<(Python3ParserOPEN_BRACE-54)))) != 0) {
			{
				p.SetState(900)
				p.Test()
			}

		}
		p.SetState(904)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserCOLON {
			{
				p.SetState(903)
				p.Sliceop()
			}

		}

	}

	return localctx
}

// ISliceopContext is an interface to support dynamic dispatch.
type ISliceopContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSliceopContext differentiates from other interfaces.
	IsSliceopContext()
}

type SliceopContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySliceopContext() *SliceopContext {
	var p = new(SliceopContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_sliceop
	return p
}

func (*SliceopContext) IsSliceopContext() {}

func NewSliceopContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SliceopContext {
	var p = new(SliceopContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_sliceop

	return p
}

func (s *SliceopContext) GetParser() antlr.Parser { return s.parser }

func (s *SliceopContext) Test() ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *SliceopContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SliceopContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SliceopContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterSliceop(s)
	}
}

func (s *SliceopContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitSliceop(s)
	}
}

func (s *SliceopContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitSliceop(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Sliceop() (localctx ISliceopContext) {
	localctx = NewSliceopContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, Python3ParserRULE_sliceop)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(908)
		p.Match(Python3ParserCOLON)
	}
	p.SetState(910)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-20)&-(0x1f+1)) == 0 && ((1<<uint((_la-20)))&((1<<(Python3ParserLAMBDA-20))|(1<<(Python3ParserNOT-20))|(1<<(Python3ParserNONE-20))|(1<<(Python3ParserTRUE-20))|(1<<(Python3ParserFALSE-20))|(1<<(Python3ParserNAME-20))|(1<<(Python3ParserSTRING_LITERAL-20))|(1<<(Python3ParserBYTES_LITERAL-20))|(1<<(Python3ParserDECIMAL_INTEGER-20))|(1<<(Python3ParserOCT_INTEGER-20))|(1<<(Python3ParserHEX_INTEGER-20))|(1<<(Python3ParserBIN_INTEGER-20))|(1<<(Python3ParserFLOAT_NUMBER-20))|(1<<(Python3ParserIMAG_NUMBER-20))|(1<<(Python3ParserELLIPSIS-20))|(1<<(Python3ParserSTAR-20))|(1<<(Python3ParserOPEN_PAREN-20)))) != 0) || (((_la-54)&-(0x1f+1)) == 0 && ((1<<uint((_la-54)))&((1<<(Python3ParserOPEN_BRACK-54))|(1<<(Python3ParserADD-54))|(1<<(Python3ParserMINUS-54))|(1<<(Python3ParserNOT_OP-54))|(1<<(Python3ParserOPEN_BRACE-54)))) != 0) {
		{
			p.SetState(909)
			p.Test()
		}

	}

	return localctx
}

// IExprlistContext is an interface to support dynamic dispatch.
type IExprlistContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExprlistContext differentiates from other interfaces.
	IsExprlistContext()
}

type ExprlistContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprlistContext() *ExprlistContext {
	var p = new(ExprlistContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_exprlist
	return p
}

func (*ExprlistContext) IsExprlistContext() {}

func NewExprlistContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprlistContext {
	var p = new(ExprlistContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_exprlist

	return p
}

func (s *ExprlistContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprlistContext) AllStar_expr() []IStar_exprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStar_exprContext)(nil)).Elem())
	var tst = make([]IStar_exprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStar_exprContext)
		}
	}

	return tst
}

func (s *ExprlistContext) Star_expr(i int) IStar_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStar_exprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStar_exprContext)
}

func (s *ExprlistContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprlistContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExprlistContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterExprlist(s)
	}
}

func (s *ExprlistContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitExprlist(s)
	}
}

func (s *ExprlistContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitExprlist(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Exprlist() (localctx IExprlistContext) {
	localctx = NewExprlistContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, Python3ParserRULE_exprlist)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(912)
		p.Star_expr()
	}
	p.SetState(917)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 124, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(913)
				p.Match(Python3ParserCOMMA)
			}
			{
				p.SetState(914)
				p.Star_expr()
			}

		}
		p.SetState(919)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 124, p.GetParserRuleContext())
	}
	p.SetState(921)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserCOMMA {
		{
			p.SetState(920)
			p.Match(Python3ParserCOMMA)
		}

	}

	return localctx
}

// ITestlistContext is an interface to support dynamic dispatch.
type ITestlistContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTestlistContext differentiates from other interfaces.
	IsTestlistContext()
}

type TestlistContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTestlistContext() *TestlistContext {
	var p = new(TestlistContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_testlist
	return p
}

func (*TestlistContext) IsTestlistContext() {}

func NewTestlistContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TestlistContext {
	var p = new(TestlistContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_testlist

	return p
}

func (s *TestlistContext) GetParser() antlr.Parser { return s.parser }

func (s *TestlistContext) AllTest() []ITestContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITestContext)(nil)).Elem())
	var tst = make([]ITestContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITestContext)
		}
	}

	return tst
}

func (s *TestlistContext) Test(i int) ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *TestlistContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TestlistContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TestlistContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterTestlist(s)
	}
}

func (s *TestlistContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitTestlist(s)
	}
}

func (s *TestlistContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitTestlist(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Testlist() (localctx ITestlistContext) {
	localctx = NewTestlistContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, Python3ParserRULE_testlist)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(923)
		p.Test()
	}
	p.SetState(928)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 126, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(924)
				p.Match(Python3ParserCOMMA)
			}
			{
				p.SetState(925)
				p.Test()
			}

		}
		p.SetState(930)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 126, p.GetParserRuleContext())
	}
	p.SetState(932)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserCOMMA {
		{
			p.SetState(931)
			p.Match(Python3ParserCOMMA)
		}

	}

	return localctx
}

// IDictorsetmakerContext is an interface to support dynamic dispatch.
type IDictorsetmakerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDictorsetmakerContext differentiates from other interfaces.
	IsDictorsetmakerContext()
}

type DictorsetmakerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDictorsetmakerContext() *DictorsetmakerContext {
	var p = new(DictorsetmakerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_dictorsetmaker
	return p
}

func (*DictorsetmakerContext) IsDictorsetmakerContext() {}

func NewDictorsetmakerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DictorsetmakerContext {
	var p = new(DictorsetmakerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_dictorsetmaker

	return p
}

func (s *DictorsetmakerContext) GetParser() antlr.Parser { return s.parser }

func (s *DictorsetmakerContext) AllTest() []ITestContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITestContext)(nil)).Elem())
	var tst = make([]ITestContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITestContext)
		}
	}

	return tst
}

func (s *DictorsetmakerContext) Test(i int) ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *DictorsetmakerContext) Comp_for() IComp_forContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComp_forContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComp_forContext)
}

func (s *DictorsetmakerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DictorsetmakerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DictorsetmakerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterDictorsetmaker(s)
	}
}

func (s *DictorsetmakerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitDictorsetmaker(s)
	}
}

func (s *DictorsetmakerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitDictorsetmaker(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Dictorsetmaker() (localctx IDictorsetmakerContext) {
	localctx = NewDictorsetmakerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, Python3ParserRULE_dictorsetmaker)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(967)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 134, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(934)
			p.Test()
		}
		{
			p.SetState(935)
			p.Match(Python3ParserCOLON)
		}
		{
			p.SetState(936)
			p.Test()
		}
		p.SetState(951)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case Python3ParserFOR:
			{
				p.SetState(937)
				p.Comp_for()
			}

		case Python3ParserCOMMA, Python3ParserCLOSE_BRACE:
			p.SetState(945)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 128, p.GetParserRuleContext())

			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(938)
						p.Match(Python3ParserCOMMA)
					}
					{
						p.SetState(939)
						p.Test()
					}
					{
						p.SetState(940)
						p.Match(Python3ParserCOLON)
					}
					{
						p.SetState(941)
						p.Test()
					}

				}
				p.SetState(947)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 128, p.GetParserRuleContext())
			}
			p.SetState(949)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == Python3ParserCOMMA {
				{
					p.SetState(948)
					p.Match(Python3ParserCOMMA)
				}

			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(953)
			p.Test()
		}
		p.SetState(965)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case Python3ParserFOR:
			{
				p.SetState(954)
				p.Comp_for()
			}

		case Python3ParserCOMMA, Python3ParserCLOSE_BRACE:
			p.SetState(959)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 131, p.GetParserRuleContext())

			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(955)
						p.Match(Python3ParserCOMMA)
					}
					{
						p.SetState(956)
						p.Test()
					}

				}
				p.SetState(961)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 131, p.GetParserRuleContext())
			}
			p.SetState(963)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == Python3ParserCOMMA {
				{
					p.SetState(962)
					p.Match(Python3ParserCOMMA)
				}

			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	}

	return localctx
}

// IClassdefContext is an interface to support dynamic dispatch.
type IClassdefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassdefContext differentiates from other interfaces.
	IsClassdefContext()
}

type ClassdefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassdefContext() *ClassdefContext {
	var p = new(ClassdefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_classdef
	return p
}

func (*ClassdefContext) IsClassdefContext() {}

func NewClassdefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassdefContext {
	var p = new(ClassdefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_classdef

	return p
}

func (s *ClassdefContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassdefContext) CLASS() antlr.TerminalNode {
	return s.GetToken(Python3ParserCLASS, 0)
}

func (s *ClassdefContext) NAME() antlr.TerminalNode {
	return s.GetToken(Python3ParserNAME, 0)
}

func (s *ClassdefContext) Suite() ISuiteContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISuiteContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISuiteContext)
}

func (s *ClassdefContext) Arglist() IArglistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArglistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArglistContext)
}

func (s *ClassdefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassdefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassdefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterClassdef(s)
	}
}

func (s *ClassdefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitClassdef(s)
	}
}

func (s *ClassdefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitClassdef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Classdef() (localctx IClassdefContext) {
	localctx = NewClassdefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, Python3ParserRULE_classdef)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(969)
		p.Match(Python3ParserCLASS)
	}
	{
		p.SetState(970)
		p.Match(Python3ParserNAME)
	}
	p.SetState(976)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserOPEN_PAREN {
		{
			p.SetState(971)
			p.Match(Python3ParserOPEN_PAREN)
		}
		p.SetState(973)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la-20)&-(0x1f+1)) == 0 && ((1<<uint((_la-20)))&((1<<(Python3ParserLAMBDA-20))|(1<<(Python3ParserNOT-20))|(1<<(Python3ParserNONE-20))|(1<<(Python3ParserTRUE-20))|(1<<(Python3ParserFALSE-20))|(1<<(Python3ParserNAME-20))|(1<<(Python3ParserSTRING_LITERAL-20))|(1<<(Python3ParserBYTES_LITERAL-20))|(1<<(Python3ParserDECIMAL_INTEGER-20))|(1<<(Python3ParserOCT_INTEGER-20))|(1<<(Python3ParserHEX_INTEGER-20))|(1<<(Python3ParserBIN_INTEGER-20))|(1<<(Python3ParserFLOAT_NUMBER-20))|(1<<(Python3ParserIMAG_NUMBER-20))|(1<<(Python3ParserELLIPSIS-20))|(1<<(Python3ParserSTAR-20))|(1<<(Python3ParserOPEN_PAREN-20)))) != 0) || (((_la-52)&-(0x1f+1)) == 0 && ((1<<uint((_la-52)))&((1<<(Python3ParserPOWER-52))|(1<<(Python3ParserOPEN_BRACK-52))|(1<<(Python3ParserADD-52))|(1<<(Python3ParserMINUS-52))|(1<<(Python3ParserNOT_OP-52))|(1<<(Python3ParserOPEN_BRACE-52)))) != 0) {
			{
				p.SetState(972)
				p.Arglist()
			}

		}
		{
			p.SetState(975)
			p.Match(Python3ParserCLOSE_PAREN)
		}

	}
	{
		p.SetState(978)
		p.Match(Python3ParserCOLON)
	}
	{
		p.SetState(979)
		p.Suite()
	}

	return localctx
}

// IArglistContext is an interface to support dynamic dispatch.
type IArglistContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArglistContext differentiates from other interfaces.
	IsArglistContext()
}

type ArglistContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArglistContext() *ArglistContext {
	var p = new(ArglistContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_arglist
	return p
}

func (*ArglistContext) IsArglistContext() {}

func NewArglistContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArglistContext {
	var p = new(ArglistContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_arglist

	return p
}

func (s *ArglistContext) GetParser() antlr.Parser { return s.parser }

func (s *ArglistContext) AllArgument() []IArgumentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IArgumentContext)(nil)).Elem())
	var tst = make([]IArgumentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IArgumentContext)
		}
	}

	return tst
}

func (s *ArglistContext) Argument(i int) IArgumentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IArgumentContext)
}

func (s *ArglistContext) AllTest() []ITestContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITestContext)(nil)).Elem())
	var tst = make([]ITestContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITestContext)
		}
	}

	return tst
}

func (s *ArglistContext) Test(i int) ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *ArglistContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArglistContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArglistContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterArglist(s)
	}
}

func (s *ArglistContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitArglist(s)
	}
}

func (s *ArglistContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitArglist(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Arglist() (localctx IArglistContext) {
	localctx = NewArglistContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, Python3ParserRULE_arglist)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(986)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 137, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(981)
				p.Argument()
			}
			{
				p.SetState(982)
				p.Match(Python3ParserCOMMA)
			}

		}
		p.SetState(988)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 137, p.GetParserRuleContext())
	}
	p.SetState(1009)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 141, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(989)
			p.Argument()
		}
		p.SetState(991)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserCOMMA {
			{
				p.SetState(990)
				p.Match(Python3ParserCOMMA)
			}

		}

	case 2:
		{
			p.SetState(993)
			p.Match(Python3ParserSTAR)
		}
		{
			p.SetState(994)
			p.Test()
		}
		p.SetState(999)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 139, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(995)
					p.Match(Python3ParserCOMMA)
				}
				{
					p.SetState(996)
					p.Argument()
				}

			}
			p.SetState(1001)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 139, p.GetParserRuleContext())
		}
		p.SetState(1005)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserCOMMA {
			{
				p.SetState(1002)
				p.Match(Python3ParserCOMMA)
			}
			{
				p.SetState(1003)
				p.Match(Python3ParserPOWER)
			}
			{
				p.SetState(1004)
				p.Test()
			}

		}

	case 3:
		{
			p.SetState(1007)
			p.Match(Python3ParserPOWER)
		}
		{
			p.SetState(1008)
			p.Test()
		}

	}

	return localctx
}

// IArgumentContext is an interface to support dynamic dispatch.
type IArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArgumentContext differentiates from other interfaces.
	IsArgumentContext()
}

type ArgumentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentContext() *ArgumentContext {
	var p = new(ArgumentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_argument
	return p
}

func (*ArgumentContext) IsArgumentContext() {}

func NewArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentContext {
	var p = new(ArgumentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_argument

	return p
}

func (s *ArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentContext) AllTest() []ITestContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITestContext)(nil)).Elem())
	var tst = make([]ITestContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITestContext)
		}
	}

	return tst
}

func (s *ArgumentContext) Test(i int) ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *ArgumentContext) Comp_for() IComp_forContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComp_forContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComp_forContext)
}

func (s *ArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterArgument(s)
	}
}

func (s *ArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitArgument(s)
	}
}

func (s *ArgumentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitArgument(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Argument() (localctx IArgumentContext) {
	localctx = NewArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, Python3ParserRULE_argument)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1019)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 143, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1011)
			p.Test()
		}
		p.SetState(1013)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Python3ParserFOR {
			{
				p.SetState(1012)
				p.Comp_for()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1015)
			p.Test()
		}
		{
			p.SetState(1016)
			p.Match(Python3ParserASSIGN)
		}
		{
			p.SetState(1017)
			p.Test()
		}

	}

	return localctx
}

// IComp_iterContext is an interface to support dynamic dispatch.
type IComp_iterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComp_iterContext differentiates from other interfaces.
	IsComp_iterContext()
}

type Comp_iterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComp_iterContext() *Comp_iterContext {
	var p = new(Comp_iterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_comp_iter
	return p
}

func (*Comp_iterContext) IsComp_iterContext() {}

func NewComp_iterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comp_iterContext {
	var p = new(Comp_iterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_comp_iter

	return p
}

func (s *Comp_iterContext) GetParser() antlr.Parser { return s.parser }

func (s *Comp_iterContext) Comp_for() IComp_forContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComp_forContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComp_forContext)
}

func (s *Comp_iterContext) Comp_if() IComp_ifContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComp_ifContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComp_ifContext)
}

func (s *Comp_iterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comp_iterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comp_iterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterComp_iter(s)
	}
}

func (s *Comp_iterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitComp_iter(s)
	}
}

func (s *Comp_iterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitComp_iter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Comp_iter() (localctx IComp_iterContext) {
	localctx = NewComp_iterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, Python3ParserRULE_comp_iter)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1023)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Python3ParserFOR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1021)
			p.Comp_for()
		}

	case Python3ParserIF:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1022)
			p.Comp_if()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IComp_forContext is an interface to support dynamic dispatch.
type IComp_forContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComp_forContext differentiates from other interfaces.
	IsComp_forContext()
}

type Comp_forContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComp_forContext() *Comp_forContext {
	var p = new(Comp_forContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_comp_for
	return p
}

func (*Comp_forContext) IsComp_forContext() {}

func NewComp_forContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comp_forContext {
	var p = new(Comp_forContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_comp_for

	return p
}

func (s *Comp_forContext) GetParser() antlr.Parser { return s.parser }

func (s *Comp_forContext) FOR() antlr.TerminalNode {
	return s.GetToken(Python3ParserFOR, 0)
}

func (s *Comp_forContext) Exprlist() IExprlistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprlistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprlistContext)
}

func (s *Comp_forContext) IN() antlr.TerminalNode {
	return s.GetToken(Python3ParserIN, 0)
}

func (s *Comp_forContext) Or_test() IOr_testContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOr_testContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOr_testContext)
}

func (s *Comp_forContext) Comp_iter() IComp_iterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComp_iterContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComp_iterContext)
}

func (s *Comp_forContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comp_forContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comp_forContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterComp_for(s)
	}
}

func (s *Comp_forContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitComp_for(s)
	}
}

func (s *Comp_forContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitComp_for(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Comp_for() (localctx IComp_forContext) {
	localctx = NewComp_forContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, Python3ParserRULE_comp_for)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1025)
		p.Match(Python3ParserFOR)
	}
	{
		p.SetState(1026)
		p.Exprlist()
	}
	{
		p.SetState(1027)
		p.Match(Python3ParserIN)
	}
	{
		p.SetState(1028)
		p.Or_test()
	}
	p.SetState(1030)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserIF || _la == Python3ParserFOR {
		{
			p.SetState(1029)
			p.Comp_iter()
		}

	}

	return localctx
}

// IComp_ifContext is an interface to support dynamic dispatch.
type IComp_ifContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComp_ifContext differentiates from other interfaces.
	IsComp_ifContext()
}

type Comp_ifContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComp_ifContext() *Comp_ifContext {
	var p = new(Comp_ifContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_comp_if
	return p
}

func (*Comp_ifContext) IsComp_ifContext() {}

func NewComp_ifContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comp_ifContext {
	var p = new(Comp_ifContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_comp_if

	return p
}

func (s *Comp_ifContext) GetParser() antlr.Parser { return s.parser }

func (s *Comp_ifContext) IF() antlr.TerminalNode {
	return s.GetToken(Python3ParserIF, 0)
}

func (s *Comp_ifContext) Test_nocond() ITest_nocondContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITest_nocondContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITest_nocondContext)
}

func (s *Comp_ifContext) Comp_iter() IComp_iterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComp_iterContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComp_iterContext)
}

func (s *Comp_ifContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comp_ifContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comp_ifContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterComp_if(s)
	}
}

func (s *Comp_ifContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitComp_if(s)
	}
}

func (s *Comp_ifContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitComp_if(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Comp_if() (localctx IComp_ifContext) {
	localctx = NewComp_ifContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, Python3ParserRULE_comp_if)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1032)
		p.Match(Python3ParserIF)
	}
	{
		p.SetState(1033)
		p.Test_nocond()
	}
	p.SetState(1035)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Python3ParserIF || _la == Python3ParserFOR {
		{
			p.SetState(1034)
			p.Comp_iter()
		}

	}

	return localctx
}

// IYield_exprContext is an interface to support dynamic dispatch.
type IYield_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsYield_exprContext differentiates from other interfaces.
	IsYield_exprContext()
}

type Yield_exprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyYield_exprContext() *Yield_exprContext {
	var p = new(Yield_exprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_yield_expr
	return p
}

func (*Yield_exprContext) IsYield_exprContext() {}

func NewYield_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Yield_exprContext {
	var p = new(Yield_exprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_yield_expr

	return p
}

func (s *Yield_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Yield_exprContext) YIELD() antlr.TerminalNode {
	return s.GetToken(Python3ParserYIELD, 0)
}

func (s *Yield_exprContext) Yield_arg() IYield_argContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IYield_argContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IYield_argContext)
}

func (s *Yield_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Yield_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Yield_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterYield_expr(s)
	}
}

func (s *Yield_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitYield_expr(s)
	}
}

func (s *Yield_exprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitYield_expr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Yield_expr() (localctx IYield_exprContext) {
	localctx = NewYield_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, Python3ParserRULE_yield_expr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1037)
		p.Match(Python3ParserYIELD)
	}
	p.SetState(1039)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-4)&-(0x1f+1)) == 0 && ((1<<uint((_la-4)))&((1<<(Python3ParserFROM-4))|(1<<(Python3ParserLAMBDA-4))|(1<<(Python3ParserNOT-4))|(1<<(Python3ParserNONE-4))|(1<<(Python3ParserTRUE-4))|(1<<(Python3ParserFALSE-4))|(1<<(Python3ParserNAME-4)))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(Python3ParserSTRING_LITERAL-36))|(1<<(Python3ParserBYTES_LITERAL-36))|(1<<(Python3ParserDECIMAL_INTEGER-36))|(1<<(Python3ParserOCT_INTEGER-36))|(1<<(Python3ParserHEX_INTEGER-36))|(1<<(Python3ParserBIN_INTEGER-36))|(1<<(Python3ParserFLOAT_NUMBER-36))|(1<<(Python3ParserIMAG_NUMBER-36))|(1<<(Python3ParserELLIPSIS-36))|(1<<(Python3ParserSTAR-36))|(1<<(Python3ParserOPEN_PAREN-36))|(1<<(Python3ParserOPEN_BRACK-36))|(1<<(Python3ParserADD-36))|(1<<(Python3ParserMINUS-36))|(1<<(Python3ParserNOT_OP-36))|(1<<(Python3ParserOPEN_BRACE-36)))) != 0) {
		{
			p.SetState(1038)
			p.Yield_arg()
		}

	}

	return localctx
}

// IYield_argContext is an interface to support dynamic dispatch.
type IYield_argContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsYield_argContext differentiates from other interfaces.
	IsYield_argContext()
}

type Yield_argContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyYield_argContext() *Yield_argContext {
	var p = new(Yield_argContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_yield_arg
	return p
}

func (*Yield_argContext) IsYield_argContext() {}

func NewYield_argContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Yield_argContext {
	var p = new(Yield_argContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_yield_arg

	return p
}

func (s *Yield_argContext) GetParser() antlr.Parser { return s.parser }

func (s *Yield_argContext) FROM() antlr.TerminalNode {
	return s.GetToken(Python3ParserFROM, 0)
}

func (s *Yield_argContext) Test() ITestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestContext)
}

func (s *Yield_argContext) Testlist() ITestlistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITestlistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITestlistContext)
}

func (s *Yield_argContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Yield_argContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Yield_argContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterYield_arg(s)
	}
}

func (s *Yield_argContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitYield_arg(s)
	}
}

func (s *Yield_argContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitYield_arg(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Yield_arg() (localctx IYield_argContext) {
	localctx = NewYield_argContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, Python3ParserRULE_yield_arg)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1044)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Python3ParserFROM:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1041)
			p.Match(Python3ParserFROM)
		}
		{
			p.SetState(1042)
			p.Test()
		}

	case Python3ParserLAMBDA, Python3ParserNOT, Python3ParserNONE, Python3ParserTRUE, Python3ParserFALSE, Python3ParserNAME, Python3ParserSTRING_LITERAL, Python3ParserBYTES_LITERAL, Python3ParserDECIMAL_INTEGER, Python3ParserOCT_INTEGER, Python3ParserHEX_INTEGER, Python3ParserBIN_INTEGER, Python3ParserFLOAT_NUMBER, Python3ParserIMAG_NUMBER, Python3ParserELLIPSIS, Python3ParserSTAR, Python3ParserOPEN_PAREN, Python3ParserOPEN_BRACK, Python3ParserADD, Python3ParserMINUS, Python3ParserNOT_OP, Python3ParserOPEN_BRACE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1043)
			p.Testlist()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IStrrContext is an interface to support dynamic dispatch.
type IStrrContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStrrContext differentiates from other interfaces.
	IsStrrContext()
}

type StrrContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStrrContext() *StrrContext {
	var p = new(StrrContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_strr
	return p
}

func (*StrrContext) IsStrrContext() {}

func NewStrrContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StrrContext {
	var p = new(StrrContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_strr

	return p
}

func (s *StrrContext) GetParser() antlr.Parser { return s.parser }

func (s *StrrContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(Python3ParserSTRING_LITERAL, 0)
}

func (s *StrrContext) BYTES_LITERAL() antlr.TerminalNode {
	return s.GetToken(Python3ParserBYTES_LITERAL, 0)
}

func (s *StrrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StrrContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StrrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterStrr(s)
	}
}

func (s *StrrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitStrr(s)
	}
}

func (s *StrrContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitStrr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Strr() (localctx IStrrContext) {
	localctx = NewStrrContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, Python3ParserRULE_strr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1046)
	_la = p.GetTokenStream().LA(1)

	if !(_la == Python3ParserSTRING_LITERAL || _la == Python3ParserBYTES_LITERAL) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// INumberContext is an interface to support dynamic dispatch.
type INumberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNumberContext differentiates from other interfaces.
	IsNumberContext()
}

type NumberContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumberContext() *NumberContext {
	var p = new(NumberContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_number
	return p
}

func (*NumberContext) IsNumberContext() {}

func NewNumberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumberContext {
	var p = new(NumberContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_number

	return p
}

func (s *NumberContext) GetParser() antlr.Parser { return s.parser }

func (s *NumberContext) Integer() IIntegerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerContext)
}

func (s *NumberContext) FLOAT_NUMBER() antlr.TerminalNode {
	return s.GetToken(Python3ParserFLOAT_NUMBER, 0)
}

func (s *NumberContext) IMAG_NUMBER() antlr.TerminalNode {
	return s.GetToken(Python3ParserIMAG_NUMBER, 0)
}

func (s *NumberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NumberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterNumber(s)
	}
}

func (s *NumberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitNumber(s)
	}
}

func (s *NumberContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitNumber(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Number() (localctx INumberContext) {
	localctx = NewNumberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, Python3ParserRULE_number)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1051)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Python3ParserDECIMAL_INTEGER, Python3ParserOCT_INTEGER, Python3ParserHEX_INTEGER, Python3ParserBIN_INTEGER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1048)
			p.Integer()
		}

	case Python3ParserFLOAT_NUMBER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1049)
			p.Match(Python3ParserFLOAT_NUMBER)
		}

	case Python3ParserIMAG_NUMBER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1050)
			p.Match(Python3ParserIMAG_NUMBER)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IIntegerContext is an interface to support dynamic dispatch.
type IIntegerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIntegerContext differentiates from other interfaces.
	IsIntegerContext()
}

type IntegerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntegerContext() *IntegerContext {
	var p = new(IntegerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Python3ParserRULE_integer
	return p
}

func (*IntegerContext) IsIntegerContext() {}

func NewIntegerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntegerContext {
	var p = new(IntegerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Python3ParserRULE_integer

	return p
}

func (s *IntegerContext) GetParser() antlr.Parser { return s.parser }

func (s *IntegerContext) DECIMAL_INTEGER() antlr.TerminalNode {
	return s.GetToken(Python3ParserDECIMAL_INTEGER, 0)
}

func (s *IntegerContext) OCT_INTEGER() antlr.TerminalNode {
	return s.GetToken(Python3ParserOCT_INTEGER, 0)
}

func (s *IntegerContext) HEX_INTEGER() antlr.TerminalNode {
	return s.GetToken(Python3ParserHEX_INTEGER, 0)
}

func (s *IntegerContext) BIN_INTEGER() antlr.TerminalNode {
	return s.GetToken(Python3ParserBIN_INTEGER, 0)
}

func (s *IntegerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntegerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntegerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.EnterInteger(s)
	}
}

func (s *IntegerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Python3Listener); ok {
		listenerT.ExitInteger(s)
	}
}

func (s *IntegerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Python3Visitor:
		return t.VisitInteger(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Python3Parser) Integer() (localctx IIntegerContext) {
	localctx = NewIntegerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, Python3ParserRULE_integer)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1053)
	_la = p.GetTokenStream().LA(1)

	if !(((_la-38)&-(0x1f+1)) == 0 && ((1<<uint((_la-38)))&((1<<(Python3ParserDECIMAL_INTEGER-38))|(1<<(Python3ParserOCT_INTEGER-38))|(1<<(Python3ParserHEX_INTEGER-38))|(1<<(Python3ParserBIN_INTEGER-38)))) != 0) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}
