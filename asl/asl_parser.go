// Code generated from ASL.g4 by ANTLR 4.9.3. DO NOT EDIT.

package asl // ASL
import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 116, 1201,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4,
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55,
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9,
	60, 4, 61, 9, 61, 4, 62, 9, 62, 4, 63, 9, 63, 4, 64, 9, 64, 4, 65, 9, 65,
	4, 66, 9, 66, 4, 67, 9, 67, 4, 68, 9, 68, 4, 69, 9, 69, 4, 70, 9, 70, 4,
	71, 9, 71, 4, 72, 9, 72, 4, 73, 9, 73, 4, 74, 9, 74, 4, 75, 9, 75, 4, 76,
	9, 76, 4, 77, 9, 77, 4, 78, 9, 78, 4, 79, 9, 79, 4, 80, 9, 80, 4, 81, 9,
	81, 4, 82, 9, 82, 4, 83, 9, 83, 4, 84, 9, 84, 4, 85, 9, 85, 4, 86, 9, 86,
	4, 87, 9, 87, 4, 88, 9, 88, 4, 89, 9, 89, 4, 90, 9, 90, 4, 91, 9, 91, 4,
	92, 9, 92, 4, 93, 9, 93, 4, 94, 9, 94, 4, 95, 9, 95, 4, 96, 9, 96, 4, 97,
	9, 97, 4, 98, 9, 98, 4, 99, 9, 99, 4, 100, 9, 100, 4, 101, 9, 101, 4, 102,
	9, 102, 4, 103, 9, 103, 4, 104, 9, 104, 4, 105, 9, 105, 4, 106, 9, 106,
	4, 107, 9, 107, 3, 2, 6, 2, 216, 10, 2, 13, 2, 14, 2, 217, 3, 2, 3, 2,
	3, 3, 3, 3, 3, 3, 5, 3, 225, 10, 3, 3, 3, 6, 3, 228, 10, 3, 13, 3, 14,
	3, 229, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3,
	4, 3, 4, 3, 4, 5, 4, 245, 10, 4, 3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 251, 10,
	5, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 5, 6, 258, 10, 6, 3, 7, 3, 7, 5, 7, 262,
	10, 7, 3, 7, 3, 7, 3, 7, 5, 7, 267, 10, 7, 3, 8, 3, 8, 5, 8, 271, 10, 8,
	3, 8, 3, 8, 3, 8, 3, 9, 3, 9, 5, 9, 278, 10, 9, 3, 9, 3, 9, 3, 9, 5, 9,
	283, 10, 9, 3, 10, 3, 10, 5, 10, 287, 10, 10, 3, 10, 3, 10, 3, 10, 3, 11,
	3, 11, 5, 11, 294, 10, 11, 3, 11, 3, 11, 3, 11, 3, 12, 3, 12, 3, 12, 3,
	12, 5, 12, 303, 10, 12, 3, 12, 3, 12, 3, 12, 3, 12, 3, 12, 5, 12, 310,
	10, 12, 3, 12, 3, 12, 3, 12, 5, 12, 315, 10, 12, 3, 13, 3, 13, 3, 13, 3,
	13, 5, 13, 321, 10, 13, 3, 14, 3, 14, 3, 14, 3, 14, 5, 14, 327, 10, 14,
	3, 14, 3, 14, 5, 14, 331, 10, 14, 3, 15, 3, 15, 5, 15, 335, 10, 15, 3,
	15, 3, 15, 3, 15, 5, 15, 340, 10, 15, 3, 15, 3, 15, 3, 15, 5, 15, 345,
	10, 15, 3, 16, 3, 16, 3, 16, 7, 16, 350, 10, 16, 12, 16, 14, 16, 353, 11,
	16, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 5, 17,
	364, 10, 17, 3, 18, 3, 18, 3, 18, 5, 18, 369, 10, 18, 3, 19, 3, 19, 5,
	19, 373, 10, 19, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 5, 20, 380, 10, 20,
	3, 20, 3, 20, 5, 20, 384, 10, 20, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 5,
	21, 391, 10, 21, 3, 21, 5, 21, 394, 10, 21, 3, 21, 3, 21, 3, 21, 3, 21,
	3, 21, 5, 21, 401, 10, 21, 3, 21, 3, 21, 5, 21, 405, 10, 21, 3, 22, 3,
	22, 3, 22, 3, 22, 3, 22, 3, 22, 5, 22, 413, 10, 22, 3, 22, 3, 22, 7, 22,
	417, 10, 22, 12, 22, 14, 22, 420, 11, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3,
	22, 3, 22, 5, 22, 428, 10, 22, 3, 22, 3, 22, 3, 22, 7, 22, 433, 10, 22,
	12, 22, 14, 22, 436, 11, 22, 5, 22, 438, 10, 22, 3, 23, 3, 23, 3, 24, 3,
	24, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24, 5, 24, 449, 10, 24, 3, 25, 3, 25,
	5, 25, 453, 10, 25, 3, 25, 3, 25, 3, 25, 3, 25, 5, 25, 459, 10, 25, 3,
	25, 3, 25, 6, 25, 463, 10, 25, 13, 25, 14, 25, 464, 3, 25, 3, 25, 5, 25,
	469, 10, 25, 3, 25, 3, 25, 5, 25, 473, 10, 25, 3, 26, 3, 26, 3, 26, 3,
	26, 5, 26, 479, 10, 26, 3, 26, 3, 26, 3, 26, 5, 26, 484, 10, 26, 3, 26,
	3, 26, 3, 26, 5, 26, 489, 10, 26, 3, 27, 3, 27, 3, 27, 5, 27, 494, 10,
	27, 3, 27, 3, 27, 3, 27, 3, 27, 5, 27, 500, 10, 27, 3, 27, 3, 27, 3, 27,
	3, 27, 3, 27, 3, 27, 5, 27, 508, 10, 27, 5, 27, 510, 10, 27, 3, 28, 3,
	28, 3, 28, 5, 28, 515, 10, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28,
	3, 28, 3, 28, 5, 28, 525, 10, 28, 3, 29, 3, 29, 3, 29, 5, 29, 530, 10,
	29, 3, 30, 3, 30, 3, 30, 3, 30, 3, 31, 3, 31, 3, 31, 3, 31, 3, 32, 3, 32,
	5, 32, 542, 10, 32, 3, 33, 3, 33, 3, 33, 3, 33, 5, 33, 548, 10, 33, 3,
	33, 3, 33, 3, 33, 3, 33, 3, 33, 5, 33, 555, 10, 33, 5, 33, 557, 10, 33,
	3, 34, 3, 34, 3, 34, 3, 34, 5, 34, 563, 10, 34, 3, 34, 3, 34, 3, 34, 3,
	35, 3, 35, 3, 35, 3, 35, 3, 36, 3, 36, 3, 36, 3, 36, 3, 37, 3, 37, 3, 37,
	7, 37, 579, 10, 37, 12, 37, 14, 37, 582, 11, 37, 3, 38, 3, 38, 3, 38, 3,
	38, 3, 38, 3, 38, 5, 38, 590, 10, 38, 3, 39, 3, 39, 3, 39, 5, 39, 595,
	10, 39, 3, 40, 3, 40, 5, 40, 599, 10, 40, 3, 40, 3, 40, 3, 40, 3, 40, 3,
	40, 5, 40, 606, 10, 40, 3, 40, 3, 40, 3, 41, 3, 41, 5, 41, 612, 10, 41,
	3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 5, 41, 619, 10, 41, 3, 41, 3, 41, 3,
	42, 3, 42, 5, 42, 625, 10, 42, 3, 42, 3, 42, 3, 42, 3, 42, 3, 42, 5, 42,
	632, 10, 42, 3, 42, 3, 42, 3, 43, 3, 43, 3, 43, 3, 43, 3, 44, 3, 44, 3,
	44, 3, 44, 3, 45, 3, 45, 3, 45, 3, 45, 3, 46, 3, 46, 3, 46, 7, 46, 651,
	10, 46, 12, 46, 14, 46, 654, 11, 46, 3, 47, 3, 47, 3, 47, 5, 47, 659, 10,
	47, 3, 48, 3, 48, 3, 48, 7, 48, 664, 10, 48, 12, 48, 14, 48, 667, 11, 48,
	3, 49, 3, 49, 3, 49, 3, 49, 5, 49, 673, 10, 49, 3, 50, 3, 50, 3, 50, 3,
	50, 3, 50, 3, 50, 5, 50, 681, 10, 50, 3, 51, 3, 51, 3, 51, 3, 51, 3, 51,
	3, 51, 3, 51, 3, 51, 3, 52, 3, 52, 3, 52, 3, 52, 3, 52, 3, 52, 3, 52, 3,
	52, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53,
	3, 53, 3, 53, 3, 53, 3, 54, 3, 54, 3, 54, 3, 54, 3, 54, 3, 54, 3, 54, 3,
	54, 3, 54, 3, 54, 3, 54, 3, 54, 3, 54, 3, 54, 3, 54, 3, 54, 3, 54, 3, 54,
	3, 54, 3, 54, 3, 54, 3, 54, 3, 54, 3, 55, 3, 55, 3, 55, 3, 55, 3, 55, 3,
	55, 3, 55, 3, 55, 3, 55, 3, 55, 3, 55, 3, 55, 3, 55, 3, 55, 3, 55, 3, 56,
	3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 57, 3, 57, 5, 57, 760,
	10, 57, 3, 58, 3, 58, 3, 58, 5, 58, 765, 10, 58, 3, 59, 3, 59, 3, 60, 3,
	60, 5, 60, 771, 10, 60, 3, 61, 3, 61, 3, 61, 5, 61, 776, 10, 61, 3, 62,
	3, 62, 3, 62, 5, 62, 781, 10, 62, 3, 63, 3, 63, 3, 63, 5, 63, 786, 10,
	63, 3, 64, 3, 64, 3, 64, 5, 64, 791, 10, 64, 3, 65, 3, 65, 3, 65, 5, 65,
	796, 10, 65, 3, 66, 3, 66, 3, 66, 5, 66, 801, 10, 66, 3, 67, 3, 67, 3,
	67, 5, 67, 806, 10, 67, 3, 68, 3, 68, 3, 68, 5, 68, 811, 10, 68, 3, 69,
	3, 69, 3, 69, 5, 69, 816, 10, 69, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 3,
	71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 72, 3, 72, 3, 72, 3, 72,
	3, 72, 3, 72, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 5, 73, 842, 10,
	73, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 6, 74, 852,
	10, 74, 13, 74, 14, 74, 853, 3, 74, 3, 74, 3, 75, 3, 75, 3, 76, 3, 76,
	3, 76, 3, 76, 3, 76, 3, 76, 3, 76, 3, 76, 5, 76, 868, 10, 76, 3, 77, 3,
	77, 3, 77, 3, 77, 3, 78, 3, 78, 3, 78, 3, 78, 3, 78, 3, 78, 3, 78, 3, 78,
	5, 78, 882, 10, 78, 3, 79, 3, 79, 3, 79, 3, 79, 3, 79, 3, 79, 3, 79, 3,
	79, 3, 79, 7, 79, 893, 10, 79, 12, 79, 14, 79, 896, 11, 79, 3, 79, 3, 79,
	7, 79, 900, 10, 79, 12, 79, 14, 79, 903, 11, 79, 5, 79, 905, 10, 79, 3,
	79, 3, 79, 3, 80, 3, 80, 3, 80, 3, 80, 3, 80, 3, 80, 3, 81, 3, 81, 3, 81,
	3, 81, 3, 81, 3, 81, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 7, 82, 927,
	10, 82, 12, 82, 14, 82, 930, 11, 82, 3, 83, 3, 83, 3, 83, 3, 83, 3, 84,
	3, 84, 3, 84, 3, 84, 3, 84, 5, 84, 941, 10, 84, 3, 85, 3, 85, 3, 85, 7,
	85, 946, 10, 85, 12, 85, 14, 85, 949, 11, 85, 3, 86, 3, 86, 3, 86, 3, 86,
	3, 86, 5, 86, 956, 10, 86, 3, 87, 3, 87, 5, 87, 960, 10, 87, 3, 87, 3,
	87, 3, 87, 5, 87, 965, 10, 87, 7, 87, 967, 10, 87, 12, 87, 14, 87, 970,
	11, 87, 3, 88, 3, 88, 3, 88, 5, 88, 975, 10, 88, 3, 88, 3, 88, 3, 88, 3,
	88, 3, 88, 7, 88, 982, 10, 88, 12, 88, 14, 88, 985, 11, 88, 6, 88, 987,
	10, 88, 13, 88, 14, 88, 988, 3, 88, 3, 88, 3, 88, 6, 88, 994, 10, 88, 13,
	88, 14, 88, 995, 5, 88, 998, 10, 88, 3, 88, 3, 88, 3, 89, 3, 89, 3, 89,
	3, 89, 3, 89, 3, 89, 5, 89, 1008, 10, 89, 3, 89, 3, 89, 3, 89, 6, 89, 1013,
	10, 89, 13, 89, 14, 89, 1014, 3, 89, 3, 89, 3, 89, 6, 89, 1020, 10, 89,
	13, 89, 14, 89, 1021, 5, 89, 1024, 10, 89, 3, 89, 3, 89, 3, 90, 5, 90,
	1029, 10, 90, 3, 90, 3, 90, 3, 90, 5, 90, 1034, 10, 90, 3, 90, 7, 90, 1037,
	10, 90, 12, 90, 14, 90, 1040, 11, 90, 3, 91, 5, 91, 1043, 10, 91, 3, 91,
	3, 91, 3, 91, 5, 91, 1048, 10, 91, 3, 91, 7, 91, 1051, 10, 91, 12, 91,
	14, 91, 1054, 11, 91, 3, 91, 3, 91, 5, 91, 1058, 10, 91, 3, 91, 3, 91,
	3, 91, 5, 91, 1063, 10, 91, 3, 91, 7, 91, 1066, 10, 91, 12, 91, 14, 91,
	1069, 11, 91, 3, 91, 3, 91, 5, 91, 1073, 10, 91, 3, 92, 5, 92, 1076, 10,
	92, 3, 92, 3, 92, 3, 92, 3, 92, 3, 92, 3, 92, 3, 92, 3, 92, 3, 92, 5, 92,
	1087, 10, 92, 3, 92, 5, 92, 1090, 10, 92, 3, 93, 3, 93, 3, 93, 3, 93, 3,
	93, 3, 93, 3, 93, 5, 93, 1099, 10, 93, 3, 94, 3, 94, 3, 94, 3, 94, 3, 94,
	3, 94, 3, 94, 7, 94, 1108, 10, 94, 12, 94, 14, 94, 1111, 11, 94, 3, 94,
	3, 94, 7, 94, 1115, 10, 94, 12, 94, 14, 94, 1118, 11, 94, 5, 94, 1120,
	10, 94, 3, 94, 3, 94, 3, 95, 3, 95, 3, 95, 5, 95, 1127, 10, 95, 3, 95,
	3, 95, 3, 96, 3, 96, 3, 96, 7, 96, 1134, 10, 96, 12, 96, 14, 96, 1137,
	11, 96, 3, 96, 3, 96, 3, 96, 7, 96, 1142, 10, 96, 12, 96, 14, 96, 1145,
	11, 96, 3, 96, 3, 96, 3, 97, 3, 97, 3, 97, 7, 97, 1152, 10, 97, 12, 97,
	14, 97, 1155, 11, 97, 3, 97, 3, 97, 3, 98, 3, 98, 3, 98, 3, 98, 3, 99,
	3, 99, 3, 100, 3, 100, 3, 101, 3, 101, 3, 102, 3, 102, 5, 102, 1171, 10,
	102, 3, 102, 3, 102, 3, 102, 3, 103, 3, 103, 3, 103, 3, 103, 3, 103, 3,
	103, 3, 103, 5, 103, 1183, 10, 103, 3, 104, 3, 104, 3, 104, 3, 104, 5,
	104, 1189, 10, 104, 3, 105, 3, 105, 3, 106, 3, 106, 3, 106, 3, 106, 3,
	107, 3, 107, 3, 107, 3, 107, 3, 107, 3, 1153, 2, 108, 2, 4, 6, 8, 10, 12,
	14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48,
	50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84,
	86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116,
	118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146,
	148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 174, 176,
	178, 180, 182, 184, 186, 188, 190, 192, 194, 196, 198, 200, 202, 204, 206,
	208, 210, 212, 2, 13, 3, 2, 36, 37, 3, 2, 9, 10, 3, 2, 18, 19, 3, 2, 73,
	74, 4, 2, 14, 15, 67, 68, 3, 2, 89, 91, 4, 2, 105, 105, 109, 109, 4, 2,
	21, 22, 73, 74, 4, 2, 23, 23, 75, 75, 4, 2, 103, 104, 106, 107, 4, 2, 104,
	104, 110, 110, 2, 1308, 2, 215, 3, 2, 2, 2, 4, 224, 3, 2, 2, 2, 6, 244,
	3, 2, 2, 2, 8, 250, 3, 2, 2, 2, 10, 257, 3, 2, 2, 2, 12, 261, 3, 2, 2,
	2, 14, 270, 3, 2, 2, 2, 16, 277, 3, 2, 2, 2, 18, 286, 3, 2, 2, 2, 20, 293,
	3, 2, 2, 2, 22, 314, 3, 2, 2, 2, 24, 320, 3, 2, 2, 2, 26, 322, 3, 2, 2,
	2, 28, 334, 3, 2, 2, 2, 30, 346, 3, 2, 2, 2, 32, 354, 3, 2, 2, 2, 34, 365,
	3, 2, 2, 2, 36, 372, 3, 2, 2, 2, 38, 374, 3, 2, 2, 2, 40, 385, 3, 2, 2,
	2, 42, 437, 3, 2, 2, 2, 44, 439, 3, 2, 2, 2, 46, 448, 3, 2, 2, 2, 48, 452,
	3, 2, 2, 2, 50, 474, 3, 2, 2, 2, 52, 509, 3, 2, 2, 2, 54, 524, 3, 2, 2,
	2, 56, 529, 3, 2, 2, 2, 58, 531, 3, 2, 2, 2, 60, 535, 3, 2, 2, 2, 62, 541,
	3, 2, 2, 2, 64, 543, 3, 2, 2, 2, 66, 558, 3, 2, 2, 2, 68, 567, 3, 2, 2,
	2, 70, 571, 3, 2, 2, 2, 72, 575, 3, 2, 2, 2, 74, 589, 3, 2, 2, 2, 76, 594,
	3, 2, 2, 2, 78, 596, 3, 2, 2, 2, 80, 609, 3, 2, 2, 2, 82, 622, 3, 2, 2,
	2, 84, 635, 3, 2, 2, 2, 86, 639, 3, 2, 2, 2, 88, 643, 3, 2, 2, 2, 90, 647,
	3, 2, 2, 2, 92, 658, 3, 2, 2, 2, 94, 660, 3, 2, 2, 2, 96, 672, 3, 2, 2,
	2, 98, 680, 3, 2, 2, 2, 100, 682, 3, 2, 2, 2, 102, 690, 3, 2, 2, 2, 104,
	698, 3, 2, 2, 2, 106, 711, 3, 2, 2, 2, 108, 734, 3, 2, 2, 2, 110, 749,
	3, 2, 2, 2, 112, 759, 3, 2, 2, 2, 114, 764, 3, 2, 2, 2, 116, 766, 3, 2,
	2, 2, 118, 770, 3, 2, 2, 2, 120, 775, 3, 2, 2, 2, 122, 780, 3, 2, 2, 2,
	124, 785, 3, 2, 2, 2, 126, 790, 3, 2, 2, 2, 128, 795, 3, 2, 2, 2, 130,
	800, 3, 2, 2, 2, 132, 805, 3, 2, 2, 2, 134, 810, 3, 2, 2, 2, 136, 815,
	3, 2, 2, 2, 138, 817, 3, 2, 2, 2, 140, 822, 3, 2, 2, 2, 142, 829, 3, 2,
	2, 2, 144, 841, 3, 2, 2, 2, 146, 843, 3, 2, 2, 2, 148, 857, 3, 2, 2, 2,
	150, 867, 3, 2, 2, 2, 152, 869, 3, 2, 2, 2, 154, 873, 3, 2, 2, 2, 156,
	883, 3, 2, 2, 2, 158, 908, 3, 2, 2, 2, 160, 914, 3, 2, 2, 2, 162, 920,
	3, 2, 2, 2, 164, 931, 3, 2, 2, 2, 166, 940, 3, 2, 2, 2, 168, 942, 3, 2,
	2, 2, 170, 955, 3, 2, 2, 2, 172, 959, 3, 2, 2, 2, 174, 971, 3, 2, 2, 2,
	176, 1001, 3, 2, 2, 2, 178, 1028, 3, 2, 2, 2, 180, 1072, 3, 2, 2, 2, 182,
	1075, 3, 2, 2, 2, 184, 1098, 3, 2, 2, 2, 186, 1100, 3, 2, 2, 2, 188, 1126,
	3, 2, 2, 2, 190, 1130, 3, 2, 2, 2, 192, 1148, 3, 2, 2, 2, 194, 1158, 3,
	2, 2, 2, 196, 1162, 3, 2, 2, 2, 198, 1164, 3, 2, 2, 2, 200, 1166, 3, 2,
	2, 2, 202, 1170, 3, 2, 2, 2, 204, 1182, 3, 2, 2, 2, 206, 1188, 3, 2, 2,
	2, 208, 1190, 3, 2, 2, 2, 210, 1192, 3, 2, 2, 2, 212, 1196, 3, 2, 2, 2,
	214, 216, 5, 4, 3, 2, 215, 214, 3, 2, 2, 2, 216, 217, 3, 2, 2, 2, 217,
	215, 3, 2, 2, 2, 217, 218, 3, 2, 2, 2, 218, 219, 3, 2, 2, 2, 219, 220,
	7, 2, 2, 3, 220, 3, 3, 2, 2, 2, 221, 225, 5, 6, 4, 2, 222, 225, 5, 8, 5,
	2, 223, 225, 5, 192, 97, 2, 224, 221, 3, 2, 2, 2, 224, 222, 3, 2, 2, 2,
	224, 223, 3, 2, 2, 2, 225, 227, 3, 2, 2, 2, 226, 228, 7, 115, 2, 2, 227,
	226, 3, 2, 2, 2, 228, 229, 3, 2, 2, 2, 229, 227, 3, 2, 2, 2, 229, 230,
	3, 2, 2, 2, 230, 5, 3, 2, 2, 2, 231, 245, 5, 10, 6, 2, 232, 245, 5, 28,
	15, 2, 233, 245, 5, 34, 18, 2, 234, 245, 5, 36, 19, 2, 235, 245, 5, 48,
	25, 2, 236, 245, 5, 50, 26, 2, 237, 245, 5, 52, 27, 2, 238, 245, 5, 54,
	28, 2, 239, 245, 5, 62, 32, 2, 240, 245, 5, 76, 39, 2, 241, 245, 5, 98,
	50, 2, 242, 245, 5, 136, 69, 2, 243, 245, 5, 144, 73, 2, 244, 231, 3, 2,
	2, 2, 244, 232, 3, 2, 2, 2, 244, 233, 3, 2, 2, 2, 244, 234, 3, 2, 2, 2,
	244, 235, 3, 2, 2, 2, 244, 236, 3, 2, 2, 2, 244, 237, 3, 2, 2, 2, 244,
	238, 3, 2, 2, 2, 244, 239, 3, 2, 2, 2, 244, 240, 3, 2, 2, 2, 244, 241,
	3, 2, 2, 2, 244, 242, 3, 2, 2, 2, 244, 243, 3, 2, 2, 2, 245, 7, 3, 2, 2,
	2, 246, 251, 5, 174, 88, 2, 247, 251, 5, 176, 89, 2, 248, 251, 5, 186,
	94, 2, 249, 251, 5, 190, 96, 2, 250, 246, 3, 2, 2, 2, 250, 247, 3, 2, 2,
	2, 250, 248, 3, 2, 2, 2, 250, 249, 3, 2, 2, 2, 251, 9, 3, 2, 2, 2, 252,
	258, 5, 12, 7, 2, 253, 258, 5, 14, 8, 2, 254, 258, 5, 16, 9, 2, 255, 258,
	5, 18, 10, 2, 256, 258, 5, 20, 11, 2, 257, 252, 3, 2, 2, 2, 257, 253, 3,
	2, 2, 2, 257, 254, 3, 2, 2, 2, 257, 255, 3, 2, 2, 2, 257, 256, 3, 2, 2,
	2, 258, 11, 3, 2, 2, 2, 259, 262, 5, 196, 99, 2, 260, 262, 5, 202, 102,
	2, 261, 259, 3, 2, 2, 2, 261, 260, 3, 2, 2, 2, 262, 263, 3, 2, 2, 2, 263,
	266, 7, 68, 2, 2, 264, 267, 5, 204, 103, 2, 265, 267, 7, 8, 2, 2, 266,
	264, 3, 2, 2, 2, 266, 265, 3, 2, 2, 2, 267, 13, 3, 2, 2, 2, 268, 271, 5,
	196, 99, 2, 269, 271, 5, 202, 102, 2, 270, 268, 3, 2, 2, 2, 270, 269, 3,
	2, 2, 2, 271, 272, 3, 2, 2, 2, 272, 273, 7, 68, 2, 2, 273, 274, 9, 2, 2,
	2, 274, 15, 3, 2, 2, 2, 275, 278, 5, 196, 99, 2, 276, 278, 5, 202, 102,
	2, 277, 275, 3, 2, 2, 2, 277, 276, 3, 2, 2, 2, 278, 279, 3, 2, 2, 2, 279,
	282, 7, 68, 2, 2, 280, 283, 5, 196, 99, 2, 281, 283, 7, 3, 2, 2, 282, 280,
	3, 2, 2, 2, 282, 281, 3, 2, 2, 2, 283, 17, 3, 2, 2, 2, 284, 287, 5, 196,
	99, 2, 285, 287, 5, 202, 102, 2, 286, 284, 3, 2, 2, 2, 286, 285, 3, 2,
	2, 2, 287, 288, 3, 2, 2, 2, 288, 289, 7, 68, 2, 2, 289, 290, 5, 202, 102,
	2, 290, 19, 3, 2, 2, 2, 291, 294, 5, 196, 99, 2, 292, 294, 5, 202, 102,
	2, 293, 291, 3, 2, 2, 2, 293, 292, 3, 2, 2, 2, 294, 295, 3, 2, 2, 2, 295,
	296, 7, 68, 2, 2, 296, 297, 5, 22, 12, 2, 297, 21, 3, 2, 2, 2, 298, 299,
	5, 24, 13, 2, 299, 302, 7, 97, 2, 2, 300, 303, 5, 24, 13, 2, 301, 303,
	5, 22, 12, 2, 302, 300, 3, 2, 2, 2, 302, 301, 3, 2, 2, 2, 303, 315, 3,
	2, 2, 2, 304, 305, 7, 76, 2, 2, 305, 306, 5, 24, 13, 2, 306, 309, 7, 97,
	2, 2, 307, 310, 5, 24, 13, 2, 308, 310, 5, 22, 12, 2, 309, 307, 3, 2, 2,
	2, 309, 308, 3, 2, 2, 2, 310, 311, 3, 2, 2, 2, 311, 312, 7, 77, 2, 2, 312,
	315, 3, 2, 2, 2, 313, 315, 5, 26, 14, 2, 314, 298, 3, 2, 2, 2, 314, 304,
	3, 2, 2, 2, 314, 313, 3, 2, 2, 2, 315, 23, 3, 2, 2, 2, 316, 321, 5, 196,
	99, 2, 317, 321, 5, 202, 102, 2, 318, 321, 5, 204, 103, 2, 319, 321, 5,
	26, 14, 2, 320, 316, 3, 2, 2, 2, 320, 317, 3, 2, 2, 2, 320, 318, 3, 2,
	2, 2, 320, 319, 3, 2, 2, 2, 321, 25, 3, 2, 2, 2, 322, 330, 7, 20, 2, 2,
	323, 331, 5, 194, 98, 2, 324, 327, 5, 196, 99, 2, 325, 327, 7, 3, 2, 2,
	326, 324, 3, 2, 2, 2, 326, 325, 3, 2, 2, 2, 327, 328, 3, 2, 2, 2, 328,
	329, 7, 27, 2, 2, 329, 331, 5, 56, 29, 2, 330, 323, 3, 2, 2, 2, 330, 326,
	3, 2, 2, 2, 331, 27, 3, 2, 2, 2, 332, 335, 5, 196, 99, 2, 333, 335, 7,
	3, 2, 2, 334, 332, 3, 2, 2, 2, 334, 333, 3, 2, 2, 2, 335, 336, 3, 2, 2,
	2, 336, 337, 7, 68, 2, 2, 337, 339, 7, 4, 2, 2, 338, 340, 7, 5, 2, 2, 339,
	338, 3, 2, 2, 2, 339, 340, 3, 2, 2, 2, 340, 341, 3, 2, 2, 2, 341, 344,
	5, 198, 100, 2, 342, 343, 7, 6, 2, 2, 343, 345, 5, 30, 16, 2, 344, 342,
	3, 2, 2, 2, 344, 345, 3, 2, 2, 2, 345, 29, 3, 2, 2, 2, 346, 351, 5, 32,
	17, 2, 347, 348, 7, 73, 2, 2, 348, 350, 5, 32, 17, 2, 349, 347, 3, 2, 2,
	2, 350, 353, 3, 2, 2, 2, 351, 349, 3, 2, 2, 2, 351, 352, 3, 2, 2, 2, 352,
	31, 3, 2, 2, 2, 353, 351, 3, 2, 2, 2, 354, 355, 5, 200, 101, 2, 355, 363,
	7, 68, 2, 2, 356, 364, 5, 204, 103, 2, 357, 364, 5, 196, 99, 2, 358, 364,
	5, 202, 102, 2, 359, 364, 5, 22, 12, 2, 360, 364, 7, 36, 2, 2, 361, 364,
	7, 37, 2, 2, 362, 364, 7, 8, 2, 2, 363, 356, 3, 2, 2, 2, 363, 357, 3, 2,
	2, 2, 363, 358, 3, 2, 2, 2, 363, 359, 3, 2, 2, 2, 363, 360, 3, 2, 2, 2,
	363, 361, 3, 2, 2, 2, 363, 362, 3, 2, 2, 2, 364, 33, 3, 2, 2, 2, 365, 368,
	7, 7, 2, 2, 366, 369, 5, 196, 99, 2, 367, 369, 7, 3, 2, 2, 368, 366, 3,
	2, 2, 2, 368, 367, 3, 2, 2, 2, 369, 35, 3, 2, 2, 2, 370, 373, 5, 38, 20,
	2, 371, 373, 5, 40, 21, 2, 372, 370, 3, 2, 2, 2, 372, 371, 3, 2, 2, 2,
	373, 37, 3, 2, 2, 2, 374, 375, 5, 196, 99, 2, 375, 376, 7, 68, 2, 2, 376,
	379, 9, 3, 2, 2, 377, 380, 5, 198, 100, 2, 378, 380, 5, 194, 98, 2, 379,
	377, 3, 2, 2, 2, 379, 378, 3, 2, 2, 2, 380, 383, 3, 2, 2, 2, 381, 382,
	7, 13, 2, 2, 382, 384, 5, 42, 22, 2, 383, 381, 3, 2, 2, 2, 383, 384, 3,
	2, 2, 2, 384, 39, 3, 2, 2, 2, 385, 386, 5, 194, 98, 2, 386, 400, 7, 68,
	2, 2, 387, 388, 7, 12, 2, 2, 388, 394, 5, 198, 100, 2, 389, 391, 7, 12,
	2, 2, 390, 389, 3, 2, 2, 2, 390, 391, 3, 2, 2, 2, 391, 392, 3, 2, 2, 2,
	392, 394, 5, 194, 98, 2, 393, 387, 3, 2, 2, 2, 393, 390, 3, 2, 2, 2, 394,
	395, 3, 2, 2, 2, 395, 396, 7, 13, 2, 2, 396, 397, 5, 42, 22, 2, 397, 401,
	3, 2, 2, 2, 398, 399, 7, 11, 2, 2, 399, 401, 5, 198, 100, 2, 400, 393,
	3, 2, 2, 2, 400, 398, 3, 2, 2, 2, 401, 404, 3, 2, 2, 2, 402, 403, 9, 4,
	2, 2, 403, 405, 5, 200, 101, 2, 404, 402, 3, 2, 2, 2, 404, 405, 3, 2, 2,
	2, 405, 41, 3, 2, 2, 2, 406, 407, 5, 200, 101, 2, 407, 412, 5, 46, 24,
	2, 408, 413, 5, 196, 99, 2, 409, 413, 5, 202, 102, 2, 410, 413, 5, 204,
	103, 2, 411, 413, 7, 8, 2, 2, 412, 408, 3, 2, 2, 2, 412, 409, 3, 2, 2,
	2, 412, 410, 3, 2, 2, 2, 412, 411, 3, 2, 2, 2, 413, 418, 3, 2, 2, 2, 414,
	415, 9, 5, 2, 2, 415, 417, 5, 42, 22, 2, 416, 414, 3, 2, 2, 2, 417, 420,
	3, 2, 2, 2, 418, 416, 3, 2, 2, 2, 418, 419, 3, 2, 2, 2, 419, 438, 3, 2,
	2, 2, 420, 418, 3, 2, 2, 2, 421, 422, 7, 76, 2, 2, 422, 423, 5, 200, 101,
	2, 423, 427, 5, 46, 24, 2, 424, 428, 5, 196, 99, 2, 425, 428, 5, 204, 103,
	2, 426, 428, 7, 8, 2, 2, 427, 424, 3, 2, 2, 2, 427, 425, 3, 2, 2, 2, 427,
	426, 3, 2, 2, 2, 428, 429, 3, 2, 2, 2, 429, 434, 7, 77, 2, 2, 430, 431,
	9, 5, 2, 2, 431, 433, 5, 42, 22, 2, 432, 430, 3, 2, 2, 2, 433, 436, 3,
	2, 2, 2, 434, 432, 3, 2, 2, 2, 434, 435, 3, 2, 2, 2, 435, 438, 3, 2, 2,
	2, 436, 434, 3, 2, 2, 2, 437, 406, 3, 2, 2, 2, 437, 421, 3, 2, 2, 2, 438,
	43, 3, 2, 2, 2, 439, 440, 9, 6, 2, 2, 440, 45, 3, 2, 2, 2, 441, 449, 5,
	44, 23, 2, 442, 449, 7, 71, 2, 2, 443, 449, 7, 72, 2, 2, 444, 449, 7, 69,
	2, 2, 445, 449, 7, 70, 2, 2, 446, 449, 7, 16, 2, 2, 447, 449, 7, 17, 2,
	2, 448, 441, 3, 2, 2, 2, 448, 442, 3, 2, 2, 2, 448, 443, 3, 2, 2, 2, 448,
	444, 3, 2, 2, 2, 448, 445, 3, 2, 2, 2, 448, 446, 3, 2, 2, 2, 448, 447,
	3, 2, 2, 2, 449, 47, 3, 2, 2, 2, 450, 453, 5, 196, 99, 2, 451, 453, 5,
	194, 98, 2, 452, 450, 3, 2, 2, 2, 452, 451, 3, 2, 2, 2, 453, 454, 3, 2,
	2, 2, 454, 458, 7, 68, 2, 2, 455, 459, 5, 196, 99, 2, 456, 459, 5, 194,
	98, 2, 457, 459, 7, 3, 2, 2, 458, 455, 3, 2, 2, 2, 458, 456, 3, 2, 2, 2,
	458, 457, 3, 2, 2, 2, 459, 462, 3, 2, 2, 2, 460, 461, 7, 27, 2, 2, 461,
	463, 5, 56, 29, 2, 462, 460, 3, 2, 2, 2, 463, 464, 3, 2, 2, 2, 464, 462,
	3, 2, 2, 2, 464, 465, 3, 2, 2, 2, 465, 468, 3, 2, 2, 2, 466, 467, 7, 13,
	2, 2, 467, 469, 5, 42, 22, 2, 468, 466, 3, 2, 2, 2, 468, 469, 3, 2, 2,
	2, 469, 472, 3, 2, 2, 2, 470, 471, 9, 4, 2, 2, 471, 473, 5, 200, 101, 2,
	472, 470, 3, 2, 2, 2, 472, 473, 3, 2, 2, 2, 473, 49, 3, 2, 2, 2, 474, 475,
	5, 196, 99, 2, 475, 478, 7, 68, 2, 2, 476, 479, 5, 196, 99, 2, 477, 479,
	7, 3, 2, 2, 478, 476, 3, 2, 2, 2, 478, 477, 3, 2, 2, 2, 479, 480, 3, 2,
	2, 2, 480, 483, 7, 21, 2, 2, 481, 484, 5, 196, 99, 2, 482, 484, 7, 3, 2,
	2, 483, 481, 3, 2, 2, 2, 483, 482, 3, 2, 2, 2, 484, 485, 3, 2, 2, 2, 485,
	488, 7, 27, 2, 2, 486, 489, 5, 58, 30, 2, 487, 489, 5, 60, 31, 2, 488,
	486, 3, 2, 2, 2, 488, 487, 3, 2, 2, 2, 489, 51, 3, 2, 2, 2, 490, 493, 7,
	24, 2, 2, 491, 494, 5, 196, 99, 2, 492, 494, 7, 3, 2, 2, 493, 491, 3, 2,
	2, 2, 493, 492, 3, 2, 2, 2, 494, 495, 3, 2, 2, 2, 495, 496, 5, 56, 29,
	2, 496, 499, 5, 196, 99, 2, 497, 498, 7, 25, 2, 2, 498, 500, 5, 196, 99,
	2, 499, 497, 3, 2, 2, 2, 499, 500, 3, 2, 2, 2, 500, 510, 3, 2, 2, 2, 501,
	502, 7, 24, 2, 2, 502, 503, 5, 196, 99, 2, 503, 504, 5, 56, 29, 2, 504,
	507, 7, 3, 2, 2, 505, 506, 7, 25, 2, 2, 506, 508, 5, 196, 99, 2, 507, 505,
	3, 2, 2, 2, 507, 508, 3, 2, 2, 2, 508, 510, 3, 2, 2, 2, 509, 490, 3, 2,
	2, 2, 509, 501, 3, 2, 2, 2, 510, 53, 3, 2, 2, 2, 511, 514, 7, 26, 2, 2,
	512, 515, 5, 196, 99, 2, 513, 515, 7, 3, 2, 2, 514, 512, 3, 2, 2, 2, 514,
	513, 3, 2, 2, 2, 515, 516, 3, 2, 2, 2, 516, 517, 5, 56, 29, 2, 517, 518,
	5, 196, 99, 2, 518, 525, 3, 2, 2, 2, 519, 520, 7, 26, 2, 2, 520, 521, 5,
	196, 99, 2, 521, 522, 5, 56, 29, 2, 522, 523, 7, 3, 2, 2, 523, 525, 3,
	2, 2, 2, 524, 511, 3, 2, 2, 2, 524, 519, 3, 2, 2, 2, 525, 55, 3, 2, 2,
	2, 526, 530, 7, 102, 2, 2, 527, 530, 5, 58, 30, 2, 528, 530, 5, 60, 31,
	2, 529, 526, 3, 2, 2, 2, 529, 527, 3, 2, 2, 2, 529, 528, 3, 2, 2, 2, 530,
	57, 3, 2, 2, 2, 531, 532, 7, 102, 2, 2, 532, 533, 7, 83, 2, 2, 533, 534,
	5, 198, 100, 2, 534, 59, 3, 2, 2, 2, 535, 536, 7, 102, 2, 2, 536, 537,
	7, 83, 2, 2, 537, 538, 7, 99, 2, 2, 538, 61, 3, 2, 2, 2, 539, 542, 5, 64,
	33, 2, 540, 542, 5, 66, 34, 2, 541, 539, 3, 2, 2, 2, 541, 540, 3, 2, 2,
	2, 542, 63, 3, 2, 2, 2, 543, 544, 7, 28, 2, 2, 544, 545, 5, 68, 35, 2,
	545, 547, 7, 76, 2, 2, 546, 548, 5, 72, 37, 2, 547, 546, 3, 2, 2, 2, 547,
	548, 3, 2, 2, 2, 548, 549, 3, 2, 2, 2, 549, 550, 7, 77, 2, 2, 550, 556,
	7, 84, 2, 2, 551, 554, 7, 29, 2, 2, 552, 555, 5, 196, 99, 2, 553, 555,
	7, 3, 2, 2, 554, 552, 3, 2, 2, 2, 554, 553, 3, 2, 2, 2, 555, 557, 3, 2,
	2, 2, 556, 551, 3, 2, 2, 2, 556, 557, 3, 2, 2, 2, 557, 65, 3, 2, 2, 2,
	558, 559, 7, 28, 2, 2, 559, 560, 5, 70, 36, 2, 560, 562, 7, 76, 2, 2, 561,
	563, 5, 72, 37, 2, 562, 561, 3, 2, 2, 2, 562, 563, 3, 2, 2, 2, 563, 564,
	3, 2, 2, 2, 564, 565, 7, 77, 2, 2, 565, 566, 7, 84, 2, 2, 566, 67, 3, 2,
	2, 2, 567, 568, 7, 108, 2, 2, 568, 569, 7, 85, 2, 2, 569, 570, 7, 106,
	2, 2, 570, 69, 3, 2, 2, 2, 571, 572, 7, 108, 2, 2, 572, 573, 7, 85, 2,
	2, 573, 574, 7, 106, 2, 2, 574, 71, 3, 2, 2, 2, 575, 580, 5, 74, 38, 2,
	576, 577, 7, 86, 2, 2, 577, 579, 5, 74, 38, 2, 578, 576, 3, 2, 2, 2, 579,
	582, 3, 2, 2, 2, 580, 578, 3, 2, 2, 2, 580, 581, 3, 2, 2, 2, 581, 73, 3,
	2, 2, 2, 582, 580, 3, 2, 2, 2, 583, 590, 5, 196, 99, 2, 584, 590, 5, 204,
	103, 2, 585, 590, 7, 3, 2, 2, 586, 590, 5, 202, 102, 2, 587, 590, 5, 210,
	106, 2, 588, 590, 7, 8, 2, 2, 589, 583, 3, 2, 2, 2, 589, 584, 3, 2, 2,
	2, 589, 585, 3, 2, 2, 2, 589, 586, 3, 2, 2, 2, 589, 587, 3, 2, 2, 2, 589,
	588, 3, 2, 2, 2, 590, 75, 3, 2, 2, 2, 591, 595, 5, 78, 40, 2, 592, 595,
	5, 80, 41, 2, 593, 595, 5, 82, 42, 2, 594, 591, 3, 2, 2, 2, 594, 592, 3,
	2, 2, 2, 594, 593, 3, 2, 2, 2, 595, 77, 3, 2, 2, 2, 596, 598, 7, 80, 2,
	2, 597, 599, 5, 90, 46, 2, 598, 597, 3, 2, 2, 2, 598, 599, 3, 2, 2, 2,
	599, 600, 3, 2, 2, 2, 600, 601, 7, 81, 2, 2, 601, 602, 7, 68, 2, 2, 602,
	603, 5, 84, 43, 2, 603, 605, 7, 80, 2, 2, 604, 606, 5, 94, 48, 2, 605,
	604, 3, 2, 2, 2, 605, 606, 3, 2, 2, 2, 606, 607, 3, 2, 2, 2, 607, 608,
	7, 81, 2, 2, 608, 79, 3, 2, 2, 2, 609, 611, 7, 80, 2, 2, 610, 612, 5, 90,
	46, 2, 611, 610, 3, 2, 2, 2, 611, 612, 3, 2, 2, 2, 612, 613, 3, 2, 2, 2,
	613, 614, 7, 81, 2, 2, 614, 615, 7, 68, 2, 2, 615, 616, 5, 86, 44, 2, 616,
	618, 7, 80, 2, 2, 617, 619, 5, 94, 48, 2, 618, 617, 3, 2, 2, 2, 618, 619,
	3, 2, 2, 2, 619, 620, 3, 2, 2, 2, 620, 621, 7, 81, 2, 2, 621, 81, 3, 2,
	2, 2, 622, 624, 7, 80, 2, 2, 623, 625, 5, 90, 46, 2, 624, 623, 3, 2, 2,
	2, 624, 625, 3, 2, 2, 2, 625, 626, 3, 2, 2, 2, 626, 627, 7, 81, 2, 2, 627,
	628, 7, 68, 2, 2, 628, 629, 5, 88, 45, 2, 629, 631, 7, 80, 2, 2, 630, 632,
	5, 94, 48, 2, 631, 630, 3, 2, 2, 2, 631, 632, 3, 2, 2, 2, 632, 633, 3,
	2, 2, 2, 633, 634, 7, 81, 2, 2, 634, 83, 3, 2, 2, 2, 635, 636, 7, 108,
	2, 2, 636, 637, 7, 85, 2, 2, 637, 638, 7, 106, 2, 2, 638, 85, 3, 2, 2,
	2, 639, 640, 7, 108, 2, 2, 640, 641, 7, 85, 2, 2, 641, 642, 7, 106, 2,
	2, 642, 87, 3, 2, 2, 2, 643, 644, 7, 108, 2, 2, 644, 645, 7, 85, 2, 2,
	645, 646, 7, 106, 2, 2, 646, 89, 3, 2, 2, 2, 647, 652, 5, 92, 47, 2, 648,
	649, 7, 86, 2, 2, 649, 651, 5, 92, 47, 2, 650, 648, 3, 2, 2, 2, 651, 654,
	3, 2, 2, 2, 652, 650, 3, 2, 2, 2, 652, 653, 3, 2, 2, 2, 653, 91, 3, 2,
	2, 2, 654, 652, 3, 2, 2, 2, 655, 659, 5, 196, 99, 2, 656, 659, 5, 194,
	98, 2, 657, 659, 5, 202, 102, 2, 658, 655, 3, 2, 2, 2, 658, 656, 3, 2,
	2, 2, 658, 657, 3, 2, 2, 2, 659, 93, 3, 2, 2, 2, 660, 665, 5, 96, 49, 2,
	661, 662, 7, 86, 2, 2, 662, 664, 5, 96, 49, 2, 663, 661, 3, 2, 2, 2, 664,
	667, 3, 2, 2, 2, 665, 663, 3, 2, 2, 2, 665, 666, 3, 2, 2, 2, 666, 95, 3,
	2, 2, 2, 667, 665, 3, 2, 2, 2, 668, 673, 5, 196, 99, 2, 669, 673, 5, 194,
	98, 2, 670, 673, 5, 204, 103, 2, 671, 673, 5, 202, 102, 2, 672, 668, 3,
	2, 2, 2, 672, 669, 3, 2, 2, 2, 672, 670, 3, 2, 2, 2, 672, 671, 3, 2, 2,
	2, 673, 97, 3, 2, 2, 2, 674, 681, 5, 100, 51, 2, 675, 681, 5, 102, 52,
	2, 676, 681, 5, 104, 53, 2, 677, 681, 5, 106, 54, 2, 678, 681, 5, 108,
	55, 2, 679, 681, 5, 110, 56, 2, 680, 674, 3, 2, 2, 2, 680, 675, 3, 2, 2,
	2, 680, 676, 3, 2, 2, 2, 680, 677, 3, 2, 2, 2, 680, 678, 3, 2, 2, 2, 680,
	679, 3, 2, 2, 2, 681, 99, 3, 2, 2, 2, 682, 683, 7, 80, 2, 2, 683, 684,
	5, 112, 57, 2, 684, 685, 7, 81, 2, 2, 685, 686, 7, 68, 2, 2, 686, 687,
	7, 30, 2, 2, 687, 688, 7, 80, 2, 2, 688, 689, 7, 81, 2, 2, 689, 101, 3,
	2, 2, 2, 690, 691, 7, 80, 2, 2, 691, 692, 7, 81, 2, 2, 692, 693, 7, 68,
	2, 2, 693, 694, 7, 31, 2, 2, 694, 695, 7, 80, 2, 2, 695, 696, 5, 112, 57,
	2, 696, 697, 7, 81, 2, 2, 697, 103, 3, 2, 2, 2, 698, 699, 7, 28, 2, 2,
	699, 700, 7, 33, 2, 2, 700, 701, 7, 76, 2, 2, 701, 702, 5, 114, 58, 2,
	702, 703, 7, 86, 2, 2, 703, 704, 5, 116, 59, 2, 704, 705, 7, 86, 2, 2,
	705, 706, 5, 118, 60, 2, 706, 707, 7, 77, 2, 2, 707, 708, 7, 84, 2, 2,
	708, 709, 7, 29, 2, 2, 709, 710, 5, 112, 57, 2, 710, 105, 3, 2, 2, 2, 711,
	712, 7, 28, 2, 2, 712, 713, 7, 32, 2, 2, 713, 714, 7, 76, 2, 2, 714, 715,
	5, 120, 61, 2, 715, 716, 7, 86, 2, 2, 716, 717, 5, 122, 62, 2, 717, 718,
	7, 86, 2, 2, 718, 719, 5, 124, 63, 2, 719, 720, 7, 86, 2, 2, 720, 721,
	5, 126, 64, 2, 721, 722, 7, 86, 2, 2, 722, 723, 5, 128, 65, 2, 723, 724,
	7, 86, 2, 2, 724, 725, 5, 130, 66, 2, 725, 726, 7, 86, 2, 2, 726, 727,
	5, 116, 59, 2, 727, 728, 7, 86, 2, 2, 728, 729, 5, 118, 60, 2, 729, 730,
	7, 77, 2, 2, 730, 731, 7, 84, 2, 2, 731, 732, 7, 29, 2, 2, 732, 733, 5,
	112, 57, 2, 733, 107, 3, 2, 2, 2, 734, 735, 7, 28, 2, 2, 735, 736, 7, 35,
	2, 2, 736, 737, 7, 76, 2, 2, 737, 738, 5, 132, 67, 2, 738, 739, 7, 86,
	2, 2, 739, 740, 5, 134, 68, 2, 740, 741, 7, 86, 2, 2, 741, 742, 5, 116,
	59, 2, 742, 743, 7, 86, 2, 2, 743, 744, 5, 118, 60, 2, 744, 745, 7, 77,
	2, 2, 745, 746, 7, 84, 2, 2, 746, 747, 7, 29, 2, 2, 747, 748, 5, 112, 57,
	2, 748, 109, 3, 2, 2, 2, 749, 750, 7, 28, 2, 2, 750, 751, 7, 34, 2, 2,
	751, 752, 7, 76, 2, 2, 752, 753, 7, 77, 2, 2, 753, 754, 7, 84, 2, 2, 754,
	755, 7, 29, 2, 2, 755, 756, 5, 112, 57, 2, 756, 111, 3, 2, 2, 2, 757, 760,
	5, 196, 99, 2, 758, 760, 5, 202, 102, 2, 759, 757, 3, 2, 2, 2, 759, 758,
	3, 2, 2, 2, 760, 113, 3, 2, 2, 2, 761, 765, 5, 196, 99, 2, 762, 765, 5,
	202, 102, 2, 763, 765, 7, 95, 2, 2, 764, 761, 3, 2, 2, 2, 764, 762, 3,
	2, 2, 2, 764, 763, 3, 2, 2, 2, 765, 115, 3, 2, 2, 2, 766, 767, 7, 108,
	2, 2, 767, 117, 3, 2, 2, 2, 768, 771, 5, 196, 99, 2, 769, 771, 7, 3, 2,
	2, 770, 768, 3, 2, 2, 2, 770, 769, 3, 2, 2, 2, 771, 119, 3, 2, 2, 2, 772,
	776, 5, 196, 99, 2, 773, 776, 5, 202, 102, 2, 774, 776, 7, 95, 2, 2, 775,
	772, 3, 2, 2, 2, 775, 773, 3, 2, 2, 2, 775, 774, 3, 2, 2, 2, 776, 121,
	3, 2, 2, 2, 777, 781, 5, 196, 99, 2, 778, 781, 5, 202, 102, 2, 779, 781,
	7, 95, 2, 2, 780, 777, 3, 2, 2, 2, 780, 778, 3, 2, 2, 2, 780, 779, 3, 2,
	2, 2, 781, 123, 3, 2, 2, 2, 782, 786, 5, 196, 99, 2, 783, 786, 5, 202,
	102, 2, 784, 786, 7, 95, 2, 2, 785, 782, 3, 2, 2, 2, 785, 783, 3, 2, 2,
	2, 785, 784, 3, 2, 2, 2, 786, 125, 3, 2, 2, 2, 787, 791, 5, 196, 99, 2,
	788, 791, 5, 202, 102, 2, 789, 791, 7, 95, 2, 2, 790, 787, 3, 2, 2, 2,
	790, 788, 3, 2, 2, 2, 790, 789, 3, 2, 2, 2, 791, 127, 3, 2, 2, 2, 792,
	796, 5, 196, 99, 2, 793, 796, 5, 202, 102, 2, 794, 796, 7, 95, 2, 2, 795,
	792, 3, 2, 2, 2, 795, 793, 3, 2, 2, 2, 795, 794, 3, 2, 2, 2, 796, 129,
	3, 2, 2, 2, 797, 801, 5, 196, 99, 2, 798, 801, 5, 202, 102, 2, 799, 801,
	7, 95, 2, 2, 800, 797, 3, 2, 2, 2, 800, 798, 3, 2, 2, 2, 800, 799, 3, 2,
	2, 2, 801, 131, 3, 2, 2, 2, 802, 806, 5, 196, 99, 2, 803, 806, 5, 202,
	102, 2, 804, 806, 7, 95, 2, 2, 805, 802, 3, 2, 2, 2, 805, 803, 3, 2, 2,
	2, 805, 804, 3, 2, 2, 2, 806, 133, 3, 2, 2, 2, 807, 811, 5, 196, 99, 2,
	808, 811, 5, 202, 102, 2, 809, 811, 7, 95, 2, 2, 810, 807, 3, 2, 2, 2,
	810, 808, 3, 2, 2, 2, 810, 809, 3, 2, 2, 2, 811, 135, 3, 2, 2, 2, 812,
	816, 5, 138, 70, 2, 813, 816, 5, 140, 71, 2, 814, 816, 5, 142, 72, 2, 815,
	812, 3, 2, 2, 2, 815, 813, 3, 2, 2, 2, 815, 814, 3, 2, 2, 2, 816, 137,
	3, 2, 2, 2, 817, 818, 5, 194, 98, 2, 818, 819, 7, 68, 2, 2, 819, 820, 7,
	5, 2, 2, 820, 821, 5, 194, 98, 2, 821, 139, 3, 2, 2, 2, 822, 823, 5, 194,
	98, 2, 823, 824, 7, 68, 2, 2, 824, 825, 9, 7, 2, 2, 825, 826, 5, 194, 98,
	2, 826, 827, 7, 21, 2, 2, 827, 828, 5, 194, 98, 2, 828, 141, 3, 2, 2, 2,
	829, 830, 5, 194, 98, 2, 830, 831, 7, 68, 2, 2, 831, 832, 5, 194, 98, 2,
	832, 833, 7, 92, 2, 2, 833, 834, 5, 194, 98, 2, 834, 143, 3, 2, 2, 2, 835,
	842, 5, 146, 74, 2, 836, 842, 5, 152, 77, 2, 837, 842, 5, 154, 78, 2, 838,
	842, 5, 156, 79, 2, 839, 842, 5, 158, 80, 2, 840, 842, 5, 160, 81, 2, 841,
	835, 3, 2, 2, 2, 841, 836, 3, 2, 2, 2, 841, 837, 3, 2, 2, 2, 841, 838,
	3, 2, 2, 2, 841, 839, 3, 2, 2, 2, 841, 840, 3, 2, 2, 2, 842, 145, 3, 2,
	2, 2, 843, 844, 7, 56, 2, 2, 844, 845, 7, 57, 2, 2, 845, 846, 5, 166, 84,
	2, 846, 851, 7, 115, 2, 2, 847, 848, 5, 148, 75, 2, 848, 849, 5, 150, 76,
	2, 849, 850, 7, 115, 2, 2, 850, 852, 3, 2, 2, 2, 851, 847, 3, 2, 2, 2,
	852, 853, 3, 2, 2, 2, 853, 851, 3, 2, 2, 2, 853, 854, 3, 2, 2, 2, 854,
	855, 3, 2, 2, 2, 855, 856, 7, 58, 2, 2, 856, 147, 3, 2, 2, 2, 857, 858,
	9, 8, 2, 2, 858, 149, 3, 2, 2, 2, 859, 868, 7, 61, 2, 2, 860, 868, 7, 62,
	2, 2, 861, 868, 7, 63, 2, 2, 862, 868, 7, 64, 2, 2, 863, 868, 7, 65, 2,
	2, 864, 868, 7, 66, 2, 2, 865, 868, 5, 166, 84, 2, 866, 868, 5, 212, 107,
	2, 867, 859, 3, 2, 2, 2, 867, 860, 3, 2, 2, 2, 867, 861, 3, 2, 2, 2, 867,
	862, 3, 2, 2, 2, 867, 863, 3, 2, 2, 2, 867, 864, 3, 2, 2, 2, 867, 865,
	3, 2, 2, 2, 867, 866, 3, 2, 2, 2, 868, 151, 3, 2, 2, 2, 869, 870, 5, 164,
	83, 2, 870, 871, 7, 59, 2, 2, 871, 872, 5, 166, 84, 2, 872, 153, 3, 2,
	2, 2, 873, 874, 7, 60, 2, 2, 874, 875, 7, 80, 2, 2, 875, 876, 5, 168, 85,
	2, 876, 877, 7, 81, 2, 2, 877, 878, 7, 29, 2, 2, 878, 881, 5, 164, 83,
	2, 879, 880, 9, 4, 2, 2, 880, 882, 5, 148, 75, 2, 881, 879, 3, 2, 2, 2,
	881, 882, 3, 2, 2, 2, 882, 155, 3, 2, 2, 2, 883, 884, 7, 46, 2, 2, 884,
	885, 7, 80, 2, 2, 885, 886, 5, 172, 87, 2, 886, 887, 7, 81, 2, 2, 887,
	888, 7, 47, 2, 2, 888, 889, 5, 164, 83, 2, 889, 890, 7, 48, 2, 2, 890,
	894, 7, 115, 2, 2, 891, 893, 5, 4, 3, 2, 892, 891, 3, 2, 2, 2, 893, 896,
	3, 2, 2, 2, 894, 892, 3, 2, 2, 2, 894, 895, 3, 2, 2, 2, 895, 904, 3, 2,
	2, 2, 896, 894, 3, 2, 2, 2, 897, 901, 5, 188, 95, 2, 898, 900, 5, 4, 3,
	2, 899, 898, 3, 2, 2, 2, 900, 903, 3, 2, 2, 2, 901, 899, 3, 2, 2, 2, 901,
	902, 3, 2, 2, 2, 902, 905, 3, 2, 2, 2, 903, 901, 3, 2, 2, 2, 904, 897,
	3, 2, 2, 2, 904, 905, 3, 2, 2, 2, 905, 906, 3, 2, 2, 2, 906, 907, 7, 49,
	2, 2, 907, 157, 3, 2, 2, 2, 908, 909, 5, 164, 83, 2, 909, 910, 7, 68, 2,
	2, 910, 911, 5, 164, 83, 2, 911, 912, 9, 4, 2, 2, 912, 913, 5, 148, 75,
	2, 913, 159, 3, 2, 2, 2, 914, 915, 5, 164, 83, 2, 915, 916, 7, 68, 2, 2,
	916, 917, 5, 164, 83, 2, 917, 918, 7, 13, 2, 2, 918, 919, 5, 162, 82, 2,
	919, 161, 3, 2, 2, 2, 920, 921, 5, 148, 75, 2, 921, 922, 5, 46, 24, 2,
	922, 923, 5, 184, 93, 2, 923, 928, 3, 2, 2, 2, 924, 925, 9, 9, 2, 2, 925,
	927, 5, 162, 82, 2, 926, 924, 3, 2, 2, 2, 927, 930, 3, 2, 2, 2, 928, 926,
	3, 2, 2, 2, 928, 929, 3, 2, 2, 2, 929, 163, 3, 2, 2, 2, 930, 928, 3, 2,
	2, 2, 931, 932, 7, 78, 2, 2, 932, 933, 9, 8, 2, 2, 933, 934, 7, 79, 2,
	2, 934, 165, 3, 2, 2, 2, 935, 941, 7, 105, 2, 2, 936, 941, 7, 109, 2, 2,
	937, 938, 7, 107, 2, 2, 938, 939, 7, 83, 2, 2, 939, 941, 7, 105, 2, 2,
	940, 935, 3, 2, 2, 2, 940, 936, 3, 2, 2, 2, 940, 937, 3, 2, 2, 2, 941,
	167, 3, 2, 2, 2, 942, 947, 5, 170, 86, 2, 943, 944, 7, 86, 2, 2, 944, 946,
	5, 170, 86, 2, 945, 943, 3, 2, 2, 2, 946, 949, 3, 2, 2, 2, 947, 945, 3,
	2, 2, 2, 947, 948, 3, 2, 2, 2, 948, 169, 3, 2, 2, 2, 949, 947, 3, 2, 2,
	2, 950, 956, 5, 196, 99, 2, 951, 956, 5, 194, 98, 2, 952, 956, 5, 204,
	103, 2, 953, 956, 5, 202, 102, 2, 954, 956, 5, 164, 83, 2, 955, 950, 3,
	2, 2, 2, 955, 951, 3, 2, 2, 2, 955, 952, 3, 2, 2, 2, 955, 953, 3, 2, 2,
	2, 955, 954, 3, 2, 2, 2, 956, 171, 3, 2, 2, 2, 957, 960, 5, 196, 99, 2,
	958, 960, 5, 164, 83, 2, 959, 957, 3, 2, 2, 2, 959, 958, 3, 2, 2, 2, 960,
	968, 3, 2, 2, 2, 961, 964, 7, 86, 2, 2, 962, 965, 5, 196, 99, 2, 963, 965,
	5, 164, 83, 2, 964, 962, 3, 2, 2, 2, 964, 963, 3, 2, 2, 2, 965, 967, 3,
	2, 2, 2, 966, 961, 3, 2, 2, 2, 967, 970, 3, 2, 2, 2, 968, 966, 3, 2, 2,
	2, 968, 969, 3, 2, 2, 2, 969, 173, 3, 2, 2, 2, 970, 968, 3, 2, 2, 2, 971,
	974, 7, 38, 2, 2, 972, 975, 5, 196, 99, 2, 973, 975, 5, 202, 102, 2, 974,
	972, 3, 2, 2, 2, 974, 973, 3, 2, 2, 2, 975, 976, 3, 2, 2, 2, 976, 986,
	7, 115, 2, 2, 977, 978, 7, 39, 2, 2, 978, 979, 5, 204, 103, 2, 979, 983,
	7, 115, 2, 2, 980, 982, 5, 4, 3, 2, 981, 980, 3, 2, 2, 2, 982, 985, 3,
	2, 2, 2, 983, 981, 3, 2, 2, 2, 983, 984, 3, 2, 2, 2, 984, 987, 3, 2, 2,
	2, 985, 983, 3, 2, 2, 2, 986, 977, 3, 2, 2, 2, 987, 988, 3, 2, 2, 2, 988,
	986, 3, 2, 2, 2, 988, 989, 3, 2, 2, 2, 989, 997, 3, 2, 2, 2, 990, 991,
	7, 40, 2, 2, 991, 993, 7, 115, 2, 2, 992, 994, 5, 4, 3, 2, 993, 992, 3,
	2, 2, 2, 994, 995, 3, 2, 2, 2, 995, 993, 3, 2, 2, 2, 995, 996, 3, 2, 2,
	2, 996, 998, 3, 2, 2, 2, 997, 990, 3, 2, 2, 2, 997, 998, 3, 2, 2, 2, 998,
	999, 3, 2, 2, 2, 999, 1000, 7, 41, 2, 2, 1000, 175, 3, 2, 2, 2, 1001, 1007,
	7, 42, 2, 2, 1002, 1008, 5, 178, 90, 2, 1003, 1004, 7, 76, 2, 2, 1004,
	1005, 5, 178, 90, 2, 1005, 1006, 7, 77, 2, 2, 1006, 1008, 3, 2, 2, 2, 1007,
	1002, 3, 2, 2, 2, 1007, 1003, 3, 2, 2, 2, 1008, 1009, 3, 2, 2, 2, 1009,
	1010, 7, 43, 2, 2, 1010, 1012, 7, 115, 2, 2, 1011, 1013, 5, 4, 3, 2, 1012,
	1011, 3, 2, 2, 2, 1013, 1014, 3, 2, 2, 2, 1014, 1012, 3, 2, 2, 2, 1014,
	1015, 3, 2, 2, 2, 1015, 1023, 3, 2, 2, 2, 1016, 1017, 7, 44, 2, 2, 1017,
	1019, 7, 115, 2, 2, 1018, 1020, 5, 4, 3, 2, 1019, 1018, 3, 2, 2, 2, 1020,
	1021, 3, 2, 2, 2, 1021, 1019, 3, 2, 2, 2, 1021, 1022, 3, 2, 2, 2, 1022,
	1024, 3, 2, 2, 2, 1023, 1016, 3, 2, 2, 2, 1023, 1024, 3, 2, 2, 2, 1024,
	1025, 3, 2, 2, 2, 1025, 1026, 7, 45, 2, 2, 1026, 177, 3, 2, 2, 2, 1027,
	1029, 9, 10, 2, 2, 1028, 1027, 3, 2, 2, 2, 1028, 1029, 3, 2, 2, 2, 1029,
	1030, 3, 2, 2, 2, 1030, 1038, 5, 180, 91, 2, 1031, 1033, 9, 9, 2, 2, 1032,
	1034, 9, 10, 2, 2, 1033, 1032, 3, 2, 2, 2, 1033, 1034, 3, 2, 2, 2, 1034,
	1035, 3, 2, 2, 2, 1035, 1037, 5, 180, 91, 2, 1036, 1031, 3, 2, 2, 2, 1037,
	1040, 3, 2, 2, 2, 1038, 1036, 3, 2, 2, 2, 1038, 1039, 3, 2, 2, 2, 1039,
	179, 3, 2, 2, 2, 1040, 1038, 3, 2, 2, 2, 1041, 1043, 9, 10, 2, 2, 1042,
	1041, 3, 2, 2, 2, 1042, 1043, 3, 2, 2, 2, 1043, 1044, 3, 2, 2, 2, 1044,
	1052, 5, 182, 92, 2, 1045, 1047, 9, 9, 2, 2, 1046, 1048, 9, 10, 2, 2, 1047,
	1046, 3, 2, 2, 2, 1047, 1048, 3, 2, 2, 2, 1048, 1049, 3, 2, 2, 2, 1049,
	1051, 5, 182, 92, 2, 1050, 1045, 3, 2, 2, 2, 1051, 1054, 3, 2, 2, 2, 1052,
	1050, 3, 2, 2, 2, 1052, 1053, 3, 2, 2, 2, 1053, 1073, 3, 2, 2, 2, 1054,
	1052, 3, 2, 2, 2, 1055, 1057, 7, 76, 2, 2, 1056, 1058, 9, 10, 2, 2, 1057,
	1056, 3, 2, 2, 2, 1057, 1058, 3, 2, 2, 2, 1058, 1059, 3, 2, 2, 2, 1059,
	1067, 5, 182, 92, 2, 1060, 1062, 9, 9, 2, 2, 1061, 1063, 9, 10, 2, 2, 1062,
	1061, 3, 2, 2, 2, 1062, 1063, 3, 2, 2, 2, 1063, 1064, 3, 2, 2, 2, 1064,
	1066, 5, 182, 92, 2, 1065, 1060, 3, 2, 2, 2, 1066, 1069, 3, 2, 2, 2, 1067,
	1065, 3, 2, 2, 2, 1067, 1068, 3, 2, 2, 2, 1068, 1070, 3, 2, 2, 2, 1069,
	1067, 3, 2, 2, 2, 1070, 1071, 7, 77, 2, 2, 1071, 1073, 3, 2, 2, 2, 1072,
	1042, 3, 2, 2, 2, 1072, 1055, 3, 2, 2, 2, 1073, 181, 3, 2, 2, 2, 1074,
	1076, 7, 76, 2, 2, 1075, 1074, 3, 2, 2, 2, 1075, 1076, 3, 2, 2, 2, 1076,
	1086, 3, 2, 2, 2, 1077, 1087, 5, 196, 99, 2, 1078, 1079, 5, 184, 93, 2,
	1079, 1080, 5, 46, 24, 2, 1080, 1081, 5, 184, 93, 2, 1081, 1087, 3, 2,
	2, 2, 1082, 1083, 5, 184, 93, 2, 1083, 1084, 5, 44, 23, 2, 1084, 1085,
	7, 8, 2, 2, 1085, 1087, 3, 2, 2, 2, 1086, 1077, 3, 2, 2, 2, 1086, 1078,
	3, 2, 2, 2, 1086, 1082, 3, 2, 2, 2, 1087, 1089, 3, 2, 2, 2, 1088, 1090,
	7, 77, 2, 2, 1089, 1088, 3, 2, 2, 2, 1089, 1090, 3, 2, 2, 2, 1090, 183,
	3, 2, 2, 2, 1091, 1099, 5, 196, 99, 2, 1092, 1099, 5, 202, 102, 2, 1093,
	1099, 5, 204, 103, 2, 1094, 1095, 7, 20, 2, 2, 1095, 1099, 5, 194, 98,
	2, 1096, 1099, 5, 22, 12, 2, 1097, 1099, 7, 3, 2, 2, 1098, 1091, 3, 2,
	2, 2, 1098, 1092, 3, 2, 2, 2, 1098, 1093, 3, 2, 2, 2, 1098, 1094, 3, 2,
	2, 2, 1098, 1096, 3, 2, 2, 2, 1098, 1097, 3, 2, 2, 2, 1099, 185, 3, 2,
	2, 2, 1100, 1101, 7, 46, 2, 2, 1101, 1102, 5, 196, 99, 2, 1102, 1103, 7,
	47, 2, 2, 1103, 1104, 5, 194, 98, 2, 1104, 1105, 7, 48, 2, 2, 1105, 1109,
	7, 115, 2, 2, 1106, 1108, 5, 4, 3, 2, 1107, 1106, 3, 2, 2, 2, 1108, 1111,
	3, 2, 2, 2, 1109, 1107, 3, 2, 2, 2, 1109, 1110, 3, 2, 2, 2, 1110, 1119,
	3, 2, 2, 2, 1111, 1109, 3, 2, 2, 2, 1112, 1116, 5, 188, 95, 2, 1113, 1115,
	5, 4, 3, 2, 1114, 1113, 3, 2, 2, 2, 1115, 1118, 3, 2, 2, 2, 1116, 1114,
	3, 2, 2, 2, 1116, 1117, 3, 2, 2, 2, 1117, 1120, 3, 2, 2, 2, 1118, 1116,
	3, 2, 2, 2, 1119, 1112, 3, 2, 2, 2, 1119, 1120, 3, 2, 2, 2, 1120, 1121,
	3, 2, 2, 2, 1121, 1122, 7, 49, 2, 2, 1122, 187, 3, 2, 2, 2, 1123, 1127,
	7, 50, 2, 2, 1124, 1125, 7, 51, 2, 2, 1125, 1127, 5, 178, 90, 2, 1126,
	1123, 3, 2, 2, 2, 1126, 1124, 3, 2, 2, 2, 1127, 1128, 3, 2, 2, 2, 1128,
	1129, 7, 115, 2, 2, 1129, 189, 3, 2, 2, 2, 1130, 1131, 7, 52, 2, 2, 1131,
	1135, 7, 115, 2, 2, 1132, 1134, 5, 4, 3, 2, 1133, 1132, 3, 2, 2, 2, 1134,
	1137, 3, 2, 2, 2, 1135, 1133, 3, 2, 2, 2, 1135, 1136, 3, 2, 2, 2, 1136,
	1138, 3, 2, 2, 2, 1137, 1135, 3, 2, 2, 2, 1138, 1143, 5, 188, 95, 2, 1139,
	1142, 5, 188, 95, 2, 1140, 1142, 5, 4, 3, 2, 1141, 1139, 3, 2, 2, 2, 1141,
	1140, 3, 2, 2, 2, 1142, 1145, 3, 2, 2, 2, 1143, 1141, 3, 2, 2, 2, 1143,
	1144, 3, 2, 2, 2, 1144, 1146, 3, 2, 2, 2, 1145, 1143, 3, 2, 2, 2, 1146,
	1147, 7, 53, 2, 2, 1147, 191, 3, 2, 2, 2, 1148, 1149, 7, 54, 2, 2, 1149,
	1153, 7, 115, 2, 2, 1150, 1152, 11, 2, 2, 2, 1151, 1150, 3, 2, 2, 2, 1152,
	1155, 3, 2, 2, 2, 1153, 1154, 3, 2, 2, 2, 1153, 1151, 3, 2, 2, 2, 1154,
	1156, 3, 2, 2, 2, 1155, 1153, 3, 2, 2, 2, 1156, 1157, 7, 55, 2, 2, 1157,
	193, 3, 2, 2, 2, 1158, 1159, 7, 78, 2, 2, 1159, 1160, 5, 196, 99, 2, 1160,
	1161, 7, 79, 2, 2, 1161, 195, 3, 2, 2, 2, 1162, 1163, 9, 8, 2, 2, 1163,
	197, 3, 2, 2, 2, 1164, 1165, 7, 104, 2, 2, 1165, 199, 3, 2, 2, 2, 1166,
	1167, 9, 11, 2, 2, 1167, 201, 3, 2, 2, 2, 1168, 1171, 5, 196, 99, 2, 1169,
	1171, 7, 3, 2, 2, 1170, 1168, 3, 2, 2, 2, 1170, 1169, 3, 2, 2, 2, 1171,
	1172, 3, 2, 2, 2, 1172, 1173, 7, 83, 2, 2, 1173, 1174, 5, 200, 101, 2,
	1174, 203, 3, 2, 2, 2, 1175, 1183, 7, 95, 2, 2, 1176, 1183, 7, 96, 2, 2,
	1177, 1183, 7, 98, 2, 2, 1178, 1183, 5, 206, 104, 2, 1179, 1183, 5, 208,
	105, 2, 1180, 1183, 7, 93, 2, 2, 1181, 1183, 7, 94, 2, 2, 1182, 1175, 3,
	2, 2, 2, 1182, 1176, 3, 2, 2, 2, 1182, 1177, 3, 2, 2, 2, 1182, 1178, 3,
	2, 2, 2, 1182, 1179, 3, 2, 2, 2, 1182, 1180, 3, 2, 2, 2, 1182, 1181, 3,
	2, 2, 2, 1183, 205, 3, 2, 2, 2, 1184, 1189, 7, 99, 2, 2, 1185, 1189, 7,
	100, 2, 2, 1186, 1187, 7, 101, 2, 2, 1187, 1189, 7, 101, 2, 2, 1188, 1184,
	3, 2, 2, 2, 1188, 1185, 3, 2, 2, 2, 1188, 1186, 3, 2, 2, 2, 1189, 207,
	3, 2, 2, 2, 1190, 1191, 9, 12, 2, 2, 1191, 209, 3, 2, 2, 2, 1192, 1193,
	5, 196, 99, 2, 1193, 1194, 7, 83, 2, 2, 1194, 1195, 7, 105, 2, 2, 1195,
	211, 3, 2, 2, 2, 1196, 1197, 7, 104, 2, 2, 1197, 1198, 7, 83, 2, 2, 1198,
	1199, 7, 107, 2, 2, 1199, 213, 3, 2, 2, 2, 134, 217, 224, 229, 244, 250,
	257, 261, 266, 270, 277, 282, 286, 293, 302, 309, 314, 320, 326, 330, 334,
	339, 344, 351, 363, 368, 372, 379, 383, 390, 393, 400, 404, 412, 418, 427,
	434, 437, 448, 452, 458, 464, 468, 472, 478, 483, 488, 493, 499, 507, 509,
	514, 524, 529, 541, 547, 554, 556, 562, 580, 589, 594, 598, 605, 611, 618,
	624, 631, 652, 658, 665, 672, 680, 759, 764, 770, 775, 780, 785, 790, 795,
	800, 805, 810, 815, 841, 853, 867, 881, 894, 901, 904, 928, 940, 947, 955,
	959, 964, 968, 974, 983, 988, 995, 997, 1007, 1014, 1021, 1023, 1028, 1033,
	1038, 1042, 1047, 1052, 1057, 1062, 1067, 1072, 1075, 1086, 1089, 1098,
	1109, 1116, 1119, 1126, 1135, 1141, 1143, 1153, 1170, 1182, 1188,
}
var literalNames = []string{
	"", "'this'", "'create'", "'unique'", "'with'", "'delete'", "'UNDEFINED'",
	"'find-only'", "'find-one'", "'find-all'", "'find'", "'where'", "'equals'",
	"'not-equals'", "'less-than'", "'greater-than'", "'reverse ordered by'",
	"'ordered by'", "'countof'", "'and'", "'or'", "'not'", "'link'", "'using'",
	"'unlink'", "'->'", "'%generate'", "'to'", "'Create_Timer'", "'Delete_Timer'",
	"'TIM10:Set_Absolute_Timer'", "'TIM1:Set_Timer'", "'TIM2:Reset_Timer'",
	"'TIM3:Set_Chimer'", "'current-date'", "'current-time'", "'switch'", "'case'",
	"'default'", "'endswitch'", "'if'", "'then'", "'else'", "'endif'", "'for'",
	"'in'", "'do'", "'endfor'", "'break'", "'breakif'", "'loop'", "'endloop'",
	"'$INLINE'", "'$ENDINLINE'", "'define'", "'structure'", "'enddefine'",
	"'is'", "'append'", "'Integer'", "'Real'", "'Boolean'", "'Text'", "'Date'",
	"'Time_of_Day'", "'!='", "'='", "'<='", "'>='", "'<'", "'>'", "'&'", "'|'",
	"'!'", "'('", "')'", "'{'", "'}'", "'['", "']'", "'_'", "'.'", "';'", "':'",
	"','", "'#'", "'\\'", "'union-of'", "'disunion-of'", "'intersection-of'",
	"'not-in'", "", "", "", "", "", "", "", "", "'\"'", "", "'instance_id'",
}
var symbolicNames = []string{
	"", "THIS", "CREATE", "UNIQUE", "WITH", "DELETE", "UNDEFINED", "FIND_ONLY",
	"FIND_ONE", "FIND_ALL", "FIND", "WHERE", "EQUALS", "NOT_EQUALS", "LESS_THAN",
	"GREATER_THAN", "REVERSE_ORDERED_BY", "ORDERED_BY", "COUNTOF", "AND", "OR",
	"NOT", "LINK", "USING", "UNLINK", "RELATIONSHIP_TRAVERSAL", "GENERATE",
	"TO", "CREATE_TIMER", "DELETE_TIMER", "TIM10", "TIM1", "TIM2", "TIM3",
	"CURRENT_DATE", "CURRENT_TIME", "SWITCH", "CASE", "DEFAULT", "ENDSWITCH",
	"IF", "THEN", "ELSE", "ENDIF", "FOR", "IN", "DO", "ENDFOR", "BREAK", "BREAKIF",
	"LOOP", "ENDLOOP", "INLINE", "END_INLINE", "DEFINE", "STRUCTURE", "ENDDEFINE",
	"IS", "APPEND", "INTEGER", "REAL", "BOOLEAN", "TEXT", "DATE", "TIME", "NEQ",
	"EQ", "LTE", "GTE", "LT", "GT", "LOGICAL_AND", "LOGICAL_OR", "LOGICAL_NOT",
	"L_PAREN", "R_PAREN", "L_CURLY", "R_CURLY", "L_SQUARE", "R_SQUARE", "UNDERSCORE",
	"DOT", "SEMI_COLON", "COLON", "COMMA", "HASH", "BACKSLASH", "UNION_OF",
	"DISUNION_OF", "INTERSECTION_OF", "NOT_IN", "DATE_VALUE", "TIME_VALUE",
	"INTEGER_VALUE", "REAL_VALUE", "ARITHMETIC_OPERATOR", "BOOLEAN_VALUE",
	"LOWERCASE_TEXT", "OTHER_TEXT", "QUOTE", "R_NUMBER", "INSTANCE_ID", "UPPERCASE_ID",
	"LOWERCASE_ID", "LEADING_UPPERCASE_ID", "LEADING_FIRST_UPPERCASE_ID", "UPPERCASE_NUMBER_ID",
	"LOWERCASE_NUMBER_ID", "UPPERCASE_OR_NUMBER_ID", "NATIVE_LANGUAGE", "CONTINUATION",
	"WHITESPACE", "COMMENT", "NEWLINE", "OTHER",
}

var ruleNames = []string{
	"asl", "statement", "simple_statement", "sequential_logic_statement", "assignment_statement",
	"constant_assignment", "date_time_assignment", "variable_assignment", "object_attribute_assignment",
	"arithmetic_assignment", "arithmetic_expression", "arithmetic_component",
	"countof_function", "create_statement", "attribute_assignments", "attribute_assignment",
	"delete_statement", "find_statement", "find_instance_statement", "find_set_statement",
	"object_condition", "equality_operator", "logical_operator", "relationship_navigation",
	"associative_relationship_navigation", "relationship_link", "relationship_unlink",
	"relationship_spec", "qualified_relationship", "relationship_role", "event_generation",
	"internal_event_generation", "external_event_generation", "event_specification",
	"external_event_specification", "event_parameters", "event_parameter",
	"operation_invocation", "object_operation", "domain_operation", "bridge_operation",
	"oo_specification", "do_specification", "bo_specification", "output_parameter_list",
	"output_parameter", "input_parameter_list", "input_parameter", "timer_operation",
	"timer_creation", "timer_deletion", "set_relative_timer", "set_absolute_timer",
	"set_recurring_timer", "timer_reset", "timer_id", "time_to_fire", "return_event",
	"target_instance", "fire_year", "fire_month", "fire_date", "fire_hour",
	"fire_minute", "fire_second", "start_time", "period", "set_operation",
	"unique_set", "set_combination", "set_difference", "struct_statement",
	"struct_definition", "member_name", "member_type", "struct_instantiation",
	"struct_assembly", "struct_for_loop", "order_struct", "struct_subset",
	"struct_condition", "struct_", "struct_type", "value_list", "struct_value",
	"variable_list", "switch_statement", "if_statement", "logical_condition",
	"compound_logical_condition", "simple_logical_condition", "component",
	"for_loop", "break_statement", "loop_statement", "native_language_section",
	"set_variable", "variable", "object_name", "attribute", "object_attribute",
	"constant", "text_string", "enum_value", "structure_field", "user_defined_type",
}

type ASLParser struct {
	*antlr.BaseParser
}

// NewASLParser produces a new parser instance for the optional input antlr.TokenStream.
//
// The *ASLParser instance produced may be reused by calling the SetInputStream method.
// The initial parser configuration is expensive to construct, and the object is not thread-safe;
// however, if used within a Golang sync.Pool, the construction cost amortizes well and the
// objects can be used in a thread-safe manner.
func NewASLParser(input antlr.TokenStream) *ASLParser {
	this := new(ASLParser)
	deserializer := antlr.NewATNDeserializer(nil)
	deserializedATN := deserializer.DeserializeFromUInt16(parserATN)
	decisionToDFA := make([]*antlr.DFA, len(deserializedATN.DecisionToState))
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "ASL.g4"

	return this
}

// ASLParser tokens.
const (
	ASLParserEOF                        = antlr.TokenEOF
	ASLParserTHIS                       = 1
	ASLParserCREATE                     = 2
	ASLParserUNIQUE                     = 3
	ASLParserWITH                       = 4
	ASLParserDELETE                     = 5
	ASLParserUNDEFINED                  = 6
	ASLParserFIND_ONLY                  = 7
	ASLParserFIND_ONE                   = 8
	ASLParserFIND_ALL                   = 9
	ASLParserFIND                       = 10
	ASLParserWHERE                      = 11
	ASLParserEQUALS                     = 12
	ASLParserNOT_EQUALS                 = 13
	ASLParserLESS_THAN                  = 14
	ASLParserGREATER_THAN               = 15
	ASLParserREVERSE_ORDERED_BY         = 16
	ASLParserORDERED_BY                 = 17
	ASLParserCOUNTOF                    = 18
	ASLParserAND                        = 19
	ASLParserOR                         = 20
	ASLParserNOT                        = 21
	ASLParserLINK                       = 22
	ASLParserUSING                      = 23
	ASLParserUNLINK                     = 24
	ASLParserRELATIONSHIP_TRAVERSAL     = 25
	ASLParserGENERATE                   = 26
	ASLParserTO                         = 27
	ASLParserCREATE_TIMER               = 28
	ASLParserDELETE_TIMER               = 29
	ASLParserTIM10                      = 30
	ASLParserTIM1                       = 31
	ASLParserTIM2                       = 32
	ASLParserTIM3                       = 33
	ASLParserCURRENT_DATE               = 34
	ASLParserCURRENT_TIME               = 35
	ASLParserSWITCH                     = 36
	ASLParserCASE                       = 37
	ASLParserDEFAULT                    = 38
	ASLParserENDSWITCH                  = 39
	ASLParserIF                         = 40
	ASLParserTHEN                       = 41
	ASLParserELSE                       = 42
	ASLParserENDIF                      = 43
	ASLParserFOR                        = 44
	ASLParserIN                         = 45
	ASLParserDO                         = 46
	ASLParserENDFOR                     = 47
	ASLParserBREAK                      = 48
	ASLParserBREAKIF                    = 49
	ASLParserLOOP                       = 50
	ASLParserENDLOOP                    = 51
	ASLParserINLINE                     = 52
	ASLParserEND_INLINE                 = 53
	ASLParserDEFINE                     = 54
	ASLParserSTRUCTURE                  = 55
	ASLParserENDDEFINE                  = 56
	ASLParserIS                         = 57
	ASLParserAPPEND                     = 58
	ASLParserINTEGER                    = 59
	ASLParserREAL                       = 60
	ASLParserBOOLEAN                    = 61
	ASLParserTEXT                       = 62
	ASLParserDATE                       = 63
	ASLParserTIME                       = 64
	ASLParserNEQ                        = 65
	ASLParserEQ                         = 66
	ASLParserLTE                        = 67
	ASLParserGTE                        = 68
	ASLParserLT                         = 69
	ASLParserGT                         = 70
	ASLParserLOGICAL_AND                = 71
	ASLParserLOGICAL_OR                 = 72
	ASLParserLOGICAL_NOT                = 73
	ASLParserL_PAREN                    = 74
	ASLParserR_PAREN                    = 75
	ASLParserL_CURLY                    = 76
	ASLParserR_CURLY                    = 77
	ASLParserL_SQUARE                   = 78
	ASLParserR_SQUARE                   = 79
	ASLParserUNDERSCORE                 = 80
	ASLParserDOT                        = 81
	ASLParserSEMI_COLON                 = 82
	ASLParserCOLON                      = 83
	ASLParserCOMMA                      = 84
	ASLParserHASH                       = 85
	ASLParserBACKSLASH                  = 86
	ASLParserUNION_OF                   = 87
	ASLParserDISUNION_OF                = 88
	ASLParserINTERSECTION_OF            = 89
	ASLParserNOT_IN                     = 90
	ASLParserDATE_VALUE                 = 91
	ASLParserTIME_VALUE                 = 92
	ASLParserINTEGER_VALUE              = 93
	ASLParserREAL_VALUE                 = 94
	ASLParserARITHMETIC_OPERATOR        = 95
	ASLParserBOOLEAN_VALUE              = 96
	ASLParserLOWERCASE_TEXT             = 97
	ASLParserOTHER_TEXT                 = 98
	ASLParserQUOTE                      = 99
	ASLParserR_NUMBER                   = 100
	ASLParserINSTANCE_ID                = 101
	ASLParserUPPERCASE_ID               = 102
	ASLParserLOWERCASE_ID               = 103
	ASLParserLEADING_UPPERCASE_ID       = 104
	ASLParserLEADING_FIRST_UPPERCASE_ID = 105
	ASLParserUPPERCASE_NUMBER_ID        = 106
	ASLParserLOWERCASE_NUMBER_ID        = 107
	ASLParserUPPERCASE_OR_NUMBER_ID     = 108
	ASLParserNATIVE_LANGUAGE            = 109
	ASLParserCONTINUATION               = 110
	ASLParserWHITESPACE                 = 111
	ASLParserCOMMENT                    = 112
	ASLParserNEWLINE                    = 113
	ASLParserOTHER                      = 114
)

// ASLParser rules.
const (
	ASLParserRULE_asl                                 = 0
	ASLParserRULE_statement                           = 1
	ASLParserRULE_simple_statement                    = 2
	ASLParserRULE_sequential_logic_statement          = 3
	ASLParserRULE_assignment_statement                = 4
	ASLParserRULE_constant_assignment                 = 5
	ASLParserRULE_date_time_assignment                = 6
	ASLParserRULE_variable_assignment                 = 7
	ASLParserRULE_object_attribute_assignment         = 8
	ASLParserRULE_arithmetic_assignment               = 9
	ASLParserRULE_arithmetic_expression               = 10
	ASLParserRULE_arithmetic_component                = 11
	ASLParserRULE_countof_function                    = 12
	ASLParserRULE_create_statement                    = 13
	ASLParserRULE_attribute_assignments               = 14
	ASLParserRULE_attribute_assignment                = 15
	ASLParserRULE_delete_statement                    = 16
	ASLParserRULE_find_statement                      = 17
	ASLParserRULE_find_instance_statement             = 18
	ASLParserRULE_find_set_statement                  = 19
	ASLParserRULE_object_condition                    = 20
	ASLParserRULE_equality_operator                   = 21
	ASLParserRULE_logical_operator                    = 22
	ASLParserRULE_relationship_navigation             = 23
	ASLParserRULE_associative_relationship_navigation = 24
	ASLParserRULE_relationship_link                   = 25
	ASLParserRULE_relationship_unlink                 = 26
	ASLParserRULE_relationship_spec                   = 27
	ASLParserRULE_qualified_relationship              = 28
	ASLParserRULE_relationship_role                   = 29
	ASLParserRULE_event_generation                    = 30
	ASLParserRULE_internal_event_generation           = 31
	ASLParserRULE_external_event_generation           = 32
	ASLParserRULE_event_specification                 = 33
	ASLParserRULE_external_event_specification        = 34
	ASLParserRULE_event_parameters                    = 35
	ASLParserRULE_event_parameter                     = 36
	ASLParserRULE_operation_invocation                = 37
	ASLParserRULE_object_operation                    = 38
	ASLParserRULE_domain_operation                    = 39
	ASLParserRULE_bridge_operation                    = 40
	ASLParserRULE_oo_specification                    = 41
	ASLParserRULE_do_specification                    = 42
	ASLParserRULE_bo_specification                    = 43
	ASLParserRULE_output_parameter_list               = 44
	ASLParserRULE_output_parameter                    = 45
	ASLParserRULE_input_parameter_list                = 46
	ASLParserRULE_input_parameter                     = 47
	ASLParserRULE_timer_operation                     = 48
	ASLParserRULE_timer_creation                      = 49
	ASLParserRULE_timer_deletion                      = 50
	ASLParserRULE_set_relative_timer                  = 51
	ASLParserRULE_set_absolute_timer                  = 52
	ASLParserRULE_set_recurring_timer                 = 53
	ASLParserRULE_timer_reset                         = 54
	ASLParserRULE_timer_id                            = 55
	ASLParserRULE_time_to_fire                        = 56
	ASLParserRULE_return_event                        = 57
	ASLParserRULE_target_instance                     = 58
	ASLParserRULE_fire_year                           = 59
	ASLParserRULE_fire_month                          = 60
	ASLParserRULE_fire_date                           = 61
	ASLParserRULE_fire_hour                           = 62
	ASLParserRULE_fire_minute                         = 63
	ASLParserRULE_fire_second                         = 64
	ASLParserRULE_start_time                          = 65
	ASLParserRULE_period                              = 66
	ASLParserRULE_set_operation                       = 67
	ASLParserRULE_unique_set                          = 68
	ASLParserRULE_set_combination                     = 69
	ASLParserRULE_set_difference                      = 70
	ASLParserRULE_struct_statement                    = 71
	ASLParserRULE_struct_definition                   = 72
	ASLParserRULE_member_name                         = 73
	ASLParserRULE_member_type                         = 74
	ASLParserRULE_struct_instantiation                = 75
	ASLParserRULE_struct_assembly                     = 76
	ASLParserRULE_struct_for_loop                     = 77
	ASLParserRULE_order_struct                        = 78
	ASLParserRULE_struct_subset                       = 79
	ASLParserRULE_struct_condition                    = 80
	ASLParserRULE_struct_                             = 81
	ASLParserRULE_struct_type                         = 82
	ASLParserRULE_value_list                          = 83
	ASLParserRULE_struct_value                        = 84
	ASLParserRULE_variable_list                       = 85
	ASLParserRULE_switch_statement                    = 86
	ASLParserRULE_if_statement                        = 87
	ASLParserRULE_logical_condition                   = 88
	ASLParserRULE_compound_logical_condition          = 89
	ASLParserRULE_simple_logical_condition            = 90
	ASLParserRULE_component                           = 91
	ASLParserRULE_for_loop                            = 92
	ASLParserRULE_break_statement                     = 93
	ASLParserRULE_loop_statement                      = 94
	ASLParserRULE_native_language_section             = 95
	ASLParserRULE_set_variable                        = 96
	ASLParserRULE_variable                            = 97
	ASLParserRULE_object_name                         = 98
	ASLParserRULE_attribute                           = 99
	ASLParserRULE_object_attribute                    = 100
	ASLParserRULE_constant                            = 101
	ASLParserRULE_text_string                         = 102
	ASLParserRULE_enum_value                          = 103
	ASLParserRULE_structure_field                     = 104
	ASLParserRULE_user_defined_type                   = 105
)

// IAslContext is an interface to support dynamic dispatch.
type IAslContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAslContext differentiates from other interfaces.
	IsAslContext()
}

type AslContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAslContext() *AslContext {
	var p = new(AslContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_asl
	return p
}

func (*AslContext) IsAslContext() {}

func NewAslContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AslContext {
	var p = new(AslContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_asl

	return p
}

func (s *AslContext) GetParser() antlr.Parser { return s.parser }

func (s *AslContext) EOF() antlr.TerminalNode {
	return s.GetToken(ASLParserEOF, 0)
}

func (s *AslContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *AslContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *AslContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AslContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AslContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterAsl(s)
	}
}

func (s *AslContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitAsl(s)
	}
}

func (p *ASLParser) Asl() (localctx IAslContext) {
	this := p
	_ = this

	localctx = NewAslContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, ASLParserRULE_asl)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(213)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ASLParserTHIS)|(1<<ASLParserDELETE)|(1<<ASLParserLINK)|(1<<ASLParserUNLINK)|(1<<ASLParserGENERATE))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(ASLParserSWITCH-36))|(1<<(ASLParserIF-36))|(1<<(ASLParserFOR-36))|(1<<(ASLParserLOOP-36))|(1<<(ASLParserINLINE-36))|(1<<(ASLParserDEFINE-36))|(1<<(ASLParserAPPEND-36)))) != 0) || (((_la-76)&-(0x1f+1)) == 0 && ((1<<uint((_la-76)))&((1<<(ASLParserL_CURLY-76))|(1<<(ASLParserL_SQUARE-76))|(1<<(ASLParserLOWERCASE_ID-76))|(1<<(ASLParserLOWERCASE_NUMBER_ID-76)))) != 0) {
		{
			p.SetState(212)
			p.Statement()
		}

		p.SetState(215)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(217)
		p.Match(ASLParserEOF)
	}

	return localctx
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_statement
	return p
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) Simple_statement() ISimple_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimple_statementContext)
}

func (s *StatementContext) Sequential_logic_statement() ISequential_logic_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequential_logic_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISequential_logic_statementContext)
}

func (s *StatementContext) Native_language_section() INative_language_sectionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INative_language_sectionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INative_language_sectionContext)
}

func (s *StatementContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(ASLParserNEWLINE)
}

func (s *StatementContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(ASLParserNEWLINE, i)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterStatement(s)
	}
}

func (s *StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitStatement(s)
	}
}

func (p *ASLParser) Statement() (localctx IStatementContext) {
	this := p
	_ = this

	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, ASLParserRULE_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(222)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(219)
			p.Simple_statement()
		}

	case 2:
		{
			p.SetState(220)
			p.Sequential_logic_statement()
		}

	case 3:
		{
			p.SetState(221)
			p.Native_language_section()
		}

	}
	p.SetState(225)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == ASLParserNEWLINE {
		{
			p.SetState(224)
			p.Match(ASLParserNEWLINE)
		}

		p.SetState(227)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISimple_statementContext is an interface to support dynamic dispatch.
type ISimple_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimple_statementContext differentiates from other interfaces.
	IsSimple_statementContext()
}

type Simple_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimple_statementContext() *Simple_statementContext {
	var p = new(Simple_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_simple_statement
	return p
}

func (*Simple_statementContext) IsSimple_statementContext() {}

func NewSimple_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Simple_statementContext {
	var p = new(Simple_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_simple_statement

	return p
}

func (s *Simple_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Simple_statementContext) Assignment_statement() IAssignment_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignment_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignment_statementContext)
}

func (s *Simple_statementContext) Create_statement() ICreate_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICreate_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICreate_statementContext)
}

func (s *Simple_statementContext) Delete_statement() IDelete_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelete_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelete_statementContext)
}

func (s *Simple_statementContext) Find_statement() IFind_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFind_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFind_statementContext)
}

func (s *Simple_statementContext) Relationship_navigation() IRelationship_navigationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelationship_navigationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRelationship_navigationContext)
}

func (s *Simple_statementContext) Associative_relationship_navigation() IAssociative_relationship_navigationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssociative_relationship_navigationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssociative_relationship_navigationContext)
}

func (s *Simple_statementContext) Relationship_link() IRelationship_linkContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelationship_linkContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRelationship_linkContext)
}

func (s *Simple_statementContext) Relationship_unlink() IRelationship_unlinkContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelationship_unlinkContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRelationship_unlinkContext)
}

func (s *Simple_statementContext) Event_generation() IEvent_generationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvent_generationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEvent_generationContext)
}

func (s *Simple_statementContext) Operation_invocation() IOperation_invocationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOperation_invocationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOperation_invocationContext)
}

func (s *Simple_statementContext) Timer_operation() ITimer_operationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITimer_operationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITimer_operationContext)
}

func (s *Simple_statementContext) Set_operation() ISet_operationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISet_operationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISet_operationContext)
}

func (s *Simple_statementContext) Struct_statement() IStruct_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStruct_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStruct_statementContext)
}

func (s *Simple_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Simple_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Simple_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterSimple_statement(s)
	}
}

func (s *Simple_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitSimple_statement(s)
	}
}

func (p *ASLParser) Simple_statement() (localctx ISimple_statementContext) {
	this := p
	_ = this

	localctx = NewSimple_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, ASLParserRULE_simple_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(242)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 3, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(229)
			p.Assignment_statement()
		}

	case 2:
		{
			p.SetState(230)
			p.Create_statement()
		}

	case 3:
		{
			p.SetState(231)
			p.Delete_statement()
		}

	case 4:
		{
			p.SetState(232)
			p.Find_statement()
		}

	case 5:
		{
			p.SetState(233)
			p.Relationship_navigation()
		}

	case 6:
		{
			p.SetState(234)
			p.Associative_relationship_navigation()
		}

	case 7:
		{
			p.SetState(235)
			p.Relationship_link()
		}

	case 8:
		{
			p.SetState(236)
			p.Relationship_unlink()
		}

	case 9:
		{
			p.SetState(237)
			p.Event_generation()
		}

	case 10:
		{
			p.SetState(238)
			p.Operation_invocation()
		}

	case 11:
		{
			p.SetState(239)
			p.Timer_operation()
		}

	case 12:
		{
			p.SetState(240)
			p.Set_operation()
		}

	case 13:
		{
			p.SetState(241)
			p.Struct_statement()
		}

	}

	return localctx
}

// ISequential_logic_statementContext is an interface to support dynamic dispatch.
type ISequential_logic_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSequential_logic_statementContext differentiates from other interfaces.
	IsSequential_logic_statementContext()
}

type Sequential_logic_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySequential_logic_statementContext() *Sequential_logic_statementContext {
	var p = new(Sequential_logic_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_sequential_logic_statement
	return p
}

func (*Sequential_logic_statementContext) IsSequential_logic_statementContext() {}

func NewSequential_logic_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sequential_logic_statementContext {
	var p = new(Sequential_logic_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_sequential_logic_statement

	return p
}

func (s *Sequential_logic_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Sequential_logic_statementContext) Switch_statement() ISwitch_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISwitch_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISwitch_statementContext)
}

func (s *Sequential_logic_statementContext) If_statement() IIf_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIf_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIf_statementContext)
}

func (s *Sequential_logic_statementContext) For_loop() IFor_loopContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFor_loopContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFor_loopContext)
}

func (s *Sequential_logic_statementContext) Loop_statement() ILoop_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILoop_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILoop_statementContext)
}

func (s *Sequential_logic_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sequential_logic_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sequential_logic_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterSequential_logic_statement(s)
	}
}

func (s *Sequential_logic_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitSequential_logic_statement(s)
	}
}

func (p *ASLParser) Sequential_logic_statement() (localctx ISequential_logic_statementContext) {
	this := p
	_ = this

	localctx = NewSequential_logic_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, ASLParserRULE_sequential_logic_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(248)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASLParserSWITCH:
		{
			p.SetState(244)
			p.Switch_statement()
		}

	case ASLParserIF:
		{
			p.SetState(245)
			p.If_statement()
		}

	case ASLParserFOR:
		{
			p.SetState(246)
			p.For_loop()
		}

	case ASLParserLOOP:
		{
			p.SetState(247)
			p.Loop_statement()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAssignment_statementContext is an interface to support dynamic dispatch.
type IAssignment_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignment_statementContext differentiates from other interfaces.
	IsAssignment_statementContext()
}

type Assignment_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignment_statementContext() *Assignment_statementContext {
	var p = new(Assignment_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_assignment_statement
	return p
}

func (*Assignment_statementContext) IsAssignment_statementContext() {}

func NewAssignment_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Assignment_statementContext {
	var p = new(Assignment_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_assignment_statement

	return p
}

func (s *Assignment_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Assignment_statementContext) Constant_assignment() IConstant_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_assignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_assignmentContext)
}

func (s *Assignment_statementContext) Date_time_assignment() IDate_time_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDate_time_assignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDate_time_assignmentContext)
}

func (s *Assignment_statementContext) Variable_assignment() IVariable_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_assignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_assignmentContext)
}

func (s *Assignment_statementContext) Object_attribute_assignment() IObject_attribute_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObject_attribute_assignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObject_attribute_assignmentContext)
}

func (s *Assignment_statementContext) Arithmetic_assignment() IArithmetic_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArithmetic_assignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArithmetic_assignmentContext)
}

func (s *Assignment_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Assignment_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Assignment_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterAssignment_statement(s)
	}
}

func (s *Assignment_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitAssignment_statement(s)
	}
}

func (p *ASLParser) Assignment_statement() (localctx IAssignment_statementContext) {
	this := p
	_ = this

	localctx = NewAssignment_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, ASLParserRULE_assignment_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(255)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 5, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(250)
			p.Constant_assignment()
		}

	case 2:
		{
			p.SetState(251)
			p.Date_time_assignment()
		}

	case 3:
		{
			p.SetState(252)
			p.Variable_assignment()
		}

	case 4:
		{
			p.SetState(253)
			p.Object_attribute_assignment()
		}

	case 5:
		{
			p.SetState(254)
			p.Arithmetic_assignment()
		}

	}

	return localctx
}

// IConstant_assignmentContext is an interface to support dynamic dispatch.
type IConstant_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstant_assignmentContext differentiates from other interfaces.
	IsConstant_assignmentContext()
}

type Constant_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstant_assignmentContext() *Constant_assignmentContext {
	var p = new(Constant_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_constant_assignment
	return p
}

func (*Constant_assignmentContext) IsConstant_assignmentContext() {}

func NewConstant_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constant_assignmentContext {
	var p = new(Constant_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_constant_assignment

	return p
}

func (s *Constant_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Constant_assignmentContext) EQ() antlr.TerminalNode {
	return s.GetToken(ASLParserEQ, 0)
}

func (s *Constant_assignmentContext) Variable() IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *Constant_assignmentContext) Object_attribute() IObject_attributeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObject_attributeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObject_attributeContext)
}

func (s *Constant_assignmentContext) Constant() IConstantContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstantContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *Constant_assignmentContext) UNDEFINED() antlr.TerminalNode {
	return s.GetToken(ASLParserUNDEFINED, 0)
}

func (s *Constant_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constant_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constant_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterConstant_assignment(s)
	}
}

func (s *Constant_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitConstant_assignment(s)
	}
}

func (p *ASLParser) Constant_assignment() (localctx IConstant_assignmentContext) {
	this := p
	_ = this

	localctx = NewConstant_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, ASLParserRULE_constant_assignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(259)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 6, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(257)
			p.Variable()
		}

	case 2:
		{
			p.SetState(258)
			p.Object_attribute()
		}

	}
	{
		p.SetState(261)
		p.Match(ASLParserEQ)
	}
	p.SetState(264)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASLParserDATE_VALUE, ASLParserTIME_VALUE, ASLParserINTEGER_VALUE, ASLParserREAL_VALUE, ASLParserBOOLEAN_VALUE, ASLParserLOWERCASE_TEXT, ASLParserOTHER_TEXT, ASLParserQUOTE, ASLParserUPPERCASE_ID, ASLParserUPPERCASE_OR_NUMBER_ID:
		{
			p.SetState(262)
			p.Constant()
		}

	case ASLParserUNDEFINED:
		{
			p.SetState(263)
			p.Match(ASLParserUNDEFINED)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDate_time_assignmentContext is an interface to support dynamic dispatch.
type IDate_time_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDate_time_assignmentContext differentiates from other interfaces.
	IsDate_time_assignmentContext()
}

type Date_time_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDate_time_assignmentContext() *Date_time_assignmentContext {
	var p = new(Date_time_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_date_time_assignment
	return p
}

func (*Date_time_assignmentContext) IsDate_time_assignmentContext() {}

func NewDate_time_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Date_time_assignmentContext {
	var p = new(Date_time_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_date_time_assignment

	return p
}

func (s *Date_time_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Date_time_assignmentContext) EQ() antlr.TerminalNode {
	return s.GetToken(ASLParserEQ, 0)
}

func (s *Date_time_assignmentContext) CURRENT_DATE() antlr.TerminalNode {
	return s.GetToken(ASLParserCURRENT_DATE, 0)
}

func (s *Date_time_assignmentContext) CURRENT_TIME() antlr.TerminalNode {
	return s.GetToken(ASLParserCURRENT_TIME, 0)
}

func (s *Date_time_assignmentContext) Variable() IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *Date_time_assignmentContext) Object_attribute() IObject_attributeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObject_attributeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObject_attributeContext)
}

func (s *Date_time_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Date_time_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Date_time_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterDate_time_assignment(s)
	}
}

func (s *Date_time_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitDate_time_assignment(s)
	}
}

func (p *ASLParser) Date_time_assignment() (localctx IDate_time_assignmentContext) {
	this := p
	_ = this

	localctx = NewDate_time_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, ASLParserRULE_date_time_assignment)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(268)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 8, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(266)
			p.Variable()
		}

	case 2:
		{
			p.SetState(267)
			p.Object_attribute()
		}

	}
	{
		p.SetState(270)
		p.Match(ASLParserEQ)
	}
	{
		p.SetState(271)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ASLParserCURRENT_DATE || _la == ASLParserCURRENT_TIME) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IVariable_assignmentContext is an interface to support dynamic dispatch.
type IVariable_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariable_assignmentContext differentiates from other interfaces.
	IsVariable_assignmentContext()
}

type Variable_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariable_assignmentContext() *Variable_assignmentContext {
	var p = new(Variable_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_variable_assignment
	return p
}

func (*Variable_assignmentContext) IsVariable_assignmentContext() {}

func NewVariable_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Variable_assignmentContext {
	var p = new(Variable_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_variable_assignment

	return p
}

func (s *Variable_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Variable_assignmentContext) EQ() antlr.TerminalNode {
	return s.GetToken(ASLParserEQ, 0)
}

func (s *Variable_assignmentContext) AllVariable() []IVariableContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariableContext)(nil)).Elem())
	var tst = make([]IVariableContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariableContext)
		}
	}

	return tst
}

func (s *Variable_assignmentContext) Variable(i int) IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *Variable_assignmentContext) Object_attribute() IObject_attributeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObject_attributeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObject_attributeContext)
}

func (s *Variable_assignmentContext) THIS() antlr.TerminalNode {
	return s.GetToken(ASLParserTHIS, 0)
}

func (s *Variable_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Variable_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Variable_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterVariable_assignment(s)
	}
}

func (s *Variable_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitVariable_assignment(s)
	}
}

func (p *ASLParser) Variable_assignment() (localctx IVariable_assignmentContext) {
	this := p
	_ = this

	localctx = NewVariable_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, ASLParserRULE_variable_assignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(275)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 9, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(273)
			p.Variable()
		}

	case 2:
		{
			p.SetState(274)
			p.Object_attribute()
		}

	}
	{
		p.SetState(277)
		p.Match(ASLParserEQ)
	}
	p.SetState(280)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASLParserLOWERCASE_ID, ASLParserLOWERCASE_NUMBER_ID:
		{
			p.SetState(278)
			p.Variable()
		}

	case ASLParserTHIS:
		{
			p.SetState(279)
			p.Match(ASLParserTHIS)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IObject_attribute_assignmentContext is an interface to support dynamic dispatch.
type IObject_attribute_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObject_attribute_assignmentContext differentiates from other interfaces.
	IsObject_attribute_assignmentContext()
}

type Object_attribute_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObject_attribute_assignmentContext() *Object_attribute_assignmentContext {
	var p = new(Object_attribute_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_object_attribute_assignment
	return p
}

func (*Object_attribute_assignmentContext) IsObject_attribute_assignmentContext() {}

func NewObject_attribute_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Object_attribute_assignmentContext {
	var p = new(Object_attribute_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_object_attribute_assignment

	return p
}

func (s *Object_attribute_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Object_attribute_assignmentContext) EQ() antlr.TerminalNode {
	return s.GetToken(ASLParserEQ, 0)
}

func (s *Object_attribute_assignmentContext) AllObject_attribute() []IObject_attributeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IObject_attributeContext)(nil)).Elem())
	var tst = make([]IObject_attributeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IObject_attributeContext)
		}
	}

	return tst
}

func (s *Object_attribute_assignmentContext) Object_attribute(i int) IObject_attributeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObject_attributeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IObject_attributeContext)
}

func (s *Object_attribute_assignmentContext) Variable() IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *Object_attribute_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Object_attribute_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Object_attribute_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterObject_attribute_assignment(s)
	}
}

func (s *Object_attribute_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitObject_attribute_assignment(s)
	}
}

func (p *ASLParser) Object_attribute_assignment() (localctx IObject_attribute_assignmentContext) {
	this := p
	_ = this

	localctx = NewObject_attribute_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, ASLParserRULE_object_attribute_assignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(284)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 11, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(282)
			p.Variable()
		}

	case 2:
		{
			p.SetState(283)
			p.Object_attribute()
		}

	}
	{
		p.SetState(286)
		p.Match(ASLParserEQ)
	}
	{
		p.SetState(287)
		p.Object_attribute()
	}

	return localctx
}

// IArithmetic_assignmentContext is an interface to support dynamic dispatch.
type IArithmetic_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArithmetic_assignmentContext differentiates from other interfaces.
	IsArithmetic_assignmentContext()
}

type Arithmetic_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArithmetic_assignmentContext() *Arithmetic_assignmentContext {
	var p = new(Arithmetic_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_arithmetic_assignment
	return p
}

func (*Arithmetic_assignmentContext) IsArithmetic_assignmentContext() {}

func NewArithmetic_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Arithmetic_assignmentContext {
	var p = new(Arithmetic_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_arithmetic_assignment

	return p
}

func (s *Arithmetic_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Arithmetic_assignmentContext) EQ() antlr.TerminalNode {
	return s.GetToken(ASLParserEQ, 0)
}

func (s *Arithmetic_assignmentContext) Arithmetic_expression() IArithmetic_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArithmetic_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArithmetic_expressionContext)
}

func (s *Arithmetic_assignmentContext) Variable() IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *Arithmetic_assignmentContext) Object_attribute() IObject_attributeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObject_attributeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObject_attributeContext)
}

func (s *Arithmetic_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Arithmetic_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Arithmetic_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterArithmetic_assignment(s)
	}
}

func (s *Arithmetic_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitArithmetic_assignment(s)
	}
}

func (p *ASLParser) Arithmetic_assignment() (localctx IArithmetic_assignmentContext) {
	this := p
	_ = this

	localctx = NewArithmetic_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, ASLParserRULE_arithmetic_assignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(291)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 12, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(289)
			p.Variable()
		}

	case 2:
		{
			p.SetState(290)
			p.Object_attribute()
		}

	}
	{
		p.SetState(293)
		p.Match(ASLParserEQ)
	}
	{
		p.SetState(294)
		p.Arithmetic_expression()
	}

	return localctx
}

// IArithmetic_expressionContext is an interface to support dynamic dispatch.
type IArithmetic_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArithmetic_expressionContext differentiates from other interfaces.
	IsArithmetic_expressionContext()
}

type Arithmetic_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArithmetic_expressionContext() *Arithmetic_expressionContext {
	var p = new(Arithmetic_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_arithmetic_expression
	return p
}

func (*Arithmetic_expressionContext) IsArithmetic_expressionContext() {}

func NewArithmetic_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Arithmetic_expressionContext {
	var p = new(Arithmetic_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_arithmetic_expression

	return p
}

func (s *Arithmetic_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Arithmetic_expressionContext) AllArithmetic_component() []IArithmetic_componentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IArithmetic_componentContext)(nil)).Elem())
	var tst = make([]IArithmetic_componentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IArithmetic_componentContext)
		}
	}

	return tst
}

func (s *Arithmetic_expressionContext) Arithmetic_component(i int) IArithmetic_componentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArithmetic_componentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IArithmetic_componentContext)
}

func (s *Arithmetic_expressionContext) ARITHMETIC_OPERATOR() antlr.TerminalNode {
	return s.GetToken(ASLParserARITHMETIC_OPERATOR, 0)
}

func (s *Arithmetic_expressionContext) Arithmetic_expression() IArithmetic_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArithmetic_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArithmetic_expressionContext)
}

func (s *Arithmetic_expressionContext) L_PAREN() antlr.TerminalNode {
	return s.GetToken(ASLParserL_PAREN, 0)
}

func (s *Arithmetic_expressionContext) R_PAREN() antlr.TerminalNode {
	return s.GetToken(ASLParserR_PAREN, 0)
}

func (s *Arithmetic_expressionContext) Countof_function() ICountof_functionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICountof_functionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICountof_functionContext)
}

func (s *Arithmetic_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Arithmetic_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Arithmetic_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterArithmetic_expression(s)
	}
}

func (s *Arithmetic_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitArithmetic_expression(s)
	}
}

func (p *ASLParser) Arithmetic_expression() (localctx IArithmetic_expressionContext) {
	this := p
	_ = this

	localctx = NewArithmetic_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, ASLParserRULE_arithmetic_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(312)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 15, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(296)
			p.Arithmetic_component()
		}
		{
			p.SetState(297)
			p.Match(ASLParserARITHMETIC_OPERATOR)
		}
		p.SetState(300)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 13, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(298)
				p.Arithmetic_component()
			}

		case 2:
			{
				p.SetState(299)
				p.Arithmetic_expression()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(302)
			p.Match(ASLParserL_PAREN)
		}
		{
			p.SetState(303)
			p.Arithmetic_component()
		}
		{
			p.SetState(304)
			p.Match(ASLParserARITHMETIC_OPERATOR)
		}
		p.SetState(307)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 14, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(305)
				p.Arithmetic_component()
			}

		case 2:
			{
				p.SetState(306)
				p.Arithmetic_expression()
			}

		}
		{
			p.SetState(309)
			p.Match(ASLParserR_PAREN)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(311)
			p.Countof_function()
		}

	}

	return localctx
}

// IArithmetic_componentContext is an interface to support dynamic dispatch.
type IArithmetic_componentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArithmetic_componentContext differentiates from other interfaces.
	IsArithmetic_componentContext()
}

type Arithmetic_componentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArithmetic_componentContext() *Arithmetic_componentContext {
	var p = new(Arithmetic_componentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_arithmetic_component
	return p
}

func (*Arithmetic_componentContext) IsArithmetic_componentContext() {}

func NewArithmetic_componentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Arithmetic_componentContext {
	var p = new(Arithmetic_componentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_arithmetic_component

	return p
}

func (s *Arithmetic_componentContext) GetParser() antlr.Parser { return s.parser }

func (s *Arithmetic_componentContext) Variable() IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *Arithmetic_componentContext) Object_attribute() IObject_attributeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObject_attributeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObject_attributeContext)
}

func (s *Arithmetic_componentContext) Constant() IConstantContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstantContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *Arithmetic_componentContext) Countof_function() ICountof_functionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICountof_functionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICountof_functionContext)
}

func (s *Arithmetic_componentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Arithmetic_componentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Arithmetic_componentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterArithmetic_component(s)
	}
}

func (s *Arithmetic_componentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitArithmetic_component(s)
	}
}

func (p *ASLParser) Arithmetic_component() (localctx IArithmetic_componentContext) {
	this := p
	_ = this

	localctx = NewArithmetic_componentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, ASLParserRULE_arithmetic_component)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(318)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 16, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(314)
			p.Variable()
		}

	case 2:
		{
			p.SetState(315)
			p.Object_attribute()
		}

	case 3:
		{
			p.SetState(316)
			p.Constant()
		}

	case 4:
		{
			p.SetState(317)
			p.Countof_function()
		}

	}

	return localctx
}

// ICountof_functionContext is an interface to support dynamic dispatch.
type ICountof_functionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCountof_functionContext differentiates from other interfaces.
	IsCountof_functionContext()
}

type Countof_functionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCountof_functionContext() *Countof_functionContext {
	var p = new(Countof_functionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_countof_function
	return p
}

func (*Countof_functionContext) IsCountof_functionContext() {}

func NewCountof_functionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Countof_functionContext {
	var p = new(Countof_functionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_countof_function

	return p
}

func (s *Countof_functionContext) GetParser() antlr.Parser { return s.parser }

func (s *Countof_functionContext) COUNTOF() antlr.TerminalNode {
	return s.GetToken(ASLParserCOUNTOF, 0)
}

func (s *Countof_functionContext) Set_variable() ISet_variableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISet_variableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISet_variableContext)
}

func (s *Countof_functionContext) RELATIONSHIP_TRAVERSAL() antlr.TerminalNode {
	return s.GetToken(ASLParserRELATIONSHIP_TRAVERSAL, 0)
}

func (s *Countof_functionContext) Relationship_spec() IRelationship_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelationship_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRelationship_specContext)
}

func (s *Countof_functionContext) Variable() IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *Countof_functionContext) THIS() antlr.TerminalNode {
	return s.GetToken(ASLParserTHIS, 0)
}

func (s *Countof_functionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Countof_functionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Countof_functionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterCountof_function(s)
	}
}

func (s *Countof_functionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitCountof_function(s)
	}
}

func (p *ASLParser) Countof_function() (localctx ICountof_functionContext) {
	this := p
	_ = this

	localctx = NewCountof_functionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, ASLParserRULE_countof_function)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(320)
		p.Match(ASLParserCOUNTOF)
	}
	p.SetState(328)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASLParserL_CURLY:
		{
			p.SetState(321)
			p.Set_variable()
		}

	case ASLParserTHIS, ASLParserLOWERCASE_ID, ASLParserLOWERCASE_NUMBER_ID:
		p.SetState(324)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case ASLParserLOWERCASE_ID, ASLParserLOWERCASE_NUMBER_ID:
			{
				p.SetState(322)
				p.Variable()
			}

		case ASLParserTHIS:
			{
				p.SetState(323)
				p.Match(ASLParserTHIS)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(326)
			p.Match(ASLParserRELATIONSHIP_TRAVERSAL)
		}
		{
			p.SetState(327)
			p.Relationship_spec()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICreate_statementContext is an interface to support dynamic dispatch.
type ICreate_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCreate_statementContext differentiates from other interfaces.
	IsCreate_statementContext()
}

type Create_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_statementContext() *Create_statementContext {
	var p = new(Create_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_create_statement
	return p
}

func (*Create_statementContext) IsCreate_statementContext() {}

func NewCreate_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_statementContext {
	var p = new(Create_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_create_statement

	return p
}

func (s *Create_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_statementContext) EQ() antlr.TerminalNode {
	return s.GetToken(ASLParserEQ, 0)
}

func (s *Create_statementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(ASLParserCREATE, 0)
}

func (s *Create_statementContext) Object_name() IObject_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObject_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObject_nameContext)
}

func (s *Create_statementContext) Variable() IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *Create_statementContext) THIS() antlr.TerminalNode {
	return s.GetToken(ASLParserTHIS, 0)
}

func (s *Create_statementContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(ASLParserUNIQUE, 0)
}

func (s *Create_statementContext) WITH() antlr.TerminalNode {
	return s.GetToken(ASLParserWITH, 0)
}

func (s *Create_statementContext) Attribute_assignments() IAttribute_assignmentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_assignmentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribute_assignmentsContext)
}

func (s *Create_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterCreate_statement(s)
	}
}

func (s *Create_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitCreate_statement(s)
	}
}

func (p *ASLParser) Create_statement() (localctx ICreate_statementContext) {
	this := p
	_ = this

	localctx = NewCreate_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, ASLParserRULE_create_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(332)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASLParserLOWERCASE_ID, ASLParserLOWERCASE_NUMBER_ID:
		{
			p.SetState(330)
			p.Variable()
		}

	case ASLParserTHIS:
		{
			p.SetState(331)
			p.Match(ASLParserTHIS)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(334)
		p.Match(ASLParserEQ)
	}
	{
		p.SetState(335)
		p.Match(ASLParserCREATE)
	}
	p.SetState(337)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASLParserUNIQUE {
		{
			p.SetState(336)
			p.Match(ASLParserUNIQUE)
		}

	}
	{
		p.SetState(339)
		p.Object_name()
	}
	p.SetState(342)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASLParserWITH {
		{
			p.SetState(340)
			p.Match(ASLParserWITH)
		}
		{
			p.SetState(341)
			p.Attribute_assignments()
		}

	}

	return localctx
}

// IAttribute_assignmentsContext is an interface to support dynamic dispatch.
type IAttribute_assignmentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttribute_assignmentsContext differentiates from other interfaces.
	IsAttribute_assignmentsContext()
}

type Attribute_assignmentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttribute_assignmentsContext() *Attribute_assignmentsContext {
	var p = new(Attribute_assignmentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_attribute_assignments
	return p
}

func (*Attribute_assignmentsContext) IsAttribute_assignmentsContext() {}

func NewAttribute_assignmentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Attribute_assignmentsContext {
	var p = new(Attribute_assignmentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_attribute_assignments

	return p
}

func (s *Attribute_assignmentsContext) GetParser() antlr.Parser { return s.parser }

func (s *Attribute_assignmentsContext) AllAttribute_assignment() []IAttribute_assignmentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttribute_assignmentContext)(nil)).Elem())
	var tst = make([]IAttribute_assignmentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttribute_assignmentContext)
		}
	}

	return tst
}

func (s *Attribute_assignmentsContext) Attribute_assignment(i int) IAttribute_assignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_assignmentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttribute_assignmentContext)
}

func (s *Attribute_assignmentsContext) AllLOGICAL_AND() []antlr.TerminalNode {
	return s.GetTokens(ASLParserLOGICAL_AND)
}

func (s *Attribute_assignmentsContext) LOGICAL_AND(i int) antlr.TerminalNode {
	return s.GetToken(ASLParserLOGICAL_AND, i)
}

func (s *Attribute_assignmentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Attribute_assignmentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Attribute_assignmentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterAttribute_assignments(s)
	}
}

func (s *Attribute_assignmentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitAttribute_assignments(s)
	}
}

func (p *ASLParser) Attribute_assignments() (localctx IAttribute_assignmentsContext) {
	this := p
	_ = this

	localctx = NewAttribute_assignmentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, ASLParserRULE_attribute_assignments)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(344)
		p.Attribute_assignment()
	}
	p.SetState(349)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ASLParserLOGICAL_AND {
		{
			p.SetState(345)
			p.Match(ASLParserLOGICAL_AND)
		}
		{
			p.SetState(346)
			p.Attribute_assignment()
		}

		p.SetState(351)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IAttribute_assignmentContext is an interface to support dynamic dispatch.
type IAttribute_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttribute_assignmentContext differentiates from other interfaces.
	IsAttribute_assignmentContext()
}

type Attribute_assignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttribute_assignmentContext() *Attribute_assignmentContext {
	var p = new(Attribute_assignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_attribute_assignment
	return p
}

func (*Attribute_assignmentContext) IsAttribute_assignmentContext() {}

func NewAttribute_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Attribute_assignmentContext {
	var p = new(Attribute_assignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_attribute_assignment

	return p
}

func (s *Attribute_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Attribute_assignmentContext) Attribute() IAttributeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttributeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttributeContext)
}

func (s *Attribute_assignmentContext) EQ() antlr.TerminalNode {
	return s.GetToken(ASLParserEQ, 0)
}

func (s *Attribute_assignmentContext) Constant() IConstantContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstantContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *Attribute_assignmentContext) Variable() IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *Attribute_assignmentContext) Object_attribute() IObject_attributeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObject_attributeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObject_attributeContext)
}

func (s *Attribute_assignmentContext) Arithmetic_expression() IArithmetic_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArithmetic_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArithmetic_expressionContext)
}

func (s *Attribute_assignmentContext) CURRENT_DATE() antlr.TerminalNode {
	return s.GetToken(ASLParserCURRENT_DATE, 0)
}

func (s *Attribute_assignmentContext) CURRENT_TIME() antlr.TerminalNode {
	return s.GetToken(ASLParserCURRENT_TIME, 0)
}

func (s *Attribute_assignmentContext) UNDEFINED() antlr.TerminalNode {
	return s.GetToken(ASLParserUNDEFINED, 0)
}

func (s *Attribute_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Attribute_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Attribute_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterAttribute_assignment(s)
	}
}

func (s *Attribute_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitAttribute_assignment(s)
	}
}

func (p *ASLParser) Attribute_assignment() (localctx IAttribute_assignmentContext) {
	this := p
	_ = this

	localctx = NewAttribute_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, ASLParserRULE_attribute_assignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(352)
		p.Attribute()
	}
	{
		p.SetState(353)
		p.Match(ASLParserEQ)
	}
	p.SetState(361)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 23, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(354)
			p.Constant()
		}

	case 2:
		{
			p.SetState(355)
			p.Variable()
		}

	case 3:
		{
			p.SetState(356)
			p.Object_attribute()
		}

	case 4:
		{
			p.SetState(357)
			p.Arithmetic_expression()
		}

	case 5:
		{
			p.SetState(358)
			p.Match(ASLParserCURRENT_DATE)
		}

	case 6:
		{
			p.SetState(359)
			p.Match(ASLParserCURRENT_TIME)
		}

	case 7:
		{
			p.SetState(360)
			p.Match(ASLParserUNDEFINED)
		}

	}

	return localctx
}

// IDelete_statementContext is an interface to support dynamic dispatch.
type IDelete_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDelete_statementContext differentiates from other interfaces.
	IsDelete_statementContext()
}

type Delete_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDelete_statementContext() *Delete_statementContext {
	var p = new(Delete_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_delete_statement
	return p
}

func (*Delete_statementContext) IsDelete_statementContext() {}

func NewDelete_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Delete_statementContext {
	var p = new(Delete_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_delete_statement

	return p
}

func (s *Delete_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Delete_statementContext) DELETE() antlr.TerminalNode {
	return s.GetToken(ASLParserDELETE, 0)
}

func (s *Delete_statementContext) Variable() IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *Delete_statementContext) THIS() antlr.TerminalNode {
	return s.GetToken(ASLParserTHIS, 0)
}

func (s *Delete_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Delete_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Delete_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterDelete_statement(s)
	}
}

func (s *Delete_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitDelete_statement(s)
	}
}

func (p *ASLParser) Delete_statement() (localctx IDelete_statementContext) {
	this := p
	_ = this

	localctx = NewDelete_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, ASLParserRULE_delete_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(363)
		p.Match(ASLParserDELETE)
	}
	p.SetState(366)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASLParserLOWERCASE_ID, ASLParserLOWERCASE_NUMBER_ID:
		{
			p.SetState(364)
			p.Variable()
		}

	case ASLParserTHIS:
		{
			p.SetState(365)
			p.Match(ASLParserTHIS)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFind_statementContext is an interface to support dynamic dispatch.
type IFind_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFind_statementContext differentiates from other interfaces.
	IsFind_statementContext()
}

type Find_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFind_statementContext() *Find_statementContext {
	var p = new(Find_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_find_statement
	return p
}

func (*Find_statementContext) IsFind_statementContext() {}

func NewFind_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Find_statementContext {
	var p = new(Find_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_find_statement

	return p
}

func (s *Find_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Find_statementContext) Find_instance_statement() IFind_instance_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFind_instance_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFind_instance_statementContext)
}

func (s *Find_statementContext) Find_set_statement() IFind_set_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFind_set_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFind_set_statementContext)
}

func (s *Find_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Find_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Find_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterFind_statement(s)
	}
}

func (s *Find_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitFind_statement(s)
	}
}

func (p *ASLParser) Find_statement() (localctx IFind_statementContext) {
	this := p
	_ = this

	localctx = NewFind_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, ASLParserRULE_find_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(370)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASLParserLOWERCASE_ID, ASLParserLOWERCASE_NUMBER_ID:
		{
			p.SetState(368)
			p.Find_instance_statement()
		}

	case ASLParserL_CURLY:
		{
			p.SetState(369)
			p.Find_set_statement()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFind_instance_statementContext is an interface to support dynamic dispatch.
type IFind_instance_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFind_instance_statementContext differentiates from other interfaces.
	IsFind_instance_statementContext()
}

type Find_instance_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFind_instance_statementContext() *Find_instance_statementContext {
	var p = new(Find_instance_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_find_instance_statement
	return p
}

func (*Find_instance_statementContext) IsFind_instance_statementContext() {}

func NewFind_instance_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Find_instance_statementContext {
	var p = new(Find_instance_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_find_instance_statement

	return p
}

func (s *Find_instance_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Find_instance_statementContext) Variable() IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *Find_instance_statementContext) EQ() antlr.TerminalNode {
	return s.GetToken(ASLParserEQ, 0)
}

func (s *Find_instance_statementContext) FIND_ONE() antlr.TerminalNode {
	return s.GetToken(ASLParserFIND_ONE, 0)
}

func (s *Find_instance_statementContext) FIND_ONLY() antlr.TerminalNode {
	return s.GetToken(ASLParserFIND_ONLY, 0)
}

func (s *Find_instance_statementContext) Object_name() IObject_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObject_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObject_nameContext)
}

func (s *Find_instance_statementContext) Set_variable() ISet_variableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISet_variableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISet_variableContext)
}

func (s *Find_instance_statementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(ASLParserWHERE, 0)
}

func (s *Find_instance_statementContext) Object_condition() IObject_conditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObject_conditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObject_conditionContext)
}

func (s *Find_instance_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Find_instance_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Find_instance_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterFind_instance_statement(s)
	}
}

func (s *Find_instance_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitFind_instance_statement(s)
	}
}

func (p *ASLParser) Find_instance_statement() (localctx IFind_instance_statementContext) {
	this := p
	_ = this

	localctx = NewFind_instance_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, ASLParserRULE_find_instance_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(372)
		p.Variable()
	}
	{
		p.SetState(373)
		p.Match(ASLParserEQ)
	}
	{
		p.SetState(374)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ASLParserFIND_ONLY || _la == ASLParserFIND_ONE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(377)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASLParserUPPERCASE_ID:
		{
			p.SetState(375)
			p.Object_name()
		}

	case ASLParserL_CURLY:
		{
			p.SetState(376)
			p.Set_variable()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(381)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASLParserWHERE {
		{
			p.SetState(379)
			p.Match(ASLParserWHERE)
		}
		{
			p.SetState(380)
			p.Object_condition()
		}

	}

	return localctx
}

// IFind_set_statementContext is an interface to support dynamic dispatch.
type IFind_set_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFind_set_statementContext differentiates from other interfaces.
	IsFind_set_statementContext()
}

type Find_set_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFind_set_statementContext() *Find_set_statementContext {
	var p = new(Find_set_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_find_set_statement
	return p
}

func (*Find_set_statementContext) IsFind_set_statementContext() {}

func NewFind_set_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Find_set_statementContext {
	var p = new(Find_set_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_find_set_statement

	return p
}

func (s *Find_set_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Find_set_statementContext) AllSet_variable() []ISet_variableContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISet_variableContext)(nil)).Elem())
	var tst = make([]ISet_variableContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISet_variableContext)
		}
	}

	return tst
}

func (s *Find_set_statementContext) Set_variable(i int) ISet_variableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISet_variableContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISet_variableContext)
}

func (s *Find_set_statementContext) EQ() antlr.TerminalNode {
	return s.GetToken(ASLParserEQ, 0)
}

func (s *Find_set_statementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(ASLParserWHERE, 0)
}

func (s *Find_set_statementContext) Object_condition() IObject_conditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObject_conditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObject_conditionContext)
}

func (s *Find_set_statementContext) FIND_ALL() antlr.TerminalNode {
	return s.GetToken(ASLParserFIND_ALL, 0)
}

func (s *Find_set_statementContext) Object_name() IObject_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObject_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObject_nameContext)
}

func (s *Find_set_statementContext) Attribute() IAttributeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttributeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttributeContext)
}

func (s *Find_set_statementContext) ORDERED_BY() antlr.TerminalNode {
	return s.GetToken(ASLParserORDERED_BY, 0)
}

func (s *Find_set_statementContext) REVERSE_ORDERED_BY() antlr.TerminalNode {
	return s.GetToken(ASLParserREVERSE_ORDERED_BY, 0)
}

func (s *Find_set_statementContext) FIND() antlr.TerminalNode {
	return s.GetToken(ASLParserFIND, 0)
}

func (s *Find_set_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Find_set_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Find_set_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterFind_set_statement(s)
	}
}

func (s *Find_set_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitFind_set_statement(s)
	}
}

func (p *ASLParser) Find_set_statement() (localctx IFind_set_statementContext) {
	this := p
	_ = this

	localctx = NewFind_set_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, ASLParserRULE_find_set_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(383)
		p.Set_variable()
	}
	{
		p.SetState(384)
		p.Match(ASLParserEQ)
	}
	p.SetState(398)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASLParserFIND, ASLParserL_CURLY:
		p.SetState(391)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 29, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(385)
				p.Match(ASLParserFIND)
			}
			{
				p.SetState(386)
				p.Object_name()
			}

		case 2:
			p.SetState(388)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == ASLParserFIND {
				{
					p.SetState(387)
					p.Match(ASLParserFIND)
				}

			}
			{
				p.SetState(390)
				p.Set_variable()
			}

		}
		{
			p.SetState(393)
			p.Match(ASLParserWHERE)
		}
		{
			p.SetState(394)
			p.Object_condition()
		}

	case ASLParserFIND_ALL:
		{
			p.SetState(396)
			p.Match(ASLParserFIND_ALL)
		}
		{
			p.SetState(397)
			p.Object_name()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(402)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASLParserREVERSE_ORDERED_BY || _la == ASLParserORDERED_BY {
		{
			p.SetState(400)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ASLParserREVERSE_ORDERED_BY || _la == ASLParserORDERED_BY) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(401)
			p.Attribute()
		}

	}

	return localctx
}

// IObject_conditionContext is an interface to support dynamic dispatch.
type IObject_conditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObject_conditionContext differentiates from other interfaces.
	IsObject_conditionContext()
}

type Object_conditionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObject_conditionContext() *Object_conditionContext {
	var p = new(Object_conditionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_object_condition
	return p
}

func (*Object_conditionContext) IsObject_conditionContext() {}

func NewObject_conditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Object_conditionContext {
	var p = new(Object_conditionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_object_condition

	return p
}

func (s *Object_conditionContext) GetParser() antlr.Parser { return s.parser }

func (s *Object_conditionContext) Attribute() IAttributeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttributeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttributeContext)
}

func (s *Object_conditionContext) Logical_operator() ILogical_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILogical_operatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILogical_operatorContext)
}

func (s *Object_conditionContext) Variable() IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *Object_conditionContext) Object_attribute() IObject_attributeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObject_attributeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObject_attributeContext)
}

func (s *Object_conditionContext) Constant() IConstantContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstantContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *Object_conditionContext) UNDEFINED() antlr.TerminalNode {
	return s.GetToken(ASLParserUNDEFINED, 0)
}

func (s *Object_conditionContext) AllObject_condition() []IObject_conditionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IObject_conditionContext)(nil)).Elem())
	var tst = make([]IObject_conditionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IObject_conditionContext)
		}
	}

	return tst
}

func (s *Object_conditionContext) Object_condition(i int) IObject_conditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObject_conditionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IObject_conditionContext)
}

func (s *Object_conditionContext) AllLOGICAL_AND() []antlr.TerminalNode {
	return s.GetTokens(ASLParserLOGICAL_AND)
}

func (s *Object_conditionContext) LOGICAL_AND(i int) antlr.TerminalNode {
	return s.GetToken(ASLParserLOGICAL_AND, i)
}

func (s *Object_conditionContext) AllLOGICAL_OR() []antlr.TerminalNode {
	return s.GetTokens(ASLParserLOGICAL_OR)
}

func (s *Object_conditionContext) LOGICAL_OR(i int) antlr.TerminalNode {
	return s.GetToken(ASLParserLOGICAL_OR, i)
}

func (s *Object_conditionContext) L_PAREN() antlr.TerminalNode {
	return s.GetToken(ASLParserL_PAREN, 0)
}

func (s *Object_conditionContext) R_PAREN() antlr.TerminalNode {
	return s.GetToken(ASLParserR_PAREN, 0)
}

func (s *Object_conditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Object_conditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Object_conditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterObject_condition(s)
	}
}

func (s *Object_conditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitObject_condition(s)
	}
}

func (p *ASLParser) Object_condition() (localctx IObject_conditionContext) {
	this := p
	_ = this

	localctx = NewObject_conditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, ASLParserRULE_object_condition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(435)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASLParserINSTANCE_ID, ASLParserUPPERCASE_ID, ASLParserLEADING_UPPERCASE_ID, ASLParserLEADING_FIRST_UPPERCASE_ID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(404)
			p.Attribute()
		}
		{
			p.SetState(405)
			p.Logical_operator()
		}
		p.SetState(410)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 32, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(406)
				p.Variable()
			}

		case 2:
			{
				p.SetState(407)
				p.Object_attribute()
			}

		case 3:
			{
				p.SetState(408)
				p.Constant()
			}

		case 4:
			{
				p.SetState(409)
				p.Match(ASLParserUNDEFINED)
			}

		}
		p.SetState(416)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 33, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(412)
					_la = p.GetTokenStream().LA(1)

					if !(_la == ASLParserLOGICAL_AND || _la == ASLParserLOGICAL_OR) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(413)
					p.Object_condition()
				}

			}
			p.SetState(418)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 33, p.GetParserRuleContext())
		}

	case ASLParserL_PAREN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(419)
			p.Match(ASLParserL_PAREN)
		}
		{
			p.SetState(420)
			p.Attribute()
		}
		{
			p.SetState(421)
			p.Logical_operator()
		}
		p.SetState(425)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case ASLParserLOWERCASE_ID, ASLParserLOWERCASE_NUMBER_ID:
			{
				p.SetState(422)
				p.Variable()
			}

		case ASLParserDATE_VALUE, ASLParserTIME_VALUE, ASLParserINTEGER_VALUE, ASLParserREAL_VALUE, ASLParserBOOLEAN_VALUE, ASLParserLOWERCASE_TEXT, ASLParserOTHER_TEXT, ASLParserQUOTE, ASLParserUPPERCASE_ID, ASLParserUPPERCASE_OR_NUMBER_ID:
			{
				p.SetState(423)
				p.Constant()
			}

		case ASLParserUNDEFINED:
			{
				p.SetState(424)
				p.Match(ASLParserUNDEFINED)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(427)
			p.Match(ASLParserR_PAREN)
		}
		p.SetState(432)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 35, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(428)
					_la = p.GetTokenStream().LA(1)

					if !(_la == ASLParserLOGICAL_AND || _la == ASLParserLOGICAL_OR) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(429)
					p.Object_condition()
				}

			}
			p.SetState(434)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 35, p.GetParserRuleContext())
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IEquality_operatorContext is an interface to support dynamic dispatch.
type IEquality_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEquality_operatorContext differentiates from other interfaces.
	IsEquality_operatorContext()
}

type Equality_operatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEquality_operatorContext() *Equality_operatorContext {
	var p = new(Equality_operatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_equality_operator
	return p
}

func (*Equality_operatorContext) IsEquality_operatorContext() {}

func NewEquality_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Equality_operatorContext {
	var p = new(Equality_operatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_equality_operator

	return p
}

func (s *Equality_operatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Equality_operatorContext) EQ() antlr.TerminalNode {
	return s.GetToken(ASLParserEQ, 0)
}

func (s *Equality_operatorContext) NEQ() antlr.TerminalNode {
	return s.GetToken(ASLParserNEQ, 0)
}

func (s *Equality_operatorContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(ASLParserEQUALS, 0)
}

func (s *Equality_operatorContext) NOT_EQUALS() antlr.TerminalNode {
	return s.GetToken(ASLParserNOT_EQUALS, 0)
}

func (s *Equality_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Equality_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Equality_operatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterEquality_operator(s)
	}
}

func (s *Equality_operatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitEquality_operator(s)
	}
}

func (p *ASLParser) Equality_operator() (localctx IEquality_operatorContext) {
	this := p
	_ = this

	localctx = NewEquality_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, ASLParserRULE_equality_operator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(437)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ASLParserEQUALS || _la == ASLParserNOT_EQUALS || _la == ASLParserNEQ || _la == ASLParserEQ) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ILogical_operatorContext is an interface to support dynamic dispatch.
type ILogical_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLogical_operatorContext differentiates from other interfaces.
	IsLogical_operatorContext()
}

type Logical_operatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLogical_operatorContext() *Logical_operatorContext {
	var p = new(Logical_operatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_logical_operator
	return p
}

func (*Logical_operatorContext) IsLogical_operatorContext() {}

func NewLogical_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Logical_operatorContext {
	var p = new(Logical_operatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_logical_operator

	return p
}

func (s *Logical_operatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Logical_operatorContext) Equality_operator() IEquality_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEquality_operatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEquality_operatorContext)
}

func (s *Logical_operatorContext) LT() antlr.TerminalNode {
	return s.GetToken(ASLParserLT, 0)
}

func (s *Logical_operatorContext) GT() antlr.TerminalNode {
	return s.GetToken(ASLParserGT, 0)
}

func (s *Logical_operatorContext) LTE() antlr.TerminalNode {
	return s.GetToken(ASLParserLTE, 0)
}

func (s *Logical_operatorContext) GTE() antlr.TerminalNode {
	return s.GetToken(ASLParserGTE, 0)
}

func (s *Logical_operatorContext) LESS_THAN() antlr.TerminalNode {
	return s.GetToken(ASLParserLESS_THAN, 0)
}

func (s *Logical_operatorContext) GREATER_THAN() antlr.TerminalNode {
	return s.GetToken(ASLParserGREATER_THAN, 0)
}

func (s *Logical_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Logical_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Logical_operatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterLogical_operator(s)
	}
}

func (s *Logical_operatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitLogical_operator(s)
	}
}

func (p *ASLParser) Logical_operator() (localctx ILogical_operatorContext) {
	this := p
	_ = this

	localctx = NewLogical_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, ASLParserRULE_logical_operator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(446)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASLParserEQUALS, ASLParserNOT_EQUALS, ASLParserNEQ, ASLParserEQ:
		{
			p.SetState(439)
			p.Equality_operator()
		}

	case ASLParserLT:
		{
			p.SetState(440)
			p.Match(ASLParserLT)
		}

	case ASLParserGT:
		{
			p.SetState(441)
			p.Match(ASLParserGT)
		}

	case ASLParserLTE:
		{
			p.SetState(442)
			p.Match(ASLParserLTE)
		}

	case ASLParserGTE:
		{
			p.SetState(443)
			p.Match(ASLParserGTE)
		}

	case ASLParserLESS_THAN:
		{
			p.SetState(444)
			p.Match(ASLParserLESS_THAN)
		}

	case ASLParserGREATER_THAN:
		{
			p.SetState(445)
			p.Match(ASLParserGREATER_THAN)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IRelationship_navigationContext is an interface to support dynamic dispatch.
type IRelationship_navigationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelationship_navigationContext differentiates from other interfaces.
	IsRelationship_navigationContext()
}

type Relationship_navigationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationship_navigationContext() *Relationship_navigationContext {
	var p = new(Relationship_navigationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_relationship_navigation
	return p
}

func (*Relationship_navigationContext) IsRelationship_navigationContext() {}

func NewRelationship_navigationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Relationship_navigationContext {
	var p = new(Relationship_navigationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_relationship_navigation

	return p
}

func (s *Relationship_navigationContext) GetParser() antlr.Parser { return s.parser }

func (s *Relationship_navigationContext) EQ() antlr.TerminalNode {
	return s.GetToken(ASLParserEQ, 0)
}

func (s *Relationship_navigationContext) AllVariable() []IVariableContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariableContext)(nil)).Elem())
	var tst = make([]IVariableContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariableContext)
		}
	}

	return tst
}

func (s *Relationship_navigationContext) Variable(i int) IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *Relationship_navigationContext) AllSet_variable() []ISet_variableContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISet_variableContext)(nil)).Elem())
	var tst = make([]ISet_variableContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISet_variableContext)
		}
	}

	return tst
}

func (s *Relationship_navigationContext) Set_variable(i int) ISet_variableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISet_variableContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISet_variableContext)
}

func (s *Relationship_navigationContext) THIS() antlr.TerminalNode {
	return s.GetToken(ASLParserTHIS, 0)
}

func (s *Relationship_navigationContext) AllRELATIONSHIP_TRAVERSAL() []antlr.TerminalNode {
	return s.GetTokens(ASLParserRELATIONSHIP_TRAVERSAL)
}

func (s *Relationship_navigationContext) RELATIONSHIP_TRAVERSAL(i int) antlr.TerminalNode {
	return s.GetToken(ASLParserRELATIONSHIP_TRAVERSAL, i)
}

func (s *Relationship_navigationContext) AllRelationship_spec() []IRelationship_specContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRelationship_specContext)(nil)).Elem())
	var tst = make([]IRelationship_specContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRelationship_specContext)
		}
	}

	return tst
}

func (s *Relationship_navigationContext) Relationship_spec(i int) IRelationship_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelationship_specContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRelationship_specContext)
}

func (s *Relationship_navigationContext) WHERE() antlr.TerminalNode {
	return s.GetToken(ASLParserWHERE, 0)
}

func (s *Relationship_navigationContext) Object_condition() IObject_conditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObject_conditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObject_conditionContext)
}

func (s *Relationship_navigationContext) Attribute() IAttributeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttributeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttributeContext)
}

func (s *Relationship_navigationContext) ORDERED_BY() antlr.TerminalNode {
	return s.GetToken(ASLParserORDERED_BY, 0)
}

func (s *Relationship_navigationContext) REVERSE_ORDERED_BY() antlr.TerminalNode {
	return s.GetToken(ASLParserREVERSE_ORDERED_BY, 0)
}

func (s *Relationship_navigationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Relationship_navigationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Relationship_navigationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterRelationship_navigation(s)
	}
}

func (s *Relationship_navigationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitRelationship_navigation(s)
	}
}

func (p *ASLParser) Relationship_navigation() (localctx IRelationship_navigationContext) {
	this := p
	_ = this

	localctx = NewRelationship_navigationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, ASLParserRULE_relationship_navigation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(450)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASLParserLOWERCASE_ID, ASLParserLOWERCASE_NUMBER_ID:
		{
			p.SetState(448)
			p.Variable()
		}

	case ASLParserL_CURLY:
		{
			p.SetState(449)
			p.Set_variable()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(452)
		p.Match(ASLParserEQ)
	}
	p.SetState(456)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASLParserLOWERCASE_ID, ASLParserLOWERCASE_NUMBER_ID:
		{
			p.SetState(453)
			p.Variable()
		}

	case ASLParserL_CURLY:
		{
			p.SetState(454)
			p.Set_variable()
		}

	case ASLParserTHIS:
		{
			p.SetState(455)
			p.Match(ASLParserTHIS)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(460)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == ASLParserRELATIONSHIP_TRAVERSAL {
		{
			p.SetState(458)
			p.Match(ASLParserRELATIONSHIP_TRAVERSAL)
		}
		{
			p.SetState(459)
			p.Relationship_spec()
		}

		p.SetState(462)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(466)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASLParserWHERE {
		{
			p.SetState(464)
			p.Match(ASLParserWHERE)
		}
		{
			p.SetState(465)
			p.Object_condition()
		}

	}
	p.SetState(470)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASLParserREVERSE_ORDERED_BY || _la == ASLParserORDERED_BY {
		{
			p.SetState(468)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ASLParserREVERSE_ORDERED_BY || _la == ASLParserORDERED_BY) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(469)
			p.Attribute()
		}

	}

	return localctx
}

// IAssociative_relationship_navigationContext is an interface to support dynamic dispatch.
type IAssociative_relationship_navigationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssociative_relationship_navigationContext differentiates from other interfaces.
	IsAssociative_relationship_navigationContext()
}

type Associative_relationship_navigationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssociative_relationship_navigationContext() *Associative_relationship_navigationContext {
	var p = new(Associative_relationship_navigationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_associative_relationship_navigation
	return p
}

func (*Associative_relationship_navigationContext) IsAssociative_relationship_navigationContext() {}

func NewAssociative_relationship_navigationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Associative_relationship_navigationContext {
	var p = new(Associative_relationship_navigationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_associative_relationship_navigation

	return p
}

func (s *Associative_relationship_navigationContext) GetParser() antlr.Parser { return s.parser }

func (s *Associative_relationship_navigationContext) AllVariable() []IVariableContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariableContext)(nil)).Elem())
	var tst = make([]IVariableContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariableContext)
		}
	}

	return tst
}

func (s *Associative_relationship_navigationContext) Variable(i int) IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *Associative_relationship_navigationContext) EQ() antlr.TerminalNode {
	return s.GetToken(ASLParserEQ, 0)
}

func (s *Associative_relationship_navigationContext) AND() antlr.TerminalNode {
	return s.GetToken(ASLParserAND, 0)
}

func (s *Associative_relationship_navigationContext) RELATIONSHIP_TRAVERSAL() antlr.TerminalNode {
	return s.GetToken(ASLParserRELATIONSHIP_TRAVERSAL, 0)
}

func (s *Associative_relationship_navigationContext) AllTHIS() []antlr.TerminalNode {
	return s.GetTokens(ASLParserTHIS)
}

func (s *Associative_relationship_navigationContext) THIS(i int) antlr.TerminalNode {
	return s.GetToken(ASLParserTHIS, i)
}

func (s *Associative_relationship_navigationContext) Qualified_relationship() IQualified_relationshipContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualified_relationshipContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualified_relationshipContext)
}

func (s *Associative_relationship_navigationContext) Relationship_role() IRelationship_roleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelationship_roleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRelationship_roleContext)
}

func (s *Associative_relationship_navigationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Associative_relationship_navigationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Associative_relationship_navigationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterAssociative_relationship_navigation(s)
	}
}

func (s *Associative_relationship_navigationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitAssociative_relationship_navigation(s)
	}
}

func (p *ASLParser) Associative_relationship_navigation() (localctx IAssociative_relationship_navigationContext) {
	this := p
	_ = this

	localctx = NewAssociative_relationship_navigationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, ASLParserRULE_associative_relationship_navigation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(472)
		p.Variable()
	}
	{
		p.SetState(473)
		p.Match(ASLParserEQ)
	}
	p.SetState(476)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASLParserLOWERCASE_ID, ASLParserLOWERCASE_NUMBER_ID:
		{
			p.SetState(474)
			p.Variable()
		}

	case ASLParserTHIS:
		{
			p.SetState(475)
			p.Match(ASLParserTHIS)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(478)
		p.Match(ASLParserAND)
	}
	p.SetState(481)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASLParserLOWERCASE_ID, ASLParserLOWERCASE_NUMBER_ID:
		{
			p.SetState(479)
			p.Variable()
		}

	case ASLParserTHIS:
		{
			p.SetState(480)
			p.Match(ASLParserTHIS)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(483)
		p.Match(ASLParserRELATIONSHIP_TRAVERSAL)
	}
	p.SetState(486)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 45, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(484)
			p.Qualified_relationship()
		}

	case 2:
		{
			p.SetState(485)
			p.Relationship_role()
		}

	}

	return localctx
}

// IRelationship_linkContext is an interface to support dynamic dispatch.
type IRelationship_linkContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelationship_linkContext differentiates from other interfaces.
	IsRelationship_linkContext()
}

type Relationship_linkContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationship_linkContext() *Relationship_linkContext {
	var p = new(Relationship_linkContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_relationship_link
	return p
}

func (*Relationship_linkContext) IsRelationship_linkContext() {}

func NewRelationship_linkContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Relationship_linkContext {
	var p = new(Relationship_linkContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_relationship_link

	return p
}

func (s *Relationship_linkContext) GetParser() antlr.Parser { return s.parser }

func (s *Relationship_linkContext) LINK() antlr.TerminalNode {
	return s.GetToken(ASLParserLINK, 0)
}

func (s *Relationship_linkContext) Relationship_spec() IRelationship_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelationship_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRelationship_specContext)
}

func (s *Relationship_linkContext) AllVariable() []IVariableContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariableContext)(nil)).Elem())
	var tst = make([]IVariableContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariableContext)
		}
	}

	return tst
}

func (s *Relationship_linkContext) Variable(i int) IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *Relationship_linkContext) THIS() antlr.TerminalNode {
	return s.GetToken(ASLParserTHIS, 0)
}

func (s *Relationship_linkContext) USING() antlr.TerminalNode {
	return s.GetToken(ASLParserUSING, 0)
}

func (s *Relationship_linkContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Relationship_linkContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Relationship_linkContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterRelationship_link(s)
	}
}

func (s *Relationship_linkContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitRelationship_link(s)
	}
}

func (p *ASLParser) Relationship_link() (localctx IRelationship_linkContext) {
	this := p
	_ = this

	localctx = NewRelationship_linkContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, ASLParserRULE_relationship_link)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(507)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 49, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(488)
			p.Match(ASLParserLINK)
		}
		p.SetState(491)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case ASLParserLOWERCASE_ID, ASLParserLOWERCASE_NUMBER_ID:
			{
				p.SetState(489)
				p.Variable()
			}

		case ASLParserTHIS:
			{
				p.SetState(490)
				p.Match(ASLParserTHIS)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(493)
			p.Relationship_spec()
		}
		{
			p.SetState(494)
			p.Variable()
		}
		p.SetState(497)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ASLParserUSING {
			{
				p.SetState(495)
				p.Match(ASLParserUSING)
			}
			{
				p.SetState(496)
				p.Variable()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(499)
			p.Match(ASLParserLINK)
		}
		{
			p.SetState(500)
			p.Variable()
		}
		{
			p.SetState(501)
			p.Relationship_spec()
		}
		{
			p.SetState(502)
			p.Match(ASLParserTHIS)
		}
		p.SetState(505)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ASLParserUSING {
			{
				p.SetState(503)
				p.Match(ASLParserUSING)
			}
			{
				p.SetState(504)
				p.Variable()
			}

		}

	}

	return localctx
}

// IRelationship_unlinkContext is an interface to support dynamic dispatch.
type IRelationship_unlinkContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelationship_unlinkContext differentiates from other interfaces.
	IsRelationship_unlinkContext()
}

type Relationship_unlinkContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationship_unlinkContext() *Relationship_unlinkContext {
	var p = new(Relationship_unlinkContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_relationship_unlink
	return p
}

func (*Relationship_unlinkContext) IsRelationship_unlinkContext() {}

func NewRelationship_unlinkContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Relationship_unlinkContext {
	var p = new(Relationship_unlinkContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_relationship_unlink

	return p
}

func (s *Relationship_unlinkContext) GetParser() antlr.Parser { return s.parser }

func (s *Relationship_unlinkContext) UNLINK() antlr.TerminalNode {
	return s.GetToken(ASLParserUNLINK, 0)
}

func (s *Relationship_unlinkContext) Relationship_spec() IRelationship_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelationship_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRelationship_specContext)
}

func (s *Relationship_unlinkContext) AllVariable() []IVariableContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariableContext)(nil)).Elem())
	var tst = make([]IVariableContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariableContext)
		}
	}

	return tst
}

func (s *Relationship_unlinkContext) Variable(i int) IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *Relationship_unlinkContext) THIS() antlr.TerminalNode {
	return s.GetToken(ASLParserTHIS, 0)
}

func (s *Relationship_unlinkContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Relationship_unlinkContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Relationship_unlinkContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterRelationship_unlink(s)
	}
}

func (s *Relationship_unlinkContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitRelationship_unlink(s)
	}
}

func (p *ASLParser) Relationship_unlink() (localctx IRelationship_unlinkContext) {
	this := p
	_ = this

	localctx = NewRelationship_unlinkContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, ASLParserRULE_relationship_unlink)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(522)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 51, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(509)
			p.Match(ASLParserUNLINK)
		}
		p.SetState(512)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case ASLParserLOWERCASE_ID, ASLParserLOWERCASE_NUMBER_ID:
			{
				p.SetState(510)
				p.Variable()
			}

		case ASLParserTHIS:
			{
				p.SetState(511)
				p.Match(ASLParserTHIS)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(514)
			p.Relationship_spec()
		}
		{
			p.SetState(515)
			p.Variable()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(517)
			p.Match(ASLParserUNLINK)
		}
		{
			p.SetState(518)
			p.Variable()
		}
		{
			p.SetState(519)
			p.Relationship_spec()
		}
		{
			p.SetState(520)
			p.Match(ASLParserTHIS)
		}

	}

	return localctx
}

// IRelationship_specContext is an interface to support dynamic dispatch.
type IRelationship_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelationship_specContext differentiates from other interfaces.
	IsRelationship_specContext()
}

type Relationship_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationship_specContext() *Relationship_specContext {
	var p = new(Relationship_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_relationship_spec
	return p
}

func (*Relationship_specContext) IsRelationship_specContext() {}

func NewRelationship_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Relationship_specContext {
	var p = new(Relationship_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_relationship_spec

	return p
}

func (s *Relationship_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Relationship_specContext) R_NUMBER() antlr.TerminalNode {
	return s.GetToken(ASLParserR_NUMBER, 0)
}

func (s *Relationship_specContext) Qualified_relationship() IQualified_relationshipContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualified_relationshipContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualified_relationshipContext)
}

func (s *Relationship_specContext) Relationship_role() IRelationship_roleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelationship_roleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRelationship_roleContext)
}

func (s *Relationship_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Relationship_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Relationship_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterRelationship_spec(s)
	}
}

func (s *Relationship_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitRelationship_spec(s)
	}
}

func (p *ASLParser) Relationship_spec() (localctx IRelationship_specContext) {
	this := p
	_ = this

	localctx = NewRelationship_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, ASLParserRULE_relationship_spec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(527)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 52, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(524)
			p.Match(ASLParserR_NUMBER)
		}

	case 2:
		{
			p.SetState(525)
			p.Qualified_relationship()
		}

	case 3:
		{
			p.SetState(526)
			p.Relationship_role()
		}

	}

	return localctx
}

// IQualified_relationshipContext is an interface to support dynamic dispatch.
type IQualified_relationshipContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQualified_relationshipContext differentiates from other interfaces.
	IsQualified_relationshipContext()
}

type Qualified_relationshipContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualified_relationshipContext() *Qualified_relationshipContext {
	var p = new(Qualified_relationshipContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_qualified_relationship
	return p
}

func (*Qualified_relationshipContext) IsQualified_relationshipContext() {}

func NewQualified_relationshipContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Qualified_relationshipContext {
	var p = new(Qualified_relationshipContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_qualified_relationship

	return p
}

func (s *Qualified_relationshipContext) GetParser() antlr.Parser { return s.parser }

func (s *Qualified_relationshipContext) R_NUMBER() antlr.TerminalNode {
	return s.GetToken(ASLParserR_NUMBER, 0)
}

func (s *Qualified_relationshipContext) DOT() antlr.TerminalNode {
	return s.GetToken(ASLParserDOT, 0)
}

func (s *Qualified_relationshipContext) Object_name() IObject_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObject_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObject_nameContext)
}

func (s *Qualified_relationshipContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Qualified_relationshipContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Qualified_relationshipContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterQualified_relationship(s)
	}
}

func (s *Qualified_relationshipContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitQualified_relationship(s)
	}
}

func (p *ASLParser) Qualified_relationship() (localctx IQualified_relationshipContext) {
	this := p
	_ = this

	localctx = NewQualified_relationshipContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, ASLParserRULE_qualified_relationship)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(529)
		p.Match(ASLParserR_NUMBER)
	}
	{
		p.SetState(530)
		p.Match(ASLParserDOT)
	}
	{
		p.SetState(531)
		p.Object_name()
	}

	return localctx
}

// IRelationship_roleContext is an interface to support dynamic dispatch.
type IRelationship_roleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelationship_roleContext differentiates from other interfaces.
	IsRelationship_roleContext()
}

type Relationship_roleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationship_roleContext() *Relationship_roleContext {
	var p = new(Relationship_roleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_relationship_role
	return p
}

func (*Relationship_roleContext) IsRelationship_roleContext() {}

func NewRelationship_roleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Relationship_roleContext {
	var p = new(Relationship_roleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_relationship_role

	return p
}

func (s *Relationship_roleContext) GetParser() antlr.Parser { return s.parser }

func (s *Relationship_roleContext) R_NUMBER() antlr.TerminalNode {
	return s.GetToken(ASLParserR_NUMBER, 0)
}

func (s *Relationship_roleContext) DOT() antlr.TerminalNode {
	return s.GetToken(ASLParserDOT, 0)
}

func (s *Relationship_roleContext) LOWERCASE_TEXT() antlr.TerminalNode {
	return s.GetToken(ASLParserLOWERCASE_TEXT, 0)
}

func (s *Relationship_roleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Relationship_roleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Relationship_roleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterRelationship_role(s)
	}
}

func (s *Relationship_roleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitRelationship_role(s)
	}
}

func (p *ASLParser) Relationship_role() (localctx IRelationship_roleContext) {
	this := p
	_ = this

	localctx = NewRelationship_roleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, ASLParserRULE_relationship_role)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(533)
		p.Match(ASLParserR_NUMBER)
	}
	{
		p.SetState(534)
		p.Match(ASLParserDOT)
	}
	{
		p.SetState(535)
		p.Match(ASLParserLOWERCASE_TEXT)
	}

	return localctx
}

// IEvent_generationContext is an interface to support dynamic dispatch.
type IEvent_generationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvent_generationContext differentiates from other interfaces.
	IsEvent_generationContext()
}

type Event_generationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvent_generationContext() *Event_generationContext {
	var p = new(Event_generationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_event_generation
	return p
}

func (*Event_generationContext) IsEvent_generationContext() {}

func NewEvent_generationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Event_generationContext {
	var p = new(Event_generationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_event_generation

	return p
}

func (s *Event_generationContext) GetParser() antlr.Parser { return s.parser }

func (s *Event_generationContext) Internal_event_generation() IInternal_event_generationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInternal_event_generationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInternal_event_generationContext)
}

func (s *Event_generationContext) External_event_generation() IExternal_event_generationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExternal_event_generationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExternal_event_generationContext)
}

func (s *Event_generationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Event_generationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Event_generationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterEvent_generation(s)
	}
}

func (s *Event_generationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitEvent_generation(s)
	}
}

func (p *ASLParser) Event_generation() (localctx IEvent_generationContext) {
	this := p
	_ = this

	localctx = NewEvent_generationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, ASLParserRULE_event_generation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(539)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 53, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(537)
			p.Internal_event_generation()
		}

	case 2:
		{
			p.SetState(538)
			p.External_event_generation()
		}

	}

	return localctx
}

// IInternal_event_generationContext is an interface to support dynamic dispatch.
type IInternal_event_generationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInternal_event_generationContext differentiates from other interfaces.
	IsInternal_event_generationContext()
}

type Internal_event_generationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInternal_event_generationContext() *Internal_event_generationContext {
	var p = new(Internal_event_generationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_internal_event_generation
	return p
}

func (*Internal_event_generationContext) IsInternal_event_generationContext() {}

func NewInternal_event_generationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Internal_event_generationContext {
	var p = new(Internal_event_generationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_internal_event_generation

	return p
}

func (s *Internal_event_generationContext) GetParser() antlr.Parser { return s.parser }

func (s *Internal_event_generationContext) GENERATE() antlr.TerminalNode {
	return s.GetToken(ASLParserGENERATE, 0)
}

func (s *Internal_event_generationContext) Event_specification() IEvent_specificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvent_specificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEvent_specificationContext)
}

func (s *Internal_event_generationContext) L_PAREN() antlr.TerminalNode {
	return s.GetToken(ASLParserL_PAREN, 0)
}

func (s *Internal_event_generationContext) R_PAREN() antlr.TerminalNode {
	return s.GetToken(ASLParserR_PAREN, 0)
}

func (s *Internal_event_generationContext) SEMI_COLON() antlr.TerminalNode {
	return s.GetToken(ASLParserSEMI_COLON, 0)
}

func (s *Internal_event_generationContext) Event_parameters() IEvent_parametersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvent_parametersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEvent_parametersContext)
}

func (s *Internal_event_generationContext) TO() antlr.TerminalNode {
	return s.GetToken(ASLParserTO, 0)
}

func (s *Internal_event_generationContext) Variable() IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *Internal_event_generationContext) THIS() antlr.TerminalNode {
	return s.GetToken(ASLParserTHIS, 0)
}

func (s *Internal_event_generationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Internal_event_generationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Internal_event_generationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterInternal_event_generation(s)
	}
}

func (s *Internal_event_generationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitInternal_event_generation(s)
	}
}

func (p *ASLParser) Internal_event_generation() (localctx IInternal_event_generationContext) {
	this := p
	_ = this

	localctx = NewInternal_event_generationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, ASLParserRULE_internal_event_generation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(541)
		p.Match(ASLParserGENERATE)
	}
	{
		p.SetState(542)
		p.Event_specification()
	}
	{
		p.SetState(543)
		p.Match(ASLParserL_PAREN)
	}
	p.SetState(545)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASLParserTHIS || _la == ASLParserUNDEFINED || (((_la-91)&-(0x1f+1)) == 0 && ((1<<uint((_la-91)))&((1<<(ASLParserDATE_VALUE-91))|(1<<(ASLParserTIME_VALUE-91))|(1<<(ASLParserINTEGER_VALUE-91))|(1<<(ASLParserREAL_VALUE-91))|(1<<(ASLParserBOOLEAN_VALUE-91))|(1<<(ASLParserLOWERCASE_TEXT-91))|(1<<(ASLParserOTHER_TEXT-91))|(1<<(ASLParserQUOTE-91))|(1<<(ASLParserUPPERCASE_ID-91))|(1<<(ASLParserLOWERCASE_ID-91))|(1<<(ASLParserLOWERCASE_NUMBER_ID-91))|(1<<(ASLParserUPPERCASE_OR_NUMBER_ID-91)))) != 0) {
		{
			p.SetState(544)
			p.Event_parameters()
		}

	}
	{
		p.SetState(547)
		p.Match(ASLParserR_PAREN)
	}
	{
		p.SetState(548)
		p.Match(ASLParserSEMI_COLON)
	}
	p.SetState(554)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASLParserTO {
		{
			p.SetState(549)
			p.Match(ASLParserTO)
		}
		p.SetState(552)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case ASLParserLOWERCASE_ID, ASLParserLOWERCASE_NUMBER_ID:
			{
				p.SetState(550)
				p.Variable()
			}

		case ASLParserTHIS:
			{
				p.SetState(551)
				p.Match(ASLParserTHIS)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	}

	return localctx
}

// IExternal_event_generationContext is an interface to support dynamic dispatch.
type IExternal_event_generationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExternal_event_generationContext differentiates from other interfaces.
	IsExternal_event_generationContext()
}

type External_event_generationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExternal_event_generationContext() *External_event_generationContext {
	var p = new(External_event_generationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_external_event_generation
	return p
}

func (*External_event_generationContext) IsExternal_event_generationContext() {}

func NewExternal_event_generationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *External_event_generationContext {
	var p = new(External_event_generationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_external_event_generation

	return p
}

func (s *External_event_generationContext) GetParser() antlr.Parser { return s.parser }

func (s *External_event_generationContext) GENERATE() antlr.TerminalNode {
	return s.GetToken(ASLParserGENERATE, 0)
}

func (s *External_event_generationContext) External_event_specification() IExternal_event_specificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExternal_event_specificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExternal_event_specificationContext)
}

func (s *External_event_generationContext) L_PAREN() antlr.TerminalNode {
	return s.GetToken(ASLParserL_PAREN, 0)
}

func (s *External_event_generationContext) R_PAREN() antlr.TerminalNode {
	return s.GetToken(ASLParserR_PAREN, 0)
}

func (s *External_event_generationContext) SEMI_COLON() antlr.TerminalNode {
	return s.GetToken(ASLParserSEMI_COLON, 0)
}

func (s *External_event_generationContext) Event_parameters() IEvent_parametersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvent_parametersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEvent_parametersContext)
}

func (s *External_event_generationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *External_event_generationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *External_event_generationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterExternal_event_generation(s)
	}
}

func (s *External_event_generationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitExternal_event_generation(s)
	}
}

func (p *ASLParser) External_event_generation() (localctx IExternal_event_generationContext) {
	this := p
	_ = this

	localctx = NewExternal_event_generationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, ASLParserRULE_external_event_generation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(556)
		p.Match(ASLParserGENERATE)
	}
	{
		p.SetState(557)
		p.External_event_specification()
	}
	{
		p.SetState(558)
		p.Match(ASLParserL_PAREN)
	}
	p.SetState(560)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASLParserTHIS || _la == ASLParserUNDEFINED || (((_la-91)&-(0x1f+1)) == 0 && ((1<<uint((_la-91)))&((1<<(ASLParserDATE_VALUE-91))|(1<<(ASLParserTIME_VALUE-91))|(1<<(ASLParserINTEGER_VALUE-91))|(1<<(ASLParserREAL_VALUE-91))|(1<<(ASLParserBOOLEAN_VALUE-91))|(1<<(ASLParserLOWERCASE_TEXT-91))|(1<<(ASLParserOTHER_TEXT-91))|(1<<(ASLParserQUOTE-91))|(1<<(ASLParserUPPERCASE_ID-91))|(1<<(ASLParserLOWERCASE_ID-91))|(1<<(ASLParserLOWERCASE_NUMBER_ID-91))|(1<<(ASLParserUPPERCASE_OR_NUMBER_ID-91)))) != 0) {
		{
			p.SetState(559)
			p.Event_parameters()
		}

	}
	{
		p.SetState(562)
		p.Match(ASLParserR_PAREN)
	}
	{
		p.SetState(563)
		p.Match(ASLParserSEMI_COLON)
	}

	return localctx
}

// IEvent_specificationContext is an interface to support dynamic dispatch.
type IEvent_specificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvent_specificationContext differentiates from other interfaces.
	IsEvent_specificationContext()
}

type Event_specificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvent_specificationContext() *Event_specificationContext {
	var p = new(Event_specificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_event_specification
	return p
}

func (*Event_specificationContext) IsEvent_specificationContext() {}

func NewEvent_specificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Event_specificationContext {
	var p = new(Event_specificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_event_specification

	return p
}

func (s *Event_specificationContext) GetParser() antlr.Parser { return s.parser }

func (s *Event_specificationContext) UPPERCASE_NUMBER_ID() antlr.TerminalNode {
	return s.GetToken(ASLParserUPPERCASE_NUMBER_ID, 0)
}

func (s *Event_specificationContext) COLON() antlr.TerminalNode {
	return s.GetToken(ASLParserCOLON, 0)
}

func (s *Event_specificationContext) LEADING_UPPERCASE_ID() antlr.TerminalNode {
	return s.GetToken(ASLParserLEADING_UPPERCASE_ID, 0)
}

func (s *Event_specificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Event_specificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Event_specificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterEvent_specification(s)
	}
}

func (s *Event_specificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitEvent_specification(s)
	}
}

func (p *ASLParser) Event_specification() (localctx IEvent_specificationContext) {
	this := p
	_ = this

	localctx = NewEvent_specificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, ASLParserRULE_event_specification)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(565)
		p.Match(ASLParserUPPERCASE_NUMBER_ID)
	}
	{
		p.SetState(566)
		p.Match(ASLParserCOLON)
	}
	{
		p.SetState(567)
		p.Match(ASLParserLEADING_UPPERCASE_ID)
	}

	return localctx
}

// IExternal_event_specificationContext is an interface to support dynamic dispatch.
type IExternal_event_specificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExternal_event_specificationContext differentiates from other interfaces.
	IsExternal_event_specificationContext()
}

type External_event_specificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExternal_event_specificationContext() *External_event_specificationContext {
	var p = new(External_event_specificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_external_event_specification
	return p
}

func (*External_event_specificationContext) IsExternal_event_specificationContext() {}

func NewExternal_event_specificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *External_event_specificationContext {
	var p = new(External_event_specificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_external_event_specification

	return p
}

func (s *External_event_specificationContext) GetParser() antlr.Parser { return s.parser }

func (s *External_event_specificationContext) UPPERCASE_NUMBER_ID() antlr.TerminalNode {
	return s.GetToken(ASLParserUPPERCASE_NUMBER_ID, 0)
}

func (s *External_event_specificationContext) COLON() antlr.TerminalNode {
	return s.GetToken(ASLParserCOLON, 0)
}

func (s *External_event_specificationContext) LEADING_UPPERCASE_ID() antlr.TerminalNode {
	return s.GetToken(ASLParserLEADING_UPPERCASE_ID, 0)
}

func (s *External_event_specificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *External_event_specificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *External_event_specificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterExternal_event_specification(s)
	}
}

func (s *External_event_specificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitExternal_event_specification(s)
	}
}

func (p *ASLParser) External_event_specification() (localctx IExternal_event_specificationContext) {
	this := p
	_ = this

	localctx = NewExternal_event_specificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, ASLParserRULE_external_event_specification)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(569)
		p.Match(ASLParserUPPERCASE_NUMBER_ID)
	}
	{
		p.SetState(570)
		p.Match(ASLParserCOLON)
	}
	{
		p.SetState(571)
		p.Match(ASLParserLEADING_UPPERCASE_ID)
	}

	return localctx
}

// IEvent_parametersContext is an interface to support dynamic dispatch.
type IEvent_parametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvent_parametersContext differentiates from other interfaces.
	IsEvent_parametersContext()
}

type Event_parametersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvent_parametersContext() *Event_parametersContext {
	var p = new(Event_parametersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_event_parameters
	return p
}

func (*Event_parametersContext) IsEvent_parametersContext() {}

func NewEvent_parametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Event_parametersContext {
	var p = new(Event_parametersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_event_parameters

	return p
}

func (s *Event_parametersContext) GetParser() antlr.Parser { return s.parser }

func (s *Event_parametersContext) AllEvent_parameter() []IEvent_parameterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEvent_parameterContext)(nil)).Elem())
	var tst = make([]IEvent_parameterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEvent_parameterContext)
		}
	}

	return tst
}

func (s *Event_parametersContext) Event_parameter(i int) IEvent_parameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvent_parameterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEvent_parameterContext)
}

func (s *Event_parametersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ASLParserCOMMA)
}

func (s *Event_parametersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ASLParserCOMMA, i)
}

func (s *Event_parametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Event_parametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Event_parametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterEvent_parameters(s)
	}
}

func (s *Event_parametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitEvent_parameters(s)
	}
}

func (p *ASLParser) Event_parameters() (localctx IEvent_parametersContext) {
	this := p
	_ = this

	localctx = NewEvent_parametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, ASLParserRULE_event_parameters)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(573)
		p.Event_parameter()
	}
	p.SetState(578)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ASLParserCOMMA {
		{
			p.SetState(574)
			p.Match(ASLParserCOMMA)
		}
		{
			p.SetState(575)
			p.Event_parameter()
		}

		p.SetState(580)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IEvent_parameterContext is an interface to support dynamic dispatch.
type IEvent_parameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvent_parameterContext differentiates from other interfaces.
	IsEvent_parameterContext()
}

type Event_parameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvent_parameterContext() *Event_parameterContext {
	var p = new(Event_parameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_event_parameter
	return p
}

func (*Event_parameterContext) IsEvent_parameterContext() {}

func NewEvent_parameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Event_parameterContext {
	var p = new(Event_parameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_event_parameter

	return p
}

func (s *Event_parameterContext) GetParser() antlr.Parser { return s.parser }

func (s *Event_parameterContext) Variable() IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *Event_parameterContext) Constant() IConstantContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstantContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *Event_parameterContext) THIS() antlr.TerminalNode {
	return s.GetToken(ASLParserTHIS, 0)
}

func (s *Event_parameterContext) Object_attribute() IObject_attributeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObject_attributeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObject_attributeContext)
}

func (s *Event_parameterContext) Structure_field() IStructure_fieldContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStructure_fieldContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStructure_fieldContext)
}

func (s *Event_parameterContext) UNDEFINED() antlr.TerminalNode {
	return s.GetToken(ASLParserUNDEFINED, 0)
}

func (s *Event_parameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Event_parameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Event_parameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterEvent_parameter(s)
	}
}

func (s *Event_parameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitEvent_parameter(s)
	}
}

func (p *ASLParser) Event_parameter() (localctx IEvent_parameterContext) {
	this := p
	_ = this

	localctx = NewEvent_parameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, ASLParserRULE_event_parameter)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(587)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 59, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(581)
			p.Variable()
		}

	case 2:
		{
			p.SetState(582)
			p.Constant()
		}

	case 3:
		{
			p.SetState(583)
			p.Match(ASLParserTHIS)
		}

	case 4:
		{
			p.SetState(584)
			p.Object_attribute()
		}

	case 5:
		{
			p.SetState(585)
			p.Structure_field()
		}

	case 6:
		{
			p.SetState(586)
			p.Match(ASLParserUNDEFINED)
		}

	}

	return localctx
}

// IOperation_invocationContext is an interface to support dynamic dispatch.
type IOperation_invocationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOperation_invocationContext differentiates from other interfaces.
	IsOperation_invocationContext()
}

type Operation_invocationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOperation_invocationContext() *Operation_invocationContext {
	var p = new(Operation_invocationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_operation_invocation
	return p
}

func (*Operation_invocationContext) IsOperation_invocationContext() {}

func NewOperation_invocationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Operation_invocationContext {
	var p = new(Operation_invocationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_operation_invocation

	return p
}

func (s *Operation_invocationContext) GetParser() antlr.Parser { return s.parser }

func (s *Operation_invocationContext) Object_operation() IObject_operationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObject_operationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObject_operationContext)
}

func (s *Operation_invocationContext) Domain_operation() IDomain_operationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDomain_operationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDomain_operationContext)
}

func (s *Operation_invocationContext) Bridge_operation() IBridge_operationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBridge_operationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBridge_operationContext)
}

func (s *Operation_invocationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Operation_invocationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Operation_invocationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterOperation_invocation(s)
	}
}

func (s *Operation_invocationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitOperation_invocation(s)
	}
}

func (p *ASLParser) Operation_invocation() (localctx IOperation_invocationContext) {
	this := p
	_ = this

	localctx = NewOperation_invocationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, ASLParserRULE_operation_invocation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(592)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 60, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(589)
			p.Object_operation()
		}

	case 2:
		{
			p.SetState(590)
			p.Domain_operation()
		}

	case 3:
		{
			p.SetState(591)
			p.Bridge_operation()
		}

	}

	return localctx
}

// IObject_operationContext is an interface to support dynamic dispatch.
type IObject_operationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObject_operationContext differentiates from other interfaces.
	IsObject_operationContext()
}

type Object_operationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObject_operationContext() *Object_operationContext {
	var p = new(Object_operationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_object_operation
	return p
}

func (*Object_operationContext) IsObject_operationContext() {}

func NewObject_operationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Object_operationContext {
	var p = new(Object_operationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_object_operation

	return p
}

func (s *Object_operationContext) GetParser() antlr.Parser { return s.parser }

func (s *Object_operationContext) AllL_SQUARE() []antlr.TerminalNode {
	return s.GetTokens(ASLParserL_SQUARE)
}

func (s *Object_operationContext) L_SQUARE(i int) antlr.TerminalNode {
	return s.GetToken(ASLParserL_SQUARE, i)
}

func (s *Object_operationContext) AllR_SQUARE() []antlr.TerminalNode {
	return s.GetTokens(ASLParserR_SQUARE)
}

func (s *Object_operationContext) R_SQUARE(i int) antlr.TerminalNode {
	return s.GetToken(ASLParserR_SQUARE, i)
}

func (s *Object_operationContext) EQ() antlr.TerminalNode {
	return s.GetToken(ASLParserEQ, 0)
}

func (s *Object_operationContext) Oo_specification() IOo_specificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOo_specificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOo_specificationContext)
}

func (s *Object_operationContext) Output_parameter_list() IOutput_parameter_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOutput_parameter_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOutput_parameter_listContext)
}

func (s *Object_operationContext) Input_parameter_list() IInput_parameter_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInput_parameter_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInput_parameter_listContext)
}

func (s *Object_operationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Object_operationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Object_operationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterObject_operation(s)
	}
}

func (s *Object_operationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitObject_operation(s)
	}
}

func (p *ASLParser) Object_operation() (localctx IObject_operationContext) {
	this := p
	_ = this

	localctx = NewObject_operationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, ASLParserRULE_object_operation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(594)
		p.Match(ASLParserL_SQUARE)
	}
	p.SetState(596)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASLParserTHIS || (((_la-76)&-(0x1f+1)) == 0 && ((1<<uint((_la-76)))&((1<<(ASLParserL_CURLY-76))|(1<<(ASLParserLOWERCASE_ID-76))|(1<<(ASLParserLOWERCASE_NUMBER_ID-76)))) != 0) {
		{
			p.SetState(595)
			p.Output_parameter_list()
		}

	}
	{
		p.SetState(598)
		p.Match(ASLParserR_SQUARE)
	}
	{
		p.SetState(599)
		p.Match(ASLParserEQ)
	}
	{
		p.SetState(600)
		p.Oo_specification()
	}
	{
		p.SetState(601)
		p.Match(ASLParserL_SQUARE)
	}
	p.SetState(603)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASLParserTHIS || (((_la-76)&-(0x1f+1)) == 0 && ((1<<uint((_la-76)))&((1<<(ASLParserL_CURLY-76))|(1<<(ASLParserDATE_VALUE-76))|(1<<(ASLParserTIME_VALUE-76))|(1<<(ASLParserINTEGER_VALUE-76))|(1<<(ASLParserREAL_VALUE-76))|(1<<(ASLParserBOOLEAN_VALUE-76))|(1<<(ASLParserLOWERCASE_TEXT-76))|(1<<(ASLParserOTHER_TEXT-76))|(1<<(ASLParserQUOTE-76))|(1<<(ASLParserUPPERCASE_ID-76))|(1<<(ASLParserLOWERCASE_ID-76))|(1<<(ASLParserLOWERCASE_NUMBER_ID-76)))) != 0) || _la == ASLParserUPPERCASE_OR_NUMBER_ID {
		{
			p.SetState(602)
			p.Input_parameter_list()
		}

	}
	{
		p.SetState(605)
		p.Match(ASLParserR_SQUARE)
	}

	return localctx
}

// IDomain_operationContext is an interface to support dynamic dispatch.
type IDomain_operationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDomain_operationContext differentiates from other interfaces.
	IsDomain_operationContext()
}

type Domain_operationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDomain_operationContext() *Domain_operationContext {
	var p = new(Domain_operationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_domain_operation
	return p
}

func (*Domain_operationContext) IsDomain_operationContext() {}

func NewDomain_operationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Domain_operationContext {
	var p = new(Domain_operationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_domain_operation

	return p
}

func (s *Domain_operationContext) GetParser() antlr.Parser { return s.parser }

func (s *Domain_operationContext) AllL_SQUARE() []antlr.TerminalNode {
	return s.GetTokens(ASLParserL_SQUARE)
}

func (s *Domain_operationContext) L_SQUARE(i int) antlr.TerminalNode {
	return s.GetToken(ASLParserL_SQUARE, i)
}

func (s *Domain_operationContext) AllR_SQUARE() []antlr.TerminalNode {
	return s.GetTokens(ASLParserR_SQUARE)
}

func (s *Domain_operationContext) R_SQUARE(i int) antlr.TerminalNode {
	return s.GetToken(ASLParserR_SQUARE, i)
}

func (s *Domain_operationContext) EQ() antlr.TerminalNode {
	return s.GetToken(ASLParserEQ, 0)
}

func (s *Domain_operationContext) Do_specification() IDo_specificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDo_specificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDo_specificationContext)
}

func (s *Domain_operationContext) Output_parameter_list() IOutput_parameter_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOutput_parameter_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOutput_parameter_listContext)
}

func (s *Domain_operationContext) Input_parameter_list() IInput_parameter_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInput_parameter_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInput_parameter_listContext)
}

func (s *Domain_operationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Domain_operationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Domain_operationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterDomain_operation(s)
	}
}

func (s *Domain_operationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitDomain_operation(s)
	}
}

func (p *ASLParser) Domain_operation() (localctx IDomain_operationContext) {
	this := p
	_ = this

	localctx = NewDomain_operationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, ASLParserRULE_domain_operation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(607)
		p.Match(ASLParserL_SQUARE)
	}
	p.SetState(609)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASLParserTHIS || (((_la-76)&-(0x1f+1)) == 0 && ((1<<uint((_la-76)))&((1<<(ASLParserL_CURLY-76))|(1<<(ASLParserLOWERCASE_ID-76))|(1<<(ASLParserLOWERCASE_NUMBER_ID-76)))) != 0) {
		{
			p.SetState(608)
			p.Output_parameter_list()
		}

	}
	{
		p.SetState(611)
		p.Match(ASLParserR_SQUARE)
	}
	{
		p.SetState(612)
		p.Match(ASLParserEQ)
	}
	{
		p.SetState(613)
		p.Do_specification()
	}
	{
		p.SetState(614)
		p.Match(ASLParserL_SQUARE)
	}
	p.SetState(616)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASLParserTHIS || (((_la-76)&-(0x1f+1)) == 0 && ((1<<uint((_la-76)))&((1<<(ASLParserL_CURLY-76))|(1<<(ASLParserDATE_VALUE-76))|(1<<(ASLParserTIME_VALUE-76))|(1<<(ASLParserINTEGER_VALUE-76))|(1<<(ASLParserREAL_VALUE-76))|(1<<(ASLParserBOOLEAN_VALUE-76))|(1<<(ASLParserLOWERCASE_TEXT-76))|(1<<(ASLParserOTHER_TEXT-76))|(1<<(ASLParserQUOTE-76))|(1<<(ASLParserUPPERCASE_ID-76))|(1<<(ASLParserLOWERCASE_ID-76))|(1<<(ASLParserLOWERCASE_NUMBER_ID-76)))) != 0) || _la == ASLParserUPPERCASE_OR_NUMBER_ID {
		{
			p.SetState(615)
			p.Input_parameter_list()
		}

	}
	{
		p.SetState(618)
		p.Match(ASLParserR_SQUARE)
	}

	return localctx
}

// IBridge_operationContext is an interface to support dynamic dispatch.
type IBridge_operationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBridge_operationContext differentiates from other interfaces.
	IsBridge_operationContext()
}

type Bridge_operationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBridge_operationContext() *Bridge_operationContext {
	var p = new(Bridge_operationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_bridge_operation
	return p
}

func (*Bridge_operationContext) IsBridge_operationContext() {}

func NewBridge_operationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bridge_operationContext {
	var p = new(Bridge_operationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_bridge_operation

	return p
}

func (s *Bridge_operationContext) GetParser() antlr.Parser { return s.parser }

func (s *Bridge_operationContext) AllL_SQUARE() []antlr.TerminalNode {
	return s.GetTokens(ASLParserL_SQUARE)
}

func (s *Bridge_operationContext) L_SQUARE(i int) antlr.TerminalNode {
	return s.GetToken(ASLParserL_SQUARE, i)
}

func (s *Bridge_operationContext) AllR_SQUARE() []antlr.TerminalNode {
	return s.GetTokens(ASLParserR_SQUARE)
}

func (s *Bridge_operationContext) R_SQUARE(i int) antlr.TerminalNode {
	return s.GetToken(ASLParserR_SQUARE, i)
}

func (s *Bridge_operationContext) EQ() antlr.TerminalNode {
	return s.GetToken(ASLParserEQ, 0)
}

func (s *Bridge_operationContext) Bo_specification() IBo_specificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBo_specificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBo_specificationContext)
}

func (s *Bridge_operationContext) Output_parameter_list() IOutput_parameter_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOutput_parameter_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOutput_parameter_listContext)
}

func (s *Bridge_operationContext) Input_parameter_list() IInput_parameter_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInput_parameter_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInput_parameter_listContext)
}

func (s *Bridge_operationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bridge_operationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Bridge_operationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterBridge_operation(s)
	}
}

func (s *Bridge_operationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitBridge_operation(s)
	}
}

func (p *ASLParser) Bridge_operation() (localctx IBridge_operationContext) {
	this := p
	_ = this

	localctx = NewBridge_operationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, ASLParserRULE_bridge_operation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(620)
		p.Match(ASLParserL_SQUARE)
	}
	p.SetState(622)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASLParserTHIS || (((_la-76)&-(0x1f+1)) == 0 && ((1<<uint((_la-76)))&((1<<(ASLParserL_CURLY-76))|(1<<(ASLParserLOWERCASE_ID-76))|(1<<(ASLParserLOWERCASE_NUMBER_ID-76)))) != 0) {
		{
			p.SetState(621)
			p.Output_parameter_list()
		}

	}
	{
		p.SetState(624)
		p.Match(ASLParserR_SQUARE)
	}
	{
		p.SetState(625)
		p.Match(ASLParserEQ)
	}
	{
		p.SetState(626)
		p.Bo_specification()
	}
	{
		p.SetState(627)
		p.Match(ASLParserL_SQUARE)
	}
	p.SetState(629)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASLParserTHIS || (((_la-76)&-(0x1f+1)) == 0 && ((1<<uint((_la-76)))&((1<<(ASLParserL_CURLY-76))|(1<<(ASLParserDATE_VALUE-76))|(1<<(ASLParserTIME_VALUE-76))|(1<<(ASLParserINTEGER_VALUE-76))|(1<<(ASLParserREAL_VALUE-76))|(1<<(ASLParserBOOLEAN_VALUE-76))|(1<<(ASLParserLOWERCASE_TEXT-76))|(1<<(ASLParserOTHER_TEXT-76))|(1<<(ASLParserQUOTE-76))|(1<<(ASLParserUPPERCASE_ID-76))|(1<<(ASLParserLOWERCASE_ID-76))|(1<<(ASLParserLOWERCASE_NUMBER_ID-76)))) != 0) || _la == ASLParserUPPERCASE_OR_NUMBER_ID {
		{
			p.SetState(628)
			p.Input_parameter_list()
		}

	}
	{
		p.SetState(631)
		p.Match(ASLParserR_SQUARE)
	}

	return localctx
}

// IOo_specificationContext is an interface to support dynamic dispatch.
type IOo_specificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOo_specificationContext differentiates from other interfaces.
	IsOo_specificationContext()
}

type Oo_specificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOo_specificationContext() *Oo_specificationContext {
	var p = new(Oo_specificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_oo_specification
	return p
}

func (*Oo_specificationContext) IsOo_specificationContext() {}

func NewOo_specificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Oo_specificationContext {
	var p = new(Oo_specificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_oo_specification

	return p
}

func (s *Oo_specificationContext) GetParser() antlr.Parser { return s.parser }

func (s *Oo_specificationContext) UPPERCASE_NUMBER_ID() antlr.TerminalNode {
	return s.GetToken(ASLParserUPPERCASE_NUMBER_ID, 0)
}

func (s *Oo_specificationContext) COLON() antlr.TerminalNode {
	return s.GetToken(ASLParserCOLON, 0)
}

func (s *Oo_specificationContext) LEADING_UPPERCASE_ID() antlr.TerminalNode {
	return s.GetToken(ASLParserLEADING_UPPERCASE_ID, 0)
}

func (s *Oo_specificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Oo_specificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Oo_specificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterOo_specification(s)
	}
}

func (s *Oo_specificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitOo_specification(s)
	}
}

func (p *ASLParser) Oo_specification() (localctx IOo_specificationContext) {
	this := p
	_ = this

	localctx = NewOo_specificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, ASLParserRULE_oo_specification)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(633)
		p.Match(ASLParserUPPERCASE_NUMBER_ID)
	}
	{
		p.SetState(634)
		p.Match(ASLParserCOLON)
	}
	{
		p.SetState(635)
		p.Match(ASLParserLEADING_UPPERCASE_ID)
	}

	return localctx
}

// IDo_specificationContext is an interface to support dynamic dispatch.
type IDo_specificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDo_specificationContext differentiates from other interfaces.
	IsDo_specificationContext()
}

type Do_specificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDo_specificationContext() *Do_specificationContext {
	var p = new(Do_specificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_do_specification
	return p
}

func (*Do_specificationContext) IsDo_specificationContext() {}

func NewDo_specificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Do_specificationContext {
	var p = new(Do_specificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_do_specification

	return p
}

func (s *Do_specificationContext) GetParser() antlr.Parser { return s.parser }

func (s *Do_specificationContext) UPPERCASE_NUMBER_ID() antlr.TerminalNode {
	return s.GetToken(ASLParserUPPERCASE_NUMBER_ID, 0)
}

func (s *Do_specificationContext) COLON() antlr.TerminalNode {
	return s.GetToken(ASLParserCOLON, 0)
}

func (s *Do_specificationContext) LEADING_UPPERCASE_ID() antlr.TerminalNode {
	return s.GetToken(ASLParserLEADING_UPPERCASE_ID, 0)
}

func (s *Do_specificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Do_specificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Do_specificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterDo_specification(s)
	}
}

func (s *Do_specificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitDo_specification(s)
	}
}

func (p *ASLParser) Do_specification() (localctx IDo_specificationContext) {
	this := p
	_ = this

	localctx = NewDo_specificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, ASLParserRULE_do_specification)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(637)
		p.Match(ASLParserUPPERCASE_NUMBER_ID)
	}
	{
		p.SetState(638)
		p.Match(ASLParserCOLON)
	}
	{
		p.SetState(639)
		p.Match(ASLParserLEADING_UPPERCASE_ID)
	}

	return localctx
}

// IBo_specificationContext is an interface to support dynamic dispatch.
type IBo_specificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBo_specificationContext differentiates from other interfaces.
	IsBo_specificationContext()
}

type Bo_specificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBo_specificationContext() *Bo_specificationContext {
	var p = new(Bo_specificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_bo_specification
	return p
}

func (*Bo_specificationContext) IsBo_specificationContext() {}

func NewBo_specificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bo_specificationContext {
	var p = new(Bo_specificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_bo_specification

	return p
}

func (s *Bo_specificationContext) GetParser() antlr.Parser { return s.parser }

func (s *Bo_specificationContext) UPPERCASE_NUMBER_ID() antlr.TerminalNode {
	return s.GetToken(ASLParserUPPERCASE_NUMBER_ID, 0)
}

func (s *Bo_specificationContext) COLON() antlr.TerminalNode {
	return s.GetToken(ASLParserCOLON, 0)
}

func (s *Bo_specificationContext) LEADING_UPPERCASE_ID() antlr.TerminalNode {
	return s.GetToken(ASLParserLEADING_UPPERCASE_ID, 0)
}

func (s *Bo_specificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bo_specificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Bo_specificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterBo_specification(s)
	}
}

func (s *Bo_specificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitBo_specification(s)
	}
}

func (p *ASLParser) Bo_specification() (localctx IBo_specificationContext) {
	this := p
	_ = this

	localctx = NewBo_specificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, ASLParserRULE_bo_specification)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(641)
		p.Match(ASLParserUPPERCASE_NUMBER_ID)
	}
	{
		p.SetState(642)
		p.Match(ASLParserCOLON)
	}
	{
		p.SetState(643)
		p.Match(ASLParserLEADING_UPPERCASE_ID)
	}

	return localctx
}

// IOutput_parameter_listContext is an interface to support dynamic dispatch.
type IOutput_parameter_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOutput_parameter_listContext differentiates from other interfaces.
	IsOutput_parameter_listContext()
}

type Output_parameter_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOutput_parameter_listContext() *Output_parameter_listContext {
	var p = new(Output_parameter_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_output_parameter_list
	return p
}

func (*Output_parameter_listContext) IsOutput_parameter_listContext() {}

func NewOutput_parameter_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Output_parameter_listContext {
	var p = new(Output_parameter_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_output_parameter_list

	return p
}

func (s *Output_parameter_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Output_parameter_listContext) AllOutput_parameter() []IOutput_parameterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOutput_parameterContext)(nil)).Elem())
	var tst = make([]IOutput_parameterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOutput_parameterContext)
		}
	}

	return tst
}

func (s *Output_parameter_listContext) Output_parameter(i int) IOutput_parameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOutput_parameterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOutput_parameterContext)
}

func (s *Output_parameter_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ASLParserCOMMA)
}

func (s *Output_parameter_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ASLParserCOMMA, i)
}

func (s *Output_parameter_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Output_parameter_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Output_parameter_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterOutput_parameter_list(s)
	}
}

func (s *Output_parameter_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitOutput_parameter_list(s)
	}
}

func (p *ASLParser) Output_parameter_list() (localctx IOutput_parameter_listContext) {
	this := p
	_ = this

	localctx = NewOutput_parameter_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, ASLParserRULE_output_parameter_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(645)
		p.Output_parameter()
	}
	p.SetState(650)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ASLParserCOMMA {
		{
			p.SetState(646)
			p.Match(ASLParserCOMMA)
		}
		{
			p.SetState(647)
			p.Output_parameter()
		}

		p.SetState(652)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IOutput_parameterContext is an interface to support dynamic dispatch.
type IOutput_parameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOutput_parameterContext differentiates from other interfaces.
	IsOutput_parameterContext()
}

type Output_parameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOutput_parameterContext() *Output_parameterContext {
	var p = new(Output_parameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_output_parameter
	return p
}

func (*Output_parameterContext) IsOutput_parameterContext() {}

func NewOutput_parameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Output_parameterContext {
	var p = new(Output_parameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_output_parameter

	return p
}

func (s *Output_parameterContext) GetParser() antlr.Parser { return s.parser }

func (s *Output_parameterContext) Variable() IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *Output_parameterContext) Set_variable() ISet_variableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISet_variableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISet_variableContext)
}

func (s *Output_parameterContext) Object_attribute() IObject_attributeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObject_attributeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObject_attributeContext)
}

func (s *Output_parameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Output_parameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Output_parameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterOutput_parameter(s)
	}
}

func (s *Output_parameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitOutput_parameter(s)
	}
}

func (p *ASLParser) Output_parameter() (localctx IOutput_parameterContext) {
	this := p
	_ = this

	localctx = NewOutput_parameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, ASLParserRULE_output_parameter)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(656)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 68, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(653)
			p.Variable()
		}

	case 2:
		{
			p.SetState(654)
			p.Set_variable()
		}

	case 3:
		{
			p.SetState(655)
			p.Object_attribute()
		}

	}

	return localctx
}

// IInput_parameter_listContext is an interface to support dynamic dispatch.
type IInput_parameter_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInput_parameter_listContext differentiates from other interfaces.
	IsInput_parameter_listContext()
}

type Input_parameter_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInput_parameter_listContext() *Input_parameter_listContext {
	var p = new(Input_parameter_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_input_parameter_list
	return p
}

func (*Input_parameter_listContext) IsInput_parameter_listContext() {}

func NewInput_parameter_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Input_parameter_listContext {
	var p = new(Input_parameter_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_input_parameter_list

	return p
}

func (s *Input_parameter_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Input_parameter_listContext) AllInput_parameter() []IInput_parameterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInput_parameterContext)(nil)).Elem())
	var tst = make([]IInput_parameterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInput_parameterContext)
		}
	}

	return tst
}

func (s *Input_parameter_listContext) Input_parameter(i int) IInput_parameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInput_parameterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInput_parameterContext)
}

func (s *Input_parameter_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ASLParserCOMMA)
}

func (s *Input_parameter_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ASLParserCOMMA, i)
}

func (s *Input_parameter_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Input_parameter_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Input_parameter_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterInput_parameter_list(s)
	}
}

func (s *Input_parameter_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitInput_parameter_list(s)
	}
}

func (p *ASLParser) Input_parameter_list() (localctx IInput_parameter_listContext) {
	this := p
	_ = this

	localctx = NewInput_parameter_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, ASLParserRULE_input_parameter_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(658)
		p.Input_parameter()
	}
	p.SetState(663)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ASLParserCOMMA {
		{
			p.SetState(659)
			p.Match(ASLParserCOMMA)
		}
		{
			p.SetState(660)
			p.Input_parameter()
		}

		p.SetState(665)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IInput_parameterContext is an interface to support dynamic dispatch.
type IInput_parameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInput_parameterContext differentiates from other interfaces.
	IsInput_parameterContext()
}

type Input_parameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInput_parameterContext() *Input_parameterContext {
	var p = new(Input_parameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_input_parameter
	return p
}

func (*Input_parameterContext) IsInput_parameterContext() {}

func NewInput_parameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Input_parameterContext {
	var p = new(Input_parameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_input_parameter

	return p
}

func (s *Input_parameterContext) GetParser() antlr.Parser { return s.parser }

func (s *Input_parameterContext) Variable() IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *Input_parameterContext) Set_variable() ISet_variableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISet_variableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISet_variableContext)
}

func (s *Input_parameterContext) Constant() IConstantContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstantContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *Input_parameterContext) Object_attribute() IObject_attributeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObject_attributeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObject_attributeContext)
}

func (s *Input_parameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Input_parameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Input_parameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterInput_parameter(s)
	}
}

func (s *Input_parameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitInput_parameter(s)
	}
}

func (p *ASLParser) Input_parameter() (localctx IInput_parameterContext) {
	this := p
	_ = this

	localctx = NewInput_parameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, ASLParserRULE_input_parameter)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(670)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 70, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(666)
			p.Variable()
		}

	case 2:
		{
			p.SetState(667)
			p.Set_variable()
		}

	case 3:
		{
			p.SetState(668)
			p.Constant()
		}

	case 4:
		{
			p.SetState(669)
			p.Object_attribute()
		}

	}

	return localctx
}

// ITimer_operationContext is an interface to support dynamic dispatch.
type ITimer_operationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTimer_operationContext differentiates from other interfaces.
	IsTimer_operationContext()
}

type Timer_operationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTimer_operationContext() *Timer_operationContext {
	var p = new(Timer_operationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_timer_operation
	return p
}

func (*Timer_operationContext) IsTimer_operationContext() {}

func NewTimer_operationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Timer_operationContext {
	var p = new(Timer_operationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_timer_operation

	return p
}

func (s *Timer_operationContext) GetParser() antlr.Parser { return s.parser }

func (s *Timer_operationContext) Timer_creation() ITimer_creationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITimer_creationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITimer_creationContext)
}

func (s *Timer_operationContext) Timer_deletion() ITimer_deletionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITimer_deletionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITimer_deletionContext)
}

func (s *Timer_operationContext) Set_relative_timer() ISet_relative_timerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISet_relative_timerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISet_relative_timerContext)
}

func (s *Timer_operationContext) Set_absolute_timer() ISet_absolute_timerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISet_absolute_timerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISet_absolute_timerContext)
}

func (s *Timer_operationContext) Set_recurring_timer() ISet_recurring_timerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISet_recurring_timerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISet_recurring_timerContext)
}

func (s *Timer_operationContext) Timer_reset() ITimer_resetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITimer_resetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITimer_resetContext)
}

func (s *Timer_operationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Timer_operationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Timer_operationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterTimer_operation(s)
	}
}

func (s *Timer_operationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitTimer_operation(s)
	}
}

func (p *ASLParser) Timer_operation() (localctx ITimer_operationContext) {
	this := p
	_ = this

	localctx = NewTimer_operationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, ASLParserRULE_timer_operation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(678)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 71, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(672)
			p.Timer_creation()
		}

	case 2:
		{
			p.SetState(673)
			p.Timer_deletion()
		}

	case 3:
		{
			p.SetState(674)
			p.Set_relative_timer()
		}

	case 4:
		{
			p.SetState(675)
			p.Set_absolute_timer()
		}

	case 5:
		{
			p.SetState(676)
			p.Set_recurring_timer()
		}

	case 6:
		{
			p.SetState(677)
			p.Timer_reset()
		}

	}

	return localctx
}

// ITimer_creationContext is an interface to support dynamic dispatch.
type ITimer_creationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTimer_creationContext differentiates from other interfaces.
	IsTimer_creationContext()
}

type Timer_creationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTimer_creationContext() *Timer_creationContext {
	var p = new(Timer_creationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_timer_creation
	return p
}

func (*Timer_creationContext) IsTimer_creationContext() {}

func NewTimer_creationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Timer_creationContext {
	var p = new(Timer_creationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_timer_creation

	return p
}

func (s *Timer_creationContext) GetParser() antlr.Parser { return s.parser }

func (s *Timer_creationContext) AllL_SQUARE() []antlr.TerminalNode {
	return s.GetTokens(ASLParserL_SQUARE)
}

func (s *Timer_creationContext) L_SQUARE(i int) antlr.TerminalNode {
	return s.GetToken(ASLParserL_SQUARE, i)
}

func (s *Timer_creationContext) Timer_id() ITimer_idContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITimer_idContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITimer_idContext)
}

func (s *Timer_creationContext) AllR_SQUARE() []antlr.TerminalNode {
	return s.GetTokens(ASLParserR_SQUARE)
}

func (s *Timer_creationContext) R_SQUARE(i int) antlr.TerminalNode {
	return s.GetToken(ASLParserR_SQUARE, i)
}

func (s *Timer_creationContext) EQ() antlr.TerminalNode {
	return s.GetToken(ASLParserEQ, 0)
}

func (s *Timer_creationContext) CREATE_TIMER() antlr.TerminalNode {
	return s.GetToken(ASLParserCREATE_TIMER, 0)
}

func (s *Timer_creationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Timer_creationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Timer_creationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterTimer_creation(s)
	}
}

func (s *Timer_creationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitTimer_creation(s)
	}
}

func (p *ASLParser) Timer_creation() (localctx ITimer_creationContext) {
	this := p
	_ = this

	localctx = NewTimer_creationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, ASLParserRULE_timer_creation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(680)
		p.Match(ASLParserL_SQUARE)
	}
	{
		p.SetState(681)
		p.Timer_id()
	}
	{
		p.SetState(682)
		p.Match(ASLParserR_SQUARE)
	}
	{
		p.SetState(683)
		p.Match(ASLParserEQ)
	}
	{
		p.SetState(684)
		p.Match(ASLParserCREATE_TIMER)
	}
	{
		p.SetState(685)
		p.Match(ASLParserL_SQUARE)
	}
	{
		p.SetState(686)
		p.Match(ASLParserR_SQUARE)
	}

	return localctx
}

// ITimer_deletionContext is an interface to support dynamic dispatch.
type ITimer_deletionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTimer_deletionContext differentiates from other interfaces.
	IsTimer_deletionContext()
}

type Timer_deletionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTimer_deletionContext() *Timer_deletionContext {
	var p = new(Timer_deletionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_timer_deletion
	return p
}

func (*Timer_deletionContext) IsTimer_deletionContext() {}

func NewTimer_deletionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Timer_deletionContext {
	var p = new(Timer_deletionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_timer_deletion

	return p
}

func (s *Timer_deletionContext) GetParser() antlr.Parser { return s.parser }

func (s *Timer_deletionContext) AllL_SQUARE() []antlr.TerminalNode {
	return s.GetTokens(ASLParserL_SQUARE)
}

func (s *Timer_deletionContext) L_SQUARE(i int) antlr.TerminalNode {
	return s.GetToken(ASLParserL_SQUARE, i)
}

func (s *Timer_deletionContext) AllR_SQUARE() []antlr.TerminalNode {
	return s.GetTokens(ASLParserR_SQUARE)
}

func (s *Timer_deletionContext) R_SQUARE(i int) antlr.TerminalNode {
	return s.GetToken(ASLParserR_SQUARE, i)
}

func (s *Timer_deletionContext) EQ() antlr.TerminalNode {
	return s.GetToken(ASLParserEQ, 0)
}

func (s *Timer_deletionContext) DELETE_TIMER() antlr.TerminalNode {
	return s.GetToken(ASLParserDELETE_TIMER, 0)
}

func (s *Timer_deletionContext) Timer_id() ITimer_idContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITimer_idContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITimer_idContext)
}

func (s *Timer_deletionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Timer_deletionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Timer_deletionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterTimer_deletion(s)
	}
}

func (s *Timer_deletionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitTimer_deletion(s)
	}
}

func (p *ASLParser) Timer_deletion() (localctx ITimer_deletionContext) {
	this := p
	_ = this

	localctx = NewTimer_deletionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, ASLParserRULE_timer_deletion)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(688)
		p.Match(ASLParserL_SQUARE)
	}
	{
		p.SetState(689)
		p.Match(ASLParserR_SQUARE)
	}
	{
		p.SetState(690)
		p.Match(ASLParserEQ)
	}
	{
		p.SetState(691)
		p.Match(ASLParserDELETE_TIMER)
	}
	{
		p.SetState(692)
		p.Match(ASLParserL_SQUARE)
	}
	{
		p.SetState(693)
		p.Timer_id()
	}
	{
		p.SetState(694)
		p.Match(ASLParserR_SQUARE)
	}

	return localctx
}

// ISet_relative_timerContext is an interface to support dynamic dispatch.
type ISet_relative_timerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSet_relative_timerContext differentiates from other interfaces.
	IsSet_relative_timerContext()
}

type Set_relative_timerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySet_relative_timerContext() *Set_relative_timerContext {
	var p = new(Set_relative_timerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_set_relative_timer
	return p
}

func (*Set_relative_timerContext) IsSet_relative_timerContext() {}

func NewSet_relative_timerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Set_relative_timerContext {
	var p = new(Set_relative_timerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_set_relative_timer

	return p
}

func (s *Set_relative_timerContext) GetParser() antlr.Parser { return s.parser }

func (s *Set_relative_timerContext) GENERATE() antlr.TerminalNode {
	return s.GetToken(ASLParserGENERATE, 0)
}

func (s *Set_relative_timerContext) TIM1() antlr.TerminalNode {
	return s.GetToken(ASLParserTIM1, 0)
}

func (s *Set_relative_timerContext) L_PAREN() antlr.TerminalNode {
	return s.GetToken(ASLParserL_PAREN, 0)
}

func (s *Set_relative_timerContext) Time_to_fire() ITime_to_fireContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITime_to_fireContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITime_to_fireContext)
}

func (s *Set_relative_timerContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ASLParserCOMMA)
}

func (s *Set_relative_timerContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ASLParserCOMMA, i)
}

func (s *Set_relative_timerContext) Return_event() IReturn_eventContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReturn_eventContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReturn_eventContext)
}

func (s *Set_relative_timerContext) Target_instance() ITarget_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITarget_instanceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITarget_instanceContext)
}

func (s *Set_relative_timerContext) R_PAREN() antlr.TerminalNode {
	return s.GetToken(ASLParserR_PAREN, 0)
}

func (s *Set_relative_timerContext) SEMI_COLON() antlr.TerminalNode {
	return s.GetToken(ASLParserSEMI_COLON, 0)
}

func (s *Set_relative_timerContext) TO() antlr.TerminalNode {
	return s.GetToken(ASLParserTO, 0)
}

func (s *Set_relative_timerContext) Timer_id() ITimer_idContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITimer_idContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITimer_idContext)
}

func (s *Set_relative_timerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Set_relative_timerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Set_relative_timerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterSet_relative_timer(s)
	}
}

func (s *Set_relative_timerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitSet_relative_timer(s)
	}
}

func (p *ASLParser) Set_relative_timer() (localctx ISet_relative_timerContext) {
	this := p
	_ = this

	localctx = NewSet_relative_timerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, ASLParserRULE_set_relative_timer)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(696)
		p.Match(ASLParserGENERATE)
	}
	{
		p.SetState(697)
		p.Match(ASLParserTIM1)
	}
	{
		p.SetState(698)
		p.Match(ASLParserL_PAREN)
	}
	{
		p.SetState(699)
		p.Time_to_fire()
	}
	{
		p.SetState(700)
		p.Match(ASLParserCOMMA)
	}
	{
		p.SetState(701)
		p.Return_event()
	}
	{
		p.SetState(702)
		p.Match(ASLParserCOMMA)
	}
	{
		p.SetState(703)
		p.Target_instance()
	}
	{
		p.SetState(704)
		p.Match(ASLParserR_PAREN)
	}
	{
		p.SetState(705)
		p.Match(ASLParserSEMI_COLON)
	}
	{
		p.SetState(706)
		p.Match(ASLParserTO)
	}
	{
		p.SetState(707)
		p.Timer_id()
	}

	return localctx
}

// ISet_absolute_timerContext is an interface to support dynamic dispatch.
type ISet_absolute_timerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSet_absolute_timerContext differentiates from other interfaces.
	IsSet_absolute_timerContext()
}

type Set_absolute_timerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySet_absolute_timerContext() *Set_absolute_timerContext {
	var p = new(Set_absolute_timerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_set_absolute_timer
	return p
}

func (*Set_absolute_timerContext) IsSet_absolute_timerContext() {}

func NewSet_absolute_timerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Set_absolute_timerContext {
	var p = new(Set_absolute_timerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_set_absolute_timer

	return p
}

func (s *Set_absolute_timerContext) GetParser() antlr.Parser { return s.parser }

func (s *Set_absolute_timerContext) GENERATE() antlr.TerminalNode {
	return s.GetToken(ASLParserGENERATE, 0)
}

func (s *Set_absolute_timerContext) TIM10() antlr.TerminalNode {
	return s.GetToken(ASLParserTIM10, 0)
}

func (s *Set_absolute_timerContext) L_PAREN() antlr.TerminalNode {
	return s.GetToken(ASLParserL_PAREN, 0)
}

func (s *Set_absolute_timerContext) Fire_year() IFire_yearContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFire_yearContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFire_yearContext)
}

func (s *Set_absolute_timerContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ASLParserCOMMA)
}

func (s *Set_absolute_timerContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ASLParserCOMMA, i)
}

func (s *Set_absolute_timerContext) Fire_month() IFire_monthContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFire_monthContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFire_monthContext)
}

func (s *Set_absolute_timerContext) Fire_date() IFire_dateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFire_dateContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFire_dateContext)
}

func (s *Set_absolute_timerContext) Fire_hour() IFire_hourContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFire_hourContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFire_hourContext)
}

func (s *Set_absolute_timerContext) Fire_minute() IFire_minuteContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFire_minuteContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFire_minuteContext)
}

func (s *Set_absolute_timerContext) Fire_second() IFire_secondContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFire_secondContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFire_secondContext)
}

func (s *Set_absolute_timerContext) Return_event() IReturn_eventContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReturn_eventContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReturn_eventContext)
}

func (s *Set_absolute_timerContext) Target_instance() ITarget_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITarget_instanceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITarget_instanceContext)
}

func (s *Set_absolute_timerContext) R_PAREN() antlr.TerminalNode {
	return s.GetToken(ASLParserR_PAREN, 0)
}

func (s *Set_absolute_timerContext) SEMI_COLON() antlr.TerminalNode {
	return s.GetToken(ASLParserSEMI_COLON, 0)
}

func (s *Set_absolute_timerContext) TO() antlr.TerminalNode {
	return s.GetToken(ASLParserTO, 0)
}

func (s *Set_absolute_timerContext) Timer_id() ITimer_idContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITimer_idContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITimer_idContext)
}

func (s *Set_absolute_timerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Set_absolute_timerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Set_absolute_timerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterSet_absolute_timer(s)
	}
}

func (s *Set_absolute_timerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitSet_absolute_timer(s)
	}
}

func (p *ASLParser) Set_absolute_timer() (localctx ISet_absolute_timerContext) {
	this := p
	_ = this

	localctx = NewSet_absolute_timerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, ASLParserRULE_set_absolute_timer)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(709)
		p.Match(ASLParserGENERATE)
	}
	{
		p.SetState(710)
		p.Match(ASLParserTIM10)
	}
	{
		p.SetState(711)
		p.Match(ASLParserL_PAREN)
	}
	{
		p.SetState(712)
		p.Fire_year()
	}
	{
		p.SetState(713)
		p.Match(ASLParserCOMMA)
	}
	{
		p.SetState(714)
		p.Fire_month()
	}
	{
		p.SetState(715)
		p.Match(ASLParserCOMMA)
	}
	{
		p.SetState(716)
		p.Fire_date()
	}
	{
		p.SetState(717)
		p.Match(ASLParserCOMMA)
	}
	{
		p.SetState(718)
		p.Fire_hour()
	}
	{
		p.SetState(719)
		p.Match(ASLParserCOMMA)
	}
	{
		p.SetState(720)
		p.Fire_minute()
	}
	{
		p.SetState(721)
		p.Match(ASLParserCOMMA)
	}
	{
		p.SetState(722)
		p.Fire_second()
	}
	{
		p.SetState(723)
		p.Match(ASLParserCOMMA)
	}
	{
		p.SetState(724)
		p.Return_event()
	}
	{
		p.SetState(725)
		p.Match(ASLParserCOMMA)
	}
	{
		p.SetState(726)
		p.Target_instance()
	}
	{
		p.SetState(727)
		p.Match(ASLParserR_PAREN)
	}
	{
		p.SetState(728)
		p.Match(ASLParserSEMI_COLON)
	}
	{
		p.SetState(729)
		p.Match(ASLParserTO)
	}
	{
		p.SetState(730)
		p.Timer_id()
	}

	return localctx
}

// ISet_recurring_timerContext is an interface to support dynamic dispatch.
type ISet_recurring_timerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSet_recurring_timerContext differentiates from other interfaces.
	IsSet_recurring_timerContext()
}

type Set_recurring_timerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySet_recurring_timerContext() *Set_recurring_timerContext {
	var p = new(Set_recurring_timerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_set_recurring_timer
	return p
}

func (*Set_recurring_timerContext) IsSet_recurring_timerContext() {}

func NewSet_recurring_timerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Set_recurring_timerContext {
	var p = new(Set_recurring_timerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_set_recurring_timer

	return p
}

func (s *Set_recurring_timerContext) GetParser() antlr.Parser { return s.parser }

func (s *Set_recurring_timerContext) GENERATE() antlr.TerminalNode {
	return s.GetToken(ASLParserGENERATE, 0)
}

func (s *Set_recurring_timerContext) TIM3() antlr.TerminalNode {
	return s.GetToken(ASLParserTIM3, 0)
}

func (s *Set_recurring_timerContext) L_PAREN() antlr.TerminalNode {
	return s.GetToken(ASLParserL_PAREN, 0)
}

func (s *Set_recurring_timerContext) Start_time() IStart_timeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStart_timeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStart_timeContext)
}

func (s *Set_recurring_timerContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ASLParserCOMMA)
}

func (s *Set_recurring_timerContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ASLParserCOMMA, i)
}

func (s *Set_recurring_timerContext) Period() IPeriodContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPeriodContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPeriodContext)
}

func (s *Set_recurring_timerContext) Return_event() IReturn_eventContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReturn_eventContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReturn_eventContext)
}

func (s *Set_recurring_timerContext) Target_instance() ITarget_instanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITarget_instanceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITarget_instanceContext)
}

func (s *Set_recurring_timerContext) R_PAREN() antlr.TerminalNode {
	return s.GetToken(ASLParserR_PAREN, 0)
}

func (s *Set_recurring_timerContext) SEMI_COLON() antlr.TerminalNode {
	return s.GetToken(ASLParserSEMI_COLON, 0)
}

func (s *Set_recurring_timerContext) TO() antlr.TerminalNode {
	return s.GetToken(ASLParserTO, 0)
}

func (s *Set_recurring_timerContext) Timer_id() ITimer_idContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITimer_idContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITimer_idContext)
}

func (s *Set_recurring_timerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Set_recurring_timerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Set_recurring_timerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterSet_recurring_timer(s)
	}
}

func (s *Set_recurring_timerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitSet_recurring_timer(s)
	}
}

func (p *ASLParser) Set_recurring_timer() (localctx ISet_recurring_timerContext) {
	this := p
	_ = this

	localctx = NewSet_recurring_timerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, ASLParserRULE_set_recurring_timer)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(732)
		p.Match(ASLParserGENERATE)
	}
	{
		p.SetState(733)
		p.Match(ASLParserTIM3)
	}
	{
		p.SetState(734)
		p.Match(ASLParserL_PAREN)
	}
	{
		p.SetState(735)
		p.Start_time()
	}
	{
		p.SetState(736)
		p.Match(ASLParserCOMMA)
	}
	{
		p.SetState(737)
		p.Period()
	}
	{
		p.SetState(738)
		p.Match(ASLParserCOMMA)
	}
	{
		p.SetState(739)
		p.Return_event()
	}
	{
		p.SetState(740)
		p.Match(ASLParserCOMMA)
	}
	{
		p.SetState(741)
		p.Target_instance()
	}
	{
		p.SetState(742)
		p.Match(ASLParserR_PAREN)
	}
	{
		p.SetState(743)
		p.Match(ASLParserSEMI_COLON)
	}
	{
		p.SetState(744)
		p.Match(ASLParserTO)
	}
	{
		p.SetState(745)
		p.Timer_id()
	}

	return localctx
}

// ITimer_resetContext is an interface to support dynamic dispatch.
type ITimer_resetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTimer_resetContext differentiates from other interfaces.
	IsTimer_resetContext()
}

type Timer_resetContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTimer_resetContext() *Timer_resetContext {
	var p = new(Timer_resetContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_timer_reset
	return p
}

func (*Timer_resetContext) IsTimer_resetContext() {}

func NewTimer_resetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Timer_resetContext {
	var p = new(Timer_resetContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_timer_reset

	return p
}

func (s *Timer_resetContext) GetParser() antlr.Parser { return s.parser }

func (s *Timer_resetContext) GENERATE() antlr.TerminalNode {
	return s.GetToken(ASLParserGENERATE, 0)
}

func (s *Timer_resetContext) TIM2() antlr.TerminalNode {
	return s.GetToken(ASLParserTIM2, 0)
}

func (s *Timer_resetContext) L_PAREN() antlr.TerminalNode {
	return s.GetToken(ASLParserL_PAREN, 0)
}

func (s *Timer_resetContext) R_PAREN() antlr.TerminalNode {
	return s.GetToken(ASLParserR_PAREN, 0)
}

func (s *Timer_resetContext) SEMI_COLON() antlr.TerminalNode {
	return s.GetToken(ASLParserSEMI_COLON, 0)
}

func (s *Timer_resetContext) TO() antlr.TerminalNode {
	return s.GetToken(ASLParserTO, 0)
}

func (s *Timer_resetContext) Timer_id() ITimer_idContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITimer_idContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITimer_idContext)
}

func (s *Timer_resetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Timer_resetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Timer_resetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterTimer_reset(s)
	}
}

func (s *Timer_resetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitTimer_reset(s)
	}
}

func (p *ASLParser) Timer_reset() (localctx ITimer_resetContext) {
	this := p
	_ = this

	localctx = NewTimer_resetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, ASLParserRULE_timer_reset)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(747)
		p.Match(ASLParserGENERATE)
	}
	{
		p.SetState(748)
		p.Match(ASLParserTIM2)
	}
	{
		p.SetState(749)
		p.Match(ASLParserL_PAREN)
	}
	{
		p.SetState(750)
		p.Match(ASLParserR_PAREN)
	}
	{
		p.SetState(751)
		p.Match(ASLParserSEMI_COLON)
	}
	{
		p.SetState(752)
		p.Match(ASLParserTO)
	}
	{
		p.SetState(753)
		p.Timer_id()
	}

	return localctx
}

// ITimer_idContext is an interface to support dynamic dispatch.
type ITimer_idContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTimer_idContext differentiates from other interfaces.
	IsTimer_idContext()
}

type Timer_idContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTimer_idContext() *Timer_idContext {
	var p = new(Timer_idContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_timer_id
	return p
}

func (*Timer_idContext) IsTimer_idContext() {}

func NewTimer_idContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Timer_idContext {
	var p = new(Timer_idContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_timer_id

	return p
}

func (s *Timer_idContext) GetParser() antlr.Parser { return s.parser }

func (s *Timer_idContext) Variable() IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *Timer_idContext) Object_attribute() IObject_attributeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObject_attributeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObject_attributeContext)
}

func (s *Timer_idContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Timer_idContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Timer_idContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterTimer_id(s)
	}
}

func (s *Timer_idContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitTimer_id(s)
	}
}

func (p *ASLParser) Timer_id() (localctx ITimer_idContext) {
	this := p
	_ = this

	localctx = NewTimer_idContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, ASLParserRULE_timer_id)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(757)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 72, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(755)
			p.Variable()
		}

	case 2:
		{
			p.SetState(756)
			p.Object_attribute()
		}

	}

	return localctx
}

// ITime_to_fireContext is an interface to support dynamic dispatch.
type ITime_to_fireContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTime_to_fireContext differentiates from other interfaces.
	IsTime_to_fireContext()
}

type Time_to_fireContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTime_to_fireContext() *Time_to_fireContext {
	var p = new(Time_to_fireContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_time_to_fire
	return p
}

func (*Time_to_fireContext) IsTime_to_fireContext() {}

func NewTime_to_fireContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Time_to_fireContext {
	var p = new(Time_to_fireContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_time_to_fire

	return p
}

func (s *Time_to_fireContext) GetParser() antlr.Parser { return s.parser }

func (s *Time_to_fireContext) Variable() IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *Time_to_fireContext) Object_attribute() IObject_attributeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObject_attributeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObject_attributeContext)
}

func (s *Time_to_fireContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(ASLParserINTEGER_VALUE, 0)
}

func (s *Time_to_fireContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Time_to_fireContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Time_to_fireContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterTime_to_fire(s)
	}
}

func (s *Time_to_fireContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitTime_to_fire(s)
	}
}

func (p *ASLParser) Time_to_fire() (localctx ITime_to_fireContext) {
	this := p
	_ = this

	localctx = NewTime_to_fireContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, ASLParserRULE_time_to_fire)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(762)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 73, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(759)
			p.Variable()
		}

	case 2:
		{
			p.SetState(760)
			p.Object_attribute()
		}

	case 3:
		{
			p.SetState(761)
			p.Match(ASLParserINTEGER_VALUE)
		}

	}

	return localctx
}

// IReturn_eventContext is an interface to support dynamic dispatch.
type IReturn_eventContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReturn_eventContext differentiates from other interfaces.
	IsReturn_eventContext()
}

type Return_eventContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturn_eventContext() *Return_eventContext {
	var p = new(Return_eventContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_return_event
	return p
}

func (*Return_eventContext) IsReturn_eventContext() {}

func NewReturn_eventContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Return_eventContext {
	var p = new(Return_eventContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_return_event

	return p
}

func (s *Return_eventContext) GetParser() antlr.Parser { return s.parser }

func (s *Return_eventContext) UPPERCASE_NUMBER_ID() antlr.TerminalNode {
	return s.GetToken(ASLParserUPPERCASE_NUMBER_ID, 0)
}

func (s *Return_eventContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Return_eventContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Return_eventContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterReturn_event(s)
	}
}

func (s *Return_eventContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitReturn_event(s)
	}
}

func (p *ASLParser) Return_event() (localctx IReturn_eventContext) {
	this := p
	_ = this

	localctx = NewReturn_eventContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, ASLParserRULE_return_event)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(764)
		p.Match(ASLParserUPPERCASE_NUMBER_ID)
	}

	return localctx
}

// ITarget_instanceContext is an interface to support dynamic dispatch.
type ITarget_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTarget_instanceContext differentiates from other interfaces.
	IsTarget_instanceContext()
}

type Target_instanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTarget_instanceContext() *Target_instanceContext {
	var p = new(Target_instanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_target_instance
	return p
}

func (*Target_instanceContext) IsTarget_instanceContext() {}

func NewTarget_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Target_instanceContext {
	var p = new(Target_instanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_target_instance

	return p
}

func (s *Target_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *Target_instanceContext) Variable() IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *Target_instanceContext) THIS() antlr.TerminalNode {
	return s.GetToken(ASLParserTHIS, 0)
}

func (s *Target_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Target_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Target_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterTarget_instance(s)
	}
}

func (s *Target_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitTarget_instance(s)
	}
}

func (p *ASLParser) Target_instance() (localctx ITarget_instanceContext) {
	this := p
	_ = this

	localctx = NewTarget_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, ASLParserRULE_target_instance)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(768)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASLParserLOWERCASE_ID, ASLParserLOWERCASE_NUMBER_ID:
		{
			p.SetState(766)
			p.Variable()
		}

	case ASLParserTHIS:
		{
			p.SetState(767)
			p.Match(ASLParserTHIS)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFire_yearContext is an interface to support dynamic dispatch.
type IFire_yearContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFire_yearContext differentiates from other interfaces.
	IsFire_yearContext()
}

type Fire_yearContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFire_yearContext() *Fire_yearContext {
	var p = new(Fire_yearContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_fire_year
	return p
}

func (*Fire_yearContext) IsFire_yearContext() {}

func NewFire_yearContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Fire_yearContext {
	var p = new(Fire_yearContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_fire_year

	return p
}

func (s *Fire_yearContext) GetParser() antlr.Parser { return s.parser }

func (s *Fire_yearContext) Variable() IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *Fire_yearContext) Object_attribute() IObject_attributeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObject_attributeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObject_attributeContext)
}

func (s *Fire_yearContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(ASLParserINTEGER_VALUE, 0)
}

func (s *Fire_yearContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Fire_yearContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Fire_yearContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterFire_year(s)
	}
}

func (s *Fire_yearContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitFire_year(s)
	}
}

func (p *ASLParser) Fire_year() (localctx IFire_yearContext) {
	this := p
	_ = this

	localctx = NewFire_yearContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, ASLParserRULE_fire_year)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(773)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 75, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(770)
			p.Variable()
		}

	case 2:
		{
			p.SetState(771)
			p.Object_attribute()
		}

	case 3:
		{
			p.SetState(772)
			p.Match(ASLParserINTEGER_VALUE)
		}

	}

	return localctx
}

// IFire_monthContext is an interface to support dynamic dispatch.
type IFire_monthContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFire_monthContext differentiates from other interfaces.
	IsFire_monthContext()
}

type Fire_monthContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFire_monthContext() *Fire_monthContext {
	var p = new(Fire_monthContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_fire_month
	return p
}

func (*Fire_monthContext) IsFire_monthContext() {}

func NewFire_monthContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Fire_monthContext {
	var p = new(Fire_monthContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_fire_month

	return p
}

func (s *Fire_monthContext) GetParser() antlr.Parser { return s.parser }

func (s *Fire_monthContext) Variable() IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *Fire_monthContext) Object_attribute() IObject_attributeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObject_attributeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObject_attributeContext)
}

func (s *Fire_monthContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(ASLParserINTEGER_VALUE, 0)
}

func (s *Fire_monthContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Fire_monthContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Fire_monthContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterFire_month(s)
	}
}

func (s *Fire_monthContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitFire_month(s)
	}
}

func (p *ASLParser) Fire_month() (localctx IFire_monthContext) {
	this := p
	_ = this

	localctx = NewFire_monthContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, ASLParserRULE_fire_month)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(778)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 76, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(775)
			p.Variable()
		}

	case 2:
		{
			p.SetState(776)
			p.Object_attribute()
		}

	case 3:
		{
			p.SetState(777)
			p.Match(ASLParserINTEGER_VALUE)
		}

	}

	return localctx
}

// IFire_dateContext is an interface to support dynamic dispatch.
type IFire_dateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFire_dateContext differentiates from other interfaces.
	IsFire_dateContext()
}

type Fire_dateContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFire_dateContext() *Fire_dateContext {
	var p = new(Fire_dateContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_fire_date
	return p
}

func (*Fire_dateContext) IsFire_dateContext() {}

func NewFire_dateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Fire_dateContext {
	var p = new(Fire_dateContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_fire_date

	return p
}

func (s *Fire_dateContext) GetParser() antlr.Parser { return s.parser }

func (s *Fire_dateContext) Variable() IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *Fire_dateContext) Object_attribute() IObject_attributeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObject_attributeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObject_attributeContext)
}

func (s *Fire_dateContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(ASLParserINTEGER_VALUE, 0)
}

func (s *Fire_dateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Fire_dateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Fire_dateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterFire_date(s)
	}
}

func (s *Fire_dateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitFire_date(s)
	}
}

func (p *ASLParser) Fire_date() (localctx IFire_dateContext) {
	this := p
	_ = this

	localctx = NewFire_dateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, ASLParserRULE_fire_date)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(783)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 77, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(780)
			p.Variable()
		}

	case 2:
		{
			p.SetState(781)
			p.Object_attribute()
		}

	case 3:
		{
			p.SetState(782)
			p.Match(ASLParserINTEGER_VALUE)
		}

	}

	return localctx
}

// IFire_hourContext is an interface to support dynamic dispatch.
type IFire_hourContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFire_hourContext differentiates from other interfaces.
	IsFire_hourContext()
}

type Fire_hourContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFire_hourContext() *Fire_hourContext {
	var p = new(Fire_hourContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_fire_hour
	return p
}

func (*Fire_hourContext) IsFire_hourContext() {}

func NewFire_hourContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Fire_hourContext {
	var p = new(Fire_hourContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_fire_hour

	return p
}

func (s *Fire_hourContext) GetParser() antlr.Parser { return s.parser }

func (s *Fire_hourContext) Variable() IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *Fire_hourContext) Object_attribute() IObject_attributeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObject_attributeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObject_attributeContext)
}

func (s *Fire_hourContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(ASLParserINTEGER_VALUE, 0)
}

func (s *Fire_hourContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Fire_hourContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Fire_hourContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterFire_hour(s)
	}
}

func (s *Fire_hourContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitFire_hour(s)
	}
}

func (p *ASLParser) Fire_hour() (localctx IFire_hourContext) {
	this := p
	_ = this

	localctx = NewFire_hourContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, ASLParserRULE_fire_hour)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(788)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 78, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(785)
			p.Variable()
		}

	case 2:
		{
			p.SetState(786)
			p.Object_attribute()
		}

	case 3:
		{
			p.SetState(787)
			p.Match(ASLParserINTEGER_VALUE)
		}

	}

	return localctx
}

// IFire_minuteContext is an interface to support dynamic dispatch.
type IFire_minuteContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFire_minuteContext differentiates from other interfaces.
	IsFire_minuteContext()
}

type Fire_minuteContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFire_minuteContext() *Fire_minuteContext {
	var p = new(Fire_minuteContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_fire_minute
	return p
}

func (*Fire_minuteContext) IsFire_minuteContext() {}

func NewFire_minuteContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Fire_minuteContext {
	var p = new(Fire_minuteContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_fire_minute

	return p
}

func (s *Fire_minuteContext) GetParser() antlr.Parser { return s.parser }

func (s *Fire_minuteContext) Variable() IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *Fire_minuteContext) Object_attribute() IObject_attributeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObject_attributeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObject_attributeContext)
}

func (s *Fire_minuteContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(ASLParserINTEGER_VALUE, 0)
}

func (s *Fire_minuteContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Fire_minuteContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Fire_minuteContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterFire_minute(s)
	}
}

func (s *Fire_minuteContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitFire_minute(s)
	}
}

func (p *ASLParser) Fire_minute() (localctx IFire_minuteContext) {
	this := p
	_ = this

	localctx = NewFire_minuteContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, ASLParserRULE_fire_minute)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(793)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 79, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(790)
			p.Variable()
		}

	case 2:
		{
			p.SetState(791)
			p.Object_attribute()
		}

	case 3:
		{
			p.SetState(792)
			p.Match(ASLParserINTEGER_VALUE)
		}

	}

	return localctx
}

// IFire_secondContext is an interface to support dynamic dispatch.
type IFire_secondContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFire_secondContext differentiates from other interfaces.
	IsFire_secondContext()
}

type Fire_secondContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFire_secondContext() *Fire_secondContext {
	var p = new(Fire_secondContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_fire_second
	return p
}

func (*Fire_secondContext) IsFire_secondContext() {}

func NewFire_secondContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Fire_secondContext {
	var p = new(Fire_secondContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_fire_second

	return p
}

func (s *Fire_secondContext) GetParser() antlr.Parser { return s.parser }

func (s *Fire_secondContext) Variable() IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *Fire_secondContext) Object_attribute() IObject_attributeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObject_attributeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObject_attributeContext)
}

func (s *Fire_secondContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(ASLParserINTEGER_VALUE, 0)
}

func (s *Fire_secondContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Fire_secondContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Fire_secondContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterFire_second(s)
	}
}

func (s *Fire_secondContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitFire_second(s)
	}
}

func (p *ASLParser) Fire_second() (localctx IFire_secondContext) {
	this := p
	_ = this

	localctx = NewFire_secondContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, ASLParserRULE_fire_second)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(798)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 80, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(795)
			p.Variable()
		}

	case 2:
		{
			p.SetState(796)
			p.Object_attribute()
		}

	case 3:
		{
			p.SetState(797)
			p.Match(ASLParserINTEGER_VALUE)
		}

	}

	return localctx
}

// IStart_timeContext is an interface to support dynamic dispatch.
type IStart_timeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStart_timeContext differentiates from other interfaces.
	IsStart_timeContext()
}

type Start_timeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStart_timeContext() *Start_timeContext {
	var p = new(Start_timeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_start_time
	return p
}

func (*Start_timeContext) IsStart_timeContext() {}

func NewStart_timeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Start_timeContext {
	var p = new(Start_timeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_start_time

	return p
}

func (s *Start_timeContext) GetParser() antlr.Parser { return s.parser }

func (s *Start_timeContext) Variable() IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *Start_timeContext) Object_attribute() IObject_attributeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObject_attributeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObject_attributeContext)
}

func (s *Start_timeContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(ASLParserINTEGER_VALUE, 0)
}

func (s *Start_timeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Start_timeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Start_timeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterStart_time(s)
	}
}

func (s *Start_timeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitStart_time(s)
	}
}

func (p *ASLParser) Start_time() (localctx IStart_timeContext) {
	this := p
	_ = this

	localctx = NewStart_timeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, ASLParserRULE_start_time)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(803)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 81, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(800)
			p.Variable()
		}

	case 2:
		{
			p.SetState(801)
			p.Object_attribute()
		}

	case 3:
		{
			p.SetState(802)
			p.Match(ASLParserINTEGER_VALUE)
		}

	}

	return localctx
}

// IPeriodContext is an interface to support dynamic dispatch.
type IPeriodContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPeriodContext differentiates from other interfaces.
	IsPeriodContext()
}

type PeriodContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPeriodContext() *PeriodContext {
	var p = new(PeriodContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_period
	return p
}

func (*PeriodContext) IsPeriodContext() {}

func NewPeriodContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PeriodContext {
	var p = new(PeriodContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_period

	return p
}

func (s *PeriodContext) GetParser() antlr.Parser { return s.parser }

func (s *PeriodContext) Variable() IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *PeriodContext) Object_attribute() IObject_attributeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObject_attributeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObject_attributeContext)
}

func (s *PeriodContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(ASLParserINTEGER_VALUE, 0)
}

func (s *PeriodContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PeriodContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PeriodContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterPeriod(s)
	}
}

func (s *PeriodContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitPeriod(s)
	}
}

func (p *ASLParser) Period() (localctx IPeriodContext) {
	this := p
	_ = this

	localctx = NewPeriodContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, ASLParserRULE_period)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(808)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 82, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(805)
			p.Variable()
		}

	case 2:
		{
			p.SetState(806)
			p.Object_attribute()
		}

	case 3:
		{
			p.SetState(807)
			p.Match(ASLParserINTEGER_VALUE)
		}

	}

	return localctx
}

// ISet_operationContext is an interface to support dynamic dispatch.
type ISet_operationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSet_operationContext differentiates from other interfaces.
	IsSet_operationContext()
}

type Set_operationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySet_operationContext() *Set_operationContext {
	var p = new(Set_operationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_set_operation
	return p
}

func (*Set_operationContext) IsSet_operationContext() {}

func NewSet_operationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Set_operationContext {
	var p = new(Set_operationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_set_operation

	return p
}

func (s *Set_operationContext) GetParser() antlr.Parser { return s.parser }

func (s *Set_operationContext) Unique_set() IUnique_setContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnique_setContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnique_setContext)
}

func (s *Set_operationContext) Set_combination() ISet_combinationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISet_combinationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISet_combinationContext)
}

func (s *Set_operationContext) Set_difference() ISet_differenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISet_differenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISet_differenceContext)
}

func (s *Set_operationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Set_operationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Set_operationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterSet_operation(s)
	}
}

func (s *Set_operationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitSet_operation(s)
	}
}

func (p *ASLParser) Set_operation() (localctx ISet_operationContext) {
	this := p
	_ = this

	localctx = NewSet_operationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, ASLParserRULE_set_operation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(813)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 83, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(810)
			p.Unique_set()
		}

	case 2:
		{
			p.SetState(811)
			p.Set_combination()
		}

	case 3:
		{
			p.SetState(812)
			p.Set_difference()
		}

	}

	return localctx
}

// IUnique_setContext is an interface to support dynamic dispatch.
type IUnique_setContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnique_setContext differentiates from other interfaces.
	IsUnique_setContext()
}

type Unique_setContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnique_setContext() *Unique_setContext {
	var p = new(Unique_setContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_unique_set
	return p
}

func (*Unique_setContext) IsUnique_setContext() {}

func NewUnique_setContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unique_setContext {
	var p = new(Unique_setContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_unique_set

	return p
}

func (s *Unique_setContext) GetParser() antlr.Parser { return s.parser }

func (s *Unique_setContext) AllSet_variable() []ISet_variableContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISet_variableContext)(nil)).Elem())
	var tst = make([]ISet_variableContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISet_variableContext)
		}
	}

	return tst
}

func (s *Unique_setContext) Set_variable(i int) ISet_variableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISet_variableContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISet_variableContext)
}

func (s *Unique_setContext) EQ() antlr.TerminalNode {
	return s.GetToken(ASLParserEQ, 0)
}

func (s *Unique_setContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(ASLParserUNIQUE, 0)
}

func (s *Unique_setContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unique_setContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Unique_setContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterUnique_set(s)
	}
}

func (s *Unique_setContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitUnique_set(s)
	}
}

func (p *ASLParser) Unique_set() (localctx IUnique_setContext) {
	this := p
	_ = this

	localctx = NewUnique_setContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, ASLParserRULE_unique_set)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(815)
		p.Set_variable()
	}
	{
		p.SetState(816)
		p.Match(ASLParserEQ)
	}
	{
		p.SetState(817)
		p.Match(ASLParserUNIQUE)
	}
	{
		p.SetState(818)
		p.Set_variable()
	}

	return localctx
}

// ISet_combinationContext is an interface to support dynamic dispatch.
type ISet_combinationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSet_combinationContext differentiates from other interfaces.
	IsSet_combinationContext()
}

type Set_combinationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySet_combinationContext() *Set_combinationContext {
	var p = new(Set_combinationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_set_combination
	return p
}

func (*Set_combinationContext) IsSet_combinationContext() {}

func NewSet_combinationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Set_combinationContext {
	var p = new(Set_combinationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_set_combination

	return p
}

func (s *Set_combinationContext) GetParser() antlr.Parser { return s.parser }

func (s *Set_combinationContext) AllSet_variable() []ISet_variableContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISet_variableContext)(nil)).Elem())
	var tst = make([]ISet_variableContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISet_variableContext)
		}
	}

	return tst
}

func (s *Set_combinationContext) Set_variable(i int) ISet_variableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISet_variableContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISet_variableContext)
}

func (s *Set_combinationContext) EQ() antlr.TerminalNode {
	return s.GetToken(ASLParserEQ, 0)
}

func (s *Set_combinationContext) AND() antlr.TerminalNode {
	return s.GetToken(ASLParserAND, 0)
}

func (s *Set_combinationContext) UNION_OF() antlr.TerminalNode {
	return s.GetToken(ASLParserUNION_OF, 0)
}

func (s *Set_combinationContext) DISUNION_OF() antlr.TerminalNode {
	return s.GetToken(ASLParserDISUNION_OF, 0)
}

func (s *Set_combinationContext) INTERSECTION_OF() antlr.TerminalNode {
	return s.GetToken(ASLParserINTERSECTION_OF, 0)
}

func (s *Set_combinationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Set_combinationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Set_combinationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterSet_combination(s)
	}
}

func (s *Set_combinationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitSet_combination(s)
	}
}

func (p *ASLParser) Set_combination() (localctx ISet_combinationContext) {
	this := p
	_ = this

	localctx = NewSet_combinationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, ASLParserRULE_set_combination)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(820)
		p.Set_variable()
	}
	{
		p.SetState(821)
		p.Match(ASLParserEQ)
	}
	{
		p.SetState(822)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-87)&-(0x1f+1)) == 0 && ((1<<uint((_la-87)))&((1<<(ASLParserUNION_OF-87))|(1<<(ASLParserDISUNION_OF-87))|(1<<(ASLParserINTERSECTION_OF-87)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(823)
		p.Set_variable()
	}
	{
		p.SetState(824)
		p.Match(ASLParserAND)
	}
	{
		p.SetState(825)
		p.Set_variable()
	}

	return localctx
}

// ISet_differenceContext is an interface to support dynamic dispatch.
type ISet_differenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSet_differenceContext differentiates from other interfaces.
	IsSet_differenceContext()
}

type Set_differenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySet_differenceContext() *Set_differenceContext {
	var p = new(Set_differenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_set_difference
	return p
}

func (*Set_differenceContext) IsSet_differenceContext() {}

func NewSet_differenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Set_differenceContext {
	var p = new(Set_differenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_set_difference

	return p
}

func (s *Set_differenceContext) GetParser() antlr.Parser { return s.parser }

func (s *Set_differenceContext) AllSet_variable() []ISet_variableContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISet_variableContext)(nil)).Elem())
	var tst = make([]ISet_variableContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISet_variableContext)
		}
	}

	return tst
}

func (s *Set_differenceContext) Set_variable(i int) ISet_variableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISet_variableContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISet_variableContext)
}

func (s *Set_differenceContext) EQ() antlr.TerminalNode {
	return s.GetToken(ASLParserEQ, 0)
}

func (s *Set_differenceContext) NOT_IN() antlr.TerminalNode {
	return s.GetToken(ASLParserNOT_IN, 0)
}

func (s *Set_differenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Set_differenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Set_differenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterSet_difference(s)
	}
}

func (s *Set_differenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitSet_difference(s)
	}
}

func (p *ASLParser) Set_difference() (localctx ISet_differenceContext) {
	this := p
	_ = this

	localctx = NewSet_differenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, ASLParserRULE_set_difference)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(827)
		p.Set_variable()
	}
	{
		p.SetState(828)
		p.Match(ASLParserEQ)
	}
	{
		p.SetState(829)
		p.Set_variable()
	}
	{
		p.SetState(830)
		p.Match(ASLParserNOT_IN)
	}
	{
		p.SetState(831)
		p.Set_variable()
	}

	return localctx
}

// IStruct_statementContext is an interface to support dynamic dispatch.
type IStruct_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStruct_statementContext differentiates from other interfaces.
	IsStruct_statementContext()
}

type Struct_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStruct_statementContext() *Struct_statementContext {
	var p = new(Struct_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_struct_statement
	return p
}

func (*Struct_statementContext) IsStruct_statementContext() {}

func NewStruct_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Struct_statementContext {
	var p = new(Struct_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_struct_statement

	return p
}

func (s *Struct_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Struct_statementContext) Struct_definition() IStruct_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStruct_definitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStruct_definitionContext)
}

func (s *Struct_statementContext) Struct_instantiation() IStruct_instantiationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStruct_instantiationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStruct_instantiationContext)
}

func (s *Struct_statementContext) Struct_assembly() IStruct_assemblyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStruct_assemblyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStruct_assemblyContext)
}

func (s *Struct_statementContext) Struct_for_loop() IStruct_for_loopContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStruct_for_loopContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStruct_for_loopContext)
}

func (s *Struct_statementContext) Order_struct() IOrder_structContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOrder_structContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOrder_structContext)
}

func (s *Struct_statementContext) Struct_subset() IStruct_subsetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStruct_subsetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStruct_subsetContext)
}

func (s *Struct_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Struct_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Struct_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterStruct_statement(s)
	}
}

func (s *Struct_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitStruct_statement(s)
	}
}

func (p *ASLParser) Struct_statement() (localctx IStruct_statementContext) {
	this := p
	_ = this

	localctx = NewStruct_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, ASLParserRULE_struct_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(839)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 84, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(833)
			p.Struct_definition()
		}

	case 2:
		{
			p.SetState(834)
			p.Struct_instantiation()
		}

	case 3:
		{
			p.SetState(835)
			p.Struct_assembly()
		}

	case 4:
		{
			p.SetState(836)
			p.Struct_for_loop()
		}

	case 5:
		{
			p.SetState(837)
			p.Order_struct()
		}

	case 6:
		{
			p.SetState(838)
			p.Struct_subset()
		}

	}

	return localctx
}

// IStruct_definitionContext is an interface to support dynamic dispatch.
type IStruct_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStruct_definitionContext differentiates from other interfaces.
	IsStruct_definitionContext()
}

type Struct_definitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStruct_definitionContext() *Struct_definitionContext {
	var p = new(Struct_definitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_struct_definition
	return p
}

func (*Struct_definitionContext) IsStruct_definitionContext() {}

func NewStruct_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Struct_definitionContext {
	var p = new(Struct_definitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_struct_definition

	return p
}

func (s *Struct_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Struct_definitionContext) DEFINE() antlr.TerminalNode {
	return s.GetToken(ASLParserDEFINE, 0)
}

func (s *Struct_definitionContext) STRUCTURE() antlr.TerminalNode {
	return s.GetToken(ASLParserSTRUCTURE, 0)
}

func (s *Struct_definitionContext) Struct_type() IStruct_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStruct_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStruct_typeContext)
}

func (s *Struct_definitionContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(ASLParserNEWLINE)
}

func (s *Struct_definitionContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(ASLParserNEWLINE, i)
}

func (s *Struct_definitionContext) ENDDEFINE() antlr.TerminalNode {
	return s.GetToken(ASLParserENDDEFINE, 0)
}

func (s *Struct_definitionContext) AllMember_name() []IMember_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMember_nameContext)(nil)).Elem())
	var tst = make([]IMember_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMember_nameContext)
		}
	}

	return tst
}

func (s *Struct_definitionContext) Member_name(i int) IMember_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMember_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMember_nameContext)
}

func (s *Struct_definitionContext) AllMember_type() []IMember_typeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMember_typeContext)(nil)).Elem())
	var tst = make([]IMember_typeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMember_typeContext)
		}
	}

	return tst
}

func (s *Struct_definitionContext) Member_type(i int) IMember_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMember_typeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMember_typeContext)
}

func (s *Struct_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Struct_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Struct_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterStruct_definition(s)
	}
}

func (s *Struct_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitStruct_definition(s)
	}
}

func (p *ASLParser) Struct_definition() (localctx IStruct_definitionContext) {
	this := p
	_ = this

	localctx = NewStruct_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, ASLParserRULE_struct_definition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(841)
		p.Match(ASLParserDEFINE)
	}
	{
		p.SetState(842)
		p.Match(ASLParserSTRUCTURE)
	}
	{
		p.SetState(843)
		p.Struct_type()
	}
	{
		p.SetState(844)
		p.Match(ASLParserNEWLINE)
	}
	p.SetState(849)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == ASLParserLOWERCASE_ID || _la == ASLParserLOWERCASE_NUMBER_ID {
		{
			p.SetState(845)
			p.Member_name()
		}
		{
			p.SetState(846)
			p.Member_type()
		}
		{
			p.SetState(847)
			p.Match(ASLParserNEWLINE)
		}

		p.SetState(851)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(853)
		p.Match(ASLParserENDDEFINE)
	}

	return localctx
}

// IMember_nameContext is an interface to support dynamic dispatch.
type IMember_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMember_nameContext differentiates from other interfaces.
	IsMember_nameContext()
}

type Member_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMember_nameContext() *Member_nameContext {
	var p = new(Member_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_member_name
	return p
}

func (*Member_nameContext) IsMember_nameContext() {}

func NewMember_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Member_nameContext {
	var p = new(Member_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_member_name

	return p
}

func (s *Member_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Member_nameContext) LOWERCASE_ID() antlr.TerminalNode {
	return s.GetToken(ASLParserLOWERCASE_ID, 0)
}

func (s *Member_nameContext) LOWERCASE_NUMBER_ID() antlr.TerminalNode {
	return s.GetToken(ASLParserLOWERCASE_NUMBER_ID, 0)
}

func (s *Member_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Member_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Member_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterMember_name(s)
	}
}

func (s *Member_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitMember_name(s)
	}
}

func (p *ASLParser) Member_name() (localctx IMember_nameContext) {
	this := p
	_ = this

	localctx = NewMember_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, ASLParserRULE_member_name)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(855)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ASLParserLOWERCASE_ID || _la == ASLParserLOWERCASE_NUMBER_ID) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IMember_typeContext is an interface to support dynamic dispatch.
type IMember_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMember_typeContext differentiates from other interfaces.
	IsMember_typeContext()
}

type Member_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMember_typeContext() *Member_typeContext {
	var p = new(Member_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_member_type
	return p
}

func (*Member_typeContext) IsMember_typeContext() {}

func NewMember_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Member_typeContext {
	var p = new(Member_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_member_type

	return p
}

func (s *Member_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Member_typeContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(ASLParserINTEGER, 0)
}

func (s *Member_typeContext) REAL() antlr.TerminalNode {
	return s.GetToken(ASLParserREAL, 0)
}

func (s *Member_typeContext) BOOLEAN() antlr.TerminalNode {
	return s.GetToken(ASLParserBOOLEAN, 0)
}

func (s *Member_typeContext) TEXT() antlr.TerminalNode {
	return s.GetToken(ASLParserTEXT, 0)
}

func (s *Member_typeContext) DATE() antlr.TerminalNode {
	return s.GetToken(ASLParserDATE, 0)
}

func (s *Member_typeContext) TIME() antlr.TerminalNode {
	return s.GetToken(ASLParserTIME, 0)
}

func (s *Member_typeContext) Struct_type() IStruct_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStruct_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStruct_typeContext)
}

func (s *Member_typeContext) User_defined_type() IUser_defined_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUser_defined_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUser_defined_typeContext)
}

func (s *Member_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Member_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Member_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterMember_type(s)
	}
}

func (s *Member_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitMember_type(s)
	}
}

func (p *ASLParser) Member_type() (localctx IMember_typeContext) {
	this := p
	_ = this

	localctx = NewMember_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, ASLParserRULE_member_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(865)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASLParserINTEGER:
		{
			p.SetState(857)
			p.Match(ASLParserINTEGER)
		}

	case ASLParserREAL:
		{
			p.SetState(858)
			p.Match(ASLParserREAL)
		}

	case ASLParserBOOLEAN:
		{
			p.SetState(859)
			p.Match(ASLParserBOOLEAN)
		}

	case ASLParserTEXT:
		{
			p.SetState(860)
			p.Match(ASLParserTEXT)
		}

	case ASLParserDATE:
		{
			p.SetState(861)
			p.Match(ASLParserDATE)
		}

	case ASLParserTIME:
		{
			p.SetState(862)
			p.Match(ASLParserTIME)
		}

	case ASLParserLOWERCASE_ID, ASLParserLEADING_FIRST_UPPERCASE_ID, ASLParserLOWERCASE_NUMBER_ID:
		{
			p.SetState(863)
			p.Struct_type()
		}

	case ASLParserUPPERCASE_ID:
		{
			p.SetState(864)
			p.User_defined_type()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IStruct_instantiationContext is an interface to support dynamic dispatch.
type IStruct_instantiationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStruct_instantiationContext differentiates from other interfaces.
	IsStruct_instantiationContext()
}

type Struct_instantiationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStruct_instantiationContext() *Struct_instantiationContext {
	var p = new(Struct_instantiationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_struct_instantiation
	return p
}

func (*Struct_instantiationContext) IsStruct_instantiationContext() {}

func NewStruct_instantiationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Struct_instantiationContext {
	var p = new(Struct_instantiationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_struct_instantiation

	return p
}

func (s *Struct_instantiationContext) GetParser() antlr.Parser { return s.parser }

func (s *Struct_instantiationContext) Struct_() IStruct_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStruct_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStruct_Context)
}

func (s *Struct_instantiationContext) IS() antlr.TerminalNode {
	return s.GetToken(ASLParserIS, 0)
}

func (s *Struct_instantiationContext) Struct_type() IStruct_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStruct_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStruct_typeContext)
}

func (s *Struct_instantiationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Struct_instantiationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Struct_instantiationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterStruct_instantiation(s)
	}
}

func (s *Struct_instantiationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitStruct_instantiation(s)
	}
}

func (p *ASLParser) Struct_instantiation() (localctx IStruct_instantiationContext) {
	this := p
	_ = this

	localctx = NewStruct_instantiationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, ASLParserRULE_struct_instantiation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(867)
		p.Struct_()
	}
	{
		p.SetState(868)
		p.Match(ASLParserIS)
	}
	{
		p.SetState(869)
		p.Struct_type()
	}

	return localctx
}

// IStruct_assemblyContext is an interface to support dynamic dispatch.
type IStruct_assemblyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStruct_assemblyContext differentiates from other interfaces.
	IsStruct_assemblyContext()
}

type Struct_assemblyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStruct_assemblyContext() *Struct_assemblyContext {
	var p = new(Struct_assemblyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_struct_assembly
	return p
}

func (*Struct_assemblyContext) IsStruct_assemblyContext() {}

func NewStruct_assemblyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Struct_assemblyContext {
	var p = new(Struct_assemblyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_struct_assembly

	return p
}

func (s *Struct_assemblyContext) GetParser() antlr.Parser { return s.parser }

func (s *Struct_assemblyContext) APPEND() antlr.TerminalNode {
	return s.GetToken(ASLParserAPPEND, 0)
}

func (s *Struct_assemblyContext) L_SQUARE() antlr.TerminalNode {
	return s.GetToken(ASLParserL_SQUARE, 0)
}

func (s *Struct_assemblyContext) Value_list() IValue_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValue_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValue_listContext)
}

func (s *Struct_assemblyContext) R_SQUARE() antlr.TerminalNode {
	return s.GetToken(ASLParserR_SQUARE, 0)
}

func (s *Struct_assemblyContext) TO() antlr.TerminalNode {
	return s.GetToken(ASLParserTO, 0)
}

func (s *Struct_assemblyContext) Struct_() IStruct_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStruct_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStruct_Context)
}

func (s *Struct_assemblyContext) Member_name() IMember_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMember_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMember_nameContext)
}

func (s *Struct_assemblyContext) ORDERED_BY() antlr.TerminalNode {
	return s.GetToken(ASLParserORDERED_BY, 0)
}

func (s *Struct_assemblyContext) REVERSE_ORDERED_BY() antlr.TerminalNode {
	return s.GetToken(ASLParserREVERSE_ORDERED_BY, 0)
}

func (s *Struct_assemblyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Struct_assemblyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Struct_assemblyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterStruct_assembly(s)
	}
}

func (s *Struct_assemblyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitStruct_assembly(s)
	}
}

func (p *ASLParser) Struct_assembly() (localctx IStruct_assemblyContext) {
	this := p
	_ = this

	localctx = NewStruct_assemblyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, ASLParserRULE_struct_assembly)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(871)
		p.Match(ASLParserAPPEND)
	}
	{
		p.SetState(872)
		p.Match(ASLParserL_SQUARE)
	}
	{
		p.SetState(873)
		p.Value_list()
	}
	{
		p.SetState(874)
		p.Match(ASLParserR_SQUARE)
	}
	{
		p.SetState(875)
		p.Match(ASLParserTO)
	}
	{
		p.SetState(876)
		p.Struct_()
	}
	p.SetState(879)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASLParserREVERSE_ORDERED_BY || _la == ASLParserORDERED_BY {
		{
			p.SetState(877)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ASLParserREVERSE_ORDERED_BY || _la == ASLParserORDERED_BY) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(878)
			p.Member_name()
		}

	}

	return localctx
}

// IStruct_for_loopContext is an interface to support dynamic dispatch.
type IStruct_for_loopContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStruct_for_loopContext differentiates from other interfaces.
	IsStruct_for_loopContext()
}

type Struct_for_loopContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStruct_for_loopContext() *Struct_for_loopContext {
	var p = new(Struct_for_loopContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_struct_for_loop
	return p
}

func (*Struct_for_loopContext) IsStruct_for_loopContext() {}

func NewStruct_for_loopContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Struct_for_loopContext {
	var p = new(Struct_for_loopContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_struct_for_loop

	return p
}

func (s *Struct_for_loopContext) GetParser() antlr.Parser { return s.parser }

func (s *Struct_for_loopContext) FOR() antlr.TerminalNode {
	return s.GetToken(ASLParserFOR, 0)
}

func (s *Struct_for_loopContext) L_SQUARE() antlr.TerminalNode {
	return s.GetToken(ASLParserL_SQUARE, 0)
}

func (s *Struct_for_loopContext) Variable_list() IVariable_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_listContext)
}

func (s *Struct_for_loopContext) R_SQUARE() antlr.TerminalNode {
	return s.GetToken(ASLParserR_SQUARE, 0)
}

func (s *Struct_for_loopContext) IN() antlr.TerminalNode {
	return s.GetToken(ASLParserIN, 0)
}

func (s *Struct_for_loopContext) Struct_() IStruct_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStruct_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStruct_Context)
}

func (s *Struct_for_loopContext) DO() antlr.TerminalNode {
	return s.GetToken(ASLParserDO, 0)
}

func (s *Struct_for_loopContext) NEWLINE() antlr.TerminalNode {
	return s.GetToken(ASLParserNEWLINE, 0)
}

func (s *Struct_for_loopContext) ENDFOR() antlr.TerminalNode {
	return s.GetToken(ASLParserENDFOR, 0)
}

func (s *Struct_for_loopContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *Struct_for_loopContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *Struct_for_loopContext) Break_statement() IBreak_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBreak_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBreak_statementContext)
}

func (s *Struct_for_loopContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Struct_for_loopContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Struct_for_loopContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterStruct_for_loop(s)
	}
}

func (s *Struct_for_loopContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitStruct_for_loop(s)
	}
}

func (p *ASLParser) Struct_for_loop() (localctx IStruct_for_loopContext) {
	this := p
	_ = this

	localctx = NewStruct_for_loopContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, ASLParserRULE_struct_for_loop)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(881)
		p.Match(ASLParserFOR)
	}
	{
		p.SetState(882)
		p.Match(ASLParserL_SQUARE)
	}
	{
		p.SetState(883)
		p.Variable_list()
	}
	{
		p.SetState(884)
		p.Match(ASLParserR_SQUARE)
	}
	{
		p.SetState(885)
		p.Match(ASLParserIN)
	}
	{
		p.SetState(886)
		p.Struct_()
	}
	{
		p.SetState(887)
		p.Match(ASLParserDO)
	}
	{
		p.SetState(888)
		p.Match(ASLParserNEWLINE)
	}
	p.SetState(892)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ASLParserTHIS)|(1<<ASLParserDELETE)|(1<<ASLParserLINK)|(1<<ASLParserUNLINK)|(1<<ASLParserGENERATE))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(ASLParserSWITCH-36))|(1<<(ASLParserIF-36))|(1<<(ASLParserFOR-36))|(1<<(ASLParserLOOP-36))|(1<<(ASLParserINLINE-36))|(1<<(ASLParserDEFINE-36))|(1<<(ASLParserAPPEND-36)))) != 0) || (((_la-76)&-(0x1f+1)) == 0 && ((1<<uint((_la-76)))&((1<<(ASLParserL_CURLY-76))|(1<<(ASLParserL_SQUARE-76))|(1<<(ASLParserLOWERCASE_ID-76))|(1<<(ASLParserLOWERCASE_NUMBER_ID-76)))) != 0) {
		{
			p.SetState(889)
			p.Statement()
		}

		p.SetState(894)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(902)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASLParserBREAK || _la == ASLParserBREAKIF {
		{
			p.SetState(895)
			p.Break_statement()
		}
		p.SetState(899)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ASLParserTHIS)|(1<<ASLParserDELETE)|(1<<ASLParserLINK)|(1<<ASLParserUNLINK)|(1<<ASLParserGENERATE))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(ASLParserSWITCH-36))|(1<<(ASLParserIF-36))|(1<<(ASLParserFOR-36))|(1<<(ASLParserLOOP-36))|(1<<(ASLParserINLINE-36))|(1<<(ASLParserDEFINE-36))|(1<<(ASLParserAPPEND-36)))) != 0) || (((_la-76)&-(0x1f+1)) == 0 && ((1<<uint((_la-76)))&((1<<(ASLParserL_CURLY-76))|(1<<(ASLParserL_SQUARE-76))|(1<<(ASLParserLOWERCASE_ID-76))|(1<<(ASLParserLOWERCASE_NUMBER_ID-76)))) != 0) {
			{
				p.SetState(896)
				p.Statement()
			}

			p.SetState(901)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(904)
		p.Match(ASLParserENDFOR)
	}

	return localctx
}

// IOrder_structContext is an interface to support dynamic dispatch.
type IOrder_structContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOrder_structContext differentiates from other interfaces.
	IsOrder_structContext()
}

type Order_structContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrder_structContext() *Order_structContext {
	var p = new(Order_structContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_order_struct
	return p
}

func (*Order_structContext) IsOrder_structContext() {}

func NewOrder_structContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Order_structContext {
	var p = new(Order_structContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_order_struct

	return p
}

func (s *Order_structContext) GetParser() antlr.Parser { return s.parser }

func (s *Order_structContext) AllStruct_() []IStruct_Context {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStruct_Context)(nil)).Elem())
	var tst = make([]IStruct_Context, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStruct_Context)
		}
	}

	return tst
}

func (s *Order_structContext) Struct_(i int) IStruct_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStruct_Context)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStruct_Context)
}

func (s *Order_structContext) EQ() antlr.TerminalNode {
	return s.GetToken(ASLParserEQ, 0)
}

func (s *Order_structContext) Member_name() IMember_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMember_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMember_nameContext)
}

func (s *Order_structContext) ORDERED_BY() antlr.TerminalNode {
	return s.GetToken(ASLParserORDERED_BY, 0)
}

func (s *Order_structContext) REVERSE_ORDERED_BY() antlr.TerminalNode {
	return s.GetToken(ASLParserREVERSE_ORDERED_BY, 0)
}

func (s *Order_structContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Order_structContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Order_structContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterOrder_struct(s)
	}
}

func (s *Order_structContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitOrder_struct(s)
	}
}

func (p *ASLParser) Order_struct() (localctx IOrder_structContext) {
	this := p
	_ = this

	localctx = NewOrder_structContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, ASLParserRULE_order_struct)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(906)
		p.Struct_()
	}
	{
		p.SetState(907)
		p.Match(ASLParserEQ)
	}
	{
		p.SetState(908)
		p.Struct_()
	}
	{
		p.SetState(909)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ASLParserREVERSE_ORDERED_BY || _la == ASLParserORDERED_BY) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(910)
		p.Member_name()
	}

	return localctx
}

// IStruct_subsetContext is an interface to support dynamic dispatch.
type IStruct_subsetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStruct_subsetContext differentiates from other interfaces.
	IsStruct_subsetContext()
}

type Struct_subsetContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStruct_subsetContext() *Struct_subsetContext {
	var p = new(Struct_subsetContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_struct_subset
	return p
}

func (*Struct_subsetContext) IsStruct_subsetContext() {}

func NewStruct_subsetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Struct_subsetContext {
	var p = new(Struct_subsetContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_struct_subset

	return p
}

func (s *Struct_subsetContext) GetParser() antlr.Parser { return s.parser }

func (s *Struct_subsetContext) AllStruct_() []IStruct_Context {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStruct_Context)(nil)).Elem())
	var tst = make([]IStruct_Context, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStruct_Context)
		}
	}

	return tst
}

func (s *Struct_subsetContext) Struct_(i int) IStruct_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStruct_Context)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStruct_Context)
}

func (s *Struct_subsetContext) EQ() antlr.TerminalNode {
	return s.GetToken(ASLParserEQ, 0)
}

func (s *Struct_subsetContext) WHERE() antlr.TerminalNode {
	return s.GetToken(ASLParserWHERE, 0)
}

func (s *Struct_subsetContext) Struct_condition() IStruct_conditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStruct_conditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStruct_conditionContext)
}

func (s *Struct_subsetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Struct_subsetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Struct_subsetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterStruct_subset(s)
	}
}

func (s *Struct_subsetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitStruct_subset(s)
	}
}

func (p *ASLParser) Struct_subset() (localctx IStruct_subsetContext) {
	this := p
	_ = this

	localctx = NewStruct_subsetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, ASLParserRULE_struct_subset)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(912)
		p.Struct_()
	}
	{
		p.SetState(913)
		p.Match(ASLParserEQ)
	}
	{
		p.SetState(914)
		p.Struct_()
	}
	{
		p.SetState(915)
		p.Match(ASLParserWHERE)
	}
	{
		p.SetState(916)
		p.Struct_condition()
	}

	return localctx
}

// IStruct_conditionContext is an interface to support dynamic dispatch.
type IStruct_conditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStruct_conditionContext differentiates from other interfaces.
	IsStruct_conditionContext()
}

type Struct_conditionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStruct_conditionContext() *Struct_conditionContext {
	var p = new(Struct_conditionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_struct_condition
	return p
}

func (*Struct_conditionContext) IsStruct_conditionContext() {}

func NewStruct_conditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Struct_conditionContext {
	var p = new(Struct_conditionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_struct_condition

	return p
}

func (s *Struct_conditionContext) GetParser() antlr.Parser { return s.parser }

func (s *Struct_conditionContext) Member_name() IMember_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMember_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMember_nameContext)
}

func (s *Struct_conditionContext) Logical_operator() ILogical_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILogical_operatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILogical_operatorContext)
}

func (s *Struct_conditionContext) Component() IComponentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComponentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComponentContext)
}

func (s *Struct_conditionContext) AllStruct_condition() []IStruct_conditionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStruct_conditionContext)(nil)).Elem())
	var tst = make([]IStruct_conditionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStruct_conditionContext)
		}
	}

	return tst
}

func (s *Struct_conditionContext) Struct_condition(i int) IStruct_conditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStruct_conditionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStruct_conditionContext)
}

func (s *Struct_conditionContext) AllAND() []antlr.TerminalNode {
	return s.GetTokens(ASLParserAND)
}

func (s *Struct_conditionContext) AND(i int) antlr.TerminalNode {
	return s.GetToken(ASLParserAND, i)
}

func (s *Struct_conditionContext) AllOR() []antlr.TerminalNode {
	return s.GetTokens(ASLParserOR)
}

func (s *Struct_conditionContext) OR(i int) antlr.TerminalNode {
	return s.GetToken(ASLParserOR, i)
}

func (s *Struct_conditionContext) AllLOGICAL_AND() []antlr.TerminalNode {
	return s.GetTokens(ASLParserLOGICAL_AND)
}

func (s *Struct_conditionContext) LOGICAL_AND(i int) antlr.TerminalNode {
	return s.GetToken(ASLParserLOGICAL_AND, i)
}

func (s *Struct_conditionContext) AllLOGICAL_OR() []antlr.TerminalNode {
	return s.GetTokens(ASLParserLOGICAL_OR)
}

func (s *Struct_conditionContext) LOGICAL_OR(i int) antlr.TerminalNode {
	return s.GetToken(ASLParserLOGICAL_OR, i)
}

func (s *Struct_conditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Struct_conditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Struct_conditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterStruct_condition(s)
	}
}

func (s *Struct_conditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitStruct_condition(s)
	}
}

func (p *ASLParser) Struct_condition() (localctx IStruct_conditionContext) {
	this := p
	_ = this

	localctx = NewStruct_conditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, ASLParserRULE_struct_condition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(918)
		p.Member_name()
	}
	{
		p.SetState(919)
		p.Logical_operator()
	}
	{
		p.SetState(920)
		p.Component()
	}

	p.SetState(926)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 91, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(922)
				_la = p.GetTokenStream().LA(1)

				if !(_la == ASLParserAND || _la == ASLParserOR || _la == ASLParserLOGICAL_AND || _la == ASLParserLOGICAL_OR) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(923)
				p.Struct_condition()
			}

		}
		p.SetState(928)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 91, p.GetParserRuleContext())
	}

	return localctx
}

// IStruct_Context is an interface to support dynamic dispatch.
type IStruct_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStruct_Context differentiates from other interfaces.
	IsStruct_Context()
}

type Struct_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStruct_Context() *Struct_Context {
	var p = new(Struct_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_struct_
	return p
}

func (*Struct_Context) IsStruct_Context() {}

func NewStruct_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Struct_Context {
	var p = new(Struct_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_struct_

	return p
}

func (s *Struct_Context) GetParser() antlr.Parser { return s.parser }

func (s *Struct_Context) L_CURLY() antlr.TerminalNode {
	return s.GetToken(ASLParserL_CURLY, 0)
}

func (s *Struct_Context) R_CURLY() antlr.TerminalNode {
	return s.GetToken(ASLParserR_CURLY, 0)
}

func (s *Struct_Context) LOWERCASE_ID() antlr.TerminalNode {
	return s.GetToken(ASLParserLOWERCASE_ID, 0)
}

func (s *Struct_Context) LOWERCASE_NUMBER_ID() antlr.TerminalNode {
	return s.GetToken(ASLParserLOWERCASE_NUMBER_ID, 0)
}

func (s *Struct_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Struct_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Struct_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterStruct_(s)
	}
}

func (s *Struct_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitStruct_(s)
	}
}

func (p *ASLParser) Struct_() (localctx IStruct_Context) {
	this := p
	_ = this

	localctx = NewStruct_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, ASLParserRULE_struct_)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(929)
		p.Match(ASLParserL_CURLY)
	}
	{
		p.SetState(930)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ASLParserLOWERCASE_ID || _la == ASLParserLOWERCASE_NUMBER_ID) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(931)
		p.Match(ASLParserR_CURLY)
	}

	return localctx
}

// IStruct_typeContext is an interface to support dynamic dispatch.
type IStruct_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStruct_typeContext differentiates from other interfaces.
	IsStruct_typeContext()
}

type Struct_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStruct_typeContext() *Struct_typeContext {
	var p = new(Struct_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_struct_type
	return p
}

func (*Struct_typeContext) IsStruct_typeContext() {}

func NewStruct_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Struct_typeContext {
	var p = new(Struct_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_struct_type

	return p
}

func (s *Struct_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Struct_typeContext) LOWERCASE_ID() antlr.TerminalNode {
	return s.GetToken(ASLParserLOWERCASE_ID, 0)
}

func (s *Struct_typeContext) LOWERCASE_NUMBER_ID() antlr.TerminalNode {
	return s.GetToken(ASLParserLOWERCASE_NUMBER_ID, 0)
}

func (s *Struct_typeContext) LEADING_FIRST_UPPERCASE_ID() antlr.TerminalNode {
	return s.GetToken(ASLParserLEADING_FIRST_UPPERCASE_ID, 0)
}

func (s *Struct_typeContext) DOT() antlr.TerminalNode {
	return s.GetToken(ASLParserDOT, 0)
}

func (s *Struct_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Struct_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Struct_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterStruct_type(s)
	}
}

func (s *Struct_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitStruct_type(s)
	}
}

func (p *ASLParser) Struct_type() (localctx IStruct_typeContext) {
	this := p
	_ = this

	localctx = NewStruct_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, ASLParserRULE_struct_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(938)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASLParserLOWERCASE_ID:
		{
			p.SetState(933)
			p.Match(ASLParserLOWERCASE_ID)
		}

	case ASLParserLOWERCASE_NUMBER_ID:
		{
			p.SetState(934)
			p.Match(ASLParserLOWERCASE_NUMBER_ID)
		}

	case ASLParserLEADING_FIRST_UPPERCASE_ID:
		{
			p.SetState(935)
			p.Match(ASLParserLEADING_FIRST_UPPERCASE_ID)
		}
		{
			p.SetState(936)
			p.Match(ASLParserDOT)
		}
		{
			p.SetState(937)
			p.Match(ASLParserLOWERCASE_ID)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IValue_listContext is an interface to support dynamic dispatch.
type IValue_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsValue_listContext differentiates from other interfaces.
	IsValue_listContext()
}

type Value_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValue_listContext() *Value_listContext {
	var p = new(Value_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_value_list
	return p
}

func (*Value_listContext) IsValue_listContext() {}

func NewValue_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Value_listContext {
	var p = new(Value_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_value_list

	return p
}

func (s *Value_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Value_listContext) AllStruct_value() []IStruct_valueContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStruct_valueContext)(nil)).Elem())
	var tst = make([]IStruct_valueContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStruct_valueContext)
		}
	}

	return tst
}

func (s *Value_listContext) Struct_value(i int) IStruct_valueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStruct_valueContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStruct_valueContext)
}

func (s *Value_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ASLParserCOMMA)
}

func (s *Value_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ASLParserCOMMA, i)
}

func (s *Value_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Value_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Value_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterValue_list(s)
	}
}

func (s *Value_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitValue_list(s)
	}
}

func (p *ASLParser) Value_list() (localctx IValue_listContext) {
	this := p
	_ = this

	localctx = NewValue_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, ASLParserRULE_value_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(940)
		p.Struct_value()
	}
	p.SetState(945)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ASLParserCOMMA {
		{
			p.SetState(941)
			p.Match(ASLParserCOMMA)
		}
		{
			p.SetState(942)
			p.Struct_value()
		}

		p.SetState(947)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IStruct_valueContext is an interface to support dynamic dispatch.
type IStruct_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStruct_valueContext differentiates from other interfaces.
	IsStruct_valueContext()
}

type Struct_valueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStruct_valueContext() *Struct_valueContext {
	var p = new(Struct_valueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_struct_value
	return p
}

func (*Struct_valueContext) IsStruct_valueContext() {}

func NewStruct_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Struct_valueContext {
	var p = new(Struct_valueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_struct_value

	return p
}

func (s *Struct_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *Struct_valueContext) Variable() IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *Struct_valueContext) Set_variable() ISet_variableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISet_variableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISet_variableContext)
}

func (s *Struct_valueContext) Constant() IConstantContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstantContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *Struct_valueContext) Object_attribute() IObject_attributeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObject_attributeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObject_attributeContext)
}

func (s *Struct_valueContext) Struct_() IStruct_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStruct_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStruct_Context)
}

func (s *Struct_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Struct_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Struct_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterStruct_value(s)
	}
}

func (s *Struct_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitStruct_value(s)
	}
}

func (p *ASLParser) Struct_value() (localctx IStruct_valueContext) {
	this := p
	_ = this

	localctx = NewStruct_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, ASLParserRULE_struct_value)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(953)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 94, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(948)
			p.Variable()
		}

	case 2:
		{
			p.SetState(949)
			p.Set_variable()
		}

	case 3:
		{
			p.SetState(950)
			p.Constant()
		}

	case 4:
		{
			p.SetState(951)
			p.Object_attribute()
		}

	case 5:
		{
			p.SetState(952)
			p.Struct_()
		}

	}

	return localctx
}

// IVariable_listContext is an interface to support dynamic dispatch.
type IVariable_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariable_listContext differentiates from other interfaces.
	IsVariable_listContext()
}

type Variable_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariable_listContext() *Variable_listContext {
	var p = new(Variable_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_variable_list
	return p
}

func (*Variable_listContext) IsVariable_listContext() {}

func NewVariable_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Variable_listContext {
	var p = new(Variable_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_variable_list

	return p
}

func (s *Variable_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Variable_listContext) AllVariable() []IVariableContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariableContext)(nil)).Elem())
	var tst = make([]IVariableContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariableContext)
		}
	}

	return tst
}

func (s *Variable_listContext) Variable(i int) IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *Variable_listContext) AllStruct_() []IStruct_Context {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStruct_Context)(nil)).Elem())
	var tst = make([]IStruct_Context, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStruct_Context)
		}
	}

	return tst
}

func (s *Variable_listContext) Struct_(i int) IStruct_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStruct_Context)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStruct_Context)
}

func (s *Variable_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ASLParserCOMMA)
}

func (s *Variable_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ASLParserCOMMA, i)
}

func (s *Variable_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Variable_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Variable_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterVariable_list(s)
	}
}

func (s *Variable_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitVariable_list(s)
	}
}

func (p *ASLParser) Variable_list() (localctx IVariable_listContext) {
	this := p
	_ = this

	localctx = NewVariable_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, ASLParserRULE_variable_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(957)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASLParserLOWERCASE_ID, ASLParserLOWERCASE_NUMBER_ID:
		{
			p.SetState(955)
			p.Variable()
		}

	case ASLParserL_CURLY:
		{
			p.SetState(956)
			p.Struct_()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(966)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ASLParserCOMMA {
		{
			p.SetState(959)
			p.Match(ASLParserCOMMA)
		}
		p.SetState(962)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case ASLParserLOWERCASE_ID, ASLParserLOWERCASE_NUMBER_ID:
			{
				p.SetState(960)
				p.Variable()
			}

		case ASLParserL_CURLY:
			{
				p.SetState(961)
				p.Struct_()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(968)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISwitch_statementContext is an interface to support dynamic dispatch.
type ISwitch_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSwitch_statementContext differentiates from other interfaces.
	IsSwitch_statementContext()
}

type Switch_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySwitch_statementContext() *Switch_statementContext {
	var p = new(Switch_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_switch_statement
	return p
}

func (*Switch_statementContext) IsSwitch_statementContext() {}

func NewSwitch_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Switch_statementContext {
	var p = new(Switch_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_switch_statement

	return p
}

func (s *Switch_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Switch_statementContext) SWITCH() antlr.TerminalNode {
	return s.GetToken(ASLParserSWITCH, 0)
}

func (s *Switch_statementContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(ASLParserNEWLINE)
}

func (s *Switch_statementContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(ASLParserNEWLINE, i)
}

func (s *Switch_statementContext) ENDSWITCH() antlr.TerminalNode {
	return s.GetToken(ASLParserENDSWITCH, 0)
}

func (s *Switch_statementContext) Variable() IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *Switch_statementContext) Object_attribute() IObject_attributeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObject_attributeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObject_attributeContext)
}

func (s *Switch_statementContext) AllCASE() []antlr.TerminalNode {
	return s.GetTokens(ASLParserCASE)
}

func (s *Switch_statementContext) CASE(i int) antlr.TerminalNode {
	return s.GetToken(ASLParserCASE, i)
}

func (s *Switch_statementContext) AllConstant() []IConstantContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConstantContext)(nil)).Elem())
	var tst = make([]IConstantContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConstantContext)
		}
	}

	return tst
}

func (s *Switch_statementContext) Constant(i int) IConstantContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstantContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *Switch_statementContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(ASLParserDEFAULT, 0)
}

func (s *Switch_statementContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *Switch_statementContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *Switch_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Switch_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Switch_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterSwitch_statement(s)
	}
}

func (s *Switch_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitSwitch_statement(s)
	}
}

func (p *ASLParser) Switch_statement() (localctx ISwitch_statementContext) {
	this := p
	_ = this

	localctx = NewSwitch_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, ASLParserRULE_switch_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(969)
		p.Match(ASLParserSWITCH)
	}
	p.SetState(972)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 98, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(970)
			p.Variable()
		}

	case 2:
		{
			p.SetState(971)
			p.Object_attribute()
		}

	}
	{
		p.SetState(974)
		p.Match(ASLParserNEWLINE)
	}
	p.SetState(984)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == ASLParserCASE {
		{
			p.SetState(975)
			p.Match(ASLParserCASE)
		}
		{
			p.SetState(976)
			p.Constant()
		}
		{
			p.SetState(977)
			p.Match(ASLParserNEWLINE)
		}
		p.SetState(981)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ASLParserTHIS)|(1<<ASLParserDELETE)|(1<<ASLParserLINK)|(1<<ASLParserUNLINK)|(1<<ASLParserGENERATE))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(ASLParserSWITCH-36))|(1<<(ASLParserIF-36))|(1<<(ASLParserFOR-36))|(1<<(ASLParserLOOP-36))|(1<<(ASLParserINLINE-36))|(1<<(ASLParserDEFINE-36))|(1<<(ASLParserAPPEND-36)))) != 0) || (((_la-76)&-(0x1f+1)) == 0 && ((1<<uint((_la-76)))&((1<<(ASLParserL_CURLY-76))|(1<<(ASLParserL_SQUARE-76))|(1<<(ASLParserLOWERCASE_ID-76))|(1<<(ASLParserLOWERCASE_NUMBER_ID-76)))) != 0) {
			{
				p.SetState(978)
				p.Statement()
			}

			p.SetState(983)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

		p.SetState(986)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(995)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASLParserDEFAULT {
		{
			p.SetState(988)
			p.Match(ASLParserDEFAULT)
		}
		{
			p.SetState(989)
			p.Match(ASLParserNEWLINE)
		}
		p.SetState(991)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ASLParserTHIS)|(1<<ASLParserDELETE)|(1<<ASLParserLINK)|(1<<ASLParserUNLINK)|(1<<ASLParserGENERATE))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(ASLParserSWITCH-36))|(1<<(ASLParserIF-36))|(1<<(ASLParserFOR-36))|(1<<(ASLParserLOOP-36))|(1<<(ASLParserINLINE-36))|(1<<(ASLParserDEFINE-36))|(1<<(ASLParserAPPEND-36)))) != 0) || (((_la-76)&-(0x1f+1)) == 0 && ((1<<uint((_la-76)))&((1<<(ASLParserL_CURLY-76))|(1<<(ASLParserL_SQUARE-76))|(1<<(ASLParserLOWERCASE_ID-76))|(1<<(ASLParserLOWERCASE_NUMBER_ID-76)))) != 0) {
			{
				p.SetState(990)
				p.Statement()
			}

			p.SetState(993)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(997)
		p.Match(ASLParserENDSWITCH)
	}

	return localctx
}

// IIf_statementContext is an interface to support dynamic dispatch.
type IIf_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIf_statementContext differentiates from other interfaces.
	IsIf_statementContext()
}

type If_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIf_statementContext() *If_statementContext {
	var p = new(If_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_if_statement
	return p
}

func (*If_statementContext) IsIf_statementContext() {}

func NewIf_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *If_statementContext {
	var p = new(If_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_if_statement

	return p
}

func (s *If_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *If_statementContext) IF() antlr.TerminalNode {
	return s.GetToken(ASLParserIF, 0)
}

func (s *If_statementContext) THEN() antlr.TerminalNode {
	return s.GetToken(ASLParserTHEN, 0)
}

func (s *If_statementContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(ASLParserNEWLINE)
}

func (s *If_statementContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(ASLParserNEWLINE, i)
}

func (s *If_statementContext) ENDIF() antlr.TerminalNode {
	return s.GetToken(ASLParserENDIF, 0)
}

func (s *If_statementContext) Logical_condition() ILogical_conditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILogical_conditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILogical_conditionContext)
}

func (s *If_statementContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *If_statementContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *If_statementContext) ELSE() antlr.TerminalNode {
	return s.GetToken(ASLParserELSE, 0)
}

func (s *If_statementContext) L_PAREN() antlr.TerminalNode {
	return s.GetToken(ASLParserL_PAREN, 0)
}

func (s *If_statementContext) R_PAREN() antlr.TerminalNode {
	return s.GetToken(ASLParserR_PAREN, 0)
}

func (s *If_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *If_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *If_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterIf_statement(s)
	}
}

func (s *If_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitIf_statement(s)
	}
}

func (p *ASLParser) If_statement() (localctx IIf_statementContext) {
	this := p
	_ = this

	localctx = NewIf_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, ASLParserRULE_if_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(999)
		p.Match(ASLParserIF)
	}
	p.SetState(1005)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 103, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1000)
			p.Logical_condition()
		}

	case 2:
		{
			p.SetState(1001)
			p.Match(ASLParserL_PAREN)
		}
		{
			p.SetState(1002)
			p.Logical_condition()
		}
		{
			p.SetState(1003)
			p.Match(ASLParserR_PAREN)
		}

	}
	{
		p.SetState(1007)
		p.Match(ASLParserTHEN)
	}
	{
		p.SetState(1008)
		p.Match(ASLParserNEWLINE)
	}
	p.SetState(1010)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ASLParserTHIS)|(1<<ASLParserDELETE)|(1<<ASLParserLINK)|(1<<ASLParserUNLINK)|(1<<ASLParserGENERATE))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(ASLParserSWITCH-36))|(1<<(ASLParserIF-36))|(1<<(ASLParserFOR-36))|(1<<(ASLParserLOOP-36))|(1<<(ASLParserINLINE-36))|(1<<(ASLParserDEFINE-36))|(1<<(ASLParserAPPEND-36)))) != 0) || (((_la-76)&-(0x1f+1)) == 0 && ((1<<uint((_la-76)))&((1<<(ASLParserL_CURLY-76))|(1<<(ASLParserL_SQUARE-76))|(1<<(ASLParserLOWERCASE_ID-76))|(1<<(ASLParserLOWERCASE_NUMBER_ID-76)))) != 0) {
		{
			p.SetState(1009)
			p.Statement()
		}

		p.SetState(1012)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1021)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASLParserELSE {
		{
			p.SetState(1014)
			p.Match(ASLParserELSE)
		}
		{
			p.SetState(1015)
			p.Match(ASLParserNEWLINE)
		}
		p.SetState(1017)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ASLParserTHIS)|(1<<ASLParserDELETE)|(1<<ASLParserLINK)|(1<<ASLParserUNLINK)|(1<<ASLParserGENERATE))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(ASLParserSWITCH-36))|(1<<(ASLParserIF-36))|(1<<(ASLParserFOR-36))|(1<<(ASLParserLOOP-36))|(1<<(ASLParserINLINE-36))|(1<<(ASLParserDEFINE-36))|(1<<(ASLParserAPPEND-36)))) != 0) || (((_la-76)&-(0x1f+1)) == 0 && ((1<<uint((_la-76)))&((1<<(ASLParserL_CURLY-76))|(1<<(ASLParserL_SQUARE-76))|(1<<(ASLParserLOWERCASE_ID-76))|(1<<(ASLParserLOWERCASE_NUMBER_ID-76)))) != 0) {
			{
				p.SetState(1016)
				p.Statement()
			}

			p.SetState(1019)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(1023)
		p.Match(ASLParserENDIF)
	}

	return localctx
}

// ILogical_conditionContext is an interface to support dynamic dispatch.
type ILogical_conditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLogical_conditionContext differentiates from other interfaces.
	IsLogical_conditionContext()
}

type Logical_conditionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLogical_conditionContext() *Logical_conditionContext {
	var p = new(Logical_conditionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_logical_condition
	return p
}

func (*Logical_conditionContext) IsLogical_conditionContext() {}

func NewLogical_conditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Logical_conditionContext {
	var p = new(Logical_conditionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_logical_condition

	return p
}

func (s *Logical_conditionContext) GetParser() antlr.Parser { return s.parser }

func (s *Logical_conditionContext) AllCompound_logical_condition() []ICompound_logical_conditionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICompound_logical_conditionContext)(nil)).Elem())
	var tst = make([]ICompound_logical_conditionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICompound_logical_conditionContext)
		}
	}

	return tst
}

func (s *Logical_conditionContext) Compound_logical_condition(i int) ICompound_logical_conditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompound_logical_conditionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICompound_logical_conditionContext)
}

func (s *Logical_conditionContext) AllLOGICAL_NOT() []antlr.TerminalNode {
	return s.GetTokens(ASLParserLOGICAL_NOT)
}

func (s *Logical_conditionContext) LOGICAL_NOT(i int) antlr.TerminalNode {
	return s.GetToken(ASLParserLOGICAL_NOT, i)
}

func (s *Logical_conditionContext) AllNOT() []antlr.TerminalNode {
	return s.GetTokens(ASLParserNOT)
}

func (s *Logical_conditionContext) NOT(i int) antlr.TerminalNode {
	return s.GetToken(ASLParserNOT, i)
}

func (s *Logical_conditionContext) AllAND() []antlr.TerminalNode {
	return s.GetTokens(ASLParserAND)
}

func (s *Logical_conditionContext) AND(i int) antlr.TerminalNode {
	return s.GetToken(ASLParserAND, i)
}

func (s *Logical_conditionContext) AllOR() []antlr.TerminalNode {
	return s.GetTokens(ASLParserOR)
}

func (s *Logical_conditionContext) OR(i int) antlr.TerminalNode {
	return s.GetToken(ASLParserOR, i)
}

func (s *Logical_conditionContext) AllLOGICAL_AND() []antlr.TerminalNode {
	return s.GetTokens(ASLParserLOGICAL_AND)
}

func (s *Logical_conditionContext) LOGICAL_AND(i int) antlr.TerminalNode {
	return s.GetToken(ASLParserLOGICAL_AND, i)
}

func (s *Logical_conditionContext) AllLOGICAL_OR() []antlr.TerminalNode {
	return s.GetTokens(ASLParserLOGICAL_OR)
}

func (s *Logical_conditionContext) LOGICAL_OR(i int) antlr.TerminalNode {
	return s.GetToken(ASLParserLOGICAL_OR, i)
}

func (s *Logical_conditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Logical_conditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Logical_conditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterLogical_condition(s)
	}
}

func (s *Logical_conditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitLogical_condition(s)
	}
}

func (p *ASLParser) Logical_condition() (localctx ILogical_conditionContext) {
	this := p
	_ = this

	localctx = NewLogical_conditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, ASLParserRULE_logical_condition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1026)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 107, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1025)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ASLParserNOT || _la == ASLParserLOGICAL_NOT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(1028)
		p.Compound_logical_condition()
	}
	p.SetState(1036)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ASLParserAND || _la == ASLParserOR || _la == ASLParserLOGICAL_AND || _la == ASLParserLOGICAL_OR {
		{
			p.SetState(1029)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ASLParserAND || _la == ASLParserOR || _la == ASLParserLOGICAL_AND || _la == ASLParserLOGICAL_OR) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1031)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 108, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1030)
				_la = p.GetTokenStream().LA(1)

				if !(_la == ASLParserNOT || _la == ASLParserLOGICAL_NOT) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(1033)
			p.Compound_logical_condition()
		}

		p.SetState(1038)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ICompound_logical_conditionContext is an interface to support dynamic dispatch.
type ICompound_logical_conditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCompound_logical_conditionContext differentiates from other interfaces.
	IsCompound_logical_conditionContext()
}

type Compound_logical_conditionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompound_logical_conditionContext() *Compound_logical_conditionContext {
	var p = new(Compound_logical_conditionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_compound_logical_condition
	return p
}

func (*Compound_logical_conditionContext) IsCompound_logical_conditionContext() {}

func NewCompound_logical_conditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Compound_logical_conditionContext {
	var p = new(Compound_logical_conditionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_compound_logical_condition

	return p
}

func (s *Compound_logical_conditionContext) GetParser() antlr.Parser { return s.parser }

func (s *Compound_logical_conditionContext) AllSimple_logical_condition() []ISimple_logical_conditionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISimple_logical_conditionContext)(nil)).Elem())
	var tst = make([]ISimple_logical_conditionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISimple_logical_conditionContext)
		}
	}

	return tst
}

func (s *Compound_logical_conditionContext) Simple_logical_condition(i int) ISimple_logical_conditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_logical_conditionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISimple_logical_conditionContext)
}

func (s *Compound_logical_conditionContext) AllLOGICAL_NOT() []antlr.TerminalNode {
	return s.GetTokens(ASLParserLOGICAL_NOT)
}

func (s *Compound_logical_conditionContext) LOGICAL_NOT(i int) antlr.TerminalNode {
	return s.GetToken(ASLParserLOGICAL_NOT, i)
}

func (s *Compound_logical_conditionContext) AllNOT() []antlr.TerminalNode {
	return s.GetTokens(ASLParserNOT)
}

func (s *Compound_logical_conditionContext) NOT(i int) antlr.TerminalNode {
	return s.GetToken(ASLParserNOT, i)
}

func (s *Compound_logical_conditionContext) AllAND() []antlr.TerminalNode {
	return s.GetTokens(ASLParserAND)
}

func (s *Compound_logical_conditionContext) AND(i int) antlr.TerminalNode {
	return s.GetToken(ASLParserAND, i)
}

func (s *Compound_logical_conditionContext) AllOR() []antlr.TerminalNode {
	return s.GetTokens(ASLParserOR)
}

func (s *Compound_logical_conditionContext) OR(i int) antlr.TerminalNode {
	return s.GetToken(ASLParserOR, i)
}

func (s *Compound_logical_conditionContext) AllLOGICAL_AND() []antlr.TerminalNode {
	return s.GetTokens(ASLParserLOGICAL_AND)
}

func (s *Compound_logical_conditionContext) LOGICAL_AND(i int) antlr.TerminalNode {
	return s.GetToken(ASLParserLOGICAL_AND, i)
}

func (s *Compound_logical_conditionContext) AllLOGICAL_OR() []antlr.TerminalNode {
	return s.GetTokens(ASLParserLOGICAL_OR)
}

func (s *Compound_logical_conditionContext) LOGICAL_OR(i int) antlr.TerminalNode {
	return s.GetToken(ASLParserLOGICAL_OR, i)
}

func (s *Compound_logical_conditionContext) L_PAREN() antlr.TerminalNode {
	return s.GetToken(ASLParserL_PAREN, 0)
}

func (s *Compound_logical_conditionContext) R_PAREN() antlr.TerminalNode {
	return s.GetToken(ASLParserR_PAREN, 0)
}

func (s *Compound_logical_conditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Compound_logical_conditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Compound_logical_conditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterCompound_logical_condition(s)
	}
}

func (s *Compound_logical_conditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitCompound_logical_condition(s)
	}
}

func (p *ASLParser) Compound_logical_condition() (localctx ICompound_logical_conditionContext) {
	this := p
	_ = this

	localctx = NewCompound_logical_conditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, ASLParserRULE_compound_logical_condition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(1070)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 116, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1040)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ASLParserNOT || _la == ASLParserLOGICAL_NOT {
			{
				p.SetState(1039)
				_la = p.GetTokenStream().LA(1)

				if !(_la == ASLParserNOT || _la == ASLParserLOGICAL_NOT) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(1042)
			p.Simple_logical_condition()
		}
		p.SetState(1050)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 112, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1043)
					_la = p.GetTokenStream().LA(1)

					if !(_la == ASLParserAND || _la == ASLParserOR || _la == ASLParserLOGICAL_AND || _la == ASLParserLOGICAL_OR) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				p.SetState(1045)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == ASLParserNOT || _la == ASLParserLOGICAL_NOT {
					{
						p.SetState(1044)
						_la = p.GetTokenStream().LA(1)

						if !(_la == ASLParserNOT || _la == ASLParserLOGICAL_NOT) {
							p.GetErrorHandler().RecoverInline(p)
						} else {
							p.GetErrorHandler().ReportMatch(p)
							p.Consume()
						}
					}

				}
				{
					p.SetState(1047)
					p.Simple_logical_condition()
				}

			}
			p.SetState(1052)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 112, p.GetParserRuleContext())
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1053)
			p.Match(ASLParserL_PAREN)
		}
		p.SetState(1055)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ASLParserNOT || _la == ASLParserLOGICAL_NOT {
			{
				p.SetState(1054)
				_la = p.GetTokenStream().LA(1)

				if !(_la == ASLParserNOT || _la == ASLParserLOGICAL_NOT) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(1057)
			p.Simple_logical_condition()
		}
		p.SetState(1065)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == ASLParserAND || _la == ASLParserOR || _la == ASLParserLOGICAL_AND || _la == ASLParserLOGICAL_OR {
			{
				p.SetState(1058)
				_la = p.GetTokenStream().LA(1)

				if !(_la == ASLParserAND || _la == ASLParserOR || _la == ASLParserLOGICAL_AND || _la == ASLParserLOGICAL_OR) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			p.SetState(1060)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == ASLParserNOT || _la == ASLParserLOGICAL_NOT {
				{
					p.SetState(1059)
					_la = p.GetTokenStream().LA(1)

					if !(_la == ASLParserNOT || _la == ASLParserLOGICAL_NOT) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}
			{
				p.SetState(1062)
				p.Simple_logical_condition()
			}

			p.SetState(1067)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1068)
			p.Match(ASLParserR_PAREN)
		}

	}

	return localctx
}

// ISimple_logical_conditionContext is an interface to support dynamic dispatch.
type ISimple_logical_conditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimple_logical_conditionContext differentiates from other interfaces.
	IsSimple_logical_conditionContext()
}

type Simple_logical_conditionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimple_logical_conditionContext() *Simple_logical_conditionContext {
	var p = new(Simple_logical_conditionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_simple_logical_condition
	return p
}

func (*Simple_logical_conditionContext) IsSimple_logical_conditionContext() {}

func NewSimple_logical_conditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Simple_logical_conditionContext {
	var p = new(Simple_logical_conditionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_simple_logical_condition

	return p
}

func (s *Simple_logical_conditionContext) GetParser() antlr.Parser { return s.parser }

func (s *Simple_logical_conditionContext) Variable() IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *Simple_logical_conditionContext) L_PAREN() antlr.TerminalNode {
	return s.GetToken(ASLParserL_PAREN, 0)
}

func (s *Simple_logical_conditionContext) R_PAREN() antlr.TerminalNode {
	return s.GetToken(ASLParserR_PAREN, 0)
}

func (s *Simple_logical_conditionContext) AllComponent() []IComponentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IComponentContext)(nil)).Elem())
	var tst = make([]IComponentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IComponentContext)
		}
	}

	return tst
}

func (s *Simple_logical_conditionContext) Component(i int) IComponentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComponentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IComponentContext)
}

func (s *Simple_logical_conditionContext) Logical_operator() ILogical_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILogical_operatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILogical_operatorContext)
}

func (s *Simple_logical_conditionContext) Equality_operator() IEquality_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEquality_operatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEquality_operatorContext)
}

func (s *Simple_logical_conditionContext) UNDEFINED() antlr.TerminalNode {
	return s.GetToken(ASLParserUNDEFINED, 0)
}

func (s *Simple_logical_conditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Simple_logical_conditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Simple_logical_conditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterSimple_logical_condition(s)
	}
}

func (s *Simple_logical_conditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitSimple_logical_condition(s)
	}
}

func (p *ASLParser) Simple_logical_condition() (localctx ISimple_logical_conditionContext) {
	this := p
	_ = this

	localctx = NewSimple_logical_conditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, ASLParserRULE_simple_logical_condition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1073)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 117, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1072)
			p.Match(ASLParserL_PAREN)
		}

	}
	p.SetState(1084)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 118, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1075)
			p.Variable()
		}

	case 2:
		{
			p.SetState(1076)
			p.Component()
		}
		{
			p.SetState(1077)
			p.Logical_operator()
		}
		{
			p.SetState(1078)
			p.Component()
		}

	case 3:
		{
			p.SetState(1080)
			p.Component()
		}
		{
			p.SetState(1081)
			p.Equality_operator()
		}
		{
			p.SetState(1082)
			p.Match(ASLParserUNDEFINED)
		}

	}
	p.SetState(1087)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 119, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1086)
			p.Match(ASLParserR_PAREN)
		}

	}

	return localctx
}

// IComponentContext is an interface to support dynamic dispatch.
type IComponentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComponentContext differentiates from other interfaces.
	IsComponentContext()
}

type ComponentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComponentContext() *ComponentContext {
	var p = new(ComponentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_component
	return p
}

func (*ComponentContext) IsComponentContext() {}

func NewComponentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComponentContext {
	var p = new(ComponentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_component

	return p
}

func (s *ComponentContext) GetParser() antlr.Parser { return s.parser }

func (s *ComponentContext) Variable() IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *ComponentContext) Object_attribute() IObject_attributeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObject_attributeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObject_attributeContext)
}

func (s *ComponentContext) Constant() IConstantContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstantContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *ComponentContext) COUNTOF() antlr.TerminalNode {
	return s.GetToken(ASLParserCOUNTOF, 0)
}

func (s *ComponentContext) Set_variable() ISet_variableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISet_variableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISet_variableContext)
}

func (s *ComponentContext) Arithmetic_expression() IArithmetic_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArithmetic_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArithmetic_expressionContext)
}

func (s *ComponentContext) THIS() antlr.TerminalNode {
	return s.GetToken(ASLParserTHIS, 0)
}

func (s *ComponentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComponentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComponentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterComponent(s)
	}
}

func (s *ComponentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitComponent(s)
	}
}

func (p *ASLParser) Component() (localctx IComponentContext) {
	this := p
	_ = this

	localctx = NewComponentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, ASLParserRULE_component)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1096)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 120, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1089)
			p.Variable()
		}

	case 2:
		{
			p.SetState(1090)
			p.Object_attribute()
		}

	case 3:
		{
			p.SetState(1091)
			p.Constant()
		}

	case 4:
		{
			p.SetState(1092)
			p.Match(ASLParserCOUNTOF)
		}
		{
			p.SetState(1093)
			p.Set_variable()
		}

	case 5:
		{
			p.SetState(1094)
			p.Arithmetic_expression()
		}

	case 6:
		{
			p.SetState(1095)
			p.Match(ASLParserTHIS)
		}

	}

	return localctx
}

// IFor_loopContext is an interface to support dynamic dispatch.
type IFor_loopContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFor_loopContext differentiates from other interfaces.
	IsFor_loopContext()
}

type For_loopContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFor_loopContext() *For_loopContext {
	var p = new(For_loopContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_for_loop
	return p
}

func (*For_loopContext) IsFor_loopContext() {}

func NewFor_loopContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *For_loopContext {
	var p = new(For_loopContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_for_loop

	return p
}

func (s *For_loopContext) GetParser() antlr.Parser { return s.parser }

func (s *For_loopContext) FOR() antlr.TerminalNode {
	return s.GetToken(ASLParserFOR, 0)
}

func (s *For_loopContext) Variable() IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *For_loopContext) IN() antlr.TerminalNode {
	return s.GetToken(ASLParserIN, 0)
}

func (s *For_loopContext) Set_variable() ISet_variableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISet_variableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISet_variableContext)
}

func (s *For_loopContext) DO() antlr.TerminalNode {
	return s.GetToken(ASLParserDO, 0)
}

func (s *For_loopContext) NEWLINE() antlr.TerminalNode {
	return s.GetToken(ASLParserNEWLINE, 0)
}

func (s *For_loopContext) ENDFOR() antlr.TerminalNode {
	return s.GetToken(ASLParserENDFOR, 0)
}

func (s *For_loopContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *For_loopContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *For_loopContext) Break_statement() IBreak_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBreak_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBreak_statementContext)
}

func (s *For_loopContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *For_loopContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *For_loopContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterFor_loop(s)
	}
}

func (s *For_loopContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitFor_loop(s)
	}
}

func (p *ASLParser) For_loop() (localctx IFor_loopContext) {
	this := p
	_ = this

	localctx = NewFor_loopContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, ASLParserRULE_for_loop)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1098)
		p.Match(ASLParserFOR)
	}
	{
		p.SetState(1099)
		p.Variable()
	}
	{
		p.SetState(1100)
		p.Match(ASLParserIN)
	}
	{
		p.SetState(1101)
		p.Set_variable()
	}
	{
		p.SetState(1102)
		p.Match(ASLParserDO)
	}
	{
		p.SetState(1103)
		p.Match(ASLParserNEWLINE)
	}
	p.SetState(1107)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ASLParserTHIS)|(1<<ASLParserDELETE)|(1<<ASLParserLINK)|(1<<ASLParserUNLINK)|(1<<ASLParserGENERATE))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(ASLParserSWITCH-36))|(1<<(ASLParserIF-36))|(1<<(ASLParserFOR-36))|(1<<(ASLParserLOOP-36))|(1<<(ASLParserINLINE-36))|(1<<(ASLParserDEFINE-36))|(1<<(ASLParserAPPEND-36)))) != 0) || (((_la-76)&-(0x1f+1)) == 0 && ((1<<uint((_la-76)))&((1<<(ASLParserL_CURLY-76))|(1<<(ASLParserL_SQUARE-76))|(1<<(ASLParserLOWERCASE_ID-76))|(1<<(ASLParserLOWERCASE_NUMBER_ID-76)))) != 0) {
		{
			p.SetState(1104)
			p.Statement()
		}

		p.SetState(1109)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1117)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASLParserBREAK || _la == ASLParserBREAKIF {
		{
			p.SetState(1110)
			p.Break_statement()
		}
		p.SetState(1114)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ASLParserTHIS)|(1<<ASLParserDELETE)|(1<<ASLParserLINK)|(1<<ASLParserUNLINK)|(1<<ASLParserGENERATE))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(ASLParserSWITCH-36))|(1<<(ASLParserIF-36))|(1<<(ASLParserFOR-36))|(1<<(ASLParserLOOP-36))|(1<<(ASLParserINLINE-36))|(1<<(ASLParserDEFINE-36))|(1<<(ASLParserAPPEND-36)))) != 0) || (((_la-76)&-(0x1f+1)) == 0 && ((1<<uint((_la-76)))&((1<<(ASLParserL_CURLY-76))|(1<<(ASLParserL_SQUARE-76))|(1<<(ASLParserLOWERCASE_ID-76))|(1<<(ASLParserLOWERCASE_NUMBER_ID-76)))) != 0) {
			{
				p.SetState(1111)
				p.Statement()
			}

			p.SetState(1116)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(1119)
		p.Match(ASLParserENDFOR)
	}

	return localctx
}

// IBreak_statementContext is an interface to support dynamic dispatch.
type IBreak_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBreak_statementContext differentiates from other interfaces.
	IsBreak_statementContext()
}

type Break_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBreak_statementContext() *Break_statementContext {
	var p = new(Break_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_break_statement
	return p
}

func (*Break_statementContext) IsBreak_statementContext() {}

func NewBreak_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Break_statementContext {
	var p = new(Break_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_break_statement

	return p
}

func (s *Break_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Break_statementContext) NEWLINE() antlr.TerminalNode {
	return s.GetToken(ASLParserNEWLINE, 0)
}

func (s *Break_statementContext) BREAK() antlr.TerminalNode {
	return s.GetToken(ASLParserBREAK, 0)
}

func (s *Break_statementContext) BREAKIF() antlr.TerminalNode {
	return s.GetToken(ASLParserBREAKIF, 0)
}

func (s *Break_statementContext) Logical_condition() ILogical_conditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILogical_conditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILogical_conditionContext)
}

func (s *Break_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Break_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Break_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterBreak_statement(s)
	}
}

func (s *Break_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitBreak_statement(s)
	}
}

func (p *ASLParser) Break_statement() (localctx IBreak_statementContext) {
	this := p
	_ = this

	localctx = NewBreak_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, ASLParserRULE_break_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1124)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASLParserBREAK:
		{
			p.SetState(1121)
			p.Match(ASLParserBREAK)
		}

	case ASLParserBREAKIF:
		{
			p.SetState(1122)
			p.Match(ASLParserBREAKIF)
		}
		{
			p.SetState(1123)
			p.Logical_condition()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(1126)
		p.Match(ASLParserNEWLINE)
	}

	return localctx
}

// ILoop_statementContext is an interface to support dynamic dispatch.
type ILoop_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLoop_statementContext differentiates from other interfaces.
	IsLoop_statementContext()
}

type Loop_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLoop_statementContext() *Loop_statementContext {
	var p = new(Loop_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_loop_statement
	return p
}

func (*Loop_statementContext) IsLoop_statementContext() {}

func NewLoop_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Loop_statementContext {
	var p = new(Loop_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_loop_statement

	return p
}

func (s *Loop_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Loop_statementContext) LOOP() antlr.TerminalNode {
	return s.GetToken(ASLParserLOOP, 0)
}

func (s *Loop_statementContext) NEWLINE() antlr.TerminalNode {
	return s.GetToken(ASLParserNEWLINE, 0)
}

func (s *Loop_statementContext) AllBreak_statement() []IBreak_statementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBreak_statementContext)(nil)).Elem())
	var tst = make([]IBreak_statementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBreak_statementContext)
		}
	}

	return tst
}

func (s *Loop_statementContext) Break_statement(i int) IBreak_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBreak_statementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBreak_statementContext)
}

func (s *Loop_statementContext) ENDLOOP() antlr.TerminalNode {
	return s.GetToken(ASLParserENDLOOP, 0)
}

func (s *Loop_statementContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *Loop_statementContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *Loop_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Loop_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Loop_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterLoop_statement(s)
	}
}

func (s *Loop_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitLoop_statement(s)
	}
}

func (p *ASLParser) Loop_statement() (localctx ILoop_statementContext) {
	this := p
	_ = this

	localctx = NewLoop_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, ASLParserRULE_loop_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1128)
		p.Match(ASLParserLOOP)
	}
	{
		p.SetState(1129)
		p.Match(ASLParserNEWLINE)
	}
	p.SetState(1133)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ASLParserTHIS)|(1<<ASLParserDELETE)|(1<<ASLParserLINK)|(1<<ASLParserUNLINK)|(1<<ASLParserGENERATE))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(ASLParserSWITCH-36))|(1<<(ASLParserIF-36))|(1<<(ASLParserFOR-36))|(1<<(ASLParserLOOP-36))|(1<<(ASLParserINLINE-36))|(1<<(ASLParserDEFINE-36))|(1<<(ASLParserAPPEND-36)))) != 0) || (((_la-76)&-(0x1f+1)) == 0 && ((1<<uint((_la-76)))&((1<<(ASLParserL_CURLY-76))|(1<<(ASLParserL_SQUARE-76))|(1<<(ASLParserLOWERCASE_ID-76))|(1<<(ASLParserLOWERCASE_NUMBER_ID-76)))) != 0) {
		{
			p.SetState(1130)
			p.Statement()
		}

		p.SetState(1135)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1136)
		p.Break_statement()
	}
	p.SetState(1141)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ASLParserTHIS)|(1<<ASLParserDELETE)|(1<<ASLParserLINK)|(1<<ASLParserUNLINK)|(1<<ASLParserGENERATE))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(ASLParserSWITCH-36))|(1<<(ASLParserIF-36))|(1<<(ASLParserFOR-36))|(1<<(ASLParserBREAK-36))|(1<<(ASLParserBREAKIF-36))|(1<<(ASLParserLOOP-36))|(1<<(ASLParserINLINE-36))|(1<<(ASLParserDEFINE-36))|(1<<(ASLParserAPPEND-36)))) != 0) || (((_la-76)&-(0x1f+1)) == 0 && ((1<<uint((_la-76)))&((1<<(ASLParserL_CURLY-76))|(1<<(ASLParserL_SQUARE-76))|(1<<(ASLParserLOWERCASE_ID-76))|(1<<(ASLParserLOWERCASE_NUMBER_ID-76)))) != 0) {
		p.SetState(1139)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case ASLParserBREAK, ASLParserBREAKIF:
			{
				p.SetState(1137)
				p.Break_statement()
			}

		case ASLParserTHIS, ASLParserDELETE, ASLParserLINK, ASLParserUNLINK, ASLParserGENERATE, ASLParserSWITCH, ASLParserIF, ASLParserFOR, ASLParserLOOP, ASLParserINLINE, ASLParserDEFINE, ASLParserAPPEND, ASLParserL_CURLY, ASLParserL_SQUARE, ASLParserLOWERCASE_ID, ASLParserLOWERCASE_NUMBER_ID:
			{
				p.SetState(1138)
				p.Statement()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(1143)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1144)
		p.Match(ASLParserENDLOOP)
	}

	return localctx
}

// INative_language_sectionContext is an interface to support dynamic dispatch.
type INative_language_sectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNative_language_sectionContext differentiates from other interfaces.
	IsNative_language_sectionContext()
}

type Native_language_sectionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNative_language_sectionContext() *Native_language_sectionContext {
	var p = new(Native_language_sectionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_native_language_section
	return p
}

func (*Native_language_sectionContext) IsNative_language_sectionContext() {}

func NewNative_language_sectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Native_language_sectionContext {
	var p = new(Native_language_sectionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_native_language_section

	return p
}

func (s *Native_language_sectionContext) GetParser() antlr.Parser { return s.parser }

func (s *Native_language_sectionContext) INLINE() antlr.TerminalNode {
	return s.GetToken(ASLParserINLINE, 0)
}

func (s *Native_language_sectionContext) NEWLINE() antlr.TerminalNode {
	return s.GetToken(ASLParserNEWLINE, 0)
}

func (s *Native_language_sectionContext) END_INLINE() antlr.TerminalNode {
	return s.GetToken(ASLParserEND_INLINE, 0)
}

func (s *Native_language_sectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Native_language_sectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Native_language_sectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterNative_language_section(s)
	}
}

func (s *Native_language_sectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitNative_language_section(s)
	}
}

func (p *ASLParser) Native_language_section() (localctx INative_language_sectionContext) {
	this := p
	_ = this

	localctx = NewNative_language_sectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, ASLParserRULE_native_language_section)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1146)
		p.Match(ASLParserINLINE)
	}
	{
		p.SetState(1147)
		p.Match(ASLParserNEWLINE)
	}
	p.SetState(1151)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 128, p.GetParserRuleContext())

	for _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1+1 {
			p.SetState(1148)
			p.MatchWildcard()

		}
		p.SetState(1153)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 128, p.GetParserRuleContext())
	}
	{
		p.SetState(1154)
		p.Match(ASLParserEND_INLINE)
	}

	return localctx
}

// ISet_variableContext is an interface to support dynamic dispatch.
type ISet_variableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSet_variableContext differentiates from other interfaces.
	IsSet_variableContext()
}

type Set_variableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySet_variableContext() *Set_variableContext {
	var p = new(Set_variableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_set_variable
	return p
}

func (*Set_variableContext) IsSet_variableContext() {}

func NewSet_variableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Set_variableContext {
	var p = new(Set_variableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_set_variable

	return p
}

func (s *Set_variableContext) GetParser() antlr.Parser { return s.parser }

func (s *Set_variableContext) L_CURLY() antlr.TerminalNode {
	return s.GetToken(ASLParserL_CURLY, 0)
}

func (s *Set_variableContext) Variable() IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *Set_variableContext) R_CURLY() antlr.TerminalNode {
	return s.GetToken(ASLParserR_CURLY, 0)
}

func (s *Set_variableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Set_variableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Set_variableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterSet_variable(s)
	}
}

func (s *Set_variableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitSet_variable(s)
	}
}

func (p *ASLParser) Set_variable() (localctx ISet_variableContext) {
	this := p
	_ = this

	localctx = NewSet_variableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, ASLParserRULE_set_variable)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1156)
		p.Match(ASLParserL_CURLY)
	}
	{
		p.SetState(1157)
		p.Variable()
	}
	{
		p.SetState(1158)
		p.Match(ASLParserR_CURLY)
	}

	return localctx
}

// IVariableContext is an interface to support dynamic dispatch.
type IVariableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableContext differentiates from other interfaces.
	IsVariableContext()
}

type VariableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableContext() *VariableContext {
	var p = new(VariableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_variable
	return p
}

func (*VariableContext) IsVariableContext() {}

func NewVariableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableContext {
	var p = new(VariableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_variable

	return p
}

func (s *VariableContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableContext) LOWERCASE_ID() antlr.TerminalNode {
	return s.GetToken(ASLParserLOWERCASE_ID, 0)
}

func (s *VariableContext) LOWERCASE_NUMBER_ID() antlr.TerminalNode {
	return s.GetToken(ASLParserLOWERCASE_NUMBER_ID, 0)
}

func (s *VariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterVariable(s)
	}
}

func (s *VariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitVariable(s)
	}
}

func (p *ASLParser) Variable() (localctx IVariableContext) {
	this := p
	_ = this

	localctx = NewVariableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, ASLParserRULE_variable)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1160)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ASLParserLOWERCASE_ID || _la == ASLParserLOWERCASE_NUMBER_ID) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IObject_nameContext is an interface to support dynamic dispatch.
type IObject_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObject_nameContext differentiates from other interfaces.
	IsObject_nameContext()
}

type Object_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObject_nameContext() *Object_nameContext {
	var p = new(Object_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_object_name
	return p
}

func (*Object_nameContext) IsObject_nameContext() {}

func NewObject_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Object_nameContext {
	var p = new(Object_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_object_name

	return p
}

func (s *Object_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Object_nameContext) UPPERCASE_ID() antlr.TerminalNode {
	return s.GetToken(ASLParserUPPERCASE_ID, 0)
}

func (s *Object_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Object_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Object_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterObject_name(s)
	}
}

func (s *Object_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitObject_name(s)
	}
}

func (p *ASLParser) Object_name() (localctx IObject_nameContext) {
	this := p
	_ = this

	localctx = NewObject_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, ASLParserRULE_object_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1162)
		p.Match(ASLParserUPPERCASE_ID)
	}

	return localctx
}

// IAttributeContext is an interface to support dynamic dispatch.
type IAttributeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttributeContext differentiates from other interfaces.
	IsAttributeContext()
}

type AttributeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeContext() *AttributeContext {
	var p = new(AttributeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_attribute
	return p
}

func (*AttributeContext) IsAttributeContext() {}

func NewAttributeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeContext {
	var p = new(AttributeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_attribute

	return p
}

func (s *AttributeContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeContext) LEADING_FIRST_UPPERCASE_ID() antlr.TerminalNode {
	return s.GetToken(ASLParserLEADING_FIRST_UPPERCASE_ID, 0)
}

func (s *AttributeContext) LEADING_UPPERCASE_ID() antlr.TerminalNode {
	return s.GetToken(ASLParserLEADING_UPPERCASE_ID, 0)
}

func (s *AttributeContext) UPPERCASE_ID() antlr.TerminalNode {
	return s.GetToken(ASLParserUPPERCASE_ID, 0)
}

func (s *AttributeContext) INSTANCE_ID() antlr.TerminalNode {
	return s.GetToken(ASLParserINSTANCE_ID, 0)
}

func (s *AttributeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterAttribute(s)
	}
}

func (s *AttributeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitAttribute(s)
	}
}

func (p *ASLParser) Attribute() (localctx IAttributeContext) {
	this := p
	_ = this

	localctx = NewAttributeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, ASLParserRULE_attribute)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1164)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-101)&-(0x1f+1)) == 0 && ((1<<uint((_la-101)))&((1<<(ASLParserINSTANCE_ID-101))|(1<<(ASLParserUPPERCASE_ID-101))|(1<<(ASLParserLEADING_UPPERCASE_ID-101))|(1<<(ASLParserLEADING_FIRST_UPPERCASE_ID-101)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IObject_attributeContext is an interface to support dynamic dispatch.
type IObject_attributeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObject_attributeContext differentiates from other interfaces.
	IsObject_attributeContext()
}

type Object_attributeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObject_attributeContext() *Object_attributeContext {
	var p = new(Object_attributeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_object_attribute
	return p
}

func (*Object_attributeContext) IsObject_attributeContext() {}

func NewObject_attributeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Object_attributeContext {
	var p = new(Object_attributeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_object_attribute

	return p
}

func (s *Object_attributeContext) GetParser() antlr.Parser { return s.parser }

func (s *Object_attributeContext) DOT() antlr.TerminalNode {
	return s.GetToken(ASLParserDOT, 0)
}

func (s *Object_attributeContext) Attribute() IAttributeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttributeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttributeContext)
}

func (s *Object_attributeContext) Variable() IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *Object_attributeContext) THIS() antlr.TerminalNode {
	return s.GetToken(ASLParserTHIS, 0)
}

func (s *Object_attributeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Object_attributeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Object_attributeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterObject_attribute(s)
	}
}

func (s *Object_attributeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitObject_attribute(s)
	}
}

func (p *ASLParser) Object_attribute() (localctx IObject_attributeContext) {
	this := p
	_ = this

	localctx = NewObject_attributeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, ASLParserRULE_object_attribute)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1168)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASLParserLOWERCASE_ID, ASLParserLOWERCASE_NUMBER_ID:
		{
			p.SetState(1166)
			p.Variable()
		}

	case ASLParserTHIS:
		{
			p.SetState(1167)
			p.Match(ASLParserTHIS)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(1170)
		p.Match(ASLParserDOT)
	}
	{
		p.SetState(1171)
		p.Attribute()
	}

	return localctx
}

// IConstantContext is an interface to support dynamic dispatch.
type IConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstantContext differentiates from other interfaces.
	IsConstantContext()
}

type ConstantContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstantContext() *ConstantContext {
	var p = new(ConstantContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_constant
	return p
}

func (*ConstantContext) IsConstantContext() {}

func NewConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantContext {
	var p = new(ConstantContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_constant

	return p
}

func (s *ConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(ASLParserINTEGER_VALUE, 0)
}

func (s *ConstantContext) REAL_VALUE() antlr.TerminalNode {
	return s.GetToken(ASLParserREAL_VALUE, 0)
}

func (s *ConstantContext) BOOLEAN_VALUE() antlr.TerminalNode {
	return s.GetToken(ASLParserBOOLEAN_VALUE, 0)
}

func (s *ConstantContext) Text_string() IText_stringContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IText_stringContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IText_stringContext)
}

func (s *ConstantContext) Enum_value() IEnum_valueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnum_valueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnum_valueContext)
}

func (s *ConstantContext) DATE_VALUE() antlr.TerminalNode {
	return s.GetToken(ASLParserDATE_VALUE, 0)
}

func (s *ConstantContext) TIME_VALUE() antlr.TerminalNode {
	return s.GetToken(ASLParserTIME_VALUE, 0)
}

func (s *ConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterConstant(s)
	}
}

func (s *ConstantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitConstant(s)
	}
}

func (p *ASLParser) Constant() (localctx IConstantContext) {
	this := p
	_ = this

	localctx = NewConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, ASLParserRULE_constant)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1180)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASLParserINTEGER_VALUE:
		{
			p.SetState(1173)
			p.Match(ASLParserINTEGER_VALUE)
		}

	case ASLParserREAL_VALUE:
		{
			p.SetState(1174)
			p.Match(ASLParserREAL_VALUE)
		}

	case ASLParserBOOLEAN_VALUE:
		{
			p.SetState(1175)
			p.Match(ASLParserBOOLEAN_VALUE)
		}

	case ASLParserLOWERCASE_TEXT, ASLParserOTHER_TEXT, ASLParserQUOTE:
		{
			p.SetState(1176)
			p.Text_string()
		}

	case ASLParserUPPERCASE_ID, ASLParserUPPERCASE_OR_NUMBER_ID:
		{
			p.SetState(1177)
			p.Enum_value()
		}

	case ASLParserDATE_VALUE:
		{
			p.SetState(1178)
			p.Match(ASLParserDATE_VALUE)
		}

	case ASLParserTIME_VALUE:
		{
			p.SetState(1179)
			p.Match(ASLParserTIME_VALUE)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IText_stringContext is an interface to support dynamic dispatch.
type IText_stringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsText_stringContext differentiates from other interfaces.
	IsText_stringContext()
}

type Text_stringContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyText_stringContext() *Text_stringContext {
	var p = new(Text_stringContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_text_string
	return p
}

func (*Text_stringContext) IsText_stringContext() {}

func NewText_stringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Text_stringContext {
	var p = new(Text_stringContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_text_string

	return p
}

func (s *Text_stringContext) GetParser() antlr.Parser { return s.parser }

func (s *Text_stringContext) LOWERCASE_TEXT() antlr.TerminalNode {
	return s.GetToken(ASLParserLOWERCASE_TEXT, 0)
}

func (s *Text_stringContext) OTHER_TEXT() antlr.TerminalNode {
	return s.GetToken(ASLParserOTHER_TEXT, 0)
}

func (s *Text_stringContext) AllQUOTE() []antlr.TerminalNode {
	return s.GetTokens(ASLParserQUOTE)
}

func (s *Text_stringContext) QUOTE(i int) antlr.TerminalNode {
	return s.GetToken(ASLParserQUOTE, i)
}

func (s *Text_stringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Text_stringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Text_stringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterText_string(s)
	}
}

func (s *Text_stringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitText_string(s)
	}
}

func (p *ASLParser) Text_string() (localctx IText_stringContext) {
	this := p
	_ = this

	localctx = NewText_stringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, ASLParserRULE_text_string)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1186)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASLParserLOWERCASE_TEXT:
		{
			p.SetState(1182)
			p.Match(ASLParserLOWERCASE_TEXT)
		}

	case ASLParserOTHER_TEXT:
		{
			p.SetState(1183)
			p.Match(ASLParserOTHER_TEXT)
		}

	case ASLParserQUOTE:
		{
			p.SetState(1184)
			p.Match(ASLParserQUOTE)
		}
		{
			p.SetState(1185)
			p.Match(ASLParserQUOTE)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IEnum_valueContext is an interface to support dynamic dispatch.
type IEnum_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnum_valueContext differentiates from other interfaces.
	IsEnum_valueContext()
}

type Enum_valueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnum_valueContext() *Enum_valueContext {
	var p = new(Enum_valueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_enum_value
	return p
}

func (*Enum_valueContext) IsEnum_valueContext() {}

func NewEnum_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Enum_valueContext {
	var p = new(Enum_valueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_enum_value

	return p
}

func (s *Enum_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *Enum_valueContext) UPPERCASE_ID() antlr.TerminalNode {
	return s.GetToken(ASLParserUPPERCASE_ID, 0)
}

func (s *Enum_valueContext) UPPERCASE_OR_NUMBER_ID() antlr.TerminalNode {
	return s.GetToken(ASLParserUPPERCASE_OR_NUMBER_ID, 0)
}

func (s *Enum_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Enum_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Enum_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterEnum_value(s)
	}
}

func (s *Enum_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitEnum_value(s)
	}
}

func (p *ASLParser) Enum_value() (localctx IEnum_valueContext) {
	this := p
	_ = this

	localctx = NewEnum_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, ASLParserRULE_enum_value)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1188)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ASLParserUPPERCASE_ID || _la == ASLParserUPPERCASE_OR_NUMBER_ID) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IStructure_fieldContext is an interface to support dynamic dispatch.
type IStructure_fieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStructure_fieldContext differentiates from other interfaces.
	IsStructure_fieldContext()
}

type Structure_fieldContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStructure_fieldContext() *Structure_fieldContext {
	var p = new(Structure_fieldContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_structure_field
	return p
}

func (*Structure_fieldContext) IsStructure_fieldContext() {}

func NewStructure_fieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Structure_fieldContext {
	var p = new(Structure_fieldContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_structure_field

	return p
}

func (s *Structure_fieldContext) GetParser() antlr.Parser { return s.parser }

func (s *Structure_fieldContext) Variable() IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *Structure_fieldContext) DOT() antlr.TerminalNode {
	return s.GetToken(ASLParserDOT, 0)
}

func (s *Structure_fieldContext) LOWERCASE_ID() antlr.TerminalNode {
	return s.GetToken(ASLParserLOWERCASE_ID, 0)
}

func (s *Structure_fieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Structure_fieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Structure_fieldContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterStructure_field(s)
	}
}

func (s *Structure_fieldContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitStructure_field(s)
	}
}

func (p *ASLParser) Structure_field() (localctx IStructure_fieldContext) {
	this := p
	_ = this

	localctx = NewStructure_fieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, ASLParserRULE_structure_field)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1190)
		p.Variable()
	}
	{
		p.SetState(1191)
		p.Match(ASLParserDOT)
	}
	{
		p.SetState(1192)
		p.Match(ASLParserLOWERCASE_ID)
	}

	return localctx
}

// IUser_defined_typeContext is an interface to support dynamic dispatch.
type IUser_defined_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUser_defined_typeContext differentiates from other interfaces.
	IsUser_defined_typeContext()
}

type User_defined_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUser_defined_typeContext() *User_defined_typeContext {
	var p = new(User_defined_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASLParserRULE_user_defined_type
	return p
}

func (*User_defined_typeContext) IsUser_defined_typeContext() {}

func NewUser_defined_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *User_defined_typeContext {
	var p = new(User_defined_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASLParserRULE_user_defined_type

	return p
}

func (s *User_defined_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *User_defined_typeContext) UPPERCASE_ID() antlr.TerminalNode {
	return s.GetToken(ASLParserUPPERCASE_ID, 0)
}

func (s *User_defined_typeContext) DOT() antlr.TerminalNode {
	return s.GetToken(ASLParserDOT, 0)
}

func (s *User_defined_typeContext) LEADING_FIRST_UPPERCASE_ID() antlr.TerminalNode {
	return s.GetToken(ASLParserLEADING_FIRST_UPPERCASE_ID, 0)
}

func (s *User_defined_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *User_defined_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *User_defined_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.EnterUser_defined_type(s)
	}
}

func (s *User_defined_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASLListener); ok {
		listenerT.ExitUser_defined_type(s)
	}
}

func (p *ASLParser) User_defined_type() (localctx IUser_defined_typeContext) {
	this := p
	_ = this

	localctx = NewUser_defined_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, ASLParserRULE_user_defined_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1194)
		p.Match(ASLParserUPPERCASE_ID)
	}
	{
		p.SetState(1195)
		p.Match(ASLParserDOT)
	}
	{
		p.SetState(1196)
		p.Match(ASLParserLEADING_FIRST_UPPERCASE_ID)
	}

	return localctx
}
