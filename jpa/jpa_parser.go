// Generated from JPA.g4 by ANTLR 4.7.

package jpa // JPA
import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 86, 893,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4,
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55,
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9,
	60, 4, 61, 9, 61, 4, 62, 9, 62, 4, 63, 9, 63, 4, 64, 9, 64, 4, 65, 9, 65,
	4, 66, 9, 66, 4, 67, 9, 67, 4, 68, 9, 68, 4, 69, 9, 69, 4, 70, 9, 70, 4,
	71, 9, 71, 4, 72, 9, 72, 4, 73, 9, 73, 4, 74, 9, 74, 4, 75, 9, 75, 4, 76,
	9, 76, 4, 77, 9, 77, 4, 78, 9, 78, 4, 79, 9, 79, 4, 80, 9, 80, 4, 81, 9,
	81, 4, 82, 9, 82, 4, 83, 9, 83, 4, 84, 9, 84, 4, 85, 9, 85, 4, 86, 9, 86,
	4, 87, 9, 87, 4, 88, 9, 88, 3, 2, 3, 2, 3, 2, 5, 2, 180, 10, 2, 3, 3, 3,
	3, 3, 3, 5, 3, 185, 10, 3, 3, 3, 5, 3, 188, 10, 3, 3, 3, 5, 3, 191, 10,
	3, 3, 3, 5, 3, 194, 10, 3, 3, 4, 3, 4, 5, 4, 198, 10, 4, 3, 5, 3, 5, 5,
	5, 202, 10, 5, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 5, 6, 209, 10, 6, 7, 6, 211,
	10, 6, 12, 6, 14, 6, 214, 11, 6, 3, 7, 3, 7, 3, 7, 7, 7, 219, 10, 7, 12,
	7, 14, 7, 222, 11, 7, 3, 8, 3, 8, 5, 8, 226, 10, 8, 3, 8, 3, 8, 3, 9, 3,
	9, 3, 9, 5, 9, 233, 10, 9, 3, 9, 3, 9, 3, 10, 3, 10, 3, 10, 3, 10, 3, 11,
	3, 11, 5, 11, 243, 10, 11, 3, 11, 5, 11, 246, 10, 11, 3, 11, 3, 11, 3,
	12, 3, 12, 5, 12, 252, 10, 12, 3, 13, 3, 13, 3, 13, 3, 13, 3, 14, 3, 14,
	3, 14, 3, 14, 3, 15, 3, 15, 3, 15, 3, 15, 3, 15, 5, 15, 267, 10, 15, 3,
	15, 3, 15, 3, 16, 3, 16, 5, 16, 273, 10, 16, 3, 17, 3, 17, 5, 17, 277,
	10, 17, 3, 17, 3, 17, 3, 17, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 7, 18,
	287, 10, 18, 12, 18, 14, 18, 290, 11, 18, 3, 18, 3, 18, 3, 19, 3, 19, 3,
	19, 3, 19, 3, 19, 7, 19, 299, 10, 19, 12, 19, 14, 19, 302, 11, 19, 3, 19,
	3, 19, 3, 20, 3, 20, 3, 20, 7, 20, 309, 10, 20, 12, 20, 14, 20, 312, 11,
	20, 3, 20, 3, 20, 3, 21, 3, 21, 3, 21, 5, 21, 319, 10, 21, 3, 21, 5, 21,
	322, 10, 21, 3, 21, 3, 21, 3, 21, 3, 21, 7, 21, 328, 10, 21, 12, 21, 14,
	21, 331, 11, 21, 3, 22, 3, 22, 5, 22, 335, 10, 22, 3, 22, 3, 22, 5, 22,
	339, 10, 22, 3, 22, 3, 22, 3, 22, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3,
	23, 3, 23, 5, 23, 351, 10, 23, 3, 24, 3, 24, 3, 24, 3, 24, 5, 24, 357,
	10, 24, 3, 24, 5, 24, 360, 10, 24, 3, 25, 3, 25, 5, 25, 364, 10, 25, 3,
	25, 3, 25, 3, 25, 7, 25, 369, 10, 25, 12, 25, 14, 25, 372, 11, 25, 3, 26,
	3, 26, 3, 26, 3, 26, 3, 26, 3, 26, 3, 26, 3, 26, 5, 26, 382, 10, 26, 3,
	27, 3, 27, 3, 27, 3, 27, 3, 27, 3, 27, 7, 27, 390, 10, 27, 12, 27, 14,
	27, 393, 11, 27, 3, 27, 3, 27, 3, 28, 3, 28, 5, 28, 399, 10, 28, 3, 29,
	3, 29, 3, 29, 5, 29, 404, 10, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3,
	29, 5, 29, 412, 10, 29, 3, 29, 3, 29, 3, 29, 5, 29, 417, 10, 29, 3, 29,
	5, 29, 420, 10, 29, 3, 30, 3, 30, 3, 30, 3, 31, 3, 31, 3, 31, 3, 31, 3,
	31, 7, 31, 430, 10, 31, 12, 31, 14, 31, 433, 11, 31, 3, 32, 3, 32, 5, 32,
	437, 10, 32, 3, 33, 3, 33, 3, 33, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 7,
	34, 447, 10, 34, 12, 34, 14, 34, 450, 11, 34, 3, 35, 3, 35, 5, 35, 454,
	10, 35, 3, 36, 3, 36, 3, 36, 5, 36, 459, 10, 36, 3, 36, 5, 36, 462, 10,
	36, 3, 36, 5, 36, 465, 10, 36, 3, 37, 3, 37, 3, 37, 3, 37, 7, 37, 471,
	10, 37, 12, 37, 14, 37, 474, 11, 37, 3, 38, 3, 38, 3, 38, 5, 38, 479, 10,
	38, 3, 38, 3, 38, 3, 38, 5, 38, 484, 10, 38, 3, 39, 3, 39, 5, 39, 488,
	10, 39, 3, 40, 3, 40, 5, 40, 492, 10, 40, 3, 40, 3, 40, 3, 41, 3, 41, 3,
	41, 5, 41, 499, 10, 41, 3, 42, 3, 42, 3, 42, 7, 42, 504, 10, 42, 12, 42,
	14, 42, 507, 11, 42, 3, 43, 3, 43, 3, 43, 7, 43, 512, 10, 43, 12, 43, 14,
	43, 515, 11, 43, 3, 44, 5, 44, 518, 10, 44, 3, 44, 3, 44, 3, 45, 3, 45,
	3, 45, 3, 45, 3, 45, 5, 45, 527, 10, 45, 3, 46, 3, 46, 3, 46, 3, 46, 3,
	46, 3, 46, 3, 46, 3, 46, 5, 46, 537, 10, 46, 3, 47, 3, 47, 5, 47, 541,
	10, 47, 3, 47, 3, 47, 3, 47, 3, 47, 3, 47, 3, 47, 3, 47, 5, 47, 550, 10,
	47, 3, 47, 3, 47, 3, 47, 3, 47, 3, 47, 3, 47, 3, 47, 5, 47, 559, 10, 47,
	3, 47, 3, 47, 3, 47, 3, 47, 3, 47, 5, 47, 566, 10, 47, 3, 48, 3, 48, 5,
	48, 570, 10, 48, 3, 48, 3, 48, 3, 48, 3, 48, 3, 48, 7, 48, 577, 10, 48,
	12, 48, 14, 48, 580, 11, 48, 3, 48, 5, 48, 583, 10, 48, 3, 48, 3, 48, 3,
	49, 3, 49, 5, 49, 589, 10, 49, 3, 50, 3, 50, 5, 50, 593, 10, 50, 3, 50,
	3, 50, 3, 50, 3, 50, 5, 50, 599, 10, 50, 3, 51, 3, 51, 5, 51, 603, 10,
	51, 3, 51, 3, 51, 5, 51, 607, 10, 51, 3, 51, 3, 51, 3, 52, 3, 52, 3, 52,
	5, 52, 614, 10, 52, 3, 52, 3, 52, 3, 53, 3, 53, 5, 53, 620, 10, 53, 3,
	53, 3, 53, 5, 53, 624, 10, 53, 3, 53, 3, 53, 3, 54, 5, 54, 629, 10, 54,
	3, 54, 3, 54, 3, 54, 3, 54, 3, 54, 3, 55, 3, 55, 3, 55, 3, 55, 3, 55, 3,
	56, 3, 56, 3, 56, 3, 56, 5, 56, 645, 10, 56, 3, 56, 3, 56, 3, 56, 3, 56,
	5, 56, 651, 10, 56, 3, 56, 3, 56, 3, 56, 3, 56, 5, 56, 657, 10, 56, 3,
	56, 3, 56, 3, 56, 3, 56, 5, 56, 663, 10, 56, 3, 56, 3, 56, 3, 56, 3, 56,
	5, 56, 669, 10, 56, 3, 56, 3, 56, 3, 56, 3, 56, 5, 56, 675, 10, 56, 5,
	56, 677, 10, 56, 3, 57, 3, 57, 3, 58, 3, 58, 3, 58, 3, 58, 3, 58, 5, 58,
	686, 10, 58, 3, 59, 3, 59, 3, 59, 7, 59, 691, 10, 59, 12, 59, 14, 59, 694,
	11, 59, 3, 60, 3, 60, 3, 60, 7, 60, 699, 10, 60, 12, 60, 14, 60, 702, 11,
	60, 3, 61, 5, 61, 705, 10, 61, 3, 61, 3, 61, 3, 62, 3, 62, 3, 62, 3, 62,
	3, 62, 3, 62, 3, 62, 3, 62, 3, 62, 5, 62, 718, 10, 62, 3, 63, 3, 63, 3,
	63, 3, 63, 3, 63, 5, 63, 725, 10, 63, 3, 64, 3, 64, 3, 64, 3, 64, 3, 64,
	5, 64, 732, 10, 64, 3, 65, 3, 65, 3, 65, 3, 65, 3, 65, 5, 65, 739, 10,
	65, 3, 66, 3, 66, 3, 66, 3, 66, 5, 66, 745, 10, 66, 3, 67, 3, 67, 3, 67,
	3, 67, 3, 67, 5, 67, 752, 10, 67, 3, 68, 3, 68, 3, 68, 5, 68, 757, 10,
	68, 3, 69, 3, 69, 3, 69, 3, 69, 3, 69, 5, 69, 764, 10, 69, 3, 70, 3, 70,
	3, 70, 5, 70, 769, 10, 70, 3, 71, 3, 71, 5, 71, 773, 10, 71, 3, 72, 3,
	72, 5, 72, 777, 10, 72, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73,
	3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 5, 73, 791, 10, 73, 3, 73, 3, 73, 3,
	73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73,
	3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3,
	73, 5, 73, 817, 10, 73, 3, 74, 3, 74, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75,
	3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3,
	75, 3, 75, 3, 75, 3, 75, 5, 75, 840, 10, 75, 3, 75, 5, 75, 843, 10, 75,
	3, 75, 5, 75, 846, 10, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3,
	75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 5, 75, 861, 10, 75, 3, 76,
	3, 76, 3, 77, 3, 77, 3, 78, 3, 78, 3, 79, 3, 79, 3, 79, 3, 79, 5, 79, 873,
	10, 79, 3, 80, 3, 80, 3, 81, 3, 81, 3, 82, 3, 82, 3, 83, 3, 83, 3, 84,
	3, 84, 3, 85, 3, 85, 3, 86, 3, 86, 3, 87, 3, 87, 3, 88, 3, 88, 3, 88, 2,
	2, 89, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34,
	36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70,
	72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104,
	106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134,
	136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164,
	166, 168, 170, 172, 174, 2, 12, 3, 2, 24, 27, 3, 2, 34, 35, 3, 2, 47, 49,
	4, 2, 17, 17, 50, 50, 4, 2, 17, 17, 50, 54, 3, 2, 55, 56, 3, 2, 57, 58,
	3, 2, 65, 67, 3, 2, 73, 75, 3, 2, 78, 79, 2, 949, 2, 179, 3, 2, 2, 2, 4,
	181, 3, 2, 2, 2, 6, 195, 3, 2, 2, 2, 8, 199, 3, 2, 2, 2, 10, 203, 3, 2,
	2, 2, 12, 215, 3, 2, 2, 2, 14, 223, 3, 2, 2, 2, 16, 229, 3, 2, 2, 2, 18,
	236, 3, 2, 2, 2, 20, 245, 3, 2, 2, 2, 22, 251, 3, 2, 2, 2, 24, 253, 3,
	2, 2, 2, 26, 257, 3, 2, 2, 2, 28, 261, 3, 2, 2, 2, 30, 272, 3, 2, 2, 2,
	32, 276, 3, 2, 2, 2, 34, 281, 3, 2, 2, 2, 36, 293, 3, 2, 2, 2, 38, 310,
	3, 2, 2, 2, 40, 315, 3, 2, 2, 2, 42, 334, 3, 2, 2, 2, 44, 350, 3, 2, 2,
	2, 46, 352, 3, 2, 2, 2, 48, 361, 3, 2, 2, 2, 50, 381, 3, 2, 2, 2, 52, 383,
	3, 2, 2, 2, 54, 398, 3, 2, 2, 2, 56, 419, 3, 2, 2, 2, 58, 421, 3, 2, 2,
	2, 60, 424, 3, 2, 2, 2, 62, 436, 3, 2, 2, 2, 64, 438, 3, 2, 2, 2, 66, 441,
	3, 2, 2, 2, 68, 451, 3, 2, 2, 2, 70, 455, 3, 2, 2, 2, 72, 466, 3, 2, 2,
	2, 74, 483, 3, 2, 2, 2, 76, 487, 3, 2, 2, 2, 78, 489, 3, 2, 2, 2, 80, 498,
	3, 2, 2, 2, 82, 500, 3, 2, 2, 2, 84, 508, 3, 2, 2, 2, 86, 517, 3, 2, 2,
	2, 88, 526, 3, 2, 2, 2, 90, 536, 3, 2, 2, 2, 92, 565, 3, 2, 2, 2, 94, 567,
	3, 2, 2, 2, 96, 588, 3, 2, 2, 2, 98, 590, 3, 2, 2, 2, 100, 602, 3, 2, 2,
	2, 102, 610, 3, 2, 2, 2, 104, 617, 3, 2, 2, 2, 106, 628, 3, 2, 2, 2, 108,
	635, 3, 2, 2, 2, 110, 676, 3, 2, 2, 2, 112, 678, 3, 2, 2, 2, 114, 685,
	3, 2, 2, 2, 116, 687, 3, 2, 2, 2, 118, 695, 3, 2, 2, 2, 120, 704, 3, 2,
	2, 2, 122, 717, 3, 2, 2, 2, 124, 724, 3, 2, 2, 2, 126, 731, 3, 2, 2, 2,
	128, 738, 3, 2, 2, 2, 130, 744, 3, 2, 2, 2, 132, 751, 3, 2, 2, 2, 134,
	756, 3, 2, 2, 2, 136, 763, 3, 2, 2, 2, 138, 768, 3, 2, 2, 2, 140, 772,
	3, 2, 2, 2, 142, 776, 3, 2, 2, 2, 144, 816, 3, 2, 2, 2, 146, 818, 3, 2,
	2, 2, 148, 860, 3, 2, 2, 2, 150, 862, 3, 2, 2, 2, 152, 864, 3, 2, 2, 2,
	154, 866, 3, 2, 2, 2, 156, 872, 3, 2, 2, 2, 158, 874, 3, 2, 2, 2, 160,
	876, 3, 2, 2, 2, 162, 878, 3, 2, 2, 2, 164, 880, 3, 2, 2, 2, 166, 882,
	3, 2, 2, 2, 168, 884, 3, 2, 2, 2, 170, 886, 3, 2, 2, 2, 172, 888, 3, 2,
	2, 2, 174, 890, 3, 2, 2, 2, 176, 180, 5, 4, 3, 2, 177, 180, 5, 6, 4, 2,
	178, 180, 5, 8, 5, 2, 179, 176, 3, 2, 2, 2, 179, 177, 3, 2, 2, 2, 179,
	178, 3, 2, 2, 2, 180, 3, 3, 2, 2, 2, 181, 182, 5, 48, 25, 2, 182, 184,
	5, 10, 6, 2, 183, 185, 5, 58, 30, 2, 184, 183, 3, 2, 2, 2, 184, 185, 3,
	2, 2, 2, 185, 187, 3, 2, 2, 2, 186, 188, 5, 60, 31, 2, 187, 186, 3, 2,
	2, 2, 187, 188, 3, 2, 2, 2, 188, 190, 3, 2, 2, 2, 189, 191, 5, 64, 33,
	2, 190, 189, 3, 2, 2, 2, 190, 191, 3, 2, 2, 2, 191, 193, 3, 2, 2, 2, 192,
	194, 5, 66, 34, 2, 193, 192, 3, 2, 2, 2, 193, 194, 3, 2, 2, 2, 194, 5,
	3, 2, 2, 2, 195, 197, 5, 40, 21, 2, 196, 198, 5, 58, 30, 2, 197, 196, 3,
	2, 2, 2, 197, 198, 3, 2, 2, 2, 198, 7, 3, 2, 2, 2, 199, 201, 5, 46, 24,
	2, 200, 202, 5, 58, 30, 2, 201, 200, 3, 2, 2, 2, 201, 202, 3, 2, 2, 2,
	202, 9, 3, 2, 2, 2, 203, 204, 7, 3, 2, 2, 204, 212, 5, 12, 7, 2, 205, 208,
	7, 4, 2, 2, 206, 209, 5, 12, 7, 2, 207, 209, 5, 28, 15, 2, 208, 206, 3,
	2, 2, 2, 208, 207, 3, 2, 2, 2, 209, 211, 3, 2, 2, 2, 210, 205, 3, 2, 2,
	2, 211, 214, 3, 2, 2, 2, 212, 210, 3, 2, 2, 2, 212, 213, 3, 2, 2, 2, 213,
	11, 3, 2, 2, 2, 214, 212, 3, 2, 2, 2, 215, 220, 5, 14, 8, 2, 216, 219,
	5, 16, 9, 2, 217, 219, 5, 18, 10, 2, 218, 216, 3, 2, 2, 2, 218, 217, 3,
	2, 2, 2, 219, 222, 3, 2, 2, 2, 220, 218, 3, 2, 2, 2, 220, 221, 3, 2, 2,
	2, 221, 13, 3, 2, 2, 2, 222, 220, 3, 2, 2, 2, 223, 225, 5, 174, 88, 2,
	224, 226, 7, 5, 2, 2, 225, 224, 3, 2, 2, 2, 225, 226, 3, 2, 2, 2, 226,
	227, 3, 2, 2, 2, 227, 228, 7, 80, 2, 2, 228, 15, 3, 2, 2, 2, 229, 230,
	5, 20, 11, 2, 230, 232, 5, 22, 12, 2, 231, 233, 7, 5, 2, 2, 232, 231, 3,
	2, 2, 2, 232, 233, 3, 2, 2, 2, 233, 234, 3, 2, 2, 2, 234, 235, 7, 80, 2,
	2, 235, 17, 3, 2, 2, 2, 236, 237, 5, 20, 11, 2, 237, 238, 7, 6, 2, 2, 238,
	239, 5, 22, 12, 2, 239, 19, 3, 2, 2, 2, 240, 242, 7, 7, 2, 2, 241, 243,
	7, 8, 2, 2, 242, 241, 3, 2, 2, 2, 242, 243, 3, 2, 2, 2, 243, 246, 3, 2,
	2, 2, 244, 246, 7, 9, 2, 2, 245, 240, 3, 2, 2, 2, 245, 244, 3, 2, 2, 2,
	245, 246, 3, 2, 2, 2, 246, 247, 3, 2, 2, 2, 247, 248, 7, 10, 2, 2, 248,
	21, 3, 2, 2, 2, 249, 252, 5, 24, 13, 2, 250, 252, 5, 26, 14, 2, 251, 249,
	3, 2, 2, 2, 251, 250, 3, 2, 2, 2, 252, 23, 3, 2, 2, 2, 253, 254, 7, 80,
	2, 2, 254, 255, 7, 11, 2, 2, 255, 256, 5, 172, 87, 2, 256, 25, 3, 2, 2,
	2, 257, 258, 7, 80, 2, 2, 258, 259, 7, 11, 2, 2, 259, 260, 5, 170, 86,
	2, 260, 27, 3, 2, 2, 2, 261, 262, 7, 12, 2, 2, 262, 263, 7, 13, 2, 2, 263,
	264, 5, 36, 19, 2, 264, 266, 7, 14, 2, 2, 265, 267, 7, 5, 2, 2, 266, 265,
	3, 2, 2, 2, 266, 267, 3, 2, 2, 2, 267, 268, 3, 2, 2, 2, 268, 269, 7, 80,
	2, 2, 269, 29, 3, 2, 2, 2, 270, 273, 5, 32, 17, 2, 271, 273, 5, 34, 18,
	2, 272, 270, 3, 2, 2, 2, 272, 271, 3, 2, 2, 2, 273, 31, 3, 2, 2, 2, 274,
	277, 7, 80, 2, 2, 275, 277, 5, 34, 18, 2, 276, 274, 3, 2, 2, 2, 276, 275,
	3, 2, 2, 2, 277, 278, 3, 2, 2, 2, 278, 279, 7, 11, 2, 2, 279, 280, 5, 38,
	20, 2, 280, 33, 3, 2, 2, 2, 281, 282, 7, 80, 2, 2, 282, 288, 7, 11, 2,
	2, 283, 284, 5, 170, 86, 2, 284, 285, 7, 11, 2, 2, 285, 287, 3, 2, 2, 2,
	286, 283, 3, 2, 2, 2, 287, 290, 3, 2, 2, 2, 288, 286, 3, 2, 2, 2, 288,
	289, 3, 2, 2, 2, 289, 291, 3, 2, 2, 2, 290, 288, 3, 2, 2, 2, 291, 292,
	5, 170, 86, 2, 292, 35, 3, 2, 2, 2, 293, 294, 7, 80, 2, 2, 294, 300, 7,
	11, 2, 2, 295, 296, 5, 170, 86, 2, 296, 297, 7, 11, 2, 2, 297, 299, 3,
	2, 2, 2, 298, 295, 3, 2, 2, 2, 299, 302, 3, 2, 2, 2, 300, 298, 3, 2, 2,
	2, 300, 301, 3, 2, 2, 2, 301, 303, 3, 2, 2, 2, 302, 300, 3, 2, 2, 2, 303,
	304, 5, 172, 87, 2, 304, 37, 3, 2, 2, 2, 305, 306, 5, 168, 85, 2, 306,
	307, 7, 11, 2, 2, 307, 309, 3, 2, 2, 2, 308, 305, 3, 2, 2, 2, 309, 312,
	3, 2, 2, 2, 310, 308, 3, 2, 2, 2, 310, 311, 3, 2, 2, 2, 311, 313, 3, 2,
	2, 2, 312, 310, 3, 2, 2, 2, 313, 314, 5, 166, 84, 2, 314, 39, 3, 2, 2,
	2, 315, 316, 7, 15, 2, 2, 316, 321, 5, 174, 88, 2, 317, 319, 7, 5, 2, 2,
	318, 317, 3, 2, 2, 2, 318, 319, 3, 2, 2, 2, 319, 320, 3, 2, 2, 2, 320,
	322, 7, 80, 2, 2, 321, 318, 3, 2, 2, 2, 321, 322, 3, 2, 2, 2, 322, 323,
	3, 2, 2, 2, 323, 324, 7, 16, 2, 2, 324, 329, 5, 42, 22, 2, 325, 326, 7,
	4, 2, 2, 326, 328, 5, 42, 22, 2, 327, 325, 3, 2, 2, 2, 328, 331, 3, 2,
	2, 2, 329, 327, 3, 2, 2, 2, 329, 330, 3, 2, 2, 2, 330, 41, 3, 2, 2, 2,
	331, 329, 3, 2, 2, 2, 332, 333, 7, 80, 2, 2, 333, 335, 7, 11, 2, 2, 334,
	332, 3, 2, 2, 2, 334, 335, 3, 2, 2, 2, 335, 338, 3, 2, 2, 2, 336, 339,
	5, 38, 20, 2, 337, 339, 5, 170, 86, 2, 338, 336, 3, 2, 2, 2, 338, 337,
	3, 2, 2, 2, 339, 340, 3, 2, 2, 2, 340, 341, 7, 17, 2, 2, 341, 342, 5, 44,
	23, 2, 342, 43, 3, 2, 2, 2, 343, 351, 5, 116, 59, 2, 344, 351, 5, 126,
	64, 2, 345, 351, 5, 130, 66, 2, 346, 351, 5, 134, 68, 2, 347, 351, 5, 138,
	70, 2, 348, 351, 5, 142, 72, 2, 349, 351, 7, 18, 2, 2, 350, 343, 3, 2,
	2, 2, 350, 344, 3, 2, 2, 2, 350, 345, 3, 2, 2, 2, 350, 346, 3, 2, 2, 2,
	350, 347, 3, 2, 2, 2, 350, 348, 3, 2, 2, 2, 350, 349, 3, 2, 2, 2, 351,
	45, 3, 2, 2, 2, 352, 353, 7, 19, 2, 2, 353, 354, 7, 3, 2, 2, 354, 359,
	5, 174, 88, 2, 355, 357, 7, 5, 2, 2, 356, 355, 3, 2, 2, 2, 356, 357, 3,
	2, 2, 2, 357, 358, 3, 2, 2, 2, 358, 360, 7, 80, 2, 2, 359, 356, 3, 2, 2,
	2, 359, 360, 3, 2, 2, 2, 360, 47, 3, 2, 2, 2, 361, 363, 7, 20, 2, 2, 362,
	364, 7, 21, 2, 2, 363, 362, 3, 2, 2, 2, 363, 364, 3, 2, 2, 2, 364, 365,
	3, 2, 2, 2, 365, 370, 5, 50, 26, 2, 366, 367, 7, 4, 2, 2, 367, 369, 5,
	50, 26, 2, 368, 366, 3, 2, 2, 2, 369, 372, 3, 2, 2, 2, 370, 368, 3, 2,
	2, 2, 370, 371, 3, 2, 2, 2, 371, 49, 3, 2, 2, 2, 372, 370, 3, 2, 2, 2,
	373, 382, 5, 30, 16, 2, 374, 382, 5, 56, 29, 2, 375, 382, 7, 80, 2, 2,
	376, 377, 7, 22, 2, 2, 377, 378, 7, 13, 2, 2, 378, 379, 7, 80, 2, 2, 379,
	382, 7, 14, 2, 2, 380, 382, 5, 52, 27, 2, 381, 373, 3, 2, 2, 2, 381, 374,
	3, 2, 2, 2, 381, 375, 3, 2, 2, 2, 381, 376, 3, 2, 2, 2, 381, 380, 3, 2,
	2, 2, 382, 51, 3, 2, 2, 2, 383, 384, 7, 23, 2, 2, 384, 385, 5, 160, 81,
	2, 385, 386, 7, 13, 2, 2, 386, 391, 5, 54, 28, 2, 387, 388, 7, 4, 2, 2,
	388, 390, 5, 54, 28, 2, 389, 387, 3, 2, 2, 2, 390, 393, 3, 2, 2, 2, 391,
	389, 3, 2, 2, 2, 391, 392, 3, 2, 2, 2, 392, 394, 3, 2, 2, 2, 393, 391,
	3, 2, 2, 2, 394, 395, 7, 14, 2, 2, 395, 53, 3, 2, 2, 2, 396, 399, 5, 30,
	16, 2, 397, 399, 5, 56, 29, 2, 398, 396, 3, 2, 2, 2, 398, 397, 3, 2, 2,
	2, 399, 55, 3, 2, 2, 2, 400, 401, 9, 2, 2, 2, 401, 403, 7, 13, 2, 2, 402,
	404, 7, 21, 2, 2, 403, 402, 3, 2, 2, 2, 403, 404, 3, 2, 2, 2, 404, 405,
	3, 2, 2, 2, 405, 406, 5, 32, 17, 2, 406, 407, 7, 14, 2, 2, 407, 420, 3,
	2, 2, 2, 408, 409, 7, 28, 2, 2, 409, 411, 7, 13, 2, 2, 410, 412, 7, 21,
	2, 2, 411, 410, 3, 2, 2, 2, 411, 412, 3, 2, 2, 2, 412, 416, 3, 2, 2, 2,
	413, 417, 7, 80, 2, 2, 414, 417, 5, 32, 17, 2, 415, 417, 5, 34, 18, 2,
	416, 413, 3, 2, 2, 2, 416, 414, 3, 2, 2, 2, 416, 415, 3, 2, 2, 2, 417,
	418, 3, 2, 2, 2, 418, 420, 7, 14, 2, 2, 419, 400, 3, 2, 2, 2, 419, 408,
	3, 2, 2, 2, 420, 57, 3, 2, 2, 2, 421, 422, 7, 29, 2, 2, 422, 423, 5, 82,
	42, 2, 423, 59, 3, 2, 2, 2, 424, 425, 7, 30, 2, 2, 425, 426, 7, 31, 2,
	2, 426, 431, 5, 62, 32, 2, 427, 428, 7, 4, 2, 2, 428, 430, 5, 62, 32, 2,
	429, 427, 3, 2, 2, 2, 430, 433, 3, 2, 2, 2, 431, 429, 3, 2, 2, 2, 431,
	432, 3, 2, 2, 2, 432, 61, 3, 2, 2, 2, 433, 431, 3, 2, 2, 2, 434, 437, 5,
	30, 16, 2, 435, 437, 7, 80, 2, 2, 436, 434, 3, 2, 2, 2, 436, 435, 3, 2,
	2, 2, 437, 63, 3, 2, 2, 2, 438, 439, 7, 32, 2, 2, 439, 440, 5, 82, 42,
	2, 440, 65, 3, 2, 2, 2, 441, 442, 7, 33, 2, 2, 442, 443, 7, 31, 2, 2, 443,
	448, 5, 68, 35, 2, 444, 445, 7, 4, 2, 2, 445, 447, 5, 68, 35, 2, 446, 444,
	3, 2, 2, 2, 447, 450, 3, 2, 2, 2, 448, 446, 3, 2, 2, 2, 448, 449, 3, 2,
	2, 2, 449, 67, 3, 2, 2, 2, 450, 448, 3, 2, 2, 2, 451, 453, 5, 32, 17, 2,
	452, 454, 9, 3, 2, 2, 453, 452, 3, 2, 2, 2, 453, 454, 3, 2, 2, 2, 454,
	69, 3, 2, 2, 2, 455, 456, 5, 78, 40, 2, 456, 458, 5, 72, 37, 2, 457, 459,
	5, 58, 30, 2, 458, 457, 3, 2, 2, 2, 458, 459, 3, 2, 2, 2, 459, 461, 3,
	2, 2, 2, 460, 462, 5, 60, 31, 2, 461, 460, 3, 2, 2, 2, 461, 462, 3, 2,
	2, 2, 462, 464, 3, 2, 2, 2, 463, 465, 5, 64, 33, 2, 464, 463, 3, 2, 2,
	2, 464, 465, 3, 2, 2, 2, 465, 71, 3, 2, 2, 2, 466, 467, 7, 3, 2, 2, 467,
	472, 5, 74, 38, 2, 468, 469, 7, 4, 2, 2, 469, 471, 5, 74, 38, 2, 470, 468,
	3, 2, 2, 2, 471, 474, 3, 2, 2, 2, 472, 470, 3, 2, 2, 2, 472, 473, 3, 2,
	2, 2, 473, 73, 3, 2, 2, 2, 474, 472, 3, 2, 2, 2, 475, 484, 5, 12, 7, 2,
	476, 478, 5, 76, 39, 2, 477, 479, 7, 5, 2, 2, 478, 477, 3, 2, 2, 2, 478,
	479, 3, 2, 2, 2, 479, 480, 3, 2, 2, 2, 480, 481, 7, 80, 2, 2, 481, 484,
	3, 2, 2, 2, 482, 484, 5, 28, 15, 2, 483, 475, 3, 2, 2, 2, 483, 476, 3,
	2, 2, 2, 483, 482, 3, 2, 2, 2, 484, 75, 3, 2, 2, 2, 485, 488, 5, 36, 19,
	2, 486, 488, 5, 34, 18, 2, 487, 485, 3, 2, 2, 2, 487, 486, 3, 2, 2, 2,
	488, 77, 3, 2, 2, 2, 489, 491, 7, 20, 2, 2, 490, 492, 7, 21, 2, 2, 491,
	490, 3, 2, 2, 2, 491, 492, 3, 2, 2, 2, 492, 493, 3, 2, 2, 2, 493, 494,
	5, 80, 41, 2, 494, 79, 3, 2, 2, 2, 495, 499, 5, 30, 16, 2, 496, 499, 5,
	56, 29, 2, 497, 499, 7, 80, 2, 2, 498, 495, 3, 2, 2, 2, 498, 496, 3, 2,
	2, 2, 498, 497, 3, 2, 2, 2, 499, 81, 3, 2, 2, 2, 500, 505, 5, 84, 43, 2,
	501, 502, 7, 36, 2, 2, 502, 504, 5, 84, 43, 2, 503, 501, 3, 2, 2, 2, 504,
	507, 3, 2, 2, 2, 505, 503, 3, 2, 2, 2, 505, 506, 3, 2, 2, 2, 506, 83, 3,
	2, 2, 2, 507, 505, 3, 2, 2, 2, 508, 513, 5, 86, 44, 2, 509, 510, 7, 37,
	2, 2, 510, 512, 5, 86, 44, 2, 511, 509, 3, 2, 2, 2, 512, 515, 3, 2, 2,
	2, 513, 511, 3, 2, 2, 2, 513, 514, 3, 2, 2, 2, 514, 85, 3, 2, 2, 2, 515,
	513, 3, 2, 2, 2, 516, 518, 7, 38, 2, 2, 517, 516, 3, 2, 2, 2, 517, 518,
	3, 2, 2, 2, 518, 519, 3, 2, 2, 2, 519, 520, 5, 88, 45, 2, 520, 87, 3, 2,
	2, 2, 521, 527, 5, 90, 46, 2, 522, 523, 7, 13, 2, 2, 523, 524, 5, 82, 42,
	2, 524, 525, 7, 14, 2, 2, 525, 527, 3, 2, 2, 2, 526, 521, 3, 2, 2, 2, 526,
	522, 3, 2, 2, 2, 527, 89, 3, 2, 2, 2, 528, 537, 5, 110, 56, 2, 529, 537,
	5, 92, 47, 2, 530, 537, 5, 98, 50, 2, 531, 537, 5, 94, 48, 2, 532, 537,
	5, 100, 51, 2, 533, 537, 5, 102, 52, 2, 534, 537, 5, 104, 53, 2, 535, 537,
	5, 106, 54, 2, 536, 528, 3, 2, 2, 2, 536, 529, 3, 2, 2, 2, 536, 530, 3,
	2, 2, 2, 536, 531, 3, 2, 2, 2, 536, 532, 3, 2, 2, 2, 536, 533, 3, 2, 2,
	2, 536, 534, 3, 2, 2, 2, 536, 535, 3, 2, 2, 2, 537, 91, 3, 2, 2, 2, 538,
	540, 5, 114, 58, 2, 539, 541, 7, 38, 2, 2, 540, 539, 3, 2, 2, 2, 540, 541,
	3, 2, 2, 2, 541, 542, 3, 2, 2, 2, 542, 543, 7, 39, 2, 2, 543, 544, 5, 114,
	58, 2, 544, 545, 7, 37, 2, 2, 545, 546, 5, 114, 58, 2, 546, 566, 3, 2,
	2, 2, 547, 549, 5, 124, 63, 2, 548, 550, 7, 38, 2, 2, 549, 548, 3, 2, 2,
	2, 549, 550, 3, 2, 2, 2, 550, 551, 3, 2, 2, 2, 551, 552, 7, 39, 2, 2, 552,
	553, 5, 124, 63, 2, 553, 554, 7, 37, 2, 2, 554, 555, 5, 124, 63, 2, 555,
	566, 3, 2, 2, 2, 556, 558, 5, 128, 65, 2, 557, 559, 7, 38, 2, 2, 558, 557,
	3, 2, 2, 2, 558, 559, 3, 2, 2, 2, 559, 560, 3, 2, 2, 2, 560, 561, 7, 39,
	2, 2, 561, 562, 5, 128, 65, 2, 562, 563, 7, 37, 2, 2, 563, 564, 5, 128,
	65, 2, 564, 566, 3, 2, 2, 2, 565, 538, 3, 2, 2, 2, 565, 547, 3, 2, 2, 2,
	565, 556, 3, 2, 2, 2, 566, 93, 3, 2, 2, 2, 567, 569, 5, 32, 17, 2, 568,
	570, 7, 38, 2, 2, 569, 568, 3, 2, 2, 2, 569, 570, 3, 2, 2, 2, 570, 571,
	3, 2, 2, 2, 571, 572, 7, 12, 2, 2, 572, 582, 7, 13, 2, 2, 573, 578, 5,
	96, 49, 2, 574, 575, 7, 4, 2, 2, 575, 577, 5, 96, 49, 2, 576, 574, 3, 2,
	2, 2, 577, 580, 3, 2, 2, 2, 578, 576, 3, 2, 2, 2, 578, 579, 3, 2, 2, 2,
	579, 583, 3, 2, 2, 2, 580, 578, 3, 2, 2, 2, 581, 583, 5, 70, 36, 2, 582,
	573, 3, 2, 2, 2, 582, 581, 3, 2, 2, 2, 583, 584, 3, 2, 2, 2, 584, 585,
	7, 14, 2, 2, 585, 95, 3, 2, 2, 2, 586, 589, 5, 158, 80, 2, 587, 589, 5,
	156, 79, 2, 588, 586, 3, 2, 2, 2, 588, 587, 3, 2, 2, 2, 589, 97, 3, 2,
	2, 2, 590, 592, 5, 124, 63, 2, 591, 593, 7, 38, 2, 2, 592, 591, 3, 2, 2,
	2, 592, 593, 3, 2, 2, 2, 593, 594, 3, 2, 2, 2, 594, 595, 7, 40, 2, 2, 595,
	598, 5, 154, 78, 2, 596, 597, 7, 41, 2, 2, 597, 599, 7, 83, 2, 2, 598,
	596, 3, 2, 2, 2, 598, 599, 3, 2, 2, 2, 599, 99, 3, 2, 2, 2, 600, 603, 5,
	30, 16, 2, 601, 603, 5, 156, 79, 2, 602, 600, 3, 2, 2, 2, 602, 601, 3,
	2, 2, 2, 603, 604, 3, 2, 2, 2, 604, 606, 7, 42, 2, 2, 605, 607, 7, 38,
	2, 2, 606, 605, 3, 2, 2, 2, 606, 607, 3, 2, 2, 2, 607, 608, 3, 2, 2, 2,
	608, 609, 7, 18, 2, 2, 609, 101, 3, 2, 2, 2, 610, 611, 5, 36, 19, 2, 611,
	613, 7, 42, 2, 2, 612, 614, 7, 38, 2, 2, 613, 612, 3, 2, 2, 2, 613, 614,
	3, 2, 2, 2, 614, 615, 3, 2, 2, 2, 615, 616, 7, 43, 2, 2, 616, 103, 3, 2,
	2, 2, 617, 619, 5, 140, 71, 2, 618, 620, 7, 38, 2, 2, 619, 618, 3, 2, 2,
	2, 619, 620, 3, 2, 2, 2, 620, 621, 3, 2, 2, 2, 621, 623, 7, 44, 2, 2, 622,
	624, 7, 45, 2, 2, 623, 622, 3, 2, 2, 2, 623, 624, 3, 2, 2, 2, 624, 625,
	3, 2, 2, 2, 625, 626, 5, 36, 19, 2, 626, 105, 3, 2, 2, 2, 627, 629, 7,
	38, 2, 2, 628, 627, 3, 2, 2, 2, 628, 629, 3, 2, 2, 2, 629, 630, 3, 2, 2,
	2, 630, 631, 7, 46, 2, 2, 631, 632, 7, 13, 2, 2, 632, 633, 5, 70, 36, 2,
	633, 634, 7, 14, 2, 2, 634, 107, 3, 2, 2, 2, 635, 636, 9, 4, 2, 2, 636,
	637, 7, 13, 2, 2, 637, 638, 5, 70, 36, 2, 638, 639, 7, 14, 2, 2, 639, 109,
	3, 2, 2, 2, 640, 641, 5, 124, 63, 2, 641, 644, 5, 112, 57, 2, 642, 645,
	5, 124, 63, 2, 643, 645, 5, 108, 55, 2, 644, 642, 3, 2, 2, 2, 644, 643,
	3, 2, 2, 2, 645, 677, 3, 2, 2, 2, 646, 647, 5, 132, 67, 2, 647, 650, 9,
	5, 2, 2, 648, 651, 5, 132, 67, 2, 649, 651, 5, 108, 55, 2, 650, 648, 3,
	2, 2, 2, 650, 649, 3, 2, 2, 2, 651, 677, 3, 2, 2, 2, 652, 653, 5, 136,
	69, 2, 653, 656, 9, 5, 2, 2, 654, 657, 5, 136, 69, 2, 655, 657, 5, 108,
	55, 2, 656, 654, 3, 2, 2, 2, 656, 655, 3, 2, 2, 2, 657, 677, 3, 2, 2, 2,
	658, 659, 5, 128, 65, 2, 659, 662, 5, 112, 57, 2, 660, 663, 5, 128, 65,
	2, 661, 663, 5, 108, 55, 2, 662, 660, 3, 2, 2, 2, 662, 661, 3, 2, 2, 2,
	663, 677, 3, 2, 2, 2, 664, 665, 5, 140, 71, 2, 665, 668, 9, 5, 2, 2, 666,
	669, 5, 140, 71, 2, 667, 669, 5, 108, 55, 2, 668, 666, 3, 2, 2, 2, 668,
	667, 3, 2, 2, 2, 669, 677, 3, 2, 2, 2, 670, 671, 5, 114, 58, 2, 671, 674,
	5, 112, 57, 2, 672, 675, 5, 114, 58, 2, 673, 675, 5, 108, 55, 2, 674, 672,
	3, 2, 2, 2, 674, 673, 3, 2, 2, 2, 675, 677, 3, 2, 2, 2, 676, 640, 3, 2,
	2, 2, 676, 646, 3, 2, 2, 2, 676, 652, 3, 2, 2, 2, 676, 658, 3, 2, 2, 2,
	676, 664, 3, 2, 2, 2, 676, 670, 3, 2, 2, 2, 677, 111, 3, 2, 2, 2, 678,
	679, 9, 6, 2, 2, 679, 113, 3, 2, 2, 2, 680, 686, 5, 116, 59, 2, 681, 682,
	7, 13, 2, 2, 682, 683, 5, 70, 36, 2, 683, 684, 7, 14, 2, 2, 684, 686, 3,
	2, 2, 2, 685, 680, 3, 2, 2, 2, 685, 681, 3, 2, 2, 2, 686, 115, 3, 2, 2,
	2, 687, 692, 5, 118, 60, 2, 688, 689, 9, 7, 2, 2, 689, 691, 5, 118, 60,
	2, 690, 688, 3, 2, 2, 2, 691, 694, 3, 2, 2, 2, 692, 690, 3, 2, 2, 2, 692,
	693, 3, 2, 2, 2, 693, 117, 3, 2, 2, 2, 694, 692, 3, 2, 2, 2, 695, 700,
	5, 120, 61, 2, 696, 697, 9, 8, 2, 2, 697, 699, 5, 120, 61, 2, 698, 696,
	3, 2, 2, 2, 699, 702, 3, 2, 2, 2, 700, 698, 3, 2, 2, 2, 700, 701, 3, 2,
	2, 2, 701, 119, 3, 2, 2, 2, 702, 700, 3, 2, 2, 2, 703, 705, 9, 7, 2, 2,
	704, 703, 3, 2, 2, 2, 704, 705, 3, 2, 2, 2, 705, 706, 3, 2, 2, 2, 706,
	707, 5, 122, 62, 2, 707, 121, 3, 2, 2, 2, 708, 718, 5, 32, 17, 2, 709,
	718, 5, 152, 77, 2, 710, 711, 7, 13, 2, 2, 711, 712, 5, 116, 59, 2, 712,
	713, 7, 14, 2, 2, 713, 718, 3, 2, 2, 2, 714, 718, 5, 156, 79, 2, 715, 718,
	5, 144, 73, 2, 716, 718, 5, 56, 29, 2, 717, 708, 3, 2, 2, 2, 717, 709,
	3, 2, 2, 2, 717, 710, 3, 2, 2, 2, 717, 714, 3, 2, 2, 2, 717, 715, 3, 2,
	2, 2, 717, 716, 3, 2, 2, 2, 718, 123, 3, 2, 2, 2, 719, 725, 5, 126, 64,
	2, 720, 721, 7, 13, 2, 2, 721, 722, 5, 70, 36, 2, 722, 723, 7, 14, 2, 2,
	723, 725, 3, 2, 2, 2, 724, 719, 3, 2, 2, 2, 724, 720, 3, 2, 2, 2, 725,
	125, 3, 2, 2, 2, 726, 732, 5, 32, 17, 2, 727, 732, 7, 82, 2, 2, 728, 732,
	5, 156, 79, 2, 729, 732, 5, 148, 75, 2, 730, 732, 5, 56, 29, 2, 731, 726,
	3, 2, 2, 2, 731, 727, 3, 2, 2, 2, 731, 728, 3, 2, 2, 2, 731, 729, 3, 2,
	2, 2, 731, 730, 3, 2, 2, 2, 732, 127, 3, 2, 2, 2, 733, 739, 5, 130, 66,
	2, 734, 735, 7, 13, 2, 2, 735, 736, 5, 70, 36, 2, 736, 737, 7, 14, 2, 2,
	737, 739, 3, 2, 2, 2, 738, 733, 3, 2, 2, 2, 738, 734, 3, 2, 2, 2, 739,
	129, 3, 2, 2, 2, 740, 745, 5, 32, 17, 2, 741, 745, 5, 156, 79, 2, 742,
	745, 5, 146, 74, 2, 743, 745, 5, 56, 29, 2, 744, 740, 3, 2, 2, 2, 744,
	741, 3, 2, 2, 2, 744, 742, 3, 2, 2, 2, 744, 743, 3, 2, 2, 2, 745, 131,
	3, 2, 2, 2, 746, 752, 5, 134, 68, 2, 747, 748, 7, 13, 2, 2, 748, 749, 5,
	70, 36, 2, 749, 750, 7, 14, 2, 2, 750, 752, 3, 2, 2, 2, 751, 746, 3, 2,
	2, 2, 751, 747, 3, 2, 2, 2, 752, 133, 3, 2, 2, 2, 753, 757, 5, 32, 17,
	2, 754, 757, 5, 164, 83, 2, 755, 757, 5, 156, 79, 2, 756, 753, 3, 2, 2,
	2, 756, 754, 3, 2, 2, 2, 756, 755, 3, 2, 2, 2, 757, 135, 3, 2, 2, 2, 758,
	764, 5, 138, 70, 2, 759, 760, 7, 13, 2, 2, 760, 761, 5, 70, 36, 2, 761,
	762, 7, 14, 2, 2, 762, 764, 3, 2, 2, 2, 763, 758, 3, 2, 2, 2, 763, 759,
	3, 2, 2, 2, 764, 137, 3, 2, 2, 2, 765, 769, 5, 32, 17, 2, 766, 769, 5,
	162, 82, 2, 767, 769, 5, 156, 79, 2, 768, 765, 3, 2, 2, 2, 768, 766, 3,
	2, 2, 2, 768, 767, 3, 2, 2, 2, 769, 139, 3, 2, 2, 2, 770, 773, 5, 34, 18,
	2, 771, 773, 5, 142, 72, 2, 772, 770, 3, 2, 2, 2, 772, 771, 3, 2, 2, 2,
	773, 141, 3, 2, 2, 2, 774, 777, 7, 80, 2, 2, 775, 777, 5, 156, 79, 2, 776,
	774, 3, 2, 2, 2, 776, 775, 3, 2, 2, 2, 777, 143, 3, 2, 2, 2, 778, 779,
	7, 59, 2, 2, 779, 780, 7, 13, 2, 2, 780, 781, 5, 126, 64, 2, 781, 782,
	7, 14, 2, 2, 782, 817, 3, 2, 2, 2, 783, 784, 7, 60, 2, 2, 784, 785, 7,
	13, 2, 2, 785, 786, 5, 126, 64, 2, 786, 787, 7, 4, 2, 2, 787, 790, 5, 126,
	64, 2, 788, 789, 7, 4, 2, 2, 789, 791, 5, 116, 59, 2, 790, 788, 3, 2, 2,
	2, 790, 791, 3, 2, 2, 2, 791, 792, 3, 2, 2, 2, 792, 793, 7, 14, 2, 2, 793,
	817, 3, 2, 2, 2, 794, 795, 7, 61, 2, 2, 795, 796, 7, 13, 2, 2, 796, 797,
	5, 116, 59, 2, 797, 798, 7, 14, 2, 2, 798, 817, 3, 2, 2, 2, 799, 800, 7,
	62, 2, 2, 800, 801, 7, 13, 2, 2, 801, 802, 5, 116, 59, 2, 802, 803, 7,
	14, 2, 2, 803, 817, 3, 2, 2, 2, 804, 805, 7, 63, 2, 2, 805, 806, 7, 13,
	2, 2, 806, 807, 5, 116, 59, 2, 807, 808, 7, 4, 2, 2, 808, 809, 5, 116,
	59, 2, 809, 810, 7, 14, 2, 2, 810, 817, 3, 2, 2, 2, 811, 812, 7, 64, 2,
	2, 812, 813, 7, 13, 2, 2, 813, 814, 5, 36, 19, 2, 814, 815, 7, 14, 2, 2,
	815, 817, 3, 2, 2, 2, 816, 778, 3, 2, 2, 2, 816, 783, 3, 2, 2, 2, 816,
	794, 3, 2, 2, 2, 816, 799, 3, 2, 2, 2, 816, 804, 3, 2, 2, 2, 816, 811,
	3, 2, 2, 2, 817, 145, 3, 2, 2, 2, 818, 819, 9, 9, 2, 2, 819, 147, 3, 2,
	2, 2, 820, 821, 7, 68, 2, 2, 821, 822, 7, 13, 2, 2, 822, 823, 5, 126, 64,
	2, 823, 824, 7, 4, 2, 2, 824, 825, 5, 126, 64, 2, 825, 826, 7, 14, 2, 2,
	826, 861, 3, 2, 2, 2, 827, 828, 7, 69, 2, 2, 828, 829, 7, 13, 2, 2, 829,
	830, 5, 126, 64, 2, 830, 831, 7, 4, 2, 2, 831, 832, 5, 116, 59, 2, 832,
	833, 7, 4, 2, 2, 833, 834, 5, 116, 59, 2, 834, 835, 7, 14, 2, 2, 835, 861,
	3, 2, 2, 2, 836, 837, 7, 70, 2, 2, 837, 845, 7, 13, 2, 2, 838, 840, 5,
	150, 76, 2, 839, 838, 3, 2, 2, 2, 839, 840, 3, 2, 2, 2, 840, 842, 3, 2,
	2, 2, 841, 843, 7, 85, 2, 2, 842, 841, 3, 2, 2, 2, 842, 843, 3, 2, 2, 2,
	843, 844, 3, 2, 2, 2, 844, 846, 7, 3, 2, 2, 845, 839, 3, 2, 2, 2, 845,
	846, 3, 2, 2, 2, 846, 847, 3, 2, 2, 2, 847, 848, 5, 126, 64, 2, 848, 849,
	7, 14, 2, 2, 849, 861, 3, 2, 2, 2, 850, 851, 7, 71, 2, 2, 851, 852, 7,
	13, 2, 2, 852, 853, 5, 126, 64, 2, 853, 854, 7, 14, 2, 2, 854, 861, 3,
	2, 2, 2, 855, 856, 7, 72, 2, 2, 856, 857, 7, 13, 2, 2, 857, 858, 5, 126,
	64, 2, 858, 859, 7, 14, 2, 2, 859, 861, 3, 2, 2, 2, 860, 820, 3, 2, 2,
	2, 860, 827, 3, 2, 2, 2, 860, 836, 3, 2, 2, 2, 860, 850, 3, 2, 2, 2, 860,
	855, 3, 2, 2, 2, 861, 149, 3, 2, 2, 2, 862, 863, 9, 10, 2, 2, 863, 151,
	3, 2, 2, 2, 864, 865, 3, 2, 2, 2, 865, 153, 3, 2, 2, 2, 866, 867, 3, 2,
	2, 2, 867, 155, 3, 2, 2, 2, 868, 869, 7, 76, 2, 2, 869, 873, 7, 86, 2,
	2, 870, 871, 7, 77, 2, 2, 871, 873, 7, 80, 2, 2, 872, 868, 3, 2, 2, 2,
	872, 870, 3, 2, 2, 2, 873, 157, 3, 2, 2, 2, 874, 875, 3, 2, 2, 2, 875,
	159, 3, 2, 2, 2, 876, 877, 3, 2, 2, 2, 877, 161, 3, 2, 2, 2, 878, 879,
	3, 2, 2, 2, 879, 163, 3, 2, 2, 2, 880, 881, 9, 11, 2, 2, 881, 165, 3, 2,
	2, 2, 882, 883, 3, 2, 2, 2, 883, 167, 3, 2, 2, 2, 884, 885, 3, 2, 2, 2,
	885, 169, 3, 2, 2, 2, 886, 887, 3, 2, 2, 2, 887, 171, 3, 2, 2, 2, 888,
	889, 3, 2, 2, 2, 889, 173, 3, 2, 2, 2, 890, 891, 3, 2, 2, 2, 891, 175,
	3, 2, 2, 2, 104, 179, 184, 187, 190, 193, 197, 201, 208, 212, 218, 220,
	225, 232, 242, 245, 251, 266, 272, 276, 288, 300, 310, 318, 321, 329, 334,
	338, 350, 356, 359, 363, 370, 381, 391, 398, 403, 411, 416, 419, 431, 436,
	448, 453, 458, 461, 464, 472, 478, 483, 487, 491, 498, 505, 513, 517, 526,
	536, 540, 549, 558, 565, 569, 578, 582, 588, 592, 598, 602, 606, 613, 619,
	623, 628, 644, 650, 656, 662, 668, 674, 676, 685, 692, 700, 704, 717, 724,
	731, 738, 744, 751, 756, 763, 768, 772, 776, 790, 816, 839, 842, 845, 860,
	872,
}
var deserializer = antlr.NewATNDeserializer(nil)
var deserializedATN = deserializer.DeserializeFromUInt16(parserATN)

var literalNames = []string{
	"", "'FROM'", "','", "'AS'", "'FETCH'", "'LEFT'", "'OUTER'", "'INNER'",
	"'JOIN'", "'.'", "'IN'", "'('", "')'", "'UPDATE'", "'SET'", "'='", "'NULL'",
	"'DELETE'", "'SELECT'", "'DISTINCT'", "'OBJECT'", "'NEW'", "'AVG'", "'MAX'",
	"'MIN'", "'SUM'", "'COUNT'", "'WHERE'", "'GROUP'", "'BY'", "'HAVING'",
	"'ORDER'", "'ASC'", "'DESC'", "'OR'", "'AND'", "'NOT'", "'BETWEEN'", "'LIKE'",
	"'ESCAPE'", "'IS'", "'EMPTY'", "'MEMBER'", "'OF'", "'EXISTS'", "'ALL'",
	"'ANY'", "'SOME'", "'<>'", "'>'", "'>='", "'<'", "'<='", "'+'", "'-'",
	"'*'", "'/'", "'LENGTH'", "'LOCATE'", "'ABS'", "'SQRT'", "'MOD'", "'SIZE'",
	"'CURRENT_DATE'", "'CURRENT_TIME'", "'CURRENT_TIMESTAMP'", "'CONCAT'",
	"'SUBSTRING'", "'TRIM'", "'LOWER'", "'UPPER'", "'LEADING'", "'TRAILING'",
	"'BOTH'", "'?'", "':'", "'true'", "'false'",
}
var symbolicNames = []string{
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "IDENTIFICATION_VARIABLE", "CHARACTER", "STRINGLITERAL",
	"ESCAPE_CHARACTER", "WS", "TRIM_CHARACTER", "INT_NUMERAL",
}

var ruleNames = []string{
	"ql_statement", "select_statement", "update_statement", "delete_statement",
	"from_clause", "identification_variable_declaration", "range_variable_declaration",
	"join", "fetch_join", "join_spec", "join_association_path_expression",
	"join_collection_valued_path_expression", "join_single_valued_association_path_expression",
	"collection_member_declaration", "single_valued_path_expression", "state_field_path_expression",
	"single_valued_association_path_expression", "collection_valued_path_expression",
	"state_field", "update_clause", "update_item", "new_value", "delete_clause",
	"select_clause", "select_expression", "constructor_expression", "constructor_item",
	"aggregate_expression", "where_clause", "groupby_clause", "groupby_item",
	"having_clause", "orderby_clause", "orderby_item", "subquery", "subquery_from_clause",
	"subselect_identification_variable_declaration", "association_path_expression",
	"simple_select_clause", "simple_select_expression", "conditional_expression",
	"conditional_term", "conditional_factor", "conditional_primary", "simple_cond_expression",
	"between_expression", "in_expression", "in_item", "like_expression", "null_comparison_expression",
	"empty_collection_comparison_expression", "collection_member_expression",
	"exists_expression", "all_or_any_expression", "comparison_expression",
	"comparison_operator", "arithmetic_expression", "simple_arithmetic_expression",
	"arithmetic_term", "arithmetic_factor", "arithmetic_primary", "string_expression",
	"string_primary", "datetime_expression", "datetime_primary", "boolean_expression",
	"boolean_primary", "enum_expression", "enum_primary", "entity_expression",
	"simple_entity_expression", "functions_returning_numerics", "functions_returning_datetime",
	"functions_returning_strings", "trim_specification", "numeric_literal",
	"pattern_value", "input_parameter", "literal", "constructor_name", "enum_literal",
	"boolean_literal", "simple_state_field", "embedded_class_state_field",
	"single_valued_association_field", "collection_valued_association_field",
	"abstract_schema_name",
}
var decisionToDFA = make([]*antlr.DFA, len(deserializedATN.DecisionToState))

func init() {
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
}

type JPAParser struct {
	*antlr.BaseParser
}

func NewJPAParser(input antlr.TokenStream) *JPAParser {
	this := new(JPAParser)

	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "JPA.g4"

	return this
}

// JPAParser tokens.
const (
	JPAParserEOF                     = antlr.TokenEOF
	JPAParserT__0                    = 1
	JPAParserT__1                    = 2
	JPAParserT__2                    = 3
	JPAParserT__3                    = 4
	JPAParserT__4                    = 5
	JPAParserT__5                    = 6
	JPAParserT__6                    = 7
	JPAParserT__7                    = 8
	JPAParserT__8                    = 9
	JPAParserT__9                    = 10
	JPAParserT__10                   = 11
	JPAParserT__11                   = 12
	JPAParserT__12                   = 13
	JPAParserT__13                   = 14
	JPAParserT__14                   = 15
	JPAParserT__15                   = 16
	JPAParserT__16                   = 17
	JPAParserT__17                   = 18
	JPAParserT__18                   = 19
	JPAParserT__19                   = 20
	JPAParserT__20                   = 21
	JPAParserT__21                   = 22
	JPAParserT__22                   = 23
	JPAParserT__23                   = 24
	JPAParserT__24                   = 25
	JPAParserT__25                   = 26
	JPAParserT__26                   = 27
	JPAParserT__27                   = 28
	JPAParserT__28                   = 29
	JPAParserT__29                   = 30
	JPAParserT__30                   = 31
	JPAParserT__31                   = 32
	JPAParserT__32                   = 33
	JPAParserT__33                   = 34
	JPAParserT__34                   = 35
	JPAParserT__35                   = 36
	JPAParserT__36                   = 37
	JPAParserT__37                   = 38
	JPAParserT__38                   = 39
	JPAParserT__39                   = 40
	JPAParserT__40                   = 41
	JPAParserT__41                   = 42
	JPAParserT__42                   = 43
	JPAParserT__43                   = 44
	JPAParserT__44                   = 45
	JPAParserT__45                   = 46
	JPAParserT__46                   = 47
	JPAParserT__47                   = 48
	JPAParserT__48                   = 49
	JPAParserT__49                   = 50
	JPAParserT__50                   = 51
	JPAParserT__51                   = 52
	JPAParserT__52                   = 53
	JPAParserT__53                   = 54
	JPAParserT__54                   = 55
	JPAParserT__55                   = 56
	JPAParserT__56                   = 57
	JPAParserT__57                   = 58
	JPAParserT__58                   = 59
	JPAParserT__59                   = 60
	JPAParserT__60                   = 61
	JPAParserT__61                   = 62
	JPAParserT__62                   = 63
	JPAParserT__63                   = 64
	JPAParserT__64                   = 65
	JPAParserT__65                   = 66
	JPAParserT__66                   = 67
	JPAParserT__67                   = 68
	JPAParserT__68                   = 69
	JPAParserT__69                   = 70
	JPAParserT__70                   = 71
	JPAParserT__71                   = 72
	JPAParserT__72                   = 73
	JPAParserT__73                   = 74
	JPAParserT__74                   = 75
	JPAParserT__75                   = 76
	JPAParserT__76                   = 77
	JPAParserIDENTIFICATION_VARIABLE = 78
	JPAParserCHARACTER               = 79
	JPAParserSTRINGLITERAL           = 80
	JPAParserESCAPE_CHARACTER        = 81
	JPAParserWS                      = 82
	JPAParserTRIM_CHARACTER          = 83
	JPAParserINT_NUMERAL             = 84
)

// JPAParser rules.
const (
	JPAParserRULE_ql_statement                                   = 0
	JPAParserRULE_select_statement                               = 1
	JPAParserRULE_update_statement                               = 2
	JPAParserRULE_delete_statement                               = 3
	JPAParserRULE_from_clause                                    = 4
	JPAParserRULE_identification_variable_declaration            = 5
	JPAParserRULE_range_variable_declaration                     = 6
	JPAParserRULE_join                                           = 7
	JPAParserRULE_fetch_join                                     = 8
	JPAParserRULE_join_spec                                      = 9
	JPAParserRULE_join_association_path_expression               = 10
	JPAParserRULE_join_collection_valued_path_expression         = 11
	JPAParserRULE_join_single_valued_association_path_expression = 12
	JPAParserRULE_collection_member_declaration                  = 13
	JPAParserRULE_single_valued_path_expression                  = 14
	JPAParserRULE_state_field_path_expression                    = 15
	JPAParserRULE_single_valued_association_path_expression      = 16
	JPAParserRULE_collection_valued_path_expression              = 17
	JPAParserRULE_state_field                                    = 18
	JPAParserRULE_update_clause                                  = 19
	JPAParserRULE_update_item                                    = 20
	JPAParserRULE_new_value                                      = 21
	JPAParserRULE_delete_clause                                  = 22
	JPAParserRULE_select_clause                                  = 23
	JPAParserRULE_select_expression                              = 24
	JPAParserRULE_constructor_expression                         = 25
	JPAParserRULE_constructor_item                               = 26
	JPAParserRULE_aggregate_expression                           = 27
	JPAParserRULE_where_clause                                   = 28
	JPAParserRULE_groupby_clause                                 = 29
	JPAParserRULE_groupby_item                                   = 30
	JPAParserRULE_having_clause                                  = 31
	JPAParserRULE_orderby_clause                                 = 32
	JPAParserRULE_orderby_item                                   = 33
	JPAParserRULE_subquery                                       = 34
	JPAParserRULE_subquery_from_clause                           = 35
	JPAParserRULE_subselect_identification_variable_declaration  = 36
	JPAParserRULE_association_path_expression                    = 37
	JPAParserRULE_simple_select_clause                           = 38
	JPAParserRULE_simple_select_expression                       = 39
	JPAParserRULE_conditional_expression                         = 40
	JPAParserRULE_conditional_term                               = 41
	JPAParserRULE_conditional_factor                             = 42
	JPAParserRULE_conditional_primary                            = 43
	JPAParserRULE_simple_cond_expression                         = 44
	JPAParserRULE_between_expression                             = 45
	JPAParserRULE_in_expression                                  = 46
	JPAParserRULE_in_item                                        = 47
	JPAParserRULE_like_expression                                = 48
	JPAParserRULE_null_comparison_expression                     = 49
	JPAParserRULE_empty_collection_comparison_expression         = 50
	JPAParserRULE_collection_member_expression                   = 51
	JPAParserRULE_exists_expression                              = 52
	JPAParserRULE_all_or_any_expression                          = 53
	JPAParserRULE_comparison_expression                          = 54
	JPAParserRULE_comparison_operator                            = 55
	JPAParserRULE_arithmetic_expression                          = 56
	JPAParserRULE_simple_arithmetic_expression                   = 57
	JPAParserRULE_arithmetic_term                                = 58
	JPAParserRULE_arithmetic_factor                              = 59
	JPAParserRULE_arithmetic_primary                             = 60
	JPAParserRULE_string_expression                              = 61
	JPAParserRULE_string_primary                                 = 62
	JPAParserRULE_datetime_expression                            = 63
	JPAParserRULE_datetime_primary                               = 64
	JPAParserRULE_boolean_expression                             = 65
	JPAParserRULE_boolean_primary                                = 66
	JPAParserRULE_enum_expression                                = 67
	JPAParserRULE_enum_primary                                   = 68
	JPAParserRULE_entity_expression                              = 69
	JPAParserRULE_simple_entity_expression                       = 70
	JPAParserRULE_functions_returning_numerics                   = 71
	JPAParserRULE_functions_returning_datetime                   = 72
	JPAParserRULE_functions_returning_strings                    = 73
	JPAParserRULE_trim_specification                             = 74
	JPAParserRULE_numeric_literal                                = 75
	JPAParserRULE_pattern_value                                  = 76
	JPAParserRULE_input_parameter                                = 77
	JPAParserRULE_literal                                        = 78
	JPAParserRULE_constructor_name                               = 79
	JPAParserRULE_enum_literal                                   = 80
	JPAParserRULE_boolean_literal                                = 81
	JPAParserRULE_simple_state_field                             = 82
	JPAParserRULE_embedded_class_state_field                     = 83
	JPAParserRULE_single_valued_association_field                = 84
	JPAParserRULE_collection_valued_association_field            = 85
	JPAParserRULE_abstract_schema_name                           = 86
)

// IQl_statementContext is an interface to support dynamic dispatch.
type IQl_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQl_statementContext differentiates from other interfaces.
	IsQl_statementContext()
}

type Ql_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQl_statementContext() *Ql_statementContext {
	var p = new(Ql_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_ql_statement
	return p
}

func (*Ql_statementContext) IsQl_statementContext() {}

func NewQl_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Ql_statementContext {
	var p = new(Ql_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_ql_statement

	return p
}

func (s *Ql_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Ql_statementContext) Select_statement() ISelect_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelect_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelect_statementContext)
}

func (s *Ql_statementContext) Update_statement() IUpdate_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUpdate_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUpdate_statementContext)
}

func (s *Ql_statementContext) Delete_statement() IDelete_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelete_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelete_statementContext)
}

func (s *Ql_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ql_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Ql_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterQl_statement(s)
	}
}

func (s *Ql_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitQl_statement(s)
	}
}

func (s *Ql_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitQl_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Ql_statement() (localctx IQl_statementContext) {
	localctx = NewQl_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, JPAParserRULE_ql_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(177)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case JPAParserT__17:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(174)
			p.Select_statement()
		}

	case JPAParserT__12:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(175)
			p.Update_statement()
		}

	case JPAParserT__16:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(176)
			p.Delete_statement()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISelect_statementContext is an interface to support dynamic dispatch.
type ISelect_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelect_statementContext differentiates from other interfaces.
	IsSelect_statementContext()
}

type Select_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_statementContext() *Select_statementContext {
	var p = new(Select_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_select_statement
	return p
}

func (*Select_statementContext) IsSelect_statementContext() {}

func NewSelect_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_statementContext {
	var p = new(Select_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_select_statement

	return p
}

func (s *Select_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_statementContext) Select_clause() ISelect_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelect_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelect_clauseContext)
}

func (s *Select_statementContext) From_clause() IFrom_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFrom_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFrom_clauseContext)
}

func (s *Select_statementContext) Where_clause() IWhere_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhere_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWhere_clauseContext)
}

func (s *Select_statementContext) Groupby_clause() IGroupby_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroupby_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGroupby_clauseContext)
}

func (s *Select_statementContext) Having_clause() IHaving_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHaving_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHaving_clauseContext)
}

func (s *Select_statementContext) Orderby_clause() IOrderby_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOrderby_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOrderby_clauseContext)
}

func (s *Select_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Select_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterSelect_statement(s)
	}
}

func (s *Select_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitSelect_statement(s)
	}
}

func (s *Select_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitSelect_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Select_statement() (localctx ISelect_statementContext) {
	localctx = NewSelect_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, JPAParserRULE_select_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(179)
		p.Select_clause()
	}
	{
		p.SetState(180)
		p.From_clause()
	}
	p.SetState(182)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == JPAParserT__26 {
		{
			p.SetState(181)
			p.Where_clause()
		}

	}
	p.SetState(185)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == JPAParserT__27 {
		{
			p.SetState(184)
			p.Groupby_clause()
		}

	}
	p.SetState(188)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == JPAParserT__29 {
		{
			p.SetState(187)
			p.Having_clause()
		}

	}
	p.SetState(191)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == JPAParserT__30 {
		{
			p.SetState(190)
			p.Orderby_clause()
		}

	}

	return localctx
}

// IUpdate_statementContext is an interface to support dynamic dispatch.
type IUpdate_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUpdate_statementContext differentiates from other interfaces.
	IsUpdate_statementContext()
}

type Update_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUpdate_statementContext() *Update_statementContext {
	var p = new(Update_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_update_statement
	return p
}

func (*Update_statementContext) IsUpdate_statementContext() {}

func NewUpdate_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Update_statementContext {
	var p = new(Update_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_update_statement

	return p
}

func (s *Update_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Update_statementContext) Update_clause() IUpdate_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUpdate_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUpdate_clauseContext)
}

func (s *Update_statementContext) Where_clause() IWhere_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhere_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWhere_clauseContext)
}

func (s *Update_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Update_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Update_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterUpdate_statement(s)
	}
}

func (s *Update_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitUpdate_statement(s)
	}
}

func (s *Update_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitUpdate_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Update_statement() (localctx IUpdate_statementContext) {
	localctx = NewUpdate_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, JPAParserRULE_update_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(193)
		p.Update_clause()
	}
	p.SetState(195)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == JPAParserT__26 {
		{
			p.SetState(194)
			p.Where_clause()
		}

	}

	return localctx
}

// IDelete_statementContext is an interface to support dynamic dispatch.
type IDelete_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDelete_statementContext differentiates from other interfaces.
	IsDelete_statementContext()
}

type Delete_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDelete_statementContext() *Delete_statementContext {
	var p = new(Delete_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_delete_statement
	return p
}

func (*Delete_statementContext) IsDelete_statementContext() {}

func NewDelete_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Delete_statementContext {
	var p = new(Delete_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_delete_statement

	return p
}

func (s *Delete_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Delete_statementContext) Delete_clause() IDelete_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDelete_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDelete_clauseContext)
}

func (s *Delete_statementContext) Where_clause() IWhere_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhere_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWhere_clauseContext)
}

func (s *Delete_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Delete_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Delete_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterDelete_statement(s)
	}
}

func (s *Delete_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitDelete_statement(s)
	}
}

func (s *Delete_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitDelete_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Delete_statement() (localctx IDelete_statementContext) {
	localctx = NewDelete_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, JPAParserRULE_delete_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(197)
		p.Delete_clause()
	}
	p.SetState(199)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == JPAParserT__26 {
		{
			p.SetState(198)
			p.Where_clause()
		}

	}

	return localctx
}

// IFrom_clauseContext is an interface to support dynamic dispatch.
type IFrom_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFrom_clauseContext differentiates from other interfaces.
	IsFrom_clauseContext()
}

type From_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrom_clauseContext() *From_clauseContext {
	var p = new(From_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_from_clause
	return p
}

func (*From_clauseContext) IsFrom_clauseContext() {}

func NewFrom_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *From_clauseContext {
	var p = new(From_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_from_clause

	return p
}

func (s *From_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *From_clauseContext) AllIdentification_variable_declaration() []IIdentification_variable_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentification_variable_declarationContext)(nil)).Elem())
	var tst = make([]IIdentification_variable_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentification_variable_declarationContext)
		}
	}

	return tst
}

func (s *From_clauseContext) Identification_variable_declaration(i int) IIdentification_variable_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentification_variable_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentification_variable_declarationContext)
}

func (s *From_clauseContext) AllCollection_member_declaration() []ICollection_member_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICollection_member_declarationContext)(nil)).Elem())
	var tst = make([]ICollection_member_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICollection_member_declarationContext)
		}
	}

	return tst
}

func (s *From_clauseContext) Collection_member_declaration(i int) ICollection_member_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollection_member_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICollection_member_declarationContext)
}

func (s *From_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *From_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *From_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterFrom_clause(s)
	}
}

func (s *From_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitFrom_clause(s)
	}
}

func (s *From_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitFrom_clause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) From_clause() (localctx IFrom_clauseContext) {
	localctx = NewFrom_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, JPAParserRULE_from_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(201)
		p.Match(JPAParserT__0)
	}
	{
		p.SetState(202)
		p.Identification_variable_declaration()
	}
	p.SetState(210)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == JPAParserT__1 {
		{
			p.SetState(203)
			p.Match(JPAParserT__1)
		}
		p.SetState(206)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case JPAParserT__2, JPAParserIDENTIFICATION_VARIABLE:
			{
				p.SetState(204)
				p.Identification_variable_declaration()
			}

		case JPAParserT__9:
			{
				p.SetState(205)
				p.Collection_member_declaration()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(212)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IIdentification_variable_declarationContext is an interface to support dynamic dispatch.
type IIdentification_variable_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdentification_variable_declarationContext differentiates from other interfaces.
	IsIdentification_variable_declarationContext()
}

type Identification_variable_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentification_variable_declarationContext() *Identification_variable_declarationContext {
	var p = new(Identification_variable_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_identification_variable_declaration
	return p
}

func (*Identification_variable_declarationContext) IsIdentification_variable_declarationContext() {}

func NewIdentification_variable_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Identification_variable_declarationContext {
	var p = new(Identification_variable_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_identification_variable_declaration

	return p
}

func (s *Identification_variable_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Identification_variable_declarationContext) Range_variable_declaration() IRange_variable_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRange_variable_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRange_variable_declarationContext)
}

func (s *Identification_variable_declarationContext) AllJoin() []IJoinContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IJoinContext)(nil)).Elem())
	var tst = make([]IJoinContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IJoinContext)
		}
	}

	return tst
}

func (s *Identification_variable_declarationContext) Join(i int) IJoinContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJoinContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IJoinContext)
}

func (s *Identification_variable_declarationContext) AllFetch_join() []IFetch_joinContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFetch_joinContext)(nil)).Elem())
	var tst = make([]IFetch_joinContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFetch_joinContext)
		}
	}

	return tst
}

func (s *Identification_variable_declarationContext) Fetch_join(i int) IFetch_joinContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFetch_joinContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFetch_joinContext)
}

func (s *Identification_variable_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Identification_variable_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Identification_variable_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterIdentification_variable_declaration(s)
	}
}

func (s *Identification_variable_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitIdentification_variable_declaration(s)
	}
}

func (s *Identification_variable_declarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitIdentification_variable_declaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Identification_variable_declaration() (localctx IIdentification_variable_declarationContext) {
	localctx = NewIdentification_variable_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, JPAParserRULE_identification_variable_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(213)
		p.Range_variable_declaration()
	}
	p.SetState(218)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<JPAParserT__4)|(1<<JPAParserT__6)|(1<<JPAParserT__7))) != 0 {
		p.SetState(216)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 9, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(214)
				p.Join()
			}

		case 2:
			{
				p.SetState(215)
				p.Fetch_join()
			}

		}

		p.SetState(220)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IRange_variable_declarationContext is an interface to support dynamic dispatch.
type IRange_variable_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRange_variable_declarationContext differentiates from other interfaces.
	IsRange_variable_declarationContext()
}

type Range_variable_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRange_variable_declarationContext() *Range_variable_declarationContext {
	var p = new(Range_variable_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_range_variable_declaration
	return p
}

func (*Range_variable_declarationContext) IsRange_variable_declarationContext() {}

func NewRange_variable_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Range_variable_declarationContext {
	var p = new(Range_variable_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_range_variable_declaration

	return p
}

func (s *Range_variable_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Range_variable_declarationContext) Abstract_schema_name() IAbstract_schema_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAbstract_schema_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAbstract_schema_nameContext)
}

func (s *Range_variable_declarationContext) IDENTIFICATION_VARIABLE() antlr.TerminalNode {
	return s.GetToken(JPAParserIDENTIFICATION_VARIABLE, 0)
}

func (s *Range_variable_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Range_variable_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Range_variable_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterRange_variable_declaration(s)
	}
}

func (s *Range_variable_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitRange_variable_declaration(s)
	}
}

func (s *Range_variable_declarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitRange_variable_declaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Range_variable_declaration() (localctx IRange_variable_declarationContext) {
	localctx = NewRange_variable_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, JPAParserRULE_range_variable_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(221)
		p.Abstract_schema_name()
	}
	p.SetState(223)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == JPAParserT__2 {
		{
			p.SetState(222)
			p.Match(JPAParserT__2)
		}

	}
	{
		p.SetState(225)
		p.Match(JPAParserIDENTIFICATION_VARIABLE)
	}

	return localctx
}

// IJoinContext is an interface to support dynamic dispatch.
type IJoinContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsJoinContext differentiates from other interfaces.
	IsJoinContext()
}

type JoinContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinContext() *JoinContext {
	var p = new(JoinContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_join
	return p
}

func (*JoinContext) IsJoinContext() {}

func NewJoinContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinContext {
	var p = new(JoinContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_join

	return p
}

func (s *JoinContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinContext) Join_spec() IJoin_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJoin_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IJoin_specContext)
}

func (s *JoinContext) Join_association_path_expression() IJoin_association_path_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJoin_association_path_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IJoin_association_path_expressionContext)
}

func (s *JoinContext) IDENTIFICATION_VARIABLE() antlr.TerminalNode {
	return s.GetToken(JPAParserIDENTIFICATION_VARIABLE, 0)
}

func (s *JoinContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterJoin(s)
	}
}

func (s *JoinContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitJoin(s)
	}
}

func (s *JoinContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitJoin(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Join() (localctx IJoinContext) {
	localctx = NewJoinContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, JPAParserRULE_join)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(227)
		p.Join_spec()
	}
	{
		p.SetState(228)
		p.Join_association_path_expression()
	}
	p.SetState(230)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == JPAParserT__2 {
		{
			p.SetState(229)
			p.Match(JPAParserT__2)
		}

	}
	{
		p.SetState(232)
		p.Match(JPAParserIDENTIFICATION_VARIABLE)
	}

	return localctx
}

// IFetch_joinContext is an interface to support dynamic dispatch.
type IFetch_joinContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFetch_joinContext differentiates from other interfaces.
	IsFetch_joinContext()
}

type Fetch_joinContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFetch_joinContext() *Fetch_joinContext {
	var p = new(Fetch_joinContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_fetch_join
	return p
}

func (*Fetch_joinContext) IsFetch_joinContext() {}

func NewFetch_joinContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Fetch_joinContext {
	var p = new(Fetch_joinContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_fetch_join

	return p
}

func (s *Fetch_joinContext) GetParser() antlr.Parser { return s.parser }

func (s *Fetch_joinContext) Join_spec() IJoin_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJoin_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IJoin_specContext)
}

func (s *Fetch_joinContext) Join_association_path_expression() IJoin_association_path_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJoin_association_path_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IJoin_association_path_expressionContext)
}

func (s *Fetch_joinContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Fetch_joinContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Fetch_joinContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterFetch_join(s)
	}
}

func (s *Fetch_joinContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitFetch_join(s)
	}
}

func (s *Fetch_joinContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitFetch_join(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Fetch_join() (localctx IFetch_joinContext) {
	localctx = NewFetch_joinContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, JPAParserRULE_fetch_join)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(234)
		p.Join_spec()
	}
	{
		p.SetState(235)
		p.Match(JPAParserT__3)
	}
	{
		p.SetState(236)
		p.Join_association_path_expression()
	}

	return localctx
}

// IJoin_specContext is an interface to support dynamic dispatch.
type IJoin_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsJoin_specContext differentiates from other interfaces.
	IsJoin_specContext()
}

type Join_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoin_specContext() *Join_specContext {
	var p = new(Join_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_join_spec
	return p
}

func (*Join_specContext) IsJoin_specContext() {}

func NewJoin_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Join_specContext {
	var p = new(Join_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_join_spec

	return p
}

func (s *Join_specContext) GetParser() antlr.Parser { return s.parser }
func (s *Join_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Join_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Join_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterJoin_spec(s)
	}
}

func (s *Join_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitJoin_spec(s)
	}
}

func (s *Join_specContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitJoin_spec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Join_spec() (localctx IJoin_specContext) {
	localctx = NewJoin_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, JPAParserRULE_join_spec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(243)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case JPAParserT__4:
		{
			p.SetState(238)
			p.Match(JPAParserT__4)
		}

		p.SetState(240)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == JPAParserT__5 {
			{
				p.SetState(239)
				p.Match(JPAParserT__5)
			}

		}

	case JPAParserT__6:
		{
			p.SetState(242)
			p.Match(JPAParserT__6)
		}

	case JPAParserT__7:

	default:
	}
	{
		p.SetState(245)
		p.Match(JPAParserT__7)
	}

	return localctx
}

// IJoin_association_path_expressionContext is an interface to support dynamic dispatch.
type IJoin_association_path_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsJoin_association_path_expressionContext differentiates from other interfaces.
	IsJoin_association_path_expressionContext()
}

type Join_association_path_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoin_association_path_expressionContext() *Join_association_path_expressionContext {
	var p = new(Join_association_path_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_join_association_path_expression
	return p
}

func (*Join_association_path_expressionContext) IsJoin_association_path_expressionContext() {}

func NewJoin_association_path_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Join_association_path_expressionContext {
	var p = new(Join_association_path_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_join_association_path_expression

	return p
}

func (s *Join_association_path_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Join_association_path_expressionContext) Join_collection_valued_path_expression() IJoin_collection_valued_path_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJoin_collection_valued_path_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IJoin_collection_valued_path_expressionContext)
}

func (s *Join_association_path_expressionContext) Join_single_valued_association_path_expression() IJoin_single_valued_association_path_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJoin_single_valued_association_path_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IJoin_single_valued_association_path_expressionContext)
}

func (s *Join_association_path_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Join_association_path_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Join_association_path_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterJoin_association_path_expression(s)
	}
}

func (s *Join_association_path_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitJoin_association_path_expression(s)
	}
}

func (s *Join_association_path_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitJoin_association_path_expression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Join_association_path_expression() (localctx IJoin_association_path_expressionContext) {
	localctx = NewJoin_association_path_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, JPAParserRULE_join_association_path_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(249)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 15, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(247)
			p.Join_collection_valued_path_expression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(248)
			p.Join_single_valued_association_path_expression()
		}

	}

	return localctx
}

// IJoin_collection_valued_path_expressionContext is an interface to support dynamic dispatch.
type IJoin_collection_valued_path_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsJoin_collection_valued_path_expressionContext differentiates from other interfaces.
	IsJoin_collection_valued_path_expressionContext()
}

type Join_collection_valued_path_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoin_collection_valued_path_expressionContext() *Join_collection_valued_path_expressionContext {
	var p = new(Join_collection_valued_path_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_join_collection_valued_path_expression
	return p
}

func (*Join_collection_valued_path_expressionContext) IsJoin_collection_valued_path_expressionContext() {
}

func NewJoin_collection_valued_path_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Join_collection_valued_path_expressionContext {
	var p = new(Join_collection_valued_path_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_join_collection_valued_path_expression

	return p
}

func (s *Join_collection_valued_path_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Join_collection_valued_path_expressionContext) IDENTIFICATION_VARIABLE() antlr.TerminalNode {
	return s.GetToken(JPAParserIDENTIFICATION_VARIABLE, 0)
}

func (s *Join_collection_valued_path_expressionContext) Collection_valued_association_field() ICollection_valued_association_fieldContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollection_valued_association_fieldContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollection_valued_association_fieldContext)
}

func (s *Join_collection_valued_path_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Join_collection_valued_path_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Join_collection_valued_path_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterJoin_collection_valued_path_expression(s)
	}
}

func (s *Join_collection_valued_path_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitJoin_collection_valued_path_expression(s)
	}
}

func (s *Join_collection_valued_path_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitJoin_collection_valued_path_expression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Join_collection_valued_path_expression() (localctx IJoin_collection_valued_path_expressionContext) {
	localctx = NewJoin_collection_valued_path_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, JPAParserRULE_join_collection_valued_path_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(251)
		p.Match(JPAParserIDENTIFICATION_VARIABLE)
	}
	{
		p.SetState(252)
		p.Match(JPAParserT__8)
	}
	{
		p.SetState(253)
		p.Collection_valued_association_field()
	}

	return localctx
}

// IJoin_single_valued_association_path_expressionContext is an interface to support dynamic dispatch.
type IJoin_single_valued_association_path_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsJoin_single_valued_association_path_expressionContext differentiates from other interfaces.
	IsJoin_single_valued_association_path_expressionContext()
}

type Join_single_valued_association_path_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoin_single_valued_association_path_expressionContext() *Join_single_valued_association_path_expressionContext {
	var p = new(Join_single_valued_association_path_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_join_single_valued_association_path_expression
	return p
}

func (*Join_single_valued_association_path_expressionContext) IsJoin_single_valued_association_path_expressionContext() {
}

func NewJoin_single_valued_association_path_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Join_single_valued_association_path_expressionContext {
	var p = new(Join_single_valued_association_path_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_join_single_valued_association_path_expression

	return p
}

func (s *Join_single_valued_association_path_expressionContext) GetParser() antlr.Parser {
	return s.parser
}

func (s *Join_single_valued_association_path_expressionContext) IDENTIFICATION_VARIABLE() antlr.TerminalNode {
	return s.GetToken(JPAParserIDENTIFICATION_VARIABLE, 0)
}

func (s *Join_single_valued_association_path_expressionContext) Single_valued_association_field() ISingle_valued_association_fieldContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingle_valued_association_fieldContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingle_valued_association_fieldContext)
}

func (s *Join_single_valued_association_path_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Join_single_valued_association_path_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Join_single_valued_association_path_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterJoin_single_valued_association_path_expression(s)
	}
}

func (s *Join_single_valued_association_path_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitJoin_single_valued_association_path_expression(s)
	}
}

func (s *Join_single_valued_association_path_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitJoin_single_valued_association_path_expression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Join_single_valued_association_path_expression() (localctx IJoin_single_valued_association_path_expressionContext) {
	localctx = NewJoin_single_valued_association_path_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, JPAParserRULE_join_single_valued_association_path_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(255)
		p.Match(JPAParserIDENTIFICATION_VARIABLE)
	}
	{
		p.SetState(256)
		p.Match(JPAParserT__8)
	}
	{
		p.SetState(257)
		p.Single_valued_association_field()
	}

	return localctx
}

// ICollection_member_declarationContext is an interface to support dynamic dispatch.
type ICollection_member_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollection_member_declarationContext differentiates from other interfaces.
	IsCollection_member_declarationContext()
}

type Collection_member_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollection_member_declarationContext() *Collection_member_declarationContext {
	var p = new(Collection_member_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_collection_member_declaration
	return p
}

func (*Collection_member_declarationContext) IsCollection_member_declarationContext() {}

func NewCollection_member_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Collection_member_declarationContext {
	var p = new(Collection_member_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_collection_member_declaration

	return p
}

func (s *Collection_member_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Collection_member_declarationContext) Collection_valued_path_expression() ICollection_valued_path_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollection_valued_path_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollection_valued_path_expressionContext)
}

func (s *Collection_member_declarationContext) IDENTIFICATION_VARIABLE() antlr.TerminalNode {
	return s.GetToken(JPAParserIDENTIFICATION_VARIABLE, 0)
}

func (s *Collection_member_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Collection_member_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Collection_member_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterCollection_member_declaration(s)
	}
}

func (s *Collection_member_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitCollection_member_declaration(s)
	}
}

func (s *Collection_member_declarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitCollection_member_declaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Collection_member_declaration() (localctx ICollection_member_declarationContext) {
	localctx = NewCollection_member_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, JPAParserRULE_collection_member_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(259)
		p.Match(JPAParserT__9)
	}
	{
		p.SetState(260)
		p.Match(JPAParserT__10)
	}
	{
		p.SetState(261)
		p.Collection_valued_path_expression()
	}
	{
		p.SetState(262)
		p.Match(JPAParserT__11)
	}
	p.SetState(264)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == JPAParserT__2 {
		{
			p.SetState(263)
			p.Match(JPAParserT__2)
		}

	}
	{
		p.SetState(266)
		p.Match(JPAParserIDENTIFICATION_VARIABLE)
	}

	return localctx
}

// ISingle_valued_path_expressionContext is an interface to support dynamic dispatch.
type ISingle_valued_path_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSingle_valued_path_expressionContext differentiates from other interfaces.
	IsSingle_valued_path_expressionContext()
}

type Single_valued_path_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingle_valued_path_expressionContext() *Single_valued_path_expressionContext {
	var p = new(Single_valued_path_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_single_valued_path_expression
	return p
}

func (*Single_valued_path_expressionContext) IsSingle_valued_path_expressionContext() {}

func NewSingle_valued_path_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Single_valued_path_expressionContext {
	var p = new(Single_valued_path_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_single_valued_path_expression

	return p
}

func (s *Single_valued_path_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Single_valued_path_expressionContext) State_field_path_expression() IState_field_path_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IState_field_path_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IState_field_path_expressionContext)
}

func (s *Single_valued_path_expressionContext) Single_valued_association_path_expression() ISingle_valued_association_path_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingle_valued_association_path_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingle_valued_association_path_expressionContext)
}

func (s *Single_valued_path_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Single_valued_path_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Single_valued_path_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterSingle_valued_path_expression(s)
	}
}

func (s *Single_valued_path_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitSingle_valued_path_expression(s)
	}
}

func (s *Single_valued_path_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitSingle_valued_path_expression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Single_valued_path_expression() (localctx ISingle_valued_path_expressionContext) {
	localctx = NewSingle_valued_path_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, JPAParserRULE_single_valued_path_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(270)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 17, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(268)
			p.State_field_path_expression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(269)
			p.Single_valued_association_path_expression()
		}

	}

	return localctx
}

// IState_field_path_expressionContext is an interface to support dynamic dispatch.
type IState_field_path_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsState_field_path_expressionContext differentiates from other interfaces.
	IsState_field_path_expressionContext()
}

type State_field_path_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyState_field_path_expressionContext() *State_field_path_expressionContext {
	var p = new(State_field_path_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_state_field_path_expression
	return p
}

func (*State_field_path_expressionContext) IsState_field_path_expressionContext() {}

func NewState_field_path_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *State_field_path_expressionContext {
	var p = new(State_field_path_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_state_field_path_expression

	return p
}

func (s *State_field_path_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *State_field_path_expressionContext) State_field() IState_fieldContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IState_fieldContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IState_fieldContext)
}

func (s *State_field_path_expressionContext) IDENTIFICATION_VARIABLE() antlr.TerminalNode {
	return s.GetToken(JPAParserIDENTIFICATION_VARIABLE, 0)
}

func (s *State_field_path_expressionContext) Single_valued_association_path_expression() ISingle_valued_association_path_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingle_valued_association_path_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingle_valued_association_path_expressionContext)
}

func (s *State_field_path_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *State_field_path_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *State_field_path_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterState_field_path_expression(s)
	}
}

func (s *State_field_path_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitState_field_path_expression(s)
	}
}

func (s *State_field_path_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitState_field_path_expression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) State_field_path_expression() (localctx IState_field_path_expressionContext) {
	localctx = NewState_field_path_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, JPAParserRULE_state_field_path_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(274)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 18, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(272)
			p.Match(JPAParserIDENTIFICATION_VARIABLE)
		}

	case 2:
		{
			p.SetState(273)
			p.Single_valued_association_path_expression()
		}

	}
	{
		p.SetState(276)
		p.Match(JPAParserT__8)
	}
	{
		p.SetState(277)
		p.State_field()
	}

	return localctx
}

// ISingle_valued_association_path_expressionContext is an interface to support dynamic dispatch.
type ISingle_valued_association_path_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSingle_valued_association_path_expressionContext differentiates from other interfaces.
	IsSingle_valued_association_path_expressionContext()
}

type Single_valued_association_path_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingle_valued_association_path_expressionContext() *Single_valued_association_path_expressionContext {
	var p = new(Single_valued_association_path_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_single_valued_association_path_expression
	return p
}

func (*Single_valued_association_path_expressionContext) IsSingle_valued_association_path_expressionContext() {
}

func NewSingle_valued_association_path_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Single_valued_association_path_expressionContext {
	var p = new(Single_valued_association_path_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_single_valued_association_path_expression

	return p
}

func (s *Single_valued_association_path_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Single_valued_association_path_expressionContext) IDENTIFICATION_VARIABLE() antlr.TerminalNode {
	return s.GetToken(JPAParserIDENTIFICATION_VARIABLE, 0)
}

func (s *Single_valued_association_path_expressionContext) AllSingle_valued_association_field() []ISingle_valued_association_fieldContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISingle_valued_association_fieldContext)(nil)).Elem())
	var tst = make([]ISingle_valued_association_fieldContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISingle_valued_association_fieldContext)
		}
	}

	return tst
}

func (s *Single_valued_association_path_expressionContext) Single_valued_association_field(i int) ISingle_valued_association_fieldContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingle_valued_association_fieldContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISingle_valued_association_fieldContext)
}

func (s *Single_valued_association_path_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Single_valued_association_path_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Single_valued_association_path_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterSingle_valued_association_path_expression(s)
	}
}

func (s *Single_valued_association_path_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitSingle_valued_association_path_expression(s)
	}
}

func (s *Single_valued_association_path_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitSingle_valued_association_path_expression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Single_valued_association_path_expression() (localctx ISingle_valued_association_path_expressionContext) {
	localctx = NewSingle_valued_association_path_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, JPAParserRULE_single_valued_association_path_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(279)
		p.Match(JPAParserIDENTIFICATION_VARIABLE)
	}
	{
		p.SetState(280)
		p.Match(JPAParserT__8)
	}
	p.SetState(286)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 19, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(281)
				p.Single_valued_association_field()
			}
			{
				p.SetState(282)
				p.Match(JPAParserT__8)
			}

		}
		p.SetState(288)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 19, p.GetParserRuleContext())
	}
	{
		p.SetState(289)
		p.Single_valued_association_field()
	}

	return localctx
}

// ICollection_valued_path_expressionContext is an interface to support dynamic dispatch.
type ICollection_valued_path_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollection_valued_path_expressionContext differentiates from other interfaces.
	IsCollection_valued_path_expressionContext()
}

type Collection_valued_path_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollection_valued_path_expressionContext() *Collection_valued_path_expressionContext {
	var p = new(Collection_valued_path_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_collection_valued_path_expression
	return p
}

func (*Collection_valued_path_expressionContext) IsCollection_valued_path_expressionContext() {}

func NewCollection_valued_path_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Collection_valued_path_expressionContext {
	var p = new(Collection_valued_path_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_collection_valued_path_expression

	return p
}

func (s *Collection_valued_path_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Collection_valued_path_expressionContext) IDENTIFICATION_VARIABLE() antlr.TerminalNode {
	return s.GetToken(JPAParserIDENTIFICATION_VARIABLE, 0)
}

func (s *Collection_valued_path_expressionContext) Collection_valued_association_field() ICollection_valued_association_fieldContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollection_valued_association_fieldContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollection_valued_association_fieldContext)
}

func (s *Collection_valued_path_expressionContext) AllSingle_valued_association_field() []ISingle_valued_association_fieldContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISingle_valued_association_fieldContext)(nil)).Elem())
	var tst = make([]ISingle_valued_association_fieldContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISingle_valued_association_fieldContext)
		}
	}

	return tst
}

func (s *Collection_valued_path_expressionContext) Single_valued_association_field(i int) ISingle_valued_association_fieldContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingle_valued_association_fieldContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISingle_valued_association_fieldContext)
}

func (s *Collection_valued_path_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Collection_valued_path_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Collection_valued_path_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterCollection_valued_path_expression(s)
	}
}

func (s *Collection_valued_path_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitCollection_valued_path_expression(s)
	}
}

func (s *Collection_valued_path_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitCollection_valued_path_expression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Collection_valued_path_expression() (localctx ICollection_valued_path_expressionContext) {
	localctx = NewCollection_valued_path_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, JPAParserRULE_collection_valued_path_expression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(291)
		p.Match(JPAParserIDENTIFICATION_VARIABLE)
	}
	{
		p.SetState(292)
		p.Match(JPAParserT__8)
	}
	p.SetState(298)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == JPAParserT__8 {
		{
			p.SetState(293)
			p.Single_valued_association_field()
		}
		{
			p.SetState(294)
			p.Match(JPAParserT__8)
		}

		p.SetState(300)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(301)
		p.Collection_valued_association_field()
	}

	return localctx
}

// IState_fieldContext is an interface to support dynamic dispatch.
type IState_fieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsState_fieldContext differentiates from other interfaces.
	IsState_fieldContext()
}

type State_fieldContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyState_fieldContext() *State_fieldContext {
	var p = new(State_fieldContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_state_field
	return p
}

func (*State_fieldContext) IsState_fieldContext() {}

func NewState_fieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *State_fieldContext {
	var p = new(State_fieldContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_state_field

	return p
}

func (s *State_fieldContext) GetParser() antlr.Parser { return s.parser }

func (s *State_fieldContext) Simple_state_field() ISimple_state_fieldContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_state_fieldContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimple_state_fieldContext)
}

func (s *State_fieldContext) AllEmbedded_class_state_field() []IEmbedded_class_state_fieldContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEmbedded_class_state_fieldContext)(nil)).Elem())
	var tst = make([]IEmbedded_class_state_fieldContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEmbedded_class_state_fieldContext)
		}
	}

	return tst
}

func (s *State_fieldContext) Embedded_class_state_field(i int) IEmbedded_class_state_fieldContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEmbedded_class_state_fieldContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEmbedded_class_state_fieldContext)
}

func (s *State_fieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *State_fieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *State_fieldContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterState_field(s)
	}
}

func (s *State_fieldContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitState_field(s)
	}
}

func (s *State_fieldContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitState_field(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) State_field() (localctx IState_fieldContext) {
	localctx = NewState_fieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, JPAParserRULE_state_field)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(308)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == JPAParserT__8 {
		{
			p.SetState(303)
			p.Embedded_class_state_field()
		}
		{
			p.SetState(304)
			p.Match(JPAParserT__8)
		}

		p.SetState(310)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(311)
		p.Simple_state_field()
	}

	return localctx
}

// IUpdate_clauseContext is an interface to support dynamic dispatch.
type IUpdate_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUpdate_clauseContext differentiates from other interfaces.
	IsUpdate_clauseContext()
}

type Update_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUpdate_clauseContext() *Update_clauseContext {
	var p = new(Update_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_update_clause
	return p
}

func (*Update_clauseContext) IsUpdate_clauseContext() {}

func NewUpdate_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Update_clauseContext {
	var p = new(Update_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_update_clause

	return p
}

func (s *Update_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Update_clauseContext) Abstract_schema_name() IAbstract_schema_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAbstract_schema_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAbstract_schema_nameContext)
}

func (s *Update_clauseContext) AllUpdate_item() []IUpdate_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IUpdate_itemContext)(nil)).Elem())
	var tst = make([]IUpdate_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IUpdate_itemContext)
		}
	}

	return tst
}

func (s *Update_clauseContext) Update_item(i int) IUpdate_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUpdate_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IUpdate_itemContext)
}

func (s *Update_clauseContext) IDENTIFICATION_VARIABLE() antlr.TerminalNode {
	return s.GetToken(JPAParserIDENTIFICATION_VARIABLE, 0)
}

func (s *Update_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Update_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Update_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterUpdate_clause(s)
	}
}

func (s *Update_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitUpdate_clause(s)
	}
}

func (s *Update_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitUpdate_clause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Update_clause() (localctx IUpdate_clauseContext) {
	localctx = NewUpdate_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, JPAParserRULE_update_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(313)
		p.Match(JPAParserT__12)
	}
	{
		p.SetState(314)
		p.Abstract_schema_name()
	}
	p.SetState(319)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == JPAParserT__2 || _la == JPAParserIDENTIFICATION_VARIABLE {
		p.SetState(316)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == JPAParserT__2 {
			{
				p.SetState(315)
				p.Match(JPAParserT__2)
			}

		}
		{
			p.SetState(318)
			p.Match(JPAParserIDENTIFICATION_VARIABLE)
		}

	}
	{
		p.SetState(321)
		p.Match(JPAParserT__13)
	}
	{
		p.SetState(322)
		p.Update_item()
	}
	p.SetState(327)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == JPAParserT__1 {
		{
			p.SetState(323)
			p.Match(JPAParserT__1)
		}
		{
			p.SetState(324)
			p.Update_item()
		}

		p.SetState(329)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IUpdate_itemContext is an interface to support dynamic dispatch.
type IUpdate_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUpdate_itemContext differentiates from other interfaces.
	IsUpdate_itemContext()
}

type Update_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUpdate_itemContext() *Update_itemContext {
	var p = new(Update_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_update_item
	return p
}

func (*Update_itemContext) IsUpdate_itemContext() {}

func NewUpdate_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Update_itemContext {
	var p = new(Update_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_update_item

	return p
}

func (s *Update_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Update_itemContext) New_value() INew_valueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INew_valueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INew_valueContext)
}

func (s *Update_itemContext) State_field() IState_fieldContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IState_fieldContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IState_fieldContext)
}

func (s *Update_itemContext) Single_valued_association_field() ISingle_valued_association_fieldContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingle_valued_association_fieldContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingle_valued_association_fieldContext)
}

func (s *Update_itemContext) IDENTIFICATION_VARIABLE() antlr.TerminalNode {
	return s.GetToken(JPAParserIDENTIFICATION_VARIABLE, 0)
}

func (s *Update_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Update_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Update_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterUpdate_item(s)
	}
}

func (s *Update_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitUpdate_item(s)
	}
}

func (s *Update_itemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitUpdate_item(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Update_item() (localctx IUpdate_itemContext) {
	localctx = NewUpdate_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, JPAParserRULE_update_item)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(332)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == JPAParserIDENTIFICATION_VARIABLE {
		{
			p.SetState(330)
			p.Match(JPAParserIDENTIFICATION_VARIABLE)
		}
		{
			p.SetState(331)
			p.Match(JPAParserT__8)
		}

	}
	p.SetState(336)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 26, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(334)
			p.State_field()
		}

	case 2:
		{
			p.SetState(335)
			p.Single_valued_association_field()
		}

	}
	{
		p.SetState(338)
		p.Match(JPAParserT__14)
	}
	{
		p.SetState(339)
		p.New_value()
	}

	return localctx
}

// INew_valueContext is an interface to support dynamic dispatch.
type INew_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNew_valueContext differentiates from other interfaces.
	IsNew_valueContext()
}

type New_valueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNew_valueContext() *New_valueContext {
	var p = new(New_valueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_new_value
	return p
}

func (*New_valueContext) IsNew_valueContext() {}

func NewNew_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *New_valueContext {
	var p = new(New_valueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_new_value

	return p
}

func (s *New_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *New_valueContext) Simple_arithmetic_expression() ISimple_arithmetic_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_arithmetic_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimple_arithmetic_expressionContext)
}

func (s *New_valueContext) String_primary() IString_primaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IString_primaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IString_primaryContext)
}

func (s *New_valueContext) Datetime_primary() IDatetime_primaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDatetime_primaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDatetime_primaryContext)
}

func (s *New_valueContext) Boolean_primary() IBoolean_primaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBoolean_primaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBoolean_primaryContext)
}

func (s *New_valueContext) Enum_primary() IEnum_primaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnum_primaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnum_primaryContext)
}

func (s *New_valueContext) Simple_entity_expression() ISimple_entity_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_entity_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimple_entity_expressionContext)
}

func (s *New_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *New_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *New_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterNew_value(s)
	}
}

func (s *New_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitNew_value(s)
	}
}

func (s *New_valueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitNew_value(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) New_value() (localctx INew_valueContext) {
	localctx = NewNew_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, JPAParserRULE_new_value)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(348)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 27, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(341)
			p.Simple_arithmetic_expression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(342)
			p.String_primary()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(343)
			p.Datetime_primary()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(344)
			p.Boolean_primary()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(345)
			p.Enum_primary()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(346)
			p.Simple_entity_expression()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(347)
			p.Match(JPAParserT__15)
		}

	}

	return localctx
}

// IDelete_clauseContext is an interface to support dynamic dispatch.
type IDelete_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDelete_clauseContext differentiates from other interfaces.
	IsDelete_clauseContext()
}

type Delete_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDelete_clauseContext() *Delete_clauseContext {
	var p = new(Delete_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_delete_clause
	return p
}

func (*Delete_clauseContext) IsDelete_clauseContext() {}

func NewDelete_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Delete_clauseContext {
	var p = new(Delete_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_delete_clause

	return p
}

func (s *Delete_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Delete_clauseContext) Abstract_schema_name() IAbstract_schema_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAbstract_schema_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAbstract_schema_nameContext)
}

func (s *Delete_clauseContext) IDENTIFICATION_VARIABLE() antlr.TerminalNode {
	return s.GetToken(JPAParserIDENTIFICATION_VARIABLE, 0)
}

func (s *Delete_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Delete_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Delete_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterDelete_clause(s)
	}
}

func (s *Delete_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitDelete_clause(s)
	}
}

func (s *Delete_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitDelete_clause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Delete_clause() (localctx IDelete_clauseContext) {
	localctx = NewDelete_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, JPAParserRULE_delete_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(350)
		p.Match(JPAParserT__16)
	}
	{
		p.SetState(351)
		p.Match(JPAParserT__0)
	}
	{
		p.SetState(352)
		p.Abstract_schema_name()
	}
	p.SetState(357)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == JPAParserT__2 || _la == JPAParserIDENTIFICATION_VARIABLE {
		p.SetState(354)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == JPAParserT__2 {
			{
				p.SetState(353)
				p.Match(JPAParserT__2)
			}

		}
		{
			p.SetState(356)
			p.Match(JPAParserIDENTIFICATION_VARIABLE)
		}

	}

	return localctx
}

// ISelect_clauseContext is an interface to support dynamic dispatch.
type ISelect_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelect_clauseContext differentiates from other interfaces.
	IsSelect_clauseContext()
}

type Select_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_clauseContext() *Select_clauseContext {
	var p = new(Select_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_select_clause
	return p
}

func (*Select_clauseContext) IsSelect_clauseContext() {}

func NewSelect_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_clauseContext {
	var p = new(Select_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_select_clause

	return p
}

func (s *Select_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_clauseContext) AllSelect_expression() []ISelect_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISelect_expressionContext)(nil)).Elem())
	var tst = make([]ISelect_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISelect_expressionContext)
		}
	}

	return tst
}

func (s *Select_clauseContext) Select_expression(i int) ISelect_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelect_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISelect_expressionContext)
}

func (s *Select_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Select_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterSelect_clause(s)
	}
}

func (s *Select_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitSelect_clause(s)
	}
}

func (s *Select_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitSelect_clause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Select_clause() (localctx ISelect_clauseContext) {
	localctx = NewSelect_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, JPAParserRULE_select_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(359)
		p.Match(JPAParserT__17)
	}
	p.SetState(361)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == JPAParserT__18 {
		{
			p.SetState(360)
			p.Match(JPAParserT__18)
		}

	}
	{
		p.SetState(363)
		p.Select_expression()
	}
	p.SetState(368)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == JPAParserT__1 {
		{
			p.SetState(364)
			p.Match(JPAParserT__1)
		}
		{
			p.SetState(365)
			p.Select_expression()
		}

		p.SetState(370)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISelect_expressionContext is an interface to support dynamic dispatch.
type ISelect_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelect_expressionContext differentiates from other interfaces.
	IsSelect_expressionContext()
}

type Select_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_expressionContext() *Select_expressionContext {
	var p = new(Select_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_select_expression
	return p
}

func (*Select_expressionContext) IsSelect_expressionContext() {}

func NewSelect_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_expressionContext {
	var p = new(Select_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_select_expression

	return p
}

func (s *Select_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_expressionContext) Single_valued_path_expression() ISingle_valued_path_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingle_valued_path_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingle_valued_path_expressionContext)
}

func (s *Select_expressionContext) Aggregate_expression() IAggregate_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAggregate_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAggregate_expressionContext)
}

func (s *Select_expressionContext) IDENTIFICATION_VARIABLE() antlr.TerminalNode {
	return s.GetToken(JPAParserIDENTIFICATION_VARIABLE, 0)
}

func (s *Select_expressionContext) Constructor_expression() IConstructor_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstructor_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstructor_expressionContext)
}

func (s *Select_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Select_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterSelect_expression(s)
	}
}

func (s *Select_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitSelect_expression(s)
	}
}

func (s *Select_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitSelect_expression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Select_expression() (localctx ISelect_expressionContext) {
	localctx = NewSelect_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, JPAParserRULE_select_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(379)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 32, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(371)
			p.Single_valued_path_expression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(372)
			p.Aggregate_expression()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(373)
			p.Match(JPAParserIDENTIFICATION_VARIABLE)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(374)
			p.Match(JPAParserT__19)
		}
		{
			p.SetState(375)
			p.Match(JPAParserT__10)
		}
		{
			p.SetState(376)
			p.Match(JPAParserIDENTIFICATION_VARIABLE)
		}
		{
			p.SetState(377)
			p.Match(JPAParserT__11)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(378)
			p.Constructor_expression()
		}

	}

	return localctx
}

// IConstructor_expressionContext is an interface to support dynamic dispatch.
type IConstructor_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstructor_expressionContext differentiates from other interfaces.
	IsConstructor_expressionContext()
}

type Constructor_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstructor_expressionContext() *Constructor_expressionContext {
	var p = new(Constructor_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_constructor_expression
	return p
}

func (*Constructor_expressionContext) IsConstructor_expressionContext() {}

func NewConstructor_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constructor_expressionContext {
	var p = new(Constructor_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_constructor_expression

	return p
}

func (s *Constructor_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Constructor_expressionContext) Constructor_name() IConstructor_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstructor_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstructor_nameContext)
}

func (s *Constructor_expressionContext) AllConstructor_item() []IConstructor_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConstructor_itemContext)(nil)).Elem())
	var tst = make([]IConstructor_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConstructor_itemContext)
		}
	}

	return tst
}

func (s *Constructor_expressionContext) Constructor_item(i int) IConstructor_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstructor_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConstructor_itemContext)
}

func (s *Constructor_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constructor_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constructor_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterConstructor_expression(s)
	}
}

func (s *Constructor_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitConstructor_expression(s)
	}
}

func (s *Constructor_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitConstructor_expression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Constructor_expression() (localctx IConstructor_expressionContext) {
	localctx = NewConstructor_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, JPAParserRULE_constructor_expression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(381)
		p.Match(JPAParserT__20)
	}
	{
		p.SetState(382)
		p.Constructor_name()
	}
	{
		p.SetState(383)
		p.Match(JPAParserT__10)
	}
	{
		p.SetState(384)
		p.Constructor_item()
	}
	p.SetState(389)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == JPAParserT__1 {
		{
			p.SetState(385)
			p.Match(JPAParserT__1)
		}
		{
			p.SetState(386)
			p.Constructor_item()
		}

		p.SetState(391)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(392)
		p.Match(JPAParserT__11)
	}

	return localctx
}

// IConstructor_itemContext is an interface to support dynamic dispatch.
type IConstructor_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstructor_itemContext differentiates from other interfaces.
	IsConstructor_itemContext()
}

type Constructor_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstructor_itemContext() *Constructor_itemContext {
	var p = new(Constructor_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_constructor_item
	return p
}

func (*Constructor_itemContext) IsConstructor_itemContext() {}

func NewConstructor_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constructor_itemContext {
	var p = new(Constructor_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_constructor_item

	return p
}

func (s *Constructor_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Constructor_itemContext) Single_valued_path_expression() ISingle_valued_path_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingle_valued_path_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingle_valued_path_expressionContext)
}

func (s *Constructor_itemContext) Aggregate_expression() IAggregate_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAggregate_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAggregate_expressionContext)
}

func (s *Constructor_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constructor_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constructor_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterConstructor_item(s)
	}
}

func (s *Constructor_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitConstructor_item(s)
	}
}

func (s *Constructor_itemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitConstructor_item(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Constructor_item() (localctx IConstructor_itemContext) {
	localctx = NewConstructor_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, JPAParserRULE_constructor_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(396)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case JPAParserIDENTIFICATION_VARIABLE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(394)
			p.Single_valued_path_expression()
		}

	case JPAParserT__21, JPAParserT__22, JPAParserT__23, JPAParserT__24, JPAParserT__25:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(395)
			p.Aggregate_expression()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAggregate_expressionContext is an interface to support dynamic dispatch.
type IAggregate_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAggregate_expressionContext differentiates from other interfaces.
	IsAggregate_expressionContext()
}

type Aggregate_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAggregate_expressionContext() *Aggregate_expressionContext {
	var p = new(Aggregate_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_aggregate_expression
	return p
}

func (*Aggregate_expressionContext) IsAggregate_expressionContext() {}

func NewAggregate_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Aggregate_expressionContext {
	var p = new(Aggregate_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_aggregate_expression

	return p
}

func (s *Aggregate_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Aggregate_expressionContext) State_field_path_expression() IState_field_path_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IState_field_path_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IState_field_path_expressionContext)
}

func (s *Aggregate_expressionContext) IDENTIFICATION_VARIABLE() antlr.TerminalNode {
	return s.GetToken(JPAParserIDENTIFICATION_VARIABLE, 0)
}

func (s *Aggregate_expressionContext) Single_valued_association_path_expression() ISingle_valued_association_path_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingle_valued_association_path_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingle_valued_association_path_expressionContext)
}

func (s *Aggregate_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Aggregate_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Aggregate_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterAggregate_expression(s)
	}
}

func (s *Aggregate_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitAggregate_expression(s)
	}
}

func (s *Aggregate_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitAggregate_expression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Aggregate_expression() (localctx IAggregate_expressionContext) {
	localctx = NewAggregate_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, JPAParserRULE_aggregate_expression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(417)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case JPAParserT__21, JPAParserT__22, JPAParserT__23, JPAParserT__24:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(398)
		_la = p.GetTokenStream().LA(1)

		if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<JPAParserT__21)|(1<<JPAParserT__22)|(1<<JPAParserT__23)|(1<<JPAParserT__24))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
		{
			p.SetState(399)
			p.Match(JPAParserT__10)
		}
		p.SetState(401)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == JPAParserT__18 {
			{
				p.SetState(400)
				p.Match(JPAParserT__18)
			}

		}
		{
			p.SetState(403)
			p.State_field_path_expression()
		}
		{
			p.SetState(404)
			p.Match(JPAParserT__11)
		}

	case JPAParserT__25:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(406)
			p.Match(JPAParserT__25)
		}
		{
			p.SetState(407)
			p.Match(JPAParserT__10)
		}
		p.SetState(409)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == JPAParserT__18 {
			{
				p.SetState(408)
				p.Match(JPAParserT__18)
			}

		}
		p.SetState(414)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 37, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(411)
				p.Match(JPAParserIDENTIFICATION_VARIABLE)
			}

		case 2:
			{
				p.SetState(412)
				p.State_field_path_expression()
			}

		case 3:
			{
				p.SetState(413)
				p.Single_valued_association_path_expression()
			}

		}
		{
			p.SetState(416)
			p.Match(JPAParserT__11)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IWhere_clauseContext is an interface to support dynamic dispatch.
type IWhere_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWhere_clauseContext differentiates from other interfaces.
	IsWhere_clauseContext()
}

type Where_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhere_clauseContext() *Where_clauseContext {
	var p = new(Where_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_where_clause
	return p
}

func (*Where_clauseContext) IsWhere_clauseContext() {}

func NewWhere_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Where_clauseContext {
	var p = new(Where_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_where_clause

	return p
}

func (s *Where_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Where_clauseContext) Conditional_expression() IConditional_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditional_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditional_expressionContext)
}

func (s *Where_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Where_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Where_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterWhere_clause(s)
	}
}

func (s *Where_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitWhere_clause(s)
	}
}

func (s *Where_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitWhere_clause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Where_clause() (localctx IWhere_clauseContext) {
	localctx = NewWhere_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, JPAParserRULE_where_clause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(419)
		p.Match(JPAParserT__26)
	}
	{
		p.SetState(420)
		p.Conditional_expression()
	}

	return localctx
}

// IGroupby_clauseContext is an interface to support dynamic dispatch.
type IGroupby_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGroupby_clauseContext differentiates from other interfaces.
	IsGroupby_clauseContext()
}

type Groupby_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupby_clauseContext() *Groupby_clauseContext {
	var p = new(Groupby_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_groupby_clause
	return p
}

func (*Groupby_clauseContext) IsGroupby_clauseContext() {}

func NewGroupby_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Groupby_clauseContext {
	var p = new(Groupby_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_groupby_clause

	return p
}

func (s *Groupby_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Groupby_clauseContext) AllGroupby_item() []IGroupby_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IGroupby_itemContext)(nil)).Elem())
	var tst = make([]IGroupby_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IGroupby_itemContext)
		}
	}

	return tst
}

func (s *Groupby_clauseContext) Groupby_item(i int) IGroupby_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroupby_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IGroupby_itemContext)
}

func (s *Groupby_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Groupby_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Groupby_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterGroupby_clause(s)
	}
}

func (s *Groupby_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitGroupby_clause(s)
	}
}

func (s *Groupby_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitGroupby_clause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Groupby_clause() (localctx IGroupby_clauseContext) {
	localctx = NewGroupby_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, JPAParserRULE_groupby_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(422)
		p.Match(JPAParserT__27)
	}
	{
		p.SetState(423)
		p.Match(JPAParserT__28)
	}
	{
		p.SetState(424)
		p.Groupby_item()
	}
	p.SetState(429)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == JPAParserT__1 {
		{
			p.SetState(425)
			p.Match(JPAParserT__1)
		}
		{
			p.SetState(426)
			p.Groupby_item()
		}

		p.SetState(431)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IGroupby_itemContext is an interface to support dynamic dispatch.
type IGroupby_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGroupby_itemContext differentiates from other interfaces.
	IsGroupby_itemContext()
}

type Groupby_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupby_itemContext() *Groupby_itemContext {
	var p = new(Groupby_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_groupby_item
	return p
}

func (*Groupby_itemContext) IsGroupby_itemContext() {}

func NewGroupby_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Groupby_itemContext {
	var p = new(Groupby_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_groupby_item

	return p
}

func (s *Groupby_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Groupby_itemContext) Single_valued_path_expression() ISingle_valued_path_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingle_valued_path_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingle_valued_path_expressionContext)
}

func (s *Groupby_itemContext) IDENTIFICATION_VARIABLE() antlr.TerminalNode {
	return s.GetToken(JPAParserIDENTIFICATION_VARIABLE, 0)
}

func (s *Groupby_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Groupby_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Groupby_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterGroupby_item(s)
	}
}

func (s *Groupby_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitGroupby_item(s)
	}
}

func (s *Groupby_itemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitGroupby_item(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Groupby_item() (localctx IGroupby_itemContext) {
	localctx = NewGroupby_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, JPAParserRULE_groupby_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(434)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 40, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(432)
			p.Single_valued_path_expression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(433)
			p.Match(JPAParserIDENTIFICATION_VARIABLE)
		}

	}

	return localctx
}

// IHaving_clauseContext is an interface to support dynamic dispatch.
type IHaving_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHaving_clauseContext differentiates from other interfaces.
	IsHaving_clauseContext()
}

type Having_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHaving_clauseContext() *Having_clauseContext {
	var p = new(Having_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_having_clause
	return p
}

func (*Having_clauseContext) IsHaving_clauseContext() {}

func NewHaving_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Having_clauseContext {
	var p = new(Having_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_having_clause

	return p
}

func (s *Having_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Having_clauseContext) Conditional_expression() IConditional_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditional_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditional_expressionContext)
}

func (s *Having_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Having_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Having_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterHaving_clause(s)
	}
}

func (s *Having_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitHaving_clause(s)
	}
}

func (s *Having_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitHaving_clause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Having_clause() (localctx IHaving_clauseContext) {
	localctx = NewHaving_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, JPAParserRULE_having_clause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(436)
		p.Match(JPAParserT__29)
	}
	{
		p.SetState(437)
		p.Conditional_expression()
	}

	return localctx
}

// IOrderby_clauseContext is an interface to support dynamic dispatch.
type IOrderby_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOrderby_clauseContext differentiates from other interfaces.
	IsOrderby_clauseContext()
}

type Orderby_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrderby_clauseContext() *Orderby_clauseContext {
	var p = new(Orderby_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_orderby_clause
	return p
}

func (*Orderby_clauseContext) IsOrderby_clauseContext() {}

func NewOrderby_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Orderby_clauseContext {
	var p = new(Orderby_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_orderby_clause

	return p
}

func (s *Orderby_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Orderby_clauseContext) AllOrderby_item() []IOrderby_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOrderby_itemContext)(nil)).Elem())
	var tst = make([]IOrderby_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOrderby_itemContext)
		}
	}

	return tst
}

func (s *Orderby_clauseContext) Orderby_item(i int) IOrderby_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOrderby_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOrderby_itemContext)
}

func (s *Orderby_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Orderby_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Orderby_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterOrderby_clause(s)
	}
}

func (s *Orderby_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitOrderby_clause(s)
	}
}

func (s *Orderby_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitOrderby_clause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Orderby_clause() (localctx IOrderby_clauseContext) {
	localctx = NewOrderby_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, JPAParserRULE_orderby_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(439)
		p.Match(JPAParserT__30)
	}
	{
		p.SetState(440)
		p.Match(JPAParserT__28)
	}
	{
		p.SetState(441)
		p.Orderby_item()
	}
	p.SetState(446)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == JPAParserT__1 {
		{
			p.SetState(442)
			p.Match(JPAParserT__1)
		}
		{
			p.SetState(443)
			p.Orderby_item()
		}

		p.SetState(448)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IOrderby_itemContext is an interface to support dynamic dispatch.
type IOrderby_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOrderby_itemContext differentiates from other interfaces.
	IsOrderby_itemContext()
}

type Orderby_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrderby_itemContext() *Orderby_itemContext {
	var p = new(Orderby_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_orderby_item
	return p
}

func (*Orderby_itemContext) IsOrderby_itemContext() {}

func NewOrderby_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Orderby_itemContext {
	var p = new(Orderby_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_orderby_item

	return p
}

func (s *Orderby_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Orderby_itemContext) State_field_path_expression() IState_field_path_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IState_field_path_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IState_field_path_expressionContext)
}

func (s *Orderby_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Orderby_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Orderby_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterOrderby_item(s)
	}
}

func (s *Orderby_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitOrderby_item(s)
	}
}

func (s *Orderby_itemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitOrderby_item(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Orderby_item() (localctx IOrderby_itemContext) {
	localctx = NewOrderby_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, JPAParserRULE_orderby_item)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(449)
		p.State_field_path_expression()
	}
	p.SetState(451)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == JPAParserT__31 || _la == JPAParserT__32 {
		p.SetState(450)
		_la = p.GetTokenStream().LA(1)

		if !(_la == JPAParserT__31 || _la == JPAParserT__32) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}

	}

	return localctx
}

// ISubqueryContext is an interface to support dynamic dispatch.
type ISubqueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubqueryContext differentiates from other interfaces.
	IsSubqueryContext()
}

type SubqueryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubqueryContext() *SubqueryContext {
	var p = new(SubqueryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_subquery
	return p
}

func (*SubqueryContext) IsSubqueryContext() {}

func NewSubqueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubqueryContext {
	var p = new(SubqueryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_subquery

	return p
}

func (s *SubqueryContext) GetParser() antlr.Parser { return s.parser }

func (s *SubqueryContext) Simple_select_clause() ISimple_select_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_select_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimple_select_clauseContext)
}

func (s *SubqueryContext) Subquery_from_clause() ISubquery_from_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubquery_from_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubquery_from_clauseContext)
}

func (s *SubqueryContext) Where_clause() IWhere_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhere_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWhere_clauseContext)
}

func (s *SubqueryContext) Groupby_clause() IGroupby_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroupby_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGroupby_clauseContext)
}

func (s *SubqueryContext) Having_clause() IHaving_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHaving_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHaving_clauseContext)
}

func (s *SubqueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubqueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubqueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterSubquery(s)
	}
}

func (s *SubqueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitSubquery(s)
	}
}

func (s *SubqueryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitSubquery(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Subquery() (localctx ISubqueryContext) {
	localctx = NewSubqueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, JPAParserRULE_subquery)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(453)
		p.Simple_select_clause()
	}
	{
		p.SetState(454)
		p.Subquery_from_clause()
	}
	p.SetState(456)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == JPAParserT__26 {
		{
			p.SetState(455)
			p.Where_clause()
		}

	}
	p.SetState(459)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == JPAParserT__27 {
		{
			p.SetState(458)
			p.Groupby_clause()
		}

	}
	p.SetState(462)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == JPAParserT__29 {
		{
			p.SetState(461)
			p.Having_clause()
		}

	}

	return localctx
}

// ISubquery_from_clauseContext is an interface to support dynamic dispatch.
type ISubquery_from_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubquery_from_clauseContext differentiates from other interfaces.
	IsSubquery_from_clauseContext()
}

type Subquery_from_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubquery_from_clauseContext() *Subquery_from_clauseContext {
	var p = new(Subquery_from_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_subquery_from_clause
	return p
}

func (*Subquery_from_clauseContext) IsSubquery_from_clauseContext() {}

func NewSubquery_from_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Subquery_from_clauseContext {
	var p = new(Subquery_from_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_subquery_from_clause

	return p
}

func (s *Subquery_from_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Subquery_from_clauseContext) AllSubselect_identification_variable_declaration() []ISubselect_identification_variable_declarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISubselect_identification_variable_declarationContext)(nil)).Elem())
	var tst = make([]ISubselect_identification_variable_declarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISubselect_identification_variable_declarationContext)
		}
	}

	return tst
}

func (s *Subquery_from_clauseContext) Subselect_identification_variable_declaration(i int) ISubselect_identification_variable_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubselect_identification_variable_declarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISubselect_identification_variable_declarationContext)
}

func (s *Subquery_from_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Subquery_from_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Subquery_from_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterSubquery_from_clause(s)
	}
}

func (s *Subquery_from_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitSubquery_from_clause(s)
	}
}

func (s *Subquery_from_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitSubquery_from_clause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Subquery_from_clause() (localctx ISubquery_from_clauseContext) {
	localctx = NewSubquery_from_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, JPAParserRULE_subquery_from_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(464)
		p.Match(JPAParserT__0)
	}
	{
		p.SetState(465)
		p.Subselect_identification_variable_declaration()
	}
	p.SetState(470)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == JPAParserT__1 {
		{
			p.SetState(466)
			p.Match(JPAParserT__1)
		}
		{
			p.SetState(467)
			p.Subselect_identification_variable_declaration()
		}

		p.SetState(472)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISubselect_identification_variable_declarationContext is an interface to support dynamic dispatch.
type ISubselect_identification_variable_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubselect_identification_variable_declarationContext differentiates from other interfaces.
	IsSubselect_identification_variable_declarationContext()
}

type Subselect_identification_variable_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubselect_identification_variable_declarationContext() *Subselect_identification_variable_declarationContext {
	var p = new(Subselect_identification_variable_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_subselect_identification_variable_declaration
	return p
}

func (*Subselect_identification_variable_declarationContext) IsSubselect_identification_variable_declarationContext() {
}

func NewSubselect_identification_variable_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Subselect_identification_variable_declarationContext {
	var p = new(Subselect_identification_variable_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_subselect_identification_variable_declaration

	return p
}

func (s *Subselect_identification_variable_declarationContext) GetParser() antlr.Parser {
	return s.parser
}

func (s *Subselect_identification_variable_declarationContext) Identification_variable_declaration() IIdentification_variable_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentification_variable_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentification_variable_declarationContext)
}

func (s *Subselect_identification_variable_declarationContext) Association_path_expression() IAssociation_path_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssociation_path_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssociation_path_expressionContext)
}

func (s *Subselect_identification_variable_declarationContext) IDENTIFICATION_VARIABLE() antlr.TerminalNode {
	return s.GetToken(JPAParserIDENTIFICATION_VARIABLE, 0)
}

func (s *Subselect_identification_variable_declarationContext) Collection_member_declaration() ICollection_member_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollection_member_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollection_member_declarationContext)
}

func (s *Subselect_identification_variable_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Subselect_identification_variable_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Subselect_identification_variable_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterSubselect_identification_variable_declaration(s)
	}
}

func (s *Subselect_identification_variable_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitSubselect_identification_variable_declaration(s)
	}
}

func (s *Subselect_identification_variable_declarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitSubselect_identification_variable_declaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Subselect_identification_variable_declaration() (localctx ISubselect_identification_variable_declarationContext) {
	localctx = NewSubselect_identification_variable_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, JPAParserRULE_subselect_identification_variable_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(481)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 48, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(473)
			p.Identification_variable_declaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(474)
			p.Association_path_expression()
		}
		p.SetState(476)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == JPAParserT__2 {
			{
				p.SetState(475)
				p.Match(JPAParserT__2)
			}

		}
		{
			p.SetState(478)
			p.Match(JPAParserIDENTIFICATION_VARIABLE)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(480)
			p.Collection_member_declaration()
		}

	}

	return localctx
}

// IAssociation_path_expressionContext is an interface to support dynamic dispatch.
type IAssociation_path_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssociation_path_expressionContext differentiates from other interfaces.
	IsAssociation_path_expressionContext()
}

type Association_path_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssociation_path_expressionContext() *Association_path_expressionContext {
	var p = new(Association_path_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_association_path_expression
	return p
}

func (*Association_path_expressionContext) IsAssociation_path_expressionContext() {}

func NewAssociation_path_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Association_path_expressionContext {
	var p = new(Association_path_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_association_path_expression

	return p
}

func (s *Association_path_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Association_path_expressionContext) Collection_valued_path_expression() ICollection_valued_path_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollection_valued_path_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollection_valued_path_expressionContext)
}

func (s *Association_path_expressionContext) Single_valued_association_path_expression() ISingle_valued_association_path_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingle_valued_association_path_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingle_valued_association_path_expressionContext)
}

func (s *Association_path_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Association_path_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Association_path_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterAssociation_path_expression(s)
	}
}

func (s *Association_path_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitAssociation_path_expression(s)
	}
}

func (s *Association_path_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitAssociation_path_expression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Association_path_expression() (localctx IAssociation_path_expressionContext) {
	localctx = NewAssociation_path_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, JPAParserRULE_association_path_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(485)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 49, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(483)
			p.Collection_valued_path_expression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(484)
			p.Single_valued_association_path_expression()
		}

	}

	return localctx
}

// ISimple_select_clauseContext is an interface to support dynamic dispatch.
type ISimple_select_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimple_select_clauseContext differentiates from other interfaces.
	IsSimple_select_clauseContext()
}

type Simple_select_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimple_select_clauseContext() *Simple_select_clauseContext {
	var p = new(Simple_select_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_simple_select_clause
	return p
}

func (*Simple_select_clauseContext) IsSimple_select_clauseContext() {}

func NewSimple_select_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Simple_select_clauseContext {
	var p = new(Simple_select_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_simple_select_clause

	return p
}

func (s *Simple_select_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Simple_select_clauseContext) Simple_select_expression() ISimple_select_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_select_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimple_select_expressionContext)
}

func (s *Simple_select_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Simple_select_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Simple_select_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterSimple_select_clause(s)
	}
}

func (s *Simple_select_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitSimple_select_clause(s)
	}
}

func (s *Simple_select_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitSimple_select_clause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Simple_select_clause() (localctx ISimple_select_clauseContext) {
	localctx = NewSimple_select_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, JPAParserRULE_simple_select_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(487)
		p.Match(JPAParserT__17)
	}
	p.SetState(489)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == JPAParserT__18 {
		{
			p.SetState(488)
			p.Match(JPAParserT__18)
		}

	}
	{
		p.SetState(491)
		p.Simple_select_expression()
	}

	return localctx
}

// ISimple_select_expressionContext is an interface to support dynamic dispatch.
type ISimple_select_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimple_select_expressionContext differentiates from other interfaces.
	IsSimple_select_expressionContext()
}

type Simple_select_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimple_select_expressionContext() *Simple_select_expressionContext {
	var p = new(Simple_select_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_simple_select_expression
	return p
}

func (*Simple_select_expressionContext) IsSimple_select_expressionContext() {}

func NewSimple_select_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Simple_select_expressionContext {
	var p = new(Simple_select_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_simple_select_expression

	return p
}

func (s *Simple_select_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Simple_select_expressionContext) Single_valued_path_expression() ISingle_valued_path_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingle_valued_path_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingle_valued_path_expressionContext)
}

func (s *Simple_select_expressionContext) Aggregate_expression() IAggregate_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAggregate_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAggregate_expressionContext)
}

func (s *Simple_select_expressionContext) IDENTIFICATION_VARIABLE() antlr.TerminalNode {
	return s.GetToken(JPAParserIDENTIFICATION_VARIABLE, 0)
}

func (s *Simple_select_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Simple_select_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Simple_select_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterSimple_select_expression(s)
	}
}

func (s *Simple_select_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitSimple_select_expression(s)
	}
}

func (s *Simple_select_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitSimple_select_expression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Simple_select_expression() (localctx ISimple_select_expressionContext) {
	localctx = NewSimple_select_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, JPAParserRULE_simple_select_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(496)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 51, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(493)
			p.Single_valued_path_expression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(494)
			p.Aggregate_expression()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(495)
			p.Match(JPAParserIDENTIFICATION_VARIABLE)
		}

	}

	return localctx
}

// IConditional_expressionContext is an interface to support dynamic dispatch.
type IConditional_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConditional_expressionContext differentiates from other interfaces.
	IsConditional_expressionContext()
}

type Conditional_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditional_expressionContext() *Conditional_expressionContext {
	var p = new(Conditional_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_conditional_expression
	return p
}

func (*Conditional_expressionContext) IsConditional_expressionContext() {}

func NewConditional_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Conditional_expressionContext {
	var p = new(Conditional_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_conditional_expression

	return p
}

func (s *Conditional_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Conditional_expressionContext) AllConditional_term() []IConditional_termContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConditional_termContext)(nil)).Elem())
	var tst = make([]IConditional_termContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConditional_termContext)
		}
	}

	return tst
}

func (s *Conditional_expressionContext) Conditional_term(i int) IConditional_termContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditional_termContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConditional_termContext)
}

func (s *Conditional_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Conditional_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Conditional_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterConditional_expression(s)
	}
}

func (s *Conditional_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitConditional_expression(s)
	}
}

func (s *Conditional_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitConditional_expression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Conditional_expression() (localctx IConditional_expressionContext) {
	localctx = NewConditional_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, JPAParserRULE_conditional_expression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(498)
		p.Conditional_term()
	}

	p.SetState(503)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == JPAParserT__33 {
		{
			p.SetState(499)
			p.Match(JPAParserT__33)
		}
		{
			p.SetState(500)
			p.Conditional_term()
		}

		p.SetState(505)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IConditional_termContext is an interface to support dynamic dispatch.
type IConditional_termContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConditional_termContext differentiates from other interfaces.
	IsConditional_termContext()
}

type Conditional_termContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditional_termContext() *Conditional_termContext {
	var p = new(Conditional_termContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_conditional_term
	return p
}

func (*Conditional_termContext) IsConditional_termContext() {}

func NewConditional_termContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Conditional_termContext {
	var p = new(Conditional_termContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_conditional_term

	return p
}

func (s *Conditional_termContext) GetParser() antlr.Parser { return s.parser }

func (s *Conditional_termContext) AllConditional_factor() []IConditional_factorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConditional_factorContext)(nil)).Elem())
	var tst = make([]IConditional_factorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConditional_factorContext)
		}
	}

	return tst
}

func (s *Conditional_termContext) Conditional_factor(i int) IConditional_factorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditional_factorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConditional_factorContext)
}

func (s *Conditional_termContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Conditional_termContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Conditional_termContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterConditional_term(s)
	}
}

func (s *Conditional_termContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitConditional_term(s)
	}
}

func (s *Conditional_termContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitConditional_term(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Conditional_term() (localctx IConditional_termContext) {
	localctx = NewConditional_termContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, JPAParserRULE_conditional_term)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(506)
		p.Conditional_factor()
	}

	p.SetState(511)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == JPAParserT__34 {
		{
			p.SetState(507)
			p.Match(JPAParserT__34)
		}
		{
			p.SetState(508)
			p.Conditional_factor()
		}

		p.SetState(513)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IConditional_factorContext is an interface to support dynamic dispatch.
type IConditional_factorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConditional_factorContext differentiates from other interfaces.
	IsConditional_factorContext()
}

type Conditional_factorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditional_factorContext() *Conditional_factorContext {
	var p = new(Conditional_factorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_conditional_factor
	return p
}

func (*Conditional_factorContext) IsConditional_factorContext() {}

func NewConditional_factorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Conditional_factorContext {
	var p = new(Conditional_factorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_conditional_factor

	return p
}

func (s *Conditional_factorContext) GetParser() antlr.Parser { return s.parser }

func (s *Conditional_factorContext) Conditional_primary() IConditional_primaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditional_primaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditional_primaryContext)
}

func (s *Conditional_factorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Conditional_factorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Conditional_factorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterConditional_factor(s)
	}
}

func (s *Conditional_factorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitConditional_factor(s)
	}
}

func (s *Conditional_factorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitConditional_factor(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Conditional_factor() (localctx IConditional_factorContext) {
	localctx = NewConditional_factorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, JPAParserRULE_conditional_factor)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(515)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 54, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(514)
			p.Match(JPAParserT__35)
		}

	}
	{
		p.SetState(517)
		p.Conditional_primary()
	}

	return localctx
}

// IConditional_primaryContext is an interface to support dynamic dispatch.
type IConditional_primaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConditional_primaryContext differentiates from other interfaces.
	IsConditional_primaryContext()
}

type Conditional_primaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditional_primaryContext() *Conditional_primaryContext {
	var p = new(Conditional_primaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_conditional_primary
	return p
}

func (*Conditional_primaryContext) IsConditional_primaryContext() {}

func NewConditional_primaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Conditional_primaryContext {
	var p = new(Conditional_primaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_conditional_primary

	return p
}

func (s *Conditional_primaryContext) GetParser() antlr.Parser { return s.parser }

func (s *Conditional_primaryContext) Simple_cond_expression() ISimple_cond_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_cond_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimple_cond_expressionContext)
}

func (s *Conditional_primaryContext) Conditional_expression() IConditional_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditional_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditional_expressionContext)
}

func (s *Conditional_primaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Conditional_primaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Conditional_primaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterConditional_primary(s)
	}
}

func (s *Conditional_primaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitConditional_primary(s)
	}
}

func (s *Conditional_primaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitConditional_primary(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Conditional_primary() (localctx IConditional_primaryContext) {
	localctx = NewConditional_primaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, JPAParserRULE_conditional_primary)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(524)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 55, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(519)
			p.Simple_cond_expression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(520)
			p.Match(JPAParserT__10)
		}
		{
			p.SetState(521)
			p.Conditional_expression()
		}
		{
			p.SetState(522)
			p.Match(JPAParserT__11)
		}

	}

	return localctx
}

// ISimple_cond_expressionContext is an interface to support dynamic dispatch.
type ISimple_cond_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimple_cond_expressionContext differentiates from other interfaces.
	IsSimple_cond_expressionContext()
}

type Simple_cond_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimple_cond_expressionContext() *Simple_cond_expressionContext {
	var p = new(Simple_cond_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_simple_cond_expression
	return p
}

func (*Simple_cond_expressionContext) IsSimple_cond_expressionContext() {}

func NewSimple_cond_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Simple_cond_expressionContext {
	var p = new(Simple_cond_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_simple_cond_expression

	return p
}

func (s *Simple_cond_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Simple_cond_expressionContext) Comparison_expression() IComparison_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComparison_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComparison_expressionContext)
}

func (s *Simple_cond_expressionContext) Between_expression() IBetween_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBetween_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBetween_expressionContext)
}

func (s *Simple_cond_expressionContext) Like_expression() ILike_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILike_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILike_expressionContext)
}

func (s *Simple_cond_expressionContext) In_expression() IIn_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIn_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIn_expressionContext)
}

func (s *Simple_cond_expressionContext) Null_comparison_expression() INull_comparison_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INull_comparison_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INull_comparison_expressionContext)
}

func (s *Simple_cond_expressionContext) Empty_collection_comparison_expression() IEmpty_collection_comparison_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEmpty_collection_comparison_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEmpty_collection_comparison_expressionContext)
}

func (s *Simple_cond_expressionContext) Collection_member_expression() ICollection_member_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollection_member_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollection_member_expressionContext)
}

func (s *Simple_cond_expressionContext) Exists_expression() IExists_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExists_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExists_expressionContext)
}

func (s *Simple_cond_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Simple_cond_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Simple_cond_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterSimple_cond_expression(s)
	}
}

func (s *Simple_cond_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitSimple_cond_expression(s)
	}
}

func (s *Simple_cond_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitSimple_cond_expression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Simple_cond_expression() (localctx ISimple_cond_expressionContext) {
	localctx = NewSimple_cond_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, JPAParserRULE_simple_cond_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(534)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 56, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(526)
			p.Comparison_expression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(527)
			p.Between_expression()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(528)
			p.Like_expression()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(529)
			p.In_expression()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(530)
			p.Null_comparison_expression()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(531)
			p.Empty_collection_comparison_expression()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(532)
			p.Collection_member_expression()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(533)
			p.Exists_expression()
		}

	}

	return localctx
}

// IBetween_expressionContext is an interface to support dynamic dispatch.
type IBetween_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBetween_expressionContext differentiates from other interfaces.
	IsBetween_expressionContext()
}

type Between_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBetween_expressionContext() *Between_expressionContext {
	var p = new(Between_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_between_expression
	return p
}

func (*Between_expressionContext) IsBetween_expressionContext() {}

func NewBetween_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Between_expressionContext {
	var p = new(Between_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_between_expression

	return p
}

func (s *Between_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Between_expressionContext) AllArithmetic_expression() []IArithmetic_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IArithmetic_expressionContext)(nil)).Elem())
	var tst = make([]IArithmetic_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IArithmetic_expressionContext)
		}
	}

	return tst
}

func (s *Between_expressionContext) Arithmetic_expression(i int) IArithmetic_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArithmetic_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IArithmetic_expressionContext)
}

func (s *Between_expressionContext) AllString_expression() []IString_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IString_expressionContext)(nil)).Elem())
	var tst = make([]IString_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IString_expressionContext)
		}
	}

	return tst
}

func (s *Between_expressionContext) String_expression(i int) IString_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IString_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IString_expressionContext)
}

func (s *Between_expressionContext) AllDatetime_expression() []IDatetime_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDatetime_expressionContext)(nil)).Elem())
	var tst = make([]IDatetime_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDatetime_expressionContext)
		}
	}

	return tst
}

func (s *Between_expressionContext) Datetime_expression(i int) IDatetime_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDatetime_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDatetime_expressionContext)
}

func (s *Between_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Between_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Between_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterBetween_expression(s)
	}
}

func (s *Between_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitBetween_expression(s)
	}
}

func (s *Between_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitBetween_expression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Between_expression() (localctx IBetween_expressionContext) {
	localctx = NewBetween_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, JPAParserRULE_between_expression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(563)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 60, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(536)
			p.Arithmetic_expression()
		}
		p.SetState(538)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == JPAParserT__35 {
			{
				p.SetState(537)
				p.Match(JPAParserT__35)
			}

		}
		{
			p.SetState(540)
			p.Match(JPAParserT__36)
		}
		{
			p.SetState(541)
			p.Arithmetic_expression()
		}
		{
			p.SetState(542)
			p.Match(JPAParserT__34)
		}
		{
			p.SetState(543)
			p.Arithmetic_expression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(545)
			p.String_expression()
		}
		p.SetState(547)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == JPAParserT__35 {
			{
				p.SetState(546)
				p.Match(JPAParserT__35)
			}

		}
		{
			p.SetState(549)
			p.Match(JPAParserT__36)
		}
		{
			p.SetState(550)
			p.String_expression()
		}
		{
			p.SetState(551)
			p.Match(JPAParserT__34)
		}
		{
			p.SetState(552)
			p.String_expression()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(554)
			p.Datetime_expression()
		}
		p.SetState(556)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == JPAParserT__35 {
			{
				p.SetState(555)
				p.Match(JPAParserT__35)
			}

		}
		{
			p.SetState(558)
			p.Match(JPAParserT__36)
		}
		{
			p.SetState(559)
			p.Datetime_expression()
		}
		{
			p.SetState(560)
			p.Match(JPAParserT__34)
		}
		{
			p.SetState(561)
			p.Datetime_expression()
		}

	}

	return localctx
}

// IIn_expressionContext is an interface to support dynamic dispatch.
type IIn_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIn_expressionContext differentiates from other interfaces.
	IsIn_expressionContext()
}

type In_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIn_expressionContext() *In_expressionContext {
	var p = new(In_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_in_expression
	return p
}

func (*In_expressionContext) IsIn_expressionContext() {}

func NewIn_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *In_expressionContext {
	var p = new(In_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_in_expression

	return p
}

func (s *In_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *In_expressionContext) State_field_path_expression() IState_field_path_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IState_field_path_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IState_field_path_expressionContext)
}

func (s *In_expressionContext) AllIn_item() []IIn_itemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIn_itemContext)(nil)).Elem())
	var tst = make([]IIn_itemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIn_itemContext)
		}
	}

	return tst
}

func (s *In_expressionContext) In_item(i int) IIn_itemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIn_itemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIn_itemContext)
}

func (s *In_expressionContext) Subquery() ISubqueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubqueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubqueryContext)
}

func (s *In_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *In_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *In_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterIn_expression(s)
	}
}

func (s *In_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitIn_expression(s)
	}
}

func (s *In_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitIn_expression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) In_expression() (localctx IIn_expressionContext) {
	localctx = NewIn_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, JPAParserRULE_in_expression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(565)
		p.State_field_path_expression()
	}
	p.SetState(567)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == JPAParserT__35 {
		{
			p.SetState(566)
			p.Match(JPAParserT__35)
		}

	}
	{
		p.SetState(569)
		p.Match(JPAParserT__9)
	}
	{
		p.SetState(570)
		p.Match(JPAParserT__10)
	}
	p.SetState(580)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case JPAParserT__1, JPAParserT__11, JPAParserT__73, JPAParserT__74:
		{
			p.SetState(571)
			p.In_item()
		}
		p.SetState(576)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == JPAParserT__1 {
			{
				p.SetState(572)
				p.Match(JPAParserT__1)
			}
			{
				p.SetState(573)
				p.In_item()
			}

			p.SetState(578)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case JPAParserT__17:
		{
			p.SetState(579)
			p.Subquery()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(582)
		p.Match(JPAParserT__11)
	}

	return localctx
}

// IIn_itemContext is an interface to support dynamic dispatch.
type IIn_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIn_itemContext differentiates from other interfaces.
	IsIn_itemContext()
}

type In_itemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIn_itemContext() *In_itemContext {
	var p = new(In_itemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_in_item
	return p
}

func (*In_itemContext) IsIn_itemContext() {}

func NewIn_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *In_itemContext {
	var p = new(In_itemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_in_item

	return p
}

func (s *In_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *In_itemContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *In_itemContext) Input_parameter() IInput_parameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInput_parameterContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInput_parameterContext)
}

func (s *In_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *In_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *In_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterIn_item(s)
	}
}

func (s *In_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitIn_item(s)
	}
}

func (s *In_itemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitIn_item(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) In_item() (localctx IIn_itemContext) {
	localctx = NewIn_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, JPAParserRULE_in_item)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(586)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case JPAParserT__1, JPAParserT__11:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(584)
			p.Literal()
		}

	case JPAParserT__73, JPAParserT__74:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(585)
			p.Input_parameter()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ILike_expressionContext is an interface to support dynamic dispatch.
type ILike_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLike_expressionContext differentiates from other interfaces.
	IsLike_expressionContext()
}

type Like_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLike_expressionContext() *Like_expressionContext {
	var p = new(Like_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_like_expression
	return p
}

func (*Like_expressionContext) IsLike_expressionContext() {}

func NewLike_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Like_expressionContext {
	var p = new(Like_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_like_expression

	return p
}

func (s *Like_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Like_expressionContext) String_expression() IString_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IString_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IString_expressionContext)
}

func (s *Like_expressionContext) Pattern_value() IPattern_valueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPattern_valueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPattern_valueContext)
}

func (s *Like_expressionContext) ESCAPE_CHARACTER() antlr.TerminalNode {
	return s.GetToken(JPAParserESCAPE_CHARACTER, 0)
}

func (s *Like_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Like_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Like_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterLike_expression(s)
	}
}

func (s *Like_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitLike_expression(s)
	}
}

func (s *Like_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitLike_expression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Like_expression() (localctx ILike_expressionContext) {
	localctx = NewLike_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, JPAParserRULE_like_expression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(588)
		p.String_expression()
	}
	p.SetState(590)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == JPAParserT__35 {
		{
			p.SetState(589)
			p.Match(JPAParserT__35)
		}

	}
	{
		p.SetState(592)
		p.Match(JPAParserT__37)
	}
	{
		p.SetState(593)
		p.Pattern_value()
	}
	p.SetState(596)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == JPAParserT__38 {
		{
			p.SetState(594)
			p.Match(JPAParserT__38)
		}
		{
			p.SetState(595)
			p.Match(JPAParserESCAPE_CHARACTER)
		}

	}

	return localctx
}

// INull_comparison_expressionContext is an interface to support dynamic dispatch.
type INull_comparison_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNull_comparison_expressionContext differentiates from other interfaces.
	IsNull_comparison_expressionContext()
}

type Null_comparison_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNull_comparison_expressionContext() *Null_comparison_expressionContext {
	var p = new(Null_comparison_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_null_comparison_expression
	return p
}

func (*Null_comparison_expressionContext) IsNull_comparison_expressionContext() {}

func NewNull_comparison_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Null_comparison_expressionContext {
	var p = new(Null_comparison_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_null_comparison_expression

	return p
}

func (s *Null_comparison_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Null_comparison_expressionContext) Single_valued_path_expression() ISingle_valued_path_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingle_valued_path_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingle_valued_path_expressionContext)
}

func (s *Null_comparison_expressionContext) Input_parameter() IInput_parameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInput_parameterContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInput_parameterContext)
}

func (s *Null_comparison_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Null_comparison_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Null_comparison_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterNull_comparison_expression(s)
	}
}

func (s *Null_comparison_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitNull_comparison_expression(s)
	}
}

func (s *Null_comparison_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitNull_comparison_expression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Null_comparison_expression() (localctx INull_comparison_expressionContext) {
	localctx = NewNull_comparison_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, JPAParserRULE_null_comparison_expression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(600)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case JPAParserIDENTIFICATION_VARIABLE:
		{
			p.SetState(598)
			p.Single_valued_path_expression()
		}

	case JPAParserT__73, JPAParserT__74:
		{
			p.SetState(599)
			p.Input_parameter()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(602)
		p.Match(JPAParserT__39)
	}
	p.SetState(604)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == JPAParserT__35 {
		{
			p.SetState(603)
			p.Match(JPAParserT__35)
		}

	}
	{
		p.SetState(606)
		p.Match(JPAParserT__15)
	}

	return localctx
}

// IEmpty_collection_comparison_expressionContext is an interface to support dynamic dispatch.
type IEmpty_collection_comparison_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEmpty_collection_comparison_expressionContext differentiates from other interfaces.
	IsEmpty_collection_comparison_expressionContext()
}

type Empty_collection_comparison_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEmpty_collection_comparison_expressionContext() *Empty_collection_comparison_expressionContext {
	var p = new(Empty_collection_comparison_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_empty_collection_comparison_expression
	return p
}

func (*Empty_collection_comparison_expressionContext) IsEmpty_collection_comparison_expressionContext() {
}

func NewEmpty_collection_comparison_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Empty_collection_comparison_expressionContext {
	var p = new(Empty_collection_comparison_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_empty_collection_comparison_expression

	return p
}

func (s *Empty_collection_comparison_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Empty_collection_comparison_expressionContext) Collection_valued_path_expression() ICollection_valued_path_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollection_valued_path_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollection_valued_path_expressionContext)
}

func (s *Empty_collection_comparison_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Empty_collection_comparison_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Empty_collection_comparison_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterEmpty_collection_comparison_expression(s)
	}
}

func (s *Empty_collection_comparison_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitEmpty_collection_comparison_expression(s)
	}
}

func (s *Empty_collection_comparison_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitEmpty_collection_comparison_expression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Empty_collection_comparison_expression() (localctx IEmpty_collection_comparison_expressionContext) {
	localctx = NewEmpty_collection_comparison_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, JPAParserRULE_empty_collection_comparison_expression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(608)
		p.Collection_valued_path_expression()
	}
	{
		p.SetState(609)
		p.Match(JPAParserT__39)
	}
	p.SetState(611)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == JPAParserT__35 {
		{
			p.SetState(610)
			p.Match(JPAParserT__35)
		}

	}
	{
		p.SetState(613)
		p.Match(JPAParserT__40)
	}

	return localctx
}

// ICollection_member_expressionContext is an interface to support dynamic dispatch.
type ICollection_member_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollection_member_expressionContext differentiates from other interfaces.
	IsCollection_member_expressionContext()
}

type Collection_member_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollection_member_expressionContext() *Collection_member_expressionContext {
	var p = new(Collection_member_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_collection_member_expression
	return p
}

func (*Collection_member_expressionContext) IsCollection_member_expressionContext() {}

func NewCollection_member_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Collection_member_expressionContext {
	var p = new(Collection_member_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_collection_member_expression

	return p
}

func (s *Collection_member_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Collection_member_expressionContext) Entity_expression() IEntity_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEntity_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEntity_expressionContext)
}

func (s *Collection_member_expressionContext) Collection_valued_path_expression() ICollection_valued_path_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollection_valued_path_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollection_valued_path_expressionContext)
}

func (s *Collection_member_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Collection_member_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Collection_member_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterCollection_member_expression(s)
	}
}

func (s *Collection_member_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitCollection_member_expression(s)
	}
}

func (s *Collection_member_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitCollection_member_expression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Collection_member_expression() (localctx ICollection_member_expressionContext) {
	localctx = NewCollection_member_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, JPAParserRULE_collection_member_expression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(615)
		p.Entity_expression()
	}
	p.SetState(617)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == JPAParserT__35 {
		{
			p.SetState(616)
			p.Match(JPAParserT__35)
		}

	}
	{
		p.SetState(619)
		p.Match(JPAParserT__41)
	}
	p.SetState(621)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == JPAParserT__42 {
		{
			p.SetState(620)
			p.Match(JPAParserT__42)
		}

	}
	{
		p.SetState(623)
		p.Collection_valued_path_expression()
	}

	return localctx
}

// IExists_expressionContext is an interface to support dynamic dispatch.
type IExists_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExists_expressionContext differentiates from other interfaces.
	IsExists_expressionContext()
}

type Exists_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExists_expressionContext() *Exists_expressionContext {
	var p = new(Exists_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_exists_expression
	return p
}

func (*Exists_expressionContext) IsExists_expressionContext() {}

func NewExists_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Exists_expressionContext {
	var p = new(Exists_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_exists_expression

	return p
}

func (s *Exists_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Exists_expressionContext) Subquery() ISubqueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubqueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubqueryContext)
}

func (s *Exists_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Exists_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Exists_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterExists_expression(s)
	}
}

func (s *Exists_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitExists_expression(s)
	}
}

func (s *Exists_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitExists_expression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Exists_expression() (localctx IExists_expressionContext) {
	localctx = NewExists_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, JPAParserRULE_exists_expression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(626)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == JPAParserT__35 {
		{
			p.SetState(625)
			p.Match(JPAParserT__35)
		}

	}
	{
		p.SetState(628)
		p.Match(JPAParserT__43)
	}
	{
		p.SetState(629)
		p.Match(JPAParserT__10)
	}
	{
		p.SetState(630)
		p.Subquery()
	}
	{
		p.SetState(631)
		p.Match(JPAParserT__11)
	}

	return localctx
}

// IAll_or_any_expressionContext is an interface to support dynamic dispatch.
type IAll_or_any_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAll_or_any_expressionContext differentiates from other interfaces.
	IsAll_or_any_expressionContext()
}

type All_or_any_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAll_or_any_expressionContext() *All_or_any_expressionContext {
	var p = new(All_or_any_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_all_or_any_expression
	return p
}

func (*All_or_any_expressionContext) IsAll_or_any_expressionContext() {}

func NewAll_or_any_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *All_or_any_expressionContext {
	var p = new(All_or_any_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_all_or_any_expression

	return p
}

func (s *All_or_any_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *All_or_any_expressionContext) Subquery() ISubqueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubqueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubqueryContext)
}

func (s *All_or_any_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *All_or_any_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *All_or_any_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterAll_or_any_expression(s)
	}
}

func (s *All_or_any_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitAll_or_any_expression(s)
	}
}

func (s *All_or_any_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitAll_or_any_expression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) All_or_any_expression() (localctx IAll_or_any_expressionContext) {
	localctx = NewAll_or_any_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, JPAParserRULE_all_or_any_expression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(633)
	_la = p.GetTokenStream().LA(1)

	if !(((_la-45)&-(0x1f+1)) == 0 && ((1<<uint((_la-45)))&((1<<(JPAParserT__44-45))|(1<<(JPAParserT__45-45))|(1<<(JPAParserT__46-45)))) != 0) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}
	{
		p.SetState(634)
		p.Match(JPAParserT__10)
	}
	{
		p.SetState(635)
		p.Subquery()
	}
	{
		p.SetState(636)
		p.Match(JPAParserT__11)
	}

	return localctx
}

// IComparison_expressionContext is an interface to support dynamic dispatch.
type IComparison_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComparison_expressionContext differentiates from other interfaces.
	IsComparison_expressionContext()
}

type Comparison_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparison_expressionContext() *Comparison_expressionContext {
	var p = new(Comparison_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_comparison_expression
	return p
}

func (*Comparison_expressionContext) IsComparison_expressionContext() {}

func NewComparison_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comparison_expressionContext {
	var p = new(Comparison_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_comparison_expression

	return p
}

func (s *Comparison_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Comparison_expressionContext) AllString_expression() []IString_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IString_expressionContext)(nil)).Elem())
	var tst = make([]IString_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IString_expressionContext)
		}
	}

	return tst
}

func (s *Comparison_expressionContext) String_expression(i int) IString_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IString_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IString_expressionContext)
}

func (s *Comparison_expressionContext) Comparison_operator() IComparison_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComparison_operatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComparison_operatorContext)
}

func (s *Comparison_expressionContext) All_or_any_expression() IAll_or_any_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAll_or_any_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAll_or_any_expressionContext)
}

func (s *Comparison_expressionContext) AllBoolean_expression() []IBoolean_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBoolean_expressionContext)(nil)).Elem())
	var tst = make([]IBoolean_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBoolean_expressionContext)
		}
	}

	return tst
}

func (s *Comparison_expressionContext) Boolean_expression(i int) IBoolean_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBoolean_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBoolean_expressionContext)
}

func (s *Comparison_expressionContext) AllEnum_expression() []IEnum_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEnum_expressionContext)(nil)).Elem())
	var tst = make([]IEnum_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEnum_expressionContext)
		}
	}

	return tst
}

func (s *Comparison_expressionContext) Enum_expression(i int) IEnum_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnum_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEnum_expressionContext)
}

func (s *Comparison_expressionContext) AllDatetime_expression() []IDatetime_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDatetime_expressionContext)(nil)).Elem())
	var tst = make([]IDatetime_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDatetime_expressionContext)
		}
	}

	return tst
}

func (s *Comparison_expressionContext) Datetime_expression(i int) IDatetime_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDatetime_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDatetime_expressionContext)
}

func (s *Comparison_expressionContext) AllEntity_expression() []IEntity_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEntity_expressionContext)(nil)).Elem())
	var tst = make([]IEntity_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEntity_expressionContext)
		}
	}

	return tst
}

func (s *Comparison_expressionContext) Entity_expression(i int) IEntity_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEntity_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEntity_expressionContext)
}

func (s *Comparison_expressionContext) AllArithmetic_expression() []IArithmetic_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IArithmetic_expressionContext)(nil)).Elem())
	var tst = make([]IArithmetic_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IArithmetic_expressionContext)
		}
	}

	return tst
}

func (s *Comparison_expressionContext) Arithmetic_expression(i int) IArithmetic_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArithmetic_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IArithmetic_expressionContext)
}

func (s *Comparison_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comparison_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comparison_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterComparison_expression(s)
	}
}

func (s *Comparison_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitComparison_expression(s)
	}
}

func (s *Comparison_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitComparison_expression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Comparison_expression() (localctx IComparison_expressionContext) {
	localctx = NewComparison_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, JPAParserRULE_comparison_expression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(674)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 79, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(638)
			p.String_expression()
		}
		{
			p.SetState(639)
			p.Comparison_operator()
		}
		p.SetState(642)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case JPAParserT__10, JPAParserT__21, JPAParserT__22, JPAParserT__23, JPAParserT__24, JPAParserT__25, JPAParserT__65, JPAParserT__66, JPAParserT__67, JPAParserT__68, JPAParserT__69, JPAParserT__73, JPAParserT__74, JPAParserIDENTIFICATION_VARIABLE, JPAParserSTRINGLITERAL:
			{
				p.SetState(640)
				p.String_expression()
			}

		case JPAParserT__44, JPAParserT__45, JPAParserT__46:
			{
				p.SetState(641)
				p.All_or_any_expression()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(644)
			p.Boolean_expression()
		}
		p.SetState(645)
		_la = p.GetTokenStream().LA(1)

		if !(_la == JPAParserT__14 || _la == JPAParserT__47) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
		p.SetState(648)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case JPAParserT__10, JPAParserT__73, JPAParserT__74, JPAParserT__75, JPAParserT__76, JPAParserIDENTIFICATION_VARIABLE:
			{
				p.SetState(646)
				p.Boolean_expression()
			}

		case JPAParserT__44, JPAParserT__45, JPAParserT__46:
			{
				p.SetState(647)
				p.All_or_any_expression()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(650)
			p.Enum_expression()
		}
		p.SetState(651)
		_la = p.GetTokenStream().LA(1)

		if !(_la == JPAParserT__14 || _la == JPAParserT__47) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
		p.SetState(654)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case JPAParserEOF, JPAParserT__10, JPAParserT__11, JPAParserT__27, JPAParserT__29, JPAParserT__30, JPAParserT__33, JPAParserT__34, JPAParserT__73, JPAParserT__74, JPAParserIDENTIFICATION_VARIABLE:
			{
				p.SetState(652)
				p.Enum_expression()
			}

		case JPAParserT__44, JPAParserT__45, JPAParserT__46:
			{
				p.SetState(653)
				p.All_or_any_expression()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(656)
			p.Datetime_expression()
		}
		{
			p.SetState(657)
			p.Comparison_operator()
		}
		p.SetState(660)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case JPAParserT__10, JPAParserT__21, JPAParserT__22, JPAParserT__23, JPAParserT__24, JPAParserT__25, JPAParserT__62, JPAParserT__63, JPAParserT__64, JPAParserT__73, JPAParserT__74, JPAParserIDENTIFICATION_VARIABLE:
			{
				p.SetState(658)
				p.Datetime_expression()
			}

		case JPAParserT__44, JPAParserT__45, JPAParserT__46:
			{
				p.SetState(659)
				p.All_or_any_expression()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(662)
			p.Entity_expression()
		}
		p.SetState(663)
		_la = p.GetTokenStream().LA(1)

		if !(_la == JPAParserT__14 || _la == JPAParserT__47) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
		p.SetState(666)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case JPAParserT__73, JPAParserT__74, JPAParserIDENTIFICATION_VARIABLE:
			{
				p.SetState(664)
				p.Entity_expression()
			}

		case JPAParserT__44, JPAParserT__45, JPAParserT__46:
			{
				p.SetState(665)
				p.All_or_any_expression()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(668)
			p.Arithmetic_expression()
		}
		{
			p.SetState(669)
			p.Comparison_operator()
		}
		p.SetState(672)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case JPAParserEOF, JPAParserT__10, JPAParserT__11, JPAParserT__21, JPAParserT__22, JPAParserT__23, JPAParserT__24, JPAParserT__25, JPAParserT__27, JPAParserT__29, JPAParserT__30, JPAParserT__33, JPAParserT__34, JPAParserT__52, JPAParserT__53, JPAParserT__54, JPAParserT__55, JPAParserT__56, JPAParserT__57, JPAParserT__58, JPAParserT__59, JPAParserT__60, JPAParserT__61, JPAParserT__73, JPAParserT__74, JPAParserIDENTIFICATION_VARIABLE:
			{
				p.SetState(670)
				p.Arithmetic_expression()
			}

		case JPAParserT__44, JPAParserT__45, JPAParserT__46:
			{
				p.SetState(671)
				p.All_or_any_expression()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	}

	return localctx
}

// IComparison_operatorContext is an interface to support dynamic dispatch.
type IComparison_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComparison_operatorContext differentiates from other interfaces.
	IsComparison_operatorContext()
}

type Comparison_operatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparison_operatorContext() *Comparison_operatorContext {
	var p = new(Comparison_operatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_comparison_operator
	return p
}

func (*Comparison_operatorContext) IsComparison_operatorContext() {}

func NewComparison_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comparison_operatorContext {
	var p = new(Comparison_operatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_comparison_operator

	return p
}

func (s *Comparison_operatorContext) GetParser() antlr.Parser { return s.parser }
func (s *Comparison_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comparison_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comparison_operatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterComparison_operator(s)
	}
}

func (s *Comparison_operatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitComparison_operator(s)
	}
}

func (s *Comparison_operatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitComparison_operator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Comparison_operator() (localctx IComparison_operatorContext) {
	localctx = NewComparison_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, JPAParserRULE_comparison_operator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(676)
	_la = p.GetTokenStream().LA(1)

	if !(_la == JPAParserT__14 || (((_la-48)&-(0x1f+1)) == 0 && ((1<<uint((_la-48)))&((1<<(JPAParserT__47-48))|(1<<(JPAParserT__48-48))|(1<<(JPAParserT__49-48))|(1<<(JPAParserT__50-48))|(1<<(JPAParserT__51-48)))) != 0)) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// IArithmetic_expressionContext is an interface to support dynamic dispatch.
type IArithmetic_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArithmetic_expressionContext differentiates from other interfaces.
	IsArithmetic_expressionContext()
}

type Arithmetic_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArithmetic_expressionContext() *Arithmetic_expressionContext {
	var p = new(Arithmetic_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_arithmetic_expression
	return p
}

func (*Arithmetic_expressionContext) IsArithmetic_expressionContext() {}

func NewArithmetic_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Arithmetic_expressionContext {
	var p = new(Arithmetic_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_arithmetic_expression

	return p
}

func (s *Arithmetic_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Arithmetic_expressionContext) Simple_arithmetic_expression() ISimple_arithmetic_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_arithmetic_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimple_arithmetic_expressionContext)
}

func (s *Arithmetic_expressionContext) Subquery() ISubqueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubqueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubqueryContext)
}

func (s *Arithmetic_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Arithmetic_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Arithmetic_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterArithmetic_expression(s)
	}
}

func (s *Arithmetic_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitArithmetic_expression(s)
	}
}

func (s *Arithmetic_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitArithmetic_expression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Arithmetic_expression() (localctx IArithmetic_expressionContext) {
	localctx = NewArithmetic_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, JPAParserRULE_arithmetic_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(683)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 80, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(678)
			p.Simple_arithmetic_expression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(679)
			p.Match(JPAParserT__10)
		}
		{
			p.SetState(680)
			p.Subquery()
		}
		{
			p.SetState(681)
			p.Match(JPAParserT__11)
		}

	}

	return localctx
}

// ISimple_arithmetic_expressionContext is an interface to support dynamic dispatch.
type ISimple_arithmetic_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimple_arithmetic_expressionContext differentiates from other interfaces.
	IsSimple_arithmetic_expressionContext()
}

type Simple_arithmetic_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimple_arithmetic_expressionContext() *Simple_arithmetic_expressionContext {
	var p = new(Simple_arithmetic_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_simple_arithmetic_expression
	return p
}

func (*Simple_arithmetic_expressionContext) IsSimple_arithmetic_expressionContext() {}

func NewSimple_arithmetic_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Simple_arithmetic_expressionContext {
	var p = new(Simple_arithmetic_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_simple_arithmetic_expression

	return p
}

func (s *Simple_arithmetic_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Simple_arithmetic_expressionContext) AllArithmetic_term() []IArithmetic_termContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IArithmetic_termContext)(nil)).Elem())
	var tst = make([]IArithmetic_termContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IArithmetic_termContext)
		}
	}

	return tst
}

func (s *Simple_arithmetic_expressionContext) Arithmetic_term(i int) IArithmetic_termContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArithmetic_termContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IArithmetic_termContext)
}

func (s *Simple_arithmetic_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Simple_arithmetic_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Simple_arithmetic_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterSimple_arithmetic_expression(s)
	}
}

func (s *Simple_arithmetic_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitSimple_arithmetic_expression(s)
	}
}

func (s *Simple_arithmetic_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitSimple_arithmetic_expression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Simple_arithmetic_expression() (localctx ISimple_arithmetic_expressionContext) {
	localctx = NewSimple_arithmetic_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, JPAParserRULE_simple_arithmetic_expression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(685)
		p.Arithmetic_term()
	}

	p.SetState(690)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == JPAParserT__52 || _la == JPAParserT__53 {
		p.SetState(686)
		_la = p.GetTokenStream().LA(1)

		if !(_la == JPAParserT__52 || _la == JPAParserT__53) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
		{
			p.SetState(687)
			p.Arithmetic_term()
		}

		p.SetState(692)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IArithmetic_termContext is an interface to support dynamic dispatch.
type IArithmetic_termContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArithmetic_termContext differentiates from other interfaces.
	IsArithmetic_termContext()
}

type Arithmetic_termContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArithmetic_termContext() *Arithmetic_termContext {
	var p = new(Arithmetic_termContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_arithmetic_term
	return p
}

func (*Arithmetic_termContext) IsArithmetic_termContext() {}

func NewArithmetic_termContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Arithmetic_termContext {
	var p = new(Arithmetic_termContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_arithmetic_term

	return p
}

func (s *Arithmetic_termContext) GetParser() antlr.Parser { return s.parser }

func (s *Arithmetic_termContext) AllArithmetic_factor() []IArithmetic_factorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IArithmetic_factorContext)(nil)).Elem())
	var tst = make([]IArithmetic_factorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IArithmetic_factorContext)
		}
	}

	return tst
}

func (s *Arithmetic_termContext) Arithmetic_factor(i int) IArithmetic_factorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArithmetic_factorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IArithmetic_factorContext)
}

func (s *Arithmetic_termContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Arithmetic_termContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Arithmetic_termContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterArithmetic_term(s)
	}
}

func (s *Arithmetic_termContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitArithmetic_term(s)
	}
}

func (s *Arithmetic_termContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitArithmetic_term(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Arithmetic_term() (localctx IArithmetic_termContext) {
	localctx = NewArithmetic_termContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, JPAParserRULE_arithmetic_term)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(693)
		p.Arithmetic_factor()
	}

	p.SetState(698)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == JPAParserT__54 || _la == JPAParserT__55 {
		p.SetState(694)
		_la = p.GetTokenStream().LA(1)

		if !(_la == JPAParserT__54 || _la == JPAParserT__55) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
		{
			p.SetState(695)
			p.Arithmetic_factor()
		}

		p.SetState(700)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IArithmetic_factorContext is an interface to support dynamic dispatch.
type IArithmetic_factorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArithmetic_factorContext differentiates from other interfaces.
	IsArithmetic_factorContext()
}

type Arithmetic_factorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArithmetic_factorContext() *Arithmetic_factorContext {
	var p = new(Arithmetic_factorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_arithmetic_factor
	return p
}

func (*Arithmetic_factorContext) IsArithmetic_factorContext() {}

func NewArithmetic_factorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Arithmetic_factorContext {
	var p = new(Arithmetic_factorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_arithmetic_factor

	return p
}

func (s *Arithmetic_factorContext) GetParser() antlr.Parser { return s.parser }

func (s *Arithmetic_factorContext) Arithmetic_primary() IArithmetic_primaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArithmetic_primaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArithmetic_primaryContext)
}

func (s *Arithmetic_factorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Arithmetic_factorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Arithmetic_factorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterArithmetic_factor(s)
	}
}

func (s *Arithmetic_factorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitArithmetic_factor(s)
	}
}

func (s *Arithmetic_factorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitArithmetic_factor(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Arithmetic_factor() (localctx IArithmetic_factorContext) {
	localctx = NewArithmetic_factorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, JPAParserRULE_arithmetic_factor)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(702)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 83, p.GetParserRuleContext()) == 1 {
		p.SetState(701)
		_la = p.GetTokenStream().LA(1)

		if !(_la == JPAParserT__52 || _la == JPAParserT__53) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}

	}
	{
		p.SetState(704)
		p.Arithmetic_primary()
	}

	return localctx
}

// IArithmetic_primaryContext is an interface to support dynamic dispatch.
type IArithmetic_primaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArithmetic_primaryContext differentiates from other interfaces.
	IsArithmetic_primaryContext()
}

type Arithmetic_primaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArithmetic_primaryContext() *Arithmetic_primaryContext {
	var p = new(Arithmetic_primaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_arithmetic_primary
	return p
}

func (*Arithmetic_primaryContext) IsArithmetic_primaryContext() {}

func NewArithmetic_primaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Arithmetic_primaryContext {
	var p = new(Arithmetic_primaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_arithmetic_primary

	return p
}

func (s *Arithmetic_primaryContext) GetParser() antlr.Parser { return s.parser }

func (s *Arithmetic_primaryContext) State_field_path_expression() IState_field_path_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IState_field_path_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IState_field_path_expressionContext)
}

func (s *Arithmetic_primaryContext) Numeric_literal() INumeric_literalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumeric_literalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumeric_literalContext)
}

func (s *Arithmetic_primaryContext) Simple_arithmetic_expression() ISimple_arithmetic_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_arithmetic_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimple_arithmetic_expressionContext)
}

func (s *Arithmetic_primaryContext) Input_parameter() IInput_parameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInput_parameterContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInput_parameterContext)
}

func (s *Arithmetic_primaryContext) Functions_returning_numerics() IFunctions_returning_numericsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctions_returning_numericsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctions_returning_numericsContext)
}

func (s *Arithmetic_primaryContext) Aggregate_expression() IAggregate_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAggregate_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAggregate_expressionContext)
}

func (s *Arithmetic_primaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Arithmetic_primaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Arithmetic_primaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterArithmetic_primary(s)
	}
}

func (s *Arithmetic_primaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitArithmetic_primary(s)
	}
}

func (s *Arithmetic_primaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitArithmetic_primary(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Arithmetic_primary() (localctx IArithmetic_primaryContext) {
	localctx = NewArithmetic_primaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, JPAParserRULE_arithmetic_primary)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(715)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case JPAParserIDENTIFICATION_VARIABLE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(706)
			p.State_field_path_expression()
		}

	case JPAParserEOF, JPAParserT__1, JPAParserT__11, JPAParserT__14, JPAParserT__26, JPAParserT__27, JPAParserT__29, JPAParserT__30, JPAParserT__33, JPAParserT__34, JPAParserT__35, JPAParserT__36, JPAParserT__47, JPAParserT__48, JPAParserT__49, JPAParserT__50, JPAParserT__51, JPAParserT__52, JPAParserT__53, JPAParserT__54, JPAParserT__55:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(707)
			p.Numeric_literal()
		}

	case JPAParserT__10:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(708)
			p.Match(JPAParserT__10)
		}
		{
			p.SetState(709)
			p.Simple_arithmetic_expression()
		}
		{
			p.SetState(710)
			p.Match(JPAParserT__11)
		}

	case JPAParserT__73, JPAParserT__74:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(712)
			p.Input_parameter()
		}

	case JPAParserT__56, JPAParserT__57, JPAParserT__58, JPAParserT__59, JPAParserT__60, JPAParserT__61:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(713)
			p.Functions_returning_numerics()
		}

	case JPAParserT__21, JPAParserT__22, JPAParserT__23, JPAParserT__24, JPAParserT__25:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(714)
			p.Aggregate_expression()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IString_expressionContext is an interface to support dynamic dispatch.
type IString_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsString_expressionContext differentiates from other interfaces.
	IsString_expressionContext()
}

type String_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyString_expressionContext() *String_expressionContext {
	var p = new(String_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_string_expression
	return p
}

func (*String_expressionContext) IsString_expressionContext() {}

func NewString_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *String_expressionContext {
	var p = new(String_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_string_expression

	return p
}

func (s *String_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *String_expressionContext) String_primary() IString_primaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IString_primaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IString_primaryContext)
}

func (s *String_expressionContext) Subquery() ISubqueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubqueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubqueryContext)
}

func (s *String_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *String_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *String_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterString_expression(s)
	}
}

func (s *String_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitString_expression(s)
	}
}

func (s *String_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitString_expression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) String_expression() (localctx IString_expressionContext) {
	localctx = NewString_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, JPAParserRULE_string_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(722)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case JPAParserT__21, JPAParserT__22, JPAParserT__23, JPAParserT__24, JPAParserT__25, JPAParserT__65, JPAParserT__66, JPAParserT__67, JPAParserT__68, JPAParserT__69, JPAParserT__73, JPAParserT__74, JPAParserIDENTIFICATION_VARIABLE, JPAParserSTRINGLITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(717)
			p.String_primary()
		}

	case JPAParserT__10:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(718)
			p.Match(JPAParserT__10)
		}
		{
			p.SetState(719)
			p.Subquery()
		}
		{
			p.SetState(720)
			p.Match(JPAParserT__11)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IString_primaryContext is an interface to support dynamic dispatch.
type IString_primaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsString_primaryContext differentiates from other interfaces.
	IsString_primaryContext()
}

type String_primaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyString_primaryContext() *String_primaryContext {
	var p = new(String_primaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_string_primary
	return p
}

func (*String_primaryContext) IsString_primaryContext() {}

func NewString_primaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *String_primaryContext {
	var p = new(String_primaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_string_primary

	return p
}

func (s *String_primaryContext) GetParser() antlr.Parser { return s.parser }

func (s *String_primaryContext) State_field_path_expression() IState_field_path_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IState_field_path_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IState_field_path_expressionContext)
}

func (s *String_primaryContext) STRINGLITERAL() antlr.TerminalNode {
	return s.GetToken(JPAParserSTRINGLITERAL, 0)
}

func (s *String_primaryContext) Input_parameter() IInput_parameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInput_parameterContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInput_parameterContext)
}

func (s *String_primaryContext) Functions_returning_strings() IFunctions_returning_stringsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctions_returning_stringsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctions_returning_stringsContext)
}

func (s *String_primaryContext) Aggregate_expression() IAggregate_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAggregate_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAggregate_expressionContext)
}

func (s *String_primaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *String_primaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *String_primaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterString_primary(s)
	}
}

func (s *String_primaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitString_primary(s)
	}
}

func (s *String_primaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitString_primary(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) String_primary() (localctx IString_primaryContext) {
	localctx = NewString_primaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, JPAParserRULE_string_primary)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(729)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case JPAParserIDENTIFICATION_VARIABLE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(724)
			p.State_field_path_expression()
		}

	case JPAParserSTRINGLITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(725)
			p.Match(JPAParserSTRINGLITERAL)
		}

	case JPAParserT__73, JPAParserT__74:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(726)
			p.Input_parameter()
		}

	case JPAParserT__65, JPAParserT__66, JPAParserT__67, JPAParserT__68, JPAParserT__69:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(727)
			p.Functions_returning_strings()
		}

	case JPAParserT__21, JPAParserT__22, JPAParserT__23, JPAParserT__24, JPAParserT__25:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(728)
			p.Aggregate_expression()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDatetime_expressionContext is an interface to support dynamic dispatch.
type IDatetime_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDatetime_expressionContext differentiates from other interfaces.
	IsDatetime_expressionContext()
}

type Datetime_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDatetime_expressionContext() *Datetime_expressionContext {
	var p = new(Datetime_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_datetime_expression
	return p
}

func (*Datetime_expressionContext) IsDatetime_expressionContext() {}

func NewDatetime_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Datetime_expressionContext {
	var p = new(Datetime_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_datetime_expression

	return p
}

func (s *Datetime_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Datetime_expressionContext) Datetime_primary() IDatetime_primaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDatetime_primaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDatetime_primaryContext)
}

func (s *Datetime_expressionContext) Subquery() ISubqueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubqueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubqueryContext)
}

func (s *Datetime_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Datetime_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Datetime_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterDatetime_expression(s)
	}
}

func (s *Datetime_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitDatetime_expression(s)
	}
}

func (s *Datetime_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitDatetime_expression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Datetime_expression() (localctx IDatetime_expressionContext) {
	localctx = NewDatetime_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, JPAParserRULE_datetime_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(736)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case JPAParserT__21, JPAParserT__22, JPAParserT__23, JPAParserT__24, JPAParserT__25, JPAParserT__62, JPAParserT__63, JPAParserT__64, JPAParserT__73, JPAParserT__74, JPAParserIDENTIFICATION_VARIABLE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(731)
			p.Datetime_primary()
		}

	case JPAParserT__10:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(732)
			p.Match(JPAParserT__10)
		}
		{
			p.SetState(733)
			p.Subquery()
		}
		{
			p.SetState(734)
			p.Match(JPAParserT__11)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDatetime_primaryContext is an interface to support dynamic dispatch.
type IDatetime_primaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDatetime_primaryContext differentiates from other interfaces.
	IsDatetime_primaryContext()
}

type Datetime_primaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDatetime_primaryContext() *Datetime_primaryContext {
	var p = new(Datetime_primaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_datetime_primary
	return p
}

func (*Datetime_primaryContext) IsDatetime_primaryContext() {}

func NewDatetime_primaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Datetime_primaryContext {
	var p = new(Datetime_primaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_datetime_primary

	return p
}

func (s *Datetime_primaryContext) GetParser() antlr.Parser { return s.parser }

func (s *Datetime_primaryContext) State_field_path_expression() IState_field_path_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IState_field_path_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IState_field_path_expressionContext)
}

func (s *Datetime_primaryContext) Input_parameter() IInput_parameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInput_parameterContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInput_parameterContext)
}

func (s *Datetime_primaryContext) Functions_returning_datetime() IFunctions_returning_datetimeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctions_returning_datetimeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctions_returning_datetimeContext)
}

func (s *Datetime_primaryContext) Aggregate_expression() IAggregate_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAggregate_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAggregate_expressionContext)
}

func (s *Datetime_primaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Datetime_primaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Datetime_primaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterDatetime_primary(s)
	}
}

func (s *Datetime_primaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitDatetime_primary(s)
	}
}

func (s *Datetime_primaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitDatetime_primary(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Datetime_primary() (localctx IDatetime_primaryContext) {
	localctx = NewDatetime_primaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, JPAParserRULE_datetime_primary)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(742)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case JPAParserIDENTIFICATION_VARIABLE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(738)
			p.State_field_path_expression()
		}

	case JPAParserT__73, JPAParserT__74:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(739)
			p.Input_parameter()
		}

	case JPAParserT__62, JPAParserT__63, JPAParserT__64:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(740)
			p.Functions_returning_datetime()
		}

	case JPAParserT__21, JPAParserT__22, JPAParserT__23, JPAParserT__24, JPAParserT__25:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(741)
			p.Aggregate_expression()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IBoolean_expressionContext is an interface to support dynamic dispatch.
type IBoolean_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBoolean_expressionContext differentiates from other interfaces.
	IsBoolean_expressionContext()
}

type Boolean_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBoolean_expressionContext() *Boolean_expressionContext {
	var p = new(Boolean_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_boolean_expression
	return p
}

func (*Boolean_expressionContext) IsBoolean_expressionContext() {}

func NewBoolean_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Boolean_expressionContext {
	var p = new(Boolean_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_boolean_expression

	return p
}

func (s *Boolean_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Boolean_expressionContext) Boolean_primary() IBoolean_primaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBoolean_primaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBoolean_primaryContext)
}

func (s *Boolean_expressionContext) Subquery() ISubqueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubqueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubqueryContext)
}

func (s *Boolean_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Boolean_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Boolean_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterBoolean_expression(s)
	}
}

func (s *Boolean_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitBoolean_expression(s)
	}
}

func (s *Boolean_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitBoolean_expression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Boolean_expression() (localctx IBoolean_expressionContext) {
	localctx = NewBoolean_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, JPAParserRULE_boolean_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(749)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case JPAParserT__73, JPAParserT__74, JPAParserT__75, JPAParserT__76, JPAParserIDENTIFICATION_VARIABLE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(744)
			p.Boolean_primary()
		}

	case JPAParserT__10:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(745)
			p.Match(JPAParserT__10)
		}
		{
			p.SetState(746)
			p.Subquery()
		}
		{
			p.SetState(747)
			p.Match(JPAParserT__11)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IBoolean_primaryContext is an interface to support dynamic dispatch.
type IBoolean_primaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBoolean_primaryContext differentiates from other interfaces.
	IsBoolean_primaryContext()
}

type Boolean_primaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBoolean_primaryContext() *Boolean_primaryContext {
	var p = new(Boolean_primaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_boolean_primary
	return p
}

func (*Boolean_primaryContext) IsBoolean_primaryContext() {}

func NewBoolean_primaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Boolean_primaryContext {
	var p = new(Boolean_primaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_boolean_primary

	return p
}

func (s *Boolean_primaryContext) GetParser() antlr.Parser { return s.parser }

func (s *Boolean_primaryContext) State_field_path_expression() IState_field_path_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IState_field_path_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IState_field_path_expressionContext)
}

func (s *Boolean_primaryContext) Boolean_literal() IBoolean_literalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBoolean_literalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBoolean_literalContext)
}

func (s *Boolean_primaryContext) Input_parameter() IInput_parameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInput_parameterContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInput_parameterContext)
}

func (s *Boolean_primaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Boolean_primaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Boolean_primaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterBoolean_primary(s)
	}
}

func (s *Boolean_primaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitBoolean_primary(s)
	}
}

func (s *Boolean_primaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitBoolean_primary(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Boolean_primary() (localctx IBoolean_primaryContext) {
	localctx = NewBoolean_primaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, JPAParserRULE_boolean_primary)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(754)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case JPAParserIDENTIFICATION_VARIABLE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(751)
			p.State_field_path_expression()
		}

	case JPAParserT__75, JPAParserT__76:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(752)
			p.Boolean_literal()
		}

	case JPAParserT__73, JPAParserT__74:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(753)
			p.Input_parameter()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IEnum_expressionContext is an interface to support dynamic dispatch.
type IEnum_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnum_expressionContext differentiates from other interfaces.
	IsEnum_expressionContext()
}

type Enum_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnum_expressionContext() *Enum_expressionContext {
	var p = new(Enum_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_enum_expression
	return p
}

func (*Enum_expressionContext) IsEnum_expressionContext() {}

func NewEnum_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Enum_expressionContext {
	var p = new(Enum_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_enum_expression

	return p
}

func (s *Enum_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Enum_expressionContext) Enum_primary() IEnum_primaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnum_primaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnum_primaryContext)
}

func (s *Enum_expressionContext) Subquery() ISubqueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubqueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubqueryContext)
}

func (s *Enum_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Enum_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Enum_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterEnum_expression(s)
	}
}

func (s *Enum_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitEnum_expression(s)
	}
}

func (s *Enum_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitEnum_expression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Enum_expression() (localctx IEnum_expressionContext) {
	localctx = NewEnum_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, JPAParserRULE_enum_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(761)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case JPAParserEOF, JPAParserT__11, JPAParserT__14, JPAParserT__27, JPAParserT__29, JPAParserT__30, JPAParserT__33, JPAParserT__34, JPAParserT__47, JPAParserT__73, JPAParserT__74, JPAParserIDENTIFICATION_VARIABLE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(756)
			p.Enum_primary()
		}

	case JPAParserT__10:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(757)
			p.Match(JPAParserT__10)
		}
		{
			p.SetState(758)
			p.Subquery()
		}
		{
			p.SetState(759)
			p.Match(JPAParserT__11)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IEnum_primaryContext is an interface to support dynamic dispatch.
type IEnum_primaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnum_primaryContext differentiates from other interfaces.
	IsEnum_primaryContext()
}

type Enum_primaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnum_primaryContext() *Enum_primaryContext {
	var p = new(Enum_primaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_enum_primary
	return p
}

func (*Enum_primaryContext) IsEnum_primaryContext() {}

func NewEnum_primaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Enum_primaryContext {
	var p = new(Enum_primaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_enum_primary

	return p
}

func (s *Enum_primaryContext) GetParser() antlr.Parser { return s.parser }

func (s *Enum_primaryContext) State_field_path_expression() IState_field_path_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IState_field_path_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IState_field_path_expressionContext)
}

func (s *Enum_primaryContext) Enum_literal() IEnum_literalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnum_literalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnum_literalContext)
}

func (s *Enum_primaryContext) Input_parameter() IInput_parameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInput_parameterContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInput_parameterContext)
}

func (s *Enum_primaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Enum_primaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Enum_primaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterEnum_primary(s)
	}
}

func (s *Enum_primaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitEnum_primary(s)
	}
}

func (s *Enum_primaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitEnum_primary(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Enum_primary() (localctx IEnum_primaryContext) {
	localctx = NewEnum_primaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, JPAParserRULE_enum_primary)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(766)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case JPAParserIDENTIFICATION_VARIABLE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(763)
			p.State_field_path_expression()
		}

	case JPAParserEOF, JPAParserT__1, JPAParserT__11, JPAParserT__14, JPAParserT__26, JPAParserT__27, JPAParserT__29, JPAParserT__30, JPAParserT__33, JPAParserT__34, JPAParserT__47:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(764)
			p.Enum_literal()
		}

	case JPAParserT__73, JPAParserT__74:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(765)
			p.Input_parameter()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IEntity_expressionContext is an interface to support dynamic dispatch.
type IEntity_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEntity_expressionContext differentiates from other interfaces.
	IsEntity_expressionContext()
}

type Entity_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEntity_expressionContext() *Entity_expressionContext {
	var p = new(Entity_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_entity_expression
	return p
}

func (*Entity_expressionContext) IsEntity_expressionContext() {}

func NewEntity_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Entity_expressionContext {
	var p = new(Entity_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_entity_expression

	return p
}

func (s *Entity_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Entity_expressionContext) Single_valued_association_path_expression() ISingle_valued_association_path_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingle_valued_association_path_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingle_valued_association_path_expressionContext)
}

func (s *Entity_expressionContext) Simple_entity_expression() ISimple_entity_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_entity_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimple_entity_expressionContext)
}

func (s *Entity_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Entity_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Entity_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterEntity_expression(s)
	}
}

func (s *Entity_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitEntity_expression(s)
	}
}

func (s *Entity_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitEntity_expression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Entity_expression() (localctx IEntity_expressionContext) {
	localctx = NewEntity_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, JPAParserRULE_entity_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(770)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 93, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(768)
			p.Single_valued_association_path_expression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(769)
			p.Simple_entity_expression()
		}

	}

	return localctx
}

// ISimple_entity_expressionContext is an interface to support dynamic dispatch.
type ISimple_entity_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimple_entity_expressionContext differentiates from other interfaces.
	IsSimple_entity_expressionContext()
}

type Simple_entity_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimple_entity_expressionContext() *Simple_entity_expressionContext {
	var p = new(Simple_entity_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_simple_entity_expression
	return p
}

func (*Simple_entity_expressionContext) IsSimple_entity_expressionContext() {}

func NewSimple_entity_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Simple_entity_expressionContext {
	var p = new(Simple_entity_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_simple_entity_expression

	return p
}

func (s *Simple_entity_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Simple_entity_expressionContext) IDENTIFICATION_VARIABLE() antlr.TerminalNode {
	return s.GetToken(JPAParserIDENTIFICATION_VARIABLE, 0)
}

func (s *Simple_entity_expressionContext) Input_parameter() IInput_parameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInput_parameterContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInput_parameterContext)
}

func (s *Simple_entity_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Simple_entity_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Simple_entity_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterSimple_entity_expression(s)
	}
}

func (s *Simple_entity_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitSimple_entity_expression(s)
	}
}

func (s *Simple_entity_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitSimple_entity_expression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Simple_entity_expression() (localctx ISimple_entity_expressionContext) {
	localctx = NewSimple_entity_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, JPAParserRULE_simple_entity_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(774)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case JPAParserIDENTIFICATION_VARIABLE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(772)
			p.Match(JPAParserIDENTIFICATION_VARIABLE)
		}

	case JPAParserT__73, JPAParserT__74:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(773)
			p.Input_parameter()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFunctions_returning_numericsContext is an interface to support dynamic dispatch.
type IFunctions_returning_numericsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctions_returning_numericsContext differentiates from other interfaces.
	IsFunctions_returning_numericsContext()
}

type Functions_returning_numericsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctions_returning_numericsContext() *Functions_returning_numericsContext {
	var p = new(Functions_returning_numericsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_functions_returning_numerics
	return p
}

func (*Functions_returning_numericsContext) IsFunctions_returning_numericsContext() {}

func NewFunctions_returning_numericsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Functions_returning_numericsContext {
	var p = new(Functions_returning_numericsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_functions_returning_numerics

	return p
}

func (s *Functions_returning_numericsContext) GetParser() antlr.Parser { return s.parser }

func (s *Functions_returning_numericsContext) AllString_primary() []IString_primaryContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IString_primaryContext)(nil)).Elem())
	var tst = make([]IString_primaryContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IString_primaryContext)
		}
	}

	return tst
}

func (s *Functions_returning_numericsContext) String_primary(i int) IString_primaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IString_primaryContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IString_primaryContext)
}

func (s *Functions_returning_numericsContext) AllSimple_arithmetic_expression() []ISimple_arithmetic_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISimple_arithmetic_expressionContext)(nil)).Elem())
	var tst = make([]ISimple_arithmetic_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISimple_arithmetic_expressionContext)
		}
	}

	return tst
}

func (s *Functions_returning_numericsContext) Simple_arithmetic_expression(i int) ISimple_arithmetic_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_arithmetic_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISimple_arithmetic_expressionContext)
}

func (s *Functions_returning_numericsContext) Collection_valued_path_expression() ICollection_valued_path_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollection_valued_path_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollection_valued_path_expressionContext)
}

func (s *Functions_returning_numericsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Functions_returning_numericsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Functions_returning_numericsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterFunctions_returning_numerics(s)
	}
}

func (s *Functions_returning_numericsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitFunctions_returning_numerics(s)
	}
}

func (s *Functions_returning_numericsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitFunctions_returning_numerics(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Functions_returning_numerics() (localctx IFunctions_returning_numericsContext) {
	localctx = NewFunctions_returning_numericsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, JPAParserRULE_functions_returning_numerics)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(814)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case JPAParserT__56:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(776)
			p.Match(JPAParserT__56)
		}
		{
			p.SetState(777)
			p.Match(JPAParserT__10)
		}
		{
			p.SetState(778)
			p.String_primary()
		}
		{
			p.SetState(779)
			p.Match(JPAParserT__11)
		}

	case JPAParserT__57:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(781)
			p.Match(JPAParserT__57)
		}
		{
			p.SetState(782)
			p.Match(JPAParserT__10)
		}
		{
			p.SetState(783)
			p.String_primary()
		}
		{
			p.SetState(784)
			p.Match(JPAParserT__1)
		}
		{
			p.SetState(785)
			p.String_primary()
		}
		p.SetState(788)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == JPAParserT__1 {
			{
				p.SetState(786)
				p.Match(JPAParserT__1)
			}
			{
				p.SetState(787)
				p.Simple_arithmetic_expression()
			}

		}
		{
			p.SetState(790)
			p.Match(JPAParserT__11)
		}

	case JPAParserT__58:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(792)
			p.Match(JPAParserT__58)
		}
		{
			p.SetState(793)
			p.Match(JPAParserT__10)
		}
		{
			p.SetState(794)
			p.Simple_arithmetic_expression()
		}
		{
			p.SetState(795)
			p.Match(JPAParserT__11)
		}

	case JPAParserT__59:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(797)
			p.Match(JPAParserT__59)
		}
		{
			p.SetState(798)
			p.Match(JPAParserT__10)
		}
		{
			p.SetState(799)
			p.Simple_arithmetic_expression()
		}
		{
			p.SetState(800)
			p.Match(JPAParserT__11)
		}

	case JPAParserT__60:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(802)
			p.Match(JPAParserT__60)
		}
		{
			p.SetState(803)
			p.Match(JPAParserT__10)
		}
		{
			p.SetState(804)
			p.Simple_arithmetic_expression()
		}
		{
			p.SetState(805)
			p.Match(JPAParserT__1)
		}
		{
			p.SetState(806)
			p.Simple_arithmetic_expression()
		}
		{
			p.SetState(807)
			p.Match(JPAParserT__11)
		}

	case JPAParserT__61:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(809)
			p.Match(JPAParserT__61)
		}
		{
			p.SetState(810)
			p.Match(JPAParserT__10)
		}
		{
			p.SetState(811)
			p.Collection_valued_path_expression()
		}
		{
			p.SetState(812)
			p.Match(JPAParserT__11)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFunctions_returning_datetimeContext is an interface to support dynamic dispatch.
type IFunctions_returning_datetimeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctions_returning_datetimeContext differentiates from other interfaces.
	IsFunctions_returning_datetimeContext()
}

type Functions_returning_datetimeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctions_returning_datetimeContext() *Functions_returning_datetimeContext {
	var p = new(Functions_returning_datetimeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_functions_returning_datetime
	return p
}

func (*Functions_returning_datetimeContext) IsFunctions_returning_datetimeContext() {}

func NewFunctions_returning_datetimeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Functions_returning_datetimeContext {
	var p = new(Functions_returning_datetimeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_functions_returning_datetime

	return p
}

func (s *Functions_returning_datetimeContext) GetParser() antlr.Parser { return s.parser }
func (s *Functions_returning_datetimeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Functions_returning_datetimeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Functions_returning_datetimeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterFunctions_returning_datetime(s)
	}
}

func (s *Functions_returning_datetimeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitFunctions_returning_datetime(s)
	}
}

func (s *Functions_returning_datetimeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitFunctions_returning_datetime(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Functions_returning_datetime() (localctx IFunctions_returning_datetimeContext) {
	localctx = NewFunctions_returning_datetimeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, JPAParserRULE_functions_returning_datetime)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(816)
	_la = p.GetTokenStream().LA(1)

	if !(((_la-63)&-(0x1f+1)) == 0 && ((1<<uint((_la-63)))&((1<<(JPAParserT__62-63))|(1<<(JPAParserT__63-63))|(1<<(JPAParserT__64-63)))) != 0) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// IFunctions_returning_stringsContext is an interface to support dynamic dispatch.
type IFunctions_returning_stringsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctions_returning_stringsContext differentiates from other interfaces.
	IsFunctions_returning_stringsContext()
}

type Functions_returning_stringsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctions_returning_stringsContext() *Functions_returning_stringsContext {
	var p = new(Functions_returning_stringsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_functions_returning_strings
	return p
}

func (*Functions_returning_stringsContext) IsFunctions_returning_stringsContext() {}

func NewFunctions_returning_stringsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Functions_returning_stringsContext {
	var p = new(Functions_returning_stringsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_functions_returning_strings

	return p
}

func (s *Functions_returning_stringsContext) GetParser() antlr.Parser { return s.parser }

func (s *Functions_returning_stringsContext) AllString_primary() []IString_primaryContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IString_primaryContext)(nil)).Elem())
	var tst = make([]IString_primaryContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IString_primaryContext)
		}
	}

	return tst
}

func (s *Functions_returning_stringsContext) String_primary(i int) IString_primaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IString_primaryContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IString_primaryContext)
}

func (s *Functions_returning_stringsContext) AllSimple_arithmetic_expression() []ISimple_arithmetic_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISimple_arithmetic_expressionContext)(nil)).Elem())
	var tst = make([]ISimple_arithmetic_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISimple_arithmetic_expressionContext)
		}
	}

	return tst
}

func (s *Functions_returning_stringsContext) Simple_arithmetic_expression(i int) ISimple_arithmetic_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_arithmetic_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISimple_arithmetic_expressionContext)
}

func (s *Functions_returning_stringsContext) Trim_specification() ITrim_specificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITrim_specificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITrim_specificationContext)
}

func (s *Functions_returning_stringsContext) TRIM_CHARACTER() antlr.TerminalNode {
	return s.GetToken(JPAParserTRIM_CHARACTER, 0)
}

func (s *Functions_returning_stringsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Functions_returning_stringsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Functions_returning_stringsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterFunctions_returning_strings(s)
	}
}

func (s *Functions_returning_stringsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitFunctions_returning_strings(s)
	}
}

func (s *Functions_returning_stringsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitFunctions_returning_strings(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Functions_returning_strings() (localctx IFunctions_returning_stringsContext) {
	localctx = NewFunctions_returning_stringsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, JPAParserRULE_functions_returning_strings)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(858)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case JPAParserT__65:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(818)
			p.Match(JPAParserT__65)
		}
		{
			p.SetState(819)
			p.Match(JPAParserT__10)
		}
		{
			p.SetState(820)
			p.String_primary()
		}
		{
			p.SetState(821)
			p.Match(JPAParserT__1)
		}
		{
			p.SetState(822)
			p.String_primary()
		}
		{
			p.SetState(823)
			p.Match(JPAParserT__11)
		}

	case JPAParserT__66:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(825)
			p.Match(JPAParserT__66)
		}
		{
			p.SetState(826)
			p.Match(JPAParserT__10)
		}
		{
			p.SetState(827)
			p.String_primary()
		}
		{
			p.SetState(828)
			p.Match(JPAParserT__1)
		}
		{
			p.SetState(829)
			p.Simple_arithmetic_expression()
		}
		{
			p.SetState(830)
			p.Match(JPAParserT__1)
		}
		{
			p.SetState(831)
			p.Simple_arithmetic_expression()
		}
		{
			p.SetState(832)
			p.Match(JPAParserT__11)
		}

	case JPAParserT__67:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(834)
			p.Match(JPAParserT__67)
		}
		{
			p.SetState(835)
			p.Match(JPAParserT__10)
		}
		p.SetState(843)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == JPAParserT__0 || (((_la-71)&-(0x1f+1)) == 0 && ((1<<uint((_la-71)))&((1<<(JPAParserT__70-71))|(1<<(JPAParserT__71-71))|(1<<(JPAParserT__72-71))|(1<<(JPAParserTRIM_CHARACTER-71)))) != 0) {
			p.SetState(837)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if ((_la-71)&-(0x1f+1)) == 0 && ((1<<uint((_la-71)))&((1<<(JPAParserT__70-71))|(1<<(JPAParserT__71-71))|(1<<(JPAParserT__72-71)))) != 0 {
				{
					p.SetState(836)
					p.Trim_specification()
				}

			}
			p.SetState(840)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == JPAParserTRIM_CHARACTER {
				{
					p.SetState(839)
					p.Match(JPAParserTRIM_CHARACTER)
				}

			}
			{
				p.SetState(842)
				p.Match(JPAParserT__0)
			}

		}
		{
			p.SetState(845)
			p.String_primary()
		}
		{
			p.SetState(846)
			p.Match(JPAParserT__11)
		}

	case JPAParserT__68:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(848)
			p.Match(JPAParserT__68)
		}
		{
			p.SetState(849)
			p.Match(JPAParserT__10)
		}
		{
			p.SetState(850)
			p.String_primary()
		}
		{
			p.SetState(851)
			p.Match(JPAParserT__11)
		}

	case JPAParserT__69:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(853)
			p.Match(JPAParserT__69)
		}
		{
			p.SetState(854)
			p.Match(JPAParserT__10)
		}
		{
			p.SetState(855)
			p.String_primary()
		}
		{
			p.SetState(856)
			p.Match(JPAParserT__11)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITrim_specificationContext is an interface to support dynamic dispatch.
type ITrim_specificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTrim_specificationContext differentiates from other interfaces.
	IsTrim_specificationContext()
}

type Trim_specificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTrim_specificationContext() *Trim_specificationContext {
	var p = new(Trim_specificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_trim_specification
	return p
}

func (*Trim_specificationContext) IsTrim_specificationContext() {}

func NewTrim_specificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Trim_specificationContext {
	var p = new(Trim_specificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_trim_specification

	return p
}

func (s *Trim_specificationContext) GetParser() antlr.Parser { return s.parser }
func (s *Trim_specificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Trim_specificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Trim_specificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterTrim_specification(s)
	}
}

func (s *Trim_specificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitTrim_specification(s)
	}
}

func (s *Trim_specificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitTrim_specification(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Trim_specification() (localctx ITrim_specificationContext) {
	localctx = NewTrim_specificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, JPAParserRULE_trim_specification)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(860)
	_la = p.GetTokenStream().LA(1)

	if !(((_la-71)&-(0x1f+1)) == 0 && ((1<<uint((_la-71)))&((1<<(JPAParserT__70-71))|(1<<(JPAParserT__71-71))|(1<<(JPAParserT__72-71)))) != 0) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// INumeric_literalContext is an interface to support dynamic dispatch.
type INumeric_literalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNumeric_literalContext differentiates from other interfaces.
	IsNumeric_literalContext()
}

type Numeric_literalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumeric_literalContext() *Numeric_literalContext {
	var p = new(Numeric_literalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_numeric_literal
	return p
}

func (*Numeric_literalContext) IsNumeric_literalContext() {}

func NewNumeric_literalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Numeric_literalContext {
	var p = new(Numeric_literalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_numeric_literal

	return p
}

func (s *Numeric_literalContext) GetParser() antlr.Parser { return s.parser }
func (s *Numeric_literalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Numeric_literalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Numeric_literalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterNumeric_literal(s)
	}
}

func (s *Numeric_literalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitNumeric_literal(s)
	}
}

func (s *Numeric_literalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitNumeric_literal(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Numeric_literal() (localctx INumeric_literalContext) {
	localctx = NewNumeric_literalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, JPAParserRULE_numeric_literal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)

	return localctx
}

// IPattern_valueContext is an interface to support dynamic dispatch.
type IPattern_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPattern_valueContext differentiates from other interfaces.
	IsPattern_valueContext()
}

type Pattern_valueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPattern_valueContext() *Pattern_valueContext {
	var p = new(Pattern_valueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_pattern_value
	return p
}

func (*Pattern_valueContext) IsPattern_valueContext() {}

func NewPattern_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Pattern_valueContext {
	var p = new(Pattern_valueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_pattern_value

	return p
}

func (s *Pattern_valueContext) GetParser() antlr.Parser { return s.parser }
func (s *Pattern_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Pattern_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Pattern_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterPattern_value(s)
	}
}

func (s *Pattern_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitPattern_value(s)
	}
}

func (s *Pattern_valueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitPattern_value(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Pattern_value() (localctx IPattern_valueContext) {
	localctx = NewPattern_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, JPAParserRULE_pattern_value)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)

	return localctx
}

// IInput_parameterContext is an interface to support dynamic dispatch.
type IInput_parameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInput_parameterContext differentiates from other interfaces.
	IsInput_parameterContext()
}

type Input_parameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInput_parameterContext() *Input_parameterContext {
	var p = new(Input_parameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_input_parameter
	return p
}

func (*Input_parameterContext) IsInput_parameterContext() {}

func NewInput_parameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Input_parameterContext {
	var p = new(Input_parameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_input_parameter

	return p
}

func (s *Input_parameterContext) GetParser() antlr.Parser { return s.parser }

func (s *Input_parameterContext) INT_NUMERAL() antlr.TerminalNode {
	return s.GetToken(JPAParserINT_NUMERAL, 0)
}

func (s *Input_parameterContext) IDENTIFICATION_VARIABLE() antlr.TerminalNode {
	return s.GetToken(JPAParserIDENTIFICATION_VARIABLE, 0)
}

func (s *Input_parameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Input_parameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Input_parameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterInput_parameter(s)
	}
}

func (s *Input_parameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitInput_parameter(s)
	}
}

func (s *Input_parameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitInput_parameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Input_parameter() (localctx IInput_parameterContext) {
	localctx = NewInput_parameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, JPAParserRULE_input_parameter)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(870)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case JPAParserT__73:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(866)
			p.Match(JPAParserT__73)
		}
		{
			p.SetState(867)
			p.Match(JPAParserINT_NUMERAL)
		}

	case JPAParserT__74:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(868)
			p.Match(JPAParserT__74)
		}
		{
			p.SetState(869)
			p.Match(JPAParserIDENTIFICATION_VARIABLE)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_literal
	return p
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }
func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterLiteral(s)
	}
}

func (s *LiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitLiteral(s)
	}
}

func (s *LiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Literal() (localctx ILiteralContext) {
	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, JPAParserRULE_literal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)

	return localctx
}

// IConstructor_nameContext is an interface to support dynamic dispatch.
type IConstructor_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstructor_nameContext differentiates from other interfaces.
	IsConstructor_nameContext()
}

type Constructor_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstructor_nameContext() *Constructor_nameContext {
	var p = new(Constructor_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_constructor_name
	return p
}

func (*Constructor_nameContext) IsConstructor_nameContext() {}

func NewConstructor_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constructor_nameContext {
	var p = new(Constructor_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_constructor_name

	return p
}

func (s *Constructor_nameContext) GetParser() antlr.Parser { return s.parser }
func (s *Constructor_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constructor_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constructor_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterConstructor_name(s)
	}
}

func (s *Constructor_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitConstructor_name(s)
	}
}

func (s *Constructor_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitConstructor_name(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Constructor_name() (localctx IConstructor_nameContext) {
	localctx = NewConstructor_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, JPAParserRULE_constructor_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)

	return localctx
}

// IEnum_literalContext is an interface to support dynamic dispatch.
type IEnum_literalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnum_literalContext differentiates from other interfaces.
	IsEnum_literalContext()
}

type Enum_literalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnum_literalContext() *Enum_literalContext {
	var p = new(Enum_literalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_enum_literal
	return p
}

func (*Enum_literalContext) IsEnum_literalContext() {}

func NewEnum_literalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Enum_literalContext {
	var p = new(Enum_literalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_enum_literal

	return p
}

func (s *Enum_literalContext) GetParser() antlr.Parser { return s.parser }
func (s *Enum_literalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Enum_literalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Enum_literalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterEnum_literal(s)
	}
}

func (s *Enum_literalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitEnum_literal(s)
	}
}

func (s *Enum_literalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitEnum_literal(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Enum_literal() (localctx IEnum_literalContext) {
	localctx = NewEnum_literalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, JPAParserRULE_enum_literal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)

	return localctx
}

// IBoolean_literalContext is an interface to support dynamic dispatch.
type IBoolean_literalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBoolean_literalContext differentiates from other interfaces.
	IsBoolean_literalContext()
}

type Boolean_literalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBoolean_literalContext() *Boolean_literalContext {
	var p = new(Boolean_literalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_boolean_literal
	return p
}

func (*Boolean_literalContext) IsBoolean_literalContext() {}

func NewBoolean_literalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Boolean_literalContext {
	var p = new(Boolean_literalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_boolean_literal

	return p
}

func (s *Boolean_literalContext) GetParser() antlr.Parser { return s.parser }
func (s *Boolean_literalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Boolean_literalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Boolean_literalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterBoolean_literal(s)
	}
}

func (s *Boolean_literalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitBoolean_literal(s)
	}
}

func (s *Boolean_literalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitBoolean_literal(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Boolean_literal() (localctx IBoolean_literalContext) {
	localctx = NewBoolean_literalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, JPAParserRULE_boolean_literal)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(878)
	_la = p.GetTokenStream().LA(1)

	if !(_la == JPAParserT__75 || _la == JPAParserT__76) {
		p.GetErrorHandler().RecoverInline(p)
	} else {
		p.GetErrorHandler().ReportMatch(p)
		p.Consume()
	}

	return localctx
}

// ISimple_state_fieldContext is an interface to support dynamic dispatch.
type ISimple_state_fieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimple_state_fieldContext differentiates from other interfaces.
	IsSimple_state_fieldContext()
}

type Simple_state_fieldContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimple_state_fieldContext() *Simple_state_fieldContext {
	var p = new(Simple_state_fieldContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_simple_state_field
	return p
}

func (*Simple_state_fieldContext) IsSimple_state_fieldContext() {}

func NewSimple_state_fieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Simple_state_fieldContext {
	var p = new(Simple_state_fieldContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_simple_state_field

	return p
}

func (s *Simple_state_fieldContext) GetParser() antlr.Parser { return s.parser }
func (s *Simple_state_fieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Simple_state_fieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Simple_state_fieldContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterSimple_state_field(s)
	}
}

func (s *Simple_state_fieldContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitSimple_state_field(s)
	}
}

func (s *Simple_state_fieldContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitSimple_state_field(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Simple_state_field() (localctx ISimple_state_fieldContext) {
	localctx = NewSimple_state_fieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, JPAParserRULE_simple_state_field)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)

	return localctx
}

// IEmbedded_class_state_fieldContext is an interface to support dynamic dispatch.
type IEmbedded_class_state_fieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEmbedded_class_state_fieldContext differentiates from other interfaces.
	IsEmbedded_class_state_fieldContext()
}

type Embedded_class_state_fieldContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEmbedded_class_state_fieldContext() *Embedded_class_state_fieldContext {
	var p = new(Embedded_class_state_fieldContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_embedded_class_state_field
	return p
}

func (*Embedded_class_state_fieldContext) IsEmbedded_class_state_fieldContext() {}

func NewEmbedded_class_state_fieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Embedded_class_state_fieldContext {
	var p = new(Embedded_class_state_fieldContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_embedded_class_state_field

	return p
}

func (s *Embedded_class_state_fieldContext) GetParser() antlr.Parser { return s.parser }
func (s *Embedded_class_state_fieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Embedded_class_state_fieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Embedded_class_state_fieldContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterEmbedded_class_state_field(s)
	}
}

func (s *Embedded_class_state_fieldContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitEmbedded_class_state_field(s)
	}
}

func (s *Embedded_class_state_fieldContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitEmbedded_class_state_field(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Embedded_class_state_field() (localctx IEmbedded_class_state_fieldContext) {
	localctx = NewEmbedded_class_state_fieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, JPAParserRULE_embedded_class_state_field)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)

	return localctx
}

// ISingle_valued_association_fieldContext is an interface to support dynamic dispatch.
type ISingle_valued_association_fieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSingle_valued_association_fieldContext differentiates from other interfaces.
	IsSingle_valued_association_fieldContext()
}

type Single_valued_association_fieldContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingle_valued_association_fieldContext() *Single_valued_association_fieldContext {
	var p = new(Single_valued_association_fieldContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_single_valued_association_field
	return p
}

func (*Single_valued_association_fieldContext) IsSingle_valued_association_fieldContext() {}

func NewSingle_valued_association_fieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Single_valued_association_fieldContext {
	var p = new(Single_valued_association_fieldContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_single_valued_association_field

	return p
}

func (s *Single_valued_association_fieldContext) GetParser() antlr.Parser { return s.parser }
func (s *Single_valued_association_fieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Single_valued_association_fieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Single_valued_association_fieldContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterSingle_valued_association_field(s)
	}
}

func (s *Single_valued_association_fieldContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitSingle_valued_association_field(s)
	}
}

func (s *Single_valued_association_fieldContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitSingle_valued_association_field(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Single_valued_association_field() (localctx ISingle_valued_association_fieldContext) {
	localctx = NewSingle_valued_association_fieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, JPAParserRULE_single_valued_association_field)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)

	return localctx
}

// ICollection_valued_association_fieldContext is an interface to support dynamic dispatch.
type ICollection_valued_association_fieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollection_valued_association_fieldContext differentiates from other interfaces.
	IsCollection_valued_association_fieldContext()
}

type Collection_valued_association_fieldContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollection_valued_association_fieldContext() *Collection_valued_association_fieldContext {
	var p = new(Collection_valued_association_fieldContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_collection_valued_association_field
	return p
}

func (*Collection_valued_association_fieldContext) IsCollection_valued_association_fieldContext() {}

func NewCollection_valued_association_fieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Collection_valued_association_fieldContext {
	var p = new(Collection_valued_association_fieldContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_collection_valued_association_field

	return p
}

func (s *Collection_valued_association_fieldContext) GetParser() antlr.Parser { return s.parser }
func (s *Collection_valued_association_fieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Collection_valued_association_fieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Collection_valued_association_fieldContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterCollection_valued_association_field(s)
	}
}

func (s *Collection_valued_association_fieldContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitCollection_valued_association_field(s)
	}
}

func (s *Collection_valued_association_fieldContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitCollection_valued_association_field(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Collection_valued_association_field() (localctx ICollection_valued_association_fieldContext) {
	localctx = NewCollection_valued_association_fieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, JPAParserRULE_collection_valued_association_field)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)

	return localctx
}

// IAbstract_schema_nameContext is an interface to support dynamic dispatch.
type IAbstract_schema_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAbstract_schema_nameContext differentiates from other interfaces.
	IsAbstract_schema_nameContext()
}

type Abstract_schema_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAbstract_schema_nameContext() *Abstract_schema_nameContext {
	var p = new(Abstract_schema_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = JPAParserRULE_abstract_schema_name
	return p
}

func (*Abstract_schema_nameContext) IsAbstract_schema_nameContext() {}

func NewAbstract_schema_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Abstract_schema_nameContext {
	var p = new(Abstract_schema_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = JPAParserRULE_abstract_schema_name

	return p
}

func (s *Abstract_schema_nameContext) GetParser() antlr.Parser { return s.parser }
func (s *Abstract_schema_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Abstract_schema_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Abstract_schema_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.EnterAbstract_schema_name(s)
	}
}

func (s *Abstract_schema_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JPAListener); ok {
		listenerT.ExitAbstract_schema_name(s)
	}
}

func (s *Abstract_schema_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case JPAVisitor:
		return t.VisitAbstract_schema_name(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *JPAParser) Abstract_schema_name() (localctx IAbstract_schema_nameContext) {
	localctx = NewAbstract_schema_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, JPAParserRULE_abstract_schema_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)

	return localctx
}
